<!doctype html><html lang=id class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=en href=https://kubernetes.io/docs/><link rel=alternate hreflang=zh-cn href=https://kubernetes.io/zh-cn/docs/><link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/><link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/><link rel=alternate hreflang=it href=https://kubernetes.io/it/docs/><link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/><link rel=alternate hreflang=pt-br href=https://kubernetes.io/pt-br/docs/><link rel=alternate hreflang=hi href=https://kubernetes.io/hi/docs/><link rel=alternate hreflang=vi href=https://kubernetes.io/vi/docs/><link rel=alternate hreflang=ru href=https://kubernetes.io/ru/docs/><link rel=alternate hreflang=pl href=https://kubernetes.io/pl/docs/><link rel=alternate hreflang=uk href=https://kubernetes.io/uk/docs/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/id/docs/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>Dokumentasi | Kubernetes</title><meta property="og:title" content="Dokumentasi"><meta property="og:description" content="Orkestrasi Kontainer dengan Skala Produksi"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/id/docs/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="Dokumentasi"><meta itemprop=description content="Orkestrasi Kontainer dengan Skala Produksi"><meta name=twitter:card content="summary"><meta name=twitter:title content="Dokumentasi"><meta name=twitter:description content="Orkestrasi Kontainer dengan Skala Produksi"><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content><meta property="og:description" content><meta name=twitter:description content><meta property="og:url" content="https://kubernetes.io/id/docs/"><meta property="og:title" content="Dokumentasi"><meta name=twitter:title content="Dokumentasi"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/id/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/id/docs/>Dokumentasi</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/id/community/>Komunitas</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/id/case-studies/>Studi kasus</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Versi</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/id/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/id/docs/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/id/docs/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/id/docs/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/id/docs/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/id/docs/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Bahasa Indonesia</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/docs/>English</a>
<a class=dropdown-item href=/zh-cn/docs/>中文 (Chinese)</a>
<a class=dropdown-item href=/ko/docs/>한국어 (Korean)</a>
<a class=dropdown-item href=/ja/docs/>日本語 (Japanese)</a>
<a class=dropdown-item href=/fr/docs/>Français (French)</a>
<a class=dropdown-item href=/it/docs/>Italiano (Italian)</a>
<a class=dropdown-item href=/de/docs/>Deutsch (German)</a>
<a class=dropdown-item href=/es/docs/>Español (Spanish)</a>
<a class=dropdown-item href=/pt-br/docs/>Português (Portuguese)</a>
<a class=dropdown-item href=/hi/docs/>हिन्दी (Hindi)</a>
<a class=dropdown-item href=/vi/docs/>Tiếng Việt (Vietnamese)</a>
<a class=dropdown-item href=/ru/docs/>Русский (Russian)</a>
<a class=dropdown-item href=/pl/docs/>Polski (Polish)</a>
<a class=dropdown-item href=/uk/docs/>Українська (Ukrainian)</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>This is the multi-page printable view of this section.
<a href=# onclick="return print(),!1">Click here to print</a>.</p><p><a href=/id/docs/>Return to the regular view of this page</a>.</p></div><h1 class=title>Dokumentasi</h1><ul><li>1: <a href=#pg-e735cee7e913aa88bc0aa10594d12966>Dokumentasi Kubernetes</a></li><ul><li>1.1: <a href=#pg-92dfff0ca612d0bff40171aa9df6c4ae>Versi Dokumentasi yang Tersedia</a></li></ul><li>2: <a href=#pg-66b565805ca1061be35ff2c0165f13c1>Persiapan</a></li><ul><li>2.1: <a href=#pg-0b597086a9d1382f86abadcfeab657d6>Lingkungan Pembelajaran</a></li><ul></ul><li>2.2: <a href=#pg-4e14853fdaa3bd273f31a60112b9b5ac>Lingkungan Produksi</a></li><ul><li>2.2.1: <a href=#pg-a77d3feb6e6d9978f32fa14622642e9a>Runtime Container</a></li><li>2.2.2: <a href=#pg-00e1646f68aeb89f9722cf6f6cfcad94>Menginstal Kubernetes dengan perkakas penyebaran</a></li><ul><li>2.2.2.1: <a href=#pg-a16f59f325a17cdeed324d5c889f7f73>Menyiapkan klaster dengan kubeadm</a></li><ul><li>2.2.2.1.1: <a href=#pg-29e59491dd6118b23072dfe9ebb93323>Menginstal kubeadm</a></li><li>2.2.2.1.2: <a href=#pg-134ed1f6142a98e6ac681a1ba4920e53>Membuat sebuah klaster dengan control-plane tunggal menggunakan kubeadm</a></li><li>2.2.2.1.3: <a href=#pg-3941d5c3409342219bf7e03128b8ecb6>Membangun Klaster dengan Ketersediaan Tinggi menggunakan kubeadm</a></li></ul></ul></ul><li>2.3: <a href=#pg-84b6491601d6a2b3da4cd5a105c866ba>Praktek-praktek Terbaik</a></li><ul><li>2.3.1: <a href=#pg-970615c97499e3651fd3a98e0387cefc>Menjalankan klaster dalam beberapa zona</a></li></ul></ul><li>3: <a href=#pg-dd948255948d6b59b32c471abcb62997>Konsep</a></li><ul><li>3.1: <a href=#pg-0554ac387412eaf4e6e89b2f847dacde>Ikhtisar</a></li><ul><li>3.1.1: <a href=#pg-45bdca6129cf540121623e903c18ba46>Apa itu Kubernetes?</a></li><li>3.1.2: <a href=#pg-13b0f1dbe89228e3d76d2ac231e245f1>Komponen-Komponen Kubernetes</a></li><li>3.1.3: <a href=#pg-0c745f42e623d2b70a53bc0e6db73d95>API Kubernetes</a></li><li>3.1.4: <a href=#pg-110f33530cf761140cb1dab536baef04>Menggunakan Objek-Objek Kubernetes</a></li><ul><li>3.1.4.1: <a href=#pg-9f5adfa77f48c50d5cc81155a3cecb98>Memahami Konsep Objek-Objek yang ada pada Kubernetes</a></li><li>3.1.4.2: <a href=#pg-6751db8ff5409476de8225d17d6c42dd>Pengaturan Objek Kubernetes</a></li><li>3.1.4.3: <a href=#pg-f37749a83c2916b63279ea60f3cfe53e>Nama</a></li><li>3.1.4.4: <a href=#pg-1127165f472b7181b9c1d5a0b187d620>Namespace</a></li><li>3.1.4.5: <a href=#pg-f1dec4557fb8ffbac9f11390aaaf9fa4>Label dan Selektor</a></li><li>3.1.4.6: <a href=#pg-93cd7a1d4e1623e2bf01afc49a5af69c>Anotasi</a></li><li>3.1.4.7: <a href=#pg-046c03090d47bc4b89b818dc645c3865>Selektor Field</a></li><li>3.1.4.8: <a href=#pg-5dd62c6a4a481b4cf1ac50f6799eb581>Label yang Disarankan</a></li></ul></ul><li>3.2: <a href=#pg-2bf36ccd6b3dbeafecf87c39761b07c7>Arsitektur Kubernetes</a></li><ul><li>3.2.1: <a href=#pg-9ef2890698e773b6c0d24fd2c20146f5>Node</a></li><li>3.2.2: <a href=#pg-c0251def6da29b30afebfb04549f1703>Komunikasi antara Control Plane dan Node</a></li><li>3.2.3: <a href=#pg-ca8819042a505291540e831283da66df>Controller</a></li><li>3.2.4: <a href=#pg-bc804b02614d67025b4c788f1ca87fbc>Konsep-konsep di balik Controller Manager</a></li></ul><li>3.3: <a href=#pg-a5f7383c83ab9eb9cd0e3c4c020b3ae6>Kontainer</a></li><ul><li>3.3.1: <a href=#pg-8fda96dc403731ceba5e0ddd0ab3ad15>Ikhtisar Kontainer</a></li><li>3.3.2: <a href=#pg-16042b4652ad19e565c7263824029a43>Image</a></li><li>3.3.3: <a href=#pg-643212488f778acf04bebed65ba34441>Kontainer Environment</a></li><li>3.3.4: <a href=#pg-a858027489648786a3b16264e451272b>Runtime Class</a></li><li>3.3.5: <a href=#pg-e6941d969d81540208a3e78bc56f43bc>Lifecyle Hook pada Kontainer</a></li></ul><li>3.4: <a href=#pg-d52aadda80edd9f8c514cfe2321363c2>Workloads</a></li><ul><li>3.4.1: <a href=#pg-4d68b0ccf9c683e6368ffdcc40c838d4>Pods</a></li><ul><li>3.4.1.1: <a href=#pg-37afa6c66c74400d1579f10faf55e5b6>Pengenalan Pod</a></li><li>3.4.1.2: <a href=#pg-99cce294fe789317ee684a6e1f07f20f>Pod</a></li><li>3.4.1.3: <a href=#pg-c3c2b9cf30915ec9d46c147201da3332>Siklus Hidup Pod</a></li><li>3.4.1.4: <a href=#pg-1ccbd4eeded6ab138d98b59175bd557e>Init Container</a></li><li>3.4.1.5: <a href=#pg-c8d62295ca703fdcef1aaf89fb4c916a>Batasan Persebaran Topologi Pod</a></li><li>3.4.1.6: <a href=#pg-4e9b9cbc9776b12e7335c53da377c9c8>Pod Preset</a></li><li>3.4.1.7: <a href=#pg-4aaf43c715cd764bc8ed4436f3537e68>Disrupsi</a></li><li>3.4.1.8: <a href=#pg-53a1005011e1bda2ce81819aad7c8b32>Kontainer Sementara (Ephemeral)</a></li></ul><li>3.4.2: <a href=#pg-89637410cacae45a36ab1cc278c482eb>Controllers</a></li><ul><li>3.4.2.1: <a href=#pg-d459b930218774655fa7fd1620625539>ReplicaSet</a></li><li>3.4.2.2: <a href=#pg-27f1331d515d95f76aa1156088b4ad91>ReplicationController</a></li><li>3.4.2.3: <a href=#pg-a2dc0393e0c4079e1c504b6429844e86>Deployment</a></li><li>3.4.2.4: <a href=#pg-6d72299952c37ca8cc61b416e5bdbcd4>StatefulSet</a></li><li>3.4.2.5: <a href=#pg-41600eb8b6631c88848156f381e9d588>DaemonSet</a></li><li>3.4.2.6: <a href=#pg-9add0d2120634b63073ad08dc8683bd6>Garbage Collection</a></li><li>3.4.2.7: <a href=#pg-4de50a37ebb6f2340484192126cb7a04>Pengendali TTL untuk Sumber Daya yang Telah Selesai Digunakan</a></li><li>3.4.2.8: <a href=#pg-cc7cc3c4907039d9f863162e20bfbbef>Jobs</a></li><li>3.4.2.9: <a href=#pg-2e4cec01c525b45eccd6010e21cc76d9>CronJob</a></li></ul></ul><li>3.5: <a href=#pg-0a0a7eca3e302a3c08f8c85e15d337fd>Services, Load Balancing, dan Jaringan</a></li><ul><li>3.5.1: <a href=#pg-5701136fd2ce258047b6ddc389112352>Service</a></li><li>3.5.2: <a href=#pg-3a38878244d862dfdb8d7adb32f77584>Topologi Service (Service Topology)</a></li><li>3.5.3: <a href=#pg-f51db1097575de8072afe1f5b156a70c>EndpointSlice</a></li><li>3.5.4: <a href=#pg-91cb8a4438b003df11bc1c426a81b756>DNS untuk Service dan Pod</a></li><li>3.5.5: <a href=#pg-f804ac0532fcade3966ea2e3769ca031>Menghubungkan aplikasi dengan Service</a></li><li>3.5.6: <a href=#pg-199bcc92443dbc9bed44819467d7eb75>Ingress</a></li><li>3.5.7: <a href=#pg-5a8edeb1f2dc8e38cd6d561bb08b0d78>Kontroler Ingress</a></li><li>3.5.8: <a href=#pg-ded1daafdcd293023ee333728007ca61>NetworkPolicy</a></li><li>3.5.9: <a href=#pg-509638b5ca0e420fa426f14f34e2d3b1>Menambahkan Entry pada /etc/hosts Pod dengan HostAliases</a></li><li>3.5.10: <a href=#pg-21f8d19c60c33914baab66224c3d46a7>Dual-stack IPv4/IPv6</a></li></ul><li>3.6: <a href=#pg-f018f568c6723865753f150c3c59bdda>Storage</a></li><ul><li>3.6.1: <a href=#pg-27795584640a03bd2024f1fe3b3ab754>Volume</a></li><li>3.6.2: <a href=#pg-ffd12528a12882b282e1bd19e29f9e75>Persistent Volume</a></li><li>3.6.3: <a href=#pg-c262af210c6828dec445d2f55a1d877a>VolumeSnapshot</a></li><li>3.6.4: <a href=#pg-707ca81a34eb1ca202f34692e9917d1e>Pengklonaan Volume CSI</a></li><li>3.6.5: <a href=#pg-f0276d05eef111249272a1c932a91e2c>StorageClass</a></li><li>3.6.6: <a href=#pg-4d00116c86dade62bdd5be7dc2afa1ca>VolumeSnapshotClass</a></li><li>3.6.7: <a href=#pg-018f0a7fc6e2f6d16da37702fc39b4f3>Penyediaan Volume Dinamis</a></li><li>3.6.8: <a href=#pg-b2e4b16ac37988c678a3312a4a6639f8>Limit Volume yang Spesifik terhadap Node</a></li></ul><li>3.7: <a href=#pg-275bea454e1cf4c5adeca4058b5af988>Konfigurasi</a></li><ul><li>3.7.1: <a href=#pg-ddef6fd0e47bb51c6f05e8e7fb11d2dd>Konfigurasi dan Penerapan Konsep</a></li><li>3.7.2: <a href=#pg-4c9401ed6b037e1adb958cbce20630c7>Mengatur Sumber Daya Komputasi untuk Container</a></li><li>3.7.3: <a href=#pg-e511ed821ada65d0053341dbd8ad2bb5>Secret</a></li><li>3.7.4: <a href=#pg-ab6d20f33ad930a67ee7ef57bff6c75e>Mengatur Akses Klaster Menggunakan Berkas kubeconfig</a></li><li>3.7.5: <a href=#pg-ed4ae5e4344d619bc6df6e1278efae74>Prioritas dan Pemindahan Pod</a></li></ul><li>3.8: <a href=#pg-712cb3c03ff14a39e5a83a6d9b71d203>Keamanan</a></li><ul><li>3.8.1: <a href=#pg-04eeb110d75afc8acb2cf7a3db743985>Ikhtisar Keamanan Cloud Native</a></li></ul><li>3.9: <a href=#pg-c21d05f31057c5bcd2ebdd01f4e62a0e>Penjadwalan dan Pengusiran</a></li><ul><li>3.9.1: <a href=#pg-961126cd43559012893979e568396a49>Bin Packing Sumber Daya untuk Sumber Daya Tambahan</a></li><li>3.9.2: <a href=#pg-da22fe2278df236f71efbe672f392677>Overhead Pod</a></li><li>3.9.3: <a href=#pg-21169f516071aea5d16734a4c27789a5>Menetapkan Pod ke Node</a></li><li>3.9.4: <a href=#pg-ede4960b56a3529ee0bfe7c8fe2d09a5>Taint dan Toleration</a></li><li>3.9.5: <a href=#pg-598f36d691ab197f9d995784574b0a12>Penjadwal Kubernetes</a></li><li>3.9.6: <a href=#pg-602208c95fe7b1f1170310ce993f5814>Kerangka Kerja Penjadwalan (Scheduling Framework)</a></li><li>3.9.7: <a href=#pg-d9574a30fcbc631b0d2a57850e161e89>Penyetelan Kinerja Penjadwal</a></li></ul><li>3.10: <a href=#pg-ac9161c6d952925b083ad9602b4e8e7f>Policies</a></li><ul><li>3.10.1: <a href=#pg-a935ff8c59eb116b43494255cc67f69a>LimitRange</a></li><li>3.10.2: <a href=#pg-94ddc6e901c30f256138db11d09f05a3>Resource Quota</a></li><li>3.10.3: <a href=#pg-59977cbac423e20437db079757cb03df>Pod Security Policy</a></li></ul><li>3.11: <a href=#pg-285a3785fd3d20f437c28d87ca4dadca>Administrasi Klaster</a></li><ul><li>3.11.1: <a href=#pg-fb494ea3b1874bd753dcd11c3f35c2dc>Ikhtisar Administrasi Klaster</a></li><li>3.11.2: <a href=#pg-2bf9a93ab5ba014fb6ff70b22c29d432>Sertifikat</a></li><li>3.11.3: <a href=#pg-d0e81230313a2684e7b7e40b21834e30>Penyedia Layanan Cloud</a></li><li>3.11.4: <a href=#pg-3aeeecf7cdb2a21eb4b31db7a71c81e2>Mengelola Resource</a></li><li>3.11.5: <a href=#pg-d649067a69d8d5c7e71564b42b96909e>Jaringan Kluster</a></li><li>3.11.6: <a href=#pg-c4b1e87a84441f8a90699a345ce48d68>Arsitektur Logging</a></li><li>3.11.7: <a href=#pg-cbfd3654996eae9fcdef009f70fa83f0>Metrik untuk Komponen Sistem Kubernetes</a></li><li>3.11.8: <a href=#pg-2e05a56491965ae320c2662590b2ca18>Konfigurasi Garbage Collection pada kubelet</a></li><li>3.11.9: <a href=#pg-3003324f360fdacc06ca144e57ff0e97>Federation</a></li><li>3.11.10: <a href=#pg-08e94e6a480e0d6b2de72d84a1b97617>Berbagai Proxy di Kubernetes</a></li><li>3.11.11: <a href=#pg-d5cc46b61677b53f61a407d20bdd0830>Metrik controller manager</a></li><li>3.11.12: <a href=#pg-85d633ae590aa20ec024f1b7af1d74fc>Instalasi Add-ons</a></li><li>3.11.13: <a href=#pg-31c9327d2332c585341b64ddafa19cdd>Prioritas dan Kesetaraan API (API Priority and Fairness)</a></li></ul><li>3.12: <a href=#pg-7e0d97616b15e2c383c6a0a96ec442cb>Memperluas Kubernetes</a></li><ul><li>3.12.1: <a href=#pg-5c2b36cd0ddbe006b575d4e54c63d508>Memperluas Klaster Kubernetes Kamu</a></li><li>3.12.2: <a href=#pg-0af41d3bd7c785621b58b7564793396a>Memperluas API Kubernetes</a></li><ul><li>3.12.2.1: <a href=#pg-1ea4977c0ebf97569bf54a477faa7fa5>Memperluas Kubernetes API dengan Lapisan Agregasi</a></li><li>3.12.2.2: <a href=#pg-342388440304e19ce30c0f8ada1c77ce>Custom Resource</a></li></ul><li>3.12.3: <a href=#pg-c8937cdc9df96f3328becf04f8211292>Ekstensi Komputasi, Penyimpanan, dan Jaringan</a></li><ul><li>3.12.3.1: <a href=#pg-1ac2260db9ecccbf0303a899bc27ce6d>Plugin Jaringan</a></li><li>3.12.3.2: <a href=#pg-53e1ea8892ceca307ba19e8d6a7b8d32>Plugin Perangkat</a></li></ul><li>3.12.4: <a href=#pg-3131452556176159fb269593c1a52012>Pola Operator</a></li><li>3.12.5: <a href=#pg-b26fcf43d01abc16c8110766026dafed>Service Catalog</a></li><li>3.12.6: <a href=#pg-bad3c3629d0ab48ed84b6caf66d02f89>Poseidon-Firmament - Sebuah Penjadwal Alternatif</a></li></ul></ul><li>4: <a href=#pg-f8918f697450c2009b75913f9e9317a5>Tugas</a></li><ul><li>4.1: <a href=#pg-57bf66f59d9a642b82eebeabbc66470b>Menginstal Peralatan</a></li><ul><li>4.1.1: <a href=#pg-bbdc530b292ab4074d1dfe69feafb3e7>Menginstal dan Menyiapkan kubectl</a></li></ul><li>4.2: <a href=#pg-964bdff888520740e5e221695245678d>Menjalankan Tugas-Tugas Otomatis dengan CronJob</a></li><li>4.3: <a href=#pg-f5da33b976758a9183018c421eb83f58>Mengatur Pod dan Kontainer</a></li><ul><li>4.3.1: <a href=#pg-e6dd9300cf3a955f7cdfe77fb5d15292>Menetapkan Sumber Daya Memori untuk Container dan Pod</a></li><li>4.3.2: <a href=#pg-904cea8c8efd5c0d33adbfe579ec2dd2>Konfigurasi Quality of Service untuk Pod</a></li><li>4.3.3: <a href=#pg-484833fb880d1e179cc2965d15f84da5>Mengatur Pod untuk Menggunakan Volume sebagai Tempat Penyimpanan</a></li><li>4.3.4: <a href=#pg-528d2422215cb9632b7b45e886b023b5>Mengatur Pod untuk Penyimpanan dengan PersistentVolume</a></li><li>4.3.5: <a href=#pg-abd895c0803315e9717e6ff9ec4e3d30>Mengonfigurasi Konteks Keamanan untuk Pod atau Container</a></li><li>4.3.6: <a href=#pg-2c0d882359718c4c69c67099bed2156c>Mengatur ServiceAccount untuk Pod</a></li><li>4.3.7: <a href=#pg-d385b86a7cb496d3b1c3b2a47280ca70>Menarik Image dari Register Pribadi</a></li><li>4.3.8: <a href=#pg-eb54daf87df373096b5e830680194dfc>Mengatur Probe Liveness, Readiness dan Startup</a></li><li>4.3.9: <a href=#pg-fc3f4777ae8ea685d2b54e175277ac01>Menempatkan Pod pada Node Menggunakan Afinitas Pod</a></li><li>4.3.10: <a href=#pg-ed34e761c3dbd00fa79577fa78e30020>Mengatur Pod untuk Menggunakan ConfigMap</a></li><li>4.3.11: <a href=#pg-3d7b9cb24a647c36ba63f7a02ec49010>Pembagian Namespace Proses antar Container pada sebuah Pod</a></li><li>4.3.12: <a href=#pg-42a59b878d4c58e5c6f4bb87483dda93>Membuat Pod Statis</a></li></ul><li>4.4: <a href=#pg-34a810f1516ad9d99b2697e36e9b0d0f>Mengelola Sebuah Klaster</a></li><ul><li>4.4.1: <a href=#pg-1239a77618c6278373832a142cd85519>Menggunakan Calico untuk NetworkPolicy</a></li><li>4.4.2: <a href=#pg-47be5dd51f686017f1766e6ec7aa6f41>Mengelola Memori, CPU, dan Sumber Daya API</a></li><ul><li>4.4.2.1: <a href=#pg-adb489b1ab985c9215657b0d4c6ae92b>Mengatur Batas Minimum dan Maksimum Memori pada sebuah Namespace</a></li></ul><li>4.4.3: <a href=#pg-8bcf4aeb5bbb6d6969a146e5ab97557b>Debugging Resolusi DNS</a></li><li>4.4.4: <a href=#pg-3d0cd7d2f13d4759094f281504cf57b8>Kustomisasi Service DNS</a></li><li>4.4.5: <a href=#pg-b64a1d2bb3f4ed9f7021134e09a75c36>Melakukan Reservasi Sumber Daya Komputasi untuk Daemon Sistem</a></li><li>4.4.6: <a href=#pg-1e966f5d0540bbee0876f9d0d08d54dc>Membagi sebuah Klaster dengan Namespace</a></li><li>4.4.7: <a href=#pg-0b17e83b6049e53b8ffa864bdfa07c87>Mengatur Control Plane Kubernetes dengan Ketersediaan Tinggi (High-Availability)</a></li><li>4.4.8: <a href=#pg-fe5ad73163d38596340536ec03a205f0>Menggunakan sysctl dalam Sebuah Klaster Kubernetes</a></li><li>4.4.9: <a href=#pg-c4d0832845adc92b7ccd54aed63fc932>Mengoperasikan klaster etcd untuk Kubernetes</a></li></ul><li>4.5: <a href=#pg-aa0731e8aa8e2f6cc9e3c1a5e9895863>Mengelola Objek Kubernetes</a></li><ul><li>4.5.1: <a href=#pg-df206392be6f4d19bd8da41cee7170fa>Pengelolaan Objek Kubernetes secara Deklaratif dengan Menggunakan Berkas Konfigurasi</a></li><li>4.5.2: <a href=#pg-11aa6950fcb203094823c8e2cbdd517f>Mengelola Objek Kubernetes secara Deklaratif menggunakan Kustomize</a></li><li>4.5.3: <a href=#pg-80c83fe9b80d0fef2681c8d59c0aa197>Pengelolaan Objek Kubernetes dengan Perintah Imperatif</a></li><li>4.5.4: <a href=#pg-b18886277c410fc6f32ce068e2160537>Pengelolaan Objek Kubernetes Secara Imperatif dengan Menggunakan File Konfigurasi</a></li></ul><li>4.6: <a href=#pg-866924fa095f897ede8dfdcab9e97942>Memasukkan Data ke dalam Aplikasi</a></li><ul><li>4.6.1: <a href=#pg-c9af1e81bb6e109f6c41febe44f0931b>Mendefinisikan Perintah dan Argumen untuk sebuah Kontainer</a></li><li>4.6.2: <a href=#pg-82c93897176489678232542102daea40>Mendefinisikan Variabel Lingkungan untuk sebuah Kontainer</a></li><li>4.6.3: <a href=#pg-7f9454a1e775548c23ee5b300a9218a3>Mendistribusikan Kredensial dengan Aman Menggunakan Secret</a></li></ul><li>4.7: <a href=#pg-a78a5e7e765fd8c49c8f7c0d72499f72>Menjalankan</a></li><ul><li>4.7.1: <a href=#pg-790ea02857492b3a822e981e93e3a98b>Menjalankan Aplikasi Stateless Menggunakan Deployment</a></li><li>4.7.2: <a href=#pg-f5f2f7a74377a9d45325c5253353fa8f>Menghapus Paksa Pod StatefulSet</a></li><li>4.7.3: <a href=#pg-0c0bb1bd76d2a9069e50e2cec6d20c2a>HorizontalPodAutoscaler</a></li><li>4.7.4: <a href=#pg-8138226ce9660ac8e3e82ff86fff8ad2>Panduan HorizontalPodAutoscaler</a></li></ul><li>4.8: <a href=#pg-b74b959f5a531003dd0653dfbfc2e88b>Mengakes Aplikasi-aplikasi di sebuah Klaster</a></li><ul><li>4.8.1: <a href=#pg-777447042cd4e81df3fa5beb3357a485>Antarmuka Pengguna Berbasis Web (Dashboard)</a></li><li>4.8.2: <a href=#pg-6a8d9e9e05f2b6825afbb8889c957370>Mengakses Klaster</a></li><li>4.8.3: <a href=#pg-5a233e14205d77fe1294917d2da6f876>Mengkonfigurasi Akses ke Banyak Klaster</a></li><li>4.8.4: <a href=#pg-72d3dddbc0c166c9a364e753d2b31ff0>Menggunakan Port Forwarding untuk Mengakses Aplikasi di sebuah Klaster</a></li><li>4.8.5: <a href=#pg-21cd8f87563675fb0278d3694ba9ecb0>Membuat Load Balancer Eksternal</a></li><li>4.8.6: <a href=#pg-48e8f306f919c5b81265e265a2b76ab4>Membuat Daftar Semua Image Container yang Berjalan dalam Klaster</a></li></ul><li>4.9: <a href=#pg-f6a755efe831d24956501e4bcd49ff96>Pemantauan, Pencatatan, and Debugging</a></li><ul><li>4.9.1: <a href=#pg-731bb8b338c16aebfb9590ba2bd3fdd1>Introspeksi dan _Debugging_ Aplikasi</a></li><li>4.9.2: <a href=#pg-9713ac27b6d9e3034033200d968221f2>Mendapatkan Shell Untuk Masuk ke Container yang Sedang Berjalan</a></li><li>4.9.3: <a href=#pg-9e6e1b706f11386fe2c4b4ffda1409e4>Perangkat untuk Memantau Sumber Daya</a></li></ul><li>4.10: <a href=#pg-d3c88a8663f58e9ec0bed73faff5b670>TLS</a></li><ul><li>4.10.1: <a href=#pg-9a87de8ee8332cb487f34a05debb1125>Kelola Sertifikat TLS Pada Klaster</a></li></ul><li>4.11: <a href=#pg-ba58efa15c6d46f10e34d799be220965>Mengelola Daemon Klaster</a></li><ul><li>4.11.1: <a href=#pg-f1bf7e426f482a85e1a417d1fd9ea7b7>Melakukan Rollback pada DaemonSet</a></li></ul></ul><li>5: <a href=#pg-68ec2370d0409cc27325be36693f9368>Tutorial</a></li><ul><li>5.1: <a href=#pg-5e3051fff9e84735871d9fb5e7b93f33>Halo Minikube</a></li><li>5.2: <a href=#pg-3c83f53a74233ace9b289ac5e24c3e62>Mempelajari Panduan Dasar Kubernetes</a></li><ul><li>5.2.1: <a href=#pg-7df66040311338d6098ebeab43ba9afb>Membuat Klaster</a></li><ul><li>5.2.1.1: <a href=#pg-de49316920e97a82e36763cb66781ada>Menggunakan Minikube Untuk Membuat Klaster</a></li><li>5.2.1.2: <a href=#pg-323b75976001e8dfe35d67d61bc74f1a>Tutorial Interaktif - Membuat Klaster</a></li></ul><li>5.2.2: <a href=#pg-76d78b3fba507f7ed33cef14a35b631d>Menyebarkan (Deploy) Aplikasi</a></li><ul><li>5.2.2.1: <a href=#pg-2b1bba431989008c7493109a0f049ece>Menggunakan kubectl untuk membuat Deployment</a></li><li>5.2.2.2: <a href=#pg-f8997ec143b382fa6c9621941ea62ca3>Tutorial Interaktif - Menyebarkan (Deploy) Aplikasi</a></li></ul><li>5.2.3: <a href=#pg-250d620a73ec8be7e1f7d835574c4596>Menjelajahi Aplikasimu</a></li><ul><li>5.2.3.1: <a href=#pg-2771f4e8c45321b17cb0114a2d266453>Melihat Pod dan Node</a></li><li>5.2.3.2: <a href=#pg-4b01eab98a9844ad91131079654199dd>Tutorial Interaktif - Menjelajahi Aplikasimu</a></li></ul><li>5.2.4: <a href=#pg-4b0e31c9e0eae68bbb0a358b4042ada9>Mengekspos Aplikasimu Secara Publik</a></li><ul><li>5.2.4.1: <a href=#pg-8ef4dad8f743b191a9e8c6f891cb191a>Menggunakan Service untuk Mengekspos Aplikasimu</a></li><li>5.2.4.2: <a href=#pg-352241d22effe0714772d21c7d1b512d>Tutorial Interaktif - Mengekspos Aplikasimu</a></li></ul><li>5.2.5: <a href=#pg-be4996c93fb39c459a30b6669569d423>Penyekalaan Aplikasimu</a></li><ul><li>5.2.5.1: <a href=#pg-d1c15c9bd4f625adbc13149b1475287c>Menjalankan Multipel Instans dari Aplikasimu</a></li><li>5.2.5.2: <a href=#pg-7bdb3fbaa1177ff5dfa3fe86bd35ef59>Tutorial Interaktif - Penyekalaan Aplikasimu</a></li></ul><li>5.2.6: <a href=#pg-62b8b17dadfb55f1801cf8439e944e58>Memperbarui Aplikasimu</a></li><ul><li>5.2.6.1: <a href=#pg-12e04355145afad615ca3c38335ba019>Melakukan Pembaruan Bertahap</a></li><li>5.2.6.2: <a href=#pg-dddc0cb356c280e0339bcf42776987dc>Tutorial Interaktif - Memperbarui Aplikasimu</a></li></ul></ul><li>5.3: <a href=#pg-1efbbc2c3015389f835b1661d5effb29>Aplikasi Stateless</a></li><ul><li>5.3.1: <a href=#pg-62caf420877232190a7404b8d93c6724>Mengekspos Alamat IP Eksternal untuk Mengakses Aplikasi di dalam Klaster</a></li></ul><li>5.4: <a href=#pg-d6336d9712aa433eb5f0fb8cbed6bef7>Aplikasi Stateful</a></li><ul><li>5.4.1: <a href=#pg-42e39658021b706bcc9478c8cc73c4a3>Dasar-dasar StatefulSet</a></li></ul></ul><li>6: <a href=#pg-b00a88a07ceb21b1a83e5822e0c86c1d>Referensi</a></li><ul><li>6.1: <a href=#pg-2b03679960950df772fb4fe7d78427b9>Glosarium</a></li><li>6.2: <a href=#pg-99b26586d8a33ec06996dcf7892a9683>Mengakses API</a></li><ul><li>6.2.1: <a href=#pg-954776b47f2d90515f375623a0ce98e1>Menggunakan Otorisasi RBAC</a></li></ul><li>6.3: <a href=#pg-03460a7254c6c73eb2a1bb3dd7d25910>Baris Perintah kubectl</a></li><ul><li>6.3.1: <a href=#pg-8aba901ac13f124e5782b90ddb166ee2>Contekan kubectl</a></li></ul></ul><li>7: <a href=#pg-4985cb55ddfb184639d767ec54b9f0f7>Berkontribusi ke Dokumentasi Kubernetes</a></li><ul><li>7.1: <a href=#pg-e5340359b8afe1fe409af06178af8886>Menyarankan peningkatan kualitas konten</a></li><li>7.2: <a href=#pg-8b9b22280711800788333c1a4d129735>Berpartisipasi dalam SIG Docs</a></li><ul></ul><li>7.3: <a href=#pg-9d388974115458abb65431d0a8610843>Dokumentasi Khusus Untuk Translasi Bahasa Indonesia</a></li></ul></ul><div class=content></div></div><div class=td-content><h1 id=pg-e735cee7e913aa88bc0aa10594d12966>1 - Dokumentasi Kubernetes</h1></div><div class=td-content><h1 id=pg-92dfff0ca612d0bff40171aa9df6c4ae>1.1 - Versi Dokumentasi yang Tersedia</h1><p>Situs web ini berisi dokumentasi untuk versi terkini Kubernetes
dan empat versi sebelumnya.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-66b565805ca1061be35ff2c0165f13c1>2 - Persiapan</h1><p>Bagian ini mencantumkan berbagai cara untuk menyiapkan dan menjalankan Kubernetes. Ketika kamu menginstal Kubernetes, pilih tipe instalasi berdasarkan: kemudahan perawatan, keamanan, sumber daya yang tersedia, dan keahlian yang dibutuhkan untuk mengoperasikan dan mengelola klaster.</p><p>Kamu dapat menggelar klaster Kubernetes di mesin lokal, <em>cloud</em>, <em>datacenter</em> di tempat, atau pilih klaster Kubernetes yang dikelola. Ada juga solusi khusus di berbagai penyedia <em>cloud</em>, atau lingkungan <em>baremetal</em>.</p><h2 id=lingkungan-pembelajaran>Lingkungan Pembelajaran</h2><p>Jika kamu sedang belajar Kubernetes, gunakan alat yang didukung oleh komunitas Kubernetes, atau alat di ekosistem untuk menyiapkan klaster Kubernetes di mesin lokal.</p><h2 id=lingkungan-produksi>Lingkungan Produksi</h2><p>Pada saat mengevaluasi sebuah solusi untuk lingkungan produksi, pertimbangkan aspek dari pengoperasian klaster Kubernetes atau abstraksi yang ingin kamu kelola atau membiarkan penyedia.</p><p><a href=https://kubernetes.io/partners/#conformance>Kubernetes Partner</a> termasuk dari daftar dari penyedia <a href=https://github.com/cncf/k8s-conformance/#certified-kubernetes><em>Certified</em> Kubernetes</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-0b597086a9d1382f86abadcfeab657d6>2.1 - Lingkungan Pembelajaran</h1><h2 id=kind>kind</h2><p><a href=https://kind.sigs.k8s.io/docs/><code>kind</code></a> memberikan kamu kemampuan untuk
menjalankan Kubernetes pada komputer lokal kamu. Perangkat ini membutuhkan
<a href=https://docs.docker.com/get-docker/>Docker</a> yang sudah diinstal dan
terkonfigurasi.</p><p>Halaman <a href=https://kind.sigs.k8s.io/docs/user/quick-start/>Memulai Cepat</a> <code>kind</code>
memperlihatkan kepada kamu tentang apa yang perlu kamu lakukan agar <code>kind</code> dapat
berjalan dan bekerja.</p><p><a class="btn btn-primary" href=https://kind.sigs.k8s.io/docs/user/quick-start/ role=button aria-label="Melihat Memulai Cepat Kind">Melihat Memulai Cepat Kind</a></p><h2 id=minikube>minikube</h2><p>Seperti halnya dengan <code>kind</code>, <a href=https://minikube.sigs.k8s.io/><code>minikube</code></a>
merupakan perangkat yang memungkinkan kamu untuk menjalankan Kubernetes
secara lokal. <code>minikube</code> menjalankan sebuah klaster Kubernetes dengan
satu node saja dalam komputer pribadi (termasuk Windows, macOS dan Linux)
sehingga kamu dapat mencoba Kubernetes atau untuk pekerjaan pengembangan
sehari-hari.</p><p>Kamu bisa mengikuti petunjuk resmi
<a href=https://minikube.sigs.k8s.io/docs/start/>Memulai!</a>
<code>minikube</code> jika kamu ingin fokus agar perangkat ini terinstal.</p><p><a class="btn btn-primary" href=https://minikube.sigs.k8s.io/docs/start/ role=button aria-label="Lihat Panduan Memulai! Minikube">Lihat Panduan Memulai! Minikube</a></p><p>Setelah kamu memiliki <code>minikube</code> yang bekerja, kamu bisa menggunakannya
untuk <a href=/id/docs/tutorials/hello-minikube/>menjalankan aplikasi contoh</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-4e14853fdaa3bd273f31a60112b9b5ac>2.2 - Lingkungan Produksi</h1></div><div class=td-content><h1 id=pg-a77d3feb6e6d9978f32fa14622642e9a>2.2.1 - Runtime Container</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.6 [stable]</code></div><p>Untuk menjalankan Container di Pod, Kubernetes menggunakan <em>runtime</em> Container (Container runtimes). Berikut ini adalah
petunjuk instalasi untuk berbagai macam <em>runtime</em>.</p><div class="alert alert-warning caution callout" role=alert><strong>Perhatian:</strong><p>Sebuah kekurangan ditemukan dalam cara <code>runc</code> menangani pendeskripsi berkas (<em>file</em>) sistem ketika menjalankan Container.
Container yang berbahaya dapat menggunakan kekurangan ini untuk menimpa konten biner <code>runc</code> dan
akibatnya Container tersebut dapat menjalankan perintah yang sewenang-wenang pada sistem host dari Container tersebut.</p><p>Silahkan merujuk pada <a href=https://access.redhat.com/security/cve/cve-2019-5736>CVE-2019-5736</a> untuk informasi lebih lanjut tentang masalah ini.</p></div><h3 id=penerapan>Penerapan</h3><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Dokumen ini ditulis untuk pengguna yang memasang CRI (Container Runtime Interface) pada sistem operasi Linux. Untuk sistem operasi yang lain,
silahkan cari dokumentasi khusus untuk platform kamu.</div><p>Kamu harus menjalankan semua perintah dalam panduan ini sebagai <code>root</code>. Sebagai contoh, awali perintah
dengan <code>sudo</code>, atau masuk sebagai <code>root</code> dan kemudian baru menjalankan perintah sebagai pengguna <code>root</code>.</p><h3 id=driver-cgroup><em>Driver</em> cgroup</h3><p>Ketika systemd dipilih sebagai sistem init untuk sebuah distribusi Linux, proses init menghasilkan
dan menggunakan grup kontrol root (<code>cgroup</code>) dan proses ini akan bertindak sebagai manajer cgroup. Systemd memiliki integrasi yang ketat
dengan cgroup dan akan mengalokasikan cgroups untuk setiap proses. Kamu dapat mengonfigurasi
<em>runtime</em> Container dan kubelet untuk menggunakan <code>cgroupfs</code>. Menggunakan <code>cgroupfs</code> bersama dengan systemd berarti
akan ada dua manajer cgroup yang berbeda.</p><p>Cgroup digunakan untuk membatasi sumber daya yang dialokasikan untuk proses.
Sebuah manajer cgroup tunggal akan menyederhanakan pandangan tentang sumber daya apa yang sedang dialokasikan
dan secara bawaan (<em>default</em>) akan memiliki pandangan yang lebih konsisten tentang sumber daya yang tersedia dan yang sedang digunakan. Ketika kita punya memiliki
dua manajer maka kita pun akan memiliki dua pandangan berbeda tentang sumber daya tersebut. Kita telah melihat kasus di lapangan
di mana Node yang dikonfigurasi menggunakan <code>cgroupfs</code> untuk kubelet dan Docker, dan <code>systemd</code>
untuk semua sisa proses yang berjalan pada Node maka Node tersebut akan menjadi tidak stabil di bawah tekanan sumber daya.</p><p>Mengubah aturan sedemikian rupa sehingga <em>runtime</em> Container dan kubelet kamu menggunakan <code>systemd</code> sebagai <em>driver</em> cgroup
akan menstabilkan sistem. Silahkan perhatikan opsi <code>native.cgroupdriver=systemd</code> dalam pengaturan Docker di bawah ini.</p><div class="alert alert-warning caution callout" role=alert><strong>Perhatian:</strong> Mengubah driver cgroup dari Node yang telah bergabung kedalam sebuah Cluster sangat tidak direkomendasikan.
Jika kubelet telah membuat Pod menggunakan semantik dari sebuah <em>driver</em> cgroup, mengubah <em>runtime</em> Container
ke <em>driver</em> cgroup yang lain dapat mengakibatkan kesalahan pada saat percobaan untuk membuat kembali PodSandbox
untuk Pod yang sudah ada. Menjalankan ulang (<em>restart</em>) kubelet mungkin tidak menyelesaikan kesalahan tersebut. Rekomendasi yang dianjurkan
adalah untuk menguras Node dari beban kerjanya, menghapusnya dari Cluster dan menggabungkannya kembali.</div><h2 id=docker>Docker</h2><p>Pada setiap mesin kamu, mari menginstall Docker.
Versi yang direkomendasikan adalah 19.03.11, tetapi versi 1.13.1, 17.03, 17.06, 17.09, 18.06 dan 18.09 juga diketahui bekerja dengan baik.
Jagalah versi Docker pada versi terbaru yang sudah terverifikasi pada catatan rilis Kubernetes.</p><p>Gunakan perintah berikut untuk menginstal Docker pada sistem kamu:</p><ul class="nav nav-tabs" id=tab-cri-docker-installation role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-cri-docker-installation-0 role=tab aria-controls=tab-cri-docker-installation-0 aria-selected=true>Ubuntu 16.04+</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-cri-docker-installation-1 role=tab aria-controls=tab-cri-docker-installation-1>CentOS/RHEL 7.4+</a></li></ul><div class=tab-content id=tab-cri-docker-installation><div id=tab-cri-docker-installation-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-cri-docker-installation-0><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># (Menginstal Docker CE)</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic>## Mengatur repositori:</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic>### Menginstal packet untuk mengijinkan apt untuk menggunakan repositori melalui HTTPS</span>
</span></span><span style=display:flex><span>apt-get update <span style=color:#666>&amp;&amp;</span> apt-get install -y <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  apt-transport-https ca-certificates curl software-properties-common gnupg2
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Menambahkan key GPG resmi dari Docker:</span>
</span></span><span style=display:flex><span>curl -fsSL https://download.docker.com/linux/ubuntu/gpg | apt-key add -
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Menambahkan repositori apt dari Docker:</span>
</span></span><span style=display:flex><span>add-apt-repository <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  <span style=color:#b44>&#34;deb [arch=amd64] https://download.docker.com/linux/ubuntu \
</span></span></span><span style=display:flex><span><span style=color:#b44>  </span><span style=color:#a2f;font-weight:700>$(</span>lsb_release -cs<span style=color:#a2f;font-weight:700>)</span><span style=color:#b44> \
</span></span></span><span style=display:flex><span><span style=color:#b44>  stable&#34;</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Menginstal Docker CE</span>
</span></span><span style=display:flex><span>apt-get update <span style=color:#666>&amp;&amp;</span> apt-get install -y <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  containerd.io<span style=color:#666>=</span>1.2.13-2 <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  docker-ce<span style=color:#666>=</span>5:19.03.11~3-0~ubuntu-<span style=color:#a2f;font-weight:700>$(</span>lsb_release -cs<span style=color:#a2f;font-weight:700>)</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  docker-ce-cli<span style=color:#666>=</span>5:19.03.11~3-0~ubuntu-<span style=color:#a2f;font-weight:700>$(</span>lsb_release -cs<span style=color:#a2f;font-weight:700>)</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Mengatur daemon Docker</span>
</span></span><span style=display:flex><span>cat &gt; /etc/docker/daemon.json <span style=color:#b44>&lt;&lt;EOF
</span></span></span><span style=display:flex><span><span style=color:#b44>{
</span></span></span><span style=display:flex><span><span style=color:#b44>  &#34;exec-opts&#34;: [&#34;native.cgroupdriver=systemd&#34;],
</span></span></span><span style=display:flex><span><span style=color:#b44>  &#34;log-driver&#34;: &#34;json-file&#34;,
</span></span></span><span style=display:flex><span><span style=color:#b44>  &#34;log-opts&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#b44>    &#34;max-size&#34;: &#34;100m&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44>  },
</span></span></span><span style=display:flex><span><span style=color:#b44>  &#34;storage-driver&#34;: &#34;overlay2&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44>}
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>mkdir -p /etc/systemd/system/docker.service.d
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Menjalankan ulang Docker</span>
</span></span><span style=display:flex><span>systemctl daemon-reload
</span></span><span style=display:flex><span>systemctl restart docker
</span></span></code></pre></div></div><div id=tab-cri-docker-installation-1 class=tab-pane role=tabpanel aria-labelledby=tab-cri-docker-installation-1><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># (Menginstal Docker CE)</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic>## Mengatur repositori</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic>### Menginstal paket yang diperlukan</span>
</span></span><span style=display:flex><span>yum install -y yum-utils device-mapper-persistent-data lvm2
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic>## Menambahkan repositori apt dari Docker</span>
</span></span><span style=display:flex><span>yum-config-manager --add-repo <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  https://download.docker.com/linux/centos/docker-ce.repo
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Menginstal Docker CE</span>
</span></span><span style=display:flex><span>yum update -y <span style=color:#666>&amp;&amp;</span> yum install -y <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  containerd.io-1.2.13 <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  docker-ce-19.03.11 <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  docker-ce-cli-19.03.11
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic>## Membuat berkas /etc/docker</span>
</span></span><span style=display:flex><span>mkdir /etc/docker
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Mengatur daemon Docker</span>
</span></span><span style=display:flex><span>cat &gt; /etc/docker/daemon.json <span style=color:#b44>&lt;&lt;EOF
</span></span></span><span style=display:flex><span><span style=color:#b44>{
</span></span></span><span style=display:flex><span><span style=color:#b44>  &#34;exec-opts&#34;: [&#34;native.cgroupdriver=systemd&#34;],
</span></span></span><span style=display:flex><span><span style=color:#b44>  &#34;log-driver&#34;: &#34;json-file&#34;,
</span></span></span><span style=display:flex><span><span style=color:#b44>  &#34;log-opts&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#b44>    &#34;max-size&#34;: &#34;100m&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44>  },
</span></span></span><span style=display:flex><span><span style=color:#b44>  &#34;storage-driver&#34;: &#34;overlay2&#34;,
</span></span></span><span style=display:flex><span><span style=color:#b44>  &#34;storage-opts&#34;: [
</span></span></span><span style=display:flex><span><span style=color:#b44>    &#34;overlay2.override_kernel_check=true&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44>  ]
</span></span></span><span style=display:flex><span><span style=color:#b44>}
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>mkdir -p /etc/systemd/system/docker.service.d
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Menjalankan ulang Docker</span>
</span></span><span style=display:flex><span>systemctl daemon-reload
</span></span><span style=display:flex><span>systemctl restart docker
</span></span></code></pre></div></div></div><p>Jika kamu menginginkan layanan Docker berjalan dari saat memulai pertama (<em>boot</em>), jalankan perintah ini:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sudo systemctl <span style=color:#a2f>enable</span> docker
</span></span></code></pre></div><p>Silahkan merujuk pada <a href=https://docs.docker.com/engine/installation/>Panduan resmi instalasi Docker</a>
untuk informasi lebih lanjut.</p><h2 id=cri-o>CRI-O</h2><p>Bagian ini mencakup langkah-langkah yang diperlukan untuk menginstal <code>CRI-O</code> sebagai <em>runtime</em> CRI.</p><p>Gunakan perintah-perinath berikut untuk menginstal CRI-O pada sistem kamu:</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Versi mayor dan minor dari CRI-O harus sesuai dengan versi mayor dan minor dari Kubernetes.
Untuk informasi lebih lanjut, lihatlah <a href=https://github.com/cri-o/cri-o>Matriks kompatibilitas CRI-O</a>.</div><h3 id=prasyarat>Prasyarat</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>modprobe overlay
</span></span><span style=display:flex><span>modprobe br_netfilter
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Mengatur parameter sysctl yang diperlukan, dimana ini akan bernilai tetap setiap kali penjalanan ulang.</span>
</span></span><span style=display:flex><span>cat &gt; /etc/sysctl.d/99-kubernetes-cri.conf <span style=color:#b44>&lt;&lt;EOF
</span></span></span><span style=display:flex><span><span style=color:#b44>net.bridge.bridge-nf-call-iptables  = 1
</span></span></span><span style=display:flex><span><span style=color:#b44>net.ipv4.ip_forward                 = 1
</span></span></span><span style=display:flex><span><span style=color:#b44>net.bridge.bridge-nf-call-ip6tables = 1
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>sysctl --system
</span></span></code></pre></div><ul class="nav nav-tabs" id=tab-cri-cri-o-installation role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-cri-cri-o-installation-0 role=tab aria-controls=tab-cri-cri-o-installation-0 aria-selected=true>Debian</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-cri-cri-o-installation-1 role=tab aria-controls=tab-cri-cri-o-installation-1>Ubuntu 18.04, 19.04 and 19.10</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-cri-cri-o-installation-2 role=tab aria-controls=tab-cri-cri-o-installation-2>CentOS/RHEL 7.4+</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-cri-cri-o-installation-3 role=tab aria-controls=tab-cri-cri-o-installation-3>openSUSE Tumbleweed</a></li></ul><div class=tab-content id=tab-cri-cri-o-installation><div id=tab-cri-cri-o-installation-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-cri-cri-o-installation-0><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Debian Unstable/Sid</span>
</span></span><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b44>&#39;deb http://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/Debian_Unstable/ /&#39;</span> &gt; /etc/apt/sources.list.d/devel:kubic:libcontainers:stable.list
</span></span><span style=display:flex><span>wget -nv https://download.opensuse.org/repositories/devel:kubic:libcontainers:stable/Debian_Unstable/Release.key -O- | sudo apt-key add -
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Debian Testing</span>
</span></span><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b44>&#39;deb http://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/Debian_Testing/ /&#39;</span> &gt; /etc/apt/sources.list.d/devel:kubic:libcontainers:stable.list
</span></span><span style=display:flex><span>wget -nv https://download.opensuse.org/repositories/devel:kubic:libcontainers:stable/Debian_Testing/Release.key -O- | sudo apt-key add -
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Debian 10</span>
</span></span><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b44>&#39;deb http://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/Debian_10/ /&#39;</span> &gt; /etc/apt/sources.list.d/devel:kubic:libcontainers:stable.list
</span></span><span style=display:flex><span>wget -nv https://download.opensuse.org/repositories/devel:kubic:libcontainers:stable/Debian_10/Release.key -O- | sudo apt-key add -
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Raspbian 10</span>
</span></span><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b44>&#39;deb http://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/Raspbian_10/ /&#39;</span> &gt; /etc/apt/sources.list.d/devel:kubic:libcontainers:stable.list
</span></span><span style=display:flex><span>wget -nv https://download.opensuse.org/repositories/devel:kubic:libcontainers:stable/Raspbian_10/Release.key -O- | sudo apt-key add -
</span></span></code></pre></div><p>dan kemudian install CRI-O:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sudo apt-get install cri-o-1.17
</span></span></code></pre></div></div><div id=tab-cri-cri-o-installation-1 class=tab-pane role=tabpanel aria-labelledby=tab-cri-cri-o-installation-1><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Mengatur repositori paket</span>
</span></span><span style=display:flex><span>. /etc/os-release
</span></span><span style=display:flex><span>sudo sh -c <span style=color:#b44>&#34;echo &#39;deb http://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/x</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>NAME</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>_</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>VERSION_ID</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>/ /&#39; &gt; /etc/apt/sources.list.d/devel:kubic:libcontainers:stable.list&#34;</span>
</span></span><span style=display:flex><span>wget -nv https://download.opensuse.org/repositories/devel:kubic:libcontainers:stable/x<span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>NAME</span><span style=color:#b68;font-weight:700>}</span>_<span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>VERSION_ID</span><span style=color:#b68;font-weight:700>}</span>/Release.key -O- | sudo apt-key add -
</span></span><span style=display:flex><span>sudo apt-get update
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Menginstal CRI-O</span>
</span></span><span style=display:flex><span>sudo apt-get install cri-o-1.17
</span></span></code></pre></div></div><div id=tab-cri-cri-o-installation-2 class=tab-pane role=tabpanel aria-labelledby=tab-cri-cri-o-installation-2><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Menginstal prasyarat</span>
</span></span><span style=display:flex><span>curl -L -o /etc/yum.repos.d/devel:kubic:libcontainers:stable.repo https://download.opensuse.org/repositories/devel:kubic:libcontainers:stable/CentOS_7/devel:kubic:libcontainers:stable.repo
</span></span><span style=display:flex><span>curl -L -o /etc/yum.repos.d/devel:kubic:libcontainers:stable:cri-o:1.25.repo https://download.opensuse.org/repositories/devel:kubic:libcontainers:stable:cri-o:1.25/CentOS_7/devel:kubic:libcontainers:stable:cri-o:1.25.repo
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Menginstal CRI-O</span>
</span></span><span style=display:flex><span>yum install -y cri-o
</span></span></code></pre></div></div><div id=tab-cri-cri-o-installation-3 class=tab-pane role=tabpanel aria-labelledby=tab-cri-cri-o-installation-3><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sudo zypper install cri-o
</span></span></code></pre></div></div></div><h3 id=memulai-cri-o>Memulai CRI-O</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>systemctl daemon-reload
</span></span><span style=display:flex><span>systemctl start crio
</span></span></code></pre></div><p>Silahkan merujuk pada <a href=https://github.com/kubernetes-sigs/cri-o#getting-started>Panduan instalasi CRI-O</a>
untuk informasi lanjut.</p><h2 id=containerd>Containerd</h2><p>Bagian ini berisi langkah-langkah yang diperlukan untuk menggunakan <code>containerd</code> sebagai <em>runtime</em> CRI.</p><p>Gunakan perintah-perintah berikut untuk menginstal containerd pada sistem kamu:</p><h3 id=prasyarat-1>Prasyarat</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat &gt; /etc/modules-load.d/containerd.conf <span style=color:#b44>&lt;&lt;EOF
</span></span></span><span style=display:flex><span><span style=color:#b44>overlay
</span></span></span><span style=display:flex><span><span style=color:#b44>br_netfilter
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>modprobe overlay
</span></span><span style=display:flex><span>modprobe br_netfilter
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Mengatur parameter sysctl yang diperlukan, dimana ini akan bernilai tetap setiap kali penjalanan ulang.</span>
</span></span><span style=display:flex><span>cat &gt; /etc/sysctl.d/99-kubernetes-cri.conf <span style=color:#b44>&lt;&lt;EOF
</span></span></span><span style=display:flex><span><span style=color:#b44>net.bridge.bridge-nf-call-iptables  = 1
</span></span></span><span style=display:flex><span><span style=color:#b44>net.ipv4.ip_forward                 = 1
</span></span></span><span style=display:flex><span><span style=color:#b44>net.bridge.bridge-nf-call-ip6tables = 1
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>sysctl --system
</span></span></code></pre></div><h3 id=menginstal-containerd>Menginstal containerd</h3><ul class="nav nav-tabs" id=tab-cri-containerd-installation role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-cri-containerd-installation-0 role=tab aria-controls=tab-cri-containerd-installation-0 aria-selected=true>Ubuntu 16.04</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-cri-containerd-installation-1 role=tab aria-controls=tab-cri-containerd-installation-1>CentOS/RHEL 7.4+</a></li></ul><div class=tab-content id=tab-cri-containerd-installation><div id=tab-cri-containerd-installation-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-cri-containerd-installation-0><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># (Meninstal containerd)</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic>## Mengatur repositori paket</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic>### Install packages to allow apt to use a repository over HTTPS</span>
</span></span><span style=display:flex><span>apt-get update <span style=color:#666>&amp;&amp;</span> apt-get install -y apt-transport-https ca-certificates curl software-properties-common
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic>## Menambahkan key GPG resmi dari Docker:</span>
</span></span><span style=display:flex><span>curl -fsSL https://download.docker.com/linux/ubuntu/gpg | apt-key add -
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic>## Mengatur repositori paket Docker</span>
</span></span><span style=display:flex><span>add-apt-repository <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    <span style=color:#b44>&#34;deb [arch=amd64] https://download.docker.com/linux/ubuntu \
</span></span></span><span style=display:flex><span><span style=color:#b44>    </span><span style=color:#a2f;font-weight:700>$(</span>lsb_release -cs<span style=color:#a2f;font-weight:700>)</span><span style=color:#b44> \
</span></span></span><span style=display:flex><span><span style=color:#b44>    stable&#34;</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic>## Menginstal containerd</span>
</span></span><span style=display:flex><span>apt-get update <span style=color:#666>&amp;&amp;</span> apt-get install -y containerd.io
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Mengonfigure containerd</span>
</span></span><span style=display:flex><span>mkdir -p /etc/containerd
</span></span><span style=display:flex><span>containerd config default | sudo tee /etc/containerd/config.toml
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Menjalankan ulang containerd</span>
</span></span><span style=display:flex><span>systemctl restart containerd
</span></span></code></pre></div></div><div id=tab-cri-containerd-installation-1 class=tab-pane role=tabpanel aria-labelledby=tab-cri-containerd-installation-1><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># (Menginstal containerd)</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic>## Mengatur repositori</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic>### Menginstal paket prasyarat</span>
</span></span><span style=display:flex><span>yum install -y yum-utils device-mapper-persistent-data lvm2
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic>## Menambahkan repositori Docker</span>
</span></span><span style=display:flex><span>yum-config-manager <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    --add-repo <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    https://download.docker.com/linux/centos/docker-ce.repo
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic>## Menginstal containerd</span>
</span></span><span style=display:flex><span>yum update -y <span style=color:#666>&amp;&amp;</span> yum install -y containerd.io
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic>## Mengonfigurasi containerd</span>
</span></span><span style=display:flex><span>mkdir -p /etc/containerd
</span></span><span style=display:flex><span>containerd config default | sudo tee /etc/containerd/config.toml
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Menjalankan ulang containerd</span>
</span></span><span style=display:flex><span>systemctl restart containerd
</span></span></code></pre></div></div></div><h3 id=systemd>systemd</h3><p>Untuk menggunakan driver cgroup <code>systemd</code>, atur <code>plugins.cri.systemd_cgroup = true</code> pada <code>/etc/containerd/config.toml</code>.
Ketika menggunakan kubeadm, konfigurasikan secara manual
<a href=/id/docs/setup/production-environment/tools/kubeadm/install-kubeadm/#mengonfigurasi-cgroup-untuk-kubelet-pada-node-control-plane>driver cgroup untuk kubelet</a></p><h2 id=runtime-cri-yang-lainnya-frakti><em>Runtime</em> CRI yang lainnya: Frakti</h2><p>Silahkan lihat <a href=https://github.com/kubernetes/frakti#quickstart>Panduan cepat memulai Frakti</a> untuk informasi lebih lanjut.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-00e1646f68aeb89f9722cf6f6cfcad94>2.2.2 - Menginstal Kubernetes dengan perkakas penyebaran</h1></div><div class=td-content><h1 id=pg-a16f59f325a17cdeed324d5c889f7f73>2.2.2.1 - Menyiapkan klaster dengan kubeadm</h1></div><div class=td-content><h1 id=pg-29e59491dd6118b23072dfe9ebb93323>2.2.2.1.1 - Menginstal kubeadm</h1><p><img src=/images/kubeadm-stacked-color.png align=right width=150px>Laman ini menunjukkan cara untuk menginstal <code>kubeadm</code>.
Untuk informasi mengenai cara membuat sebuah klaster dengan kubeadm setelah kamu melakukan proses instalasi ini, lihat laman <a href=/id/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/>Menggunakan kubeadm untuk Membuat Sebuah Klaster</a>.</p><h2 id=sebelum-kamu-memulai>Sebelum kamu memulai</h2><ul><li>Satu mesin atau lebih yang menjalankan:<ul><li>Ubuntu 16.04+</li><li>Debian 9+</li><li>CentOS 7</li><li>Red Hat Enterprise Linux (RHEL) 7</li><li>Fedora 25+</li><li>HypriotOS v1.0.1+</li><li>Container Linux (teruji pada versi 1800.6.0)</li></ul></li><li>2 GB RAM atau lebih per mesin (kurang dari nilai tersebut akan menyisakan sedikit ruang untuk
aplikasi-aplikasimu)</li><li>2 CPU atau lebih</li><li>Koneksi internet pada seluruh mesin pada klaster (kamu dapat menggunakan internet
publik ataupun pribadi)</li><li><em>Hostname</em> yang unik, alamat MAC, dan product_uuid untuk setiap Node. Lihat <a href=#memastikan-alamat-mac>di sini</a> untuk detail lebih lanjut.</li><li>Porta tertentu pada mesin. Lihat <a href=#memeriksa-porta-yang-dibutuhkan>di sini</a> untuk detail lebih lanjut.</li><li><em>Swap</em> dinonaktifkan. Kamu <strong>HARUS</strong> menonaktifkan <em>swap</em> agar kubelet dapat berfungsi dengan baik.</li></ul><h2 id=memastikan-alamat-mac>Memastikan alamat MAC dan product_uuid yang unik untuk setiap Node</h2><ul><li>Kamu bisa mendapatkan alamat MAC dari antarmuka jaringan menggunakan perintah <code>ip link</code> atau <code>ifconfig -a</code></li><li>product_uuid didapatkan dengan perintah <code>sudo cat /sys/class/dmi/id/product_uuid</code></li></ul><p>Sangat memungkinkan bagi perangkat keras untuk memiliki alamat yang unik, namun beberapa mesin virtual bisa memiliki
nilai yang identik. Kubernetes menggunakan nilai-nilai tersebut untuk mengidentifikasi Node-Node secara unik pada klaster.
Jika nilai-nilai tersebut tidak unik pada tiap Node, proses instalasi
bisa saja <a href=https://github.com/kubernetes/kubeadm/issues/31>gagal</a>.</p><h2 id=memeriksa-adaptor-jaringan>Memeriksa adaptor jaringan</h2><p>Jika kamu memiliki lebih dari satu adaptor jaringan, dan komponen Kubernetes tidak dapat dijangkau melalui rute bawaan (<em>default route</em>),
kami merekomendasikan kamu untuk menambahkan rute IP sehingga alamat-alamat klaster Kubernetes melewati adaptor yang tepat.</p><h2 id=membuat-iptables-melihat-bridged-traffic>Membuat iptables melihat <em>bridged traffic</em></h2><p>Agar iptables pada Node Linux dapat melihat <em>bridged traffic</em> dengan benar, kamu harus memastikan <code>net.bridge.bridge-nf-call-iptables</code> bernilai 1 pada pengaturan <code>sysctl</code>, misalnya.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF | sudo tee /etc/sysctl.d/k8s.conf
</span></span></span><span style=display:flex><span><span style=color:#b44>net.bridge.bridge-nf-call-ip6tables = 1
</span></span></span><span style=display:flex><span><span style=color:#b44>net.bridge.bridge-nf-call-iptables = 1
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span><span style=display:flex><span>sudo sysctl --system
</span></span></code></pre></div><p>Pastikan modul <code>br_netfilter</code> sudah dimuat sebelum melakukan langkah ini. Hal ini dilakukan dengan menjalankan <code>lsmod | grep br_netfilter</code>. Untuk memuatnya secara eksplisit gunakan <code>sudo modprobe br_netfilter</code>.</p><p>Untuk detail lebih lanjut, silakan lihat laman <a href=/id/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/#persyaratan-plugin-jaringan>Persyaratan <em>Plugin</em> Jaringan</a>.</p><h2 id=memeriksa-porta-yang-dibutuhkan>Memeriksa porta yang dibutuhkan</h2><h3 id=node-control-plane>Node <em>control-plane</em></h3><table><thead><tr><th>Protokol</th><th>Arah</th><th>Rentang Porta</th><th>Kegunaan</th><th>Digunakan oleh</th></tr></thead><tbody><tr><td>TCP</td><td>Inbound</td><td>6443*</td><td>Kubernetes API server</td><td>All</td></tr><tr><td>TCP</td><td>Inbound</td><td>2379-2380</td><td>etcd server client API</td><td>kube-apiserver, etcd</td></tr><tr><td>TCP</td><td>Inbound</td><td>10250</td><td>Kubelet API</td><td>Self, Control plane</td></tr><tr><td>TCP</td><td>Inbound</td><td>10251</td><td>kube-scheduler</td><td>Self</td></tr><tr><td>TCP</td><td>Inbound</td><td>10252</td><td>kube-controller-manager</td><td>Self</td></tr></tbody></table><h3 id=node-pekerja-worker>Node pekerja (<em>worker</em>)</h3><table><thead><tr><th>Protokol</th><th>Arah</th><th>Rentang Porta</th><th>Kegunaan</th><th>Digunakan oleh</th></tr></thead><tbody><tr><td>TCP</td><td>Inbound</td><td>10250</td><td>Kubelet API</td><td>Self, Control plane</td></tr><tr><td>TCP</td><td>Inbound</td><td>30000-32767</td><td>NodePort Services†</td><td>All</td></tr></tbody></table><p>† Jangkauan porta bawaan untuk <a href=/id/docs/concepts/services-networking/service/>Service NodePort</a>.</p><p>Angka porta yang ditandai dengan * dapat diganti (<em>overrideable</em>), sehingga kamu harus memastikan porta khusus lainnya yang kamu sediakan juga terbuka.</p><p>Meskipun porta etcd turut dituliskan pada Node <em>control-plane</em>, kamu juga bisa menghos klaster etcd-mu sendiri
secara eksternal atau pada porta <em>custom</em>.</p><p><em>Plugin</em> jaringan Pod yang kamu gunakan (lihat di bawah) juga mungkin membutuhkan porta tertentu untuk terbuka.
Karena hal ini dapat berbeda pada setiap <em>plugin</em> jaringan Pod, silakan lihat
dokumentasi <em>plugin</em> mengenai porta yang dibutuhkan.</p><h2 id=menginstal-runtime>Menginstal <em>runtime</em></h2><p>Untuk menjalankan Container pada Pod, Kubernetes menggunakan
<a class=glossary-tooltip title='Runtime Container adalah perangkat lunak yang bertanggung jawab untuk menjalankan Container.' data-toggle=tooltip data-placement=top href=/id/docs/setup/production-environment/container-runtimes target=_blank aria-label='_runtime_ Container'>_runtime_ Container</a>.</p><ul class="nav nav-tabs" id=container-runtime role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#container-runtime-0 role=tab aria-controls=container-runtime-0 aria-selected=true>Linux nodes</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#container-runtime-1 role=tab aria-controls=container-runtime-1>sistem operasi lainnya</a></li></ul><div class=tab-content id=container-runtime><div id=container-runtime-0 class="tab-pane show active" role=tabpanel aria-labelledby=container-runtime-0><p><p>Secara bawaan, Kubernetes menggunakan
<a class=glossary-tooltip title='Sebuah API untuk mengintegrasikan runtime Container dengan kubelet.' data-toggle=tooltip data-placement=top href=/id/docs/concepts/overview/components/#container-runtime target=_blank aria-label='Container Runtime Interface'>Container Runtime Interface</a> (CRI)
sebagai perantara dengan <em>runtime</em> Container pilihanmu.</p><p>Jika kamu tidak menentukan <em>runtime</em>, kubeadm secara otomatis mencoba untuk mendeteksi
<em>runtime</em> Container yang terinstal dengan memindai sekumpulan soket domain Unix yang umum digunakan.
Tabel berikut menunjukkan <em>runtime</em> Container dan lokasi soketnya:</p><table><caption style=display:none>_Runtime_ Container dan lokasi soketnya</caption><thead><tr><th><em>Runtime</em></th><th>Lokasi domain soket Unix</th></tr></thead><tbody><tr><td>Docker</td><td><code>/var/run/docker.sock</code></td></tr><tr><td>containerd</td><td><code>/run/containerd/containerd.sock</code></td></tr><tr><td>CRI-O</td><td><code>/var/run/crio/crio.sock</code></td></tr></tbody></table><br>Jika ditemukan Docker dan containerd secara bersamaan, Docker akan terpilih. Hal ini diperlukan
karena Docker 18.09 dirilis dengan containerd dan keduanya dapat ditemukan meskipun kamu
hanya menginstal Docker.
Jika ditemukan selain dari kedua _runtime_ Container tersebut, kubeadm akan berhenti dengan kegagalan.<p>Komponen kubelet berintegrasi dengan Docker melalui implementasi CRI <code>dockershim</code> bawaannya.</p><p>Lihat <a href=/id/docs/setup/production-environment/container-runtimes/><em>runtime</em> Container</a>
untuk informasi lebih lanjut.</p></div><div id=container-runtime-1 class=tab-pane role=tabpanel aria-labelledby=container-runtime-1><p><p>Secara bawaan, kubeadm menggunakan <a class=glossary-tooltip title='Docker merupakan suatu teknologi perangkat lunak yang menyediakan virtualisasi pada level sistem operasi yang juga dikenal sebagai Container.' data-toggle=tooltip data-placement=top href=https://docs.docker.com/engine/ target=_blank aria-label=Docker>Docker</a> sebagai <em>runtime</em> Container.
Komponen kubelet berintegrasi dengan Docker melalui implementasi CRI <code>dockershim</code> bawaannya.</p><p>Lihat <a href=/id/docs/setup/production-environment/container-runtimes/><em>runtime</em> Container</a>
untuk informasi lebih lanjut.</p></div></div><h2 id=menginstal-kubeadm-kubelet-dan-kubectl>Menginstal kubeadm, kubelet, dan kubectl</h2><p>Kamu akan menginstal <em>package</em> berikut pada semua mesinmu:</p><ul><li><p><code>kubeadm</code>: alat untuk mem-<em>bootstrap</em> klaster.</p></li><li><p><code>kubelet</code>: komponen yang berjalan pada seluruh mesin pada klaster
dan memiliki tugas seperti menjalankan Pod dan Container.</p></li><li><p><code>kubectl</code>: alat untuk berinteraksi dengan klastermu.</p></li></ul><p>Alat kubeadm <strong>tidak akan</strong> menginstal atau mengelola <code>kubelet</code> ataupun <code>kubectl</code> untukmu, jadi kamu harus memastikan
keduanya memiliki versi yang cocok dengan <em>control plane</em> Kubernetes yang akan kamu instal
dengan kubeadm. Jika tidak, ada risiko <em>version skew</em> yang dapat terjadi dan
dapat berujung pada perangai yang bermasalah dan tidak terduga. Namun, <em>satu</em> <em>version skew</em> minor antara
kubelet dan <em>control plane</em> masih diperbolehkan, tetapi versi kubelet tidak boleh melebihi versi API
Server. Sebagai contoh, kubelet yang berjalan pada versi 1.7.0 akan kompatibel dengan API Server versi 1.8.0, tetapi tidak sebaliknya.</p><p>Untuk informasi mengenai instalasi <code>kubectl</code>, lihat <a href=/id/docs/tasks/tools/install-kubectl/>Menginstal dan mengatur kubectl</a>.</p><div class="alert alert-danger warning callout" role=alert><strong>Peringatan:</strong> Instruksi ini membuat seluruh <em>package</em> Kubernetes keluar dari <em>system upgrade</em>.
Hal ini karena kubeadm dan Kubernetes membutuhkan
<a href=/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade/>perhatian khusus untuk pembaharuan</a>.</div><p>Untuk informasi lebih lanjut mengenai <em>version skew</em>, lihat:</p><ul><li><a href=/docs/setup/release/version-skew-policy/>Kebijakan <em>version-skew</em> dan versi Kubernetes</a></li><li><a href=/id/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/#version-skew-policy>Kebijakan <em>version skew</em></a> yang spesifik untuk kubeadm</li></ul><ul class="nav nav-tabs" id=k8s-install role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#k8s-install-0 role=tab aria-controls=k8s-install-0 aria-selected=true>Ubuntu, Debian atau HypriotOS</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#k8s-install-1 role=tab aria-controls=k8s-install-1>CentOS, RHEL atau Fedora</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#k8s-install-2 role=tab aria-controls=k8s-install-2>Container Linux</a></li></ul><div class=tab-content id=k8s-install><div id=k8s-install-0 class="tab-pane show active" role=tabpanel aria-labelledby=k8s-install-0><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo apt-get update <span style=color:#666>&amp;&amp;</span> sudo apt-get install -y apt-transport-https curl
</span></span><span style=display:flex><span>curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key add -
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF | sudo tee /etc/apt/sources.list.d/kubernetes.list
</span></span></span><span style=display:flex><span><span style=color:#b44>deb https://apt.kubernetes.io/ kubernetes-xenial main
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span><span style=display:flex><span>sudo apt-get update
</span></span><span style=display:flex><span>sudo apt-get install -y kubelet kubeadm kubectl
</span></span><span style=display:flex><span>sudo apt-mark hold kubelet kubeadm kubectl
</span></span></code></pre></div></div><div id=k8s-install-1 class=tab-pane role=tabpanel aria-labelledby=k8s-install-1><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo
</span></span></span><span style=display:flex><span><span style=color:#b44>[kubernetes]
</span></span></span><span style=display:flex><span><span style=color:#b44>name=Kubernetes
</span></span></span><span style=display:flex><span><span style=color:#b44>baseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-\$basearch
</span></span></span><span style=display:flex><span><span style=color:#b44>enabled=1
</span></span></span><span style=display:flex><span><span style=color:#b44>gpgcheck=1
</span></span></span><span style=display:flex><span><span style=color:#b44>repo_gpgcheck=1
</span></span></span><span style=display:flex><span><span style=color:#b44>gpgkey=https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg
</span></span></span><span style=display:flex><span><span style=color:#b44>exclude=kubelet kubeadm kubectl
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Mengatur SELinux menjadi permissive mode (menonaktifkannya secara efektif)</span>
</span></span><span style=display:flex><span>setenforce <span style=color:#666>0</span>
</span></span><span style=display:flex><span>sed -i <span style=color:#b44>&#39;s/^SELINUX=enforcing$/SELINUX=permissive/&#39;</span> /etc/selinux/config
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>yum install -y kubelet kubeadm kubectl --disableexcludes<span style=color:#666>=</span>kubernetes
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>systemctl <span style=color:#a2f>enable</span> --now kubelet
</span></span></code></pre></div><p><strong>Catatan:</strong></p><ul><li><p>Mengatur SELinux menjadi <em>permissive mode</em> dengan menjalankan <code>setenforce 0</code> dan <code>sed ...</code> menonaktifkannya secara efektif.
Hal ini diperlukan untuk mengizinkan Container untuk mengakses <em>filesystem</em> hos, yang dibutuhkan untuk jaringan Pod sebagai contoh.
Kamu harus melakukan ini sampai dukungan SELinux ditingkatkan pada kubelet.</p></li><li><p>Kamu dapat membiarkan SELinux aktif jika kamu mengetahui cara mengonfigurasinya, tetapi hal tersebut mungkin membutuhkan pengaturan yang tidak didukung oleh kubeadm.</p></li></ul></div><div id=k8s-install-2 class=tab-pane role=tabpanel aria-labelledby=k8s-install-2><p><p>Menginstal <em>plugin</em> CNI (dibutuhkan untuk kebanyakan jaringan Pod):</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#b8860b>CNI_VERSION</span><span style=color:#666>=</span><span style=color:#b44>&#34;v0.8.2&#34;</span>
</span></span><span style=display:flex><span><span style=color:#b8860b>ARCH</span><span style=color:#666>=</span><span style=color:#b44>&#34;amd64&#34;</span>
</span></span><span style=display:flex><span>mkdir -p /opt/cni/bin
</span></span><span style=display:flex><span>curl -L <span style=color:#b44>&#34;https://github.com/containernetworking/plugins/releases/download/</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>CNI_VERSION</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>/cni-plugins-linux-</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>ARCH</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>-</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>CNI_VERSION</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>.tgz&#34;</span> | tar -C /opt/cni/bin -xz
</span></span></code></pre></div><p>Menginstal crictl (dibutuhkan untuk kubeadm / Kubelet Container Runtime Interface (CRI))</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#b8860b>CRICTL_VERSION</span><span style=color:#666>=</span><span style=color:#b44>&#34;v1.22.0&#34;</span>
</span></span><span style=display:flex><span><span style=color:#b8860b>ARCH</span><span style=color:#666>=</span><span style=color:#b44>&#34;amd64&#34;</span>
</span></span><span style=display:flex><span>mkdir -p /opt/bin
</span></span><span style=display:flex><span>curl -L <span style=color:#b44>&#34;https://github.com/kubernetes-sigs/cri-tools/releases/download/</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>CRICTL_VERSION</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>/crictl-</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>CRICTL_VERSION</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>-linux-</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>ARCH</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>.tar.gz&#34;</span> | sudo tar -C <span style=color:#b8860b>$DOWNLOAD_DIR</span> -xz
</span></span></code></pre></div><p>Menginstal <code>kubeadm</code>, <code>kubelet</code>, <code>kubectl</code> dan menambahkan <em>systemd service</em> <code>kubelet</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#b8860b>RELEASE</span><span style=color:#666>=</span><span style=color:#b44>&#34;</span><span style=color:#a2f;font-weight:700>$(</span>curl -sSL https://dl.k8s.io/release/stable.txt<span style=color:#a2f;font-weight:700>)</span><span style=color:#b44>&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>mkdir -p /opt/bin
</span></span><span style=display:flex><span><span style=color:#b8860b>ARCH</span><span style=color:#666>=</span><span style=color:#b44>&#34;amd64&#34;</span>
</span></span><span style=display:flex><span><span style=color:#a2f>cd</span> /opt/bin
</span></span><span style=display:flex><span>curl -L --remote-name-all https://storage.googleapis.com/kubernetes-release/release/<span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>RELEASE</span><span style=color:#b68;font-weight:700>}</span>/bin/linux/<span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>ARCH</span><span style=color:#b68;font-weight:700>}</span>/<span style=color:#666>{</span>kubeadm,kubelet,kubectl<span style=color:#666>}</span>
</span></span><span style=display:flex><span>chmod +x <span style=color:#666>{</span>kubeadm,kubelet,kubectl<span style=color:#666>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#b8860b>RELEASE_VERSION</span><span style=color:#666>=</span><span style=color:#b44>&#34;v0.2.7&#34;</span>
</span></span><span style=display:flex><span>curl -sSL <span style=color:#b44>&#34;https://raw.githubusercontent.com/kubernetes/release/</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>RELEASE_VERSION</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>/cmd/kubepkg/templates/latest/deb/kubelet/lib/systemd/system/kubelet.service&#34;</span> | sed <span style=color:#b44>&#34;s:/usr/bin:/opt/bin:g&#34;</span> &gt; /etc/systemd/system/kubelet.service
</span></span><span style=display:flex><span>mkdir -p /etc/systemd/system/kubelet.service.d
</span></span><span style=display:flex><span>curl -sSL <span style=color:#b44>&#34;https://raw.githubusercontent.com/kubernetes/release/</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>RELEASE_VERSION</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>/cmd/kubepkg/templates/latest/deb/kubeadm/10-kubeadm.conf&#34;</span> | sed <span style=color:#b44>&#34;s:/usr/bin:/opt/bin:g&#34;</span> &gt; /etc/systemd/system/kubelet.service.d/10-kubeadm.conf
</span></span></code></pre></div><p>Mengaktifkan dan menjalankan <code>kubelet</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>systemctl <span style=color:#a2f>enable</span> --now kubelet
</span></span></code></pre></div></div></div><p>Sekarang kubelet akan melakukan <em>restart</em> setiap beberapa detik, sambil menunggu dalam kondisi <em>crashloop</em> sampai kubeadm memberikan instruksi yang harus dilakukan.</p><h2 id=mengonfigurasi-cgroup-untuk-kubelet-pada-node-control-plane>Mengonfigurasi <em>driver</em> cgroup yang digunakan oleh kubelet pada Node <em>control-plane</em></h2><p>Ketika menggunakan Docker, kubeadm akan mendeteksi secara otomatis <em>driver</em> cgroup untuk kubelet
dan mengaturnya pada berkas <code>/var/lib/kubelet/config.yaml</code> pada saat <em>runtime</em>.</p><p>Jika kamu menggunakan CRI yang berbeda, kamu harus memodifikasi berkasnya dengan nilai <code>cgroupDriver</code> yang kamu gunakan, seperti berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubelet.config.k8s.io/v1beta1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>KubeletConfiguration<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>cgroupDriver</span>:<span style=color:#bbb> </span>&lt;value&gt;<span style=color:#bbb>
</span></span></span></code></pre></div><p>Harap diperhatikan, kamu <strong>hanya</strong> perlu melakukannya jika <em>driver</em> cgroup dari CRI pilihanmu
bukanlah <code>cgroupfs</code>, karena nilai tersebut merupakan nilai bawaan yang digunakan oleh kubelet.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Karena opsi <code>--cgroup-driver</code> sudah dihilangkan pada kubelet, jika kamu memilikinya pada <code>/var/lib/kubelet/kubeadm-flags.env</code>
atau <code>/etc/default/kubelet</code>(<code>/etc/sysconfig/kubelet</code> untuk RPM), silakan hapus dan gunakan KubeletConfiguration
(secara bawaan disimpan di <code>/var/lib/kubelet/config.yaml</code>).</div><p>Kamu harus melakukan <em>restart</em> pada kubelet:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo systemctl daemon-reload
</span></span><span style=display:flex><span>sudo systemctl restart kubelet
</span></span></code></pre></div><p>Deteksi <em>driver</em> cgroup secara otomatis untuk <em>runtime</em> Container lainnya
seperti CRI-O dan containerd masih dalam proses pengembangan.</p><h2 id=penyelesaian-masalah>Penyelesaian masalah</h2><p>Jika kamu menemui kesulitan dengan kubeadm, silakan merujuk pada <a href=/docs/setup/production-environment/tools/kubeadm/troubleshooting-kubeadm/>dokumen penyelesaian masalah</a>.</p><h2 id=selanjutnya>Selanjutnya</h2><ul><li><a href=/id/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/>Menggunakan kubeadm untuk Membuat Sebuah Klaster</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-134ed1f6142a98e6ac681a1ba4920e53>2.2.2.1.2 - Membuat sebuah klaster dengan control-plane tunggal menggunakan kubeadm</h1><p>Perkakas <img src=/images/kubeadm-stacked-color.png align=right width=150px><code>kubeadm</code> membantu kamu membuat sebuah klaster Kubernetes minimum yang layak dan sesuai dengan <em>best practice</em>. Bahkan, kamu dapat menggunakan <code>kubeadm</code> untuk membuat sebuah klaster yang lolos <a href=https://kubernetes.io/blog/2017/10/software-conformance-certification>uji Kubernetes Conformance</a>.<br><code>kubeadm</code> juga mendukung fungsi siklus hidup (<em>lifecycle</em>)
klaster lainnya, seperti <a href=/docs/reference/access-authn-authz/bootstrap-tokens/><em>bootstrap token</em></a> dan pembaruan klaster (<em>cluster upgrade</em>).</p><p><code>kubeadm</code> merupakan perkakas yang bagus jika kamu membutuhkan:</p><ul><li>Sebuah cara yang sederhana untuk kamu mencoba Kubernetes, mungkin untuk pertama kalinya.</li><li>Sebuah cara bagi pengguna lama (<em>existing users</em>) untuk mengotomatiskan penyetelan sebuah klaster dan menguji aplikasi mereka.</li><li>Sebuah komponen dasar pada ekosistem lain dan/atau perkakas penginstal lain dengan cakupan
yang lebih luas.</li></ul><p>Kamu dapat menginstal dan menggunakan <code>kubeadm</code> pada berbagai macam mesin: laptop milikmu, sekelompok
server di <em>cloud</em>, sebuah Raspberry Pi, dan lain-lain. Baik itu men-<em>deploy</em> pada
<em>cloud</em> ataupun <em>on-premise</em>, kamu dapat mengintegrasikan <code>kubeadm</code> pada sistem <em>provisioning</em> seperti
Ansible atau Terraform.</p><h2 id=sebelum-kamu-memulai>Sebelum kamu memulai</h2><p>Untuk mengikuti panduan ini, kamu membutuhkan:</p><ul><li>Satu mesin atau lebih, yang menjalankan sistem operasi Linux yang kompatibel dengan deb atau rpm; sebagai contoh: Ubuntu atau CentOS.</li><li>2 GiB atau lebih RAM per mesin--kurang dari nilai tersebut akan menyisakan sedikit ruang untuk
aplikasi-aplikasimu.</li><li>Sedikitnya 2 CPU pada mesin yang akan kamu gunakan sebagai Node <em>control-plane</em>.</li><li>Koneksi internet pada seluruh mesin pada klaster. Kamu dapat menggunakan internet
publik ataupun pribadi.</li></ul><p>Kamu juga harus menggunakan versi <code>kubeadm</code> yang dapat men-<em>deploy</em> versi
Kubernetes yang ingin kamu gunakan pada klaster barumu.</p><p><a href=https://kubernetes.io/docs/setup/release/version-skew-policy/#supported-versions>Kebijakan dukungan versi Kubernetes dan <em>version skew</em></a> juga berlaku pada <code>kubeadm</code> dan Kubernetes secara umum.
Periksa kebijakan tersebut untuk mempelajari tentang versi Kubernetes dan <code>kubeadm</code>
mana saja yang didukung. Laman ini ditulis untuk Kubernetes v1.25.</p><p>Fitur <code>kubeadm</code> secara umum berstatus <em>General Availability</em> (GA). Beberapa sub-fitur sedang
berada dalam pengembangan. Implementasi pembuatan klaster dapat berubah
sedikit seiring dengan berevolusinya kubeadm, namun secara umum implementasinya sudah cukup stabil.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Semua perintah di dalam <code>kubeadm alpha</code>, sesuai definisi, didukung pada level <em>alpha</em>.</div><h2 id=tujuan>Tujuan</h2><ul><li>Menginstal Kubernetes klaster dengan <em>control-plane</em> tunggal atau <a href=/docs/setup/production-environment/tools/kubeadm/high-availability/>klaster dengan ketersediaan tinggi</a></li><li>Menginstal jaringan Pod pada klaster sehingga Pod dapat
berinteraksi satu sama lain</li></ul><h2 id=instruksi>Instruksi</h2><h3 id=menginstal-kubeadm-pada-hos>Menginstal kubeadm pada hos</h3><p>Lihat <a href=/id/docs/setup/production-environment/tools/kubeadm/install-kubeadm/>"Menginstal kubeadm"</a>.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong><p>Jika kamu sudah menginstal kubeadm sebelumnya, jalankan <code>apt-get update && apt-get upgrade</code> atau <code>yum update</code> untuk mendapatkan versi kubeadm paling baru.</p><p>Ketika kamu melakukan pembaruan, kubelet melakukan <em>restart</em> setiap beberapa detik sambil menunggu dalam kondisi <em>crashloop</em> sampai
kubeadm memberikan perintah yang harus dilakukan. <em>Crashloop</em> ini memang diantisipasi dan normal.
Setelah kamu menginisialisasi <em>control-plane</em>, kubelet akan berjalan normal.</p></div><h3 id=menginisialisasi-node-control-plane>Menginisialisasi Node <em>control-plane</em></h3><p>Node <em>control-plane</em> adalah mesin dimana komponen-komponen <em>control plane</em> berjalan, termasuk
<a class=glossary-tooltip title='Penyimpanan key value konsisten yang digunakan sebagai penyimpanan data klaster Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/tasks/administer-cluster/configure-upgrade-etcd/ target=_blank aria-label=etcd>etcd</a> (basis data klaster) dan
<a class=glossary-tooltip title='Komponen control plane yang mengekspos API Kubernetes. Merupakan front-end dari control plane Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-apiserver/ target=_blank aria-label='API Server'>API Server</a>
(yang akan berkomunikasi dengan perkakas <em>command line</em> <a class=glossary-tooltip title='Sebuah utilitas baris perintah untuk berkomunikasi dengan suatu server API Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/user-guide/kubectl-overview/ target=_blank aria-label=kubectl>kubectl</a>.</p><ol><li>(Direkomendasikan) Jika kamu berencana untuk memperbarui klaster <code>kubeadm</code> dengan <em>control-plane</em> tunggal
menjadi ketersediaan tinggi kamu harus menentukan <code>--control-plane-endpoint</code> agar mengarah ke <em>endpoint</em> yang digunakan bersama
untuk semua Node <em>control-plane</em>. <em>Endpoint</em> tersebut dapat berupa nama DNS atau sebuah alamat IP dari <em>load-balancer</em>.</li><li>Pilih <em>add-on</em> jaringan Pod, dan pastikan apakah diperlukan argumen untuk
diberikan pada <code>kubeadm init</code>. Tergantung
penyedia pihak ketiga yang kamu pilih, kamu mungkin harus mengatur <code>--pod-network-cidr</code> dengan nilai
yang spesifik pada penyedia tertentu. Lihat <a href=#jaringan-pod>Menginstal <em>add-on</em> jaringan Pod</a>.</li><li>(Opsional) Sejak versi 1.14, <code>kubeadm</code> mencoba untuk mendeteksi <em>runtime</em> kontainer pada Linux
dengan menggunakan daftar <em>domain socket path</em> yang umum diketahui. Untuk menggunakan <em>runtime</em> kontainer yang berbeda atau
jika ada lebih dari satu yang terpasang pada Node yang digunakan, tentukan argumen <code>--cri-socket</code>
pada <code>kubeadm init</code>. Lihat <a href=/id/docs/setup/production-environment/tools/kubeadm/install-kubeadm/#installing-runtime>Menginstal <em>runtime</em></a>.</li><li>(Opsional) Kecuali ditentukan sebelumnya, <code>kubeadm</code> akan menggunakan antarmuka jaringan yang diasosiasikan
dengan <em>default gateway</em> untuk mengatur alamat <em>advertise</em> untuk API Server pada Node <em>control-plane</em> ini.
Untuk menggunakan antarmuka jaringan yang berbeda, tentukan argumen <code>--apiserver-advertise-address=&lt;ip-address></code>
pada <code>kubeadm init</code>. Untuk men-<em>deploy</em> klaster Kubernetes IPv6 menggunakan pengalamatan IPv6, kamu
harus menentukan alamat IPv6, sebagai contoh <code>--apiserver-advertise-address=fd00::101</code></li><li>(Opsional) Jalankan <code>kubeadm config images pull</code> sebelum <code>kubeadm init</code> untuk memastikan
konektivitas ke <em>container image registry</em> gcr.io.</li></ol><p>Untuk menginisialisasi Node <em>control-plane</em> jalankan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubeadm init &lt;args&gt;
</span></span></code></pre></div><h3 id=pertimbangan-mengenai-apiserver-advertise-address-dan-controlplaneendpoint>Pertimbangan mengenai apiserver-advertise-address dan ControlPlaneEndpoint</h3><p>Meski <code>--apiserver-advertise-address</code> dapat digunakan untuk mengatur alamat <em>advertise</em> untuk server
API pada Node <em>control-plane</em> ini, <code>--control-plane-endpoint</code> dapat digunakan untuk mengatur <em>endpoint</em> yang digunakan bersama
untuk seluruh Node <em>control-plane</em>.</p><p><code>--control-plane-endpoint</code> tidak hanya mengizinkan alamat IP tetapi juga nama DNS yang dapat dipetakan ke alamat IP.
Silakan hubungi administrator jaringan kamu untuk mengevaluasi solusi-solusi yang mempertimbangkan pemetaan tersebut.</p><p>Berikut contoh pemetaannya:</p><pre tabindex=0><code>192.168.0.102 cluster-endpoint
</code></pre><p>Di mana <code>192.168.0.102</code> merupakan alamat IP dari Node ini dan <code>cluster-endpoint</code> merupakan nama DNS <em>custom</em> yang dipetakan pada IP ini.
Hal ini memungkinkan kamu untuk memberikan <code>--control-plane-endpoint=cluster-endpoint</code> pada <code>kubeadm init</code> dan memberikan nama DNS yang sama pada
<code>kubeadm join</code>. Kemudian kamu dapat memodifikasi <code>cluster-endpoint</code> untuk mengarah pada alamat <em>load-balancer</em> dalam skenario
ketersediaan tinggi (<em>highly availabile</em>).</p><p>Mengubah klaster <em>control plane</em> tunggal yang dibuat tanpa <code>--control-plane-endpoint</code> menjadi klaster dengan ketersediaan tinggi
tidak didukung oleh kubeadm.</p><h3 id=informasi-lebih-lanjut>Informasi lebih lanjut</h3><p>Untuk informasi lebih lanjut mengenai argumen-argumen <code>kubeadm init</code>, lihat <a href=/docs/reference/setup-tools/kubeadm/>panduan referensi kubeadm</a>.</p><p>Untuk daftar pengaturan konfigurasi yang lengkap, lihat <a href=/docs/reference/setup-tools/kubeadm/kubeadm-init/#config-file>dokumentasi berkas konfigurasi</a>.</p><p>Untuk menyetel komponen-komponen <em>control plane</em>, termasuk pemasangan IPv6 opsional pada <em>liveness probe</em> untuk komponen-komponen <em>control plane</em> dan server etcd, berikan argumen ekstra pada tiap komponen seperti yang didokumentasikan pada <a href=/docs/setup/production-environment/tools/kubeadm/control-plane-flags/>argumen-argumen <em>custom</em></a>.</p><p>Untuk menjalankan <code>kubeadm init</code> lagi, sebelumnya kamu harus <a href=#pembongkaran>membongkar klaster</a>.</p><p>Jika kamu menggabungkan sebuah Node dengan arsitektur yang berbeda ke klastermu, pastikan DaemonSets yang di_deploy_
memiliki <em>image</em> kontainer yang mendukung arsitektur tersebut.</p><p>Pertama-tama <code>kubeadm init</code> akan menjalankan sekumpulan <em>precheck</em> untuk memastikan mesin
siap untuk menjalankan Kubernetes. Kumpulan <em>precheck</em> ini menunjukkan peringatan-peringatan dan akan berhenti jika terjadi kesalahan. Kemudian <code>kubeadm init</code>
akan mengunduh dan menginstal komponen-komponen <em>control plane</em> klaster. Hal ini membutuhkan waktu beberapa menit.
Keluaran yang dihasilkan terlihat seperti berikut ini:</p><pre tabindex=0><code class=language-none data-lang=none>[init] Using Kubernetes version: vX.Y.Z
[preflight] Running pre-flight checks
[preflight] Pulling images required for setting up a Kubernetes cluster
[preflight] This might take a minute or two, depending on the speed of your internet connection
[preflight] You can also perform this action in beforehand using &#39;kubeadm config images pull&#39;
[kubelet-start] Writing kubelet environment file with flags to file &#34;/var/lib/kubelet/kubeadm-flags.env&#34;
[kubelet-start] Writing kubelet configuration to file &#34;/var/lib/kubelet/config.yaml&#34;
[kubelet-start] Activating the kubelet service
[certs] Using certificateDir folder &#34;/etc/kubernetes/pki&#34;
[certs] Generating &#34;etcd/ca&#34; certificate and key
[certs] Generating &#34;etcd/server&#34; certificate and key
[certs] etcd/server serving cert is signed for DNS names [kubeadm-cp localhost] and IPs [10.138.0.4 127.0.0.1 ::1]
[certs] Generating &#34;etcd/healthcheck-client&#34; certificate and key
[certs] Generating &#34;etcd/peer&#34; certificate and key
[certs] etcd/peer serving cert is signed for DNS names [kubeadm-cp localhost] and IPs [10.138.0.4 127.0.0.1 ::1]
[certs] Generating &#34;apiserver-etcd-client&#34; certificate and key
[certs] Generating &#34;ca&#34; certificate and key
[certs] Generating &#34;apiserver&#34; certificate and key
[certs] apiserver serving cert is signed for DNS names [kubeadm-cp kubernetes kubernetes.default kubernetes.default.svc kubernetes.default.svc.cluster.local] and IPs [10.96.0.1 10.138.0.4]
[certs] Generating &#34;apiserver-kubelet-client&#34; certificate and key
[certs] Generating &#34;front-proxy-ca&#34; certificate and key
[certs] Generating &#34;front-proxy-client&#34; certificate and key
[certs] Generating &#34;sa&#34; key and public key
[kubeconfig] Using kubeconfig folder &#34;/etc/kubernetes&#34;
[kubeconfig] Writing &#34;admin.conf&#34; kubeconfig file
[kubeconfig] Writing &#34;kubelet.conf&#34; kubeconfig file
[kubeconfig] Writing &#34;controller-manager.conf&#34; kubeconfig file
[kubeconfig] Writing &#34;scheduler.conf&#34; kubeconfig file
[control-plane] Using manifest folder &#34;/etc/kubernetes/manifests&#34;
[control-plane] Creating static Pod manifest for &#34;kube-apiserver&#34;
[control-plane] Creating static Pod manifest for &#34;kube-controller-manager&#34;
[control-plane] Creating static Pod manifest for &#34;kube-scheduler&#34;
[etcd] Creating static Pod manifest for local etcd in &#34;/etc/kubernetes/manifests&#34;
[wait-control-plane] Waiting for the kubelet to boot up the control plane as static Pods from directory &#34;/etc/kubernetes/manifests&#34;. This can take up to 4m0s
[apiclient] All control plane components are healthy after 31.501735 seconds
[uploadconfig] storing the configuration used in ConfigMap &#34;kubeadm-config&#34; in the &#34;kube-system&#34; Namespace
[kubelet] Creating a ConfigMap &#34;kubelet-config-X.Y&#34; in namespace kube-system with the configuration for the kubelets in the cluster
[patchnode] Uploading the CRI Socket information &#34;/var/run/dockershim.sock&#34; to the Node API object &#34;kubeadm-cp&#34; as an annotation
[mark-control-plane] Marking the node kubeadm-cp as control-plane by adding the label &#34;node-role.kubernetes.io/master=&#39;&#39;&#34;
[mark-control-plane] Marking the node kubeadm-cp as control-plane by adding the taints [node-role.kubernetes.io/master:NoSchedule]
[bootstrap-token] Using token: &lt;token&gt;
[bootstrap-token] Configuring bootstrap tokens, cluster-info ConfigMap, RBAC Roles
[bootstraptoken] configured RBAC rules to allow Node Bootstrap tokens to post CSRs in order for nodes to get long term certificate credentials
[bootstraptoken] configured RBAC rules to allow the csrapprover controller automatically approve CSRs from a Node Bootstrap Token
[bootstraptoken] configured RBAC rules to allow certificate rotation for all node client certificates in the cluster
[bootstraptoken] creating the &#34;cluster-info&#34; ConfigMap in the &#34;kube-public&#34; namespace
[addons] Applied essential addon: CoreDNS
[addons] Applied essential addon: kube-proxy

Your Kubernetes control-plane has initialized successfully!

To start using your cluster, you need to run the following as a regular user:

  mkdir -p $HOME/.kube
  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config
  sudo chown $(id -u):$(id -g) $HOME/.kube/config

You should now deploy a Pod network to the cluster.
Run &#34;kubectl apply -f [podnetwork].yaml&#34; with one of the options listed at:
  /docs/concepts/cluster-administration/addons/

You can now join any number of machines by running the following on each node
as root:

  kubeadm join &lt;control-plane-host&gt;:&lt;control-plane-port&gt; --token &lt;token&gt; --discovery-token-ca-cert-hash sha256:&lt;hash&gt;
</code></pre><p>Untuk membuat kubectl bekerja bagi pengguna <em>non-root</em>, jalankan perintah-perintah berikut, yang juga merupakan
bagian dari keluaran <code>kubeadm init</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>mkdir -p <span style=color:#b8860b>$HOME</span>/.kube
</span></span><span style=display:flex><span>sudo cp -i /etc/kubernetes/admin.conf <span style=color:#b8860b>$HOME</span>/.kube/config
</span></span><span style=display:flex><span>sudo chown <span style=color:#a2f;font-weight:700>$(</span>id -u<span style=color:#a2f;font-weight:700>)</span>:<span style=color:#a2f;font-weight:700>$(</span>id -g<span style=color:#a2f;font-weight:700>)</span> <span style=color:#b8860b>$HOME</span>/.kube/config
</span></span></code></pre></div><p>Secara alternatif, jika kamu adalah pengguna <code>root</code>, kamu dapat menjalankan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#a2f>export</span> <span style=color:#b8860b>KUBECONFIG</span><span style=color:#666>=</span>/etc/kubernetes/admin.conf
</span></span></code></pre></div><p>Buatlah catatan dari perintah <code>kubeadm join</code> yang dihasilkan <code>kubeadm init</code>. Kamu
membutuhkan perintah ini untuk <a href=#menggabungkan-node>menggabungkan Node-Node ke klaster</a>.</p><p><em>Token</em> digunakan untuk otentikasi bersama (<em>mutual authentication</em>) antara Node <em>control-plane</em> dan Node-Node yang
akan bergabung. <em>Token</em> yang didapat di sini bersifat rahasia. Simpan dengan aman, karena siapapun yang memiliki token tersebut
dapat menambahkan Node-Node yang dapat mengotentikasikan diri ke klaster. Kamu dapat menampilkan daftar <em>token</em>,
membuat, dan menghapus <em>token</em> dengan perintah <code>kubeadm token</code>. Lihat
<a href=/docs/reference/setup-tools/kubeadm/kubeadm-token/>panduan referensi kubeadm</a>.</p><h3 id=jaringan-pod>Menginstal <em>add-on</em> jaringan Pod</h3><div class="alert alert-warning caution callout" role=alert><strong>Perhatian:</strong><p>Bagian ini berisi informasi penting mengenai penyetelan jejaring dan
urutan <em>deployment</em>.
Baca seluruh saran ini dengan saksama sebelum melanjutkan.</p><p><strong>Kamu harus men-<em>deploy</em>
<em>add-on</em> jaringan Pod berbasis <a class=glossary-tooltip title='Container network interface (CNI) plugins are a type of Network plugin that adheres to the appc/CNI specification.' data-toggle=tooltip data-placement=top href=/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/ target=_blank aria-label='_Container Network Interface_'><em>Container Network Interface</em></a>
(CNI) sehingga Pod dapat berkomunikasi satu sama lain.<br>DNS klaster (CoreDNS) tidak akan menyala sebelum jaringan dipasangkan.</strong></p><ul><li><p>Perlu diperhatikan bahwa jaringan Pod tidak boleh tumpang tindih dengan jaringan hos
manapun: kamu akan menemui beberapa masalah jika terjadi tumpang tindih.<br>(Jika kamu menemukan adanya bentrokan antara jaringan Pod
pilihan <em>plugin</em> jaringan dengan jaringan hos, kamu harus memikirkan blok
CIDR yang cocok untuk digunakan, kemudian menggunakannya pada saat <code>kubeadm init</code> dengan
<code>--pod-network-cidr</code>, atau sebagai penggantinya pada YAML <em>plugin</em> jaringan kamu).</p></li><li><p>Secara bawaan, <code>kubeadm</code> mengatur klastermu untuk menggunakan dan melaksanakan penggunaan
<a href=/id/docs/reference/access-authn-authz/rbac/>RBAC</a> (<em>role based access control</em>).<br>Pastikan <em>plugin</em> jaringan Pod mendukung RBAC, dan begitu juga seluruh manifes
yang kamu gunakan untuk men-<em>deploy</em>-nya.</p></li><li><p>Jika kamu ingin menggunakan IPv6--baik jaringan <em>dual-stack</em>, ataupun jaringan <em>single-stack</em> IPv6
--untuk klastermu, pastikan <em>plugin</em> jaringan Pod
mendukung IPv6.<br>Dukungan IPv6 telah ditambahkan pada CNI sejak <a href=https://github.com/containernetworking/cni/releases/tag/v0.6.0>v0.6.0</a>.</p></li></ul></div><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Saat ini Calico adalah satu-satunya <em>plugin</em> CNI yang dapat menerima uji e2e (<em>end-to-end</em>) oleh proyek kubeadm.
Jika kamu menemukan isu terkait <em>plugin</em> CNI kamu harus membuat tiket pada pelacak isu masing-masing <em>plugin</em>,
bukan pada pelacak isu kubeadm maupun kubernetes.</div><p>Beberapa proyek eksternal menyediakan jaringan Pod Kubernetes menggunakan CNI, beberapa di antaranya juga
mendukung <a href=/docs/concepts/services-networking/networkpolicies/>Network Policy</a>.</p><p>Lihat daftar
<a href=https://kubernetes.io/docs/concepts/cluster-administration/addons/#networking-and-network-policy><em>add-on</em> jejaring dan <em>network policy</em></a> yang tersedia.</p><p>Kamu dapat menginstal <em>add-on</em> jaringan Pod dengan perintah berikut pada Node
<em>control-plane</em> atau Node yang memiliki kredensial kubeconfig:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl apply -f &lt;add-on.yaml&gt;
</span></span></code></pre></div><p>Kamu hanya dapat menginstal satu jaringan Pod per klaster.
Di bawah ini kamu dapat menemukan instruksi instalasi untuk beberapa <em>plugin</em> jaringan Pod yang populer:</p><ul class="nav nav-tabs" id=tabs-pod-install role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tabs-pod-install-0 role=tab aria-controls=tabs-pod-install-0 aria-selected=true>Calico</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tabs-pod-install-1 role=tab aria-controls=tabs-pod-install-1>Cilium</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tabs-pod-install-2 role=tab aria-controls=tabs-pod-install-2>Contiv-VPP</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tabs-pod-install-3 role=tab aria-controls=tabs-pod-install-3>Kube-router</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tabs-pod-install-4 role=tab aria-controls=tabs-pod-install-4>Weave Net</a></li></ul><div class=tab-content id=tabs-pod-install><div id=tabs-pod-install-0 class="tab-pane show active" role=tabpanel aria-labelledby=tabs-pod-install-0><p><p><a href=https://docs.projectcalico.org/latest/introduction/>Calico</a> merupakan penyedia jejaring dan <em>network policy</em>. Calico mendukung sekumpulan opsi jejaring yang fleksibel sehingga kamu dapat memilih opsi yang paling efisien untuk situasimu, termasuk jaringan <em>non-overlay</em> dan <em>overlay</em>, dengan atau tanpa BGP. Calico menggunakan mesin yang sama untuk melaksanakan <em>network policy</em> pada hos, Pod, dan (jika menggunakan Istio & Envoy) aplikasi yang berada pada lapisan <em>service mesh</em>. Calico bekerja pada beberapa arsitektur, meliputi <code>amd64</code>, <code>arm64</code>, dan <code>ppc64le</code>.</p><p>Secara bawaan, Calico menggunakan <code>192.168.0.0/16</code> sebagai CIDR jaringan Pod, namun hal ini dapat diatur pada berkas calico.yaml. Agar Calico dapat bekerja dengan benar, kamu perlu memberikan CIDR yang sama pada perintah <code>kubeadm init</code> menggunakan opsi <code>--pod-network-cidr=192.168.0.0/16</code> atau melalui konfigurasi kubeadm.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://docs.projectcalico.org/v3.11/manifests/calico.yaml
</span></span></code></pre></div></div><div id=tabs-pod-install-1 class=tab-pane role=tabpanel aria-labelledby=tabs-pod-install-1><p><p>Agar Cilium dapat bekerja dengan benar, kamu harus memberikan <code>--pod-network-cidr=10.217.0.0/16</code> pada <code>kubeadm init</code>.</p><p>Untuk men-<em>deploy</em> Cilium kamu hanya perlu menjalankan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f https://raw.githubusercontent.com/cilium/cilium/v1.6/install/kubernetes/quick-install.yaml
</span></span></code></pre></div><p>Ketika seluruh Pod Cilium sudah bertanda <code>READY</code>, kamu dapat mulai menggunakan klaster.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -n kube-system --selector<span style=color:#666>=</span>k8s-app<span style=color:#666>=</span>cilium
</span></span></code></pre></div><p>Keluarannya akan tampil seperti berikut:</p><pre tabindex=0><code>NAME           READY   STATUS    RESTARTS   AGE
cilium-drxkl   1/1     Running   0          18m
</code></pre><p>Cilium dapat digunakan sebagai kube-proxy, lihat <a href=https://docs.cilium.io/en/stable/gettingstarted/kubeproxy-free>Kubernetes tanpa kube-proxy</a>.</p><p>Untuk informasi lebih lanjut mengenai penggunaan Cilium dengan Kubernetes, lihat <a href=https://docs.cilium.io/en/stable/kubernetes/>panduan Instalasi Kubernetes untuk Cilium</a>.</p></div><div id=tabs-pod-install-2 class=tab-pane role=tabpanel aria-labelledby=tabs-pod-install-2><p><p><a href=https://contivpp.io/>Contiv-VPP</a> menggunakan CNF vSwitch berbasis <a href=https://fd.io/>FD.io VPP</a> yang dapat diprogram,
menawarkan layanan dan jejaring <em>cloud-native</em> yang memiliki banyak fungsi dan berkinerja tinggi.</p><p>Contiv-VPP mengimplementasikan Service dan Network Policy Kubernetes pada <em>user space</em> (on VPP).</p><p>Silakan merujuk pada panduan pemasangan berikut: <a href=https://github.com/contiv/vpp/blob/master/docs/setup/MANUAL_INSTALL.md>Pemasangan Manual Contiv-VPP</a></p></div><div id=tabs-pod-install-3 class=tab-pane role=tabpanel aria-labelledby=tabs-pod-install-3><p><p>Kube-router mengandalkan kube-controller-manager untuk mengalokasikan CIDR Pod untuk Node-Node. Maka dari itu, gunakan <code>kubeadm init</code> dengan opsi <code>--pod-network-cidr</code>.</p><p>Kube-router menyediakan jejaring Pod, <em>network policy</em>, dan IP Virtual Server(IPVS)/Linux Virtual Server(LVS) berbasis <em>service proxy</em> yang memiliki kinerja tinggi.</p><p>Informasi mengenai penggunaan <code>kubeadm</code> untuk mendirikan klaster Kubernetes dengan Kube-router, dapat dilihat di <a href=https://github.com/cloudnativelabs/kube-router/blob/master/docs/kubeadm.md>panduan pemasangan resminya</a>.</p></div><div id=tabs-pod-install-4 class=tab-pane role=tabpanel aria-labelledby=tabs-pod-install-4><p><p>Untuk informasi lebih lanjut mengenai pemasangan klaster Kubernetes menggunakan Weave Net, silakan lihat <a href=https://www.weave.works/docs/net/latest/kube-addon/>Mengintegrasikan Kubernetes melalui Addon</a>.</p><p>Weave Net bekerja pada platform <code>amd64</code>, <code>arm</code>, <code>arm64</code> dan <code>ppc64le</code> tanpa membutuhkan tindakan ekstra.
Weave Net menyalakan mode <em>hairpin</em> secara bawaan. Hal ini mengizinkan Pod untuk mengakses dirinya sendiri melalui alamat IP Service
jika mereka tidak tahu PodIP miliknya.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f <span style=color:#b44>&#34;https://cloud.weave.works/k8s/net?k8s-version=</span><span style=color:#a2f;font-weight:700>$(</span>kubectl version | base64 | tr -d <span style=color:#b44>&#39;\n&#39;</span><span style=color:#a2f;font-weight:700>)</span><span style=color:#b44>&#34;</span>
</span></span></code></pre></div></div></div><p>Setelah jaringan Pod dipasangkan, kamu dapat mengonfirmasi hal tersebut dengan
memastikan Pod CoreDNS berada pada kondisi <code>Running</code> pada keluaran <code>kubectl get pods --all-namespaces</code>.
Dan setelah Pod CoreDNS sudah menyala dan berjalan, kamu dapat melanjutkan (pemasangan klaster) dengan menggabungkan Node-Node yang lain.</p><p>Jika jaringan belum bekerja atau CoreDNS tidak berada pada kondisi <code>Running</code>, periksalah/lihatlah
<a href=/docs/setup/production-environment/tools/kubeadm/troubleshooting-kubeadm/>panduan penyelesaian masalah</a>
untuk <code>kubeadm</code>.</p><h3 id=isolasi-node-control-plane>Isolasi Node <em>control plane</em></h3><p>Secara bawaan, klaster tidak akan menjadwalkan Pod pada Node <em>control-plane</em> untuk alasan
keamanan. Jika kamu ingin Pod dapat dijadwalkan pada Node <em>control-plane</em>, sebagai contoh untuk
klaster Kubernetes bermesin-tunggal untuk pengembangan, jalankan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl taint nodes --all node-role.kubernetes.io/master-
</span></span></code></pre></div><p>Dengan keluaran seperti berikut:</p><pre tabindex=0><code>node &#34;test-01&#34; untainted
taint &#34;node-role.kubernetes.io/master:&#34; not found
taint &#34;node-role.kubernetes.io/master:&#34; not found
</code></pre><p>Hal ini akan menghapus <em>taint</em> <code>node-role.kubernetes.io/master</code> pada Node manapun yang
memilikinya, termasuk Node <em>control-plane</em>, sehingga <em>scheduler</em> akan dapat
menjadwalkan Pod di manapun.</p><h3 id=menggabungkan-node>Menggabungkan Node-Node</h3><p>Node adalah tempat beban kerja (Container, Pod, dan lain-lain) berjalan. Untuk menambahkan Node baru pada klaster lakukan hal berikut pada setiap mesin:</p><ul><li>SSH ke mesin</li><li>Gunakan pengguna <em>root</em> (mis. <code>sudo su -</code>)</li><li>Jalankan perintah hasil keluaran <code>kubeadm init</code>. Sebagai contoh:</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubeadm join --token &lt;token&gt; &lt;control-plane-host&gt;:&lt;control-plane-port&gt; --discovery-token-ca-cert-hash sha256:&lt;hash&gt;
</span></span></code></pre></div><p>Jika kamu tidak memiliki <em>token</em>, kamu bisa mendapatkannya dengan menjalankan perintah berikut pada Node <em>control-plane</em>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubeadm token list
</span></span></code></pre></div><p>Keluarannya akan tampil seperti berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#888>TOKEN                    TTL  EXPIRES              USAGES           DESCRIPTION            EXTRA GROUPS
</span></span></span><span style=display:flex><span><span style=color:#888>8ewj1p.9r9hcjoqgajrj4gi  23h  2018-06-12T02:51:28Z authentication,  The default bootstrap  system:
</span></span></span><span style=display:flex><span><span style=color:#888>                                                   signing          token generated by     bootstrappers:
</span></span></span><span style=display:flex><span><span style=color:#888>                                                                    &#39;kubeadm init&#39;.        kubeadm:
</span></span></span><span style=display:flex><span><span style=color:#888>                                                                                           default-node-token
</span></span></span></code></pre></div><p>Secara bawaan, <em>token</em> akan kadaluarsa dalam 24 jam. Jika kamu menggabungkan Node ke klaster setelah <em>token</em> kadaluarsa,
kamu dapat membuat <em>token</em> baru dengan menjalankan perintah berikut pada Node <em>control-plane</em>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubeadm token create
</span></span></code></pre></div><p>Keluarannya akan tampil seperti berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#888>5didvk.d09sbcov8ph2amjw
</span></span></span></code></pre></div><p>Jika kamu tidak memiliki nilai <code>--discovery-token-ca-cert-hash</code>, kamu bisa mendapatkannya dengan menjalankan perintah berantai berikut pada Node <em>control-plane</em>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt | openssl rsa -pubin -outform der 2&gt;/dev/null | <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>   openssl dgst -sha256 -hex | sed <span style=color:#b44>&#39;s/^.* //&#39;</span>
</span></span></code></pre></div><p>Keluaran yang diberikan kurang lebih akan ditampilkan sebagai berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#888>8cb2de97839780a412b93877f8507ad6c94f73add17d5d7058e91741c9d5ec78
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Untuk menentukan <em>tuple</em> IPv6 untuk <code>&lt;control-plane-host>:&lt;control-plane-port></code>, alamat IPv6 harus be ditutup dengan kurung siku, sebagai contoh: <code>[fd00::101]:2073</code>.</div><p>Keluaran yang diberikan kurang lebih akan ditampilkan sebagai berikut:</p><pre tabindex=0><code>[preflight] Running pre-flight checks

... (log output of join workflow) ...

Node join complete:
* Certificate signing request sent to control-plane and response
  received.
* Kubelet informed of new secure connection details.

Run &#39;kubectl get nodes&#39; on control-plane to see this machine join.
</code></pre><p>Beberapa saat kemudian, kamu akan melihat Node tersebut pada keluaran dari <code>kubectl get nodes</code> ketika dijalankan pada Node <em>control-plane</em>.</p><h3 id=opsional-mengendalikan-klaster-dari-mesin-selain-node-control-plane>(Opsional) Mengendalikan klaster dari mesin selain Node <em>control-plane</em></h3><p>Untuk membuat kubectl bekerja pada mesin lain (mis. laptop) agar dapat berbicara dengan
klaster, kamu harus menyalin berkas kubeconfig administrator dari Node <em>control-plane</em>
ke mesin seperti berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>scp root@&lt;control-plane-host&gt;:/etc/kubernetes/admin.conf .
</span></span><span style=display:flex><span>kubectl --kubeconfig ./admin.conf get nodes
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong><p>Contoh di atas mengasumsikan akses SSH dinyalakan untuk <em>root</em>. Jika tidak berlaku
demikian, kamu dapat menyalin berkas <code>admin.conf</code> untuk dapat diakses oleh pengguna lain
dan <code>scp</code> menggunakan pengguna lain tersebut.</p><p>Berkas <code>admin.conf</code> memberikan penggunanya privilese (<em>privilege</em>) <em>superuser</em> terhadap klaster.
Berkas ini harus digunakan seperlunya. Untuk pengguna biasa, direkomendasikan
untuk membuat kredensial unik dengan privilese <em>whitelist</em>. Kamu dapat melakukan
ini dengan perintah <code>kubeadm alpha kubeconfig user --client-name &lt;CN></code>.
Perintah tersebut akan mencetak berkas KubeConfig ke STDOUT yang harus kamu simpan
ke dalam sebuah berkas dan mendistribusikannya pada para pengguna. Setelah itu, whitelist
privilese menggunakan <code>kubectl create (cluster)rolebinding</code>.</p></div><h3 id=opsional-memproksi-api-server-ke-localhost>(Opsional) Memproksi API Server ke localhost</h3><p>Jika kamu ingin terhubung dengan API Server dari luar klaster kamu dapat menggunakan
<code>kubectl proxy</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>scp root@&lt;control-plane-host&gt;:/etc/kubernetes/admin.conf .
</span></span><span style=display:flex><span>kubectl --kubeconfig ./admin.conf proxy
</span></span></code></pre></div><p>Kini kamu dapat mengakses API Server secara lokal melalui <code>http://localhost:8001/api/v1</code></p><h2 id=pembongkaran>Pembongkaran</h2><p>Jika kamu menggunakan server sekali pakai untuk membuat klaster, sebagai ujicoba, kamu dapat
mematikannya tanpa perlu melakukan pembongkaran. Kamu dapat menggunakan
<code>kubectl config delete-cluster</code> untuk menghapus referensi lokal ke
klaster.</p><p>Namun, jika kamu ingin mengatur ulang klaster secara lebih rapih, pertama-tama kamu
harus <a href=/docs/reference/generated/kubectl/kubectl-commands#drain>menguras (<em>drain</em>) Node</a>
dan memastikan Node sudah kosong, kemudian mengembalikan pengaturan pada Node kembali seperti semula.</p><h3 id=menghapus-node>Menghapus Node</h3><p>Berinteraksi dengan Node <em>control-plane</em> menggunakan kredensial yang sesuai, jalankan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl drain &lt;node name&gt; --delete-local-data --force --ignore-daemonsets
</span></span><span style=display:flex><span>kubectl delete node &lt;node name&gt;
</span></span></code></pre></div><p>Lalu, pada Node yang dihapus, atur ulang semua kondisi <code>kubeadm</code> yang telah dipasang:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubeadm reset
</span></span></code></pre></div><p>Proses pengaturan ulang tidak mengatur ulang atau membersihkan kebijakan iptables atau tabel IPVS. Jika kamu ingin mengatur ulang iptables, kamu harus melakukannya secara manual:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>iptables -F <span style=color:#666>&amp;&amp;</span> iptables -t nat -F <span style=color:#666>&amp;&amp;</span> iptables -t mangle -F <span style=color:#666>&amp;&amp;</span> iptables -X
</span></span></code></pre></div><p>Jika kamu ingin mengatur ulang tabel IPVS, kamu harus menjalankan perintah berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ipvsadm -C
</span></span></code></pre></div><p>Jika kamu ingin mengulang dari awal, cukup jalankan <code>kubeadm init</code> atau <code>kubeadm join</code> dengan
argumen yang sesuai.</p><h3 id=membersihkan-control-plane>Membersihkan <em>control plane</em></h3><p>Kamu dapat menggunakan <code>kubeadm reset</code> pada hos <em>control plane</em> untuk memicu pembersihan
best-effort.</p><p>Lihat dokumentasi referensi <a href=/docs/reference/setup-tools/kubeadm/kubeadm-reset/><code>kubeadm reset</code></a>
untuk informasi lebih lanjut mengenai sub-perintah ini dan
opsinya.</p><h2 id=selanjutnya>Selanjutnya</h2><ul><li>Pastikan klaster berjalan dengan benar menggunakan <a href=https://github.com/heptio/sonobuoy>Sonobuoy</a></li><li><a id=lifecycle>Lihat <a href=/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade/>Memperbaharui klaster kubeadm</a>
untuk detail mengenai pembaruan klaster menggunakan <code>kubeadm</code>.</li><li>Pelajari penggunaan <code>kubeadm</code> lebih lanjut pada <a href=/docs/reference/setup-tools/kubeadm>dokumentasi referensi kubeadm</a></li><li>Pelajari lebih lanjut mengenai <a href=/docs/concepts/>konsep-konsep</a> Kubernetes dan <a href=/docs/user-guide/kubectl-overview/><code>kubectl</code></a>.</li><li>Lihat halaman <a href=/id/docs/concepts/cluster-administration/networking/>Cluster Networking</a> untuk daftar
<em>add-on</em> jaringan Pod yang lebih banyak.</li><li><a id=other-addons>Lihat <a href=/id/docs/concepts/cluster-administration/addons/>daftar <em>add-on</em></a> untuk
mengeksplor <em>add-on</em> lainnya, termasuk perkakas untuk <em>logging</em>, <em>monitoring</em>, <em>network policy</em>, visualisasi &
pengendalian klaster Kubernetes.</li><li>Atur bagaimana klaster mengelola log untuk peristiwa-peristiwa klaster dan dari
aplikasi-aplikasi yang berjalan pada Pod.
Lihat <a href=/id/docs/concepts/cluster-administration/logging/>Arsitektur Logging</a> untuk
gambaran umum tentang hal-hal yang terlibat.</li></ul><h3 id=umpan-balik>Umpan balik</h3><ul><li>Untuk masalah kekutu (<em>bug</em>), kunjungi <a href=https://github.com/kubernetes/kubeadm/issues>kubeadm GitHub issue tracker</a></li><li>Untuk dukungan, kunjungi kanal Slack
<a href=https://kubernetes.slack.com/messages/kubeadm/>#kubeadm</a></li><li>Kanal Slack umum pengembangan SIG Cluster Lifecycle:
<a href=https://kubernetes.slack.com/messages/sig-cluster-lifecycle/>#sig-cluster-lifecycle</a></li><li>SIG Cluster Lifecycle <a href=https://github.com/kubernetes/community/tree/master/sig-cluster-lifecycle#readme>SIG information</a></li><li>Milis SIG Cluster Lifecycle:
<a href=https://groups.google.com/forum/#!forum/kubernetes-sig-cluster-lifecycle>kubernetes-sig-cluster-lifecycle</a></li></ul><h2 id=kebijakan-version-skew>Kebijakan <em>version skew</em></h2><p><code>kubeadm</code> versi v1.25 dapat men-<em>deploy</em> klaster dengan <em>control plane</em> versi v1.25 atau v1.24.
<code>kubeadm</code> v1.25 juga dapat memperbarui klaster yang dibuat dengan kubeadm v1.24.</p><p>Karena kita tidak dapat memprediksi masa depan, CLI kubeadm v1.25 mungkin atau tidak mungkin dapat men-<em>deploy</em> klaster v1.26.</p><p>Sumber daya ini menyediakan informasi lebih lanjut mengenai <em>version skew</em> yang didukung antara kubelet dan <em>control plane</em>, serta komponen Kubernetes lainnya:</p><ul><li><a href=/docs/setup/release/version-skew-policy/>Kebijakan versi and version-skew Kubernetes</a></li><li><a href=/id/docs/setup/production-environment/tools/kubeadm/install-kubeadm/#installing-kubeadm-kubelet-and-kubectl>Panduan instalasi</a> spesifik untuk kubeadm</li></ul><h2 id=keterbatasan>Keterbatasan</h2><h3 id=ketahanan-klaster>Ketahanan klaster</h3><p>Klaster yang dibuat pada panduan ini hanya memiliki Node <em>control-plane</em> tunggal, dengan basis data etcd tunggal
yang berjalan di atasnya. Hal ini berarti jika terjadi kegagalan pada Node <em>control-plane</em>, klaster dapat kehilangan
data dan mungkin harus dibuat kembali dari awal.</p><p>Solusi:</p><ul><li><p>Lakukan <a href=https://coreos.com/etcd/docs/latest/admin_guide.html>back up etcd</a> secara reguler. Direktori data
etcd yang dikonfigurasi oleh kubeadm berada di <code>/var/lib/etcd</code> pada Node <em>control-plane</em>.</p></li><li><p>Gunakan banyak Node <em>control-plane</em>. Kamu dapat membaca
<a href=/docs/setup/production-environment/tools/kubeadm/ha-topology/>Opsi untuk topologi dengan ketersediaan tinggi</a> untuk memilih topologi
klaster yang menyediakan ketersediaan lebih tinggi.</p></li></ul><h3 id=kompatibilitas-platform>Kompatibilitas platform</h3><p><em>Package</em> dbm/rpm dan <em>binary</em> kubeadm dibuat untuk amd64, arm (32-bit), arm64, ppc64le, dan s390x
mengikuti <a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/multi-platform.md>proposal multi-platform</a>.</p><p><em>Image</em> kontainer <em>multiplatform</em> untuk <em>control plane</em> dan <em>addon</em> juga telah didukung sejak v1.12.</p><p>Hanya beberapa penyedia jaringan yang menawarkan solusi untuk seluruh platform. Silakan merujuk pada daftar
penyedia jaringan di atas atau dokumentasi dari masing-masing penyedia untuk mencari tahu apakah penyedia tersebut
mendukung platform pilihanmu.</p><h2 id=penyelesaian-masalah>Penyelesaian masalah</h2><p>Jika kamu menemui kesulitan dengan kubeadm, silakan merujuk pada <a href=/docs/setup/production-environment/tools/kubeadm/troubleshooting-kubeadm/>dokumen penyelesaian masalah</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-3941d5c3409342219bf7e03128b8ecb6>2.2.2.1.3 - Membangun Klaster dengan Ketersediaan Tinggi menggunakan kubeadm</h1><p>Laman ini menjelaskan dua pendekatan yang berbeda untuk membuat klaster Kubernetes dengan ketersediaan tinggi menggunakan kubeadm:</p><ul><li>Dengan Node <em>control plane</em> yang bertumpuk (<em>stacked</em>). Pendekatan ini membutuhkan sumber daya infrastruktur yang lebih sedikit. Anggota-anggota etcd dan Node <em>control plane</em> diletakkan pada tempat yang sama (<em>co-located</em>).</li><li>Dengan klaster etcd eksternal. Pendekatan ini membutuhkan lebih banyak sumber daya infrastruktur. Node <em>control plane</em> dan anggota etcd berada pada tempat yang berbeda.</li></ul><p>Sebelum memulai, kamu harus memikirkan dengan matang pendekatan mana yang paling sesuai untuk kebutuhan aplikasi dan <em>environment</em>-mu. <a href=/id/docs/setup/production-environment/tools/kubeadm/ha-topology/>Topik perbandingan berikut</a> menguraikan kelebihan dan kekurangan dari masing-masing pendekatan.</p><p>Jika kamu menghadapi masalah dalam pembuatan klaster dengan ketersediaan tinggi, silakan berikan umpan balik
pada <a href=https://github.com/kubernetes/kubeadm/issues/new>pelacak isu</a> kubeadm.</p><p>Lihat juga <a href=/id/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade-1-15>dokumentasi pembaruan</a>.</p><div class="alert alert-warning caution callout" role=alert><strong>Perhatian:</strong> Laman ini tidak menunjukkan cara untuk menjalankan klastermu pada penyedia layanan cloud. Pada <em>environment</em> cloud, kedua pendekatan yang didokumentasikan di sini tidak akan bekerja untuk objek Service dengan tipe LoadBalancer maupun PersistentVolume dinamis.</div><h2 id=sebelum-kamu-memulai>Sebelum kamu memulai</h2><p>Untuk kedua metode kamu membutuhkan infrastruktur seperti berikut:</p><ul><li>Tiga mesin yang memenuhi <a href=/id/docs/setup/production-environment/tools/kubeadm/install-kubeadm/#sebelum-mulai>kebutuhan minimum kubeadm</a> untuk
Node <em>control plane</em></li><li>Tiga mesin yang memenuhi <a href=/id/docs/setup/production-environment/tools/kubeadm/install-kubeadm/#sebelum-mulai>kebutuhan minimum kubeadm</a> untuk Node <em>worker</em></li><li>Konektivitas internet pada seluruh mesin di dalam klaster (baik jaringan publik maupun jaringan pribadi)</li><li>Hak akses sudo pada seluruh mesin</li><li>Akses SSH dari satu perangkat ke seluruh Node pada sistem</li><li>Perkakas <code>kubeadm</code> dan <code>kubelet</code> diinstal pada seluruh mesin. Perkakas <code>kubectl</code> bersifat opsional.</li></ul><p>Untuk klaster etcd eksternal saja, kamu juga membutuhkan:</p><ul><li>Tiga mesin tambahan untuk anggota-anggota etcd</li></ul><h2 id=langkah-pertama-untuk-kedua-metode>Langkah pertama untuk kedua metode</h2><h3 id=membuat-load-balancer-untuk-kube-apiserver>Membuat <em>load balancer</em> untuk kube-apiserver</h3><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Akan ada banyak konfigurasi untuk <em>load balancer</em>. Contoh berikut ini hanyalah salah satu
opsi. Kebutuhan klastermu mungkin membutuhkan konfigurasi berbeda.</div><ol><li><p>Buat sebuah <em>load balancer</em> kube-apiserver dengan sebuah nama yang yang akan mengubah ke dalam bentuk DNS.</p><ul><li><p>Pada <em>environment</em> cloud kamu harus meletakkan Node <em>control plane</em> di belakang <em>load balancer</em> yang meneruskan TCP. <em>Load balancer</em> ini mendistribusikan trafik ke seluruh Node <em>control plane</em> pada daftar tujuan. <em>Health check</em> untuk
apiserver adalah pengujian TCP pada porta yang didengarkan oleh kube-apiserver
(nilai semula <code>:6443</code>).</p></li><li><p>Tidak direkomendasikan untuk menggunakan alamat IP secara langsung pada <em>environment</em> cloud.</p></li><li><p><em>Load balancer</em> harus dapat berkomunikasi dengan seluruh Node <em>control plane</em>
pada porta yang digunakan apiserver. <em>Load balancer</em> tersebut juga harus mengizinkan trafik masuk pada porta yang didengarkannya.</p></li><li><p>Pastikan alamat <em>load balancer</em> sesuai
dengan alamat <code>ControlPlaneEndpoint</code> pada kubeadm.</p></li><li><p>Baca panduan <a href=https://github.com/kubernetes/kubeadm/blob/master/id/docs/ha-considerations.md#options-for-software-load-balancing>Opsi untuk <em>Software Load Balancing</em></a>
untuk detail lebih lanjut.</p></li></ul></li><li><p>Tambahkan Node <em>control plane</em> pertama pada <em>load balancer</em> dan lakukan pengujian koneksi:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>nc -v LOAD_BALANCER_IP PORT
</span></span></code></pre></div><ul><li>Kegalatan koneksi yang ditolak memang diantisipasi karena apiserver belum
berjalan. Namun jika mendapat <em>timeout</em>, berarti <em>load balancer</em> tidak dapat berkomunikasi
dengan Node <em>control plane</em>. Jika terjadi <em>timeout</em>, lakukan pengaturan ulang pada <em>load balancer</em> agar dapat berkomunikasi dengan Node <em>control plane</em>.</li></ul></li><li><p>Tambahkan Node <em>control plane</em> lainnya pada grup tujuan <em>load balancer</em>.</p></li></ol><h2 id=node-control-plane-dan-etcd-bertumpuk-stacked>Node <em>control plane</em> dan etcd bertumpuk (<em>stacked</em>)</h2><h3 id=langkah-langkah-untuk-node-control-plane-pertama>Langkah-langkah untuk Node <em>control plane</em> pertama</h3><ol><li><p>Inisialisasi <em>control plane</em>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>sudo kubeadm init --control-plane-endpoint <span style=color:#b44>&#34;LOAD_BALANCER_DNS:LOAD_BALANCER_PORT&#34;</span> --upload-certs
</span></span></code></pre></div><ul><li><p>Kamu bisa menggunakan opsi <code>--kubernetes-version</code> untuk mengatur versi Kubernetes yang akan digunakan.
Direkomendasikan untuk menggunakan versi kubeadm, kubelet, kubectl, dan Kubernetes yang sama.</p></li><li><p>Opsi <code>--control-plane-endpoint</code> harus diatur menuju alamat atau DNS dan porta dari <em>load balancer</em>.</p></li><li><p>Opsi <code>--upload-certs</code> digunakan untuk mengunggah sertifikat-sertifikat yang harus dibagikan ke seluruh
Node <em>control plane</em> pada klaster. Jika sebaliknya, kamu memilih untuk menyalin sertifikat ke
seluruh Node <em>control plane</em> sendiri atau menggunakan perkakas automasi, silakan hapus opsi ini dan merujuk ke bagian <a href=#distribusi-sertifikat-manual>Distribusi sertifikat manual</a> di bawah.</p></li></ul><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Opsi <code>--config</code> dan <code>--certificate-key</code> pada <code>kubeadm init</code> tidak dapat digunakan secara bersamaan, maka dari itu jika kamu ingin menggunakan
<a href=https://godoc.org/k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm/v1beta2>konfigurasi kubeadm</a>
kamu harus menambahkan <em>field</em> <code>certificateKey</code> pada lokasi pengaturan yang sesuai
(berada di bawah <code>InitConfiguration</code> dan <code>JoinConfiguration: controlPlane</code>).</div><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Beberapa <em>plugin</em> jaringan CNI membutuhkan pengaturan tambahan, seperti menentukan CIDR IP untuk Pod, meski beberapa lainnya tidak.
Lihat <a href=/id/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/#jaringan-pod>dokumentasi jaringan CNI</a>.
Untuk menambahkan CIDR Pod, tambahkan opsi <code>--pod-network-cidr</code>, atau jika kamu menggunakan berkas konfigurasi kubeadm
pasang <em>field</em> <code>podSubnet</code> di bawah objek <code>networking</code> dari <code>ClusterConfiguration</code>.</div><ul><li><p>Keluaran yang dihasilkan terlihat seperti berikut ini:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>...
</span></span><span style=display:flex><span>You can now join any number of control-plane node by running the following <span style=color:#a2f>command</span> on each as a root:
</span></span><span style=display:flex><span>    kubeadm join 192.168.0.200:6443 --token 9vr73a.a8uxyaju799qwdjv --discovery-token-ca-cert-hash sha256:7c2e69131a36ae2a042a339b33381c6d0d43887e2de83720eff5359e26aec866 --control-plane --certificate-key f8902e114ef118304e561c3ecd4d0b543adc226b7a07f675f56564185ffe0c07
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Please note that the certificate-key gives access to cluster sensitive data, keep it secret!
</span></span><span style=display:flex><span>As a safeguard, uploaded-certs will be deleted in two hours; If necessary, you can use kubeadm init phase upload-certs to reload certs afterward.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Then you can join any number of worker nodes by running the following on each as root:
</span></span><span style=display:flex><span>    kubeadm join 192.168.0.200:6443 --token 9vr73a.a8uxyaju799qwdjv --discovery-token-ca-cert-hash sha256:7c2e69131a36ae2a042a339b33381c6d0d43887e2de83720eff5359e26aec866
</span></span></code></pre></div></li><li><p>Salin keluaran ini pada sebuah berkas teks. Kamu akan membutuhkannya nanti untuk menggabungkan Node <em>control plane</em> dan <em>worker</em> ke klaster.</p></li><li><p>Ketika opsi <code>--upload-certs</code> digunakan dengan <code>kubeadm init</code>, sertifikat dari <em>control plane</em> utama
akan dienkripsi dan diunggah ke Secret <code>kubeadm-certs</code>.</p></li><li><p>Untuk mengunggah ulang sertifikat dan membuat kunci dekripsi baru, gunakan perintah berikut pada Node <em>control plane</em>
yang sudah tergabung pada klaster:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>sudo kubeadm init phase upload-certs --upload-certs
</span></span></code></pre></div></li><li><p>Kamu juga dapat menentukan <code>--certificate-key</code> <em>custom</em> pada saat <code>init</code> yang nanti dapat digunakan pada saat <code>join</code>.
Untuk membuat kunci tersebut kamu dapat menggunakan perintah berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubeadm alpha certs certificate-key
</span></span></code></pre></div></li></ul><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Secret <code>kubeadm-certs</code> dan kunci dekripsi akan kadaluarsa setelah dua jam.</div><div class="alert alert-warning caution callout" role=alert><strong>Perhatian:</strong> Seperti yang tertera pada keluaran perintah, kunci sertifikat memberikan akses ke data klaster yang bersifat sensitif, jaga kerahasiaannya!</div></li><li><p>Pasang <em>plugin</em> CNI pilihanmu:
<a href=/id/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/#jaringan-pod>Ikuti petunjuk berikut</a>
untuk menginstal penyedia CNI. Pastikan konfigurasinya sesuai dengan CIDR Pod yang ditentukan pada berkas konfigurasi kubeadm jika diterapkan.</p><p>Pada contoh berikut kami menggunakan Weave Net:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl apply -f <span style=color:#b44>&#34;https://cloud.weave.works/k8s/net?k8s-version=</span><span style=color:#a2f;font-weight:700>$(</span>kubectl version | base64 | tr -d <span style=color:#b44>&#39;\n&#39;</span><span style=color:#a2f;font-weight:700>)</span><span style=color:#b44>&#34;</span>
</span></span></code></pre></div></li><li><p>Tulis perintah berikut dan saksikan Pod komponen-komponen <em>control plane</em> mulai dinyalakan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl get pod -n kube-system -w
</span></span></code></pre></div></li></ol><h3 id=langkah-langkah-selanjutnya-untuk-node-control-plane>Langkah-langkah selanjutnya untuk Node <em>control plane</em></h3><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Sejak kubeadm versi 1.15 kamu dapat menggabungkan beberapa Node <em>control plane</em> secara bersamaan.
Pada versi sebelumnya, kamu harus menggabungkan Node <em>control plane</em> baru secara berurutan, setelah
Node pertama selesai diinisialisasi.</div><p>Untuk setiap Node <em>control plane</em> kamu harus:</p><ol><li><p>Mengeksekusi perintah untuk bergabung yang sebelumnya diberikan pada keluaran <code>kubeadm init</code> pada Node pertama.
Perintah tersebut terlihat seperti ini:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>sudo kubeadm join 192.168.0.200:6443 --token 9vr73a.a8uxyaju799qwdjv --discovery-token-ca-cert-hash sha256:7c2e69131a36ae2a042a339b33381c6d0d43887e2de83720eff5359e26aec866 --control-plane --certificate-key f8902e114ef118304e561c3ecd4d0b543adc226b7a07f675f56564185ffe0c07
</span></span></code></pre></div><ul><li>Opsi <code>--control-plane</code> menunjukkan <code>kubeadm join</code> untuk membuat <em>control plane</em> baru.</li><li>Opsi <code>--certificate-key ...</code> akan membuat sertifikat <em>control plane</em> diunduh
dari Secret <code>kubeadm-certs</code> pada klaster dan didekripsi menggunakan kunci yang diberikan.</li></ul></li></ol><h2 id=node-etcd-eksternal>Node etcd eksternal</h2><p>Membangun sebuah klaster dengan Node etcd eksternal memiliki prosedur yang mirip dengan etcd bertumpuk
dengan pengecualian yaitu kamu harus setup etcd terlebih dulu, dan kamu harus memberikan informasi etcd
pada berkas konfigurasi kubeadm.</p><h3 id=memasang-klaster-etcd>Memasang klaster etcd</h3><ol><li><p>Ikuti <a href=/docs/setup/production-environment/tools/kubeadm/setup-ha-etcd-with-kubeadm/>petunjuk berikut</a> untuk membangun klaster etcd.</p></li><li><p>Lakukan pengaturan SSH seperti yang dijelaskan <a href=#distribusi-sertifikat-manual>di sini</a>.</p></li><li><p>Salin berkas-berkas berikut dari Node etcd manapun pada klaster ke Node <em>control plane</em> pertama:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#a2f>export</span> <span style=color:#b8860b>CONTROL_PLANE</span><span style=color:#666>=</span><span style=color:#b44>&#34;ubuntu@10.0.0.7&#34;</span>
</span></span><span style=display:flex><span>scp /etc/kubernetes/pki/etcd/ca.crt <span style=color:#b44>&#34;</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>CONTROL_PLANE</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>&#34;</span>:
</span></span><span style=display:flex><span>scp /etc/kubernetes/pki/apiserver-etcd-client.crt <span style=color:#b44>&#34;</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>CONTROL_PLANE</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>&#34;</span>:
</span></span><span style=display:flex><span>scp /etc/kubernetes/pki/apiserver-etcd-client.key <span style=color:#b44>&#34;</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>CONTROL_PLANE</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>&#34;</span>:
</span></span></code></pre></div><ul><li>Ganti nilai <code>CONTROL_PLANE</code> dengan <code>user@host</code> dari mesin <em>control plane</em> pertama.</li></ul></li></ol><h3 id=mengatur-node-control-plane-pertama>Mengatur Node <em>control plane</em> pertama</h3><ol><li><p>Buat sebuah berkas bernama <code>kubeadm-config.yaml</code> dengan konten sebagai berikut:</p><pre><code>apiVersion: kubeadm.k8s.io/v1beta2
kind: ClusterConfiguration
kubernetesVersion: stable
controlPlaneEndpoint: &quot;LOAD_BALANCER_DNS:LOAD_BALANCER_PORT&quot;
etcd:
    external:
        endpoints:
        - https://ETCD_0_IP:2379
        - https://ETCD_1_IP:2379
        - https://ETCD_2_IP:2379
        caFile: /etc/kubernetes/pki/etcd/ca.crt
        certFile: /etc/kubernetes/pki/apiserver-etcd-client.crt
        keyFile: /etc/kubernetes/pki/apiserver-etcd-client.key
</code></pre></li></ol><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Perbedaan antara etcd bertumpuk dan etcd eksternal yaitu etcd eksternal membutuhkan
sebuah berkas konfigurasi dengan <em>endpoint</em> etcd di bawah objek <code>external</code>untuk <code>etcd</code>.
Pada kasus ini topologi etcd bertumpuk dikelola secara otomatis.</div><ul><li>Ganti variabel-variabel berikut pada templat konfigurasi dengan nilai yang sesuai untuk klastermu:</li></ul><pre><code>- `LOAD_BALANCER_DNS`
- `LOAD_BALANCER_PORT`
- `ETCD_0_IP`
- `ETCD_1_IP`
- `ETCD_2_IP`
</code></pre><p>Langkah-langkah berikut sama dengan pengaturan pada etcd bertumpuk:</p><ol><li><p>Jalankan <code>sudo kubeadm init --config kubeadm-config.yaml --upload-certs</code> pada Node ini.</p></li><li><p>Tulis perintah untuk bergabung yang didapat dari keluaran ke dalam sebuah berkas teks untuk digunakan nanti.</p></li><li><p>Pasang <em>plugin</em> CNI pilihanmu. Contoh berikut ini untuk Weave Net:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl apply -f <span style=color:#b44>&#34;https://cloud.weave.works/k8s/net?k8s-version=</span><span style=color:#a2f;font-weight:700>$(</span>kubectl version | base64 | tr -d <span style=color:#b44>&#39;\n&#39;</span><span style=color:#a2f;font-weight:700>)</span><span style=color:#b44>&#34;</span>
</span></span></code></pre></div></li></ol><h3 id=langkah-selanjutnya-untuk-node-control-plane-lainnya>Langkah selanjutnya untuk Node <em>control plane</em> lainnya</h3><p>Langkah-langkah selanjutnya sama untuk pengaturan etcd bertumpuk:</p><ul><li>Pastikan Node <em>control plane</em> pertama sudah diinisialisasi dengan sempurna.</li><li>Gabungkan setiap Node <em>control plane</em> dengan perintah untuk bergabung yang kamu simpan dalam berkas teks. Direkomendasikan untuk
menggabungkan Node <em>control plane</em> satu persatu.</li><li>Jangan lupakan bahwa kunci dekripsi dari <code>--certificate-key</code> akan kadaluarsa setelah dua jam, pada pengaturan semula.</li></ul><h2 id=tugas-tugas-umum-setelah-menyiapkan-control-plane>Tugas-tugas umum setelah menyiapkan <em>control plane</em></h2><h3 id=menginstal-worker>Menginstal <em>worker</em></h3><p>Node <em>worker</em> bisa digabungkan ke klaster menggunakan perintah yang kamu simpan sebelumnya
dari keluaran perintah <code>kubeadm init</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>sudo kubeadm join 192.168.0.200:6443 --token 9vr73a.a8uxyaju799qwdjv --discovery-token-ca-cert-hash sha256:7c2e69131a36ae2a042a339b33381c6d0d43887e2de83720eff5359e26aec866
</span></span></code></pre></div><h2 id=distribusi-sertifikat-manual>Distribusi sertifikat manual</h2><p>Jika kamu memilih untuk tidak menggunakan <code>kubeadm init</code> dengan opsi <code>--upload-certs</code> berarti kamu harus
menyalin sertifikat dari Node <em>control plane</em> utama secara manual ke
Node <em>control plane</em> yang akan bergabung.</p><p>Ada beberapa cara untuk melakukan hal ini. Pada contoh berikut ini kami menggunakan <code>ssh</code> dan <code>scp</code>:</p><p>SSH dibutuhkan jika kamu ingin mengendalikan seluruh Node dari satu mesin.</p><ol><li><p>Nyalakan ssh-agent pada perangkat utamamu yang memiliki akses ke seluruh Node pada
sistem:</p><pre tabindex=0><code>eval $(ssh-agent)
</code></pre></li><li><p>Tambahkan identitas SSH milikmu ke dalam sesi:</p><pre tabindex=0><code>ssh-add ~/.ssh/path_to_private_key
</code></pre></li><li><p>Lakukan SSH secara bergantian ke setiap Node untuk memastikan koneksi bekerja dengan baik.</p><ul><li><p>Ketika kamu melakukan SSH ke Node, pastikan untuk menambahkan opsi <code>-A</code>:</p><pre tabindex=0><code>ssh -A 10.0.0.7
</code></pre></li><li><p>Jika kamu menggunakan sudo pada Node, pastikan kamu menyimpan <em>environment</em> yang ada sehingga penerusan SSH
dapat bekerja dengan baik:</p><pre tabindex=0><code>sudo -E -s
</code></pre></li></ul></li><li><p>Setelah mengatur SSH pada seluruh Node kamu harus menjalankan skrip berikut pada Node <em>control plane</em> pertama setelah
menjalankan <code>kubeadm init</code>. Skrip ini akan menyalin sertifikat dari Node <em>control plane</em> pertama ke Node
<em>control plane</em> lainnya:</p><p>Pada contoh berikut, ganti <code>CONTROL_PLANE_IPS</code> dengan alamat IP dari
Node <em>control plane</em> lainnya.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#b8860b>USER</span><span style=color:#666>=</span>ubuntu <span style=color:#080;font-style:italic># dapat disesuaikan</span>
</span></span><span style=display:flex><span><span style=color:#b8860b>CONTROL_PLANE_IPS</span><span style=color:#666>=</span><span style=color:#b44>&#34;10.0.0.7 10.0.0.8&#34;</span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>for</span> host in <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>CONTROL_PLANE_IPS</span><span style=color:#b68;font-weight:700>}</span>; <span style=color:#a2f;font-weight:700>do</span>
</span></span><span style=display:flex><span>    scp /etc/kubernetes/pki/ca.crt <span style=color:#b44>&#34;</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>USER</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>&#34;</span>@<span style=color:#b8860b>$host</span>:
</span></span><span style=display:flex><span>    scp /etc/kubernetes/pki/ca.key <span style=color:#b44>&#34;</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>USER</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>&#34;</span>@<span style=color:#b8860b>$host</span>:
</span></span><span style=display:flex><span>    scp /etc/kubernetes/pki/sa.key <span style=color:#b44>&#34;</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>USER</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>&#34;</span>@<span style=color:#b8860b>$host</span>:
</span></span><span style=display:flex><span>    scp /etc/kubernetes/pki/sa.pub <span style=color:#b44>&#34;</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>USER</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>&#34;</span>@<span style=color:#b8860b>$host</span>:
</span></span><span style=display:flex><span>    scp /etc/kubernetes/pki/front-proxy-ca.crt <span style=color:#b44>&#34;</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>USER</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>&#34;</span>@<span style=color:#b8860b>$host</span>:
</span></span><span style=display:flex><span>    scp /etc/kubernetes/pki/front-proxy-ca.key <span style=color:#b44>&#34;</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>USER</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>&#34;</span>@<span style=color:#b8860b>$host</span>:
</span></span><span style=display:flex><span>    scp /etc/kubernetes/pki/etcd/ca.crt <span style=color:#b44>&#34;</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>USER</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>&#34;</span>@<span style=color:#b8860b>$host</span>:etcd-ca.crt
</span></span><span style=display:flex><span>    <span style=color:#080;font-style:italic># Kutip baris berikut jika kamu menggunakan etcd eksternal</span>
</span></span><span style=display:flex><span>    scp /etc/kubernetes/pki/etcd/ca.key <span style=color:#b44>&#34;</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>USER</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>&#34;</span>@<span style=color:#b8860b>$host</span>:etcd-ca.key
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>done</span>
</span></span></code></pre></div><div class="alert alert-warning caution callout" role=alert><strong>Perhatian:</strong> Salinlah hanya sertifikat yang berada pada daftar di atas saja. Perkakas kubeadm akan mengambil alih pembuatan sertifikat lainnya
dengan SANs yang dibutuhkan untuk Node <em>control plane</em> yang akan bergabung. Jika kamu menyalin seluruh sertifikat tanpa sengaja,
pembuatan Node tambahan dapat gagal akibat tidak adanya SANs yang dibutuhkan.</div></li><li><p>Lalu, pada setiap Node <em>control plane</em> yang bergabung kamu harus menjalankan skrip berikut sebelum menjalankan <code>kubeadm join</code>.
Skrip ini akan memindahkan sertifikat yang telah disalin sebelumnya dari direktori <em>home</em> ke <code>/etc/kubernetes/pki</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#b8860b>USER</span><span style=color:#666>=</span>ubuntu <span style=color:#080;font-style:italic># dapat disesuaikan</span>
</span></span><span style=display:flex><span>mkdir -p /etc/kubernetes/pki/etcd
</span></span><span style=display:flex><span>mv /home/<span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>USER</span><span style=color:#b68;font-weight:700>}</span>/ca.crt /etc/kubernetes/pki/
</span></span><span style=display:flex><span>mv /home/<span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>USER</span><span style=color:#b68;font-weight:700>}</span>/ca.key /etc/kubernetes/pki/
</span></span><span style=display:flex><span>mv /home/<span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>USER</span><span style=color:#b68;font-weight:700>}</span>/sa.pub /etc/kubernetes/pki/
</span></span><span style=display:flex><span>mv /home/<span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>USER</span><span style=color:#b68;font-weight:700>}</span>/sa.key /etc/kubernetes/pki/
</span></span><span style=display:flex><span>mv /home/<span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>USER</span><span style=color:#b68;font-weight:700>}</span>/front-proxy-ca.crt /etc/kubernetes/pki/
</span></span><span style=display:flex><span>mv /home/<span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>USER</span><span style=color:#b68;font-weight:700>}</span>/front-proxy-ca.key /etc/kubernetes/pki/
</span></span><span style=display:flex><span>mv /home/<span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>USER</span><span style=color:#b68;font-weight:700>}</span>/etcd-ca.crt /etc/kubernetes/pki/etcd/ca.crt
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Kutip baris berikut jika kamu menggunakan etcd eksternal</span>
</span></span><span style=display:flex><span>mv /home/<span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>USER</span><span style=color:#b68;font-weight:700>}</span>/etcd-ca.key /etc/kubernetes/pki/etcd/ca.key
</span></span></code></pre></div></li></ol></div><div class=td-content style=page-break-before:always><h1 id=pg-84b6491601d6a2b3da4cd5a105c866ba>2.3 - Praktek-praktek Terbaik</h1></div><div class=td-content><h1 id=pg-970615c97499e3651fd3a98e0387cefc>2.3.1 - Menjalankan klaster dalam beberapa zona</h1><p>Laman ini menjelaskan tentang bagaimana menjalankan sebuah klaster dalam beberapa zona.</p><h2 id=pendahuluan>Pendahuluan</h2><p>Kubernetes 1.2 menambahkan dukungan untuk menjalankan sebuah klaster dalam beberapa zona kegagalan (<em>multiple failure zones</em>)
(GCE secara sederhana menyebutnya sebagai <em>"zones"</em>, AWS menyebutnya sebagai <em>"availability zones"</em>, dan di sini kita akan menyebutnya sebagai "zona").
Fitur ini adalah versi sederhana dari fitur federasi klaster yang lebih luas (yang sebelumnya ditujukan pada
sebuah nama panggilan yang ramah (<em>affectionate nickname</em>) <a href=https://github.com/kubernetes/community/blob/main/contributors/design-proposals/multicluster/federation.md>"Ubernetes"</a>).
Federasi klaster yang penuh memungkinkan untuk menggabungkan
klaster Kubernetes terpisah, yang berjalan pada wilayah atau penyedia cloud yang berbeda
(baik dalam <em>datacenter</em> atau <em>on-premise</em>). Namun banyak
pengguna yang ingin menjalankan klaster Kubernetes dengan tingkat ketersediaan yang lebih, dalam beberapa zona
dari satu penyedia cloud mereka, dan dukungan inilah yang akhirnya memperbolehkan fitur multi-zona dalam versi Kubernetes 1.2
(sebelumnya fitur ini dikenal dengan nama panggilan "Ubernetes Lite").</p><p>Dukungan multi-zona sengaja dibuat terbatas: dimana satu klaster Kubernetes hanya dapat berjalan
dalam beberapa zona, tetapi hanya pada wilayah yang sama (dan penyedia cloud yang sama pula). Hanya
GCE dan AWS yang saat ini mendukung fitur ini secara otomatis (meskipun cukup mudah
untuk menambahkan dukungan serupa untuk penyedia cloud yang lain atau bahkan untuk perangkat <em>baremetal</em>, hanya dengan mengatur
label yang sesuai untuk ditambahkan ke Node dan volume).</p><h2 id=fungsionalitas>Fungsionalitas</h2><p>Ketika Node mulai dijalankan, kubelet secara otomatis menambahkan label
informasi pada Node tersebut.</p><p>Kubernetes akan menyebarkan Pod secara otomatis dalam sebuah <em>controller</em> replikasi
atau Service lintas Node dalam sebuah klaster zona tunggal (untuk mengurangi dampak
kegagalan). Dengan klaster multi-zona, perilaku penyebaran ini akan
dilanjutkan hingga melintasi zona (untuk mengurangi dampak kegagalan dalam satu zona.) (Ini
dicapai melalui opsi <code>SelectorSpreadPriority</code>). Hal tersebut adalah untuk upaya penempatan terbaik,
apabila zona pada klaster kamu bersifat heterogen
(mis. jumlah Node yang berbeda, tipe Node yang berbeda, atau
persyaratan sumber daya Pod yag berbeda), yang akan mencegah dengan sempurna
penyebaran Pod kamu untuk melintasi zona yang berbeda. Jika diinginkan, kamu bisa menggunakan
zona yang homogen (jumlah dan jenis Node yang sama) untuk mengurangi
probabilitas penyebaran yang tidak merata.</p><p>Pada saat volume persisten dibuat, <em>controller</em> penerima <code>PersistentVolumeLabel</code>
akan secara otomatis menambahkan label zona pada volume tersebut. Penjadwal (melalui
predikat <code>VolumeZonePredicate</code>) kemudian akan memastikan bahwa Pod yang mengklaim
suatu volume hanya akan ditempatkan pada zona yang sama dengan volume tersebut, karena volume
tidak dapat di-<em>attach</em> melintasi zona yang berbeda.</p><h2 id=batasan>Batasan</h2><p>Ada beberapa batasan penting dari dukungan multi-zona:</p><ul><li><p>Kami berasumsi bahwa zona yang berbeda terletak secara berdekatan satu sama lain dalam
jaringan, jadi kami tidak melakukan <em>routing</em> yang sadar akan zona. Secara khusus, lalu lintas (<em>traffic</em>)
yang berjalan melalui Service mungkin melintasi beberapa zona (bahkan ketika beberapa Pod yang mendukung Service itu
berada pada zona yang sama dengan klien), dan hal ini dapat menimbulkan latensi dan biaya tambahan.</p></li><li><p>Volume <em>zone-afinity</em> hanya akan bekerja dengan PersistentVolume, dan tidak akan
berfungsi apabila kamu secara langsung menentukan volume EBS dalam spesifikasi Pod (misalnya).</p></li><li><p>Klaster tidak dapat melebarkan jangkauan cloud atau <em>region</em> (fungsi ini akan membutuhkan
dukungan penuh federasi).</p></li><li><p>Meskipun Node kamu berada dalam beberapa zona, saat ini kube-up hanya membuat
satu Node master secara bawaan (<em>default</em>). Karena Service memerlukan
ketersediaan (<em>availability</em>) yang tinggi dan dapat mentolerir akan hilangnya sebuah zona, maka <em>control plane</em>
diletakkan pada setiap zona. Pengguna yang menginginkan <em>control plane</em> yang memiliki ketersediaan
tinggi harus mengikuti instruksi <a href=/docs/admin/high-availability>ketersediaan tinggi</a>.</p></li></ul><h3 id=batasan-volume>Batasan Volume</h3><p>Batasan berikut ditunjukkan dengan menggunakan <a href=/id/docs/concepts/storage/storage-classes/#mode-volume-_binding_>pengikatan volume yang sadar topologi</a>.</p><ul><li><p>Penyebaran zona volume StatefulSet yang menggunakan penyediaan secara dinamis, saat ini tidak sesuai dengan
kebijakan afinitas atau anti-afinitas Pod.</p></li><li><p>Jika nama StatefulSet berisi tanda hubung ("-"), maka penyebaran zona volume
mungkin saja tidak menyediakan distribusi penyimpanan (<em>storage</em>) yang seragam di seluruh zona yang berbeda.</p></li><li><p>Ketika menentukan beberapa PVC dalam spesifikasi Deployment atau Pod, StorageClass
perlu dikonfigurasi untuk zona tunggal tertentu, atau PV perlu
disediakan secara statis pada zona tertentu. Solusi lainnya adalah menggunakan sebuah
StatefulSet, yang akan memastikan bahwa semua volume untuk sebuah replika
disediakan dalam zona yang sama.</p></li></ul><h2 id=panduan>Panduan</h2><p>Kita sekarang akan berjalan melalui pengaturan dan menggunakan multi-zona
klaster pada GCE & AWS. Untuk melakukannya, kamu perlu mengaktifkan klaster penuh
(dengan menentukan <code>MULTIZONE=true</code>), dan kemudian kamu menambahkan Node di zona tambahan
dengan menjalankan <code>kube-up</code> lagi (dengan menetapkan opsi <code>KUBE_USE_EXISTING_MASTER=true</code>).</p><h3 id=mengaktifkan-klaster-kamu>Mengaktifkan klaster kamu</h3><p>Buatlah klaster seperti biasa, tetapi teruskan opsi MULTIZONE untuk memberi tahu klaster untuk mengelola beberapa zona;
dan membuat Node di zona us-central1-a.</p><p>GCE:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -sS https://get.k8s.io | <span style=color:#b8860b>MULTIZONE</span><span style=color:#666>=</span><span style=color:#a2f>true</span> <span style=color:#b8860b>KUBERNETES_PROVIDER</span><span style=color:#666>=</span>gce <span style=color:#b8860b>KUBE_GCE_ZONE</span><span style=color:#666>=</span>us-central1-a <span style=color:#b8860b>NUM_NODES</span><span style=color:#666>=</span><span style=color:#666>3</span> bash
</span></span></code></pre></div><p>AWS:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -sS https://get.k8s.io | <span style=color:#b8860b>MULTIZONE</span><span style=color:#666>=</span><span style=color:#a2f>true</span> <span style=color:#b8860b>KUBERNETES_PROVIDER</span><span style=color:#666>=</span>aws <span style=color:#b8860b>KUBE_AWS_ZONE</span><span style=color:#666>=</span>us-west-2a <span style=color:#b8860b>NUM_NODES</span><span style=color:#666>=</span><span style=color:#666>3</span> bash
</span></span></code></pre></div><p>Langkah ini akan mengaktifkan klaster seperti biasa, namun masih berjalan dalam satu zona
(tetapi opsi <code>MULTIZONE=true</code> telah mengaktifkan kapabilitas multi-zona).</p><h3 id=node-yang-telah-diberi-label>Node yang telah diberi label</h3><p>Lihatlah Node; dimana kamu bisa melihat Node tersebut diberi label sesuai dengan informasi zona.
Node tersebut sejauh ini berada di zona <code>us-central1-a</code> (GCE) atau zona <code>us-west-2a</code> (AWS).
Label dari Node itu adalah <code>failure-domain.beta.kubernetes.io/region</code> untuk informasi wilayah,
dan <code>failure-domain.beta.kubernetes.io/zone</code> untuk informasi zona:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get nodes --show-labels
</span></span></code></pre></div><p>Tampilan akan seperti dibawah ini:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME                     STATUS                     ROLES    AGE   VERSION          LABELS
</span></span><span style=display:flex><span>kubernetes-master        Ready,SchedulingDisabled   &lt;none&gt;   6m    v1.13.0          beta.kubernetes.io/instance-type<span style=color:#666>=</span>n1-standard-1,failure-domain.beta.kubernetes.io/region<span style=color:#666>=</span>us-central1,failure-domain.beta.kubernetes.io/zone<span style=color:#666>=</span>us-central1-a,kubernetes.io/hostname<span style=color:#666>=</span>kubernetes-master
</span></span><span style=display:flex><span>kubernetes-minion-87j9   Ready                      &lt;none&gt;   6m    v1.13.0          beta.kubernetes.io/instance-type<span style=color:#666>=</span>n1-standard-2,failure-domain.beta.kubernetes.io/region<span style=color:#666>=</span>us-central1,failure-domain.beta.kubernetes.io/zone<span style=color:#666>=</span>us-central1-a,kubernetes.io/hostname<span style=color:#666>=</span>kubernetes-minion-87j9
</span></span><span style=display:flex><span>kubernetes-minion-9vlv   Ready                      &lt;none&gt;   6m    v1.13.0          beta.kubernetes.io/instance-type<span style=color:#666>=</span>n1-standard-2,failure-domain.beta.kubernetes.io/region<span style=color:#666>=</span>us-central1,failure-domain.beta.kubernetes.io/zone<span style=color:#666>=</span>us-central1-a,kubernetes.io/hostname<span style=color:#666>=</span>kubernetes-minion-9vlv
</span></span><span style=display:flex><span>kubernetes-minion-a12q   Ready                      &lt;none&gt;   6m    v1.13.0          beta.kubernetes.io/instance-type<span style=color:#666>=</span>n1-standard-2,failure-domain.beta.kubernetes.io/region<span style=color:#666>=</span>us-central1,failure-domain.beta.kubernetes.io/zone<span style=color:#666>=</span>us-central1-a,kubernetes.io/hostname<span style=color:#666>=</span>kubernetes-minion-a12q
</span></span></code></pre></div><h3 id=menambah-lebih-banyak-node-di-zona-kedua>Menambah lebih banyak Node di zona kedua</h3><p>Mari kita tambahkan sekumpulan Node ke dalam klaster yang ada, dengan menggunakan kembali
master yang ada, namun dijalankan pada zona yang berbeda (zona <code>us-central1-b</code> atau zona <code>us-west-2b</code>).
Kemudian kita jalankan kube-up lagi, tetapi dengan menentukan opsi <code>KUBE_USE_EXISTING_MASTER=true</code>
sehingga kube-up tidak akan membuat master baru, tetapi akan menggunakan kembali master yang dibuat sebelumnya.</p><p>GCE:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#b8860b>KUBE_USE_EXISTING_MASTER</span><span style=color:#666>=</span><span style=color:#a2f>true</span> <span style=color:#b8860b>MULTIZONE</span><span style=color:#666>=</span><span style=color:#a2f>true</span> <span style=color:#b8860b>KUBERNETES_PROVIDER</span><span style=color:#666>=</span>gce <span style=color:#b8860b>KUBE_GCE_ZONE</span><span style=color:#666>=</span>us-central1-b <span style=color:#b8860b>NUM_NODES</span><span style=color:#666>=</span><span style=color:#666>3</span> kubernetes/cluster/kube-up.sh
</span></span></code></pre></div><p>Pada AWS, kita juga perlu menentukan CIDR jaringan sebagai tambahan
subnet, bersama dengan alamat IP internal dari master:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#b8860b>KUBE_USE_EXISTING_MASTER</span><span style=color:#666>=</span><span style=color:#a2f>true</span> <span style=color:#b8860b>MULTIZONE</span><span style=color:#666>=</span><span style=color:#a2f>true</span> <span style=color:#b8860b>KUBERNETES_PROVIDER</span><span style=color:#666>=</span>aws <span style=color:#b8860b>KUBE_AWS_ZONE</span><span style=color:#666>=</span>us-west-2b <span style=color:#b8860b>NUM_NODES</span><span style=color:#666>=</span><span style=color:#666>3</span> <span style=color:#b8860b>KUBE_SUBNET_CIDR</span><span style=color:#666>=</span>172.20.1.0/24 <span style=color:#b8860b>MASTER_INTERNAL_IP</span><span style=color:#666>=</span>172.20.0.9 kubernetes/cluster/kube-up.sh
</span></span></code></pre></div><p>Lihat lagi Node; dimana 3 Node lainnya harus sudah dijalankan dan ditandai
berada di <code>us-central1-b</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get nodes --show-labels
</span></span></code></pre></div><p>Hasil tampilan akan terlihat seperti dibawah ini:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME                     STATUS                     ROLES    AGE   VERSION           LABELS
</span></span><span style=display:flex><span>kubernetes-master        Ready,SchedulingDisabled   &lt;none&gt;   16m   v1.13.0           beta.kubernetes.io/instance-type<span style=color:#666>=</span>n1-standard-1,failure-domain.beta.kubernetes.io/region<span style=color:#666>=</span>us-central1,failure-domain.beta.kubernetes.io/zone<span style=color:#666>=</span>us-central1-a,kubernetes.io/hostname<span style=color:#666>=</span>kubernetes-master
</span></span><span style=display:flex><span>kubernetes-minion-281d   Ready                      &lt;none&gt;   2m    v1.13.0           beta.kubernetes.io/instance-type<span style=color:#666>=</span>n1-standard-2,failure-domain.beta.kubernetes.io/region<span style=color:#666>=</span>us-central1,failure-domain.beta.kubernetes.io/zone<span style=color:#666>=</span>us-central1-b,kubernetes.io/hostname<span style=color:#666>=</span>kubernetes-minion-281d
</span></span><span style=display:flex><span>kubernetes-minion-87j9   Ready                      &lt;none&gt;   16m   v1.13.0           beta.kubernetes.io/instance-type<span style=color:#666>=</span>n1-standard-2,failure-domain.beta.kubernetes.io/region<span style=color:#666>=</span>us-central1,failure-domain.beta.kubernetes.io/zone<span style=color:#666>=</span>us-central1-a,kubernetes.io/hostname<span style=color:#666>=</span>kubernetes-minion-87j9
</span></span><span style=display:flex><span>kubernetes-minion-9vlv   Ready                      &lt;none&gt;   16m   v1.13.0           beta.kubernetes.io/instance-type<span style=color:#666>=</span>n1-standard-2,failure-domain.beta.kubernetes.io/region<span style=color:#666>=</span>us-central1,failure-domain.beta.kubernetes.io/zone<span style=color:#666>=</span>us-central1-a,kubernetes.io/hostname<span style=color:#666>=</span>kubernetes-minion-9vlv
</span></span><span style=display:flex><span>kubernetes-minion-a12q   Ready                      &lt;none&gt;   17m   v1.13.0           beta.kubernetes.io/instance-type<span style=color:#666>=</span>n1-standard-2,failure-domain.beta.kubernetes.io/region<span style=color:#666>=</span>us-central1,failure-domain.beta.kubernetes.io/zone<span style=color:#666>=</span>us-central1-a,kubernetes.io/hostname<span style=color:#666>=</span>kubernetes-minion-a12q
</span></span><span style=display:flex><span>kubernetes-minion-pp2f   Ready                      &lt;none&gt;   2m    v1.13.0           beta.kubernetes.io/instance-type<span style=color:#666>=</span>n1-standard-2,failure-domain.beta.kubernetes.io/region<span style=color:#666>=</span>us-central1,failure-domain.beta.kubernetes.io/zone<span style=color:#666>=</span>us-central1-b,kubernetes.io/hostname<span style=color:#666>=</span>kubernetes-minion-pp2f
</span></span><span style=display:flex><span>kubernetes-minion-wf8i   Ready                      &lt;none&gt;   2m    v1.13.0           beta.kubernetes.io/instance-type<span style=color:#666>=</span>n1-standard-2,failure-domain.beta.kubernetes.io/region<span style=color:#666>=</span>us-central1,failure-domain.beta.kubernetes.io/zone<span style=color:#666>=</span>us-central1-b,kubernetes.io/hostname<span style=color:#666>=</span>kubernetes-minion-wf8i
</span></span></code></pre></div><h3 id=afinitas-volume>Afinitas Volume</h3><p>Buatlah sebuah volume dengan menggunakan pembuatan volume yang dinamis (hanya PersistentVolume yang didukung untuk afinitas zona):</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl apply -f - <span style=color:#b44>&lt;&lt;EOF
</span></span></span><span style=display:flex><span><span style=color:#b44>{
</span></span></span><span style=display:flex><span><span style=color:#b44>  &#34;apiVersion&#34;: &#34;v1&#34;,
</span></span></span><span style=display:flex><span><span style=color:#b44>  &#34;kind&#34;: &#34;PersistentVolumeClaim&#34;,
</span></span></span><span style=display:flex><span><span style=color:#b44>  &#34;metadata&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#b44>    &#34;name&#34;: &#34;claim1&#34;,
</span></span></span><span style=display:flex><span><span style=color:#b44>    &#34;annotations&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#b44>        &#34;volume.alpha.kubernetes.io/storage-class&#34;: &#34;foo&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44>    }
</span></span></span><span style=display:flex><span><span style=color:#b44>  },
</span></span></span><span style=display:flex><span><span style=color:#b44>  &#34;spec&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#b44>    &#34;accessModes&#34;: [
</span></span></span><span style=display:flex><span><span style=color:#b44>      &#34;ReadWriteOnce&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44>    ],
</span></span></span><span style=display:flex><span><span style=color:#b44>    &#34;resources&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#b44>      &#34;requests&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#b44>        &#34;storage&#34;: &#34;5Gi&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44>      }
</span></span></span><span style=display:flex><span><span style=color:#b44>    }
</span></span></span><span style=display:flex><span><span style=color:#b44>  }
</span></span></span><span style=display:flex><span><span style=color:#b44>}
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Untuk versi Kubernetes 1.3+ akan mendistribusikan klaim PV yang dinamis di seluruh
zona yang telah dikonfigurasi. Untuk versi 1.2, volume persisten yang dinamis selalu dibuat di zona master klaster
(yaitu <code>us-central1-a</code>/<code>us-west-2a</code>); masalah tersebut diangkat pada
(<a href=https://github.com/kubernetes/kubernetes/issues/23330>#23330</a>)
dan telah diselesaikan pada versi 1.3+.</div><p>Sekarang marilah kita memvalidasi bahwa Kubernetes secara otomatis memberikan label zona & wilayah di mana PV itu dibuat.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pv --show-labels
</span></span></code></pre></div><p>Hasil tampilan akan terlihat seperti dibawah ini:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME           CAPACITY   ACCESSMODES   RECLAIM POLICY   STATUS    CLAIM            STORAGECLASS    REASON    AGE       LABELS
</span></span><span style=display:flex><span>pv-gce-mj4gm   5Gi        RWO           Retain           Bound     default/claim1   manual                    46s       failure-domain.beta.kubernetes.io/region<span style=color:#666>=</span>us-central1,failure-domain.beta.kubernetes.io/zone<span style=color:#666>=</span>us-central1-a
</span></span></code></pre></div><p>Kemudian sekarang kita akan membuat Pod yang menggunakan klaim akan volume persisten.
Karena volume pada GCE PDs / AWS EBS tidak dapat di-<em>attach</em> melewati zona yang berbeda,
hal ini berarti bahwa Pod ini hanya dapat dibuat pada zona yang sama dengan volume tersebut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>kubectl apply -f - &lt;&lt;EOF<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myfrontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/var/www/html&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypd<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypd<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>persistentVolumeClaim</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>claimName</span>:<span style=color:#bbb> </span>claim1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>EOF<span style=color:#bbb>
</span></span></span></code></pre></div><p>Perhatikan bahwa Pod secara otomatis dibuat pada zona yang sama dengan volume, karena
pada umumnya lampiran lintas zona tidak diizinkan oleh penyedia cloud:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe pod mypod | grep Node
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>Node:        kubernetes-minion-9vlv/10.240.0.5
</span></span></code></pre></div><p>Kemudian cek label Node:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get node kubernetes-minion-9vlv --show-labels
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME                     STATUS    AGE    VERSION          LABELS
</span></span><span style=display:flex><span>kubernetes-minion-9vlv   Ready     22m    v1.6.0+fff5156   beta.kubernetes.io/instance-type<span style=color:#666>=</span>n1-standard-2,failure-domain.beta.kubernetes.io/region<span style=color:#666>=</span>us-central1,failure-domain.beta.kubernetes.io/zone<span style=color:#666>=</span>us-central1-a,kubernetes.io/hostname<span style=color:#666>=</span>kubernetes-minion-9vlv
</span></span></code></pre></div><h3 id=pod-yang-tersebar-melintasi-zona-yang-berbeda>Pod yang tersebar melintasi zona yang berbeda</h3><p>Pod dalam <em>controller</em> atau Service replikasi tersebar secara otomatis
melintasi zona yang berbeda. Pertama-tama, mari kita luncurkan lebih banyak Node di zona ketiga:</p><p>GCE:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#b8860b>KUBE_USE_EXISTING_MASTER</span><span style=color:#666>=</span><span style=color:#a2f>true</span> <span style=color:#b8860b>MULTIZONE</span><span style=color:#666>=</span><span style=color:#a2f>true</span> <span style=color:#b8860b>KUBERNETES_PROVIDER</span><span style=color:#666>=</span>gce <span style=color:#b8860b>KUBE_GCE_ZONE</span><span style=color:#666>=</span>us-central1-f <span style=color:#b8860b>NUM_NODES</span><span style=color:#666>=</span><span style=color:#666>3</span> kubernetes/cluster/kube-up.sh
</span></span></code></pre></div><p>AWS:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#b8860b>KUBE_USE_EXISTING_MASTER</span><span style=color:#666>=</span><span style=color:#a2f>true</span> <span style=color:#b8860b>MULTIZONE</span><span style=color:#666>=</span><span style=color:#a2f>true</span> <span style=color:#b8860b>KUBERNETES_PROVIDER</span><span style=color:#666>=</span>aws <span style=color:#b8860b>KUBE_AWS_ZONE</span><span style=color:#666>=</span>us-west-2c <span style=color:#b8860b>NUM_NODES</span><span style=color:#666>=</span><span style=color:#666>3</span> <span style=color:#b8860b>KUBE_SUBNET_CIDR</span><span style=color:#666>=</span>172.20.2.0/24 <span style=color:#b8860b>MASTER_INTERNAL_IP</span><span style=color:#666>=</span>172.20.0.9 kubernetes/cluster/kube-up.sh
</span></span></code></pre></div><p>Pastikan bahwa kamu mempunyai Node dalam 3 zona berbeda:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get nodes --show-labels
</span></span></code></pre></div><p>Buatlah contoh dengan program guestbook-go, yang mencakup RC dengan ukuran 3, dan menjalankan sebuah aplikasi web sederhana:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>find kubernetes/examples/guestbook-go/ -name <span style=color:#b44>&#39;*.json&#39;</span> | xargs -I <span style=color:#666>{}</span> kubectl apply -f <span style=color:#666>{}</span>
</span></span></code></pre></div><p>Beberapa Pod seharusnya tersebar di ketiga zona semuanya:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe pod -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>guestbook | grep Node
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>Node:        kubernetes-minion-9vlv/10.240.0.5
</span></span><span style=display:flex><span>Node:        kubernetes-minion-281d/10.240.0.8
</span></span><span style=display:flex><span>Node:        kubernetes-minion-olsh/10.240.0.11
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get node kubernetes-minion-9vlv kubernetes-minion-281d kubernetes-minion-olsh --show-labels
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME                     STATUS    ROLES    AGE    VERSION          LABELS
</span></span><span style=display:flex><span>kubernetes-minion-9vlv   Ready     &lt;none&gt;   34m    v1.13.0          beta.kubernetes.io/instance-type<span style=color:#666>=</span>n1-standard-2,failure-domain.beta.kubernetes.io/region<span style=color:#666>=</span>us-central1,failure-domain.beta.kubernetes.io/zone<span style=color:#666>=</span>us-central1-a,kubernetes.io/hostname<span style=color:#666>=</span>kubernetes-minion-9vlv
</span></span><span style=display:flex><span>kubernetes-minion-281d   Ready     &lt;none&gt;   20m    v1.13.0          beta.kubernetes.io/instance-type<span style=color:#666>=</span>n1-standard-2,failure-domain.beta.kubernetes.io/region<span style=color:#666>=</span>us-central1,failure-domain.beta.kubernetes.io/zone<span style=color:#666>=</span>us-central1-b,kubernetes.io/hostname<span style=color:#666>=</span>kubernetes-minion-281d
</span></span><span style=display:flex><span>kubernetes-minion-olsh   Ready     &lt;none&gt;   3m     v1.13.0          beta.kubernetes.io/instance-type<span style=color:#666>=</span>n1-standard-2,failure-domain.beta.kubernetes.io/region<span style=color:#666>=</span>us-central1,failure-domain.beta.kubernetes.io/zone<span style=color:#666>=</span>us-central1-f,kubernetes.io/hostname<span style=color:#666>=</span>kubernetes-minion-olsh
</span></span></code></pre></div><p><em>Load-balancer</em> menjangkau semua zona dalam satu klaster; program contoh guestbook-go
sudah termasuk contoh Service dengan beban seimbang (<em>load-balanced service</em>):</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe service guestbook | grep LoadBalancer.Ingress
</span></span></code></pre></div><p>Hasil tampilan akan terlihat seperti di bawah ini:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>LoadBalancer Ingress:   130.211.126.21
</span></span></code></pre></div><p>Atur alamat IP di atas:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>export</span> <span style=color:#b8860b>IP</span><span style=color:#666>=</span>130.211.126.21
</span></span></code></pre></div><p>Telusurilah dengan curl melalui alamat IP tersebut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -s http://<span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>IP</span><span style=color:#b68;font-weight:700>}</span>:3000/env | grep HOSTNAME
</span></span></code></pre></div><p>Hasil tampilan akan terlihat seperti di bawah ini:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  <span style=color:#b44>&#34;HOSTNAME&#34;</span>: <span style=color:#b44>&#34;guestbook-44sep&#34;</span>,
</span></span></code></pre></div><p>Kemudian, telusurilah beberapa kali:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#666>(</span><span style=color:#a2f;font-weight:700>for</span> i in <span style=color:#b44>`</span>seq 20<span style=color:#b44>`</span>; <span style=color:#a2f;font-weight:700>do</span> curl -s http://<span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>IP</span><span style=color:#b68;font-weight:700>}</span>:3000/env | grep HOSTNAME; <span style=color:#a2f;font-weight:700>done</span><span style=color:#666>)</span>  | sort | uniq
</span></span></code></pre></div><p>Hasil tampilan akan terlihat seperti dibawah ini:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  <span style=color:#b44>&#34;HOSTNAME&#34;</span>: <span style=color:#b44>&#34;guestbook-44sep&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#b44>&#34;HOSTNAME&#34;</span>: <span style=color:#b44>&#34;guestbook-hum5n&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#b44>&#34;HOSTNAME&#34;</span>: <span style=color:#b44>&#34;guestbook-ppm40&#34;</span>,
</span></span></code></pre></div><p><em>Load balancer</em> telah menargetkan ke semua Pod dengan benar, meskipun semuanya berada di beberapa zona yang berbeda.</p><h3 id=menghentikan-klaster>Menghentikan Klaster</h3><h3 id=shutting-down-the-cluster>Shutting down the cluster</h3><p>Apabila kamu sudah selesai, maka bersihkanlah:</p><p>GCE:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#b8860b>KUBERNETES_PROVIDER</span><span style=color:#666>=</span>gce <span style=color:#b8860b>KUBE_USE_EXISTING_MASTER</span><span style=color:#666>=</span><span style=color:#a2f>true</span> <span style=color:#b8860b>KUBE_GCE_ZONE</span><span style=color:#666>=</span>us-central1-f kubernetes/cluster/kube-down.sh
</span></span><span style=display:flex><span><span style=color:#b8860b>KUBERNETES_PROVIDER</span><span style=color:#666>=</span>gce <span style=color:#b8860b>KUBE_USE_EXISTING_MASTER</span><span style=color:#666>=</span><span style=color:#a2f>true</span> <span style=color:#b8860b>KUBE_GCE_ZONE</span><span style=color:#666>=</span>us-central1-b kubernetes/cluster/kube-down.sh
</span></span><span style=display:flex><span><span style=color:#b8860b>KUBERNETES_PROVIDER</span><span style=color:#666>=</span>gce <span style=color:#b8860b>KUBE_GCE_ZONE</span><span style=color:#666>=</span>us-central1-a kubernetes/cluster/kube-down.sh
</span></span></code></pre></div><p>AWS:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#b8860b>KUBERNETES_PROVIDER</span><span style=color:#666>=</span>aws <span style=color:#b8860b>KUBE_USE_EXISTING_MASTER</span><span style=color:#666>=</span><span style=color:#a2f>true</span> <span style=color:#b8860b>KUBE_AWS_ZONE</span><span style=color:#666>=</span>us-west-2c kubernetes/cluster/kube-down.sh
</span></span><span style=display:flex><span><span style=color:#b8860b>KUBERNETES_PROVIDER</span><span style=color:#666>=</span>aws <span style=color:#b8860b>KUBE_USE_EXISTING_MASTER</span><span style=color:#666>=</span><span style=color:#a2f>true</span> <span style=color:#b8860b>KUBE_AWS_ZONE</span><span style=color:#666>=</span>us-west-2b kubernetes/cluster/kube-down.sh
</span></span><span style=display:flex><span><span style=color:#b8860b>KUBERNETES_PROVIDER</span><span style=color:#666>=</span>aws <span style=color:#b8860b>KUBE_AWS_ZONE</span><span style=color:#666>=</span>us-west-2a kubernetes/cluster/kube-down.sh
</span></span></code></pre></div></div><div class=td-content style=page-break-before:always><h1 id=pg-dd948255948d6b59b32c471abcb62997>3 - Konsep</h1><p>Bagian konsep ini membantu kamu belajar tentang bagian-bagian sistem serta abstraksi
yang digunakan Kubernetes untuk merepresentasikan klaster kamu, serta membantu
kamu belajar lebih dalam bagaimana cara kerja Kubernetes.</p><h2 id=ikhtisar>Ikhtisar</h2><p>Untuk menggunakan Kubernetes, kamu menggunakan objek-objek <em>Kubernetes API</em> untuk merepresentasikan
<em>state</em> yang diinginkan: apa yang aplikasi atau <em>workload</em> lain yang ingin kamu
jalankan, <em>image</em> kontainer yang digunakan, jaringan atau <em>resource disk</em> apa yang ingin
kamu sediakan, dan lain sebagainya. Kamu membuat <em>state</em> yang diinginkan dengan cara membuat
objek dengan menggunakan API Kubernetes, dan biasanya menggunakan <code>command-line interface</code>, yaitu <code>kubectl</code>.
Kamu juga dapat secara langsung berinteraksi dengan klaster untuk membuat atau mengubah
<em>state</em> yang kamu inginkan.</p><p>Setelah kamu membuat <em>state</em> yang kamu inginkan, <em>Control Plane</em> Kubernetes
menggunakan <code>Pod Lifecycle Event Generator (PLEG)</code> untuk mengubah
<em>state</em> yang ada saat ini supaya sama dengan <em>state</em> yang diinginkan.
Untuk melakukan hal tersebut, Kubernetes melakukan berbagai <em>task</em> secara otomatis,
misalnya dengan mekanisme <code>start</code> atau <code>stop</code> kontainer, melakukan <em>scale</em> replika dari
suatu aplikasi, dan lain sebagainya. <em>Control Plane</em> Kubernetes terdiri dari sekumpulan
<code>process</code> yang dijalankan di klaster:</p><ul><li><strong>Kubernetes Master</strong> terdiri dari tiga buah <em>process</em> yang dijalankan pada sebuah <em>node</em> di klaster kamu, <em>node</em> ini disebut sebagai <em>master</em>, yang terdiri <a href=/docs/admin/kube-apiserver/>kube-apiserver</a>, <a href=/docs/admin/kube-controller-manager/>kube-controller-manager</a> dan <a href=/docs/admin/kube-scheduler/>kube-scheduler</a>.</li><li>Setiap <em>node</em> non-master pada klaster kamu menjalankan dua buah <em>process</em>:<ul><li><strong><a href=/docs/admin/kubelet/>kubelet</a></strong>, yang menjadi perantara komunikasi dengan <em>master</em>.</li><li><strong><a href=/docs/admin/kube-proxy/>kube-proxy</a></strong>, sebuah <em>proxy</em> yang merupakan representasi jaringan yang ada pada setiap <em>node</em>.</li></ul></li></ul><h2 id=objek-kubernetes>Objek Kubernetes</h2><p>Kubernetes memiliki beberapa abstraksi yang merepresentasikan <em>state</em> dari sistem kamu:
apa yang aplikasi atau <em>workload</em> lain yang ingin kamu jalankan, jaringan atau <em>resource disk</em> apa yang ingin
kamu sediakan, serta beberapa informasi lain terkait apa yang sedang klaster kamu lakukan.
Abstraksi ini direpresentasikan oleh objek yang tersedia di API Kubernetes;
lihat <a href=/docs/concepts/abstractions/overview/>ikhtisar objek-objek Kubernetes</a>
untuk penjelasan yang lebih mendetail.</p><p>Objek mendasar Kubernetes termasuk:</p><ul><li><a href=/id/docs/concepts/workloads/pods/pod-overview/>Pod</a></li><li><a href=/id/docs/concepts/services-networking/service/>Service</a></li><li><a href=/id/docs/concepts/storage/volumes/>Volume</a></li><li><a href=/id/docs/concepts/overview/working-with-objects/namespaces/>Namespace</a></li></ul><p>Sebagai tambahan, Kubernetes memiliki beberapa abstraksi yang lebih tinggi yang disebut kontroler.
Kontroler merupakan objek mendasar dengan fungsi tambahan, contoh dari kontroler ini adalah:</p><ul><li><a href=/id/docs/concepts/workloads/controllers/replicaset/>ReplicaSet</a></li><li><a href=/id/docs/concepts/workloads/controllers/deployment/>Deployment</a></li><li><a href=/id/docs/concepts/workloads/controllers/statefulset/>StatefulSet</a></li><li><a href=/id/docs/concepts/workloads/controllers/daemonset/>DaemonSet</a></li><li><a href=/id/docs/concepts/workloads/controllers/job/>Job</a></li></ul><h2 id=control-plane-kubernetes><em>Control Plane</em> Kubernetes</h2><p>Berbagai bagian <em>Control Plane</em> Kubernetes, seperti <em>master</em> dan <em>process-process</em> kubelet,
mengatur bagaimana Kubernetes berkomunikasi dengan klaster kamu. <em>Control Plane</em>
menjaga seluruh <em>record</em> dari objek Kubernetes serta terus menjalankan
iterasi untuk melakukan manajemen <em>state</em> objek. <em>Control Plane</em> akan memberikan respon
apabila terdapat perubahan pada klaster kamu dan mengubah <em>state</em> saat ini agar sesuai
dengan <em>state</em> yang diinginkan.</p><p>Contohnya, ketika kamu menggunakan API Kubernetes untuk membuat sebuah <em>Deployment</em>,
kamu memberikan sebuah <em>state</em> baru yang harus dipenuhi oleh sistem. <em>Control Plane</em>
kemudian akan mencatat objek apa saja yang dibuat, serta menjalankan instruksi yang kamu berikan
dengan cara melakukan <code>start</code> aplikasi dan melakukan <code>scheduling</code> aplikasi tersebut
pada <em>node</em>, dengan kata lain mengubah <em>state</em> saat ini agar sesuai dengan <em>state</em> yang diinginkan.</p><h3 id=master>Master</h3><p>Master Kubernetes bertanggung jawab untuk memelihara <em>state</em> yang diinginkan pada klaster kamu.
Ketika kamu berinteraksi dengan Kubernetes, misalnya saja menggunakan perangkat <code>kubectl</code>,
kamu berkomunikasi dengan <em>master</em> klaster Kubernetes kamu.</p><blockquote><p>"master" merujuk pada tiga buah <em>process</em> yang dijalankan pada sebuah <em>node</em> pada klaster kamu, <em>node</em> ini disebut sebagai <em>master</em>, yang terdiri <a href=/docs/admin/kube-apiserver/>kube-apiserver</a>, <a href=/docs/admin/kube-controller-manager/>kube-controller-manager</a> dan <a href=/docs/admin/kube-scheduler/>kube-scheduler</a>.</p></blockquote><h3 id=node>Node</h3><p><em>Node</em> di dalam klaster Kubernetes adalah mesin (mesin virtual maupun fisik) yang
menjalankan aplikasi kamu. Master mengontrol setiap node; kamu akan jarang berinteraksi
dengan <em>node</em> secara langsung.</p><h4 id=metadata-objek>Metadata objek</h4><ul><li><a href=/id/docs/concepts/overview/working-with-objects/annotations/>Anotasi</a></li></ul><h2 id=selanjutnya>Selanjutnya</h2><p>Jika kamu ingin menulis halaman konsep, perhatikan
<a href=/docs/home/contribute/page-templates/>cara penggunaan template pada laman</a>
untuk informasi mengenai konsep tipe halaman dan <em>template</em> konsep.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-0554ac387412eaf4e6e89b2f847dacde>3.1 - Ikhtisar</h1></div><div class=td-content><h1 id=pg-45bdca6129cf540121623e903c18ba46>3.1.1 - Apa itu Kubernetes?</h1><div class=lead>Kubernetes merupakan <em>platform open-source</em> yang digunakan untuk melakukan manajemen <em>workloads</em> aplikasi yang dikontainerisasi, serta menyediakan konfigurasi dan otomatisasi secara deklaratif. Kubernetes berada di dalam ekosistem yang besar dan berkembang cepat. <em>Service</em>, <em>support</em>, dan perkakas Kubernetes tersedia secara meluas. Kubernetes merupakan <em>platform open-source</em> yang digunakan untuk melakukan manajemen <em>workloads</em> aplikasi yang dikontainerisasi, serta menyediakan konfigurasi dan otomatisasi secara deklaratif. Kubernetes berada di dalam ekosistem yang besar dan berkembang cepat. <em>Service</em>, <em>support</em>, dan perkakas Kubernetes tersedia secara meluas.</div><p>Laman ini merupakan ikhtisar Kubernetes.</p><p>Kubernetes merupakan <i>platform open-source</i> yang digunakan untuk melakukan
manajemen <i>workloads</i> aplikasi yang dikontainerisasi, serta menyediakan
konfigurasi dan otomatisasi secara deklaratif. Kubernetes berada di dalam ekosistem
yang besar dan berkembang cepat. <i>Service</i>, <i>support</i>, dan perkakas
Kubernetes tersedia secara meluas.</p><p>Google membuka Kubernetes sebagai proyek <i>open source</i> pada tahun 2014.
Kubernetes dibangun berdasarkan <a href=https://research.google.com/pubs/pub43438.html>pengalaman Google selama satu setengah dekade dalam menjalankan workloads</a>
bersamaan dengan kontribusi berupa ide-ide terbaik yang diberikan oleh komunitas.</p><h2 id=mengapa-kubernetes-dan-hal-apa-saja-yang-dapat-dilakukan-oleh-kubernetes>Mengapa Kubernetes dan hal apa saja yang dapat dilakukan oleh Kubernetes?</h2><p>Kubernetes memiliki sejumlah fitur yang dapat dijabarkan sebagai berikut:</p><ul><li><i>platform</i> kontainer</li><li><i>platform microservices</i></li><li><i>platform cloud</i> yang tidak mudah dipindahkan</li></ul><p>Kubernetes menyediakan manajemen <i>environment</i> yang berpusat pada kontainer.
Kubernetes melakukan orkestrasi terhadap <i>computing</i>, <i>networking</i>,
dan inftrastruktur penyimpanan. Fitur inilah yang kemudian membuat konsep Platform as a Service (PaaS)
menjadi lebih sederhana dilengkapi dengan fleksibilitas yang dimiliki oleh Infrastructure as a Service (IaaS).</p><h2 id=lalu-apa-yang-menyebabkan-kubernetes-disebut-sebagai-sebuah-platform>Lalu apa yang menyebabkan Kubernetes disebut sebagai sebuah platform?</h2><p>Meskipun Kubernetes menyediakan banyak fungsionalitas, selalu ada keadaan dimana
hal tersebut membutuhkan fitur baru. <i>Workflow</i> spesifik yang terkait dengan
proses pengembangan aplikasi dapat ditambahkan pada <i>streamline</i> untuk meningkatkan
produktivitas developer. Orkestrasi ad-hoc yang dapat diterima biasanya membutuhkan desain
otomatisasi yang kokoh agar bersifat <i>scalable</i>. Hal inilah yang membuat
Kubernetes juga didesain sebagai <i>platform</i> untuk membangun ekosistem komponen dan
dan perkakas untuk memudahkan proses <i>deployment</i>, <i>scale</i>, dan juga manajemen
aplikasi.</p><p><a href>Labels</a> memudahkan pengguna mengkategorisasikan <i>resources</i> yang mereka miliki
sesuai dengan kebutuhan. <a href>Annotations</a> memungkinkan pengguna untuk menambahkan informasi
tambahan pada <i>resource</i> yang dimiliki.</p><p>Selain itu, <a href>Kubernetes control plane</a> dibuat berdasarkan
<a href=/docs/reference/using-api/api-overview/>API</a> yang tersedia bagi pengguna dan developer. Pengguna
dapat mengimplementasikan kontroler sesuai dengan kebutuhan mereka, contohnya adalah
<a href=https://github.com/kubernetes/community/blob/main/contributors/devel/scheduler.md>schedulers</a>,
dengan <a href>API kustom yang mereka miliki</a>, kontroler kustom ini kemudian dapat digunakan
pada <a href>command-line
tool</a> generik yang ada.</p><p><a href=https://git.k8s.io/community/contributors/design-proposals/architecture/architecture.md>Desain</a>
inilah yang memungkinkan beberapa sistem lain untuk dapat dibangun di atas Kubernetes.</p><h2 id=lalu-hal-apakah-yang-tidak-termasuk-di-dalam-kubernetes>Lalu hal apakah yang tidak termasuk di dalam Kubernetes?</h2><p>Kubernetes bukanlah sebuah <i>PaaS (Platform as a
Service)</i> yang biasanya. Meskipun Kubernetes dijalankan pada tingkatan kontainer
dan bukan pada tingkatan perangkat keras, Kubernetes menyediakan beberapa fitur
yang biasanya disediakan oleh Paas, seperti <i>deployment</i>, <i>scaling</i>,
<i>load balancing</i>, <i>logging</i>, dan <i>monitoring</i>. Akan tetapi,
Kubernetes bukanlah sistem monolitik, melainkan suatu sistem yang bersifat sebagai
<i>bulding block</i> dan <i>pluggable</i> yang dapat digunakan untuk membangun sebuah
platform yang dibutuhkan oleh developer dengan tetap mengutamakan konsep fleksibilitas.</p><p>Kubernetes:</p><ul><li>Tidak melakukan limitasi terhadap aplikasi yang di-support. Kubernetes bertujuan
untuk mendukung berbagai variasi <i>workloads</i>, termasuk
<i>stateless</i>, <i>stateful</i>, dan <i>data-processing</i>. Jika sebuah
aplikasi dapat dijalankan di atas kontainer, maka aplikasi tersebut juga dapat
dijalankan di atas Kubernetes.</li><li>Tidak menyediakan mekanisme untuk melakukan <i>deploy</i> kode sumber
maupun mekanisme <i>build</i> sebuah aplikasi. <i>Continuous Integration, Delivery, and Deployment
(CI/CD) workflows</i> ditentukan oleh preferensi serta kebutuhan teknis organisasi.</li><li>Tidak menyediakan <i>application-level services</i>, seperti <i>middleware
(e.g., message buses)</i>, <i>data-processing frameworks (for example,
Spark)</i>, <i>databases (e.g., mysql)</i>, <i>caches</i>, maupun <i>cluster storage systems (e.g.,
Ceph)</i> sebagai suatu <i>built-in services</i>. Komponen tersebut dapat dijalankan di atas Kubernetes, dan/atau
dapat diakses oleh aplikasi yang dijalankan di atas Kubernetes melalui sebuah mekanisme tidak mudah dipindahkan
misalnya saja <i>Open Service Broker</i>.</li><li>Tidak membatasi penyedia layanan <i>logging</i>, <i>monitoring</i>, maupun <i>alerting</i> yang digunakan.
Kubernetes menyediakan <i>proof of concept</i> dan mekanisme integrasi yang dapat digunakan
untuk mengumpulkan serta mengekspor metriks yang ada.</li><li>Tidak menyediakan atau mengharuskan penggunaan <i>configuration language/system (e.g.,
<a href=https://github.com/google/jsonnet>jsonnet</a>)</i>. Kubernetes menyediakan suatu API deklaratif
yang dapat digunakan oleh berbagai jenis spesifikasi deklaratif.</li><li>Tidak menyediakan atau mengadaptasi sebuah konfigurasi, <i>maintenance</i>, manajemen, atau
<i>self-healing</i> mesin dengan spesifikasi khusus.</li></ul><p>Sebagai tambahan, Kubernetes bukanlah sebuah <em>sitem orkestrasi biasa</em>. Bahkan pada kenyataannya,
Kubernetes menghilangkan kebutuhan untuk melakukan orkestrasi. Definisi teknis dari
<em>orkestrasi</em> merupakan eksekusi dari sebuah workflow yang sudah didefinisikan sebelumnya: pertama kerjakan A, kemudian B,
dan terakhir C. Sebaliknya, Kubernetes disusun oleh seperangkat
proses kontrol yang dapat idekomposisi yang selalu menjalankan <i>state</i> yang ada
saat ini hingga sesuai dengan <i>state</i> yang dinginkan.
Kita tidak perlu peduli proses apa saja yang perlu dilakukan untuk melakukan A hingga C.
Mekanisme kontrol yang tersentralisasi juga tidak dibutuhkan. Dengan demikian, sistem yang
dihasilkan lebih mudah digunakan lebih kokoh, serta lebih <i>extensible</i>.</p><h2 id=mengapa-kontainer>Mengapa kontainer?</h2><p>Mencari alasan kenapa kita harus menggunakan kontainer?</p><p><img src=/images/docs/why_containers.svg alt="Mengapa kontainer?"></p><p><em>Cara Lama</em> untuk melakukan mekanisme <i>deploy</i> suatu aplikasi
adalah dengan cara instalasi aplikasi tersebut pada sebuah mesin
dengan menggunakan <i>package manager</i> yang dimiliki oleh sistem operasi
mesin tersebut. Hal ini menciptakan suatu ketergantungan antara <i>executables</i>,
konfigurasi, serta ketergantungan lain yang dibutuhkan aplikasi dengan sistem operasi
yang digunakan oleh mesin. Untuk mengatasi hal ini, tentunya bisa saja kita melakukan
mekanisme <i>build</i> suatu <i>image</i> VM yang <i>immutable</i> untuk mendapatkan
mekanisme <i>rollouts</i> dan <i>rollback</i> yang dapat diprediksi.
Meskipun demikian, VM masih dianggap "berat" dan tidak tidak mudah dipindahkan.</p><p><em>Cara Baru</em> adalah dengan melakukan mekanisme <i>deploy</i> kontainer pada tingkatan
virtualisasi di level sistem operasi (OS) bukan pada tingkatan virtualisasi perangkat keras.
Kontainer ini berada dalam lingkungan yang terisolasi satu sama lain serta terisolasi dengan
mesin dimana kontainer ini berada. Kontainer ini memiliki <i>filesystems</i> masing-masing.
Selain itu, setiap kontainer tidak dapat "melihat" <i>process</i> yang sedang dijalankan di
kontainer lain. Selain itu <i>resource</i> komputasi yang digunakan oleh kontainer
ini juga dapat dibatasi. Kontainer juga dapat dengan lebih mudah di-<i>build</i> jika
dibandingkan dengan VM, karena kontainer tidak bergantung pada <i>filesystem</i>
yang dimiliki mesin, serta dengan mudah dapat didistribusikan.</p><p>Karena kontainer ukurannya kecil dan lebih cepat, sebuah aplikasi dapat dibangun di setiap
<i>image</i> kontainer. Mekanisme pemetaan satu-satu antara kontainer dan aplikasi
inilah yang membuka keuntungan secara meyeluruh yang dapat diberikan oleh kontainer.
Dengan menggunakan kontainer, <i>image</i> kontainer dapat dibuat diwaktu rilis aplikasi.
Pembuatan <i>image</i> ini memungkinkan aplikasi secara konsisten dirilis pada
<i>environment</i> <i>development</i> maupun <i>production</i>. Selain itu,
kontainer juga memiliki transparasi yang lebih tinggi dibandingkan dengan VM. Maksudnya,
infrastruktur punya tugas untuk mengatur lifecycle seluruh process yang ada di dalam kontainer. Ini bukanlah lagi tugas sebuah supervisor process yang tersembunyi di dalam kontainer.</p><p>Secara garis besar, penggunaan kontainer memiliki keuntungan sebagai berikut:</p><ul><li><strong>Mekanisme pembuatan aplikasi serta proses deployment yang lebih efektif</strong>:
Kontainer dapat meningkatkan kemudahan dan efisiensi jika dibandingkan dengan penggunaan VM.</li><li><strong>Continuous development, integration, and deployment</strong>:
Digunakan untuk melakukan proses <i>build</i> dan <i>deploy</i> yang sering dilakukan
serta kemudahan mekanisme <i>rollback</i> karena image yang ada sifatnya <i>immutable</i>.</li><li><strong>Pemisahan kepentingan antara Dev dan Ops</strong>:
Pembuatan <i>image</i> container dilakukan pada saat rilis dan bukan pada saat <i>deploy</i>
mengurangi ketergantungan aplikasi dan infrastruktur.</li><li><strong>Observabilitas</strong>
Tidak hanya informasi dan metriks pada level OS, tapi juga kesehatan aplikasi dan <i>signal</i> lain.</li><li><strong>Konsistensi <i>environment</i> pada masa pengembangan , <i>testing</i>, dan <i>production</i></strong>:
Memiliki perilaku yang sama baik ketika dijalankan di mesin lokal maupun penyedia layanan <i>cloud</i>.</li><li><strong>Portabilitas antar penyedia layanan <i>cloud</i> maupun distribusi OS</strong>:
Dapat dijalankan pada Ubuntu, RHEL, CoreOS, on-prem, Google Kubernetes Engine, dan dimanapun.</li><li><strong>Manajemen yang bersifat Aplikasi sentris</strong>:
Meningkatkan level abstraksi dari proses menjalankan OS pada perangkat keras virtual
ke proses menjalankan aplikasi pada sebuah OS dengan menggunakan <i>resource</i> logis.</li><li><strong><a href=https://martinfowler.com/articles/microservices.html>Mikroservis</a> yang renggang (loosely coupled), terdistribusi, elastis, dan terliberasi</strong>:
Aplikasi dapat dipecah menjadi komponen yang lebih kecil yang independen dan dapat
di-<i>deploy</i> dan diatur secara dinamis -- bukan sebuah sistem monolitik yang dijalankan pada
sebuah mesin yang hanya punya satu tujuan.</li><li><strong>Isolasi <i>resource</i></strong>:
Performa aplikasi yang bisa diprediksi.</li><li><strong>Utilisasi <i>resource</i></strong>:
Efisiensi yang tinggi</li></ul><h2 id=apakah-arti-kubernetes-k8s>Apakah arti Kubernetes? K8s?</h2><p>Nama <strong>Kubernetes</strong> berasal dari Bahasa Yunani, yang berarti <em>juru mudi</em> atau
<em>pilot</em>, dan merupakan asal kata <em>gubernur</em> dan
<a href="http://www.etymonline.com/index.php?term=cybernetics">cybernetic</a>. <em>K8s</em>
merupakan sebuah singkatan yang didapat dengan mengganti 8 huruf "ubernete" dengan
"8".</p><h2 id=selanjutnya>Selanjutnya</h2><ul><li>Siap untuk <a href=/docs/setup/>memulai</a>?</li><li>Untuk penjelasan lebih rinci, silahkan lihat <a href=/docs/home/>Dokumentasi Kubernetes</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-13b0f1dbe89228e3d76d2ac231e245f1>3.1.2 - Komponen-Komponen Kubernetes</h1><div class=lead>Sebuah klaster Kubernetes terdiri dari komponen yang merepresentasikan bidang kontrol dan sepasang mesin yaitu <em>nodes</em>.</div><p>Dokumen ini merupakan ikhtisar yang mencakup berbagai komponen
yang dibutuhkan agar klaster Kubernetes dapat berjalan secara fungsional.</p><h2 id=komponen-i-master-i>Komponen <i>Master</i></h2><p>Komponen <i>master</i> menyediakan <i>control plane</i> bagi klaster.
Komponen ini berperan dalam proses pengambilan secara global
pada klaster (contohnya, mekanisme <i>schedule</i>), serta berperan dalam proses
deteksi serta pemberian respons terhadap <i>events</i> yang berlangsung di dalam klaster
(contohnya, penjadwalan pod baru apabila jumlah replika yang ada pada
<i>replication controller</i> tidak terpenuhi).</p><p>Komponen master dapat dijalankan di mesin manapun yang ada di klaster. Meski begitu,
untuk memudahkan proses yang ada, <i>script</i> inisiasi awal yang dijalankan
biasanya memulai komponen master pada mesin yang sama, serta tidak menjalankan
kontainer bagi pengguna di mesin ini. Contoh konfigurasi <i>multi-master VM</i>
dapat dilihat di modul [Membangun Klaster HA] (/docs/admin/high-availability/).</p><h3 id=kube-apiserver>kube-apiserver</h3><p>Komponen <em>control plane</em> yang mengekspos API Kubernetes. Merupakan <em>front-end</em> dari <em>control plane</em> Kubernetes.</p><p>Komponen ini didesain agar dapat diskalakan secara horizontal. Lihat <a href=/docs/admin/high-availability/>Membangun Klaster HA</a>.</p><h3 id=etcd>etcd</h3><p>Penyimpanan <i>key value</i> konsisten yang digunakan sebagai penyimpanan data klaster Kubernetes.</p><p>Selalu perhatikan mekanisme untuk mem-<i>backup</i> data etcd pada klaster Kubernetes kamu. Untuk informasi lebih lanjut tentang etcd, lihat <a href=https://etcd.io/docs>dokumentasi etcd</a>.</p><h3 id=kube-scheduler>kube-scheduler</h3><p>Komponen <em>control plane</em> yang bertugas mengamati <a class=glossary-tooltip title='Unit Kubernetes yang paling sederhana dan kecil. Sebuah Pod merepresentasikan sebuah set kontainer yang dijalankan pada kluster kamu.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a> baru yang belum ditempatkan di node manapun dan kemudian memilihkan <a class=glossary-tooltip title='A node is a worker machine in Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/nodes/ target=_blank aria-label=Node>Node</a> di mana Pod baru tersebut akan dijalankan.</p><p>Faktor-faktor yang dipertimbangkan untuk keputusan penjadwalan termasuk: kebutuhan sumber daya secara individual dan kolektif, batasan perangkat keras/perangkat lunak/peraturan, spesifikasi afinitas dan nonafinitas, lokalisasi data, interferensi antar beban kerja dan tenggat waktu.</p><h3 id=kube-controller-manager>kube-controller-manager</h3><p>Komponen <em>control plane</em> yang menjalankan pengontrol.</p><p>Secara logis, setiap pengontrol adalah sebuah proses yang berbeda, tetapi untuk mengurangi kompleksitas, kesemuanya dikompilasi menjadi sebuah biner (<em>binary</em>) yang dijalankan sebagai satu proses.</p><p>Kontroler-kontroler ini meliputi:</p><ul><li>Kontroler <i>Node</i> : Bertanggung jawab untuk mengamati dan memberikan
respons apabila jumlah <i>node</i> berkurang.</li><li>Kontroler Replikasi : Bertanggung jawab untuk menjaga jumlah <i>pod</i> agar
jumlahnya sesuai dengan kebutuhan setiap objek kontroler replikasi yang ada di sistem.</li><li>Kontroler <i>Endpoints</i> : Menginisiasi objek <i>Endpoints</i>
(yang merupakan gabungan <i>Pods</i> dan <i>Services</i>).</li><li>Kontroler <i>Service Account & Token</i>: Membuat akun dan
akses token API standar untuk setiap <i>namespaces</i> yang dibuat.</li></ul><h3 id=cloud-controller-manager>cloud-controller-manager</h3><p><a href=/docs/tasks/administer-cluster/running-cloud-controller/>Cloud-controller-manager</a> merupakan kontroler yang berinteraksi dengan penyedia layanan <i>cloud</i>.
Kontroler ini merupakat fitur alfa yang diperkenalkan pada Kubernetes versi 1.6.</p><p><i>Cloud-controller-manager</i> hanya menjalankan iterasi kontroler <i>cloud-provider-specific</i> .
Kamu harus menonaktifkan iterasi kontroler ini pada <i>kube-controller-manager</i>.
Kamu dapat menonaktifka iterasi kontroler ini dengan mengubah nilai argumen <code>--cloud-provider</code> dengan <code>external</code>
ketika menginisiasi <i>kube-controller-manager</i>.</p><p>Adanya <i>cloud-controller-manager</i> memungkinkan kode yang dimiliki oleh penyedia layanan <i>cloud</i>
dan kode yang ada pada Kubernetes saling tidak bergantung selama masa <i>development</i>.
Pada versi sebelumnya, Kubernetes bergantung pada fungsionalitas spesifik yang disediakan oleh
penyedia layanan <i>cloud</i>. Di masa mendatang, kode yang secara spesifik dimiliki oleh
penyedia layanan <i>cloud</i> akan dipelihara oleh penyedia layanan <i>cloud</i> itu sendiri,
kode ini selanjutnya akan dihubungkan dengan <i>cloud-controller-manager</i> ketika Kubernetes dijalankan.</p><p>Kontroler berikut ini memiliki keterkaitan dengan penyedia layanan <i>cloud</i>:</p><ul><li>Kontroler Node : Melakukan pengecekan pada penyedia layanan <i>cloud</i> ketika menentukan apakah sebuah <i>node</i> telah dihapus pada <i>cloud</i> apabila <i>node</i> tersebut berhenti memberikan respons.</li><li>Kontroler Route : Melakukan pengaturan awal <i>route</i> yang ada pada penyedia layanan <i>cloud</i></li><li>Kontroler Service : Untuk membuat, memperbaharui, menghapus <i>load balancer</i> yang disediakan oleh penyedia layanan <i>cloud</i></li><li>Kontroler Volume : Untuk membuat, meng-attach, dan melakukan <i>mount volume</i> serta melakukan inetraksi dengan penyedia layanan <i>cloud</i> untuk melakukan orkestrasi <i>volume</i></li></ul><h2 id=komponen-i-node-i>Komponen <i>Node</i></h2><p>Komponen ini ada pada setiap <i>node</i>, fungsinya adalah melakukan pemeliharaan terhadap <i>pod</i> serta menyediakan <i>environment runtime</i> bagi Kubernetes.</p><h3 id=kubelet>kubelet</h3><p>Agen yang dijalankan pada setiap node di klaster yang bertugas untuk memastikan kontainer dijalankan di dalam Pod.</p><h3 id=kube-proxy>kube-proxy</h3><p><a href=/docs/admin/kube-proxy/>kube-proxy</a> membantu abstraksi service Kubernetes melakukan tugasnya. Hal ini terjadi dengan cara memelihara aturan-aturan jaringan (network rules) serta meneruskan koneksi yang ditujukan pada suatu host.</p><h3 id=i-container-runtime-i><i>Container Runtime</i></h3><p><i>Container runtime</i> adalah perangkat lunak yang bertanggung jawab dalam menjalankan kontainer.
Kubernetes mendukung beberapa <i>runtime</i>, diantaranya adalah: <a href=http://www.docker.com>Docker</a>, <a href=https://containerd.io>containerd</a>, <a href=https://cri-o.io/>cri-o</a>, <a href=https://github.com/kubernetes-incubator/rktlet>rktlet</a> dan semua implementasi <a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-node/container-runtime-interface.md>Kubernetes CRI (Container Runtime Interface)</a>.</p><h2 id=i-addons-i><i>Addons</i></h2><p><i>Addons</i> merupakan pod dan service yang mengimplementasikan fitur-fitur yang diperlukan klaster.</p><p>Beberapa <i>addons</i> akan dijelaskan selanjutnya.</p><h3 id=dns>DNS</h3><p>Meskipun tidak semua <i>addons</i> dibutuhkan, semua klaster Kubernetes hendaknya
memiliki DNS klaster. Komponen ini penting karena banyak dibutuhkan oleh komponen
lainnya.</p><p><a href=/id/docs/concepts/cluster-administration/addons/>Klaster DNS</a> adalah server DNS, selain beberapa server DNS lain yang sudah ada di
<i>environment</i> kamu, yang berfungsi sebagai catatan DNS bagi Kubernetes <i>services</i></p><p>Kontainer yang dimulai oleh kubernetes secara otomatis akan memasukkan server DNS ini
ke dalam mekanisme pencarian DNS yang dimilikinya.</p><h3 id=i-web-ui-i-dasbor><i>Web UI</i> (Dasbor)</h3><p><a href=/id/docs/tasks/access-application-cluster/web-ui-dashboard/>Dasbor</a> adalah antar muka berbasis web multifungsi yang ada pada klaster Kubernetes.
Dasbor ini memungkinkan user melakukan manajemen dan <i>troubleshooting</i> klaster maupun
aplikasi yang ada pada klaster itu sendiri.</p><h3 id=i-container-resource-monitoring-i><i>Container Resource Monitoring</i></h3><p><a href=/docs/tasks/debug-application-cluster/resource-usage-monitoring/>Container Resource Monitoring</a> mencatat metrik <i>time-series</i> yang diperoleh
dari kontainer ke dalam basis data serta menyediakan antar muka yang dapat digunakan
untuk melakukan pencarian data yang dibutuhkan.</p><h3 id=i-cluster-level-logging-i><i>Cluster-level Logging</i></h3><p><a href=/id/docs/concepts/cluster-administration/logging/>Cluster-level logging</a> bertanggung jawab mencatat <i>log</i> kontainer pada
penyimpanan <i>log</i> terpusat dengan antar muka yang dapat digunakan untuk melakukan
pencarian.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-0c745f42e623d2b70a53bc0e6db73d95>3.1.3 - API Kubernetes</h1><div class=lead>API Kubernetes membuatmu dapat melakukan <em>query</em> dan memanipulasi keadaan objek dalam Kubernetes. Inti dari bidang kontrol Kubernetes adalah <em>server</em> API dan HTTP API yang diekspos. Pengguna, berbagai bagian klastermu, dan komponen eksternal semuanya berkomunikasi satu sama lain melalui server API.</div><p>Secara keseluruhan standar yang digunakan untuk API dijelaskan di dalam <a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md>dokumentasi API standar</a>.</p><p><i>Endpoints API</i>, <i>resource types</i> serta contoh penggunaan dijelaskan di dalam <a href=/docs/reference>API Reference</a>.</p><p>Akses <i>remote</i> penggunaan API dijelaskan di dalam <a href=/docs/reference/access-authn-authz/controlling-access/>dokumentasi akses API</a>.</p><p>API Kubernetes juga berperan sebagai skema konfigurasi yang deklaratif di dalam sistem.. Sementara itu, <a href=/docs/reference/kubectl/overview/>kubectl</a> merupakan <i>command-line</i> yang dapat digunakan untuk membuat, menmperbaharui, menghapus, dan mendapatkan obyek API.</p><p>Kubernetes menyimpan bentuk terserialisasi dari obyek API yang dimilikinya di dalam <a href=https://coreos.com/docs/distributed-configuration/getting-started-with-etcd/>etcd</a>.</p><p>Kubernetes sendiri dibagi menjadi beberapa komponen yang saling dapat saling interaksi melalui API.</p><h2 id=perubahan-api>Perubahan API</h2><p>Berdasarkan pengalaman kami, semua sistem yang berhasil memerlukan kebutuhan
untuk terus tumbuh dan berkembang seiring dengan bertambahnya kebutuhan
yang ada. Dengan demikian, kami berekspektasi bahwa API akan selalu berubah seiring dengan bertambahnya kebutuhan yang ada.
Meski begitu, perubahan yang ada akan selalu kompatibel dengan implementasi sebelumnya, untuk jangka waktu tertentu.
Secara umum, penambahan pada sebuah resource API atau field resource bisa sering terjadi.. Penghapusan <i>resource API</i> atau suatu <i>field</i>, di sisi lain,
diharapkan untuk dapat memenuhi <a href=/docs/reference/using-api/deprecation-policy/>kaidah deprecation API</a>.</p><p>Hal-hal apa saja yang perlu diperhatikan untuk menjamin kompatibilitas API
secara rinci dibahas di dalam <a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api_changes.md>dokumentasi perubahan API</a>.</p><h2 id=swagger-and-openapi-definition>Swagger and OpenAPI Definition</h2><p>Detail mengenai API didokumentasikan dengan menggunakan <a href=https://www.openapis.org/>OpenAPI</a>.</p><p>Semenjak Kubernetes versi 1.10, Kubernetes menghadirkan spesifikasi <i>OpenAPI</i> melalui <i>endpoint</i> <code>/openapi/v2</code>.
Format <i>request</i> dapat diterapkan dengan cara menambahkan <i>header HTTP</i>:</p><table><thead><tr><th>Header</th><th>Opsi</th></tr></thead><tbody><tr><td>Accept</td><td><code>application/json</code>, <code>application/com.github.proto-openapi.spec.v2@v1.0+protobuf</code> (<i>content-type</i> standar yang digunakan adalah <code>application/json</code> untuk <code>*/*</code>)</td></tr><tr><td>Accept-Encoding</td><td><code>gzip</code></td></tr></tbody></table><p>Sebelum versi 1.14, terdapat 4 buah <i>endpoint</i> yang menyediakan spesifikasi <i>OpenAPI</i>
dalam format berbeda yang dapat digunakan (<code>/swagger.json</code>, <code>/swagger-2.0.0.json</code>, <code>/swagger-2.0.0.pb-v1</code>, <code>/swagger-2.0.0.pb-v1.gz</code>).
<i>Endpoint</i> ini bersifat <i>deprecated</i> dan akan dihapus pada Kubernetes versi 1.14.</p><p><strong>Cara mendapatkan spesifikasi <i>OpenAPI</i></strong>:</p><table><thead><tr><th>Sebelum 1.10</th><th>Mulai Kubernetes 1.10</th></tr></thead><tbody><tr><td>GET /swagger.json</td><td>GET /openapi/v2 <strong>Accept</strong>: application/json</td></tr><tr><td>GET /swagger-2.0.0.pb-v1</td><td>GET /openapi/v2 <strong>Accept</strong>: <a href=mailto:application/com.github.proto-openapi.spec.v2@v1.0>application/com.github.proto-openapi.spec.v2@v1.0</a>+protobuf</td></tr><tr><td>GET /swagger-2.0.0.pb-v1.gz</td><td>GET /openapi/v2 <strong>Accept</strong>: <a href=mailto:application/com.github.proto-openapi.spec.v2@v1.0>application/com.github.proto-openapi.spec.v2@v1.0</a>+protobuf <strong>Accept-Encoding</strong>: gzip</td></tr></tbody></table><p>Kubernetes juga menyediakan alternatif mekanisme serialisasi lain,
yaitu dengan menggunakan <i>Protobuf</i>, yang secara umum digunakan untuk mekanisme komunikasi
intra-klaster, hal ini didokumentasikan di dalam <a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/protobuf.md>proposal desain</a>
serta berkas IDL sebagai bentuk spesifikasi skema berada dalam <i>package</i> Go</p><p>Sebelum Kubernetes versi 1.14, <i>apiserver</i> Kubernetes juga mengekspos API
yang dapat digunakan untuk mendapatkan spesifikasi <a href=http://swagger.io/>Swagger v1.2</a> pada <i>endpoint</i> <code>/swaggerapi</code>.
<i>Endpoint</i> ini akan sudah bersifat <i>deprecated</i> dan akan dihapus pada
Kubernetes versi 1.14.</p><h2 id=pemberian-versi-pada-api>Pemberian Versi pada API</h2><p>Untuk memudahkan restrukturisasi field dan resource yang ada,
Kubernetes menyediakan beberapa versi API yang berada pada <i>path</i> yang berbeda,
misalnya <code>/api/v1</code> atau <code>/apis/extensions/v1beta1</code>.</p><p>Kita dapat memilih versi yang akan digunakan pada tingkatan API
dan bukan pada tingkatan <i>field</i> atau <i>resource</i> untuk memastikan
API yang digunakan memperlihatkan gambaran yang jelas serta konsisten
mengenai <i>resoure</i> dan sifat sistem yang ada.</p><p>Perhatikan bahwa pemberian versi pada API dan pemberian versi pada API dan perangkat lunak memiliki keterkaitan secara tak langsung.
Proposal <a href=https://git.k8s.io/community/contributors/design-proposals/release/versioning.md>API and release
versioning</a> memberikan deskripsi keterkaitan antara
pemberian versi pada API dan pemberian versi pada perangkat lunak.</p><p>API dengan versi yang berbeda menunjukan tingkatan kestabilan dan ketersediaan yang diberikan pada versi tersebut.
Kriteria untuk setiap tingkatan dideskripsikan secara lebih detail di dalam
<a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api_changes.md#alpha-beta-and-stable-versions>dokumentasi perubahan API</a>. They are summarized here:</p><ul><li>Tingkatan <i>Alpha</i>:<ul><li>Nama dari versi ini mengandung string <code>alpha</code> (misalnya, <code>v1alpha1</code>).</li><li>Bisa jadi terdapat <i>bug</i>. Secara <i>default</i> fitur ini tidak diekspos.</li><li>Ketersediaan untuk fitur yang ada bisa saja dihilangkan pada suatu waktu tanpa pemberitahuan sebelumnya.</li><li>API yang ada mungkin saja berubah tanpa memperhatikan kompatibilitas dengan versi perangkat lunak sebelumnya.</li><li>Hanya direkomendasikan untuk klaster yang digunakan untuk tujuan <i>testing</i>.</li></ul></li><li>Tingkatan <i>Beta</i>:<ul><li>Nama dari versi ini mengandung string <code>beta</code> (misalnya <code>v2beta3</code>).</li><li>Kode yang ada sudah melalui mekanisme <i>testing</i> yang cukup baik. Menggunakan fitur ini dianggap cukup aman. Fitur ini diekspos secara <i>default</i>.</li><li>Ketersediaan untuk fitur secara menyeluruh tidak akan dihapus, meskipun begitu detail untuk suatu fitur bisa saja berubah.</li><li>Skema dan/atau semantik dari suatu obyek mungkin saja berubah tanpa memerhatikan kompatibilitas pada rilis <i>beta</i> selanjutnya.
Jika hal ini terjadi, kami akan menyediakan suatu instruksi untuk melakukan migrasi di versi rilis selanjutnya. hal ini bisa saja terdiri dari penghapusan, pengubahan, ataupun pembuatan
obyek API. Proses pengubahan mungkin saja membutuhkan pemikiran yang matang. Dampak proses ini bisa saja menyebabkan <i>downtime</i> aplikasi yang bergantung pada fitur ini.</li><li>Disarankan hanya untuk digunakan untuk penggunaan yang untuk penggunaan yang tidak berdampak langsung pada bisnis kamu.</li><li><strong>Kami mohon untuk mencoba versi <i>beta</i> yang kami sediakan dan berikan masukan terhadap fitur yang kamu pakai! Apabila fitur tersebut sudah tidak lagi berada di dalam tingkatan <i>beta</i> perubahan yang kami buat terhadap fitur tersebut bisa jadi tidak lagi dapat digunakan</strong></li></ul></li><li>Tingkatan stabil:<ul><li>Nama dari versi ini mengandung string <code>vX</code> dimana <code>X</code> merupakan bilangan bulat.</li><li>Fitur yang ada pada tingkatan ini akan selalu muncul di rilis berikutnya.</li></ul></li></ul><h2 id=i-api-groups-i><i>API groups</i></h2><p>Untuk memudahkan proses ekstensi suatu API Kubernetes, kami mengimplementasikan <a href=https://git.k8s.io/community/contributors/design-proposals/api-machinery/api-group.md><em>API groups</em></a>.
<i>API group</i> ini dispesifikasikan di dalam <i>path</i> <i>REST</i> serta di dalam <i>field</i> <code>apiVersion</code> dari sebuah obyek yang sudah diserialisasi.</p><p>Saat ini, terdapat beberapa <i>API groups</i> yang digunakan:</p><ol><li><p>Kelompok <em>core</em>, seringkali disebut sebagai <em>legacy group</em>, berada pada <i>path</i> <i>REST</i> <code>/api/v1</code> serta menggunakan <code>apiVersion: v1</code>.</p></li><li><p><i>Named groups</i> berada pada <i>path</i> <i>REST</i> <code>/apis/$GROUP_NAME/$VERSION</code>, serta menggunakan <code>apiVersion: $GROUP_NAME/$VERSION</code>
(misalnya <code>apiVersion: batch/v1</code>). Daftar menyeluruh mengenai apa saja <i>API groups</i> dapat dilihat di <a href=/docs/reference/>Kubernetes API reference</a>.</p></li></ol><p>Ekstensi API dengan custom resources dapat dilakukan melalui dua buah path:</p><ol><li><a href>CustomResourceDefinition</a>
digunakan jika memerlukan seluruh set semantik Kubernetes API, pengguna boleh implementasi apiserver sendiri dengan menggunakan aggregator.</li><li>Pengguna yang membutuhkan seperangkat semantik API Kubernetes API dapat mengimplementasikan <i>apiserver</i> mereka sendiri.
dengan menggunakan <a href>aggregator</a>
untuk membuat integrasi dengan klien menjadi lebih mudah.</li></ol><h2 id=mengaktifkan-i-api-groups-i>Mengaktifkan <i>API groups</i></h2><p>Beberapa <i>resources</i> dan <i>API groups</i> sudah diaktifkan secara <i>default</i>.
<i>Resource</i> dan <i>API groups</i> ini dapat diaktifkan dan dinonaktifkan dengan mengatur penanda <code>--runtime-config</code>
pada <i>apiserver</i>. <code>--runtime-config</code> menerima nilai yang dipisahkan oleh koma. Sebagai contoh: untuk menonaktifkan batch/v1, tetapkan
<code>--runtime-config=batch/v1=false</code>, untuk mengaktifkan batch/v2alpha1, tetapkan <code>--runtime-config=batch/v2alpha1</code>.
Penanda menerima nilai yang dipisahkan oleh pasangan <code>key=value</code> yang mendeskripsikan konfigurasi <i>runtime</i> pada <i>apiserver</i>.</p><p>PENTING: Melakukan proses mengaktifkan atau menonaktifkan <i>groups</i> atau <i>resources</i>
membutuhkan mekanisme <i>restart</i> <i>apiserver</i> dan <i>controller-manager</i>
agar <i>apiserver</i> dapat menerima perubahan <code>--runtime-config</code>.</p><h2 id=mengaktifkan-i-resources-i-di-dalam-i-groups-i>Mengaktifkan <i>resources</i> di dalam <i>groups</i></h2><p><i>DaemonSets</i>, <i>Deployments</i>, <i>HorizontalPodAutoscalers</i>,
<i>Ingresses</i>, <i>Jobs</i>, dan <i>ReplicaSets</i> diaktifkan secara <i>default</i>.
Ekstensi lain dapat diaktifkan penanda <code>--runtime-config</code> pada <i>apiserver</i>. Penanda <code>--runtime-config</code> menerima nilai yang dipisahkan oleh koma.
Sebagai contoh untuk menonaktifkan <i>deployments</i> dan <i>ingress</i>, tetapkan.
<code>--runtime-config=extensions/v1beta1/deployments=false,extensions/v1beta1/ingresses=false</code></p></div><div class=td-content style=page-break-before:always><h1 id=pg-110f33530cf761140cb1dab536baef04>3.1.4 - Menggunakan Objek-Objek Kubernetes</h1><div class=lead>Objek-objek Kubernetes adalah entitas yang tetap dalam sistem Kubernetes. Kubernetes menggunakan entitas tersebut untuk merepresentasikan keadaan dari klastermu. Pelajari tentang objek model Kubernetes dan bagaimana menggunakan objek tersebut.</div></div><div class=td-content><h1 id=pg-9f5adfa77f48c50d5cc81155a3cecb98>3.1.4.1 - Memahami Konsep Objek-Objek yang ada pada Kubernetes</h1><p>Laman ini menjelaskan bagaimana objek-objek Kubernetes direpresentasikan di dalam API Kubernetes,
dan bagaimana kamu dapat merepresentasikannya di dalam format <code>.yaml</code>.</p><h2 id=memahami-konsep-objek-objek-yang-ada-pada-kubernetes>Memahami Konsep Objek-Objek yang Ada pada Kubernetes</h2><p>Objek-objek Kubernetes adalah entitas persisten di dalam sistem Kubernetes.
Kubernetes menggunakan entitas ini untuk merepresentasikan <em>state</em> yang ada pada
klaster kamu. Secara spesifik, hal itu dapat dideskripsikan sebagai:</p><ul><li>Aplikasi-aplikasi kontainer apa sajakah yang sedang dijalankan (serta pada <em>node</em> apa aplikasi tersebut dijalankan)</li><li><em>Resource</em> yang tersedia untuk aplikasi tersebut</li><li><em>Policy</em> yang mengatur bagaimana aplikasi tersebut dijalankan, misalnya <em>restart</em>, <em>upgrade</em>, dan <em>fault-tolerance</em>.</li></ul><p>Objek Kubernetes merupakan sebuah <em>"record of intent"</em>--yang mana sekali kamu membuat suatu objek,
sistem Kubernetes akan bekerja secara konsisten untuk menjamin
bahwa objek tersebut akan selalu ada. Dengan membuat sebuah objek, secara tak langsung kamu
memberikan informasi pada sistem Kubernetes mengenai perilaku apakah yang kamu inginkan pada <em>workload</em> klaster yang kamu miliki;
dengan kata lain ini merupakan definisi <em>state</em> klaster yang kamu inginkan.</p><p>Untuk menggunakan objek-objek Kubernetes--baik membuat, mengubah, atau menghapus objek-objek tersebut--kamu
harus menggunakan <a href=/id/docs/concepts/overview/kubernetes-api/>API Kubernetes</a>.
Ketika kamu menggunakan perintah <code>kubectl</code>, perintah ini akan melakukan <em>API call</em> untuk perintah
yang kamu berikan. Kamu juga dapat menggunakan API Kubernetes secara langsung pada program yang kamu miliki
menggunakan salah satu <a href=/docs/reference/using-api/client-libraries/><em>library</em> klien</a> yang disediakan.</p><h3 id=spec-dan-status-objek><em>Spec</em> dan Status Objek</h3><p>Setiap objek Kubernetes memiliki <em>field</em> berantai yang mengatur konfigurasi sebuah objek:
<em>spec</em> dan status. <em>Spec</em>, merupakan <em>field</em> yang harus kamu sediakan, <em>field</em> ini mendeskripsikan
<em>state</em> yang kamu inginkan untuk objek tersebut--karakteristik dari objek yang kamu miliki.
Status mendeskripsikan <em>state</em> yang sebenarnya dari sebuah objek, dan hal ini disediakan dan selalu diubah oleh
sistem Kubernetes. Setiap saat, <em>Control Plane</em> Kubernetes selalu memantau apakah <em>state</em> aktual sudah sesuai dengan
<em>state</em> yang diinginkan.</p><p>Sebagai contoh, <em>Deployment</em> merupakan sebuah objek yang merepresentasikan sebuah aplikasi yang dijalankan di klaster kamu.
Ketika kamu membuat sebuah <em>Deployment</em>, kamu bisa saja memberikan <em>spec</em> bagi <em>Deployment</em> untuk memberikan spesifikasi
berapa banyak <em>replica</em> yang kamu inginkan. Sistem Kubernetes kemudian akan membaca konfigurasi yang kamu berikan
dan mengaktifkan tiga buah instans untuk aplikasi yang kamu inginkan--mengubah status yang ada saat ini agar sesuai dengan apa yang kamu inginkan.
Jika terjadi kegagalan dalam instans yang dibuat, sistem Kubernetes akan memberikan respons bahwa terdapat perbedaan antara <em>spec</em> dan status serta
melakukan penyesuaian dengan cara memberikan instans pengganti.</p><p>Informasi lebih lanjut mengenai <em>spec</em> objek, status, dan <em>metadata</em> dapat kamu baca di <a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md>Konvensi API Kubernetes</a>.</p><h3 id=mendeskripsikan-objek-kubernetes>Mendeskripsikan Objek Kubernetes</h3><p>Ketika kamu membuat sebuah objek di Kubernetes, kamu harus menyediakan <em>spec</em> objek yang
mendeskripsikan <em>state</em> yang diinginkan, serta beberapa informasi tentang objek tersebut (seperti nama).
Ketika kamu menggunakan API Kubernetes untuk membuat objek tersebut (baik secara langsung atau menggunakan perintah
<code>kubectl</code>), <em>request</em> API yang dibuat harus mencakup informasi seperti <em>request body</em> dalam format JSON.
Apabila kamu memberikan <strong>informasi dalam bentuk <code>.yaml</code> ketika menggunakan perintah <code>kubectl</code></strong> maka <code>kubectl</code>
akan mengubah informasi yang kamu berikan ke dalam format JSON ketika melakukan <em>request</em> API.</p><p>Berikut merupakan contoh <em>file</em> <code>.yaml</code> yang menunjukkan <em>field</em> dan <em>spec</em> objek untuk <em>Deployment</em>:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/application/deployment.yaml download=application/deployment.yaml><code>application/deployment.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("application-deployment-yaml")' title="Copy application/deployment.yaml to clipboard"></img></div><div class=includecode id=application-deployment-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb> </span><span style=color:#080;font-style:italic># for versions before 1.9.0 use apps/v1beta2</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># tells deployment to run 2 pods matching the template</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.7.9<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Salah satu cara untuk membuat <em>Deployment</em> menggunakan <em>file</em> <code>.yaml</code>
seperti yang dijabarkan di atas adalah dengan menggunakan perintah
<a href=/docs/reference/generated/kubectl/kubectl-commands#apply><code>kubectl apply</code></a>
pada <em>command-line interface</em> <code>kubectl</code> kamu menerapkan <em>file</em> <code>.yaml</code> sebagai sebuah argumen.
Berikut merupakan contoh penggunaannya:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/application/deployment.yaml --record
</span></span></code></pre></div><p>Keluaran yang digunakan kurang lebih akan ditampilkan sebagai berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>deployment.apps/nginx-deployment created
</span></span></code></pre></div><h3 id=field-field-yang-dibutuhkan><em>Field-Field</em> yang dibutuhkan</h3><p>Pada <em>file</em> <code>.yaml</code> untuk objek Kubernetes yang ingin kamu buat, kamu perlu
menyediakan <em>value</em> untuk <em>field-field</em> berikut:</p><ul><li><em>apiVersion</em> - Version API Kubernetes mana yang kamu gunakan untuk membuat objek tersebut</li><li><em>kind</em> - Objek apakah yang ingin kamu buat</li><li><em>metadata</em> - Data yang dapat kamu gunakan untuk melakukan identifikasi objek termasuk <em>name</em> dalam betuk string, <em>UID</em>, dan <em>namespace</em> yang bersifat opsional</li></ul><p>Kamu juga harus menyediakan <em>field</em> <em>spec</em>. Format spesifik dari <em>spec</em> sebuah objek akan berbeda bergantung
pada objek apakah yang ingin kamu buat, serta mengandung <em>field</em> berantai yang spesifik bagi objek tersebut.
<a href=/docs/reference/generated/kubernetes-api/v1.25/>Referensi API Kubernetes</a> memberikan penjelasan
lebih lanjut mengenai format <em>spec</em> untuk semua objek Kubernetes yang dapat kamu buat. Misalnya saja format <em>spec</em>
untuk <em>Pod</em> dapat kamu temukan <a href=/docs/reference/generated/kubernetes-api/v1.25/#podspec-v1-core>di sini</a>,
dan format <em>spec</em> untuk <em>Deployment</em> dapat ditemukan
<a href=/docs/reference/generated/kubernetes-api/v1.25/#deploymentspec-v1-apps>di sini</a>.</p><h2 id=selanjutnya>Selanjutnya</h2><ul><li>Pelajari lebih lanjut mengenai dasar-dasar penting bagi objek Kubernetes, seperti <a href=/id/docs/concepts/workloads/pods/pod-overview/>Pod</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-6751db8ff5409476de8225d17d6c42dd>3.1.4.2 - Pengaturan Objek Kubernetes</h1><p>Perangkat <code>kubectl</code> mendukung beberapa cara untuk membuat dan mengatur objek-objek Kubernetes.
Laman ini menggambarkan berbagai macam metodenya. Baca <a href=https://kubectl.docs.kubernetes.io>Kubectl gitbook</a>
untuk penjelasan pengaturan objek dengan Kubectl secara detail.</p><h2 id=metode-pengaturan>Metode pengaturan</h2><div class="alert alert-danger warning callout" role=alert><strong>Peringatan:</strong> Sebuah objek Kubernetes hanya boleh diatur dengan menggunakan satu metode saja. Mengkombinasikan
beberapa metode untuk objek yang sama dapat menghasilkan perilaku yang tidak diinginkan.</div><table><thead><tr><th>Metode pengaturan</th><th>Dijalankan pada</th><th><em>Environment</em> yang disarankan</th><th>Jumlah penulis yang didukung</th><th>Tingkat kesulitan mempelajari</th></tr></thead><tbody><tr><td>Perintah imperatif</td><td>Objek <em>live</em></td><td>Proyek pengembangan (<em>dev</em>)</td><td>1+</td><td>Terendah</td></tr><tr><td>Konfigurasi objek imperatif</td><td>Berkas individu</td><td>Proyek produksi (<em>prod</em>)</td><td>1</td><td>Sedang</td></tr><tr><td>Konfigurasi objek deklaratif</td><td>Direktori berkas</td><td>Proyek produksi (<em>prod</em>)</td><td>1+</td><td>Tertinggi</td></tr></tbody></table><h2 id=perintah-imperatif>Perintah imperatif</h2><p>Ketika menggunakan perintah-perintah imperatif, seorang pengguna menjalankan operasi secara langsung
pada objek-objek <em>live</em> dalam sebuah klaster. Pengguna menjalankan operasi tersebut melalui
argumen atau <em>flag</em> pada perintah <code>kubectl</code>.</p><p>Ini merupakan cara yang paling mudah untuk memulai atau menjalankan tugas "sekali jalan" pada sebuah klaster.
Karena metode ini dijalankan secara langsung pada objek <em>live</em>, tidak ada <em>history</em> yang menjelaskan konfigurasi-konfigurasi terkait sebelumnya.</p><h3 id=contoh>Contoh</h3><p>Menjalankan sebuah instans Container nginx dengan membuat suatu objek Deployment:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl run nginx --image nginx
</span></span></code></pre></div><p>Melakukan hal yang sama menggunakan sintaks yang berbeda:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl create deployment nginx --image nginx
</span></span></code></pre></div><h3 id=kelebihan-dan-kekurangan>Kelebihan dan kekurangan</h3><p>Beberapa kelebihan metode ini dibandingkan metode konfigurasi objek:</p><ul><li>Sederhana, mudah dipelajari dan diingat.</li><li>Hanya memerlukan satu langkah untuk membuat perubahan pada klaster.</li></ul><p>Beberapa kekurangan metode ini dibandingkan metode konfigurasi objek:</p><ul><li>Tidak terintegrasi dengan proses peninjauan (<em>review</em>) perubahan.</li><li>Tidak menyediakan jejak audit yang terkait dengan perubahan.</li><li>Tidak menyediakan sumber <em>record</em> kecuali dari apa yang <em>live</em> terlihat.</li><li>Tidak menyediakan templat untuk membuat objek-objek baru.</li></ul><h2 id=konfigurasi-objek-imperatif>Konfigurasi objek imperatif</h2><p>Pada konfigurasi objek imperatif, perintah kubectl menetapkan jenis operasi
(<em>create</em>, <em>replace</em>, etc.), <em>flag-flag</em> pilihan dan minimal satu nama berkas.
Berkas ini harus berisi definisi lengkap dari objek tersebut
dalam bentuk YAML atau JSON.</p><p>Lihat <a href=/docs/reference/generated/kubernetes-api/v1.25/>referensi API</a>
untuk info lebih detail mengenai definisi objek.</p><div class="alert alert-danger warning callout" role=alert><strong>Peringatan:</strong> Perintah imperatif <code>replace</code> menggantikan spek yang sudah ada dengan spek yang baru,
membuang semua perubahan terhadap objek tersebut yang tidak didefinisikan pada berkas konfigurasi.
Metode ini sebaiknya tidak dilakukan pada tipe sumber daya yang spek-nya diperbarui
secara independen di luar berkas konfigurasi. Service dengan tipe <code>LoadBalancer</code>, sebagai contoh,
memiliki <em>field</em> <code>externalIPs</code> yang diperbarui secara independen di luar konfigurasi, dilakukan
oleh klaster.</div><h3 id=contoh-1>Contoh</h3><p>Membuat objek yang didefinisikan pada sebuah berkas konfigurasi:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl create -f nginx.yaml
</span></span></code></pre></div><p>Menghapus objek-objek yang didefinisikan pada dua berkas konfigurasi:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl delete -f nginx.yaml -f redis.yaml
</span></span></code></pre></div><p>Memperbarui objek yang didefinisikan pada sebuah berkas konfigurasi dengan
menimpa konfigurasi <em>live</em>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl replace -f nginx.yaml
</span></span></code></pre></div><h3 id=kelebihan-dan-kekurangan-1>Kelebihan dan kekurangan</h3><p>Beberapa kelebihan dibandingkan metode perintah imperatif:</p><ul><li>Konfigurasi objek dapat disimpan pada suatu sistem kontrol kode seperti Git.</li><li>Konfigurasi objek dapat diintegrasikan dengan proses-proses, misalnya peninjauan (<em>review</em>) perubahan sebelum <em>push</em> dan jejak audit.</li><li>Konfigurasi objek dapat menyediakan templat untuk membuat objek-objek baru.</li></ul><p>Beberapa kekurangan dibandingkan metode perintah imperatif:</p><ul><li>Konfigurasi objek memerlukan pemahaman yang mendasar soal skema objek.</li><li>Konfigurasi objek memerlukan langkah tambahan untuk menulis berkas YAML.</li></ul><p>Beberapa kelebihan dibandingkan metode konfigurasi objek deklaratif:</p><ul><li>Konfigurasi objek imperatif memiliki perilaku yang lebih sederhana dan mudah dimengerti.</li><li>Sejak Kubernetes versi 1.5, konfigurasi objek imperatif sudah lebih stabil.</li></ul><p>Beberapa kekurangan dibandingkan metode konfigurasi objek deklaratif:</p><ul><li>Konfigurasi objek imperatif bekerja dengan baik untuk berkas-berkas, namun tidak untuk direktori.</li><li>Pembaruan untuk objek-objek <em>live</em> harus diterapkan pada berkas-berkas konfigurasi, jika tidak, hasil perubahan akan hilang pada penggantian berikutnya.</li></ul><h2 id=konfigurasi-objek-deklaratif>Konfigurasi objek deklaratif</h2><p>Ketika menggunakan konfigurasi objek deklaratif, seorang pengguna beroperasi pada berkas-berkas
konfigurasi objek yang disimpan secara lokal, namun pengguna tidak mendefinisikan operasi
yang akan dilakukan pada berkas-berkas tersebut. Operasi <em>create</em>, <em>update</em>, dan <em>delete</em>
akan dideteksi secara otomatis per-objek dengan <code>kubectl</code>. Hal ini memungkinkan penerapan
melalui direktori, dimana operasi yang berbeda mungkin diperlukan untuk objek-objek yang berbeda.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Konfigurasi objek deklaratif mempertahankan perubahan yang dibuat oleh penulis lainnya, bahkan
jika perubahan tidak digabungkan (<em>merge</em>) kembali pada berkas konfigurasi objek. Hal ini
bisa terjadi dengan menggunakan operasi API <code>patch</code> supaya hanya perbedaannya saja yang ditulis,
daripada menggunakan operasi API <code>replace</code> untuk menggantikan seluruh konfigurasi objek.</div><h3 id=contoh-2>Contoh</h3><p>Melakukan pemrosesan pada semua berkas konfigurasi objek di direktori <code>configs</code>, dan melakukan
<em>create</em> atau <em>patch</em> untuk objek-objek <em>live</em>. Kamu dapat terlebih dahulu melakukan <code>diff</code> untuk
melihat perubahan-perubahan apa saja yang akan dilakukan, dan kemudian terapkan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl diff -f configs/
</span></span><span style=display:flex><span>kubectl apply -f configs/
</span></span></code></pre></div><p>Melakukan pemrosesan direktori secara rekursif:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl diff -R -f configs/
</span></span><span style=display:flex><span>kubectl apply -R -f configs/
</span></span></code></pre></div><h3 id=kelebihan-dan-kekurangan-2>Kelebihan dan kekurangan</h3><p>Beberapa kelebihan dibandingkan konfigurasi objek imperatif:</p><ul><li>Perubahan-perubahan yang dilakukan secara langsung pada objek-objek <em>live</em> akan dipertahankan, bahkan jika perubahan tersebut tidak digabungkan kembali pada berkas-berkas konfigurasi.</li><li>Konfigurasi objek deklaratif memiliki dukungan yang lebih baik dalam mengoperasikan direktori dan secara otomatis mendeteksi tipe operasi (<em>create</em>, <em>patch</em>, <em>delete</em>) per-objek.</li></ul><p>Beberapa kekurangan dibandingkan konfigurasi objek imperatif:</p><ul><li>Konfigurasi objek deklaratif lebih sulit untuk di-<em>debug</em> dan hasilnya lebih sulit dimengerti untuk perilaku yang tidak diinginkan.</li><li>Pembaruan sebagian menggunakan <em>diff</em> menghasilkan operasi <em>merge</em> dan <em>patch</em> yang rumit.</li></ul><h2 id=selanjutnya>Selanjutnya</h2><ul><li><a href=/docs/tasks/manage-kubernetes-objects/imperative-command/>Mengatur Objek Kubernetes menggunakan Perintah Imperatif</a></li><li><a href=/docs/tasks/manage-kubernetes-objects/imperative-config/>Mengatur Objek Kubernetes menggunakan Konfigurasi Objek (Imperatif)</a></li><li><a href=/docs/tasks/manage-kubernetes-objects/declarative-config/>Mengatur Objek Kubernetes menggunakan Konfigurasi Objek (Deklaratif)</a></li><li><a href=/docs/tasks/manage-kubernetes-objects/kustomization/>Mengatur Objek Kubernetes menggunakan Kustomize (Deklaratif)</a></li><li><a href=/docs/reference/generated/kubectl/kubectl-commands/>Referensi Perintah Kubectl</a></li><li><a href=https://kubectl.docs.kubernetes.io>Kubectl Gitbook</a></li><li><a href=/docs/reference/generated/kubernetes-api/v1.25/>Referensi API Kubernetes</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-f37749a83c2916b63279ea60f3cfe53e>3.1.4.3 - Nama</h1><p>Seluruh objek di dalam REST API Kubernetes secara jelas ditandai dengan nama dan UID.</p><p>Apabila pengguna ingin memberikan atribut tidak unik, Kubernetes menyediakan <a href=/docs/user-guide/labels>label</a> dan <a href=/id/docs/concepts/overview/working-with-objects/annotations/>anotasi</a>.</p><p>Bacalah <a href=https://git.k8s.io/community/contributors/design-proposals/architecture/identifiers.md>dokumentasi desain penanda</a> agar kamu dapat memahami lebih lanjut sintaks yang digunakan untuk Nama dan UID.</p><h2 id=nama>Nama</h2><p>String yang dihasilkan oleh klien yang mengacu pada sebuah objek dalam suatu URL <em>resource</em>, seperti <code>/api/v1/pods/some-name</code>.</p><p>Sebuah objek dengan kind yang sama tidak boleh memiliki nama yang sama pada suatu waktu tertentu. Meskipun begitu, apabila kamu menghapus sebuah objek, kamu membuat sebuah objek baru (yang memiliki kind yang sama) dengan nama yang sama dengan objek yang kamu hapus sebelumnya.</p><p>Berdasarkan ketentuan, nama dari <em>resources</em> Kubernetes memiliki panjang maksimum 253 karakter yang terdiri dari karakter alfanumerik huruf kecil, <code>-</code>, dan <code>.</code>, tetapi <em>resources</em> tertentu punya lebih banyak batasan yang spesifik</p><h2 id=uid>UID</h2><p>String yang dihasilkan oleh sistem Kubernetes untuk mengidentifikasi objek secara unik.</p><p>Setiap objek yang ada pada klaster Kubernetes memiliki UID yang unik. Hal ini dilakukan untuk membedakan keberadaan historis suatu entitas dengan kind dan nama yang serupa.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-1127165f472b7181b9c1d5a0b187d620>3.1.4.4 - Namespace</h1><p>Kubernetes mendukung banyak klaster virtual di dalam satu klaster fisik. Klaster virtual tersebut disebut dengan <em>namespace</em>.</p><h2 id=kapan-menggunakan-banyak-namespace>Kapan menggunakan banyak Namespace</h2><p><em>Namespace</em> dibuat untuk digunakan di <em>environment</em> dengan banyak pengguna yang berada di dalam banyak tim ataupun proyek. Untuk sebuah klaster dengan beberapa pengguna saja, kamu tidak harus membuat ataupun memikirkan tentang <em>namespace</em>. Mulai gunakan <em>namespace</em> saat kamu membutuhkan fitur dari <em>namespace</em> itu sendiri.</p><p><em>Namespace</em> menyediakan ruang untuk nama objek. Nama dari <em>resource</em> atau objek harus berbeda di dalam sebuah <em>namespace</em>, tetapi boleh sama jika berbeda <em>namespace</em>. <em>Namespace</em> tidak bisa dibuat di dalam <em>namespace</em> lain dan setiap <em>resource</em> atau objek Kubernetes hanya dapat berada di dalam satu <em>namespace</em>.</p><p><em>Namespace</em> merupakan cara yang digunakan untuk memisahkan <em>resource</em> klaster untuk beberapa pengguna (dengan <a href=/id/docs/concepts/policy/resource-quotas/><em>resource quota</em></a>).</p><p>Dalam versi Kubernetes yang akan datang, objek di dalam satu <em>namespace</em> akan mempunyai <em>access control policies</em> yang sama secara <em>default</em>.</p><p>Tidak perlu menggunakan banyak <em>namespace</em> hanya untuk memisahkan sedikit perbedaan pada <em>resource</em>, seperti perbedaan versi dari perangkat lunak yang sama: gunakan <a href=/docs/user-guide/labels>label</a> untuk membedakan <em>resource</em> di dalam <em>namespace</em> yang sama.</p><h2 id=bekerja-dengan-namespace>Bekerja dengan Namespace</h2><p>Pembuatan dan penghapusan <em>namespace</em> dijelaskan di <a href=/docs/admin/namespaces>dokumentasi panduan admin untuk <em>namespace</em></a>.</p><h3 id=melihat-namespace>Melihat namespace</h3><p>Kamu dapat melihat daftar <em>namespace</em> di dalam klaster menggunakan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get namespace
</span></span></code></pre></div><pre tabindex=0><code>NAME          STATUS    AGE
default       Active    1d
kube-system   Active    1d
kube-public   Active    1d
</code></pre><p>Kubernetes berjalan dengan tiga <em>namespace</em> awal:</p><ul><li><code>default</code>, <em>namespace default</em> untuk objek yang dibuat tanpa mencantumkan <em>namespace</em> pada spesifikasinya.</li><li><code>kube-system</code>, <em>namespace</em> yang digunakan untuk objek yang dibuat oleh sistem Kubernetes.</li><li><code>kube-public</code>, <em>namespace</em> ini dibuat secara otomatis dan dapat diakses oleh semua pengguna (termasuk yang tidak diautentikasi). <em>Namespace</em> ini disediakan untuk penggunaan klaster, jika beberapa <em>resouce</em> harus terlihat dan dapat dibaca secara publik di seluruh klaster. Aspek publik dari <em>namespace</em> ini hanya sebuah konvensi, bukan persyaratan.</li></ul><h3 id=mengkonfigurasi-namespace-untuk-request>Mengkonfigurasi namespace untuk request</h3><p>Untuk mengkonfigurasi sementara <em>request</em> untuk menggunakan <em>namespace</em> tertentu, gunakan <code>--namespace</code> <em>flag</em>.</p><p>Sebagai contoh:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl --namespace<span style=color:#666>=</span>&lt;insert-namespace-name-here&gt; run nginx --image<span style=color:#666>=</span>nginx
</span></span><span style=display:flex><span>kubectl --namespace<span style=color:#666>=</span>&lt;insert-namespace-name-here&gt; get pods
</span></span></code></pre></div><h3 id=mengkonfigurasi-preferensi-namespace>Mengkonfigurasi preferensi namespace</h3><p>Kamu dapat menyimpan konfigurasi <em>namespace</em> untuk semua perintah <code>kubectl</code> dengan perintah:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config set-context --current --namespace<span style=color:#666>=</span>&lt;insert-namespace-name-here&gt;
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Cek namespace</span>
</span></span><span style=display:flex><span>kubectl config view | grep namespace:
</span></span></code></pre></div><h2 id=namespace-dan-dns>Namespace dan DNS</h2><p>Saat kamu membuat sebuah <a href=/docs/user-guide/services>Service</a>, Kubernetes membuat <a href=/id/docs/concepts/services-networking/dns-pod-service/>Entri DNS</a> untuk <em>service</em> tersebut. Entri <em>DNS</em> ini berformat <code>&lt;service-name>.&lt;namespace-name>.svc.cluster.local</code>, yang berarti jika sebuah kontainer hanya menggunakan <code>&lt;service-name></code>, kontainer tersebut akan berkomunikasi dengan <em>service</em> yang berada di dalam satu <em>namespace</em>. Ini berguna untuk menggunakan konfigurasi yang sama di beberapa <em>namespace</em> seperti <em>Development</em>, <em>Staging</em>, dan <em>Production</em>. Jika kamu ingin berkomunikasi antar <em>namespace</em>, kamu harus menggunakan seluruh <em>fully qualified domain name (FQDN)</em>.</p><h2 id=tidak-semua-objek-di-dalam-namespace>Tidak semua objek di dalam Namespace</h2><p>Kebanyakan <em>resource</em> di Kubernetes (contohnya <em>pod</em>, <em>service</em>, <em>replication controller</em>, dan yang lain) ada di dalam <em>namespace</em>. Namun <em>resource namespace</em> sendiri tidak berada di dalam <em>namespace</em>. Dan <em>low-level resource</em> seperti <a href=/docs/admin/node>node</a> dan <em>persistentVolume</em> tidak berada di <em>namespace</em> manapun.</p><p>Untuk melihat <em>resource</em> di dalam kubernetes yang berada di dalam <em>namespace</em> ataupun tidak:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Di dalam namespace</span>
</span></span><span style=display:flex><span>kubectl api-resources --namespaced<span style=color:#666>=</span><span style=color:#a2f>true</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Tidak di dalam namespace</span>
</span></span><span style=display:flex><span>kubectl api-resources --namespaced<span style=color:#666>=</span><span style=color:#a2f>false</span>
</span></span></code></pre></div></div><div class=td-content style=page-break-before:always><h1 id=pg-f1dec4557fb8ffbac9f11390aaaf9fa4>3.1.4.5 - Label dan Selektor</h1><p><em>Label</em> merupakan pasangan <em>key/value</em> yang melekat pada objek-objek, misalnya pada Pod.
Label digunakan untuk menentukan atribut identitas dari objek agar memiliki arti dan relevan bagi para pengguna, namun tidak secara langsung memiliki makna terhadap sistem inti.
Label dapat digunakan untuk mengatur dan memilih sebagian dari banyak objek. Label-label dapat ditempelkan ke objek-objek pada saat dibuatnya objek-objek tersebut dan kemudian ditambahkan atau diubah kapan saja setelahnya.
Setiap objek dapat memiliki satu set label <em>key/value</em>. Setiap <em>Key</em> harus unik untuk objek tersebut.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#b44>&#34;metadata&#34;</span><span>:</span> {
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;labels&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;key1&#34;</span> : <span style=color:#b44>&#34;value1&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;key2&#34;</span> : <span style=color:#b44>&#34;value2&#34;</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Label memungkinkan untuk menjalankan kueri dan pengamatan dengan efisien, serta ideal untuk digunakan pada UI dan CLI. Informasi yang tidak digunakan untuk identifikasi sebaiknya menggunakan <a href=/id/docs/concepts/overview/working-with-objects/annotations/>anotasi</a>.</p><h2 id=motivasi>Motivasi</h2><p>Label memungkinkan pengguna untuk memetakan struktur organisasi mereka ke dalam objek-objek sistem yang tidak terikat secara erat, tanpa harus mewajibkan klien untuk menyimpan pemetaan tersebut.</p><p><em>Service deployments</em> dan <em>batch processing pipelines</em> sering menjadi entitas yang berdimensi ganda (contohnya partisi berganda atau <em>deployment</em>, jalur rilis berganda, tingkatan berganda, <em>micro-services</em> berganda per tingkatan). Manajemen seringkali membutuhkan operasi lintas tim, yang menyebabkan putusnya enkapsulasi dari representasi hierarki yang ketat, khususnya pada hierarki-hierarki kaku yang justru ditentukan oleh infrastruktur, bukan oleh pengguna.</p><p>Contoh label:</p><ul><li><code>"release" : "stable"</code>, <code>"release" : "canary"</code></li><li><code>"environment" : "dev"</code>, <code>"environment" : "qa"</code>, <code>"environment" : "production"</code></li><li><code>"tier" : "frontend"</code>, <code>"tier" : "backend"</code>, <code>"tier" : "cache"</code></li><li><code>"partition" : "customerA"</code>, <code>"partition" : "customerB"</code></li><li><code>"track" : "daily"</code>, <code>"track" : "weekly"</code></li></ul><p>Ini hanya contoh label yang biasa digunakan; kamu bebas mengembangkan caramu sendiri. Perlu diingat bahwa <em>Key</em> dari label harus unik untuk objek tersebut.</p><h2 id=sintaksis-dan-set-karakter>Sintaksis dan set karakter</h2><p><em>Label</em> merupakan pasangan <em>key/value</em>. <em>Key-key</em> dari Label yang valid memiliki dua segmen: sebuah prefiks dan nama yang opsional, yang dipisahkan oleh garis miring (<code>/</code>). Segmen nama wajib diisi dan tidak boleh lebih dari 63, dimulai dan diakhiri dengan karakter alfanumerik (<code>[a-z0-9A-Z]</code>) dengan tanda pisah (<code>-</code>), garis bawah (<code>_</code>), titik (<code>.</code>), dan alfanumerik di antaranya. Sedangkan prefiks bersifat opsional. Jika ditentukan, prefiks harus berupa subdomain DNS: rangkaian label DNS yang dipisahkan oleh titik (<code>.</code>), dengan total tidak lebih dari 253 karakter, yang diikuti oleh garis miring (<code>/</code>).</p><p>Jika prefiks dihilangkan, <em>Key</em> dari label diasumsikan privat bagi pengguna. Komponen sistem otomatis (contoh <code>kube-scheduler</code>, <code>kube-controller-manager</code>, <code>kube-apiserver</code>, <code>kubectl</code>, atau otomasi pihak ketiga lainnya) yang akan menambah label ke objek-objek milik pengguna akhir harus menentukan prefiks.</p><p>Prefiks <code>kubernetes.io/</code> dan <code>k8s.io/</code> dikhususkan untuk komponen inti Kubernetes.</p><p>Nilai label yang valid tidak boleh lebih dari 63 karakter dan harus kosong atau diawali dan diakhiri dengan karakter alfanumerik (<code>[a-z0-9A-Z]</code>) dengan tanda pisah (<code>-</code>), garis bawah (<code>_</code>), titik (<code>.</code>), dan alfanumerik di antaranya.</p><p>Contoh di bawah ini merupakan berkas konfigurasi untuk Pod yang memiliki dua label <code>environment: production</code> dan <code>app: nginx</code> :</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>label-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>environment</span>:<span style=color:#bbb> </span>production<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.7.9<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=selektor-label>Selektor label</h2><p>Tidak seperti <a href=/id/docs/concepts/overview/working-with-objects/names/>nama dan UID</a>, label tidak memberikan keunikan. Secara umum, kami memperkirakan bahwa banyak objek yang akan memiliki label yang sama.</p><p>Menggunakan sebuah <em>label selector</em>, klien/pengguna dapat mengidentifikasi suatu kumpulan objek. Selektor label merupakan alat/cara pengelompokan utama pada Kubernetes.</p><p>Saat ini API mendukung dua jenis selektor: <em>equality-based</em> dan <em>set-based</em>.
Sebuah selektor label dapat dibuat dari kondisi berganda yang dipisahkan oleh koma. Pada kasus kondisi berganda, semua kondisi harus dipenuhi sehingga separator koma dapat bertindak sebagai operator logika <em>AND</em> (<code>&&</code>).</p><p>Makna dari selektor yang kosong atau tidak diisi tergantung dari konteks, dan tipe API yang menggunakan selektor harus mendokumentasikan keabsahan dan arti dari selektor yang kosong tersebut.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Untuk beberapa tipe API, seperti ReplicaSet, selektor label untuk dua objek tidak boleh tumpang tindih dengan Namespace, jika tidak maka <em>controller</em> akan melihatnya sebagai instruksi yang menyebabkan konflik dan akan gagal menentukan berapa banyak replika yang seharusnya tersedia.</div><div class="alert alert-warning caution callout" role=alert><strong>Perhatian:</strong> Untuk kedua kondisi <em>equality-based</em> dan <em>set-based</em> tidak ada logika operator <em>OR</em> (<code>||</code>). Pastikan struktur pernyataan filter kamu ikut disesuaikan.</div><h3 id=kondisi-equality-based>Kondisi <em>Equality-based</em></h3><p>Kondisi <em>Equality-based</em> atau <em>inequality-based</em> memungkinkan untuk melakukan filter dengan menggunakan <em>key</em> dan <em>value</em> dari label. Objek yang cocok harus memenuhi semua batasan label yang telah ditentukan, meskipun mereka dapat memiliki label tambahan lainnya.
Terdapat tiga jenis operator yang didukung yaitu <code>=</code>,<code>==</code>,<code>!=</code>. Dua operator pertama menyatakan kesamaan (keduanya hanyalah sinonim), sementara operator terakhir menyatakan ketidaksamaan. Contoh:</p><pre tabindex=0><code>environment = production
tier != frontend
</code></pre><p>Kondisi pertama akan memilih semua sumber daya dengan <em>key</em> <code>environment</code> dan nilai <em>key</em> <code>production</code>.
Kondisi berikutnya akan memilih semua sumber daya dengan <em>key</em> <code>tier</code> dan nilai <em>key</em> selain <code>frontend</code>, dan semua sumber daya yang tidak memiliki label dengan <em>key</em> <code>tier</code>.
Kamu juga dapat memfilter sumber daya dalam <code>production</code> selain <code>frontend</code> dengan menggunakan operator koma: <code>environment=production,tier!=frontend</code></p><p>Salah satu skenario penggunaan label dengan kondisi <em>equality-based</em> yaitu untuk kriteria pemilihan Node untuk Pod-Pod. Sebagai contoh, Pod percontohan di bawah ini akan memilih Node dengan label "<code>accelerator=nvidia-tesla-p100</code>".</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cuda-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cuda-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;k8s.gcr.io/cuda-vector-add:v0.1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>nvidia.com/gpu</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodeSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>accelerator</span>:<span style=color:#bbb> </span>nvidia-tesla-p100<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=kondisi-set-based>Kondisi <em>Set-based</em></h3><p>Kondisi label <em>Set-based</em> memungkinkan memfilter <em>key</em> terhadap suatu kumpulan nilai. Terdapat tiga jenis operator yang didukung, yaitu: <code>in</code>,<code>notin</code>, dan <code>exists</code> (hanya <em>key</em>-nya saja). Contoh:</p><pre tabindex=0><code>environment in (production, qa)
tier notin (frontend, backend)
partition
!partition
</code></pre><p>Contoh pertama akan memilih semua sumber daya dengan <em>key</em> <code>environment</code> dan nilai <code>production</code> atau <code>qa</code>.
Contoh kedua akan memilih semua sumber daya dengan <em>key</em> <code>tier</code> dan nilai selain <code>frontend</code> dan <code>backend</code>, serta semua sumber daya yang tidak memiliki label dengan <em>key</em> <code>tier</code>.
Contoh ketiga akan memilih semua sumber daya yang memiliki <em>key</em> dari label<code>partition</code>; nilainya tidak diperiksa.
Sedangkan contoh keempat akan memilih semua sumber daya yang tidak memiliki label dengan <em>key</em> <code>partition</code>; nilainya tidak diperiksa.
Secara serupa, operator koma bertindak sebagai operator <em>AND</em>. Sehingga penyaringan sumber daya dengan <em>key</em> <code>partition</code> (tidak peduli nilai dari <em>key</em>) dan <code>environment</code> yang tidak sama dengan <code>qa</code> dapat dicapai dengan <code>partition,environment notin (qa)</code>.
Selektor label <em>set-based</em> merupakan bentuk umum persamaan karena <code>environment=production</code> sama dengan <code>environment in (production)</code>; demikian pula <code>!=</code> dan <code>notin</code>.</p><p>Kondisi <em>Set-based</em> dapat digabungkan dengan kondisi <em>equality-based</em>. Contoh: <code>partition in (customerA, customerB),environment!=qa</code>.</p><h2 id=api>API</h2><h3 id=penyaringan-list-dan-watch>Penyaringan LIST dan WATCH</h3><p>Operasi LIST dan WATCH dapat menentukan selektor label untuk memfilter suatu kumpulan objek yang didapat dengan menggunakan parameter kueri. Kedua jenis kondisi diperbolehkan (ditampilkan sebagai berikut, sama seperti saat tampil pada string kueri di URL):</p><ul><li>Kondisi <em>equality-based</em>: <code>?labelSelector=environment%3Dproduction,tier%3Dfrontend</code></li><li>Kondisi <em>set-based</em>: <code>?labelSelector=environment+in+%28production%2Cqa%29%2Ctier+in+%28frontend%29</code></li></ul><p>Kedua jenis selektor label dapat digunakan untuk menampilkan (<em>list</em>) dan mengamati (<em>watch</em>) sumber daya melalui klien REST. Contohnya, menargetkan <code>apiserver</code> dengan <code>kubectl</code> dan menggunakan <em>equality-based</em> kamu dapat menuliskan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l <span style=color:#b8860b>environment</span><span style=color:#666>=</span>production,tier<span style=color:#666>=</span>frontend
</span></span></code></pre></div><p>atau menggunakan kondisi <em>set-based</em>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l <span style=color:#b44>&#39;environment in (production),tier in (frontend)&#39;</span>
</span></span></code></pre></div><p>Seperti yang telah disebutkan sebelumnya, kondisi <em>set-based</em> lebih ekspresif. Sebagai contoh, mereka dapat digunakan untuk mengimplementasi operator <em>OR</em> pada nilai:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l <span style=color:#b44>&#39;environment in (production, qa)&#39;</span>
</span></span></code></pre></div><p>atau membatasi pencocokan negatif dengan operator <em>exists</em>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l <span style=color:#b44>&#39;environment,environment notin (frontend)&#39;</span>
</span></span></code></pre></div><h3 id=mengatur-referensi-pada-objek-api>Mengatur referensi pada objek API</h3><p>Pada beberapa objek Kubernetes, seperti <a href=/docs/user-guide/services><code>Service</code></a> dan <a href=/id/docs/concepts/workloads/controllers/replicationcontroller/><code>ReplicationController</code></a>, juga menggunakan selektor label untuk menentukan kumpulan dari sumber daya lain, seperti <a href=/id/docs/concepts/workloads/pods/pod>Pod</a>.</p><h4 id=service-dan-replicationcontroller>Service dan ReplicationController</h4><p>Kumpulan Pod yang ditargetkan oleh sebuah <code>service</code> ditentukan dengan selektor label. Demikian pula kumpulan Pod yang harus ditangani oleh <code>replicationcontroller</code> juga ditentukan dengan selektor label.</p><p>Selektor label untuk kedua objek tersebut ditentukan dalam berkas <code>json</code> atau <code>yaml</code> menggunakan <em>maps</em>, dan hanya mendukung kondisi <em>equality-based</em>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#b44>&#34;selector&#34;</span><span>:</span> {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;component&#34;</span> : <span style=color:#b44>&#34;redis&#34;</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>atau</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>component</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span></code></pre></div><p>selektor ini (baik dalam bentuk <code>json</code> atau <code>yaml</code>) sama dengan <code>component=redis</code> atau <code>component in (redis)</code>.</p><h4 id=sumber-daya-yang-mendukung-kondisi-set-based>Sumber daya yang mendukung kondisi set-based</h4><p>Sumber daya yang lebih baru, seperti <a href=/id/docs/concepts/workloads/controllers/jobs-run-to-completion/><code>Job</code></a>, <a href=/id/docs/concepts/workloads/controllers/deployment/><code>Deployment</code></a>, <a href=/id/docs/concepts/workloads/controllers/replicaset/><code>ReplicaSet</code></a>, dan <a href=/id/docs/concepts/workloads/controllers/daemonset/><code>DaemonSet</code></a>, juga mendukung kondisi <em>set-based</em>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>component</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- {<span style=color:green;font-weight:700>key: tier, operator: In, values</span>:<span style=color:#bbb> </span>[cache]}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- {<span style=color:green;font-weight:700>key: environment, operator: NotIn, values</span>:<span style=color:#bbb> </span>[dev]}<span style=color:#bbb>
</span></span></span></code></pre></div><p><code>matchLabels</code> merupakan pemetaan dari pasangan <code>{key,value}</code>. Sebuah <code>{key,value}</code> pada pemetaan <code>matchLabels</code> adalah sama dengan elemen dari <code>matchExpressions</code>, yang nilai <code>key</code> nya adalah "key", dengan <code>operator</code> "In", dan <em>array</em> <code>values</code> hanya berisi "value". <code>matchExpressions</code> merupakan daftar kondisi untuk selektor Pod. Operator yang valid termasuk In, NotIn, Exists, dan DoesNotExist. Kumpulan nilai ini tidak boleh kosong pada kasus In dan NotIn. Semua kondisi, baik dari <code>matchLabels</code> dan <code>matchExpressions</code> di-AND secara sekaligus -- mereka harus memenuhi semua kondisi agar cocok.</p><h4 id=memilih-kumpulan-node>Memilih kumpulan Node</h4><p>Salah satu contoh penggunaan pemilihan dengan menggunakan label yaitu untuk membatasi suatu kumpulan Node tertentu yang dapat digunakan oleh Pod.
Lihat dokumentasi pada <a href=/id/docs/concepts/scheduling-eviction/assign-pod-node/>pemilihan Node</a> untuk informasi lebih lanjut.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-93cd7a1d4e1623e2bf01afc49a5af69c>3.1.4.6 - Anotasi</h1><p>Kamu dapat menggunakan fitur anotasi dari Kubernetes untuk menempelkan sembarang
metadata tanpa identitas pada suatu objek. Klien, seperti perangkat dan <em>library</em>,
dapat memperoleh metadata tersebut.</p><h2 id=mengaitkan-metadata-pada-objek>Mengaitkan metadata pada objek</h2><p>Kamu dapat menggunakan label maupun anotasi untuk menempelkan metadata pada suatu
objek Kubernetes. Label dapat digunakan untuk memilih objek dan mencari sekumpulan
objek yang memenuhi kondisi tertentu. Sebaliknya, anotasi tidak digunakan untuk
mengenali atau memilih objek. Metadata dalam sebuah anotasi bisa berukuran kecil atau besar,
terstruktur atau tidak terstruktur, dan dapat berisikan karakter-karakter yang tidak
diperbolehkan oleh label.</p><p>Anotasi, seperti label, merupakan pemetaan <em>key/value</em>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#b44>&#34;metadata&#34;</span><span>:</span> {
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;annotations&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;key1&#34;</span> : <span style=color:#b44>&#34;value1&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;key2&#34;</span> : <span style=color:#b44>&#34;value2&#34;</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Berikut merupakan beberapa contoh informasi yang dapat dicatat dengan menggunakan anotasi:</p><ul><li><p><em>Field-field</em> yang dikelola secara deklaratif oleh <em>layer</em> konfigurasi. Menempelkan
<em>field-field</em> tersebut sebagai anotasi membedakan mereka dari nilai <em>default</em> yang
ditetapkan oleh klien ataupun server, dari <em>field-field</em> yang otomatis di-<em>generate</em>, serta
dari <em>field-field</em> yang ditetapkan oleh sistem <em>auto-sizing</em> atau <em>auto-scaling</em>.</p></li><li><p>Informasi mengenai <em>build</em>, rilis, atau <em>image</em>, seperti <em>timestamp</em>, rilis ID, git <em>branch</em>,
nomor PR, <em>hash</em> suatu <em>image</em>, dan alamat registri.</p></li><li><p>Penanda untuk <em>logging</em>, <em>monitoring</em>, <em>analytics</em>, ataupun repositori audit.</p></li><li><p>Informasi mengenai <em>library</em> klien atau perangkat yang dapat digunakan untuk <em>debugging</em>:
misalnya, informasi nama, versi, dan <em>build</em>.</p></li><li><p>Informasi yang berhubungan dengan pengguna atau perangkat/sistem, seperti URL objek yang terkait
dengan komponen dari ekosistem lain.</p></li><li><p>Metadata untuk perangkat <em>rollout</em> yang ringan (<em>lightweight</em>): contohnya, untuk
konfigurasi atau penanda (<em>checkpoint</em>).</p></li><li><p>Nomor telepon atau <em>pager</em> dari orang yang bertanggung jawab, atau entri direktori
yang berisi informasi lebih lanjut, seperti <em>website</em> sebuah tim.</p></li><li><p>Arahan dari pengguna (<em>end-user</em>) untuk melakukan implementasi, perubahan perilaku,
ataupun untuk interaksi dengan fitur-fitur non-standar.</p></li></ul><p>Tanpa menggunakan anotasi, kamu dapat saja menyimpan informasi-informasi dengan tipe
di atas pada suatu basis data atau direktori eksternal, namun hal ini sangat mempersulit
pembuatan <em>library</em> klien dan perangkat yang bisa digunakan sama-sama (<em>shared</em>) untuk melakukan
<em>deploy</em>, pengelolaan, introspeksi, dan semacamnya.</p><h2 id=sintaksis-dan-sekumpulan-karakter>Sintaksis dan sekumpulan karakter</h2><p>Anotasi merupakan <em>key/value pair</em>. <em>Key</em> dari sebuah anotasi yang valid memiliki dua segmen: segmen prefiks yang opsional dan segmen nama, dipisahkan
oleh sebuah garis miring (<code>/</code>). Segmen nama bersifat wajib dan harus terdiri dari 63 karakter atau kurang, dimulai dan diakhiri dengan karakter alfanumerik (<code>[a-z0-9A-Z]</code>) dengan tanda minus (<code>-</code>), garis bawah (<code>_</code>), titik (<code>.</code>), dan alfanumerik di tengahnya. Jika terdapat prefiks,
prefiks haruslah berupa subdomain DNS: urutan dari label DNS yang dipisahkan oleh titik (<code>.</code>), totalnya tidak melebihi 253 karakter,
diikuti dengan garis miring (<code>/</code>).</p><p>Jika tidak terdapat prefiks, maka <em>key</em> dari anotasi diasumsikan hanya bisa dilihat oleh pengguna (privat). Komponen sistem otomasi
(seperti <code>kube-scheduler</code>, <code>kube-controller-manager</code>, <code>kube-apiserver</code>, <code>kubectl</code>, ataupun otomasi pihak ketiga) yang menambahkan anotasi
pada objek-objek pengguna harus memiliki sebuah prefiks.</p><p>Prefiks <code>kubernetes.io/</code> dan <code>k8s.io/</code> merupakan reservasi dari komponen inti Kubernetes.</p><h2 id=selanjutnya>Selanjutnya</h2><p>Pelajari lebih lanjut tentang <a href=/id/docs/concepts/overview/working-with-objects/labels/>Label dan Selektor</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-046c03090d47bc4b89b818dc645c3865>3.1.4.7 - Selektor Field</h1><p>Selektor <em>field</em> memungkinkan kamu untuk <a href=/id/docs/concepts/overview/working-with-objects/kubernetes-objects>memilih (<em>select</em>) <em>resource</em> Kubernetes</a> berdasarkan
nilai dari satu atau banyak <em>field resource</em>. Di bawah ini merupakan contoh dari beberapa <em>query</em> selektor <em>field</em>:</p><ul><li><code>metadata.name=my-service</code></li><li><code>metadata.namespace!=default</code></li><li><code>status.phase=Pending</code></li></ul><p>Perintah <code>kubectl</code> di bawah ini memilih semua Pod dengan <em>field</em> <a href=/id/docs/concepts/workloads/pods/pod-lifecycle/#pod-phase><code>status.phase</code></a> yang bernilai
<code>Running</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods --field-selector status.phase<span style=color:#666>=</span>Running
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong><p>Pada dasarnya, selektor <em>field</em> merupakan filter dari <em>resource</em>. Secara <em>default</em>, tidak ada selektor/filter apapun yang diterapkan. Artinya,
semua <em>resource</em> dengan tipe apapun akan terpilih. Akibatnya, <em>query</em> dengan perintah <code>kubectl</code> di bawah ini akan memberikan hasil yang sama:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods
</span></span><span style=display:flex><span>kubectl get pods --field-selector <span style=color:#b44>&#34;&#34;</span>
</span></span></code></pre></div></div><h2 id=field-yang-didukung><em>Field</em> yang didukung</h2><p>Selektor-selektor <em>field</em> yang didukung oleh Kubernetes bervariasi tergantung dari tipe <em>resource</em>. Semua tipe <em>resource</em> mendukung <em>field</em>
<code>metadata.name</code> dan <code>metadata.namespace</code>. Jika kamu menggunakan selektor <em>field</em> yang tidak didukung, maka akan terjadi error. Contohnya:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get ingress --field-selector foo.bar<span style=color:#666>=</span>baz
</span></span></code></pre></div><pre tabindex=0><code>Error from server (BadRequest): Unable to find &#34;ingresses&#34; that match label selector &#34;&#34;, field selector &#34;foo.bar=baz&#34;: &#34;foo.bar&#34; is not a known field selector: only &#34;metadata.name&#34;, &#34;metadata.namespace&#34;
</code></pre><h2 id=operator-yang-didukung>Operator yang didukung</h2><p>Kamu dapat menggunakan operator <code>=</code>, <code>==</code>, dan <code>!=</code> pada selektor <em>field</em> (<code>=</code> dan <code>==</code> punya arti yang sama). Sebagai contoh, perintah <code>kubectl</code> ini
memilih semua Kubernetes Service yang tidak terdapat pada <em>namespace</em> <code>default</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get services --field-selector metadata.namespace!<span style=color:#666>=</span>default
</span></span></code></pre></div><h2 id=selektor-berantai>Selektor berantai</h2><p>Seperti halnya <a href=/id/docs/concepts/overview/working-with-objects/labels>label</a> dan selektor-selektor lainnya, kamu dapat membuat selektor <em>field</em> berantai
(<em>chained</em>) dengan <em>list</em> yang dipisahkan oleh koma. Perintah <code>kubectl</code> di bawah ini memilih semua Pod dengan <code>status.phase</code> tidak sama dengan
<code>Running</code> dan <em>field</em> <code>spec.restartPolicy</code> sama dengan <code>Always</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods --field-selector<span style=color:#666>=</span>status.phase!<span style=color:#666>=</span>Running,spec.restartPolicy<span style=color:#666>=</span>Always
</span></span></code></pre></div><h2 id=resource-dengan-beberapa-tipe><em>Resource</em> dengan beberapa tipe</h2><p>Kamu dapat menggunakan selektor-selektor <em>field</em> dengan beberapa tipe <em>resource</em> sekaligus. Perintah <code>kubectl</code> di bawah ini memilih semua Statefulset
dan Service yang tidak terdapat pada <em>namespace</em> <code>default</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get statefulsets,services --all-namespaces --field-selector metadata.namespace!<span style=color:#666>=</span>default
</span></span></code></pre></div></div><div class=td-content style=page-break-before:always><h1 id=pg-5dd62c6a4a481b4cf1ac50f6799eb581>3.1.4.8 - Label yang Disarankan</h1><p>Kamu dapat melakukan visualisasi dan mengatur objek Kubernetes dengan lebih banyak <em>tools</em>
dibandingkan dengan perintah kubectl dan dasbor. Sekumpulan label mengizinkan <em>tools</em>
untuk bekerja dengan interoperabilitas, mendeskripsikan objek dengan cara yang umum yang dapat
dipahami semua <em>tools</em>.</p><p>Sebagai tambahan bagi <em>tooling</em> tambahan, label yang disarankan ini mendeskripsikan
aplikasi sehingga informasi yang ada diapat di-<em>query</em>.</p><p>Metadata ini diorganisasi berbasis konsep dari sebuah aplikasi. Kubernetes bukan merupakan
sebuah platform sebagai sebuah <em>service</em> (<em>platform as a service</em>/PaaS) dan tidak
mewajibkan sebuah gagasan formal dari sebuah aplikasi.
Sebagai gantinya, aplikasi merupakan suatu hal informal yang dideskripsikan melalui metadata.
Definisi yang dimiliki oleh sebuah aplikasi merupakan sebuah hal yang cukup longgar.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Berikut merupakan label yang disarankan. Label ini mempermudah
proses manajemen aplikasi tetapi tidak dibutuhkan untuk <em>tooling</em> utama apa pun.</div><p>Label yang digunakan secara umum serta anotasi memiliki prefiks yang serupa: <code>app.kubernetes.io</code>. Label
tanpa sebuah prefiks bersifat privat khusus pengguna saja. Prefiks yang digunakan secara umum tadi
menjamin bahwa label tadi tidak akan mengganggu label <em>custom</em> yang diberikan oleh pengguna.</p><h2 id=label>Label</h2><p>Untuk mendapatkan keuntungan menyeluruh dari penggunaan label ini,
label harus digunakan pada seluruh objek sumber daya.</p><table><thead><tr><th><em>Key</em></th><th>Deskripsi</th><th>Contoh</th><th>Tipe</th></tr></thead><tbody><tr><td><code>app.kubernetes.io/name</code></td><td>Nama aplikasi</td><td><code>mysql</code></td><td>string</td></tr><tr><td><code>app.kubernetes.io/instance</code></td><td>Nama unik yang bersifat sebagai pengidentifikasi dari sebuah instans aplikasi</td><td><code>wordpress-abcxzy</code></td><td>string</td></tr><tr><td><code>app.kubernetes.io/version</code></td><td>Versi saat ini dari aplikasi (misalnya sebuah versi semantik, hash revisi, etc.)</td><td><code>5.7.21</code></td><td>string</td></tr><tr><td><code>app.kubernetes.io/component</code></td><td>Komponen yang ada pada arsitektur</td><td><code>database</code></td><td>string</td></tr><tr><td><code>app.kubernetes.io/part-of</code></td><td>Nama dari komponen lebih tinggi dari aplikasi yang mencakup bagian ini</td><td><code>wordpress</code></td><td>string</td></tr><tr><td><code>app.kubernetes.io/managed-by</code></td><td>Alat yang digunakan untuk mengatur operasi pada aplikasi</td><td><code>helm</code></td><td>string</td></tr></tbody></table><p>Untuk memberikan ilustrasi dari penggunaan label, bayangkan sebuah objek StatefulSet yang didefinisikan sebagai berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StatefulSet<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>wordpress-abcxzy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;5.7.21&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/component</span>:<span style=color:#bbb> </span>database<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/part-of</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/managed-by</span>:<span style=color:#bbb> </span>helm<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=aplikasi-dan-instans-aplikasi>Aplikasi dan Instans Aplikasi</h2><p>Sebuah aplikasi dapat diinstal sekali atau beberapa kali di dalam klaster Kubernetes dan,
pada beberapa kasus, di dalam sebuah <em>namespace</em> yang sama. Misalnya, wordpress dapat
diinstal lebih dari satu kali dimana situs web yang berbeda merupakan hasil instalasi yang berbeda.</p><p>Nama dari sebuah aplikasi dan nama instans akan dicatat secara terpisah. Sebagai contoh,
WordPress memiliki <code>wordpress</code> sebagai nilai dari <code>app.kubernetes.io/name</code> dimana
nama instans yang digunakan adalah <code>wordpress-abcxzy</code> yang merupakan nilai dari <code>app.kubernetes.io/instance</code>.
Hal ini memungkinkan aplikasi dan instans aplikasi untuk dapat diidentifikasi. Setiap instans dari aplikasi
haruslah memiliki nama yang unik.</p><h2 id=contoh>Contoh</h2><p>Untuk memberikan ilustrasi dengan cara yang berbeda pada penggunaan label, contoh di bawah ini
memiliki tingkat kompleksitas yang cukup beragam.</p><h3 id=sebuah-aplikasi-stateless-sederhana>Sebuah Aplikasi <em>Stateless</em> Sederhana</h3><p>Bayangkan sebuah kasus dimana sebuah aplikasi <em>stateless</em> di-<em>deploy</em>
menggunakan Deployment dan Service. Di bawah ini merupakan
contoh kutipan yang merepresentasikan bagaimana
label dapat digunakan secara sederhana.</p><p>Deployment digunakan untuk memastikan Pod dijalankan untuk aplikasi itu sendiri.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>myservice<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>myservice-abcxzy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Service digunakan untuk mengekspos aplikasi.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>myservice<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>myservice-abcxzy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=sebuah-aplikasi-web-dengan-basis-data>Sebuah Aplikasi Web dengan Basis Data</h3><p>Bayangkan sebuah aplikasi yang lebih kompleks: sebuah aplikasi web (WordPress)
yang menggunakan basis data (MySQL), yang diinstal menggunakan Helm.
Kutipan berikut merepresentasikan objek yang di-<em>deploy</em> untuk aplikasi ini.</p><p>Berikut merupakan konfigurasi Deployment yang digunakan untuk WordPress:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>wordpress-abcxzy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;4.9.4&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/managed-by</span>:<span style=color:#bbb> </span>helm<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/component</span>:<span style=color:#bbb> </span>server<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/part-of</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Service yang digunakan untuk mengekspos WordPress:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>wordpress-abcxzy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;4.9.4&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/managed-by</span>:<span style=color:#bbb> </span>helm<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/component</span>:<span style=color:#bbb> </span>server<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/part-of</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>MySQL diekspos sebagai StatefulSet dengan metadata yang digunakan untuk StatefulSet tersebut serta aplikasi yang menggunakannya:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StatefulSet<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>mysql-abcxzy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;5.7.21&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/managed-by</span>:<span style=color:#bbb> </span>helm<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/component</span>:<span style=color:#bbb> </span>database<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/part-of</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Service yang digunakan untuk mengekspos MySQL sebagai bagian dari WordPress:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>mysql-abcxzy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;5.7.21&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/managed-by</span>:<span style=color:#bbb> </span>helm<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/component</span>:<span style=color:#bbb> </span>database<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/part-of</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Dengan StatefulSet MySQL dan Service kamu dapat mengetahui informasi yang ada pada MySQL dan Wordpress.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-2bf36ccd6b3dbeafecf87c39761b07c7>3.2 - Arsitektur Kubernetes</h1></div><div class=td-content><h1 id=pg-9ef2890698e773b6c0d24fd2c20146f5>3.2.1 - Node</h1><p>Node merupakan sebuah mesin <i>worker</i> di dalam Kubernetes, yang sebelumnya dinamakan <code>minion</code>.
Sebuah node bisa berupa VM ataupun mesin fisik, tergantung dari klaster-nya.
Masing-masing node berisi beberapa servis yang berguna untuk menjalankan banyak <a href=/id/docs/concepts/workloads/pods/pod/>pod</a> dan diatur oleh komponen-komponen yang dimiliki oleh master.
Servis-servis di dalam sebuah node terdiri dari <a href=/id/docs/concepts/overview/components/#node-components>runtime kontainer</a>, kubelet dan kube-proxy.
Untuk lebih detail, lihat dokumentasi desain arsitektur pada <a href=https://git.k8s.io/community/contributors/design-proposals/architecture/architecture.md#the-kubernetes-node>Node Kubernetes</a>.</p><h2 id=status-node>Status Node</h2><p>Sebuah status node berisikan informasi sebagai berikut:</p><ul><li><a href=#addresses>Addresses</a></li><li><a href=#condition>Condition</a></li><li><a href=#capacity>Capacity</a></li><li><a href=#info>Info</a></li></ul><p>Masing-masing bagian dijelaskan secara rinci di bawah ini.</p><h3 id=addresses>Addresses</h3><p>Penggunaan <i>field-field</i> ini bergantung pada penyedia layanan cloud ataupun konfigurasi bare metal yang kamu punya.</p><ul><li>HostName: Merupakan hostname yang dilaporkan oleh kernel node. Dapat diganti melalui parameter <code>--hostname-override</code> pada kubelet.</li><li>ExternalIP: Biasanya merupakan alamat IP pada node yang punya <i>route</i> eksternal (bisa diakses dari luar klaster).</li><li>InternalIP: Biasanya merupakan alamat IP pada node yang hanya punya <i>route</i> di dalam klaster.</li></ul><h3 id=condition>Condition</h3><p><i>Field</i> <code>conditions</code> menjelaskan tentang status dari semua node yang sedang berjalan (<code>Running</code>).</p><table><thead><tr><th>Kondisi Node</th><th>Penjelasan</th></tr></thead><tbody><tr><td><code>OutOfDisk</code></td><td><code>True</code> jika node sudah tidak punya cukup kapasitas disk untuk menjalankan pod baru, <code>False</code> jika sebaliknya</td></tr><tr><td><code>Ready</code></td><td><code>True</code> jika node sehat (<i>healthy</i>) dan siap untuk menerima pod, <code>False</code> jika node tidak lagi sehat (<i>unhealthy</i>) dan tidak siap menerima pod, serta <code>Unknown</code> jika kontroler node tidak menerima pesan di dalam <code>node-monitor-grace-period</code> (standarnya 40 detik)</td></tr><tr><td><code>MemoryPressure</code></td><td><code>True</code> jika memori pada node terkena tekanan (<i>pressure</i>) -- maksudnya, jika kapasitas memori node sudah di titik rendah; <code>False</code> untuk sebaliknya</td></tr><tr><td><code>PIDPressure</code></td><td><code>True</code> jika <i>process-process</i> mengalami tekanan (<i>pressure</i>) -- maksudnya, jika node menjalankan terlalu banyak <i>process</i>; <code>False</code> untuk sebaliknya</td></tr><tr><td><code>DiskPressure</code></td><td><code>True</code> jika ukuran disk mengalami tekanan (<i>pressure</i>) -- maksudnya, jika kapasitas disk sudah di titik rendah; <code>False</code> untuk sebaliknya</td></tr><tr><td><code>NetworkUnavailable</code></td><td><code>True</code> jika jaringan untuk node tidak dikonfigurasi dengan benar, <code>False</code> untuk sebaliknya</td></tr></tbody></table><p><i>Condition</i> pada node direpresentasikan oleh suatu obyek JSON. Sebagai contoh, respon berikut ini menggambarkan node yang sedang sehat (<i>healthy</i>).</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#b44>&#34;conditions&#34;</span><span>:</span> [
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;Ready&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;status&#34;</span>: <span style=color:#b44>&#34;True&#34;</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>]
</span></span></code></pre></div><p>Jika status untuk <code>Ready condition</code> bernilai <code>Unknown</code> atau <code>False</code> untuk waktu yang lebih dari <code>pod-eviction-timeout</code>, tergantung bagaimana <a href=/docs/admin/kube-controller-manager/>kube-controller-manager</a> dikonfigurasi, semua pod yang dijalankan pada node tersebut akan dihilangkan oleh Kontroler Node.
Durasi <i>eviction timeout</i> yang standar adalah <strong>lima menit</strong>.
Pada kasus tertentu ketika node terputus jaringannya, apiserver tidak dapat berkomunikasi dengan kubelet yang ada pada node.
Keputusan untuk menghilangkan pod tidak dapat diberitahukan pada kubelet, sampai komunikasi dengan apiserver terhubung kembali.
Sementara itu, pod-pod akan terus berjalan pada node yang sudah terputus, walaupun mendapati <i>schedule</i> untuk dihilangkan.</p><p>Pada versi Kubernetes sebelum 1.5, kontroler node dapat menghilangkan dengan paksa (<a href=/id/docs/concepts/workloads/pods/pod/#force-deletion-of-pods>force delete</a>) pod-pod yang terputus dari apiserver.
Namun, pada versi 1.5 dan seterusnya, kontroler node tidak menghilangkan pod dengan paksa, sampai ada konfirmasi bahwa pod tersebut sudah berhenti jalan di dalam klaster.
Pada kasus dimana Kubernetes tidak bisa menarik kesimpulan bahwa ada node yang telah meninggalkan klaster, admin klaster mungkin perlu untuk menghilangkan node secara manual.
Menghilangkan obyek node dari Kubernetes akan membuat semua pod yang berjalan pada node tersebut dihilangkan oleh apiserver, dan membebaskan nama-namanya agar bisa digunakan kembali.</p><p>Pada versi 1.12, fitur <code>TaintNodesByCondition</code> telah dipromosikan ke beta, sehingga kontroler <i>lifecycle</i> node secara otomatis membuat <a href=/id/docs/concepts/configuration/taint-and-toleration/>taints</a> yang merepresentasikan <i>conditions</i>.
Akibatnya, <i>scheduler</i> menghiraukan <i>conditions</i> ketika mempertimbangkan sebuah Node; <i>scheduler</i> akan melihat pada <i>taints</i> sebuah Node dan <i>tolerations</i> sebuah Pod.</p><p>Sekarang, para pengguna dapat memilih antara model <i>scheduling</i> yang lama dan model <i>scheduling</i> yang lebih fleksibel.
Pada model yang lama, sebuah pod tidak memiliki <i>tolerations</i> apapun sampai mendapat giliran <i>schedule</i>. Namun, pod dapat dijalankan pada Node tertentu, dimana pod melakukan toleransi terhadap <i>taints</i> yang dimiliki oleh Node tersebut.</p><div class="alert alert-warning caution callout" role=alert><strong>Perhatian:</strong> Mengaktifkan fitur ini menambahkan <i>delay</i> sedikit antara waktu saat suatu <i>condition</i> terlihat dan saat suatu <i>taint</i> dibuat. <i>Delay</i> ini biasanya kurang dari satu detik, tapi dapat menambahkan jumlah yang telah berhasil mendapat <i>schedule</i>, namun ditolak oleh kubelet untuk dijalankan.</div><h3 id=capacity>Capacity</h3><p>Menjelaskan tentang <i>resource-resource</i> yang ada pada node: CPU, memori, dan jumlah pod secara maksimal yang dapat dijalankan pada suatu node.</p><h3 id=info>Info</h3><p>Informasi secara umum pada suatu node, seperti versi kernel, versi Kubernetes (versi kubelet dan kube-proxy), versi Docker (jika digunakan), nama OS.
Informasi ini dikumpulkan oleh Kubelet di dalam node.</p><h2 id=manajemen>Manajemen</h2><p>Tidak seperti <a href=/id/docs/concepts/workloads/pods/pod/>pod</a> dan <a href=/id/docs/concepts/services-networking/service/>service</a>, sebuah node tidaklah dibuat dan dikonfigurasi oleh Kubernetes: tapi node dibuat di luar klaster oleh penyedia layanan cloud, seperti Google Compute Engine, atau <i>pool</i> mesin fisik ataupun virtual (VM) yang kamu punya.
Jadi ketika Kubernetes membuat sebuah node, obyek yang merepresentasikan node tersebut akan dibuat.
Setelah pembuatan, Kubernetes memeriksa apakah node tersebut valid atau tidak.
Contohnya, jika kamu mencoba untuk membuat node dari konten berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;Node&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;v1&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;metadata&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;10.240.79.157&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;labels&#34;</span>: {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;my-first-k8s-node&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Kubernetes membuat sebuah obyek node secara internal (representasinya), dan melakukan validasi terhadap node. Validasi dilakukan dengan memeriksa kondisi kesehatan node (<i>health checking</i>), berdasarkan <i>field</i> <code>metadata.name</code>. Jika node valid -- terjadi saat semua servis yang diperlukan sudah jalan -- maka node diperbolehkan untuk menjalankan sebuah pod.
Namun jika tidak valid, node tersebut akan dihiraukan untuk aktivitas apapun yang berhubungan dengan klaster, sampai telah menjadi valid.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Kubernetes tetap menyimpan obyek untuk node yang tidak valid, dan terus memeriksa apakah node telah menjadi valid atau belum.
Kamu harus secara eksplisit menghilangkan obyek Node tersebut untuk menghilangkan proses ini.</div><p>Saat ini, ada tiga komponen yang berinteraksi dengan antarmuka node di Kubernetes: kontroler node, kubelet, dan kubectl.</p><h3 id=kontroler-node>Kontroler Node</h3><p>Kontroler node adalah komponen master Kubernetes yang berfungsi untuk mengatur berbagai aspek dari node.</p><p>Kontroler node memiliki berbagai peran (<i>role</i>) dalam sebuah <i>lifecycle</i> node.
Pertama, menetapkan blok CIDR pada node tersebut saat registrasi (jika CIDR <i>assignment</i> diaktifkan).</p><p>Kedua, terus memperbarui daftar internal node di dalam kontroler node, sesuai dengan daftar mesin yang tersedia di dalam penyedia layanan cloud.
Ketika berjalan di dalam <i>environment</i> cloud, kapanpun saat sebuah node tidak lagi sehat (<i>unhealthy</i>), kontroler node bertanya pada penyedia cloud, apakah VM untuk node tersebut masihkah tersedia atau tidak.
Jika sudah tidak tersedia, kontroler node menghilangkan node tersebut dari daftar node.</p><p>Ketiga, melakukan monitor terhadap kondisi kesehatan (<i>health</i>) node.
Kontroler node bertanggung jawab untuk mengubah status <code>NodeReady condition</code> pada <code>NodeStatus</code> menjadi <code>ConditionUnknown</code>, ketika sebuah node terputus jaringannya (kontroler node tidak lagi mendapat <i>heartbeat</i> karena suatu hal, contohnya karena node tidak hidup), dan saat kemudian melakukan <i>eviction</i> terhadap semua pod yang ada pada node tersebut (melalui terminasi halus -- <i>graceful</i>) jika node masih terus terputus. (<i>Timeout</i> standar adalah 40 detik untuk mulai melaporkan <code>ConditionUnknown</code> dan 5 menit setelah itu untuk mulai melakukan <i>eviction</i> terhadap pod.)</p><p>Kontroler node memeriksa <i>state</i> masing-masing node untuk durasi yang ditentukan oleh argumen <code>--node-monitor-period</code>.</p><p>Pada versi Kubernetes sebelum 1.13, <code>NodeStatus</code> adalah <i>heartbeat</i> yang diberikan oleh node.
Setelah versi 1.13, fitur <i>node lease</i> diperkenalkan sebagai fitur alpha (fitur gate <code>NodeLease</code>,
<a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/0009-node-heartbeat.md>KEP-0009</a>).
Ketika fitur <i>node lease</i> diaktifasi, setiap node terhubung dengan obyek <code>Lease</code> di dalam <i>namespace</i> <code>kube-node-lease</code> yang terus diperbarui secara berkala.
Kemudian, <code>NodeStatus</code> dan <i>node lease</i> keduanya dijadikan sebagai <i>heartbeat</i> dari node.
Semua <i>node lease</i> diperbarui sesering mungkin, sedangkan <code>NodeStatus</code> dilaporkan dari node untuk master hanya ketika ada perubahan atau telah melewati periode waktu tertentu (<i>default</i>-nya 1 menit, lebih lama daripada <i>default timeout</i> node-node yang terputus jaringannya).
Karena <i>node lease</i> jauh lebih ringan daripada <code>NodeStatus</code>, fitur ini membuat <i>heartbeat</i> dari node jauh lebih murah secara signifikan dari sudut pandang skalabilitas dan performa.</p><p>Di Kubernetes 1.4, kami telah memperbarui <i>logic</i> dari kontroler node supaya lebih baik dalam menangani kasus saat banyak sekali node yang tidak bisa terhubung dengan master (contohnya, karena master punya masalah jaringan).
Mulai dari 1.4, kontroler node melihat <i>state</i> dari semua node di dalam klaster, saat memutuskan untuk melakukan <i>eviction</i> pada pod.</p><p>Pada kasus kebanyakan, kontroler node membatasi <i>rate eviction</i> menjadi <code>--node-eviction-rate</code> (<i>default</i>-nya 0.1) per detik.
Artinya, kontroler node tidak akan melakukan <i>eviction</i> pada pod lebih dari 1 node per 10 detik.</p><p>Perlakuan <i>eviction</i> pada node berubah ketika sebuah node menjadi tidak sehat (<i>unhealthy</i>) di dalam suatu zona <i>availability</i>.
Kontroler node memeriksa berapa persentase node di dalam zona tersebut yang tidak sehat (saat <code>NodeReady condition</code> menjadi <code>ConditionUnknown</code> atau <code>ConditionFalse</code>) pada saat yang bersamaan.
Jika persentase node yang tidak sehat bernilai <code>--unhealthy-zone-threshold</code> (<i>default</i>-nya 0.55), maka <i>rate eviction</i> berkurang: untuk ukuran klaster yang kecil (saat jumlahnya lebih kecil atau sama dengan jumlah node <code>--large-cluster-size-threshold</code> - <i>default</i>-nya 50), maka <i>eviction</i> akan berhenti dilakukan.
Jika masih besar jumlahnya, <i>rate eviction</i> dikurangi menjadi <code>--secondary-node-eviction-rate</code> (<i>default</i>-nya 0.01) per detik.</p><p>Alasan kenapa hal ini diimplementasi untuk setiap zona <i>availability</i> adalah karena satu zona bisa saja terputus dari master, saat yang lainnya masih terhubung.
Jika klaster tidak menjangkau banyak zona <i>availability</i> yang disediakan oleh penyedia cloud, maka hanya ada satu zona (untuk semua node di dalam klaster).</p><p>Alasan utama untuk menyebarkan node pada banyak zona <i>availability</i> adalah supaya <i>workload</i> dapat dipindahkan ke zona sehat (<i>healthy</i>) saat suatu zona mati secara menyeluruh.
Kemudian, jika semua node di dalam suatu zona menjadi tidak sehat (<i>unhealthy</i>), maka kontroler node melakukan <i>eviction</i> pada <i>rate</i> normal <code>--node-eviction-rate</code>.
Kasus khusus, ketika seluruh zona tidak ada satupun sehat (tidak ada node yang sehat satupun di dalam klaster).
Pada kasus ini, kontroler node berasumsi ada masalah pada jaringan master, dan menghentikan semua <i>eviction</i> sampai jaringan terhubung kembali.</p><p>Mulai dari Kubernetes 1.6, kontroler node juga bertanggung jawab untuk melakukan <i>eviction</i> pada pod-pod yang berjalan di atas node dengan <i>taints</i> <code>NoExecute</code>, ketika pod-pod tersebut sudah tidak lagi <i>tolerate</i> terhadap <i>taints</i>.
Sebagai tambahan, hal ini di-nonaktifkan secara <i>default</i> pada fitur alpha, kontroler node bertanggung jawab untuk menambahkan <i>taints</i> yang berhubungan dengan masalah pada node, seperti terputus atau <code>NotReady</code>.
Lihat <a href=/id/docs/concepts/scheduling-eviction/taint-and-toleration/>dokumentasi ini</a> untuk bahasan detail tentang <i>taints</i> <code>NoExecute</code> dan fitur alpha.</p><p>Mulai dari versi 1.8, kontroler node bisa diatur untuk bertanggung jawab pada pembuatan <i>taints</i> yang merepresentasikan node <i>condition</i>.
Ini merupakan fitur alpha untuk versi 1.8.</p><h3 id=i-self-registration-i-untuk-node><i>Self-Registration</i> untuk Node</h3><p>Ketika argumen <code>--register-node</code> pada kubelet bernilai <i>true</i> (<i>default</i>-nya), kubelet akan berusaha untuk registrasi dirinya melalui API server.
Ini merupakan <i>pattern</i> yang disukai, digunakan oleh kebanyakan <i>distros</i>.</p><p>Kubelet memulai registrasi diri (<i>self-registration</i>) dengan opsi-opsi berikut:</p><ul><li><code>--kubeconfig</code> - <i>Path</i> berisi kredensial-kredensial yang digunakan untuk registrasi diri pada apiserver.</li><li><code>--cloud-provider</code> - Cara berbicara pada sebuah penyedia layanan cloud, baca tentang metadata-nya.</li><li><code>--register-node</code> - Registrasi secara otomatis pada API server.</li><li><code>--register-with-taints</code> - Registrasi node dengan daftar <i>taints</i> (dipisahkan oleh koma <code>&lt;key>=&lt;value>:&lt;effect></code>). No-op jika <code>register-node</code> bernilai <i>false</i>.</li><li><code>--node-ip</code> - Alamat IP dari node dimana kubelet berjalan.</li><li><code>--node-labels</code> - Label-label untuk ditambahkan saat melakukan registrasi untuk node di dalam klaster (lihat label yang dibatasi secara paksa oleh <a href=/docs/reference/access-authn-authz/admission-controllers/#noderestriction>NodeRestriction admission plugin</a> untuk 1.13+).</li><li><code>--node-status-update-frequency</code> - Menentukan seberapa sering kubelet melaporkan status pada master.</li></ul><p>Ketika mode <a href=/docs/reference/access-authn-authz/node/>otorisasi Node</a> dan <a href=/docs/reference/access-authn-authz/admission-controllers/#noderestriction>NodeRestriction admission plugin</a> diaktifkan, semua kubelet hanya punya otoritas untuk membuat/modifikasi <i>resource</i> Node masing-masing.</p><h4 id=administrasi-node-secara-manual>Administrasi Node secara Manual</h4><p>Seorang admin klaster dapat membuat dan memodifikasi obyek node.</p><p>Jika admin ingin untuk membuat obyek node secara manual, atur argument <code>--register-node=false</code> pada kubelet.</p><p>Admin dapat memodifikasi <i>resource-resource</i> node (terlepas dari <code>--register-node</code>).
Modifikasi terdiri dari pengaturan label pada node dan membuat node tidak dapat di-<i>schedule</i>.</p><p>Label-label pada node digunakan oleh <i>selector</i> node untuk mengatur proses <i>schedule</i> untuk pod, misalnya, membatasi sebuah pod hanya boleh dijalankan pada node-node tertentu.</p><p>Menandai sebuah node untuk tidak dapat di-<i>schedule</i> mencegah pod baru untuk tidak di-<i>schedule</i> pada node, tanpa mempengaruhi pod-pod yang sudah berjalan pada node tersebut.
Ini berguna sebagai langkah persiapan untuk melakukan <i>reboote</i> pada node.
Sebagai contoh, untuk menandai sebuah node untuk tidak dapat di-<i>schedule</i>, jalankan perintah berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl cordon <span style=color:#b8860b>$NODENAME</span>
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Pod-pod yang dibuat oleh suatu kontroler DaemonSet menghiraukan <i>scheduler</i> Kubernetes dan mengabaikan tanda <i>unschedulable</i> pada node.
Hal ini mengasumsikan bahwa <i>daemons</i> dimiliki oleh mesin, walaupun telah dilakukan <i>drain</i> pada aplikasi, saat melakukan persaiapan <i>reboot</i>.</div><h3 id=kapasitas-node>Kapasitas Node</h3><p>Kapasitas node (jumlah CPU dan memori) adalah bagian dari obyek node.
Pada umumnya, node-node melakukan registrasi diri dan melaporkan kapasitasnya saat obyek node dibuat.
Jika kamu melakukan <a href=#manual-node-administration>administrasi node manual</a>, maka kamu perlu mengatur kapasitas node saat menambahkan node baru.</p><p><i>Scheduler</i> Kubernetes memastikan kalau ada <i>resource</i> yang cukup untuk menjalankan semua pod di dalam sebuah node.
Kubernetes memeriksa jumlah semua <i>request</i> untuk kontainer pada sebuah node tidak lebih besar daripada kapasitas node.
Hal ini termasuk semua kontainer yang dijalankan oleh kubelet. Namun, ini tidak termasuk kontainer-kontainer yang dijalankan secara langsung oleh <a href=/id/docs/concepts/overview/components/#node-components>runtime kontainer</a> ataupun <i>process</i> yang ada di luar kontainer.</p><p>Kalau kamu ingin secara eksplisit menyimpan <i>resource</i> cadangan untuk menjalankan <i>process-process</i> selain Pod, ikut tutorial <a href=/docs/tasks/administer-cluster/reserve-compute-resources/#system-reserved>menyimpan resource cadangan untuk <i>system daemon</i></a>.</p><h2 id=obyek-api>Obyek API</h2><p>Node adalah tingkatan tertinggi dari <i>resource</i> di dalam Kubernetes REST API.
Penjelasan lebih detail tentang obyek API dapat dilihat pada: <a href=/docs/reference/generated/kubernetes-api/v1.25/#node-v1-core>Obyek Node API</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-c0251def6da29b30afebfb04549f1703>3.2.2 - Komunikasi antara Control Plane dan Node</h1><p>Dokumen ini menjelaskan tentang jalur-jalur komunikasi di antara klaster Kubernetes dan control plane yang sebenarnya hanya berhubungan dengan apiserver saja.
Kenapa ada dokumen ini? Supaya kamu, para pengguna Kubernetes, punya gambaran bagaimana mengatur instalasi untuk memperketat konfigurasi jaringan di dalam klaster.
Hal ini cukup penting, karena klaster bisa saja berjalan pada jaringan tak terpercaya (<i>untrusted network</i>), ataupun melalui alamat-alamat IP publik pada penyedia cloud.</p><h2 id=node-menuju-control-plane>Node Menuju Control Plane</h2><p>Kubernetes memiliki sebuah pola API "hub-and-spoke". Semua penggunaan API dari Node (atau Pod dimana Pod-Pod tersebut dijalankan) akan diterminasi pada apiserver (tidak ada satu komponen <em>control plane</em> apa pun yang didesain untuk diekspos pada servis <em>remote</em>).
Apiserver dikonfigurasi untuk mendengarkan koneksi aman <em>remote</em> yang pada umumnya terdapat pada porta HTTPS (443) dengan satu atau lebih bentuk <a href=/docs/reference/access-authn-authz/authentication/>autentikasi</a> klien yang dipasang.
Sebaiknya, satu atau beberapa metode <a href=/docs/reference/access-authn-authz/authorization/>otorisasi</a> juga dipasang, terutama jika kamu memperbolehkan <a href=/docs/reference/access-authn-authz/authentication/#anonymous-requests>permintaan anonim (<i>anonymous request</i>)</a> ataupun <a href=/docs/reference/access-authn-authz/authentication/#service-account-tokens>service account token</a>.</p><p>Jika diperlukan, Pod-Pod dapat terhubung pada apiserver secara aman dengan menggunakan ServiceAccount.
Dengan ini, Kubernetes memasukkan <em>public root certificate</em> dan <em>bearer token</em> yang valid ke dalam Pod, secara otomatis saat Pod mulai dijalankan.
Kubernetes Service (di dalam semua Namespace) diatur dengan sebuah alamat IP virtual. Semua yang mengakses alamat IP ini akan dialihkan (melalui kube-proxy) menuju <em>endpoint</em> HTTPS dari apiserver.</p><p>Komponen-komponen juga melakukan koneksi pada apiserver klaster melalui porta yang aman.</p><p>Akibatnya, untuk konfigurasi yang umum dan standar, semua koneksi dari klaster (node-node dan pod-pod yang berjalan di atas node tersebut) menujucontrol planesudah terhubung dengan aman.
Dan juga, klaster dancontrol planebisa terhubung melalui jaringan publik dan/atau yang tak terpercaya (<i>untrusted</i>).</p><h2 id=control-plane-menuju-node>Control Plane menuju Node</h2><p>Ada dua jalur komunikasi utama dari <em>control plane</em> (apiserver) menuju klaster. Pertama, dari apiserver ke proses kubelet yang berjalan pada setiap Node di dalam klaster. Kedua, dari apiserver ke setiap Node, Pod, ataupun Service melalui fungsi proksi pada apiserver</p><h3 id=apiserver-menuju-kubelet>Apiserver menuju kubelet</h3><p>Koneksi dari apiserver menuju kubelet bertujuan untuk:</p><ul><li>Melihat log dari pod-pod.</li><li>Masuk ke dalam pod-pod yang sedang berjalan (<i>attach</i>).</li><li>Menyediakan fungsi port-forward dari kubelet.</li></ul><p>Semua koneksi ini diterminasi pada <i>endpoint</i> HTTPS dari kubelet.
Secara <i>default</i>, apiserver tidak melakukan verifikasi <i>serving certificate</i> dari kubelet, yang membuat koneksi terekspos pada serangan <i>man-in-the-middle</i>, dan juga <strong>tidak aman</strong> untuk terhubung melalui jaringan tak terpercaya (<i>untrusted</i>) dan/atau publik.</p><p>Untuk melakukan verifikasi koneksi ini, berikan <i>root certificate</i> pada apiserver melalui tanda <code>--kubelet-certificate-authority</code>, sehingga apiserver dapat memverifikasi <i>serving certificate</i> dari kubelet.</p><p>Cara lainnya, gunakan <a href=/docs/concepts/architecture/master-node-communication/#ssh-tunnels>tunnel SSH</a> antara apiserver dan kubelet jika diperlukan, untuk menghindari komunikasi melalui jaringan tak terpercaya (<i>untrusted</i>) atau publik.</p><p>Terakhir, yang terpenting, aktifkan <a href=/docs/admin/kubelet-authentication-authorization/>autentikasi dan/atau otorisasi Kubelet</a> untuk mengamankan API kubelet.</p><h3 id=apiserver-menuju-node-pod-dan-service>Apiserver menuju Node, Pod, dan Service</h3><p>Secara <i>default</i>, koneksi apiserver menuju node, pod atau service hanyalah melalui HTTP polos (<i>plain</i>), sehingga tidak ada autentikasi maupun enkripsi.
Koneksi tersebut bisa diamankan melalui HTTPS dengan menambahkan <code>https:</code> pada URL API dengan nama dari node, pod, atau service.
Namun, koneksi tidak tervalidasi dengan <i>certificate</i> yang disediakan oleh <i>endpoint</i> HTTPS maupun kredensial <i>client</i>, sehingga walaupun koneksi sudah terenkripsi, tidak ada yang menjamin integritasnya.
Koneksi ini <strong>tidak aman</strong> untuk dilalui pada jaringan publik dan/atau tak terpercaya <i>untrusted</i>.</p><h3 id=tunnel-ssh>Tunnel SSH</h3><p>Kubernetes menyediakan tunnel SSH untuk mengamankan jalur komunikasi control plane -> Klaster.
Dengan ini, apiserver menginisiasi sebuah <i>tunnel</i> SSH untuk setiap node di dalam klaster (terhubung ke server SSH di port 22) dan membuat semua trafik menuju kubelet, node, pod, atau service dilewatkan melalui <i>tunnel</i> tesebut.
<i>Tunnel</i> ini memastikan trafik tidak terekspos keluar jaringan dimana node-node berada.</p><p><i>Tunnel</i> SSH saat ini sudah usang (<i>deprecated</i>), jadi sebaiknya jangan digunakan, kecuali kamu tahu pasti apa yang kamu lakukan.
Sebuah desain baru untuk mengganti kanal komunikasi ini sedang disiapkan.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-ca8819042a505291540e831283da66df>3.2.3 - Controller</h1><p>Dalam bidang robotika dan otomatisasi, <em>control loop</em> atau kontrol tertutup adalah
lingkaran tertutup yang mengatur keadaan suatu sistem.</p><p>Berikut adalah salah satu contoh kontrol tertutup: termostat di sebuah ruangan.</p><p>Ketika kamu mengatur suhunya, itu mengisyaratkan ke termostat
tentang <em>keadaan yang kamu inginkan</em>. Sedangkan suhu kamar yang sebenarnya
adalah <em>keadaan saat ini</em>. Termostat berfungsi untuk membawa keadaan saat ini
mendekati ke keadaan yang diinginkan, dengan menghidupkan atau mematikan
perangkat.</p><p>Di Kubernetes, <em>controller</em> adalah kontrol tertutup yang mengawasi keadaan klaster
<a class=glossary-tooltip title='Sekumpulan mesin pekerja, yang dikenal sebagai Node, yang menjalankan aplikasi dalam Container. Setiap klaster setidaknya mempunyai satu Node pekerja.' data-toggle=tooltip data-placement=top href='/id/docs/reference/glossary/?all=true#term-cluster' target=_blank aria-label=klaster>klaster</a> kamu, lalu membuat atau meminta
perubahan jika diperlukan. Setiap <em>controller</em> mencoba untuk memindahkan status
klaster saat ini mendekati keadaan yang diinginkan.</p>Di Kubernetes, pengontrol adalah kontrol tertutup yang mengawasi kondisi <a class=glossary-tooltip title='Sekumpulan mesin pekerja, yang dikenal sebagai Node, yang menjalankan aplikasi dalam Container. Setiap klaster setidaknya mempunyai satu Node pekerja.' data-toggle=tooltip data-placement=top href='/id/docs/reference/glossary/?all=true#term-cluster' target=_blank aria-label=klaster>klaster</a>, lalu membuat atau meminta perubahan jika diperlukan. Setiap pengontrol mencoba untuk memindahkan status klaster saat ini lebih dekat ke kondisi yang diinginkan.<h2 id=pola-controller>Pola <em>controller</em></h2><p>Sebuah <em>controller</em> melacak sekurang-kurangnya satu jenis sumber daya dari
Kubernetes.
<a href=/id/docs/concepts/overview/working-with-objects/kubernetes-objects/>objek-objek</a> ini
memiliki <em>spec field</em> yang merepresentasikan keadaan yang diinginkan. Satu atau
lebih <em>controller</em> untuk <em>resource</em> tersebut bertanggung jawab untuk membuat
keadaan sekarang mendekati keadaan yang diinginkan.</p><p><em>Controller</em> mungkin saja melakukan tindakan itu sendiri; namun secara umum, di
Kubernetes, <em>controller</em> akan mengirim pesan ke
<a class=glossary-tooltip title='Komponen control plane yang mengekspos API Kubernetes. Merupakan front-end dari control plane Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-apiserver/ target=_blank aria-label='API server'>API server</a> yang
mempunyai efek samping yang bermanfaat. Kamu bisa melihat contoh-contoh
di bawah ini.</p><h3 id=kontrol-melalui-server-api>Kontrol melalui server API</h3><p><em>Controller</em> <a class=glossary-tooltip title='Tugas terbatas atau bertumpuk (batch) yang berjalan sampai selesai.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/job/ target=_blank aria-label=Job>Job</a> adalah contoh dari <em>controller</em>
bawaan dari Kubernetes. <em>Controller</em> bawaan tersebut mengelola status melalui
interaksi dengan server API dari suatu klaster.</p><p>Job adalah sumber daya dalam Kubernetes yang menjalankan a
<a class=glossary-tooltip title='Unit Kubernetes yang paling sederhana dan kecil. Sebuah Pod merepresentasikan sebuah set kontainer yang dijalankan pada kluster kamu.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>, atau mungkin beberapa Pod sekaligus,
untuk melakukan sebuah pekerjaan dan kemudian berhenti.</p><p>(Setelah <a href=../../../../en/docs/concepts/scheduling-eviction/>dijadwalkan</a>, objek Pod
akan menjadi bagian dari keadaan yang diinginkan oleh kubelet).</p><p>Ketika <em>controller job</em> melihat tugas baru, maka <em>controller</em> itu memastikan bahwa,
di suatu tempat pada klaster kamu, kubelet dalam sekumpulan Node menjalankan
Pod-Pod dengan jumlah yang benar untuk menyelesaikan pekerjaan. <em>Controller job</em>
tidak menjalankan sejumlah Pod atau kontainer apa pun untuk dirinya sendiri.
Namun, <em>controller job</em> mengisyaratkan kepada server API untuk membuat atau
menghapus Pod. Komponen-komponen lain dalam
<a class=glossary-tooltip title='Merupakan lapisan orkestrasi Container yang mengekspos API dan antarmuka untuk mendefinisikan, menggelar, dan mengelola siklus hidup suatu Container.' data-toggle=tooltip data-placement=top href='/id/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='control plane'>control plane</a>
bekerja berdasarkan informasi baru (adakah Pod-Pod baru untuk menjadwalkan dan
menjalankan pekerjan), dan pada akhirnya pekerjaan itu selesai.</p><p>Setelah kamu membuat Job baru, status yang diharapkan adalah bagaimana
pekerjaan itu bisa selesai. <em>Controller job</em> membuat status pekerjaan saat ini
agar mendekati dengan keadaan yang kamu inginkan: membuat Pod yang melakukan
pekerjaan yang kamu inginkan untuk Job tersebut, sehingga Job hampir
terselesaikan.</p><p><em>Controller</em> juga memperbarui objek yang mengkonfigurasinya. Misalnya: setelah
pekerjaan dilakukan untuk Job tersebut, <em>controller job</em> memperbarui objek Job
dengan menandainya <code>Finished</code>.</p><p>(Ini hampir sama dengan bagaimana beberapa termostat mematikan lampu untuk
mengindikasikan bahwa kamar kamu sekarang sudah berada pada suhu yang kamu
inginkan).</p><h3 id=kontrol-langsung>Kontrol Langsung</h3><p>Berbeda dengan sebuah Job, beberapa dari <em>controller</em> perlu melakukan perubahan
sesuatu di luar dari klaster kamu.</p><p>Sebagai contoh, jika kamu menggunakan kontrol tertutup untuk memastikan apakah
cukup <a class=glossary-tooltip title='A node is a worker machine in Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/nodes/ target=_blank aria-label=Node>Node</a>
dalam kluster kamu, maka <em>controller</em> memerlukan sesuatu di luar klaster saat ini
untuk mengatur Node-Node baru apabila dibutuhkan.</p><p><em>controller</em> yang berinteraksi dengan keadaan eksternal dapat menemukan keadaan
yang diinginkannya melalui server API, dan kemudian berkomunikasi langsung
dengan sistem eksternal untuk membawa keadaan saat ini mendekat keadaan yang
diinginkan.</p><p>(Sebenarnya ada sebuah <a href=https://github.com/kubernetes/autoscaler/><em>controller</em></a> yang melakukan penskalaan node secara
horizontal dalam klaster kamu.</p><h2 id=sekarang-banding-diinginkan>Status sekarang berbanding status yang diinginkan</h2><p>Kubernetes mengambil pandangan sistem secara <em>cloud-native</em>, dan mampu menangani
perubahan yang konstan.</p><p>Klaster kamu dapat mengalami perubahan kapan saja pada saat pekerjaan sedang
berlangsung dan kontrol tertutup secara otomatis memperbaiki setiap kegagalan.
Hal ini berarti bahwa, secara potensi, klaster kamu tidak akan pernah mencapai
kondisi stabil.</p><p>Selama <em>controller</em> dari klaster kamu berjalan dan mampu membuat perubahan yang
bermanfaat, tidak masalah apabila keadaan keseluruhan stabil atau tidak.</p><h2 id=perancangan>Perancangan</h2><p>Sebagai prinsip dasar perancangan, Kubernetes menggunakan banyak <em>controller</em> yang
masing-masing mengelola aspek tertentu dari keadaan klaster. Yang paling umum,
kontrol tertutup tertentu menggunakan salah satu jenis sumber daya
sebagai suatu keadaan yang diinginkan, dan memiliki jenis sumber daya yang
berbeda untuk dikelola dalam rangka membuat keadaan yang diinginkan terjadi.</p><p>Sangat penting untuk memiliki beberapa <em>controller</em> sederhana daripada hanya satu
<em>controller</em> saja, dimana satu kumpulan monolitik kontrol tertutup saling
berkaitan satu sama lain. Karena <em>controller</em> bisa saja gagal, sehingga Kubernetes
dirancang untuk memungkinkan hal tersebut.</p><p>Misalnya: <em>controller</em> pekerjaan melacak objek pekerjaan (untuk menemukan
adanya pekerjaan baru) dan objek Pod (untuk menjalankan pekerjaan tersebut dan
kemudian melihat lagi ketika pekerjaan itu sudah selesai). Dalam hal ini yang
lain membuat pekerjaan, sedangkan <em>controller</em> pekerjaan membuat Pod-Pod.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong><p>Ada kemungkinan beberapa <em>controller</em> membuat atau memperbarui jenis objek yang
sama. Namun di belakang layar, <em>controller</em> Kubernetes memastikan bahwa mereka
hanya memperhatikan sumbr daya yang terkait dengan sumber daya yang mereka
kendalikan.</p><p>Misalnya, kamu dapat memiliki Deployment dan Job; dimana keduanya akan membuat
Pod. <em>Controller Job</em> tidak akan menghapus Pod yang dibuat oleh Deployment kamu,
karena ada informasi (<a class=glossary-tooltip title='Tags objects with identifying attributes that are meaningful and relevant to users.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/labels target=_blank aria-label=labels>labels</a>)
yang dapat oleh <em>controller</em> untuk membedakan Pod-Pod tersebut.</p></div><h2 id=menjalankan-_controller_>Berbagai cara menjalankan beberapa <em>controller</em></h2><p>Kubernetes hadir dengan seperangkat <em>controller</em> bawaan yang berjalan di dalam
<a class=glossary-tooltip title='Komponen control plane yang menjalankan pengontrol.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-controller-manager/ target=_blank aria-label=kube-controller-manager>kube-controller-manager</a>. Beberapa <em>controller</em>
bawaan memberikan perilaku inti yang sangat penting.</p><p><em>Controller Deployment</em> dan <em>controller Job</em> adalah contoh dari <em>controller</em> yang
hadir sebagai bagian dari Kubernetes itu sendiri (<em>controller</em> "bawaan").
Kubernetes memungkinkan kamu menjalankan <em>control plane</em> yang tangguh, sehingga
jika ada <em>controller</em> bawaan yang gagal, maka bagian lain dari <em>control plane</em> akan
mengambil alih pekerjaan.</p><p>Kamu juga dapat menemukan pengontrol yang berjalan di luar <em>control plane</em>, untuk
mengembangkan lebih jauh Kubernetes. Atau, jika mau, kamu bisa membuat
<em>controller</em> baru sendiri. Kamu dapat menjalankan <em>controller</em> kamu sendiri sebagai
satu kumpulan dari beberapa Pod, atau bisa juga sebagai bagian eksternal dari
Kubernetes. Manakah yang paling sesuai akan tergantung pada apa yang <em>controller</em>
khusus itu lakukan.</p><h2 id=selanjutnya>Selanjutnya</h2><ul><li>Silahkan baca tentang <a href=/docs/concepts/#kubernetes-control-plane><em>control plane</em> Kubernetes</a></li><li>Temukan beberapa dasar tentang <a href=/docs/concepts/#kubernetes-objects>objek-objek Kubernetes</a></li><li>Pelajari lebih lanjut tentang <a href=/id/docs/concepts/overview/kubernetes-api/>Kubernetes API</a></li><li>Apabila kamu ingin membuat <em>controller</em> sendiri, silakan lihat <a href=/id/docs/concepts/extend-kubernetes/extend-cluster/#extension-patterns>pola perluasan</a> dalam memperluas Kubernetes.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-bc804b02614d67025b4c788f1ca87fbc>3.2.4 - Konsep-konsep di balik Controller Manager</h1><p>Konsep <em>Cloud Controller Manager</em>/CCM (jangan tertukar dengan program biner kube-controller-manager) awalnya dibuat untuk memungkinkan kode vendor <em>cloud</em> spesifik dan kode inti Kubernetes untuk berkembang secara independen satu sama lainnya. CCM berjalan bersama dengan komponen Master lainnya seperti Kubernetes Controller Manager, API Server, dan Scheduler. CCM juga dapat dijalankan sebagai Kubernetes Addon (tambahan fungsi terhadap Kubernetes), yang akan berjalan di atas klaster Kubernetes.</p><p>Desain CCM didasarkan pada mekanisme <em>plugin</em> yang memungkinkan penyedia layanan <em>cloud</em> untuk berintegrasi dengan Kubernetes dengan mudah dengan menggunakan <em>plugin</em>. Sudah ada rencana untuk pengenalan penyedia layanan <em>cloud</em> baru pada Kubernetes, dan memindahkan penyedia layanan <em>cloud</em> yang sudah ada dari model yang lama ke model CCM.</p><p>Dokumen ini mendiskusikan konsep di balik CCM dan mendetail fungsi-fungsinya.</p><p>Berikut adalah arsitektur sebuah klaster Kubernetes tanpa CCM:</p><p><img src=/images/docs/pre-ccm-arch.png alt="Pre CCM Kube Arch"></p><h2 id=desain>Desain</h2><p>Pada diagram sebelumnya, Kubernetes dan penyedia layanan <em>cloud</em> diintegrasikan melalui beberapa komponen berbeda:</p><ul><li>Kubelet</li><li>Kubernetes Controller Manager</li><li>Kubernetes API server</li></ul><p>CCM menggabungkan semua logika yang bergantung pada <em>cloud</em> dari dalam tiga komponen tersebut ke dalam sebuah titik integrasi dengan <em>cloud</em>. Arsitektur baru di dalam model CCM adalah sebagai berikut:</p><p><img src=/images/docs/post-ccm-arch.png alt="CCM Kube Arch"></p><h2 id=komponen-komponen-ccm>Komponen-komponen CCM</h2><p>CCM memisahkan beberapa fungsi Kubernetes Controller Manager (KCM) dan menjalankannya sebagai proses yang berbeda. Secara spesifik, CCM memisahkan pengendali-pengendali (<em>controller</em>) di dalam KCM yang bergantung terhadap penyedia layanan <em>cloud</em>. KCM memiliki beberapa komponen pengendali yang bergantung pada <em>cloud</em> sebagai berikut:</p><ul><li>Node Controller</li><li>Volume Controller</li><li>Route Controller</li><li>Service Controller</li></ul><p>Pada versi 1.9, CCM menjalankan pengendali-pengendali dari daftar sebelumnya sebagai berikut:</p><ul><li>Node Controller</li><li>Route Controller</li><li>Service Controller</li></ul><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Volume Controller secara sengaja tidak dipilih sebagai bagian dari CCM. Hal ini adalah karena kerumitan untuk melakukannya, dan mempertimbangkan usaha-usaha yang sedang berlangsung untuk memisahkan logika volume yang spesifik vendor dari KCM, sehingga diputuskan bahwa Volume Contoller tidak akan dipisahkan dari KCM ke CCM.</div><p>Rencana awal untuk mendukung volume menggunakan CCM adalah dengan menggunakan FlexVolume untuk mendukung penambahan volume secara <em>pluggable</em>. Namun, ada sebuah usaha lain yang diberi nama Container Storage Interface (CSI) yang sedang berlangsung untuk menggantikan FlexVolume.</p><p>Mempertimbangkan dinamika tersebut, kami memutuskan untuk mengambil tindakan sementara hingga CSI siap digunakan.</p><h2 id=fungsi-fungsi-ccm>Fungsi-fungsi CCM</h2><p>Fungsi-fungsi CCM diwarisi oleh komponen-komponen Kubernetes yang bergantung pada penyedia layanan <em>cloud</em>. Bagian ini disusun berdasarkan komponen-komponen tersebut.</p><h3 id=1-kubernetes-controller-manager>1. Kubernetes Controller Manager</h3><p>Kebanyakan fungsi CCM diturunkan dari KCM. Seperti yang telah disebutkan pada bagian sebelumnya, CCM menjalankan komponen-komponen pengendali sebagai berikut:</p><ul><li>Node Controller</li><li>Route Controller</li><li>Service Controller</li></ul><h4 id=node-controller>Node Controller</h4><p>Node Controller bertugas untuk menyiapkan sebuah node dengan cara mengambil informasi node-node yang berjalan di dalam klaster dari penyedia layanan <em>cloud</em>. Node Controller melakukan fungsi-fungsi berikut:</p><ol><li>Menyiapkan sebuah node dengan memberi label <em>zone</em>/<em>region</em> yang spesifik pada <em>cloud</em>.</li><li>Menyiapkan sebuah node dengan informasi <em>instance</em> yang spesifik <em>cloud</em> , misalnya tipe dan ukurannya.</li><li>Mendapatkan alamat jaringan dan <em>hostname</em> milik node tersebut.</li><li>Dalam hal sebuah node menjadi tidak responsif, memeriksa <em>cloud</em> untuk melihat apakah node tersebut telah dihapus dari <em>cloud</em>. Juga, menghapus objek Node tersebut dari klaster Kubernetes, jika node tersebut telah dihapus dari <em>cloud</em>.</li></ol><h4 id=route-controller>Route Controller</h4><p>Route Controller bertugas mengkonfigurasi rute jaringan di dalam <em>cloud</em> secara sesuai agar Container pada node-node yang berbeda di dalam klaster Kubernetes dapat berkomunikasi satu sama lain. Route Controller hanya berlaku untuk klaster yang berjalan pada Google Compute Engine (GCE) di penyedia layanan <em>cloud</em> GCP.</p><h4 id=service-controller>Service Controller</h4><p>Service Controller bertugas memantau terjadinya operasi <code>create</code>, <code>update</code>, dan <code>delete</code> pada Service. Berdasarkan keadaan terkini Service-service pada klaster Kubernetes, Service Controller mengkonfigurasi <em>load balancer</em> spesifik <em>cloud</em> (seperti ELB, Google LB, atau Oracle Cloud Infrastructure LB) agar sesuai dengan keadaan Service-service pada klaster Kubernetes. Sebagai tambahan, Service Controller juga memastikan bahwa <em>service backend</em> (target dari <em>load balancer</em> yang bersangkutan) dari <em>load balancer cloud</em> tersebut berada dalam kondisi terkini.</p><h3 id=2-kubelet>2. Kubelet</h3><p>Node Controller berisi fungsi Kubelet yang bergantung pada <em>cloud</em>. Sebelum CCM, Kubelet bertugas untuk menyiapkan node dengan informasi spesifik <em>cloud</em> seperti alamat IP, label <em>zone</em>/<em>region</em>, dan tipe <em>instance</em>. Setelah diperkenalkannya CCM, tugas tersebut telah dipindahkan dari Kubelet ke dalam CCM.</p><p>Pada model baru ini, Kubelet menyiapkan sebuah node tanpa informasi spesifik <em>cloud</em>. Namun, Kubelet menambahkan sebuah Taint pada node yang baru dibuat yang menjadikan node tersebut tidak dapat dijadwalkan (sehingga tidak ada Pod yang dapat dijadwalkan ke node tersebut) hingga CCM menyiapkan node tersebut dengan informasi spesifik <em>cloud</em>. Setelah itu, Kubelet menghapus Taint tersebut.</p><h2 id=mekanisme-plugin>Mekanisme <em>Plugin</em></h2><p>CCM menggunakan <em>interface</em> Go untuk memungkinkan implementasi dari <em>cloud</em> apapun untuk ditambahkan. Secara spesifik, CCM menggunakan CloudProvider Interface yang didefinisikan <a href=https://github.com/kubernetes/cloud-provider/blob/9b77dc1c384685cb732b3025ed5689dd597a5971/cloud.go#L42-L62>di sini</a></p><p>Implementasi dari empat kontroler-kontroler yang disorot di atas, dan beberapa kerangka kerja, bersama dengan CloudProvider Interface, akan tetap berada pada kode inti Kubernetes. Implementasi spesifik penyedia layanan <em>cloud</em> akan dibuat di luar kode inti dan menggunakan CloudProvider Interface yang didefinisikan di kode inti.</p><p>Untuk informasi lebih lanjut mengenai pengembangan <em>plugin</em>, lihat <a href=/docs/tasks/administer-cluster/developing-cloud-controller-manager/>Mengembangkan Cloud Controller Manager</a>.</p><h2 id=otorisasi>Otorisasi</h2><p>Bagian ini memerinci akses yang dibutuhkan oleh CCM terhadap berbagai objek API untuk melakukan tugas-tugasnya.</p><h3 id=akses-untuk-node-controller>Akses untuk Node Controller</h3><p>Node Controller hanya berinteraksi dengan objek-objek Node. Node Controller membutuhkan akses penuh untuk operasi <code>get</code>, <code>list</code>, <code>create</code>, <code>update</code>, <code>patch</code>, <code>watch</code>, dan <code>delete</code> terhadap objek-objek Node.</p><p>v1/Node:</p><ul><li>Get</li><li>List</li><li>Create</li><li>Update</li><li>Patch</li><li>Watch</li><li>Delete</li></ul><h3 id=akses-untuk-route-controller>Akses untuk Route Controller</h3><p>Route Controller memantau pembuatan objek Node dan mengkonfigurasi rute jaringan secara sesuai. Route Controller membutuhkan akses untuk operasi <code>get</code> terhadap objek-objek Node.</p><p>v1/Node:</p><ul><li>Get</li></ul><h3 id=akses-untuk-service-controller>Akses untuk Service Controller</h3><p>Service Controller memantau terjadinya operasi <code>create</code>, <code>update</code> dan <code>delete</code>, kemudian mengkonfigurasi Endpoint untuk Service-service tersebut secara sesuai.</p><p>Untuk mengakses Service-service, Service Controller membutuhkan akses untuk operasi <em>list</em> dan <em>watch</em>. Untuk memperbarui Service-service, dibutuhkan akses untuk operasi <code>patch</code> dan <code>update</code>.</p><p>Untuk menyiapkan Endpoint bagi untuk Service-service, dibutuhkan akses untuk operasi <code>create</code>, <code>list</code>, <code>get</code>, <code>watch</code>, dan <code>update</code>.</p><p>v1/Service:</p><ul><li>List</li><li>Get</li><li>Watch</li><li>Patch</li><li>Update</li></ul><h3 id=akses-lainnya>Akses Lainnya</h3><p>Implementasi dari inti CCM membutuhkan akses untuk membuat Event, dan untuk memastikan operasi yang aman, dibutuhkan akses untuk membuat ServiceAccount.</p><p>v1/Event:</p><ul><li>Create</li><li>Patch</li><li>Update</li></ul><p>v1/ServiceAccount:</p><ul><li>Create</li></ul><p>Detail RBAC dari ClusterRole untuk CCM adalah sebagai berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cloud-controller-manager<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- events<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- create<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- patch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- nodes<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#39;*&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- nodes/status<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- patch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- services<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- list<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- patch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- watch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- serviceaccounts<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- create<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- persistentvolumes<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- get<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- list<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- watch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- endpoints<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- create<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- get<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- list<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- watch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=implementasi-vendor-vendor>Implementasi Vendor-vendor</h2><p>Penyedia layanan cloud berikut telah mengimplementasikan CCM:</p><ul><li><a href=https://github.com/digitalocean/digitalocean-cloud-controller-manager>Digital Ocean</a></li><li><a href=https://github.com/oracle/oci-cloud-controller-manager>Oracle</a></li><li><a href=https://github.com/kubernetes/cloud-provider-azure>Azure</a></li><li><a href=https://github.com/kubernetes/cloud-provider-gcp>GCP</a></li><li><a href=https://github.com/kubernetes/cloud-provider-aws>AWS</a></li><li><a href=https://github.com/baidu/cloud-provider-baiducloud>BaiduCloud</a></li><li><a href=https://github.com/linode/linode-cloud-controller-manager>Linode</a></li></ul><h2 id=administrasi-klaster>Administrasi Klaster</h2><p>Petunjuk lengkap untuk mengkonfigurasi dan menjalankan CCM disediakan <a href=/docs/tasks/administer-cluster/running-cloud-controller/#cloud-controller-manager>di sini</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-a5f7383c83ab9eb9cd0e3c4c020b3ae6>3.3 - Kontainer</h1></div><div class=td-content><h1 id=pg-8fda96dc403731ceba5e0ddd0ab3ad15>3.3.1 - Ikhtisar Kontainer</h1><p>Kontainer adalah teknologi untuk mengemas kode (yang telah dikompilasi) menjadi
suatu aplikasi beserta dengan dependensi-dependensi yang dibutuhkannya pada saat
dijalankan. Setiap kontainer yang Anda jalankan dapat diulang; standardisasi
dengan menyertakan dependensinya berarti Anda akan mendapatkan perilaku yang
sama di mana pun Anda menjalankannya.</p><p>Kontainer memisahkan aplikasi dari infrastruktur host yang ada dibawahnya. Hal
ini membuat penyebaran lebih mudah di lingkungan cloud atau OS yang berbeda.</p><h2 id=image-image-kontainer>Image-Image Kontainer</h2><p><a href=/id/docs/concepts/containers/images/>Kontainer image</a> meruapakan paket perangkat lunak
yang siap dijalankan, mengandung semua yang diperlukan untuk menjalankan
sebuah aplikasi: kode dan setiap <em>runtime</em> yang dibutuhkan, <em>library</em> dari
aplikasi dan sistem, dan nilai <em>default</em> untuk penganturan yang penting.</p><p>Secara desain, kontainer tidak bisa berubah: Anda tidak dapat mengubah kode
dalam kontainer yang sedang berjalan. Jika Anda memiliki aplikasi yang
terkontainerisasi dan ingin melakukan perubahan, maka Anda perlu membuat
kontainer baru dengan menyertakan perubahannya, kemudian membuat ulang kontainer
dengan memulai dari <em>image</em> yang sudah diubah.</p><h2 id=kontainer-runtime>Kontainer <em>runtime</em></h2><p>Kontainer <em>runtime</em> adalah perangkat lunak yang bertanggung jawab untuk
menjalankan kontainer. Kubernetes mendukung beberapa kontainer <em>runtime</em>:
<a class=glossary-tooltip title='Docker merupakan suatu teknologi perangkat lunak yang menyediakan virtualisasi pada level sistem operasi yang juga dikenal sebagai Container.' data-toggle=tooltip data-placement=top href=https://docs.docker.com/engine/ target=_blank aria-label=Docker>Docker</a>,
<a class=glossary-tooltip title='A container runtime with an emphasis on simplicity, robustness and portability' data-toggle=tooltip data-placement=top href=https://containerd.io/docs/ target=_blank aria-label=containerd>containerd</a>,
<a class=glossary-tooltip title='A lightweight container runtime specifically for Kubernetes' data-toggle=tooltip data-placement=top href=https://cri-o.io/#what-is-cri-o target=_blank aria-label=CRI-O>CRI-O</a>, dan semua implementasi dari
<a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-node/container-runtime-interface.md>Kubernetes CRI (Container Runtime Interface)</a>.</p><h2 id=selanjutnya>Selanjutnya</h2><ul><li>Baca tentang <a href=https://kubernetes.io/docs/concepts/containers/images/>image-image kontainer</a></li><li>Baca tentang <a href=https://kubernetes.io/docs/concepts/workloads/pods/>Pod</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-16042b4652ad19e565c7263824029a43>3.3.2 - Image</h1><p>Kamu membuat Docker <em>image</em> dan mengunduhnya ke sebuah registri sebelum digunakan di dalam Kubernetes Pod.</p><p>Properti <code>image</code> dari sebuah Container mendukung sintaksis yang sama seperti perintah <code>docker</code>, termasuk registri privat dan <em>tag</em>.</p><h2 id=memperbarui-image>Memperbarui Image</h2><p>Kebijakan <em>pull default</em> adalah <code>IfNotPresent</code> yang membuat Kubelet tidak
lagi mengunduh (<em>pull</em>) sebuah image jika sudah ada terlebih dahulu. Jika kamu ingin agar
selalu diunduh, kamu bisa melakukan salah satu dari berikut:</p><ul><li>mengatur <code>imagePullPolicy</code> dari Container menjadi <code>Always</code>.</li><li>buang <code>imagePullPolicy</code> dan gunakan <code>:latest</code> <em>tag</em> untuk <em>image</em> yang digunakan.</li><li>buang <code>imagePullPolicy</code> dan juga <em>tag</em> untuk <em>image</em>.</li><li>aktifkan <a href=/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages>AlwaysPullImages</a> <em>admission controller</em>.</li></ul><p>Harap diingat kamu sebaiknya hindari penggunaan <em>tag</em> <code>:latest</code>, lihat <a href=/id/docs/concepts/configuration/overview/#container-images>panduan konfigurasi</a> untuk informasi lebih lanjut.</p><h2 id=membuat-image-multi-arsitektur-dengan-manifest>Membuat Image Multi-arsitektur dengan Manifest</h2><p>Docker CLI saat ini mendukung perintah <code>docker manifest</code> dengan anak perintah <code>create</code>, <code>annotate</code>, dan <code>push</code>. Perintah-perintah ini dapat digunakan
untuk membuat (<em>build</em>) dan mengunggah (<em>push</em>) manifes. Kamu dapat menggunakan perintah <code>docker manifest inspect</code> untuk membaca manifes.</p><p>Lihat dokumentasi docker di sini:
<a href=https://docs.docker.com/edge/engine/reference/commandline/manifest/>https://docs.docker.com/edge/engine/reference/commandline/manifest/</a></p><p>Lihat contoh-contoh bagaimana kami menggunakan ini untuk proses <em>build harness</em>:
<a href="https://cs.k8s.io/?q=docker%20manifest%20(create%7Cpush%7Cannotate)&i=nope&files=&repos=">https://cs.k8s.io/?q=docker%20manifest%20(create%7Cpush%7Cannotate)&i=nope&files=&repos=</a></p><p>Perintah-perintah ini bergantung pada Docker CLI, dan diimplementasi hanya di sisi CLI. Kamu harus mengubah <code>$HOME/.docker/config.json</code> dan mengatur <em>key</em> <code>experimental</code> untuk mengaktifkan
atau cukup dengan mengatur <code>DOCKER_CLI_EXPERIMENTAL</code> variabel <em>environment</em> menjadi <code>enabled</code> ketika memanggil perintah-perintah CLI.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Gunakan Docker <em>18.06 ke atas</em>, versi-versi di bawahnya memiliki <em>bug</em> ataupun tidak mendukung perintah eksperimental. Contohnya <a href=https://github.com/docker/cli/issues/1135>https://github.com/docker/cli/issues/1135</a> yang menyebabkan masalah di bawah containerd.</div><p>Kalau kamu terkena masalah ketika mengunggah manifes-manifes yang rusak, cukup bersihkan manifes-manifes yang lama di <code>$HOME/.docker/manifests</code> untuk memulai dari awal.</p><p>Untuk Kubernetes, kami biasanya menggunakan <em>image-image</em> dengan sufiks <code>-$(ARCH)</code>. Untuk kompatibilitas (<em>backward compatibility</em>), lakukan <em>generate image-image</em> yang lama dengan sufiks. Idenya adalah men-<em>generate</em>, misalnya <code>pause</code> image yang memiliki manifes untuk semua arsitektur dan misalnya <code>pause-amd64</code> yang punya kompatibilitas terhadap konfigurasi-konfigurasi lama atau berkas-berkas YAML yang bisa saja punya <em>image-image</em> bersufiks yang di-<em>hardcode</em>.</p><h2 id=menggunakan-registri-privat>Menggunakan Registri Privat (<em>Private Registry</em>)</h2><p>Biasanya kita memerlukan <em>key</em> untuk membaca <em>image-image</em> yang tersedia pada suatu registri privat.
Kredensial ini dapat disediakan melalui beberapa cara:</p><ul><li>Menggunakan Google Container Registry<ul><li>per-klaster</li><li>konfigurasi secara otomatis pada Google Compute Engine atau Google Kubernetes Engine</li><li>semua Pod dapat membaca registri privat yang ada di dalam proyek</li></ul></li><li>Menggunakan Amazon Elastic Container Registry (ECR)<ul><li>menggunakan IAM <em>role</em> dan <em>policy</em> untuk mengontrol akses ke repositori ECR</li><li>secara otomatis <em>refresh</em> kredensial login ECR</li></ul></li><li>Menggunakan Oracle Cloud Infrastructure Registry (OCIR)<ul><li>menggunakan IAM <em>role</em> dan <em>policy</em> untuk mengontrol akses ke repositori OCIR</li></ul></li><li>Menggunakan Azure Container Registry (ACR)</li><li>Menggunakan IBM Cloud Container Registry<ul><li>menggunakan IAM <em>role</em> dan <em>policy</em> untuk memberikan akses ke IBM Cloud Container Registry</li></ul></li><li>Konfigurasi Node untuk otentikasi registri privat<ul><li>semua Pod dapat membaca registri privat manapun</li><li>memerlukan konfigurasi Node oleh admin klaster</li></ul></li><li>Pra-unduh <em>image</em><ul><li>semua Pod dapat menggunakan <em>image</em> apapun yang di-<em>cached</em> di dalam sebuah Node</li><li>memerlukan akses root ke dalam semua Node untuk pengaturannya</li></ul></li><li>Mengatur ImagePullSecrets dalam sebuah Pod<ul><li>hanya Pod-Pod yang menyediakan <em>key</em> sendiri yang dapat mengakses registri privat</li></ul></li></ul><p>Masing-masing opsi dijelaskan lebih lanjut di bawah ini.</p><h3 id=menggunakan-google-container-registry>Menggunakan Google Container Registry</h3><p>Kubernetes memiliki dukungan <em>native</em> untuk <a href=https://cloud.google.com/tools/container-registry/>Google Container
Registry (GCR)</a>, ketika dijalankan pada
Google Compute Engine (GCE). Jika kamu menjalankan klaster pada GCE atau Google Kubernetes Engine,
cukup gunakan nama panjang <em>image</em> (misalnya gcr.io/my_project/image:tag).</p><p>Semua Pod di dalam klaster akan memiliki akses baca <em>image</em> di registri ini.</p><p>Kubelet akan melakukan otentikasi GCR menggunakan <em>service account</em> yang dimiliki
<em>instance</em> Google. <em>Service acccount</em> pada <em>instance</em> akan memiliki sebuah <code>https://www.googleapis.com/auth/devstorage.read_only</code>,
sehingga dapat mengunduh dari GCR di proyek yang sama, tapi tidak untuk unggah.</p><h3 id=menggunakan-amazon-elastic-container-registry>Menggunakan Amazon Elastic Container Registry</h3><p>Kubernetes memiliki dukungan <em>native</em> untuk <a href=https://aws.amazon.com/ecr/>Amazon Elastic Container Registry</a>, ketika Node adalah
AWS EC2 <em>instance</em>.</p><p>Cukup gunakan nama panjang <em>image</em> (misalnya <code>ACCOUNT.dkr.ecr.REGION.amazonaws.com/imagename:tag</code>) di dalam definisi Pod.</p><p>Semua pengguna klaster yang dapat membuat Pod akan bisa menjalankan Pod yang dapat menggunakan
<em>image-image</em> di dalam registri ECR.</p><p>Kubelet akan mengambil dan secara periodik memperbarui kredensial ECR, yang memerlukan <em>permission</em> sebagai berikut:</p><ul><li><code>ecr:GetAuthorizationToken</code></li><li><code>ecr:BatchCheckLayerAvailability</code></li><li><code>ecr:GetDownloadUrlForLayer</code></li><li><code>ecr:GetRepositoryPolicy</code></li><li><code>ecr:DescribeRepositories</code></li><li><code>ecr:ListImages</code></li><li><code>ecr:BatchGetImage</code></li></ul><p>Persyaratan:</p><ul><li>Kamu harus menggunakan versi kubelet <code>v1.2.0</code> atau lebih (misal jalankan <code>/usr/bin/kubelet --version=true</code>).</li><li>Jika Node yang kamu miliki ada di region A dan registri kamu ada di region yang berbeda misalnya B, kamu perlu versi <code>v1.3.0</code> atau lebih.</li><li>ECR harus tersedia di region kamu.</li></ul><p>Cara <em>troubleshoot</em>:</p><ul><li>Verifikasi semua persyaratan di atas.</li><li>Dapatkan kredensial $REGION (misalnya <code>us-west-2</code>) pada <em>workstation</em> kamu. Lakukan SSH ke dalam <em>host</em> dan jalankan Docker secara manual menggunakan kredensial tersebut. Apakah berhasil?</li><li>Tambahkan verbositas level <em>log</em> kubelet paling tidak 3 dan periksa <em>log</em> kubelet (misal <code>journalctl -u kubelet</code>) di baris-baris yang seperti ini:<ul><li><code>aws_credentials.go:109] unable to get ECR credentials from cache, checking ECR API</code></li><li><code>aws_credentials.go:116] Got ECR credentials from ECR API for &lt;AWS account ID for ECR>.dkr.ecr.&lt;AWS region>.amazonaws.com</code></li></ul></li></ul><h3 id=menggunakan-azure-container-registry-acr>Menggunakan Azure Container Registry (ACR)</h3><p>Ketika menggunakan <a href=https://azure.microsoft.com/en-us/services/container-registry/>Azure Container Registry</a>
kamu dapat melakukan otentikasi menggunakan pengguna admin maupun sebuah <em>service principal</em>.
Untuk keduanya, otentikasi dilakukan melalui proses otentikasi Docker standar. Instruksi-instruksi ini
menggunakan perangkat <a href=https://github.com/azure/azure-cli>azure-cli</a>.</p><p>Kamu pertama perlu membuat sebuah registri dan men-<em>generate</em> kredensial, dokumentasi yang lengkap tentang hal ini
dapat dilihat pada <a href=https://docs.microsoft.com/en-us/azure/container-registry/container-registry-get-started-azure-cli>dokumentasi Azure container registry</a>.</p><p>Setelah kamu membuat registri, kamu akan menggunakan kredensial berikut untuk login:</p><ul><li><code>DOCKER_USER</code> : <em>service principal</em>, atau pengguna admin</li><li><code>DOCKER_PASSWORD</code>: kata sandi dari <em>service principal</em>, atau kata sandi dari pengguna admin</li><li><code>DOCKER_REGISTRY_SERVER</code>: <code>${some-registry-name}.azurecr.io</code></li><li><code>DOCKER_EMAIL</code>: <code>${some-email-address}</code></li></ul><p>Ketika kamu sudah memiliki variabel-variabel di atas, kamu dapat
<a href=/id/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod>mengkonfigurasi sebuah Kubernetes Secret dan menggunakannya untuk <em>deploy</em> sebuah Pod</a>.</p><h3 id=menggunakan-ibm-cloud-container-registry>Menggunakan IBM Cloud Container Registry</h3><p>IBM Cloud Container Registry menyediakan sebuah registri <em>image</em> privat yang <em>multi-tenant</em>, dapat kamu gunakan untuk menyimpan dan membagikan <em>image-image</em> secara aman. Secara <em>default</em>, <em>image-image</em> di dalam registri privat kamu akan dipindai (<em>scan</em>) oleh Vulnerability Advisor terintegrasi untuk deteksi isu
keamanan dan kerentanan (<em>vulnerability</em>) yang berpotensi. Para pengguna di dalam akun IBM Cloud kamu dapat mengakses <em>image</em>, atau kamu dapat menggunakan IAM
<em>role</em> dan <em>policy</em> untuk memberikan akses ke <em>namespace</em> di IBM Cloud Container Registry.</p><p>Untuk instalasi <em>plugin</em> CLI di IBM Cloud Containerr Registry dan membuat sebuah <em>namespace</em> untuk <em>image-image</em> kamu, lihat <a href="https://cloud.ibm.com/docs/Registry?topic=registry-getting-started">Mulai dengan IBM Cloud Container Registry</a>.</p><p>Jika kamu menggunakan akun dan wilayah (<em>region</em>) yang sama, kamu dapat melakukan <em>deploy image-image</em> yang disimpan di dalam IBM Cloud Container Registry
ke dalam <em>namespace default</em> dari klaster IBM Cloud Kubernetes Service yang kamu miliki tanpa konfigurasi tambahan, lihat <a href="https://cloud.ibm.com/docs/containers?topic=containers-images">Membuat kontainer dari <em>image</em></a>. Untuk opsi konfigurasi lainnya, lihat <a href="https://cloud.ibm.com/docs/containers?topic=containers-registry#cluster_registry_auth">Bagaimana cara mengotorasi klaster untuk mengunduh <em>image</em> dari sebuah registri</a>.</p><h3 id=konfigurasi-node-untuk-otentikasi-ke-sebuah-registri-privat>Konfigurasi Node untuk Otentikasi ke sebuah Registri Privat</h3><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Jika kamu jalan di Google Kubernetes Engine, akan ada <code>.dockercfg</code> pada setiap Node dengan kredensial untuk Google Container Registry. Kamu tidak bisa menggunakan cara ini.</div><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Jika kamu jalan di AWS EC2 dan menggunakan EC2 Container Registry (ECR), kubelet pada setiap Node akan dapat
mengatur dan memperbarui kredensial login ECR. Kamu tidak bisa menggunakan cara ini.</div><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Cara ini cocok jika kamu dapat mengontrol konfigurasi Node. Cara ini tidak akan bekerja dengan baik pada GCE,
dan penyedia layanan cloud lainnya yang tidak melakukan penggantian Node secara otomatis.</div><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Kubernetes pada saat ini hanya mendukung bagian <code>auths</code> dan <code>HttpHeaders</code> dari konfigurasi docker. Hal ini berarti bantuan kredensial (<code>credHelpers</code> atau <code>credsStore</code>) tidak didukung.</div><p>Docker menyimpan <em>key</em> untuk registri privat pada <code>$HOME/.dockercfg</code> atau berkas <code>$HOME/.docker/config.json</code>. Jika kamu menempatkan berkas yang sama
pada daftar jalur pencarian (<em>search path</em>) berikut, kubelet menggunakannya sebagai penyedia kredensial saat mengunduh <em>image</em>.</p><ul><li><code>{--root-dir:-/var/lib/kubelet}/config.json</code></li><li><code>{cwd of kubelet}/config.json</code></li><li><code>${HOME}/.docker/config.json</code></li><li><code>/.docker/config.json</code></li><li><code>{--root-dir:-/var/lib/kubelet}/.dockercfg</code></li><li><code>{cwd of kubelet}/.dockercfg</code></li><li><code>${HOME}/.dockercfg</code></li><li><code>/.dockercfg</code></li></ul><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Kamu mungkin harus mengatur <code>HOME=/root</code> secara eksplisit pada berkas <em>environment</em> kamu untuk kubelet.</div><p>Berikut langkah-langkah yang direkomendasikan untuk mengkonfigurasi Node kamu supaya bisa menggunakan registri privat.
Pada contoh ini, coba jalankan pada <em>desktop/laptop</em> kamu:</p><ol><li>Jalankan <code>docker login [server]</code> untuk setiap set kredensial yang ingin kamu gunakan. Ini akan memperbarui <code>$HOME/.docker/config.json</code>.</li><li>Lihat <code>$HOME/.docker/config.json</code> menggunakan <em>editor</em> untuk memastikan sudah berisi kredensial yang ingin kamu gunakan.</li><li>Dapatkan daftar Node, contohnya:<ul><li>jika kamu ingin mendapatkan nama: <code>nodes=$(kubectl get nodes -o jsonpath='{range.items[*].metadata}{.name} {end}')</code></li><li>jika kamu ingin mendapatkan IP: <code>nodes=$(kubectl get nodes -o jsonpath='{range .items[*].status.addresses[?(@.type=="ExternalIP")]}{.address} {end}')</code></li></ul></li><li>Salin <code>.docker/config.json</code> yang ada di lokal kamu pada salah satu jalur pencarian di atas.<ul><li>contohnya: <code>for n in $nodes; do scp ~/.docker/config.json root@$n:/var/lib/kubelet/config.json; done</code></li></ul></li></ol><p>Verifikasi dengana membuat sebuah Pod yanag menggunakan <em>image</em> privat, contohnya:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f - <span style=color:#b44>&lt;&lt;EOF
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: Pod
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: private-image-test-1
</span></span></span><span style=display:flex><span><span style=color:#b44>spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>  containers:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - name: uses-private-image
</span></span></span><span style=display:flex><span><span style=color:#b44>      image: $PRIVATE_IMAGE_NAME
</span></span></span><span style=display:flex><span><span style=color:#b44>      imagePullPolicy: Always
</span></span></span><span style=display:flex><span><span style=color:#b44>      command: [ &#34;echo&#34;, &#34;SUCCESS&#34; ]
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><pre tabindex=0><code>pod/private-image-test-1 created
</code></pre><p>Jika semuanya berjalan dengan baik, maka setelah beberapa lama, kamu dapat menjalankan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl logs private-image-test-1
</span></span></code></pre></div><p>dan lihat pada keluaran perintah:</p><pre tabindex=0><code>SUCCESS
</code></pre><p>Jika kamu mencurigai ada perintah yang gagal, kamu dapat menjalankan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe pods/private-image-test-1 | grep <span style=color:#b44>&#39;Failed&#39;</span>
</span></span></code></pre></div><p>Pada kasus gagal, keluarannya mirip seperti:</p><pre tabindex=0><code>  Fri, 26 Jun 2015 15:36:13 -0700    Fri, 26 Jun 2015 15:39:13 -0700    19    {kubelet node-i2hq}    spec.containers{uses-private-image}    failed        Failed to pull image &#34;user/privaterepo:v1&#34;: Error: image user/privaterepo:v1 not found
</code></pre><p>Kamu harus memastikan semua Node di dalam klaster memiliki <code>.docker/config.json</code> yang sama. Jika tidak, Pod-Pod
akan jalan pada beberapa Node saja dan gagal di Node lainnya. Contohnya, jika kamu menggunakan Node <em>autoscaling</em>, maka
setiap templat <em>instance</em> perlu untuk mempunyai <code>.docker/config.json</code> atau <em>mount</em> sebuah penyimpanan yang berisi berkas tersebut.</p><p>Semua Pod memiliki akses baca (<em>read</em>) untuk <em>image-image</em> di registri privat manapun ketika
<em>key</em> registri privat ditambahkan pada <code>.docker/config.json</code>.</p><h3 id=image-pra-unduh><em>Image</em> Pra-unduh</h3><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Jika kamu jalan di Google Kubernetes Engine, maka akan ada <code>.dockercfg</code> pada setiap Node dengan kredensial untuk Google Container Registry. Kamu dapat menggunakan cara ini.</div><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Cara ini cocok jika kamu dapat mengontrol konfigurasi Node. Cara ini tidak akan
bisa berjalan dengan baik pada GCE, dan penyedia cloud lainnya yang tidak menggantikan
Node secara otomatis.</div><p>Secara <em>default</em>, kubelet akan mencoba untuk mengunduh setiap <em>image</em> dari registri yang dispesifikasikan.
Hanya saja, jika properti <code>imagePullPolicy</code> diatur menjadi <code>IfNotPresent</code> atau <code>Never</code>, maka
sebuah <em>image</em> lokal digunakan.</p><p>Jika kamu ingin memanfaatkan <em>image</em> pra-unduh sebagai pengganti untuk otentikasi registri,
kamu harus memastikan semua Node di dalam klaster memiliki <em>image</em> pra-unduh yang sama.</p><p>Cara ini bisa digunakan untuk memuat <em>image</em> tertentu untuk kecepatan atau sebagai alternatif untuk otentikasi untuk sebuah registri privat.</p><p>Semua Pod akan mendapatkan akses baca ke <em>image</em> pra-unduh manapun.</p><h3 id=tentukan-imagepullsecrets-pada-sebuah-pod>Tentukan ImagePullSecrets pada sebuah Pod</h3><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Cara ini merupakan cara yang direkomendasikan saat ini untuk Google Kubernetes Engine, GCE, dan penyedia cloud lainnya yang
secara otomatis dapat membuat Node.</div><p>Kubernetes mendukung penentuan <em>key</em> registri pada sebuah Pod.</p><h4 id=membuat-sebuah-secret-dengan-docker-config>Membuat sebuah Secret dengan Docker Config</h4><p>Jalankan perintah berikut, ganti nilai huruf besar dengan yang tepat:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret docker-registry &lt;name&gt; --docker-server<span style=color:#666>=</span>DOCKER_REGISTRY_SERVER --docker-username<span style=color:#666>=</span>DOCKER_USER --docker-password<span style=color:#666>=</span>DOCKER_PASSWORD --docker-email<span style=color:#666>=</span>DOCKER_EMAIL
</span></span></code></pre></div><p>Jika kamu sudah memiliki berkas kredensial Docker, daripada menggunakan perintah di atas,
kamu dapat mengimpor berkas kredensial sebagai Kubernetes Secret.
<a href=/id/docs/tasks/configure-pod-container/pull-image-private-registry/#registry-secret-existing-credentials>Membuat sebuah Secret berbasiskan pada kredensial Docker yang sudah ada</a> menjelaskan bagaimana mengatur ini.
Cara ini berguna khususnya jika kamu menggunakan beberapa registri kontainer privat,
perintah <code>kubectl create secret docker-registry</code> akan membuat sebuah Secret yang akan
hanya bekerja menggunakan satu registri privat.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Pod-Pod hanya dapat mengacu pada imagePullSecrets di dalam <em>namespace</em>,
sehingga proses ini perlu untuk diselesaikan satu kali setiap <em>namespace</em>.</div><h4 id=mengacu-pada-imagepullsecrets-di-dalam-sebuah-pod>Mengacu pada imagePullSecrets di dalam sebuah Pod</h4><p>Sekarang, kamu dapat membuat Pod yang mengacu pada Secret dengan menambahkan bagian <code>imagePullSecrets</code>
untuk sebuah definisi Pod.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt; pod.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: Pod
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: foo
</span></span></span><span style=display:flex><span><span style=color:#b44>  namespace: awesomeapps
</span></span></span><span style=display:flex><span><span style=color:#b44>spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>  containers:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - name: foo
</span></span></span><span style=display:flex><span><span style=color:#b44>      image: janedoe/awesomeapp:v1
</span></span></span><span style=display:flex><span><span style=color:#b44>  imagePullSecrets:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - name: myregistrykey
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt;&gt; ./kustomization.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>resources:
</span></span></span><span style=display:flex><span><span style=color:#b44>- pod.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>Cara ini perlu untuk diselesaikan untuk setiap Pod yang mengguunakan registri privat.</p><p>Hanya saja, mengatur <em>field</em> ini dapat diotomasi dengan mengatur imagePullSecrets di dalam
sumber daya <a href=/docs/user-guide/service-accounts>serviceAccount</a>.
Periksa <a href=/id/docs/tasks/configure-pod-container/configure-service-account/#add-imagepullsecrets-to-a-service-account>Tambahan ImagePullSecrets untuk sebuah Service Account</a> untuk instruksi yang lebih detail.</p><p>Kamu dapat menggunakan cara ini bersama <code>.docker/config.json</code> pada setiap Node. Kredensial-kredensial
akan dapat di-<em>merged</em>. Cara ini akan dapat bekerja pada Google Kubernetes Engine.</p><h3 id=kasus-kasus-penggunaan-use-case>Kasus-Kasus Penggunaan (<em>Use Case</em>)</h3><p>Ada beberapa solusi untuk konfigurasi registri privat. Berikut beberapa kasus penggunaan
dan solusi yang disarankan.</p><ol><li>Klaster yang hanya menjalankan <em>image non-proprietary</em> (misalnya open-source). Tidak perlu unutuk menyembunyikan <em>image</em>.<ul><li>Gunakan <em>image</em> publik pada Docker hub.<ul><li>Tidak ada konfigurasi yang diperlukan.</li><li>Pada GCE/Google Kubernetes Engine, sebuah <em>mirror</em> lokal digunakan secara otomatis untuk meningkatkan kecepatan dan ketersediaan.</li></ul></li></ul></li><li>Klaster yang menjalankan <em>image proprietary</em> yang seharusnya disembunyikan dari luar perusahaan, tetapi bisa terlihat oleh pengguna klaster.<ul><li>Gunakan sebuah privat <a href=https://docs.docker.com/registry/>registri Docker</a> yang <em>hosted</em>.<ul><li>Bisa saja di-<em>host</em> pada <a href=https://hub.docker.com/signup>Docker Hub</a>, atau lainnya.</li><li>Konfigurasi <code>.docker/config.json</code> secara manual pada setiap Node seperti dijelaskan di atas.</li></ul></li><li>Atau, jalankan sebuah registri privat internal di belakang <em>firewall</em> kamu dengan akses baca terbuka.<ul><li>Tidak ada konfigurasi Kubernetes yang diperlukan.</li></ul></li><li>Atau, ketika pada GCE/Google Kubernetes Engine, menggunakan Google Container Registry yang ada di proyek.<ul><li>Hal ini bisa bekerja baik dengan <em>autoscaling</em> klaster dibandingkan konfigurasi Node manual.</li></ul></li><li>Atau, pada sebuah klaster dimana mengubah konfigurasi Node tidak nyaman, gunakan <code>imagePullSecrets</code>.</li></ul></li><li>Klaster dengan <em>image proprietary</em>, beberapa memerlukan akses kontrol yang lebih ketat.<ul><li>Pastikan <a href=/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages>AlwaysPullImages <em>admission controller</em></a> aktif. Sebaliknya, semua Pod berpotensi memiliki akses ke semua <em>image</em>.</li><li>Pindahkan data sensitif pada sumber daya "Secret", daripada mengemasnya menjadi sebuah <em>image</em>.</li></ul></li><li>Sebuah klaster <em>multi-tenant</em> dimana setiap <em>tenant</em> memerlukan registri privatnya masing-masing.<ul><li>Pastikan <a href=/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages>AlwaysPullImages <em>admission controller</em></a> aktif. Sebaliknya, semua Pod dari semua tenant berpotensi memiliki akses pada semua <em>image</em>.</li><li>Jalankan sebuah registri privat dimana otorisasi diperlukan.</li><li>Men-<em>generate</em> kredensial registri uuntuk setiap <em>tenant</em>, masukkan ke dalam <em>secret</em> uuntuk setiap <em>namespace tenant</em>.</li><li><em>Tenant</em> menambahkan <em>secret</em> pada imagePullSecrets uuntuk setiap <em>namespace</em>.</li></ul></li></ol><p>Jika kamu memiliki akses pada beberapa registri, kamu dapat membuat satu <em>secret</em> untuk setiap registri.
Kubelet akan melakukan <em>merge</em> <code>imagePullSecrets</code> manapun menjadi sebuah virtual <code>.docker/config.json</code>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-643212488f778acf04bebed65ba34441>3.3.3 - Kontainer Environment</h1><p>Laman ini menjelaskan berbagai <em>resource</em> yang tersedia di dalam Kontainer pada suatu <em>environment</em>.</p><h2 id=environment-kontainer><em>Environment</em> Kontainer</h2><p><em>Environment</em> Kontainer pada Kubernetes menyediakan beberapa <em>resource</em> penting yang tersedia di dalam Kontainer:</p><ul><li>Sebuah <em>Filesystem</em>, yang merupakan kombinasi antara <a href=/id/docs/concepts/containers/images/>image</a> dan satu atau banyak <a href=/id/docs/concepts/storage/volumes/><em>volumes</em></a>.</li><li>Informasi tentang Kontainer tersebut.</li><li>Informasi tentang objek-objek lain di dalam klaster.</li></ul><h3 id=informasi-tentang-kontainer>Informasi tentang Kontainer</h3><p><em>Hostname</em> sebuah Kontainer merupakan nama dari Pod dimana Kontainer dijalankan.
Informasi ini tersedia melalui perintah <code>hostname</code> atau panggilan (<em>function call</em>)
<a href=http://man7.org/linux/man-pages/man2/gethostname.2.html><code>gethostname</code></a> pada <code>libc</code>.</p><p>Nama Pod dan <em>namespace</em> tersedia sebagai variabel <em>environment</em> melalui <a href=/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information/>API <em>downward</em></a>.</p><p>Variabel <em>environment</em> yang ditulis pengguna dalam Pod <em>definition</em> juga tersedia di dalam Kontainer,
seperti halnya variabel <em>environment</em> yang ditentukan secara statis di dalam <em>image</em> Docker.</p><h3 id=informasi-tentang-klaster>Informasi tentang Klaster</h3><p>Daftar semua <em>Service</em> yang dijalankan ketika suatu Kontainer dibuat, tersedia di dalam Kontainer tersebut sebagai variabel <em>environment</em>.
Variabel-variabel <em>environment</em> tersebut sesuai dengan sintaksis <em>links</em> dari Docker.</p><p>Untuk suatu <em>Service</em> bernama <em>foo</em> yang terkait dengan Kontainer bernama <em>bar</em>,
variabel-variabel di bawah ini tersedia:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#b8860b>FOO_SERVICE_HOST</span><span style=color:#666>=</span>&lt;host dimana service dijalankan&gt;
</span></span><span style=display:flex><span><span style=color:#b8860b>FOO_SERVICE_PORT</span><span style=color:#666>=</span>&lt;port dimana service dijalankan&gt;
</span></span></code></pre></div><p>Semua <em>Service</em> memiliki alamat-alamat IP yang bisa didapatkan di dalam Kontainer melalui DNS,
jika <a href=http://releases.k8s.io/main/cluster/addons/dns/><em>addon</em> DNS</a> diaktifkan. </p><h2 id=selanjutnya>Selanjutnya</h2><ul><li>Pelajari lebih lanjut tentang <a href=/id/docs/concepts/containers/container-lifecycle-hooks/>berbagai <em>hook</em> pada <em>lifecycle</em> Kontainer</a>.</li><li>Dapatkan pengalaman praktis soal
<a href=/docs/tasks/configure-pod-container/attach-handler-lifecycle-event/>memberikan <em>handler</em> untuk <em>event</em> dari <em>lifecycle</em> Kontainer</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-a858027489648786a3b16264e451272b>3.3.4 - Runtime Class</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.14 [beta]</code></div><p>Laman ini menjelaskan tentang <em>resource</em> RuntimeClass dan proses pemilihan <em>runtime</em>.</p><div class="alert alert-danger warning callout" role=alert><strong>Peringatan:</strong> RuntimeClass memiliki <em>breaking change</em> untuk pembaruan ke beta pada v1.14. Jika kamu menggunakan
RuntimeClass sebelum v1.14, lihat <a href=#memperbarui-runtimeclass-dari-alpha-ke-beta>Memperbarui RuntimeClass dari Alpha ke Beta</a>.</div><h2 id=runtime-class><code>Runtime Class</code></h2><p>RuntimeClass merupakan sebuah fitur untuk memilih konfigurasi <em>runtime</em> kontainer. Konfigurasi
tersebut digunakan untuk menjalankan kontainer-kontainer milik suatu Pod.</p><h3 id=persiapan>Persiapan</h3><p>Pastikan gerbang fitur (<em>feature gate</em>) <code>RuntimeClass</code> sudah aktif (secara <em>default</em> sudah aktif).
Lihat <a href=/docs/reference/command-line-tools-reference/feature-gates/>Gerbang Fitur</a> untuk lebih
jelasnya soal pengaktifan gerbang fitur.
Gerbang fitur RuntimeClass ini harus aktif pada semua apiserver dan kubelet.</p><ol><li>Lakukan konfigurasi pada implementasi CRI untuk setiap <em>node</em> (tergantung <em>runtime</em> yang dipilih)</li><li>Buat <em>resource</em> RuntimeClass yang terkait</li></ol><h4 id=1-lakukan-konfigurasi-pada-implementasi-cri-untuk-setiap-node>1. Lakukan konfigurasi pada implementasi CRI untuk setiap <em>node</em></h4><p>Pilihan konfigurasi yang tersedia melalui RuntimeClass tergantung pada implementasi
<em>Container Runtime Interface</em> (CRI). Lihat bagian (<a href=#konfigurasi-cri>di bawah ini</a>)
soal bagaimana melakukan konfigurasi untuk implementasi CRI yang kamu miliki.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Untuk saat ini, RuntimeClass berasumsi bahwa semua <em>node</em> di dalam klaster punya
konfigurasi yang sama (homogen). Jika ada <em>node</em> yang punya konfigurasi berbeda dari
yang lain (heterogen), maka perbedaan ini harus diatur secara independen di luar RuntimeClass
melalui fitur <em>scheduling</em> (lihat <a href=/id/docs/concepts/scheduling-eviction/assign-pod-node/>Menempatkan Pod pada Node</a>).</div><p>Seluruh konfigurasi memiliki nama <code>handler</code> yang terkait, dijadikan referensi oleh RuntimeClass.
Nama <em>handler</em> harus berupa valid label 1123 DNS (alfanumerik + karakter <code>-</code>).</p><h4 id=2-buat-resource-runtimeclass-yang-terkait>2. Buat <em>resource</em> <code>RuntimeClass</code> yang terkait</h4><p>Masing-masing konfigurasi pada langkah no.1 punya nama <code>handler</code> yang merepresentasikan
konfigurasi-konfigurasi tersebut. Untuk masing-masing <code>handler</code>, buatlah sebuah objek RuntimeClass terkait.</p><p><em>Resource</em> RuntimeClass saat ini hanya memiliki 2 <em>field</em> yang penting: nama RuntimeClass tersebut
(<code>metadata.name</code>) dan <em>handler</em> (<code>handler</code>). Definisi objek tersebut terlihat seperti ini:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>node.k8s.io/v1beta1 <span style=color:#bbb> </span><span style=color:#080;font-style:italic># RuntimeClass didefinisikan pada grup API node.k8s.io</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>RuntimeClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myclass <span style=color:#bbb> </span><span style=color:#080;font-style:italic># Nama dari RuntimeClass yang nantinya akan dijadikan referensi</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># RuntimeClass merupakan resource tanpa namespace</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>handler</span>:<span style=color:#bbb> </span>myconfiguration <span style=color:#bbb> </span><span style=color:#080;font-style:italic># Nama dari konfigurasi CRI terkait</span><span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Sangat disarankan untuk hanya memperbolehkan admin klaster melakukan operasi
<em>write</em> pada RuntimeClass. Biasanya ini sudah jadi <em>default</em>. Lihat <a href=/docs/reference/access-authn-authz/authorization/>Ikhtisar
Autorisasi</a> untuk penjelasan lebih jauh.</div><h3 id=penggunaan>Penggunaan</h3><p>Ketika RuntimeClass sudah dikonfigurasi pada klaster, penggunaannya sangatlah mudah.
Kamu bisa tentukan <code>runtimeClassName</code> di dalam <code>spec</code> sebuah Pod, sebagai contoh:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>runtimeClassName</span>:<span style=color:#bbb> </span>myclass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Kubelet akan mendapat instruksi untuk menggunakan RuntimeClass dengan nama yang sudah ditentukan tersebut
untuk menjalankan Pod ini. Jika RuntimeClass dengan nama tersebut tidak ditemukan, atau CRI tidak dapat
menjalankan <em>handler</em> yang terkait, maka Pod akan memasuki <a href=/id/docs/concepts/workloads/pods/pod-lifecycle/#pod-phase>tahap</a> <code>Failed</code>.
Lihat <a href=/docs/tasks/debug-application-cluster/debug-application-introspection/><em>event</em></a> untuk mengetahui pesan error yang terkait.</p><p>Jika tidak ada <code>runtimeClassName</code> yang ditentukan di dalam Pod, maka RuntimeHandler yang <em>default</em> akan digunakan.
Untuk kasus ini, perilaku klaster akan seperti saat fitur RuntimeClass dinonaktifkan.</p><h3 id=konfigurasi-cri>Konfigurasi CRI</h3><p>Lihat <a href=/docs/setup/cri/>instalasi CRI</a> untuk lebih detail mengenai pengaturan <em>runtime</em> CRI.</p><h4 id=dockershim>dockershim</h4><p><em>Built-in</em> dockershim CRI yang dimiliki Kubernetes tidak mendukung <em>handler runtime</em>.</p><h4 id=containerd-https-containerd-io><a href=https://containerd.io/>containerd</a></h4><p><em>Handler runtime</em> diatur melalui konfigurasi containerd pada <code>/etc/containerd/config.toml</code>.
<em>Handler</em> yang valid dapat dikonfigurasi pada bagian <em>runtime</em>:</p><pre tabindex=0><code>[plugins.&#34;io.containerd.grpc.v1.cri&#34;.containerd.runtimes.${HANDLER_NAME}]
</code></pre><p>Lihat dokumentasi konfigurasi containerd untuk lebih detail:
<a href=https://github.com/containerd/containerd/blob/main/docs/cri/config.md>https://github.com/containerd/containerd/blob/main/docs/cri/config.md</a></p><h4 id=cri-o-https-cri-o-io><a href=https://cri-o.io/>cri-o</a></h4><p><em>Handler runtime</em> dapat diatur menggunakan konfigurasi cri-o pada <code>/etc/crio/crio.conf</code>.
<em>Handler</em> yang valid dapat dikonfigurasi pada <a href=https://github.com/kubernetes-sigs/cri-o/blob/master/docs/crio.conf.5.md#crioruntime-table>tabel crio.runtime</a>:</p><pre tabindex=0><code>[crio.runtime.runtimes.${HANDLER_NAME}]
  runtime_path = &#34;${PATH_TO_BINARY}&#34;
</code></pre><p>Lihat dokumentasi konfigurasi cri-o untuk lebih detail:
<a href=https://github.com/kubernetes-sigs/cri-o/blob/master/cmd/crio/config.go>https://github.com/kubernetes-sigs/cri-o/blob/master/cmd/crio/config.go</a></p><h3 id=memperbarui-runtimeclass-dari-alpha-ke-beta>Memperbarui RuntimeClass dari Alpha ke Beta</h3><p>Fitur Beta pada RuntimeClass memiliki perubahan sebagai berikut:</p><ul><li>Grup API <em>resource</em> <code>node.k8s.io</code> dan <code>runtimeclasses.node.k8s.io</code> telah dimigrasi ke suatu
API <em>built-in</em> dari CustomResourceDefinition.</li><li>Atribut <code>spec</code> telah disederhakan pada definisi RuntimeClass (tidak ada lagi yang namanya
RuntimeClassSpec).</li><li><em>Field</em> <code>runtimeHandler</code> telah berubah nama menjadi <code>handler</code>.</li><li><em>Field</em> <code>handler</code> sekarang bersifat wajib untuk semua versi API. Artinya, <em>field</em> <code>runtimeHandler</code>
pada API Alpha juga bersifat wajib.</li><li><em>Field</em> <code>handler</code> haruslah berupa label DNS valid (<a href=https://tools.ietf.org/html/rfc1123>RFC 1123</a>),
yang artinya tidak bisa berisi karakter <code>.</code> (pada semua versi). <em>Handler</em> valid harus sesuai dengan
<em>regular expression</em> ini: <code>^[a-z0-9]([-a-z0-9]*[a-z0-9])?$</code>.</li></ul><p><strong>Tindakan yang diperlukan:</strong> Tindakan-tindaka berikut ini diperlukan untuk melakukan
pembaruan fitur RuntimeClass dari versi alpha ke versi beta:</p><ul><li><em>Resource</em> RuntimeClass harus dibuat ulang <strong>setelah</strong> diperbarui ke v.1.14, dan
CRD <code>runtimeclasses.node.k8s.io</code> harus dihapus secara manual:<pre tabindex=0><code>kubectl delete customresourcedefinitions.apiextensions.k8s.io runtimeclasses.node.k8s.io
</code></pre></li><li>Fitur Alpha pada RuntimeClass akan menjadi tidak valid, jika <code>runtimeHandler</code> tidak ditentukan atau
kosong atau menggunakan karakter <code>.</code> pada <em>handler</em>. Ini harus dimigrasi ke <em>handler</em> dengan
konfigurasi yang valid (lihat petunjuk di atas).</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-e6941d969d81540208a3e78bc56f43bc>3.3.5 - Lifecyle Hook pada Kontainer</h1><p>Laman ini menjelaskan bagaimana semua Kontainer yang diatur kubelet menggunakan <em>framework lifecycle hook</em>
untuk menjalankan kode yang di-<em>trigger</em> oleh <em>event</em> selama <em>lifecycle</em> berlangsung.</p><h2 id=ikhtisar>Ikhtisar</h2><p>Kubernetes menyediakan <em>hook</em> untuk <em>lifecycle</em> Kontainer. Hal ini sejalan dengan <em>framework</em> bahasa
pemrograman pada umumnya yang memiliki <em>hook</em> untuk <em>lifecycle</em> komponen, seperti Angular contohnya.
<em>Hook</em> tersebut digunakan Kontainer untuk selalu siap menerima <em>event</em> selama <em>lifecycle</em> dan
menjalankan kode yang diimplementasi pada suatu <em>handler</em>, ketika <em>hook lifecycle</em> terkait telah dieksekusi.</p><h2 id=jenis-jenis-hook-pada-kontainer>Jenis-jenis <em>hook</em> pada Kontainer</h2><p>Ada dua jenis <em>hook</em> yang diekspos pada Kontainer:</p><p><code>PostStart</code></p><p><em>Hook</em> ini dijalankan segera setelah suatu kontainer dibuat.
Hanya saja, tidak ada jaminan bahwa <em>hook</em> akan tereksekusi sebelum <code>ENTRYPOINT</code> dari kontainer.
Tidak ada parameter yang diberikan pada <em>handler</em>.</p><p><code>PreStop</code></p><p><em>Hook</em> ini akan dipanggil sesaat sebelum kontainer dimatikan, karena suatu <em>request</em> API atau <em>event</em> pengaturan,
contohnya kegagalan pada <em>liveness probe</em>, <em>preemption</em>, perebutan <em>resource</em>, dan lainnya.
Sebuah panggilan untuk <em>hook</em> <code>PreStop</code> akan gagal jika kontainer tersebut telah ada pada <em>state terminate</em> atau <em>complete</em>.
Hal ini bersifat <em>blocking</em>, yang artinya panggilan bersifat sinkron (<em>synchronous</em>), harus menunggu eksekusi selesai, sebelum melakukan panggilan
untuk menghapus kontainer tersebut.
Tidak ada parameter yang diberikan pada <em>handler</em>.</p><p>Penjelasan yang lebih rinci tentang proses terminasi dapat dilihat pada <a href=/id/docs/concepts/workloads/pods/pod/#termination-of-pods>Terminasi Pod</a>.</p><h3 id=implementasi-handler-untuk-hook>Implementasi <em>handler</em> untuk <em>hook</em></h3><p>Kontainer dapat mengakses sebuah <em>hook</em> melalui implementasi dan registrasi sebuah <em>handler</em> untuk <em>hook</em> tersebut.
Ada dua jenis <em>handler</em> untuk <em>hook</em> yang dapat diimplementasikan untuk Kontainer:</p><ul><li>Exec - Mengeksekusi sebuah perintah tertentu, contohnya <code>pre-stop.sh</code>, di dalam cgroups dan <em>namespace</em> suatu Kontainer. <em>Resource</em> yang dikonsumsi oleh perintah tersebut dianggap sebagai bagian dari Kontainer.</li><li>HTTP - Mengeksekusi sebuah <em>request</em> HTTP untuk <em>endpoint</em> tertentu pada Kontainer tersebut.</li></ul><h3 id=eksekusi-handler-untuk-hook>Eksekusi <em>handler</em> untuk <em>hook</em></h3><p>Ketika manajemen <em>hook</em> untuk suatu <em>lifecycle</em> Kontainer dipanggil, sistem manajemen internal pada Kubernetes
akan mengeksekusi <em>handler</em> di dalam Kontainer yang terdaftar untuk <em>hook</em> tersebut.</p><p>Panggilan <em>handler</em> untuk <em>hook</em> semuanya bersifat <em>synchronous</em> di dalam konteks Pod yang
memiliki Kontainer tersebut. Artinya, untuk <em>hook</em> <code>PostStart</code>, Kontainer <code>ENTRYPOINT</code>
dan <em>hook</em> dieksekusi secara <em>asyncrhonous</em>. Akan tetapi, jika <em>hook</em> mengambil waktu terlalu lama,
atau <em>hang</em>, Kontainer tersebut tidak bisa sampai ke <em>state</em> <code>running</code>.</p><p>Perilaku ini mirip dengan yang terjadi pada <em>hook</em> <code>PreStop</code>.
Jika <em>hook</em> terlalu lama atau <em>hang</em> saat dieksekusi, Pod tersebut tetap ada pada <em>state</em> <code>Terminating</code>
dan akan dimatikan setelah <code>terminationGracePeriodSeconds</code> Pod selesai.
Jika sebuah <em>hook</em> <code>PostStart</code> atau <code>PreStop</code> gagal dieksekusi, Kontainer akan dimatikan.</p><p>Para pengguna sangat disarankan membuat <em>handler</em> untuk <em>hook</em> seringan mungkin (<em>lightweight</em>).
Biar bagaimanapun, ada beberapa kasus yang memang membutuhkan waktu lama untuk mengeksekusi
suatu perintah, misalnya saat proses penyimpanan <em>state</em> sebelum Kontainer dimatikan.</p><h3 id=jaminan-pengiriman-hook>Jaminan pengiriman <em>hook</em></h3><p>Proses pengiriman <em>hook</em> akan dilakukan <strong>paling tidak satu kali</strong>.
Artinya suatu <em>hook</em> boleh dipanggil beberapa kali untuk <em>event</em> yang sama,
seperti dalam <code>PostStart</code> atau<code>PreStop</code>.
Namun begitu, implementasi <em>hook</em> masing-masing harus memastikan bagaimana
menangani kasus ini dengan benar.</p><p>Pada umumnya, hanya terjadi satu proses pengiriman.
Jika misalnya sebuah penerima HTTP <em>hook</em> mati atau tidak bisa menerima trafik,
maka tidak ada usaha untuk mengirimkan kembali.
Namun demikian, bisa saja terjadi dua kali proses pengiriman untuk kasus tertentu.
Contohnya, jika kubelet <em>restart</em> saat di tengah proses pengiriman <em>hook</em>,
<em>hook</em> tersebut akan dikirimkan kembali saat kubelet sudah hidup kembali.</p><h3 id=melakukan-debug-handler-untuk-hook>Melakukan <em>debug</em> <em>handler</em> untuk <em>hook</em></h3><p><em>Log</em> untuk suatu <em>handler hook</em> tidak terekspos pada <em>event</em> Pod.
Jika <em>handler</em> gagal dieksekusi untuk alasan tertentu, <em>handler</em> akan melakukan <em>broadcast</em> sebuah <em>event</em>.
Untuk <code>PostStart</code>, akan dilakukan <em>broadcast event</em> <code>FailedPostStartHook</code>,
dan untuk <code>PreStop</code>, akan dilakukan <em>broadcast event</em> <code>FailedPreStopHook</code>.
Kamu dapat melihat <em>event-event</em> ini dengan menjalankan perintah <code>kubectl describe pod &lt;pod_name></code>.
Berikut merupakan contoh keluaran <em>event-event</em> setelah perintah tersebut dijalankan.</p><pre tabindex=0><code>Events:
  FirstSeen  LastSeen  Count  From                                                   SubobjectPath          Type      Reason               Message
  ---------  --------  -----  ----                                                   -------------          --------  ------               -------
  1m         1m        1      {default-scheduler }                                                          Normal    Scheduled            Successfully assigned test-1730497541-cq1d2 to gke-test-cluster-default-pool-a07e5d30-siqd
  1m         1m        1      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}  spec.containers{main}  Normal    Pulling              pulling image &#34;test:1.0&#34;
  1m         1m        1      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}  spec.containers{main}  Normal    Created              Created container with docker id 5c6a256a2567; Security:[seccomp=unconfined]
  1m         1m        1      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}  spec.containers{main}  Normal    Pulled               Successfully pulled image &#34;test:1.0&#34;
  1m         1m        1      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}  spec.containers{main}  Normal    Started              Started container with docker id 5c6a256a2567
  38s        38s       1      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}  spec.containers{main}  Normal    Killing              Killing container with docker id 5c6a256a2567: PostStart handler: Error executing in Docker Container: 1
  37s        37s       1      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}  spec.containers{main}  Normal    Killing              Killing container with docker id 8df9fdfd7054: PostStart handler: Error executing in Docker Container: 1
  38s        37s       2      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}                         Warning   FailedSync           Error syncing pod, skipping: failed to &#34;StartContainer&#34; for &#34;main&#34; with RunContainerError: &#34;PostStart handler: Error executing in Docker Container: 1&#34;
  1m         22s       2      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}  spec.containers{main}  Warning   FailedPostStartHook
</code></pre><h2 id=selanjutnya>Selanjutnya</h2><ul><li>Pelajari lebih lanjut tentang <a href=/id/docs/concepts/containers/container-environment-variables/><em>environment</em> Kontainer</a>.</li><li>Pelajari bagaimana caranya
<a href=/docs/tasks/configure-pod-container/attach-handler-lifecycle-event/>melakukan <em>attach handler</em> pada <em>event lifecycle</em> sebuah Kontainer</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-d52aadda80edd9f8c514cfe2321363c2>3.4 - Workloads</h1></div><div class=td-content><h1 id=pg-4d68b0ccf9c683e6368ffdcc40c838d4>3.4.1 - Pods</h1></div><div class=td-content><h1 id=pg-37afa6c66c74400d1579f10faf55e5b6>3.4.1.1 - Pengenalan Pod</h1><p>Halaman ini menyajikan ikhtisar dari <code>Pod</code>, objek terkecil yang dapat di <em>deploy</em> di dalam objek model Kubernetes.</p><h2 id=memahami-pod>Memahami Pod</h2><p>Sebuah <em>Pod</em> adalah unit dasar di Kubernetes--unit terkecil dan paling sederhana di dalam objek model Kubernetes yang dapat dibuat dan di <em>deploy</em>. Sebuah <em>Pod</em> merepresentasikan suatu proses yang berjalan di dalam klaster.</p><p><em>Pod</em> membungkus sebuah kontainer (atau, di beberapa kasus, beberapa kontainer), sumber penyimpanan, alamat jaringan <em>IP</em> yang unik, dan opsi yang mengatur bagaimana kontainer harus dijalankan. <em>Pod</em> merupakan representasi dari unit <em>deployment</em>: sebuah <em>instance</em> aplikasi di dalam Kubernetes, yang mungkin terdiri dari satu kontainer atau sekumpulan kontainer yang berbagi <em>resource</em>.</p><p><a href=https://www.docker.com>Docker</a> adalah salah satu kontainer <em>runtime</em> yang paling umum digunakan di Kubernetes <em>Pod</em>, tetapi <em>Pod</em> mendukung kontainer <em>runtime</em> lainnya.</p><p><em>Pod</em> di Kubernetes klaster dapat digunakan dengan dua cara:</p><ul><li><strong>Pod menjalankan satu kontainer</strong>. Model satu kontainer per <em>Pod</em> adalah model yang umum digunakan di Kubernetes; kamu dapat membayangkan sebuah <em>Pod</em> sebagai pembungkus kontainer tersebut, dan Kubernetes tidak mengelola kontainer secara langsung tetapi mengelola <em>Pod</em> tersebut.</li><li><strong>Pod menjalankan beberapa kontainer yang perlu berjalan bersamaan</strong>. Sebuah <em>Pod</em> dapat membungkus sebuah aplikasi yang terdiri dari beberapa kontainer yang perlu berbagi <em>resource</em>. Kontainer yang ditempatkan di dalam satu <em>Pod</em> ini membentuk sebuah layanan. Sebuah kontainer menyajikan berkas dari sumber penyimpanan ke publik, sedangkan kontainer <em>sidecar</em> yang lain melakukan pembaharuan terhadap berkas tersebut. <em>Pod</em> membungkus semua kontainer dan <em>resource</em> penyimpanan sebagai satu kesatuan yang dapat dikelola.</li></ul><p><a href=http://kubernetes.io/blog>Kubernetes Blog</a> menyediakan beberapa informasi tambahan terkait penggunaan <em>Pod</em>. Informasi selengkapnya, kunjungi:</p><ul><li><a href=https://kubernetes.io/blog/2015/06/the-distributed-system-toolkit-patterns>The Distributed System Toolkit: Patterns for Composite Containers</a></li><li><a href=https://kubernetes.io/blog/2016/06/container-design-patterns>Container Design Patterns</a></li></ul><p>Setiap <em>Pod</em> dimaksudkan untuk menjalankan satu <em>instance</em> aplikasi. Jika kamu ingin mengembangkan aplikasi secara horizontal (contoh, banyak <em>instance</em> sekaligus), kamu dapat menggunakan banyak <em>Pod</em>, satu untuk setiap <em>instance</em>. Di Kubernetes, konsep ini umumnya disebut dengan replikasi. <em>Pod</em> yang direplikasi biasanya dibuat dan dikelola sebagai grup oleh objek abstraksi yang disebut kontroler. Lihat <a href=#pod-dan-kontroler>Pod dan Kontroler</a> untuk informasi selengkapnya.</p><h3 id=bagaimana-pod-mengelola-beberapa-kontainer>Bagaimana <em>Pod</em> mengelola beberapa Kontainer</h3><p><em>Pod</em> didesain untuk mendukung banyak proses (sebagai kontainer) yang membentuk sebuah layanan. Kontainer di dalam sebuah <em>Pod</em> akan otomatis ditempatkan bersama di dalam satu mesin fisik atau mesin <em>virtual</em> di dalam klaster. Kontainer tersebut dapat berbagi <em>resource</em> dan dependensi, berkomunikasi satu sama lain, dan berkoordinasi kapan dan bagaimana mereka diterminasi.</p><p>Perhatikan bahwa mengelompokan kontainer di dalam satu <em>Pod</em> merupakan kasus lanjutan. Kamu dapat menggunakan pola ini hanya dalam kasus tertentu. Sebagai contoh, kamu memiliki kontainer yang bertindak sebagai <em>web server</em> yang menyajikan berkas dari <em>resource</em> penyimpanan bersama, dan kontainer <em>sidecar</em> melakukan pembaharuan terhadap berkas tersebut dari sumber lain, seperti dalam diagram <em>Pod</em> berikut:<figure><img src=/images/docs/pod.svg width=50%><figcaption><h4>Pod diagram</h4></figcaption></figure></p><p><em>Pod</em> menyediakan dua jenis <em>resource</em> sebagai penyusun dari kontainer: <em>jaringan</em> dan <em>penyimpanan</em>.</p><h4 id=jaringan>Jaringan</h4><p>Setiap <em>Pod</em> diberikan sebuah alamat <em>IP</em> unik. Setiap kontainer di dalam <em>Pod</em> berbagi <em>network namespace</em>, termasuk alamat <em>IP</em> dan <em>port</em> jaringan. Setiap kontainer di dalam <em>Pod</em> dapat berkomunikasi satu sama lain menggunakan <em>localhost</em>. Saat para kontainer di dalam <em>Pod</em> berkomunikasi dengan entitas lain di luar <em>Pod</em>, mereka harus berkoordinasi satu sama lain bagaimana mereka menggunakan <em>resource</em> jaringan (seperti <em>Port</em>).</p><h4 id=penyimpanan>Penyimpanan</h4><p><em>Pod</em> dapat menentukan penyimpanan bersama yaitu <em>volumes</em>. Semua kontainer di dalam <em>Pod</em> dapat mengakses <em>volumes</em> ini, mengizinkan kontainer untuk berbagi data. <em>Volumes</em> juga memungkinkan data di <em>Pod</em> untuk bertahan jika salah satu kontainer perlu melakukan proses <em>restart</em>. Lihat <em><a href=/id/docs/concepts/storage/volumes/>Volumes</a></em> untuk informasi lebih lanjut bagaimana Kubernetes mengimplementasikan penyimpanan di dalam <em>Pod</em>.</p><h2 id=bekerja-dengan-pod>Bekerja dengan Pod</h2><p>Kamu akan jarang membuat <em>Pod</em> secara langsung di Kubernetes. Ini karena <em>Pod</em> dirancang sebagai entitas sesaat. Saat <em>Pod</em> dibuat (baik oleh kamu, atau secara tidak langsung oleh kontroler), <em>Pod</em> ditempatkan dan dijalankan di sebuah <em>Node</em> di dalam klaster. <em>Pod</em> akan tetap di <em>Node</em> tersebut sampai proses dihentikan, Objek <em>Pod</em> dihapus, <em>Pod</em> dihentikan karena kekurangan <em>resource</em>, atau <em>Node</em> tersebut berhenti berjalan.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Tidak perlu bingung untuk membedakan antara menjalankan ulang sebuah kontainer di dalam <em>Pod</em> dan menjalankan ulang <em>Pod</em>. <em>Pod</em> itu sendiri tidak berjalan, tetapi <em>Pod</em> adalah <em>environment</em> kontainer itu berjalan dan akan tetap ada sampai dihapus.</div><p><em>Pod</em> tidak melakukan mekanisme penyembuhan diri sendiri. Jika <em>Pod</em> ditempatkan disebuah <em>Node</em> yang gagal, atau proses penempatan <em>Pod</em> itu sendiri gagal, <em>Pod</em> akan dihapus; demikian juga, <em>Pod</em> tidak akan bertahan jika <em>Node</em> tersebut kehabisan <em>resource</em> atau sedang dalam tahap pemeliharaan. Kubernetes menggunakan abstraksi yang disebut kontroler, yang menangani dan mengelola <em>Pod</em>. Jadi, meskipun <em>Pod</em> dapat dipakai secara langsung di Kubernetes, kontroler merupakan cara umum yang digunakan untuk mengelola <em>Pod</em>. Lihat <a href=#pod-dan-kontroler>Pod dan kontroler</a> untuk informasi lebih lanjut bagaimana Kubernetes menggunakan kontroler untuk mengimpelentasikan mekanisme penyembuhan diri sendiri dan replikasi pada <em>Pod</em>.</p><h3 id=pod-dan-kontroler>Pod dan Kontroler</h3><p>Kontroler dapat membuat dan mengelola banyak <em>Pod</em> untuk kamu, menangani replikasi dan menyediakan kemampuan penyembuhan diri sendiri pada lingkup klaster. Sebagai contoh, jika sebuah <em>Node</em> gagal, kontroler akan otomatis mengganti <em>Pod</em> tersebut dengan menempatkan <em>Pod</em> yang identik di <em>Node</em> yang lain.</p><p>Beberapa contoh kontroler yang berisi satu atau lebih <em>Pod</em> meliputi:</p><ul><li><a href=/id/docs/concepts/workloads/controllers/deployment/>Deployment</a></li><li><a href=/id/docs/concepts/workloads/controllers/statefulset/>StatefulSet</a></li><li><a href=/id/docs/concepts/workloads/controllers/daemonset/>DaemonSet</a></li></ul><p>Secara umum, kontroler menggunakan templat <em>Pod</em> yang kamu sediakan untuk membuat <em>Pod</em>.</p><h2 id=templat-pod>Templat Pod</h2><p>Templat <em>Pod</em> adalah spesifikasi dari <em>Pod</em> yang termasuk di dalam objek lain seperti
<a href=/id/docs/concepts/workloads/controllers/replicationcontroller/>Replication Controllers</a>, <a href=/docs/concepts/jobs/run-to-completion-finite-workloads/>Jobs</a>, dan <a href=/id/docs/concepts/workloads/controllers/daemonset/>DaemonSets</a>. Kontroler menggunakan templat <em>Pod</em> untuk membuat <em>Pod</em>.</p><p>Contoh di bawah merupakan manifestasi sederhana untuk <em>Pod</em> yang berisi kontainer yang membuat sebuah pesan.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myapp-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>myapp<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myapp-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#39;sh&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;-c&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;echo Hello Kubernetes! &amp;&amp; sleep 3600&#39;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div><p>Perubahan yang terjadi pada templat atau berganti ke templat yang baru tidak memiliki efek langsung pada <em>Pod</em> yang sudah dibuat. <em>Pod</em> yang dibuat oleh <em>replication controller</em> dapat diperbarui secara langsung.</p><h2 id=selanjutnya>Selanjutnya</h2><ul><li>Pelajari lebih lanjut tentang perilaku <em>Pod</em>:<ul><li><a href=/id/docs/concepts/workloads/pods/pod/#termination-of-pods>Terminasi Pod</a></li><li><a href=/id/docs/concepts/workloads/pods/pod-lifecycle/>Lifecycle Pod</a></li></ul></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-99cce294fe789317ee684a6e1f07f20f>3.4.1.2 - Pod</h1><p>Pod adalah unit komputasi terkecil yang bisa di-<em>deploy</em> dan dibuat serta dikelola dalam Kubernetes.</p><h2 id=apa-itu-pod>Apa Itu Pod?</h2><p>Sebuah Pod (seperti pod pada paus atau kacang polong) adalah sebuah kelompok yang
terdiri dari satu atau lebih <a class=glossary-tooltip title='Sebuah image yang ringan dan dapat dijalankan yang mengandung perangkat lunak and segala dependensi yang dibutuhkan.' data-toggle=tooltip data-placement=top href=/id/docs/concepts/overview/what-is-kubernetes/#mengapa-kontainer target=_blank aria-label=kontainer>kontainer</a>
(misalnya kontainer Docker), dengan ruang penyimpanan ataupun jaringan yang dipakai bersama,
dan sebuah spesifikasi mengenai bagaimana menjalankan kontainer. Isi dari Pod akan
selalu diletakkan dan dijadwalkan bersama, serta berjalan dalam konteks yang sama.
Sebuah Pod memodelkan <em>"logical host"</em> yang spesifik terhadap aplikasi. Ini mengandung
lebih dari satu kontainer aplikasi yang secara relatif saling terhubung erat. Sebelum
masa kontainer, menjalankan aplikasi dalam mesin fisik atau <em>virtual</em> berarti
menjalankan dalam <em>logical host</em> yang sama.</p><p>Walaupun Kubernetes mendukung lebih banyak <em>runtime</em> kontainer selain Docker,
namun Docker adalah yang paling umum diketahui dan ini membantu dalam menjelaskan
Pod dengan istilah pada Docker.</p><p>Konteks bersama dalam sebuah Pod adalah kumpulan Linux namespace, cgroup dan
kemungkinan segi isolasi lain, hal yang sama yang mengisolasi kontainer Docker.
Dalam sebuah konteks pada Pod, setiap aplikasi bisa menerapkan sub-isolasi lebih lanjut.</p><p>Semua kontainer dalam suatu Pod akan berbagi alamat IP dan <em>port</em> yang sama,
dan bisa saling berkomunikasi melalui <code>localhost</code>. Komunikasi tersebut mengunakan
standar <em>inter-process communications</em> (IPC) seperti SystemV semaphores
atau POSIX shared memory. Kontainer pada Pod yang berbeda memiliki alamat IP
yang berbeda dan tidak dapat berkomunikasi menggunakan IPC tanpa
<a href=/id/docs/concepts/policy/pod-security-policy/>pengaturan khusus</a>. Kontainer ini
biasa berkomunikasi dengan yang lain menggunakan alamat IP setiap Pod.</p><p>Aplikasi dalam suatu Pod juga memiliki akses ke <a class=glossary-tooltip title='Sebuah direktori yang mengandung data, dapat diakses o;eh kontainer-kontainer di dalam pod.' data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/ target=_blank aria-label='ruang penyimpanan'>ruang penyimpanan</a> bersama,
yang didefinisikan sebagai bagian dari Pod dan dibuat bisa diikatkan ke masing-masing
<em>filesystem</em> pada aplikasi.</p><p>Dalam istilah konsep <a href=https://www.docker.com/>Docker</a>, sebuah Pod dimodelkan sebagai
gabungan dari kontainer Docker yang berbagi <em>namespace</em> dan ruang penyimpanan <em>filesystem</em>.</p><p>Layaknya aplikasi dengan kontainer, Pod dianggap sebagai entitas yang relatif tidak kekal
(tidak bertahan lama). Seperti yang didiskusikan dalam
<a href=/id/docs/concepts/workloads/pods/pod-lifecycle/>siklus hidup Pod</a>, Pod dibuat, diberikan
ID unik (UID), dan dijadwalkan pada suatu mesin dan akan tetap disana hingga dihentikan
(bergantung pada aturan <em>restart</em>) atau dihapus. Jika <a class=glossary-tooltip title='A node is a worker machine in Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/nodes/ target=_blank aria-label=mesin>mesin</a>
mati, maka semua Pod pada mesin tersebut akan dijadwalkan untuk dihapus, namun setelah
suatu batas waktu. Suatu Pod tertentu (sesuai dengan ID unik) tidak akan dijadwalkan ulang
ke mesin baru, namun akan digantikan oleh Pod yang identik, bahkan jika dibutuhkan bisa
dengan nama yang sama, tapi dengan ID unik yang baru
(baca <a href=/id/docs/concepts/workloads/controllers/replicationcontroller/><em>replication controller</em></a>
untuk info lebih lanjut)</p><p>Ketika sesuatu dikatakan memiliki umur yang sama dengan Pod, misalnya saja ruang penyimpanan,
maka itu berarti akan tetap ada selama Pod tersebut masih ada. Jika Pod dihapus dengan
alasan apapun, sekalipun Pod pengganti yang identik telah dibuat, semua yang berhubungan
(misalnya ruang penyimpanan) akan dihapus dan dibuat ulang.</p><figure><img src=/images/docs/pod.svg width=50%><figcaption><h4>Pod diagram</h4></figcaption></figure><p><em>Sebuah Pod dengan banyak kontainer, yaitu <em>File Puller</em> dan <em>Web Server</em> yang menggunakan
ruang penyimpanan persisten untuk berbagi ruang penyimpanan bersama antara kontainer.</em></p><h2 id=motivasi-suatu-pods>Motivasi suatu Pods</h2><h3 id=pengelolaan>Pengelolaan</h3><p>Pod adalah suatu model dari pola beberapa proses yang bekerja sama dan membentuk
suatu unit layanan yang kohesif. Menyederhanakan proses melakukan <em>deploy</em> dan
pengelolaan aplikasi dengan menyediakan abstraksi tingkat yang lebih tinggi
daripada konstituen aplikasinya. Pod melayani sebagai unit dari <em>deployment</em>,
penskalaan horizontal, dan replikasi. <em>Colocation</em> (<em>co-scheduling</em>), berbagi nasib
(misalnya dimatikan), replikasi terkoordinasi, berbagi sumber daya dan
pengelolaan ketergantungan akan ditangani otomatis untuk kontainer dalam suatu Pod.</p><h3 id=berbagi-sumber-daya-dan-komunikasi>Berbagi sumber daya dan komunikasi</h3><p>Pod memungkinkan berbagi data dan komunikasi diantara konstituennya.</p><p>Semua aplikasi dalam suatu Pod menggunakan <em>namespace</em> jaringan yang sama
(alamat IP dan <em>port</em> yang sama), dan menjadikan bisa saling mencari dan berkomunikasi
dengan menggunakan <code>localhost</code>. Oleh karena itu, aplikasi dalam Pod harus
berkoordinasi mengenai penggunaan <em>port</em>. Setiap Pod memiliki alamat IP
dalam satu jaringan bersama yang bisa berkomunikasi dengan komputer lain
dan Pod lain dalam jaringan yang sama.</p><p>Kontainer dalam suatu Pod melihat <em>hostname</em> sistem sebagai sesuatu yang sama
dengan konfigurasi <code>name</code> pada Pod. Informasi lebih lanjut terdapat dibagian
<a href=/id/docs/concepts/cluster-administration/networking/>jaringan</a>.</p><p>Sebagai tambahan dalam mendefinisikan kontainer aplikasi yang berjalan dalam Pod,
Pod memberikan sepaket sistem penyimpanan bersama. Sistem penyimpanan memungkinkan
data untuk bertahan saat kontainer dijalankan ulang dan dibagikan kepada semua
aplikasi dalam Pod tersebut.</p><h2 id=penggunaan-pod>Penggunaan Pod</h2><p>Pod dapat digunakan untuk menjalankan beberapa aplikasi yang terintegrasi
secara vertikal (misalnya LAMP), namun motivasi utamanya adalah untuk mendukung
berlokasi bersama, mengelola program pembantu, diantaranya adalah:</p><ul><li>sistem pengelolaan konten, pemuat berkas dan data, manajer <em>cache</em> lokal, dll.</li><li>catatan dan <em>checkpoint</em> cadangan, kompresi, rotasi, dll.</li><li>pengamat perubahan data, pengintip catatan, adapter pencatatan dan pemantauan,
penerbit peristiwa, dll.</li><li>proksi, jembatan dan adaptor.</li><li>pengontrol, manajer, konfigurasi dan pembaharu.</li></ul><p>Secara umum, masing-masing Pod tidak dimaksudkan untuk menjalankan beberapa
aplikasi yang sama.</p><p>Penjelasan lebih lengkap bisa melihat <a href=https://kubernetes.io/blog/2015/06/the-distributed-system-toolkit-patterns>The Distributed System ToolKit: Patterns for Composite Containers</a>.</p><h2 id=alternatif-pertimbangan>Alternatif pertimbangan</h2><p>Kenapa tidak menjalankan banyak program dalam satu kontainer (Docker)?</p><ol><li>Transparansi. Membuat kontainer dalam suatu Pod menjadi terlihat dari infrastruktur,
memungkinkan infrastruktur menyediakan servis ke kontainer tersebut, misalnya saja
pengelolaan proses dan pemantauan sumber daya. Ini memfasilitasi sejumlah
kenyamanan untuk pengguna.</li><li>Pemisahan ketergantungan perangkat lunak. Setiap kontainer mungkin memiliki
versi, dibuat dan dijalankan ulang secara independen. Kubernetes mungkin mendukung
pembaharuan secara langsung terhadap suatu kontainer, suatu saat nanti.</li><li>Mudah digunakan. Penguna tidak diharuskan menjalankan manajer prosesnya sendiri,
khawatir dengan sinyal dan propagasi <em>exit-code</em>, dan lain sebagainya.</li><li>Efisiensi. Karena infrastruktur memegang lebih banyak tanggung jawab, kontainer
bisa lebih ringan.</li></ol><p>Kenapa tidak mendukung penjadwalan kontainer berdasarkan <em>affinity</em>?</p><p>Cara itu bisa menyediakan lokasi yang sama, namun tidak memberikan banyak
keuntungan dari Pod, misalnya saja berbagi sumber daya, IPC, jaminan berbagi nasib
dan kemudahan manajemen.</p><h2 id=ketahanan-suatu-pod-atau-kekurangan>Ketahanan suatu Pod (atau kekurangan)</h2><p>Pod tidak dimaksudkan untuk diperlakukan sebagai entitas yang tahan lama.
Mereka tidak akan bertahan dengan kegagalan penjadwalan, kegagalan mesin,
atau <em>eviction</em> (pengusiran), misalnya karena kurangnya sumber daya atau dalam suatu
kasus mesin sedang dalam pemeliharaan.</p><p>Secara umum, pengguna tidak seharusnya butuh membuat Pod secara langsung. Mereka
seharusnya selalu menggunakan pengontrol, sekalipun untuk yang tunggal, misalnya,
<a href=/id/docs/concepts/workloads/controllers/deployment/><em>Deployment</em></a>. Pengontrol
menyediakan penyembuhan diri dengan ruang lingkup kelompok, begitu juga dengan
pengelolaan replikasi dan penluncuran.
Pengontrol seperti <a href=/id/docs/concepts/workloads/controllers/statefulset.md><em>StatefulSet</em></a>
bisa memberikan dukungan terhadap Pod yang <em>stateful</em>.</p><p>Penggunaan API kolektif sebagai <em>user-facing primitive</em> utama adalah hal yang
relatif umum diantara sistem penjadwalan kluster, seperti</p><p><a href=https://research.google.com/pubs/pub43438.html>Borg</a>,
<a href=https://mesosphere.github.io/marathon/docs/rest-api.html>Marathon</a>,
<a href=http://aurora.apache.org/documentation/latest/reference/configuration/#job-schema>Aurora</a>, dan
<a href=https://www.slideshare.net/Docker/aravindnarayanan-facebook140613153626phpapp02-37588997>Tupperware</a>.</p><p>Pod diekspose sebagai <em>primitive</em> untuk memfasilitasi hal berikut:</p><ul><li>penjadwalan dan pengontrol sifat <em>pluggability</em></li><li>mendukung operasi pada level Pod tanpa perlu melakukan proksi melalui API pengontrol</li><li>pemisahan antara umur suatu Pod dan pengontrol, seperti misalnya <em>bootstrapping</em>.</li><li>pemisahan antara pengontrol dan servis, pengontrol <em>endpoint</em> hanya memperhatikan Pod</li><li>komposisi yang bersih antara fungsionalitas dilevel Kubelet dan klaster. Kubelet
secara efektif adalah pengontrol Pod.</li><li>aplikasi dengan ketersediaan tinggi, yang akan mengharapkan Pod akan digantikan
sebelum dihentikan dan tentu saja sebelum dihapus, seperti dalam kasus penggusuran
yang direncanakan atau pengambilan gambar.</li></ul><h2 id=penghentian-pod>Penghentian Pod</h2><p>Karena Pod merepresentasikan proses yang berjalan pada mesin didalam klaster, sangat
penting untuk memperbolehkan proses ini berhenti secara normal ketika sudah tidak
dibutuhkan (dibandingkan dengan dihentikan paksa dengan sinyal KILL dan tidak memiliki
waktu untuk dibersihkan). Pengguna seharusnya dapat meminta untuk menghapus dan tahu
proses penghentiannya, serta dapat memastikan penghentian berjalan sempurna. Ketika
pengguna meminta menghapus Pod, sistem akan mencatat masa tenggang untuk penghentian
secara normal sebelum Pod dipaksa untuk dihentikan, dan sinyal TERM akan dikirim ke
proses utama dalam setiap kontainer. Setelah masa tenggang terlewati, sinyal KILL
akan dikirim ke setiap proses dan Pod akan dihapus dari API server. Jika Kubelet
atau kontainer manajer dijalankan ulang ketika menunggu suatu proses dihentikan,
penghentian tersebut akan diulang dengan mengembalikan masa tenggang senilai semula.</p><p>Contohnya sebagai berikut:</p><ol><li>Pengguna mengirim perintah untuk menghapus Pod, dengan masa tenggang (30 detik)</li><li>Pod dalam API server akan diperbarui dengan waktu dimana Pod dianggap "mati"
bersama dengan masa tenggang.</li><li>Pod ditampilkan dalam status "Terminating" ketika tercantum dalam perintah klien</li><li>(bersamaan dengan poin 3) Ketika Kubelet melihat Pod sudah ditandai sebagai
"Terminating" karena waktu pada poin 2 sudah diatur, ini memulai proses penghentian Pod<ol><li>Jika salah satu kontainer pada Pod memiliki
<a href=/id/docs/concepts/containers/container-lifecycle-hooks/#hook-details>preStop <em>hook</em></a>,
maka akan dipanggil di dalam kontainer. Jika <code>preStop</code> <em>hook</em> masih berjalan
setelah masa tenggang habis, langkah 2 akan dipanggil dengan tambahan masa tenggang
yang sedikit, 2 detik.</li><li>Semua kontainer akan diberikan sinyal TERM. Sebagai catatan, tidak semua kontainer
akan menerima sinyal TERM dalam waktu yang sama dan mungkin butuh waktu untuk
menjalankan <code>preStop</code> <em>hook</em> jika bergantung pada urutan penghentiannya.</li></ol></li><li>(bersamaan dengan poin 3) Pod akan dihapus dari daftar <em>endpoint</em> untuk servis dan
tidak lagi dianggap sebagai bagian dari Pod yang berjalan dalam <em>replication controllers</em>.
Pod yang dihentikan, secara perlahan tidak akan melayani permintaan karena load balancer
(seperti servis proksi) menghapus mereka dari daftar rotasi.</li><li>Ketika masa tenggang sudah lewat, semua proses yang masih berjalan dalam Pod
akan dihentikan dengan sinyal SIGKILL.</li><li>Kubelet akan selesai menghapus Pod dalam API server dengan mengatur masa tenggang
menjadi 0 (langsung menghapus). Pod akan menghilang dari API dan tidak lagi terlihat
oleh klien.</li></ol><p>Secara <em>default</em>, semua penghapusan akan berjalan normal selama 30 detik. Perintah
<code>kubectl delete</code> mendukung opsi <code>--grace-period=&lt;waktu dalam detik></code> yang akan
memperbolehkan pengguna untuk menimpa nilai awal dan memberikan nilai sesuai keinginan
pengguna. Nilai <code>0</code> akan membuat Pod
<a href=/id/docs/concepts/workloads/pods/pod/#force-deletion-of-pods>dihapus paksa</a>.
Kamu harus memberikan opsi tambahan <code>--force</code> bersamaan dengan <code>--grace-period=0</code>
untuk melakukan penghapusan paksa.</p><h3 id=penghapusan-paksa-sebuah-pod>Penghapusan paksa sebuah Pod</h3><p>Penghapusan paksa dari sebuah Pod didefinisikan sebagai penghapusan Pod dari <em>state</em>
klaster dan etcd secara langsung. Ketika penghapusan paksa dilakukan, API server tidak
akan menunggu konfirmasi dari kubelet bahwa Pod sudah dihentikan pada mesin ia berjalan.
Ini menghapus Pod secara langsung dari API, sehingga Pod baru bisa dibuat dengan nama
yang sama. Dalam mesin, Pod yang dihentikan paksa akan tetap diberikan sedikit masa
tenggang sebelum dihentikan paksa.</p><p>Penghentian paksa dapat menyebabkan hal berbahaya pada beberapa Pod dan seharusnya
dilakukan dengan perhatian lebih. Dalam kasus StatefulSet Pods, silakan melihat
dokumentasi untuk <a href=/docs/tasks/run-application/force-delete-stateful-set-pod/>penghentian Pod dari StatefulSet</a>.</p><h2 id=hak-istimewa-untuk-kontainer-pada-pod>Hak istimewa untuk kontainer pada Pod</h2><p>Setiap kontainer dalam Pod dapat mengaktifkan hak istimewa (mode <em>privileged</em>), dengan menggunakan tanda
<code>privileged</code> pada <a href=/id/docs/tasks/configure-pod-container/security-context/>konteks keamanan</a>
pada spesifikasi kontainer. Ini akan berguna untuk kontainer yang ingin menggunakan
kapabilitas Linux seperti memanipulasi jaringan dan mengakses perangkat. Proses dalam
kontainer mendapatkan hak istimewa yang hampir sama dengan proses di luar kontainer.
Dengan hak istimerwa, seharusnya lebih mudah untuk menulis pada jaringan dan <em>plugin</em>
ruang penyimpanan sebagai Pod berbeda yang tidak perlu dikompilasi ke dalam kubelet.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> <em>Runtime</em> kontainer kamu harus mendukung konsep hak istimewa kontainer untuk membuat
pengaturan ini menjadi relevan.</div><h2 id=api-object>API Object</h2><p>Pod adalah sumber daya tingkat tinggi dalam Kubernetes REST API.
Definisi <a href=/docs/reference/generated/kubernetes-api/v1.25/#pod-v1-core>Objek Pod API</a> menjelaskan mengenai objek secara lengkap.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-c3c2b9cf30915ec9d46c147201da3332>3.4.1.3 - Siklus Hidup Pod</h1><p></p><p>Halaman ini menjelaskan siklus hidup sebuah Pod</p><h2 id=fase-pod>Fase Pod</h2><p><em>Field</em> <code>status</code> dari sebuah Pod merupakan sebuah objek <a href=/docs/reference/generated/kubernetes-api/v1.25/#podstatus-v1-core>PodStatus</a>, yang memiliki sebuah <em>field</em> <code>phase</code>.</p><p>Fase dari sebuah Pod adalah sesuatu yang sederhana, ringkasan yang lebih tinggi tentang Pod dalam siklus hidupnya. Fase ini tidak ditujukan sebagai sebuah kesimpulan yang luas dari observasi suatu kontainer atau <em>state</em> suatu Pod, serta tidak ditujukan sebagai <em>state machine</em> yang luas.</p><p>Jumlah dan arti dari nilai-nilai fase Pod dijaga ketat. Selain yang ada dalam dokumentasi ini, tidak perlu berasumsi mengenai Pod telah diberikan nilai <code>phase</code>.</p><p>Berikut adalah nilai yang mungkin diberikan untuk suatu <code>phase</code>:</p><table><thead><tr><th style=text-align:left>Nilai</th><th style=text-align:left>Deskripsi</th></tr></thead><tbody><tr><td style=text-align:left><code>Pending</code></td><td style=text-align:left>Pod telah disetujui oleh sistem Kubernetes, tapi ada satu atau lebih <em>image</em> kontainer yang belum terbuat. Ini termasuk saat sebelum dijadwalkan dan juga saat mengunduh <em>image</em> melalui jaringan, yang mungkin butuh beberapa waktu.</td></tr><tr><td style=text-align:left><code>Running</code></td><td style=text-align:left>Pod telah terikat ke suatu node, dan semua kontainer telah terbuat. Setidaknya ada 1 kontainer yang masih berjalan, atau dalam proses memulai atau <em>restart</em>.</td></tr><tr><td style=text-align:left><code>Succeeded</code></td><td style=text-align:left>Semua kontainer di dalam Pod sudah berhasil dihentikan, dan tidak akan dilakukan <em>restart</em>.</td></tr><tr><td style=text-align:left><code>Failed</code></td><td style=text-align:left>Semua kontainer dalan suatu Pod telah dihentikan, dan setidaknya ada satu kontainer yang terhenti karena kegagalan. Itu merupakan kontainer yang keluar dengan kode status bukan 0 atau dihentikan oleh sistem.</td></tr><tr><td style=text-align:left><code>Unknown</code></td><td style=text-align:left><em>State</em> suatu Pod tidak dapat diperoleh karena suatu alasan, biasanya karena kesalahan dalam komunikasi dengan <em>host</em> yang digunakan Pod tersebut.</td></tr></tbody></table><h2 id=kondisi-pod>Kondisi Pod</h2><p>Suatu Pod memiliki sebuah PodStatus, yang merupakan <em>array</em> dari <a href=/docs/reference/generated/kubernetes-api/v1.25/#podcondition-v1-core>PodConditions</a> yang telah atau belum dilewati oleh Pod. Setiap elemen dari <em>array</em> PodConditions mungkin memiliki enam <em>field</em> berikut:</p><ul><li><p><em>Field</em> <code>lastProbeTime</code> memberikan nilai <em>timestamp</em> yang menandakan kapan terakhir kali kondisi kondisi Pod diperiksa.</p></li><li><p><em>Field</em> <code>lastTransitionTime</code> memberikan nilai <em>timestamp</em> yang menandakan kapan terakhir kali Pod berubah status ke status lain.</p></li><li><p><em>Field</em> <code>message</code> adalah pesan yang bisa dibaca manusia yang mengidikasikan detail dari suatu transisi.</p></li><li><p><em>Field</em> <code>reason</code> adalah suatu alasan yang unik, satu kata, ditulis secara <em>CamelCase</em> untuk kondisi transisi terakhir.</p></li><li><p><em>Field</em> <code>status</code> adalah sebuah kata dengan kemungkinan nilainya berupa "<code>True</code>", "<code>False</code>", dan "<code>Unknown</code>".</p></li><li><p><em>Field</em> <code>type</code> adalah sebuah kata yang memiliki kemungkinan nilai sebagai berikut:</p><ul><li><code>PodScheduled</code>: Pod telah dijadwalkan masuk ke node;</li><li><code>Ready</code>: Pod sudah mampu menerima <em>request</em> masuk dan seharusnya sudah ditambahkan ke daftar pembagian beban kerja untuk servis yang sama;</li><li><code>Initialized</code>: Semua <a href=/id/docs/concepts/workloads/pods/init-containers>init containers</a> telah berjalan sempurna.</li><li><code>Unschedulable</code>: <em>scheduler</em> belum dapat menjadwalkan Pod saat ini, sebagai contoh karena kekurangan <em>resources</em> atau ada batasan-batasan lain.</li><li><code>ContainersReady</code>: Semua kontainer di dalam Pod telah siap.</li></ul></li></ul><h2 id=pemeriksaan-kontainer>Pemeriksaan Kontainer</h2><p>Sebuah <a href=/docs/reference/generated/kubernetes-api/v1.25/#probe-v1-core>Probe</a> adalah sebuah diagnosa yang dilakukan secara berkala oleh <a href=/docs/admin/kubelet/>kubelet</a> dalam suatu kontainer. Untuk melakukan diagnosa, kubelet memanggil sebuah <a href=https://godoc.org/k8s.io/kubernetes/pkg/api/v1#Handler>Handler</a> yang diimplementasikan oleh kontainer. Ada 3 tipe <em>Handler</em> yang tersedia, yaitu:</p><ul><li><p><a href=/docs/reference/generated/kubernetes-api/v1.25/#execaction-v1-core>ExecAction</a>: Mengeksekusi perintah tertentu di dalam kontainer. Diagnosa dikatakan berhasil jika perintah selesai dengan kode status 0.</p></li><li><p><a href=/docs/reference/generated/kubernetes-api/v1.25/#tcpsocketaction-v1-core>TCPSocketAction</a>: Melakukan pengecekan TCP terhadap alamat IP kontainer dengan <em>port</em> tertentu. Diagnosa dikatakan berhasil jika <em>port</em> tersebut terbuka.</p></li><li><p><a href=/docs/reference/generated/kubernetes-api/v1.25/#httpgetaction-v1-core>HTTPGetAction</a>: Melakukan sebuah <em>request</em> HTTP Get terhadap alamat IP kontainer dengan <em>port</em> dan <em>path</em> tertentu. Diagnosa dikatakan berhasil jika responnya memiliki kode status lebih besar atau sama dengan 200 dan kurang dari 400.</p></li></ul><p>Setiap pemeriksaan akan menghasilkan salah satu dari tiga hasil berikut:</p><ul><li><em>Success</em>: Kontainer berhasil melakukan diagnosa.</li><li><em>Failure</em>: Kontainer gagal melakukan diagnosa.</li><li><em>Unknown</em>: Gagal melakukan diagnosa, sehingga tidak ada aksi yang harus dilakukan.</li></ul><p><em>Kubelet</em> dapat secara optimal melakukan dan bereaksi terhadap dua jenis pemeriksaan yang sedang berjalan pada kontainer, yaitu:</p><ul><li><p><code>livenessProbe</code>: Ini menunjukkan apakah kontainer sedang berjalan. Jika tidak berhasil melakukan pemeriksaan terhadap <em>liveness</em> dari kontainer, maka kubelet akan mematikan kontainer, dan kontainer akan mengikuti aturan dari <a href=#restart-policy><em>restart policy</em></a>. Jika kontainer tidak menyediakan pemeriksaan terhadap <em>liveness</em>, maka nilai dari <em>state</em> adalah <code>Success</code>.</p></li><li><p><code>readinessProbe</code>: Ini menunjukan apakah kontainer sudah siap melayani <em>request</em>. Jika tidak berhasil melakukan pemeriksaan terhadap kesiapan dari kontainer, maka <em>endpoints controller</em> akan menghapus alamat IP Pod dari daftar semua <em>endpoint</em> untuk servis yang sama dengan Pod. Nilai awal <em>state</em> sebelum jeda awal adalah <code>Failure</code>. Jika kontainer tidak menyediakan pemeriksaan terhadap <em>readiness</em>, maka nilai awal <em>state</em> adalah <code>Success</code>.</p></li></ul><h3 id=kapan-sebaiknya-menggunakan-pemeriksaan-terhadap-liveness-atau-readiness>Kapan sebaiknya menggunakan pemeriksaan terhadap <em>liveness</em> atau <em>readiness</em>?</h3><p>Jika proses dalam kontainer mungkin gagal yang dikarenakan menghadapi suatu masalah
atau menjadi tidak sehat, maka pemeriksaan terhadap <em>liveness</em> tidak diperlukan.
Kubelet akan secara otomatis melakukan aksi yang tepat mengikuti <code>restartPolicy</code> dari Pod.</p><p>Jika kamu ingin kontainer bisa dimatikan dan dijalankan ulang ketika gagal melakukan
pemeriksaan, maka tentukan pemeriksaan <em>liveness</em> dan tentukan nilai <code>restartPolicy</code> sebagai <code>Always</code> atau <code>OnFailure</code>.</p><p>Jika kamu ingin mulai mengirim <em>traffic</em> ke Pod hanya ketika pemeriksaan berhasil,
maka tentukan pemeriksaan <em>readiness</em>. Dalam kasus ini, pemeriksaan <em>readiness</em> mungkin
akan sama dengan pemeriksaan <em>liveness</em>, tapi keberadaan pemeriksaan <em>readiness</em> dalam
<em>spec</em> berarti Pod akan tetap dijalankan tanpa menerima <em>traffic</em> apapun dan akan
mulai menerima <em>traffic</em> ketika pemeriksaan yang dilakukan mulai berhasil.
Jika kontainermu dibutuhkan untuk tetap berjalan ketika <em>loading</em> data yang besar,
<em>file</em> konfigurasi, atau melakukan migrasi ketika <em>startup</em>, maka tentukanlah pemeriksaan <em>readiness</em>.</p><p>Jika kamu ingin kontainermu dalam mematikan dirinya sendiri, kamu dapat menentukan
suatu pemeriksaan <em>readiness</em> yang melakukan pengecekan terhadap <em>endpoint</em> untuk <em>readiness</em>.
<em>endpoint</em> tersebut berbeda dengan <em>endpoint</em> untuk pengecekan <em>liveness</em>.</p><p>Perlu dicatat, jika kamu hanya ingin bisa menutup <em>request</em> ketika Pod sedang dihapus
maka kamu tidak perlu menggunakan pemeriksaan <em>readiness</em>. Dalam penghapusan, Pod akan
secara otomatis mengubah <em>state</em> dirinya menjadi <em>unready</em> tanpa peduli apakah terdapat
pemeriksaan <em>readiness</em> atau tidak. Pod tetap ada pada <em>state unready</em> selama menunggu
kontainer dalam Pod berhenti.</p><p>Untuk informasi lebih lanjut mengenai pengaturan pemeriksaan <em>liveness</em> atau <em>readiness</em>, lihat bagian
<a href=/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/>Konfigurasi <em>Liveness</em> dan <em>Readiness</em> <em>Probe</em></a>.</p><h2 id=status-pod-dan-kontainer>Status Pod dan Kontainer</h2><p>Untuk informasi lebih mendalam mengenai status Pod dan kontainer, silakan lihat
<a href=/docs/reference/generated/kubernetes-api/v1.25/#podstatus-v1-core>PodStatus</a>
dan
<a href=/docs/reference/generated/kubernetes-api/v1.25/#containerstatus-v1-core>ContainerStatus</a>.
Mohon diperhatikan, informasi tentang status Pod bergantung pada
<a href=/docs/reference/generated/kubernetes-api/v1.25/#containerstatus-v1-core>ContainerState</a>.</p><h2 id=state-kontainer>State Kontainer</h2><p>Ketika Pod sudah ditempatkan pada suatu node oleh scheduler, kubelet mulai membuat kontainer menggunakan <em>runtime</em> kontainer.
Ada tiga kemungkinan <em>state</em> untuk suatu kontainer, yaitu Waiting, Running, dan Terminated.
Untuk mengecek <em>state</em> suatu kontainer, kamu bisa menggunakan perintah <code>kubectl describe pod [NAMA_POD]</code>.
<em>State</em> akan ditampilkan untuk masing-masing kontainer dalam Pod tersebut.</p><ul><li><p><code>Waiting</code>: Merupakan <em>state</em> default dari kontainer. Jika <em>state</em> kontainer bukan Running atau Terminated, berarti dalam <em>Wating state</em>.
Suatu kontainer dalam Waiting <em>state</em> akan tetap menjalan operasi-operasi yang dibutuhkan, misalnya mengunduh <em>images</em>, mengaplikasikan Secrets, dsb.
Bersamaan dengan <em>state</em> ini, sebuah pesan dan alasan tentang <em>state</em> akan ditampilkan untuk memberi informasi lebih.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>State</span>:<span style=color:#bbb>          </span>Waiting<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span><span style=color:green;font-weight:700>Reason</span>:<span style=color:#bbb>       </span>ErrImagePull<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span></code></pre></div></li><li><p><code>Running</code>: Menandakan kontainer telah berjalan tanpa masalah. Setelah kontainer masuk ke <em>state</em> Running, jika terdapat <em>hook</em> <code>postStart</code> maka akan dijalankan. <em>State</em> ini juga menampilkan waktu ketika kontainer masuk ke <em>state</em> Running.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span><span style=color:green;font-weight:700>State</span>:<span style=color:#bbb>          </span>Running<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>Started</span>:<span style=color:#bbb>      </span>Wed, 30 Jan 2019 16:46:38 +0530<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div></li><li><p><code>Terminated</code>: Menandakan kontainer telah menyelesaikan "tugasnya". Kontainer akan menjadi <em>state</em> ini ketika telah menyelesaikan eksekusi atau terjadi kesalahan. Terlepas dari itu, sebuah alasan dan <em>exit code</em> akan ditampilkan, bersama dengan waktu kontainer mulai dijalankan dan waktu berhenti. Sebelum kontainer masuk ke <em>state</em> Terminated, jika terdapat <code>preStop</code> <em>hook</em> maka akan dijalankan.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span><span style=color:green;font-weight:700>State</span>:<span style=color:#bbb>          </span>Terminated<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>Reason</span>:<span style=color:#bbb>       </span>Completed<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>Exit Code</span>:<span style=color:#bbb>    </span><span style=color:#666>0</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>Started</span>:<span style=color:#bbb>      </span>Wed, 30 Jan 2019 11:45:26 +0530<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>Finished</span>:<span style=color:#bbb>     </span>Wed, 30 Jan 2019 11:45:26 +0530<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span>...<span style=color:#bbb>
</span></span></span></code></pre></div></li></ul><h2 id=pod-readiness-gate>Pod readiness gate</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.14 [stable]</code></div><p>Dalam rangka menambahkan ekstensibilitas terhadap kesiapan Pod dengan menggunakan
injeksi umpan balik tambahan atau sinyal ke dalam <code>PodStatus</code>,
Kubernetes 1.11 memperkenalkan sebuah fitur bernama <a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-network/0007-pod-ready%2B%2B.md>Pod ready++</a>.
Kamu dapat menggunakan <em>field</em> baru <code>ReadinessGate</code> dalam sebuah <code>PodSpec</code> untuk
menunjukan kondisi tambahan yang akan dievaluasi untuk kesiapan Pod. Jika Kubernetes
tidak dapat menemukan kondisi pada <em>field</em> <code>status.conditions</code> dalam suatu Pod,
maka statusnya akan secara otomatis menjadi <code>False</code>. Berikut adalah contoh pemakaiannya:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>Kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>readinessGates</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>conditionType</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;www.example.com/feature-1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>conditions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Ready <span style=color:#bbb> </span><span style=color:#080;font-style:italic># ini adalah PodCondition yang telah tersedia</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;False&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>lastProbeTime</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>null</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>lastTransitionTime</span>:<span style=color:#bbb> </span>2018-01-01T00:00:00Z<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;www.example.com/feature-1&#34;</span><span style=color:#bbb>   </span><span style=color:#080;font-style:italic># sebuah PodCondition tambahan</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;False&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>lastProbeTime</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>null</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>lastTransitionTime</span>:<span style=color:#bbb> </span>2018-01-01T00:00:00Z<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containerStatuses</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>containerID</span>:<span style=color:#bbb> </span>docker://abcd...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>ready</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Kondisi Pod yang baru harus memenuhi <a href=/id/docs/concepts/overview/working-with-objects/labels/#syntax-and-character-set>format label</a> pada Kubernetes.
Sejak perintah <code>kubectl patch</code> belum mendukung perubahan status objek, kondisi Pod yang baru harus mengubah melalui aksi <code>PATCH</code> dengan menggunakan
salah satu dari <a href=/docs/reference/using-api/client-libraries/>KubeClient <em>libraries</em></a>.</p><p>Dengan diperkenalkannya kondisi Pod yang baru, sebuah Pod akan dianggap siap hanya jika memenuhi dua syarat berikut:</p><ul><li>Semua kontainer dalam Pod telah siap.</li><li>Semua kontainer yang diatur dalam <code>ReadinessGates</code> bernilai "<code>True</code>".</li></ul><p>Untuk memfasilitasi perubahan tersebut terhadap evaluasi kesiapan Pod, dibuatkan sebuah kondisi Pod baru yaitu <code>ContainerReady</code>,
untuk dapat menangani kondisi Pod <code>Ready</code> yang sudah ada.</p><p>Dalam K8s 1.11, sebagai fitur <em>alpha</em>, fitur "Pod Ready++" harus diaktifkan melalui pengaturan
<a href=/docs/reference/command-line-tools-reference/feature-gates/>fitur <em>gate</em> pada <code>PodReadinessGates</code></a>.</p><p>Dalam K8s 1.12, fitur tersebut sudah diaktifkan dari awal.</p><h2 id=aturan-menjalankan-ulang>Aturan Menjalankan Ulang</h2><p>Sebuah PodSpec memiliki <em>field</em> <code>restartPolicy</code> dengan kemungkinan nilai berupa Always, OnFailure, dan Never.
Nilai awalnya berupa Always. <code>restartPolicy</code> akan berlaku untuk semua kontainer dalam Pod.
Kontainer yang mati dan dijalankan ulang oleh kubelet akan dijalankan ulang dengan jeda waktu yang ekponensial (10s, 20s, 40s, ...)
dengan batas atas senilai lima menit. Jeda waktu ini akan diatur ulang setelah sukses berjalan selama 10 menit.
Sesuai dengan diskusi pada <a href=/docs/user-guide/pods/#durability-of-pods-or-lack-thereof>dokumen Pod</a>,
setelah masuk ke suatu node, sebuah Pod tidak akan pindah ke node lain.</p><h2 id=umur-pod>Umur Pod</h2><p>Secara umum, Pod tidak hilang sampai ada yang menghapusnya. Ini mungkin dihapus oleh orang atau pengontrol.
Satu pengecualian untuk aturan ini adalah Pod dengan <code>phase</code> bernilai Succeeded atau Failed untuk waktu
beberapa lama yang akan berakhir dan secara otomatis akan dihapus.
(diatur dalam <code>terminated-pod-gc-threshold</code> pada master)</p><p>Tiga tipe pengontrol yang tersedia yaitu:</p><ul><li><p>Menggunakan sebuah <a href=/docs/concepts/jobs/run-to-completion-finite-workloads/>Job</a> untuk Pod yang diharapkan akan berakhir,
sebagai contoh, penghitungan dalam jumlah banyak. Jobs hanyak cocok untuk Pod dengan <code>restartPolicy</code> yang
bernilai OnFailure atau Never.</p></li><li><p>Menggunakan sebuah <a href=/id/docs/concepts/workloads/controllers/replicationcontroller/>ReplicationController</a>,
<a href=/id/docs/concepts/workloads/controllers/replicaset/>ReplicaSet</a>, atau
<a href=/id/docs/concepts/workloads/controllers/deployment/>Deployment</a> untuk Pod yang tidak diharapkan untuk berakhir,
sebagai contoh, <em>web servers</em>. ReplicationControllers hanya cocok digunakan pada Pod dengan <code>restartPolicy</code>
yang bernilai Always.</p></li><li><p>Menggunakan sebuah <a href=/id/docs/concepts/workloads/controllers/daemonset/>DaemonSet</a> untuk Pod yang akan berjalan
hanya satu untuk setiap mesin, karena menyediakan servis yang spesifik untuk suatu mesin.</p></li></ul><p>Ketiga tipe pengontrol ini memiliki sebuah PodTemplate. Direkomdasikan untuk membuat
pengontrol yang sesuai dan membiarkan ini membuat Pod, daripada membuat Pod sendiri secara langsung.
Karena Pod itu sendiri tidak tahan terhadap gagalnya suatu mesin, namun pengontrol tahan.</p><p>Jika node mati atau sambungannya terputus dari klaster, Kubernetes mengatur
<code>phase</code> dari semua Pod pada node yang mati untuk menjadi Failed.</p><h2 id=contoh>Contoh</h2><h3 id=contoh-liveness-probe-tingkat-lanjut>Contoh <em>Liveness Probe</em> tingkat lanjut</h3><p><em>Liveness probe</em> dieksekusi oleh kubelet, jadi semua permintaan akan dilakukan
di dalam <em>namespace</em> jaringan kubelet.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>test</span>:<span style=color:#bbb> </span>liveness<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>liveness-http<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- /server<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/liveness<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>livenessProbe</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>httpGet</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># ketika &#34;host&#34; tidak ditentukan, &#34;PodIP&#34; akan digunakan</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># host: my-host</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># ketika &#34;scheme&#34; tidak ditentukan, _scheme_ &#34;HTTP&#34; akan digunakan. Hanya &#34;HTTP&#34; and &#34;HTTPS&#34; yang diperbolehkan</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># scheme: HTTPS</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/healthz<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>httpHeaders</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>X-Custom-Header<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span>Awesome<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>initialDelaySeconds</span>:<span style=color:#bbb> </span><span style=color:#666>15</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>timeoutSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>liveness<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=contoh-state>Contoh <em>State</em></h3><ul><li><p>Pod sedang berjalan dan memiliki sebuah kontainer. Kontainer berhenti dengan sukses.</p><ul><li>Mencatat <em>event</em> penyelesaian.</li><li>Jika nilai <code>restartPolicy</code> adalah:<ul><li>Always: Jalankan ulang kontainer; nilai <code>phase</code> Pod akan tetap Running.</li><li>OnFailure: nilai <code>phase</code> Pod akan berubah menjadi Succeeded.</li><li>Never: nilai <code>phase</code> Pod akan berubah menjadi Succeeded.</li></ul></li></ul></li><li><p>Pod sedang berjalan dan memiliki sebuah kontainer. Kontainer berhenti dengan kegagalan.</p><ul><li>Mencatat <em>event</em> kegagalan.</li><li>Jika nilai <code>restartPolicy</code> adalah:<ul><li>Always: Jalankan ulang kontainer, nilai <code>phase</code> Pod akan tetap Running.</li><li>OnFailure: Jalankan ulang kontainer, nilai <code>phase</code> Pod akan tetap Running.</li><li>Never: nilai <code>phase</code> Pod akan menjadi Failed.</li></ul></li></ul></li><li><p>Pod sedang berjalan dan memiliki dua kontainer. Kontainer pertama berhenti dengan kegagalan.</p><ul><li>Mencatat <em>event</em> kegagalan.</li><li>Jika nilai <code>restartPolicy</code> adalah:<ul><li>Always: Jalankan ulang kontainer, nilai <code>phase</code> Pod akan tetap Running.</li><li>OnFailure: Jalankan ulang kontainer, nilai <code>phase</code> Pod akan tetap Running.</li><li>Never: Tidak akan menjalankan ulang kontainer, nilai <code>phase</code> Pod akan tetap Running.</li></ul></li><li>Jika kontainer pertama tidak berjalan dan kontainer kedua berhenti:<ul><li>Mencatat <em>event</em> kegagalan.</li><li>Jika nilai <code>restartPolicy</code> adalah:<ul><li>Always: Jalankan ulang kontainer, nilai <code>phase</code> Pod akan tetap Running.</li><li>OnFailure: Jalankan ulang kontainer, nilai <code>phase</code> Pod akan tetap Running.</li><li>Never: nilai <code>phase</code> Pod akan menjadi Failed.</li></ul></li></ul></li></ul></li><li><p>Pod sedang berjalan dan memiliki satu kontainer. Kontainer berhenti karena kehabisan <em>memory</em>.</p><ul><li>Kontainer diberhentikan dengan kegagalan.</li><li>Mencatat kejadian kehabisan <em>memory</em> (OOM)</li><li>Jika nilai <code>restartPolicy</code> adalah:<ul><li>Always: Jalankan ulang kontainer, nilai <code>phase</code> Pod akan tetap Running.</li><li>OnFailure: Jalankan ulang kontainer, nilai <code>phase</code> Pod akan tetap Running.</li><li>Never: Mencatat kejadian kegagalan, nilai <code>phase</code> Pod akan menjadi Failed.</li></ul></li></ul></li><li><p>Pod sedang berjalan dan sebuah <em>disk</em> mati.</p><ul><li>Menghentikan semua kontainer.</li><li>Mencatat kejadian yang sesuai.</li><li>Nilai <code>phase</code> Pod menjadi Failed.</li><li>Jika berjalan menggunakan pengontrol, maka Pod akan dibuat ulang di tempat lain.</li></ul></li><li><p>Pod sedang berjalan, dan node mengalami <em>segmented out</em>.</p><ul><li>Node pengontrol menunggu sampai suatu batas waktu.</li><li>Node pengontrol mengisi nilai <code>phase</code> Pod menjadi Failed.</li><li>Jika berjalan menggunakan pengontrol, maka Pod akan dibuat ulang di tempat lain.</li></ul></li></ul><h2 id=selanjutnya>Selanjutnya</h2><ul><li><p>Dapatkan pengalaman langsung mengenai
<a href=/docs/tasks/configure-pod-container/attach-handler-lifecycle-event/>penambahan <em>handlers</em> pada kontainer <em>lifecycle events</em></a>.</p></li><li><p>Dapatkan pengalaman langsung mengenai
<a href=/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/>pengaturan <em>liveness</em> dan <em>readiness probes</em></a>.</p></li><li><p>Pelajari lebih lanjut mengenai <a href=/id/docs/concepts/containers/container-lifecycle-hooks/><em>lifecycle hooks</em> pada kontainer</a>.</p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-1ccbd4eeded6ab138d98b59175bd557e>3.4.1.4 - Init Container</h1><p>Halaman ini menyediakan ikhtisar untuk Init Container, yaitu Container khusus yang dijalankan sebelum Container aplikasi dan berisi skrip peralatan atau <em>setup</em> yang tidak tersedia di dalam <em>image</em> dari Container aplikasi.</p><p>Fitur ini telah keluar dari trek Beta sejak versi 1.6. Init Container dapat dispesifikasikan di dalam PodSpec bersama dengan <em>array</em> <code>containers</code> aplikasi. Nilai anotasi <em>beta</em> akan tetap diperhitungkan dan akan menimpa nilai pada PodSpec, tetapi telah ditandai sebagai kedaluarsa pada versi 1.6 dan 1.7. Pada versi 1.8, anotasi <em>beta</em> tidak didukung lagi dan harus diganti menjadi nilai pada PodSpec.</p><h2 id=memahami-init-container>Memahami Init Container</h2><p>Sebuah <a href=/id/docs/concepts/workloads/pods/pod-overview/>Pod</a> dapat memiliki beberapa Container yang berjalan di dalamnya, dan dapat juga memiliki satu atau lebih Init Container, yang akan berjalan sebelum Container aplikasi dijalankan.</p><p>Init Container sama saja seperti Container biasa, kecuali:</p><ul><li>Mereka selalu berjalan hingga selesai.</li><li>Setiap Init Container harus selesai secara sukses sebelum Init Container berikutnya dijalankan.</li></ul><p>Jika sebuah Init Container tidak selesai secara sukses untuk sebuah Pod, Kubernetes akan mengulang kembali Pod tersebut secara terus menerus hingga Init Container selesai secara sukses. Tetapi, jika Pod tersebut memiliki nilai <code>restartPolicy</code> berupa <code>Never</code>, Pod tersebut tidak akan diulang kembali.</p><p>Untuk menspesifikasikan sebuah Container sebagai Init Container, tambahkan kolom <code>initContainers</code> pada PodSpec sebagai sebuah <em>array</em> JSON yang berisi objek dengan tipe <a href=/docs/reference/generated/kubernetes-api/v1.25/#container-v1-core>Container</a>, berdampingan dengan array <code>containers</code> aplikasi.
Status-status dari Init Container dikembalikan di kolom <code>.status.initContainerStatuses</code> sebagai sebuah <em>array</em> dari status-status Container (mirip seperti kolom <code>status.containerStatuses</code>)</p><h3 id=perbedaan-dengan-container-biasa>Perbedaan dengan Container biasa</h3><p>Init Container mendukung semua kolom dan fitur dari Container aplikasi, termasuk konfigurasi <code>limit</code> sumber daya, <code>volume</code>, dan keamanan. Tetapi, <code>request</code> dan <code>limit</code> sumber daya dari sebuah Init Container ditangani dengan cara yang sedikit berbeda, yang didokumentasikan di bagian <a href=#sumber-daya>Sumber Daya</a> di bawah. Juga, Init Container tidak mendukung <em>readiness probe</em> karena mereka harus berjalan hingga selesai sebelum Pod dapat siap.</p><p>Jika beberapa Init Container dispesifikasikan untuk sebuah Pod, Container-container tersebut akan dijalankan satu per satu secara berurutan. Setiap Init Container harus selesai secara sukses sebelum yang berikutnya dapat berjalan.
Saat semua Init Container telah berjalan hingga selesai, Kubernetes akan menginisialisasi Pod dan menjalankan Container aplikasi seperti biasa.</p><h2 id=apa-kegunaan-init-container>Apa kegunaan Init Container?</h2><p>Karena Init Container memiliki <em>image</em> yang berbeda dengan Container aplikasi, mereka memiliki beberapa kelebihan untuk kode yang berhubungan dengan dimulainya Init Container:</p><ul><li>Mereka dapat berisi dan menjalankan skrip peralatan yang tidak diinginkan untuk berada di dalam <em>image</em> Container aplikasi karena alasan keamanan.</li><li>Mereka dapat berisi skrip peralatan atau <em>setup</em> yang tidak tersedia di dalam <em>image</em> aplikasi. Misalnya, kita tidak perlu membuat <em>image</em> dengan instruksi <code>FROM</code> dari <em>image</em> lainnya hanya untuk menggunakan peralatan seperti <code>sed</code>, <code>awk</code>, <code>python</code>, atau <code>dig</code> pada saat <em>setup</em>.</li><li>Peran <em>builder</em> atau <em>deployer</em> dari <em>image</em> dapat bekerja secara independen tanpa harus digabung untuk membuat satu <em>image</em> aplikasi.</li><li>Mereka menggunakan <em>namespace</em> Linux, sehingga mereka dapat memiliki sudut pandang <em>filesystem</em> yang berbeda dengan Container aplikasi. Oleh karenanya, mereka dapat diberikan akses terhadap <code>Secret</code> yang tidak boleh diakses oleh Container aplikasi.</li><li>Mereka berjalan hingga selesai sebelum Container aplikasi manapun dimulai, sedangkan Container aplikasi dijalankan secara paralel, sehingga Init Container menyediakan cara yang mudah untuk menunda dijalankannya Container aplikasi hingga ketentuan-ketentuan yang diinginkan dipenuhi.</li></ul><h3 id=contoh-contoh>Contoh-contoh</h3><p>Berikut beberapa contoh kasus penggunaan Init Container:</p><ul><li><p>Menunggu sebuah Service untuk dibuat dengan perintah <em>shell</em> seperti:</p><pre><code>for i in {1..100}; do sleep 1; if dig myservice; then exit 0; fi; done; exit 1
</code></pre></li><li><p>Mendaftarkan suatu Pod ke sebuah peladen terpisah dari <em>downward API</em> dengan perintah seperti:</p><pre><code>`curl -X POST http://$MANAGEMENT_SERVICE_HOST:$MANAGEMENT_SERVICE_PORT/register -d 'instance=$(&lt;POD_NAME&gt;)&amp;ip=$(&lt;POD_IP&gt;)'`
</code></pre></li><li><p>Menunggu beberapa waktu sebelum menjalankan Container aplikasi dengan perintah seperti <code>sleep 60</code>.</p></li><li><p>Mengklon sebuah <em>git repository</em> ke dalam sebuah <em>volume</em>.</p></li><li><p>Menaruh nilai-nilai tertentu ke dalam sebuah <em>file</em> konfigurasi dan menjalankan peralatan <em>template</em> untuk membuat <em>file</em> konfigurasi secara dinamis untuk Container aplikasi utama. Misalnya, untuk menaruh nilai POD_IP ke dalam sebuah konfigurasi dan membuat konfigurasi aplikasi utama menggunakan Jinja.</p></li></ul><p>Contoh-contoh penggunaan yang lebih detail dapat dilihat pada <a href=/id/docs/concepts/workloads/controllers/statefulset/>dokumentasi StatefulSet</a> dan <a href=/docs/tasks/configure-pod-container/configure-pod-initialization/>petunjuk Produksi Pod</a>.</p><h3 id=menggunakan-init-container>Menggunakan Init Container</h3><p><em>File</em> YAML untuk Kubernetes 1.5 berikut menguraikan sebuah Pod sederhana yang memiliki dua buah Init Container.
Pod pertama menunggu <code>myservice</code> dan yang kedua menunggu <code>mydb</code>. Saat kedua Init Container tersebut sudah selesai, Podnya akan dijalankan.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myapp-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>myapp<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>pod.beta.kubernetes.io/init-containers</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;[
</span></span></span><span style=display:flex><span><span style=color:#b44>        {
</span></span></span><span style=display:flex><span><span style=color:#b44>            &#34;name&#34;: &#34;init-myservice&#34;,
</span></span></span><span style=display:flex><span><span style=color:#b44>            &#34;image&#34;: &#34;busybox:1.28&#34;,
</span></span></span><span style=display:flex><span><span style=color:#b44>            &#34;command&#34;: [&#39;</span>sh&#39;, &#39;-c&#39;, &#34;until nslookup myservice.$(cat /var/run/secrets/kubernetes.io/serviceaccount/namespace).svc.cluster.local; do echo waiting for myservice; sleep 2; done&#34;]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>},<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>&#34;name&#34;: </span><span style=color:#b44>&#34;init-mydb&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>&#34;image&#34;: </span><span style=color:#b44>&#34;busybox:1.28&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>&#34;command&#34;: </span>[<span style=color:#b44>&#39;sh&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;-c&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;until nslookup mydb.$(cat /var/run/secrets/kubernetes.io/serviceaccount/namespace).svc.cluster.local; do echo waiting for mydb; sleep 2; done&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>]<span style=color:#b44>&#39;
</span></span></span><span style=display:flex><span><span style=color:#b44>spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>  containers:
</span></span></span><span style=display:flex><span><span style=color:#b44>  - name: myapp-container
</span></span></span><span style=display:flex><span><span style=color:#b44>    image: busybox:1.28
</span></span></span><span style=display:flex><span><span style=color:#b44>    command: [&#39;</span>sh&#39;, &#39;-c&#39;, &#39;echo The app is running! &amp;&amp; sleep 3600&#39;]<span style=color:#bbb>
</span></span></span></code></pre></div><p>Ada sintaksis baru pada Kubernetes 1.6, walaupun sintaksis anotasi yang lama tetap akan bekerja untuk versi 1.6 dan 1.7. Sintaksis yang baru harus digunakan untuk versi 1.8 ke atas. Deklarasi Init Container dipindahkan ke dalam <code>spec</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myapp-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>myapp<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myapp-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#39;sh&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;-c&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;echo The app is running! &amp;&amp; sleep 3600&#39;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>initContainers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>init-myservice<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#39;sh&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;-c&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;until nslookup myservice; do echo waiting for myservice; sleep 2; done;&#39;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>init-mydb<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#39;sh&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;-c&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;until nslookup mydb; do echo waiting for mydb; sleep 2; done;&#39;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div><p>Sintaksis versi 1.5 tetap akan bekerja pada versi 1.6 dan 1.7, tetapi kami menyarankan untuk menggunakan sintaksis versi 1.6. Pada Kubernetes 1.6, Init Container dijadikan sebagai sebuah kolom di dalam API Kubernetes. Anotasi <em>beta</em> tetap akan diperhitungkan pada versi 1.6 dan 1.7, tetapi tidak didukung lagi pada versi 1.8 ke atas.</p><p><em>File</em> YAML di bawah menguraikan Service <code>mydb</code> dan <code>myservice</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myservice<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mydb<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9377</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Pod ini dapat dijalankan dan di-<em>debug</em> dengan menggunakan perintah berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f myapp.yaml
</span></span></code></pre></div><pre tabindex=0><code>pod/myapp-pod created
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get -f myapp.yaml
</span></span></code></pre></div><pre tabindex=0><code>NAME        READY     STATUS     RESTARTS   AGE
myapp-pod   0/1       Init:0/2   0          6m
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe -f myapp.yaml
</span></span></code></pre></div><pre tabindex=0><code>Name:          myapp-pod
Namespace:     default
[...]
Labels:        app=myapp
Status:        Pending
[...]
Init Containers:
  init-myservice:
[...]
    State:         Running
[...]
  init-mydb:
[...]
    State:         Waiting
      Reason:      PodInitializing
    Ready:         False
[...]
Containers:
  myapp-container:
[...]
    State:         Waiting
      Reason:      PodInitializing
    Ready:         False
[...]
Events:
  FirstSeen    LastSeen    Count    From                      SubObjectPath                           Type          Reason        Message
  ---------    --------    -----    ----                      -------------                           --------      ------        -------
  16s          16s         1        {default-scheduler }                                              Normal        Scheduled     Successfully assigned myapp-pod to 172.17.4.201
  16s          16s         1        {kubelet 172.17.4.201}    spec.initContainers{init-myservice}     Normal        Pulling       pulling image &#34;busybox&#34;
  13s          13s         1        {kubelet 172.17.4.201}    spec.initContainers{init-myservice}     Normal        Pulled        Successfully pulled image &#34;busybox&#34;
  13s          13s         1        {kubelet 172.17.4.201}    spec.initContainers{init-myservice}     Normal        Created       Created container with docker id 5ced34a04634; Security:[seccomp=unconfined]
  13s          13s         1        {kubelet 172.17.4.201}    spec.initContainers{init-myservice}     Normal        Started       Started container with docker id 5ced34a04634
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl logs myapp-pod -c init-myservice <span style=color:#080;font-style:italic># Memeriksa Init Container pertama</span>
</span></span><span style=display:flex><span>kubectl logs myapp-pod -c init-mydb      <span style=color:#080;font-style:italic># Memeriksa Init Container kedua</span>
</span></span></code></pre></div><p>Saat kita menjalankan Service <code>mydb</code> dan <code>myservice</code>, kita dapat melihat Init Container telah selesai dan <code>myapp-pod</code> pun dibuat:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f services.yaml
</span></span></code></pre></div><pre tabindex=0><code>service/myservice created
service/mydb created
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get -f myapp.yaml
</span></span><span style=display:flex><span>NAME        READY     STATUS    RESTARTS   AGE
</span></span><span style=display:flex><span>myapp-pod   1/1       Running   <span style=color:#666>0</span>          9m
</span></span></code></pre></div><p>Contoh ini sangat sederhana, tetapi dapat memberikan sedikit petunjuk bagi kamu untuk membuat Init Container sendiri.</p><h2 id=perilaku-mendetail>Perilaku mendetail</h2><p>Saat dimulainya sebuah Pod, Init Container dijalankan secara berurutan, setelah jaringan dan <em>volume</em> telah diinisialisasi. Setiap Init Container harus selesai dan keluar secara berhasil sebelum yang berikutnya dijalankan. Jika ada Init Container yang gagal dijalankan atau keluar secara gagal, dia akan diulang kembali sesuai dengan <code>restartPolicy</code> yang dimiliki Pod. Tetapi, jika <code>restartPolicy</code> Pod disetel dengan nilai <code>Always</code>, Init Container akan menggunakan strategi <code>RestartPolicy</code> <code>OnFailure</code>.</p><p>Sebuah Pod tidak dapat masuk ke status <code>Ready</code> hingga semua Init Container berhasil selesai. <em>Port</em> di sebuah Init Container tidak diagregasikan di dalam sebuah Service. Sebuah Pod yang sedang diinisalisasikan akan masuk ke dalam status <code>Pending</code>, tetapi akan memiliki kondisi <code>Initialized</code> yang disetel menjadi <code>true</code>.</p><p>Jika sebuah Pod diulang <a href=#alasan-pod-diulang-kembali>kembali</a>, semua Init Container harus dijalankan kembali.</p><p>Perubahan pada spesifikasi Init Container dibatasi hanya pada kolom <code>image</code> pada Init Container. Mengganti kolom <code>image</code> sebuah Init Container sama dengan mengulang kembali Pod tersebut.</p><p>Karena Init Container dapat diulang kembali, dicoba ulang, atau dijalankan ulang, Init Container sebaiknya bersifat <em>idempotent</em>. Khususnya, kode yang menulis ke dalam <em>file</em> pada <code>EmptyDir</code> sebaiknya dipersiapkan untuk menangani kemungkinan jika <em>file</em> keluaran yang diharapkan sudah ada di dalam <code>EmptyDir</code> tersebut.</p><p>Init Container memiliki semua kolom yang dimiliki oleh Container aplikasi. Tetapi, Kubernetes melarang penggunaan <code>readinessProbe</code> karena Init Container tidak dapat mendefinisikan/menggunakan <em>readiness probe</em> setelah selesai/keluar secara berhasil. Hal ini dipaksakan saat proses validasi.</p><p>Gunakan <code>activeDeadlineSeconds</code> pada Pod dan <code>livenessProbe</code> pada Container untuk mencegah Init Container gagal terus menerus. Nilai <code>activeDeadlineSeconds</code> berlaku juga terhadap Init Container.</p><p>Nama setiap Container aplikasi dan Init Container pada sebuah Pod haruslah unik; Kesalahan validasi akan terjadi jika ada Container atau Init Container yang memiliki nama yang sama.</p><h3 id=sumber-daya>Sumber Daya</h3><p>Karena eksekusi Init Container yang berurutan, aturan-aturan untuk sumber daya berlaku sebagai berikut:</p><ul><li>Yang tertinggi antara <code>request</code> atau <code>limit</code> sumber daya yang didefinisikan pada <strong>semua Init Container</strong> adalah <strong><code>request</code>/<code>limit</code> inisialisasi yang berlaku</strong>.</li><li><code>request</code>/<code>limit</code> sumber daya Pod yang berlaku adalah yang paling besar diantara:<ul><li>Jumah <code>request</code>/<code>limit</code> semua Container aplikasi untuk suatu sumber daya.</li><li><code>request</code>/<code>limit</code> inisialisasi yang berlaku untuk suatu sumber daya.</li></ul></li><li>Penjadwalan dilakukan berdasarkan <code>request</code>/<code>limit</code> (Pod) yang berlaku, yang berarti bahwa Init Container dapat mengambil sumber daya inisialisasi yang tidak digunakan selama umur Pod tersebut.</li><li><strong>Tingkat QoS yang berlaku</strong> milik Pod adalah sama dengan tingkat QoS untuk Init Container dan Container aplikasi.</li></ul><p><code>ResourceQuota</code> dan <code>limitedResources</code> diberlakukan berdasarkan <code>request</code> dan <code>limit</code> Pod yang berlaku.</p><p>Cgroup pada tingat Pod didasarkan pada <code>request</code> dan <code>limit</code> Pod yang berlaku, sama dengan <em>scheduler</em>.</p><h3 id=alasan-pod-diulang-kembali>Alasan Pod diulang kembali</h3><p>Pod dapat diulang kembali, yang berakibat pada diulangnya eksekusi Init Container, diakibatkan oleh beberapa alasan berikut:</p><ul><li>Seorang pengguna memperbarui <code>PodSpec</code>, mengakibatkan <code>image</code> Init Container berubah. Perubahan apapun pada <code>image</code> Init Container akan mengulang kembali Pod tersebut. Perubahan pada <code>image</code> Container aplikasi hanya mengulang kembali Container aplikasi yang bersangkutan.</li><li>Infrastruktur Container Pod diulang kembali. Hal ini jarang terjadi, dan hanya dapat dilakukan oleh seseorang yang memiliki akses <em>root</em> pada <em>node</em> yang bersangkutan.</li><li>Semua Container di dalam Pod diterminasi, dengan nilai <code>restartPolicy</code> yang disetel sebagai <code>Always</code>, memaksa pengulangan kembali, dan catatan selesainya Init Container telah hilang karena <em>garbage collection</em>.</li></ul><h2 id=dukungan-dan-kompatibilitas>Dukungan dan kompatibilitas</h2><p>Sebuah klaster dengan versi Apiserver 1.6.0 ke atas mendukung Init Container melalui kolom <code>.spec.initContainers</code>. Versi-versi sebelumnya mendukung Init Container melalui anotasi <em>alpha</em> atau <em>beta</em>. Kolom <code>.spec.initContainers</code> juga diduplikasikan dalam bentuk anotasi <em>alpha</em> dan <em>beta</em> agar Kubelet versi 1.3.0 ke atas dapat menjalankan Init Container, dan agar Apiserver versi 1.6 dapat dengan aman dikembalikan ke versi 1.5.x tanpa kehilangan fungsionalitas Pod-pod yang telah dibuat sebelumnya.</p><p>Pada Apiserver dan Kubelet versi 1.8.0 ke atas, dukungan untuk anotasi <em>alpha</em> dan <em>beta</em> telah dihapus, sehingga dibutuhkan konversi (manual) dari anotasi yang telah kedaluwarsa tersebut ke dalam bentuk kolom <code>.spec.initContainers</code>.</p><h2 id=selanjutnya>Selanjutnya</h2><ul><li><a href=/docs/tasks/configure-pod-container/configure-pod-initialization/#creating-a-pod-that-has-an-init-container>Membuat Pod yang memiliki Init Container</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-c8d62295ca703fdcef1aaf89fb4c916a>3.4.1.5 - Batasan Persebaran Topologi Pod</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.18 [beta]</code></div><p>Kamu dapat menggunakan batasan perseberan topologi (<em>topology spread constraints</em>)
untuk mengatur bagaimana <a class=glossary-tooltip title='Unit Kubernetes yang paling sederhana dan kecil. Sebuah Pod merepresentasikan sebuah set kontainer yang dijalankan pada kluster kamu.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a> akan disebarkan
pada klaster yang ditetapkan sebagai <em>failure-domains</em>, seperti wilayah, zona, Node dan domain
topologi yang ditentukan oleh pengguna. Ini akan membantu untuk mencapai ketersediaan yang tinggi
dan juga penggunaan sumber daya yang efisien.</p><h2 id=persyaratan>Persyaratan</h2><h3 id=mengaktifkan-gerbang-fitur>Mengaktifkan Gerbang Fitur</h3><p><a href=/docs/reference/command-line-tools-reference/feature-gates/>Gerbang fitur (<em>feature gate</em>)</a>
<code>EvenPodsSpread</code> harus diaktifkan untuk
<a class=glossary-tooltip title='Komponen control plane yang mengekspos API Kubernetes. Merupakan front-end dari control plane Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-apiserver/ target=_blank aria-label='API Server'>API Server</a> <strong>dan</strong>
<a class=glossary-tooltip title='Komponen control plane yang bertugas mengamati Pod baru yang belum ditempatkan di node manapun dan kemudian memilihkan node di mana Pod baru tersebut akan dijalankan.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-scheduler/ target=_blank aria-label='penjadwal (_scheduler_)'>penjadwal (_scheduler_)</a>.</p><h3 id=label-node>Label Node</h3><p>Batasan persebaran topologi bergantung dengan label pada Node untuk menentukan
domain topologi yang memenuhi untuk semua Node. Misalnya saja, sebuah Node bisa memiliki
label sebagai berikut: <code>node=node1,zone=us-east-1a,region=us-east-1</code></p><p>Misalkan kamu memiliki klaster dengan 4 Node dengan label sebagai berikut:</p><pre tabindex=0><code>NAME    STATUS   ROLES    AGE     VERSION   LABELS
node1   Ready    &lt;none&gt;   4m26s   v1.16.0   node=node1,zone=zoneA
node2   Ready    &lt;none&gt;   3m58s   v1.16.0   node=node2,zone=zoneA
node3   Ready    &lt;none&gt;   3m17s   v1.16.0   node=node3,zone=zoneB
node4   Ready    &lt;none&gt;   2m43s   v1.16.0   node=node4,zone=zoneB
</code></pre><p>Maka klaster tersebut secara logika akan dilihat sebagai berikut:</p><pre tabindex=0><code>+---------------+---------------+
|     zoneA     |     zoneB     |
+-------+-------+-------+-------+
| node1 | node2 | node3 | node4 |
+-------+-------+-------+-------+
</code></pre><p>Tanpa harus memberi label secara manual, kamu dapat menggunakan [label ternama]
(/docs/reference/kubernetes-api/labels-annotations-taints/) yang terbuat dan terkumpulkan
secara otomatis pada kebanyakan klaster.</p><h2 id=batasan-persebaran-untuk-pod>Batasan Persebaran untuk Pod</h2><h3 id=api>API</h3><p><em>Field</em> <code>pod.spec.topologySpreadConstraints</code> diperkenalkan pada versi 1.16 sebagai berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>topologySpreadConstraints</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>maxSkew</span>:<span style=color:#bbb> </span>&lt;integer&gt;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>minDomains</span>:<span style=color:#bbb> </span>&lt;integer&gt;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>topologyKey</span>:<span style=color:#bbb> </span>&lt;string&gt;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>whenUnsatisfiable</span>:<span style=color:#bbb> </span>&lt;string&gt;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>labelSelector</span>:<span style=color:#bbb> </span>&lt;object&gt;<span style=color:#bbb>
</span></span></span></code></pre></div><p>Kamu dapat mendefinisikan satu atau lebih <code>topologySpreadConstraint</code> untuk menginstruksikan
kube-scheduler mengenai cara peletakan tiap Pod baru dengan menggunakan kondisi Pod yang
sudah ada dalam klaster kamu. <em>Field</em> yang ada adalah:</p><ul><li><strong>maxSkew</strong> menentukan batasan yang menandakan Pod tidak tersebar secara merata.
Ini merupakan nilai maksimal dari selisih jumlah Pod yang sama untuk setiap 2 domain topologi
yang sama. Nilai ini harus lebih dari 0.</li><li><strong>topologyKey</strong> adalah kunci dari label Node. Jika terdapat dua Node memiliki label dengan
kunci ini dan memiliki nilai yang identik untuk label tersebut, maka penjadwal akan menganggap
kedua Noode dalam topologi yang sama. Penjadwal akan mencoba untuk menyeimbangkan jumlah Pod
dalam setiap domain topologi.</li><li><strong>whenUnsatisfiable</strong> mengindikasikan cara menangani Pod yang tidak memenuhi batasan persebaran:<ul><li><code>DoNotSchedule</code> (<em>default</em>) memberitahukan penjadwal untuk tidak menjadwalkan Pod tersebut.</li><li><code>ScheduleAnyway</code> memberitahukan penjadwal untuk tetap menjadwalkan Pod namun tetap menjaga ketidakseimbangan Node sekecil mungkin.</li></ul></li><li><strong>labelSelector</strong> digunakan untuk mencari Pod yang sesuai. Pod dengan label yang sama dengan ini akan dihitung untuk menentukan jumlah Pod dalam domain topologi yang sesuai. Silakan baca <a href=/id/docs/concepts/overview/working-with-objects/labels/#selektor-label>Label dan Selector</a> untuk lebih detailnya.</li></ul><p>Kamu juga bisa membaca lebih detail mengenai <em>field</em> ini dengan menjalankan perintah
<code>kubectl explain Pod.spec.topologySpreadConstraints</code>.</p><h3 id=contoh-satu-topologyspreadconstraint>Contoh: Satu TopologySpreadConstraint</h3><p>Misalkan kamu memiliki klaster dengan 4 Node dimana 3 Pod berlabel <code>foo:bar</code> terdapat pada node1,
node2 dan node3 (<code>P</code> merepresentasikan Pod):</p><pre tabindex=0><code>+---------------+---------------+
|     zoneA     |     zoneB     |
+-------+-------+-------+-------+
| node1 | node2 | node3 | node4 |
+-------+-------+-------+-------+
|   P   |   P   |   P   |       |
+-------+-------+-------+-------+
</code></pre><p>Jika kita ingin Pod baru akan disebar secara merata berdasarkan Pod yang telah ada pada semua zona,
maka <em>spec</em> bernilai sebagai berikut:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/pods/topology-spread-constraints/one-constraint.yaml download=pods/topology-spread-constraints/one-constraint.yaml><code>pods/topology-spread-constraints/one-constraint.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-topology-spread-constraints-one-constraint-yaml")' title="Copy pods/topology-spread-constraints/one-constraint.yaml to clipboard"></img></div><div class=includecode id=pods-topology-spread-constraints-one-constraint-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>foo</span>:<span style=color:#bbb> </span>bar<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>topologySpreadConstraints</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>maxSkew</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>topologyKey</span>:<span style=color:#bbb> </span>zone<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>whenUnsatisfiable</span>:<span style=color:#bbb> </span>DoNotSchedule<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>labelSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>foo</span>:<span style=color:#bbb> </span>bar<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pause<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/pause:3.1</span></span></code></pre></div></div></div><p><code>topologyKey: zone</code> berarti persebaran merata hanya akan digunakan pada Node dengan pasangan label
"zone: <nilai apapun>". <code>whenUnsatisfiable: DoNotSchedule</code> memberitahukan penjadwal untuk membiarkan
tetap ditunda jika Pod yang baru tidak memenuhi batasan yang diterapkan.</p><p>Jika penjadwal menempatkan Pod baru pada "zoneA", persebaran Pod akan menjadi [3, 1], menjadikan
ketidakseimbangan menjadi bernilai 2 (3 - 1), yang mana akan melanggar batasan <code>maxSkew: 1</code>.
Dalam contoh ini, Pod baru hanya dapat ditempatkan pada "zoneB":</p><pre tabindex=0><code>+---------------+---------------+      +---------------+---------------+
|     zoneA     |     zoneB     |      |     zoneA     |     zoneB     |
+-------+-------+-------+-------+      +-------+-------+-------+-------+
| node1 | node2 | node3 | node4 |  OR  | node1 | node2 | node3 | node4 |
+-------+-------+-------+-------+      +-------+-------+-------+-------+
|   P   |   P   |   P   |   P   |      |   P   |   P   |  P P  |       |
+-------+-------+-------+-------+      +-------+-------+-------+-------+
</code></pre><p>Kamu dapat mengatur spesifikasi Pod untuk memenuhi beberapa persyaratan berikut:</p><ul><li>Ubah nilai <code>maxSkew</code> menjadi lebih besar, misal "2", sehingga Pod baru dapat ditempatkan pada "zoneA".</li><li>Ubah nilai <code>topologyKey</code> menjadi "node" agar Pod disebarkan secara merata pada semua Node, bukan zona. Pada contoh di atas, jika <code>maxSkew</code> tetap bernilai "1", maka Pod baru hanya akan ditempatkan pada "node4".</li><li>Ubah nilai <code>whenUnsatisfiable: DoNotSchedule</code> menjadi <code>whenUnsatisfiable: ScheduleAnyway</code> untuk
menjamin agar semua Pod baru akan tetap dijadwalkan (misalkan saja API penjadwalan lain tetap
terpenuhi). Namun, ini lebih suka ditempatkan pada domain topologi yang memiliki lebih sedikit
Pod yang sesuai. (Harap diperhatikan bahwa preferensi ini digabungkan bersama dengan prioritas
penjadwalan internal yang lain, seperti rasio penggunaan sumber daya, dan lain sebagainya.)</li></ul><h3 id=contoh-beberapa-topologyspreadconstraint>Contoh: Beberapa TopologySpreadConstraint</h3><p>Ini dibuat berdasarkan contoh sebelumnya. Misalkan kamu memiliki klaster dengan 4 Node dengan
3 Pod berlabel <code>foo:bar</code> yang ditempatkan pada node1, node2 dan node3. (<code>P</code> merepresentasikan Pod):</p><pre tabindex=0><code>+---------------+---------------+
|     zoneA     |     zoneB     |
+-------+-------+-------+-------+
| node1 | node2 | node3 | node4 |
+-------+-------+-------+-------+
|   P   |   P   |   P   |       |
+-------+-------+-------+-------+
</code></pre><p>Kamu dapat menggunakan 2 TopologySpreadConstraint untuk mengatur persebaran Pod pada zona dan Node:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/pods/topology-spread-constraints/two-constraints.yaml download=pods/topology-spread-constraints/two-constraints.yaml><code>pods/topology-spread-constraints/two-constraints.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-topology-spread-constraints-two-constraints-yaml")' title="Copy pods/topology-spread-constraints/two-constraints.yaml to clipboard"></img></div><div class=includecode id=pods-topology-spread-constraints-two-constraints-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>foo</span>:<span style=color:#bbb> </span>bar<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>topologySpreadConstraints</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>maxSkew</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>topologyKey</span>:<span style=color:#bbb> </span>zone<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>whenUnsatisfiable</span>:<span style=color:#bbb> </span>DoNotSchedule<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>labelSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>foo</span>:<span style=color:#bbb> </span>bar<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>maxSkew</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>topologyKey</span>:<span style=color:#bbb> </span>node<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>whenUnsatisfiable</span>:<span style=color:#bbb> </span>DoNotSchedule<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>labelSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>foo</span>:<span style=color:#bbb> </span>bar<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pause<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/pause:3.1</span></span></code></pre></div></div></div><p>Dalam contoh ini, untuk memenuhi batasan pertama, Pod yang baru hanya akan ditempatkan pada "zoneB",
sedangkan untuk batasan kedua, Pod yang baru hanya akan ditempatkan pada "node4". Maka hasil dari
2 batasan ini akan digunakan (<em>AND</em>), sehingga opsi untuk menempatkan Pod hanya pada "node4".</p><p>Beberapa batasan dapat berujung pada konflik. Misalnya saja kamu memiliki klaster dengan 3 Node
pada 2 zona berbeda:</p><pre tabindex=0><code>+---------------+-------+
|     zoneA     | zoneB |
+-------+-------+-------+
| node1 | node2 | node3 |
+-------+-------+-------+
|  P P  |   P   |  P P  |
+-------+-------+-------+
</code></pre><p>Jika kamu menerapkan "two-constraints.yaml" pada klaster ini, kamu akan mendapatkan "mypod" tetap
dalam kondisi <code>Pending</code>. Ini dikarenakan oleh: untuk memenuhi batasan pertama, "mypod" hanya dapat
ditempatkan pada "zoneB", sedangkan untuk batasan kedua, "mypod" hanya dapat ditempatkan pada
"node2". Tidak ada hasil penggabungan dari "zoneB" dan "node2".</p><p>Untuk mengatasi situasi ini, kamu bisa menambahkan nilai <code>maxSkew</code> atau mengubah salah satu dari
batasan untuk menggunakan <code>whenUnsatisfiable: ScheduleAnyway</code>.</p><h3 id=konvensi>Konvensi</h3><p>Ada beberapa konvensi implisit yang perlu diperhatikan di sini:</p><ul><li><p>Hanya Pod dengan Namespace yang sama dengan Pod baru yang bisa menjadi kandidat yang cocok.</p></li><li><p>Node tanpa memiliki <code>topologySpreadConstraints[*].topologyKey</code> akan dilewatkan. Ini berarti:</p><ol><li>Pod yang ditempatkan pada Node tersebut tidak berpengaruh pada perhitungan <code>maxSkew</code>. Dalam contoh di atas, misalkan "node1" tidak memiliki label "zone", maka kedua Pod tidak diperhitungkan dan menyebabkan Pod yang baru akan dijadwalkan masuk ke "zoneA".</li><li>Pod yang baru tidak memiliki kesempatan untuk dijadwalkan ke Node tersebut, pada contoh di atas, misalkan terdapat "node5" dengan label <code>{zone-typo: zoneC}</code> bergabung dalam klaster, Node ini akan dilewatkan karena tidak memiliki label dengan kunci "zone".</li></ol></li><li><p>Harap diperhatikan mengenai hal yang terjadi jika nilai <code>topologySpreadConstraints[*].labelSelector</code> pada Pod yang baru tidak sesuai dengan labelnya.
Pada contoh di atas, jika kita menghapus label pada Pod yang baru, maka Pod akan tetap ditempatkan
pada "zoneB" karena batasan yang ada masih terpenuhi. Namun, setelah ditempatkan, nilai
ketidakseimbangan pada klaster masih tetap tidak berubah, zoneA tetap memiliki 2 Pod dengan label
{foo:bar} dan zoneB memiliki 1 Pod dengan label {foo:bar}. Jadi jika ini tidak yang kamu harapkan,
kami menyarankan nilai dari <code>topologySpreadConstraints[*].labelSelector</code> disamakan dengan labelnya.</p></li><li><p>Jika Pod yang baru memiliki <code>spec.nodeSelector</code> atau <code>spec.affinity.nodeAffinity</code>, Node yang tidak
sesuai dengan nilai tersebut akan dilewatkan.</p><p>Misalkan kamu memiliki klaster dengan 5 Node dari zoneA sampai zoneC:</p><pre tabindex=0><code>+---------------+---------------+-------+
|     zoneA     |     zoneB     | zoneC |
+-------+-------+-------+-------+-------+
| node1 | node2 | node3 | node4 | node5 |
+-------+-------+-------+-------+-------+
|   P   |   P   |   P   |       |       |
+-------+-------+-------+-------+-------+
</code></pre><p>dan kamu mengetahui bahwa "zoneC" harus tidak diperhitungkan. Dalam kasus ini, kamu dapat membuat
berkas yaml seperti di bawah, jadi "mypod" akan ditempatkan pada "zoneB", bukan "zoneC".
Demikian juga <code>spec.nodeSelector</code> akan digunakan.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/pods/topology-spread-constraints/one-constraint-with-nodeaffinity.yaml download=pods/topology-spread-constraints/one-constraint-with-nodeaffinity.yaml><code>pods/topology-spread-constraints/one-constraint-with-nodeaffinity.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-topology-spread-constraints-one-constraint-with-nodeaffinity-yaml")' title="Copy pods/topology-spread-constraints/one-constraint-with-nodeaffinity.yaml to clipboard"></img></div><div class=includecode id=pods-topology-spread-constraints-one-constraint-with-nodeaffinity-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>foo</span>:<span style=color:#bbb> </span>bar<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>topologySpreadConstraints</span>:<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>maxSkew</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>topologyKey</span>:<span style=color:#bbb> </span>zone<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>whenUnsatisfiable</span>:<span style=color:#bbb> </span>DoNotSchedule<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>labelSelector</span>:<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>foo</span>:<span style=color:#bbb> </span>bar<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>affinity</span>:<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>nodeAffinity</span>:<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requiredDuringSchedulingIgnoredDuringExecution</span>:<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>nodeSelectorTerms</span>:<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>zone<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>NotIn<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- zoneC<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pause<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/pause:3.1</span></span></code></pre></div></div></div></li></ul><h3 id=batasan-default-pada-tingkat-klaster>Batasan <em>default</em> pada tingkat klaster</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.18 [alpha]</code></div><p>Ini memungkinkan untuk mengatur batasan persebaran topologi bawaan untuk klaster.
Batasan persebaran topologi bawaan akan digunakan pada Pod jika dan hanya jika:</p><ul><li>Hal ini tidak mendefinisikan batasan apapun pada <code>.spec.topologySpreadConstraints</code>.</li><li>Hal ini milik sebuah Service, ReplicationController, ReplicaSet atau StatefulSet.</li></ul><p>Batasan bawaan akan diatur sebagai bagian dari argumen pada <em>plugin</em> <code>PodTopologySpread</code>
di dalam sebuah <a href=/docs/reference/scheduling/profiles>profil penjadwalan</a>.
Batasan dispesifikasikan dengan <a href=#api>API yang sama dengan di atas</a>, kecuali bagian <code>labelSelector</code>
harus kosong. <em>selector</em> akan dihitung dari Service, ReplicationController, ReplicaSet atau
StatefulSet yang dimiliki oleh Pod tersebut.</p><p>Sebuah contoh konfigurasi sebagai berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubescheduler.config.k8s.io/v1alpha2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>KubeSchedulerConfiguration<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>profiles</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>pluginConfig</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>PodTopologySpread<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>defaultConstraints</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- <span style=color:green;font-weight:700>maxSkew</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>topologyKey</span>:<span style=color:#bbb> </span>topology.kubernetes.io/zone<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>whenUnsatisfiable</span>:<span style=color:#bbb> </span>ScheduleAnyway<span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Nilai yang dihasilkan oleh batasan penjadwalan bawaan mungkin akan konflik dengan
nilai yang dihasilkan oleh
<a href=/docs/reference/scheduling/profiles/#scheduling-plugins><code>DefaultPodTopologySpread</code> plugin</a>.
Direkomendasikan untuk kamu menonaktifkan <em>plugin</em> ini dalam profil penjadwalan ketika
menggunakan batasan <em>default</em> untuk <code>PodTopologySpread</code>.</div><h2 id=perbandingan-dengan-podaffinity-podantiaffinity>Perbandingan dengan PodAffinity/PodAntiAffinity</h2><p>Di Kubernetes, arahan yang terkait dengan "Afinitas" mengontrol bagaimana Pod dijadwalkan -
lebih terkumpul atau lebih tersebar.</p><ul><li>Untuk <code>PodAffinity</code>, kamu dapat mencoba mengumpulkan beberapa Pod ke dalam suatu
domain topologi yang memenuhi syarat.</li><li>Untuk <code>PodAntiAffinity</code>, hanya satu Pod yang dalam dijadwalkan pada sebuah domain topologi.</li></ul><p>Fitur "EvenPodsSpread" memberikan opsi fleksibilas untuk mendistribusikan Pod secara merata
pada domain topologi yang berbeda, untuk meraih ketersediaan yang tinggi atau menghemat biaya.
Ini juga dapat membantu saat perbaruan bergilir dan menaikan jumlah replika dengan lancar.
Silakan baca <a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-scheduling/20190221-even-pods-spreading.md#motivation>motivasi</a> untuk lebih detail.</p><h2 id=limitasi-yang-diketahui>Limitasi yang diketahui</h2><p>Pada versi 1.18, dimana fitur ini masih Beta, beberapa limitasi yang sudah diketahui:</p><ul><li>Pengurangan jumlah Deployment akan membuat ketidakseimbangan pada persebaran Pod.</li><li>Pod yang cocok pada <em>tainted</em> Node akan dihargai. Lihat <a href=https://github.com/kubernetes/kubernetes/issues/80921>Issue 80921</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-4e9b9cbc9776b12e7335c53da377c9c8>3.4.1.6 - Pod Preset</h1><p>Halaman ini menyajikan gambaran umum tentang PodPreset, yang merupakan objek untuk memasukkan informasi tertentu ke dalam Pod pada saat waktu penciptaan. Informasi dapat berupa <em>secret</em>, <em>volume</em>, <em>volume mount</em>, dan variabel <em>environment</em>.</p><h2 id=memahami-pod-preset>Memahami Pod Preset</h2><hr><p>Sebuah <code>Pod Preset</code> adalah sebuah <em>resource</em> API untuk memasukkan kebutuhan <em>runtime</em> tambahan ke dalam sebuah Pod pada saat waktu penciptaan. Kamu akan menggunakan <em>label selector</em> untuk menunjuk Pod dimana Pod Preset diterapkan.</p><p>Menggunakan sebuah Pod Preset memungkinkan pembuat templat pod untuk tidak menyediakan secara eksplisit semua informasi untuk setiap pod. Dengan demikian, pembuat templat pod yang mengkonsumsi sebuah <em>service</em> spesifik tidak perlu tahu semua detail-detail tentang <em>service</em> tersebut.</p><p>Untuk informasi lebih lanjut mengenai latar belakang lihat <a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/service-catalog/pod-preset.md>proposal desain untuk PodPreset</a>.</p><h2 id=bagaimana-cara-kerja-pod-preset>Bagaimana Cara Kerja Pod Preset</h2><hr><p>Kubernetes menyediakan sebuah <em>admission controller</em> (<code>PodPreset</code>) dimana, ketika diaktifkan, PodPreset diterapkan kepada permintaan penciptaan Pod yang akan datang. Ketika sebuah penciptaan Pod terjadi, sistem melakukan hal-hal berikut:</p><ol><li>Mengambil semua <code>PodPreset</code> yang tersedia untuk digunakan.</li><li>Cek jika <em>label selector</em> dari salah satu <code>PodPreset</code> cocok dengan <em>label</em> pada pod yang sedang diciptakan.</li><li>Usaha untuk menggabungkan berbagai <em>resource</em> didefinisikan oleh <code>PodPreset</code> ke dalam Pod yang sedang diciptakan.</li><li>Ketika terjadi galat, lempar sebuah <em>event</em> yang mendokumentasikan galat penggabungan dalam pod, dan membuat pod tanpa salah satu <em>resource</em> dari <code>PodPreset</code>.</li><li>Anotasikan hasil spesifikasi Pod yang telah dimodifikasi untuk menunjukkan bahwa Pod telah dimodifikasi oleh sebuah PodPreset. Anotasi berupa <code>podpreset.admission.kubernetes.io/podpreset-&lt;nama pod-preset>: "&lt;versi resource>"</code>.</li></ol><p>Tiap Pod akan bisa dipasangkan oleh nol atau lebih PodPreset; dan tiap PodPreset bisa diterapkan ke nol atau lebih Pod. Ketika sebuah PodPreset diterapkan ke satu atau lebih Pod, Kubernetes memodifikasi Pod Spec. Untuk perubahan terhadap <code>Env</code>,<code>EnvFrom</code>, dan <code>VolumeMount</code>, Kubernetes memodifikasi spesifikasi kontainer untuk semua kontainer di dalam Pod; Untuk perubahan terhadap <code>Volume</code>, Kubernetes memodifikasi Pod Spec.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Sebuah Pod Preset mampu memodifikasi kolom <code>.spec.containers</code> pada sebuah Pod Spec jika sesuai. Tidak ada definisi resource dari Pod Preset yang akan diterapkan kepada kolom <code>initContainer</code>.</div><h3 id=menonaktifkan-pod-preset-untuk-sebuah-pod-spesifik>Menonaktifkan Pod Preset untuk sebuah Pod Spesifik</h3><p>Mungkin akan ada keadaan dimana kamu menginginkan sebuah Pod tidak bisa diubah oleh sebuah mutasi PodPreset. Pada kasus ini, kamu bisa menambahkan sebuah anotasi pada Pod Spec dalam bentuk: <code>podpreset.admission.kubernetes.io/exclude: "true"</code>.</p><h2 id=mengaktifkan-pod-preset>Mengaktifkan Pod Preset</h2><hr><p>Dalam rangka untuk menggunakan Pod Preset di dalam klaster kamu, kamu harus memastikan hal berikut:</p><ol><li><p>Kamu telah mengaktifkan tipe API <code>settings.k8s.io/v1alpha1/podpreset</code>. Sebagai contoh, ini bisa dilakukan dengan menambahkan <code>settings.k8s.io/v1alpha1=true</code> di dalam opsi <code>--runtime-config</code> untuk API <em>server</em>. Dalam <em>minikube</em> tambahkan argumen berikut <code>--extra-config=apiserver.runtime-config=settings.k8s.io/v1alpha1=true</code> saat menginisialisasi klaster.</p></li><li><p>Kamu telah mengaktifkan <em>admission controller</em> dari <code>PodPreset</code>. Salah satu cara untuk melakukannya adalah dengan menambahkan <code>PodPreset</code> di dalam nilai opsi <code>--enable-admission-plugins</code> yang dispesifikasikan untuk API <em>server</em>. Dalam <em>minikube</em> tambahkan argumen berikut</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>--extra-config<span style=color:#666>=</span>apiserver.enable-admission-plugins<span style=color:#666>=</span>NamespaceLifecycle,LimitRanger,ServiceAccount,DefaultStorageClass,DefaultTolerationSeconds,NodeRestriction,MutatingAdmissionWebhook,ValidatingAdmissionWebhook,ResourceQuota,PodPreset
</span></span></code></pre></div><p>saat menginisialisasi klaster.</p></li><li><p>Kamu telah membuat objek <code>PodPreset</code> pada <em>namespace</em> yang kamu gunakan dengan cara mendefinisikan Pod Preset.</p></li></ol><h2 id=selanjutnya>Selanjutnya</h2><ul><li><a href=/id/docs/concepts/workloads/pods/pod/#injecting-data-into-a-pod-using-podpreset.md>Memasukkan data ke dalam sebuah Pod dengan PodPreset</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-4aaf43c715cd764bc8ed4436f3537e68>3.4.1.7 - Disrupsi</h1><p>Petunjuk ini ditujukan pada pemilik aplikasi yang meninginkan aplikasinya memiliki ketersediaan yang tinggi, sehingga butuh untuk mengerti jenis-jenis Disrupsi yang dapat terjadi pada Pod-pod.</p><p>Petunjuk ini juga ditujukan pada administrator klaster yang ingin melakukan berbagai tindakan otomasi pada klaster, seperti pembaruan dan <em>autoscaling</em> klaster.</p><h2 id=disrupsi-yang-disengaja-dan-tidak-disengaja>Disrupsi yang Disengaja dan Tidak Disengaja</h2><p>Pod-pod tidak akan terhapus sampai sesuatu (orang ataupun <em>pengendali</em>) menghancurkan mereka atau ada kesalahan perangkat keras maupun perangkat lunak yang tidak dapat dihindari.</p><p>Kita menyebut kasus-kasus yang tidak dapat dihindari sebagai <strong>disrupsi yang tidak disengaja</strong> terhadap aplikasi. Beberapa contohnya adalah sebagai berikut:</p><ul><li>Kesalahan perangkat keras pada mesin yang menjalankan Node</li><li>Administrator klaster menghapus <em>virtual machine</em> secara tidak sengaja</li><li>Kesalahan pada penyedia layanan <em>cloud</em> yang mengakibatkan terhapusnya <em>virtual machine</em></li><li>Sebuah <em>kernel panic</em></li><li>Node menghilang dari klaster karena partisi jaringan klaster</li><li>Pod mengalami <em>eviction</em> karena Node <a href=/docs/tasks/administer-cluster/out-of-resource>kehabisan sumber daya</a></li></ul><p>Dengan pengecualian pada kondisi kehabisan sumber daya, kondisi-kondisi tersebut pada umumnya diketahui oleh kebanyakan pengguna karena kondisi-kondisi tersebut tidak spesifik pada Kubernetes saja.</p><p>Kita menyebut kasus-kasus lainnya sebagai <strong>disrupsi yang disengaja</strong>. Hal ini termasuk tindakan yang dilakukan oleh pemilik aplikasi atau yang dilakukan oleh administrator klaster. Pemilik aplikasi umumnya melakukan hal-hal berikut:</p><ul><li>Menghapus Deployment atau pengendali yang mengatur Pod</li><li>Memperbarui templat Pod yang menyebabkan pengulangan kembali/<em>restart</em></li><li>Menghapus Pod secara langsung</li></ul><p>Administrator klaster umumnya melakukan hal-hal berikut:</p><ul><li><a href=/docs/tasks/administer-cluster/safely-drain-node/>Melakukan <em>drain</em> terhadap Node</a> untuk perbaikan atau pembaruan.</li><li>Melakukan <em>drain</em> terhadap sebuah node dari klaster untuk memperkecil ukuran klaster (untuk lebih lanjutnya, pelajari <a href=/docs/tasks/administer-cluster/cluster-management/#cluster-autoscaler><em>Autoscaling</em> klaster</a>).</li><li>Menghapus sebuah Pod dari node untuk memuat Pod lain ke node tersebut.</li></ul><p>Tindakan-tindakan tersebut dapat dilakukan secara langsung oleh administrator klaster, atau oleh alat otomasi yang dijalankan oleh administrator klaster, atau oleh penyedia layanan Kubernetes kamu.</p><p>Tanyakan administrator klaster atau penyedia layanan <em>cloud</em> kamu, atau lihatlah dokumentasi penyedia layanan Kubernetes kamu untuk mengetahui bila ada sumber-sumber yang berpotensi mengakibatkan disrupsi yang disengaja yang ada pada klastermu. Jika tidak ada, kamu bisa melewatkan pembuatan <em>PodDisruptionBudget</em></p><div class="alert alert-warning caution callout" role=alert><strong>Perhatian:</strong> Tidak semua disrupsi yang disengaja dibatasi oleh Pod Disruption Budget. Contohnya, menghapus Deployment atau Pod dapat mengabaikan PodDisruptionBudget.</div><h2 id=mengatasi-disrupsi>Mengatasi Disrupsi</h2><p>Berikut beberapa cara untuk mengatasi disrupsi yang tidak disengaja:</p><ul><li>Pastikan Pod-pod kamu <a href=/docs/tasks/configure-Pod-container/assign-cpu-ram-container>merinci permintaan sumber daya klaster</a> yang dibutuhkan.</li><li>Replikasikan aplikasimu jika membutuhkan ketersediaan yang tinggi. (Pelajari tentang menjalankan aplikasi
<a href=/docs/tasks/run-application/run-stateless-application-deployment/><em>stateless</em></a> dan <a href=/docs/tasks/run-application/run-replicated-stateful-application/><em>stateful</em></a>).</li><li>Untuk mencapai ketersediaan yang bahkan lebih tinggi lagi saat mereplikasikan aplikasi, sebarkanlah Pod-pod kamu di rak-rak pada <em>data center</em> (menggunakan <a href=/docs/user-guide/node-selection/#inter-Pod-affinity-and-anti-affinity-beta-feature><em>anti-affinity</em></a>) atau di seluruh zona (jika kamu menggunakan <a href=/docs/setup/multiple-zones>klaster pada beberapa zona</a>).</li></ul><p>Frekuensi disrupsi yang disengaja dapat berubah-ubah. Pada klaster Kubernetes yang dasar, tidak ada disrupsi yang disengaja sama sekali. Tetapi, administrator klaster atau penyedia layanan Kubernetes kamu mungkin saja menjalankan beberapa servis tambahan yang dapat mengakibatkan disrupsi yang disengaja. Misalnya, memperbarui perangkat lunak pada node yang dapat mengakibatkan disrupsi yang disengaja. Selain itu, beberapa implementasi <em>autoscaling</em> klaster (atau node) dapat mengakibatkan disrupsi yang disengaja untuk merapikan dan memadatkan node-node pada klaster.
Administrator klaster atau penyedia layanan Kubernetes kamu perlu mendokumentasikan tingkatan disrupsi yang disengaja, jika ada disrupsi yang telah diperkirakan.</p><p>Kubernetes menawarkan fitur-fitur untuk membantu menjalankan aplikasi-aplikasi dengan ketersediaan tinggi bersamaan dengan seringnya disrupsi yang disengaja, fitur-fitur tersebut dinamai <em>Disruption Budget</em>.</p><h2 id=bagaimana-cara-kerja-disruption-budget>Bagaimana cara kerja <em>Disruption Budget</em></h2><p>Pemilik aplikasi dapat membuat objek <code>PodDisruptionBudget</code> (PDB) untuk setiap aplikasi. Sebuah PDB membatasi jumlah Pod yang boleh mati secara bersamaan pada aplikasi yang direplikasi dikarenakan disrupsi yang disengaja.
Misalnya, sebuah aplikasi yang bekerja secara <em>quorum</em> mau memastikan bahwa jumlah replika yang berjalan tidak jatuh ke bawah yang dibutuhkan untuk membentuk sebuah <em>quorum</em>. Contoh lainnya, sebuah <em>front-end</em> web mungkin perlu memastikan bahwa jumlah replika yang melayani trafik tidak pernah turun ke total persentase yang telah ditentukan.</p><p>Administrator klaster dan penyedia layanan Kubernetes sebaiknya menggunakan alat-alat yang menghormati PDB dengan cara berkomunikasi dengan <a href=/docs/tasks/administer-cluster/safely-drain-node/#the-eviction-api>Eviction API</a> dari pada menghapus Pod atau Deployment secara langsung. Contohnya adalah perintah <code>kubectl drain</code> dan skrip pembaruan Kubernetes-on-GCE (<code>cluster/gce/upgrade.sh</code>)</p><p>Saat seorang administrator klaster ingin melakukan <em>drain</em> terhadap sebuah node, ia akan menggunakan perintah <code>kubectl drain</code>. Alat tersebut mencoba untuk "mengusir" semua Pod di node tersebut. Permintaan untuk mengusir Pod tersebut mungkin ditolak untuk sementara, dan alat tersebut akan mencoba ulang permintaannya secara periodik hingga semua Pod dihapus, atau hingga batas waktu yang ditentukan telah dicapai.</p><p>Sebua PDB merinci jumlah replika yang dapat ditoleransi oleh sebuah aplikasi, relatif terhadap berapa banyak yang seharusnya dimiliki oleh aplikasi tersebut. Sebagai contoh, sebuah Deployment yang memiliki rincian <code>.spec.replicas :5</code> diharapkan memiliki 5 Pod pada satu waktu. Jika PDB aplikasi tersebut mengizinkan ada 4 replika pada satu waktu, maka Eviction API akan mengizinkan disrupsi yag disengaja sebanyak satu, tapi tidak mengizinkan dua, pada satu waktu.</p><p>Sebuah kelompok Pod yang mewakili aplikasi dispesifikasikan menggunakan sebuah <em>label selector</em> yang sama dengan yang digunakan oleh pengatur aplikasi tersebut (Deployment, StatefulSet, dsb.)</p><p>Jumlah Pod yang "diharapkan" dihitung dari <code>.spec.replicas</code> dari pengendali Pod tersebut. Pengendali dari sebuah Pod dapat ditemukan di spesifikasi <code>.metadata.ownerReferences</code> objek Pod yang bersangkutan.</p><p>PDB tidak dapat mencegah <a href=#disrupsi-yang-disengaja-dan-tidak-disengaja>disrupsi yang tidak disengaja</a>, tapi disrupsi ini akan dihitung terhadap bujet PDB.</p><p>Pod yang dihapus atau tidak tersetia dikarenakan pembaruan bertahap juga dihitung terhadap bujet PDB, tetapi pengendali (seperti Deployment dan StatefulSet) tidak dibatasi oleh PDB ketika melakukan pembaruan bertahap; Penanganan kerusakan saat pembaruan aplikasi dikonfigurasikan pada spesifikasi pengendali. (Pelajari tentang <a href=/id/docs/concepts/workloads/controllers/deployment/#updating-a-deployment>memperbarui sebuah Deployment</a>.)</p><p>Saat sebuah Pod diusir menggunakan <em>eviction API</em>, Pod tersebut akan dihapus secara <em>graceful</em> (lihat <code>terminationGracePeriodSeconds</code> pada <a href=/docs/reference/generated/kubernetes-api/v1.25/#Podspec-v1-core>PodSpec</a>.))</p><h2 id=contoh-pdb>Contoh PDB</h2><p>Kita ambil contoh sebuah klaster dengan 3 node, <code>node-1</code> hingga <code>node-3</code>.
Klaster tersebut menjalankan beberapa aplikasi. Salah satu dari aplikasi tersebut awalnya memiliki 3 replika, yang akan kita namai <code>Pod-a</code>, <code>Pod-b</code>, dan <code>Pod-c</code>. Sebuah Pod lain yang tidak bersangkutan dan tidak memiliki PDB, dinamai <code>Pod-x</code> juga terlihat. Awalnya, Pod-pod tersebut berada pada node-node sebagai berikut:</p><table><thead><tr><th style=text-align:center>node-1</th><th style=text-align:center>node-2</th><th style=text-align:center>node-3</th></tr></thead><tbody><tr><td style=text-align:center>Pod-a <em>available</em></td><td style=text-align:center>Pod-b <em>available</em></td><td style=text-align:center>Pod-c <em>available</em></td></tr><tr><td style=text-align:center>Pod-x <em>available</em></td><td style=text-align:center></td><td style=text-align:center></td></tr></tbody></table><p>3 Pod <code>Pod-a</code> hingga <code>Pod-c</code> adalah bagian dari sebuah Deployment, dan mereka secara kolektif memiliki sebuah PDB yang mengharuskan ada setidaknya 2 dari 3 Pod untuk tersedia sepanjang waktu.</p><p>Sebagai contoh, asumsikan administrator klaster ingin me-<em>reboot</em> ke dalam versi kernel baru untuk memperbaiki kesalahan di dalam kernel lama. Administator klaster pertama-tama mencoba untuk melakukan <em>drain</em> terhadap <code>node-1</code> menggunakan perintah <code>kubectl drain</code>. Perintah tersebut mencoba untuk mengusir <code>Pod-a</code> dan <code>Pod-x</code>. Hal ini langsung berhasil. Kedua Pod tersebut masuk ke dalam kondisi <code>terminating</code> secara bersamaan. Hal ini mengubah kondisi klaster menjadi sebagai berikut:</p><table><thead><tr><th style=text-align:center>node-1 <em>draining</em></th><th style=text-align:center>node-2</th><th style=text-align:center>node-3</th></tr></thead><tbody><tr><td style=text-align:center>Pod-a <em>terminating</em></td><td style=text-align:center>Pod-b <em>available</em></td><td style=text-align:center>Pod-c <em>available</em></td></tr><tr><td style=text-align:center>Pod-x <em>terminating</em></td><td style=text-align:center></td><td style=text-align:center></td></tr></tbody></table><p>Deployment tersebut melihat bahwa salah satu Pod berada dalam kondisi <code>terminating</code>, sehingga Deployment mencoba untuk membuat penggantinya, <code>Pod-d</code>. Sejak <code>node-1</code> ditutup (karena perintah <code>kubectl-drain</code>), <code>Pod-d</code> masuk ke node lainnya. Sesuatu juga membuat <code>Pod-y</code> sebagai pengganti <code>Pod-x</code></p><p>(Catatan: untuk sebuah StatefulSet, <code>Pod-a</code>, akan dinamai dengan <code>Pod-1</code>, harus diterminasi hingga selesai sebelum penggantinya, yang juga dinamai <code>Pod-1</code> tetapi memiliki UID yang berbeda, akan dibuat. Selain hal ini, seluruh contoh ini juga berlaku untuk StatefulSet.)</p><p>Sekarang, klaster berada pada kondisi berikut:</p><table><thead><tr><th style=text-align:center>node-1 <em>draining</em></th><th style=text-align:center>node-2</th><th style=text-align:center>node-3</th></tr></thead><tbody><tr><td style=text-align:center>Pod-a <em>terminating</em></td><td style=text-align:center>Pod-b <em>available</em></td><td style=text-align:center>Pod-c <em>available</em></td></tr><tr><td style=text-align:center>Pod-x <em>terminating</em></td><td style=text-align:center>Pod-d <em>starting</em></td><td style=text-align:center>Pod-y</td></tr></tbody></table><p>Pada satu waktu, Pod-pod yang diusir pun selesai diterminasi, dan kondisi klaster menjadi seperti berikut:</p><table><thead><tr><th style=text-align:center>node-1 <em>drained</em></th><th style=text-align:center>node-2</th><th style=text-align:center>node-3</th></tr></thead><tbody><tr><td style=text-align:center></td><td style=text-align:center>Pod-b <em>available</em></td><td style=text-align:center>Pod-c <em>available</em></td></tr><tr><td style=text-align:center></td><td style=text-align:center>Pod-d <em>starting</em></td><td style=text-align:center>Pod-y</td></tr></tbody></table><p>Pada titik ini, jika seorang administrator klaster yang tidak sabar mencoba untuk melakukan <em>drain</em> terhadap <code>node-2</code> atau <code>node-3</code>, perintah untuk melakukan <em>drain</em> terhadap node tersebut akan terhalang, karena hanya ada 2 Pod yang tersedia, dan PDB-nya membutuhkan setidaknya ada 2 Pod tersedia. Setelah beberapa waktu, <code>Pod-d</code> menjadi tersedia.</p><p>Kondisi klaster menjadi seperti berikut:</p><table><thead><tr><th style=text-align:center>node-1 <em>drained</em></th><th style=text-align:center>node-2</th><th style=text-align:center>node-3</th></tr></thead><tbody><tr><td style=text-align:center></td><td style=text-align:center>Pod-b <em>available</em></td><td style=text-align:center>Pod-c <em>available</em></td></tr><tr><td style=text-align:center></td><td style=text-align:center>Pod-d <em>available</em></td><td style=text-align:center>Pod-y</td></tr></tbody></table><p>Sekarang, administrator klaster mencoba untuk melakukan <em>drain</em> terhadap <code>node-2</code>. Perintah <em>drain</em> tersebut akan mencoba mengusir Pod-pod tersebut secara berurutan (tidak bersamaan), misalnya <code>Pod-b</code> yang pertama dan diikuti dengan <code>Pod-d</code>. Perintah tersebut akan berhasil mengusir <code>Pod-b</code>. Tetapi, pada saat ia mencoba untuk mengusir <code>Pod-d</code>, hal tersebut akan ditolak karena hal tersebut akan mengakibatkan hanya satu Pod yang tersedia untuk Deployment yang bersangkutan.</p><p>Deployment tersebut membuat pengganti <code>Pod-b</code> yang dinamai <code>Pod-e</code>.
Karena tidak ada sumber daya klaster yang cukup untuk mengalokasikan <code>Pod-e</code>, proses <em>drain</em> akan kembali terhalang.
Klaster mungkin berada pada kondisi berikut:</p><table><thead><tr><th style=text-align:center>node-1 <em>drained</em></th><th style=text-align:center>node-2</th><th style=text-align:center>node-3</th><th style=text-align:center><em>no node</em></th></tr></thead><tbody><tr><td style=text-align:center></td><td style=text-align:center>Pod-b <em>available</em></td><td style=text-align:center>Pod-c <em>available</em></td><td style=text-align:center>Pod-e <em>pending</em></td></tr><tr><td style=text-align:center></td><td style=text-align:center>Pod-d <em>available</em></td><td style=text-align:center>Pod-y</td><td style=text-align:center></td></tr></tbody></table><p>Pada titik ini, administrator klaster mesti menambah sebuah node untuk klaster agar bisa melanjutkan pembaruan klaster.</p><p>Kamu dapat melihat bagaimana frekuensi disrupsi dapat berubah-ubah pada Kubernetes, tergantung pada:</p><ul><li>Berapa banyak replika yang dibutuhkan sebuah aplikasi</li><li>Berapa lama waktu yang dibutuhkan untuk mematikan sebuah Pod secara <em>graceful</em></li><li>Berapa lama waktu yang dibutuhkan untuk memulai sebuah Pod</li><li>Tipe pengendali</li><li>Kapasitas sumber daya klaster</li></ul><h2 id=memisahkan-peran-pemilik-klaster-dan-pemilik-aplikasi>Memisahkan Peran Pemilik Klaster dan Pemilik Aplikasi</h2><p>Seringkali akan bermanfaat untuk berpikir Administrator Klaster dan Pemilik Aplikasi sebagai peran yang terpisah dan dengan pengetahuan yang terbatas satu sama lainnya. Pemisahan ini dapat dimengerti dalam beberapa skenario berikut:</p><ul><li>Saat ada banyak tim aplikasi yang berbagi pakai sebuah klaster Kubernetes, dan ada pembagian peran yang spesifik</li><li>Saat alat atau servis pihak ketiga digunakan untuk melakukan otomasi manajemen klaster.</li></ul><p>PDB mendukung pemisahan peran ini dengan cara menyediakan antarmuka bagi peran-peran tersebut.</p><p>Jika kamu tidak memiliki pemisahan peran seperti ini pada organisasimu, kamu mungkin tidak membutuhkan PDB.</p><h2 id=bagaimana-cara-melakukan-tindakan-disruptif-terhadap-klaster>Bagaimana cara melakukan Tindakan Disruptif terhadap Klaster</h2><p>Jika kamu adalah Administrator Klaster, maka kamu mesti melakukan tindakan disruptif pada setiap node di klastermu, seperti melakukan pembaruan perangkat lunak pada node, berikut beberapa opsinya:</p><ul><li>Menerima <em>downtime</em> pada saat pembaruan node</li><li>Melakukan <em>failover</em> ke replika lengkap klaster lain.<ul><li>Tanpa <em>downtime</em>, tetapi mungkin lebih mahal, baik ongkos duplikasi node-node dan tenaga yang dibutuhkan untuk melakukan <em>failover</em>.</li></ul></li><li>Membuat aplikasi yang toleran terhadap disrupsi, dan gunakan PDB.<ul><li>Tanpa <em>downtime</em>.</li><li>Duplikasi sumber daya yang minimal.</li><li>Mengizinkan lebih banyak otomasi administrasi klaster.</li><li>Membuat aplikasi yang toleran terhadap disrupsi agak rumit, tetapi usaha yang dilakukan untuk menoleransi disrupsi yang disengaja kebanyakan beririsan dengan usaha untuk mendukung <em>autoscaling</em> dan menoleransi disrupsi yang tidak disengaja.</li></ul></li></ul><h2 id=selanjutnya>Selanjutnya</h2><ul><li><p>Ikuti langkah-langkah untuk melindungi aplikasimu dengan <a href=/docs/tasks/run-application/configure-pdb/>membuat sebuah PodDisruptionBudget</a>.</p></li><li><p>Pelajari lebih lanjut mengenai <a href=/docs/tasks/administer-cluster/safely-drain-node/>melakukan <em>drain</em> terhadap node</a>.</p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-53a1005011e1bda2ce81819aad7c8b32>3.4.1.8 - Kontainer Sementara (Ephemeral)</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.16 [alpha]</code></div><p>Halaman ini memberikan gambaran umum tentang kontainer sementara: satu jenis
kontainer khusus yang berjalan sementara pada <a class=glossary-tooltip title='Unit Kubernetes yang paling sederhana dan kecil. Sebuah Pod merepresentasikan sebuah set kontainer yang dijalankan pada kluster kamu.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>
yang sudah ada untuk melakukan tindakan yang diinisiasi oleh pengguna seperti
dalam pemecahan masalah. Kamu menggunakan kontainer sementara untuk memeriksa
layanan bukan untuk membangun aplikasi.</p><div class="alert alert-danger warning callout" role=alert><strong>Peringatan:</strong> Kontainer sementara masih berada dalam fase alpha dan tidak cocok untuk
klaster produksi. Kamu harus mengharapkan adanya suatu fitur yang tidak akan
berfungsi dalam beberapa situasi tertentu, seperti saat menargetkan <em>namespace</em>
dari suatu kontainer. Sesuai dengan Kubernetes
<a href=/docs/reference/using-api/deprecation-policy/><em>Deprecation Policy</em></a>, fitur alpha
ini dapat berubah secara signifikan di masa depan atau akan dihapus seluruhnya.</div><h2 id=memahami-kontainer-sementara>Memahami Kontainer Sementara</h2><p><a class=glossary-tooltip title='Unit Kubernetes yang paling sederhana dan kecil. Sebuah Pod merepresentasikan sebuah set kontainer yang dijalankan pada kluster kamu.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a> adalah blok pembangun
fundamental dalam aplikasi Kubernetes. Karena Pod diharapkan digunakan hanya
sekali dan dapat diganti, sehingga kamu tidak dapat menambahkan kontainer ke
dalam Pod setelah Pod tersebut dibuat. Sebaliknya, kamu biasanya menghapus dan
mengganti beberapa Pod dengan cara yang terkontrol melalui
<a class=glossary-tooltip title='Mengelola aplikasi yang direplikasi di dalam klastermu.' data-toggle=tooltip data-placement=top href=/id/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Deployment>Deployment</a>.</p><p>Namun, kadang-kadang perlu juga untuk memeriksa keadaan Pod yang telah ada,
sebagai contoh untuk memecahkan masalah <em>bug</em> yang sulit direproduksi. Dalam
kasus ini, kamu dapat menjalankan sebuah kontainer sementara di dalam suatu Pod
yang sudah ada untuk memeriksa statusnya dan menjalankannya segala macam
perintah.</p><h3 id=apa-itu-kontainer-sementara>Apa itu Kontainer Sementara?</h3><p>Kontainer sementara berbeda dengan kontainer lainnya karena tidak memiliki
jaminan sumber daya maupun akan eksekusi, dan mereka tidak akan pernah secara
otomatis melakukan <em>restart</em>, jadi mereka tidak sesuai untuk membangun aplikasi.
Kontainer sementara dideskripsikan dengan menggunakan ContainerSpec yang sama
dengan kontainer biasa, tetapi banyak bagian yang tidak kompatibel dan tidak
diperbolehkan untuk kontainer sementara.</p><ul><li>Kontainer sementara mungkin tidak memiliki port, sehingga bagian seperti
<code>port</code>, <code>livenessProbe</code>, <code>readinessProbe</code> tidak diperbolehkan.</li><li>Alokasi sumber daya untuk Pod tidak dapat diubah, sehingga pengaturan
sumber daya tidak diperbolehkan.</li><li>Untuk daftar lengkap bagian yang diperbolehkan, dapat di lihat
<a href=/docs/reference/generated/kubernetes-api/v1.25/#ephemeralcontainer-v1-core>referensi dokumentasi Kontainer Sementara</a>.</li></ul><p>Kontainer sementara dibuat dengan menggunakan <em>handler</em> khusus
EphemeralContainers dalam API tanpa menambahkannya langsung ke <code>pod.spec</code>,
sehingga tidak memungkinan untuk menambahkan kontainer sementara dengan
menggunakan <code>kubectl edit</code>.</p><p>Seperti dengan kontainer biasa, kamu tidak dapat mengubah atau menghapus
kontainer sementara setelah kamu memasukkannya ke dalam sebuah Pod.</p><h2 id=penggunaan-kontainer-sementara>Penggunaan Kontainer Sementara</h2><p>Kontainer sementara berguna untuk pemecahan masalah secara interaktif pada saat
<code>kubectl exec</code> tidak mencukupi karena sebuah kontainer telah hancur atau
kontainer <em>image</em> tidak memiliki utilitas untuk <em>debugging</em>.</p><p>Khususnya, untuk <a href=https://github.com/GoogleContainerTools/distroless><em>images_distroless</em></a>
memungkinkan kamu untuk menyebarkan kontainer <em>image</em> minimal yang mengurangi
<em>surface attack</em> dan paparan <em>bug</em> dan <em>vulnerability</em>. Karena
<em>image distroless</em> tidak mempunyai sebuah <em>shell</em> atau utilitas <em>debugging</em> apa
pun, sehingga sulit untuk memecahkan masalah <em>image distroless</em> dengan
menggunakan <code>kubectl exec</code> saja.</p><p>Saat menggunakan kontainer sementara, akan sangat membantu untuk mengaktifkan
<a href=/id/docs/tasks/configure-pod-container/share-process-namespace/><em>process namespace sharing</em></a>
sehingga kamu dapat melihat proses pada kontainer lain.</p><h3 id=contoh>Contoh</h3><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Contoh-contoh pada bagian ini membutuhkan <code>EphemeralContainers</code> <a href=/docs/reference/command-line-tools-reference/feature-gates/>feature
gate</a> untuk
diaktifkan, dan membutuhkan Kubernetes klien dan server versi v1.16 atau
yang lebih baru.</div><p>Contoh-contoh pada bagian ini menunjukkan bagaimana kontainer sementara muncul
dalam API. Kamu biasanya dapat menggunakan plugin <code>kubectl</code> untuk mengatasi
masalah untuk mengotomatiskan langkah-langkah ini.</p><p>Kontainer sementara dibuat menggunakan <em>subresource</em> <code>ephemeralcontainers</code>
Pod, yang dapat didemonstrasikan menggunakan <code>kubectl --raw</code>. Pertama-tama
deskripsikan kontainer sementara untuk ditambahkan dalam daftar
<code>EphemeralContainers</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;v1&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;EphemeralContainers&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;metadata&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;example-pod&#34;</span>
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;ephemeralContainers&#34;</span>: [{
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;command&#34;</span>: [
</span></span><span style=display:flex><span>            <span style=color:#b44>&#34;sh&#34;</span>
</span></span><span style=display:flex><span>        ],
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;image&#34;</span>: <span style=color:#b44>&#34;busybox&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;imagePullPolicy&#34;</span>: <span style=color:#b44>&#34;IfNotPresent&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;debugger&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;stdin&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>,
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;tty&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>,
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;terminationMessagePolicy&#34;</span>: <span style=color:#b44>&#34;File&#34;</span>
</span></span><span style=display:flex><span>    }]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Untuk memperbarui kontainer yang sudah berjalan dalam <code>example-pod</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl replace --raw /api/v1/namespaces/default/pods/example-pod/ephemeralcontainers  -f ec.json
</span></span></code></pre></div><p>Ini akan menampilkan daftar baru dari seluruh kontainer sementara:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>   <span style=color:green;font-weight:700>&#34;kind&#34;</span>:<span style=color:#b44>&#34;EphemeralContainers&#34;</span>,
</span></span><span style=display:flex><span>   <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>:<span style=color:#b44>&#34;v1&#34;</span>,
</span></span><span style=display:flex><span>   <span style=color:green;font-weight:700>&#34;metadata&#34;</span>:{
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;name&#34;</span>:<span style=color:#b44>&#34;example-pod&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;namespace&#34;</span>:<span style=color:#b44>&#34;default&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;selfLink&#34;</span>:<span style=color:#b44>&#34;/api/v1/namespaces/default/pods/example-pod/ephemeralcontainers&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;uid&#34;</span>:<span style=color:#b44>&#34;a14a6d9b-62f2-4119-9d8e-e2ed6bc3a47c&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;resourceVersion&#34;</span>:<span style=color:#b44>&#34;15886&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;creationTimestamp&#34;</span>:<span style=color:#b44>&#34;2019-08-29T06:41:42Z&#34;</span>
</span></span><span style=display:flex><span>   },
</span></span><span style=display:flex><span>   <span style=color:green;font-weight:700>&#34;ephemeralContainers&#34;</span>:[
</span></span><span style=display:flex><span>      {
</span></span><span style=display:flex><span>         <span style=color:green;font-weight:700>&#34;name&#34;</span>:<span style=color:#b44>&#34;debugger&#34;</span>,
</span></span><span style=display:flex><span>         <span style=color:green;font-weight:700>&#34;image&#34;</span>:<span style=color:#b44>&#34;busybox&#34;</span>,
</span></span><span style=display:flex><span>         <span style=color:green;font-weight:700>&#34;command&#34;</span>:[
</span></span><span style=display:flex><span>            <span style=color:#b44>&#34;sh&#34;</span>
</span></span><span style=display:flex><span>         ],
</span></span><span style=display:flex><span>         <span style=color:green;font-weight:700>&#34;resources&#34;</span>:{
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>         },
</span></span><span style=display:flex><span>         <span style=color:green;font-weight:700>&#34;terminationMessagePolicy&#34;</span>:<span style=color:#b44>&#34;File&#34;</span>,
</span></span><span style=display:flex><span>         <span style=color:green;font-weight:700>&#34;imagePullPolicy&#34;</span>:<span style=color:#b44>&#34;IfNotPresent&#34;</span>,
</span></span><span style=display:flex><span>         <span style=color:green;font-weight:700>&#34;stdin&#34;</span>:<span style=color:#a2f;font-weight:700>true</span>,
</span></span><span style=display:flex><span>         <span style=color:green;font-weight:700>&#34;tty&#34;</span>:<span style=color:#a2f;font-weight:700>true</span>
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>   ]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Kamu dapat melihat kondisi kontainer sementara yang baru dibuat dengan
menggunakan <code>kubectl describe</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe pod example-pod
</span></span></code></pre></div><pre tabindex=0><code>...
Ephemeral Containers:
  debugger:
    Container ID:  docker://cf81908f149e7e9213d3c3644eda55c72efaff67652a2685c1146f0ce151e80f
    Image:         busybox
    Image ID:      docker-pullable://busybox@sha256:9f1003c480699be56815db0f8146ad2e22efea85129b5b5983d0e0fb52d9ab70
    Port:          &lt;none&gt;
    Host Port:     &lt;none&gt;
    Command:
      sh
    State:          Running
      Started:      Thu, 29 Aug 2019 06:42:21 +0000
    Ready:          False
    Restart Count:  0
    Environment:    &lt;none&gt;
    Mounts:         &lt;none&gt;
...
</code></pre><p>Kamu dapat mengakses kontainer sementara yang baru menggunakan
<code>kubectl attach</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl attach -it example-pod -c debugger
</span></span></code></pre></div><p>Jika proses berbagi <em>namespace</em> diaktifkan, kamu dapat melihat proses dari semua
kontainer dalam Pod tersebut. Misalnya, setelah mengakses, kamu jalankan
<code>ps</code> di kontainer <em>debugger</em>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Jalankan ini pada _shell_ dalam _debugger_ dari kontainer sementara</span>
</span></span><span style=display:flex><span>ps auxww
</span></span></code></pre></div><p>Hasilnya akan seperti ini:</p><pre tabindex=0><code>PID   USER     TIME  COMMAND
    1 root      0:00 /pause
    6 root      0:00 nginx: master process nginx -g daemon off;
   11 101       0:00 nginx: worker process
   12 101       0:00 nginx: worker process
   13 101       0:00 nginx: worker process
   14 101       0:00 nginx: worker process
   15 101       0:00 nginx: worker process
   16 101       0:00 nginx: worker process
   17 101       0:00 nginx: worker process
   18 101       0:00 nginx: worker process
   19 root      0:00 /pause
   24 root      0:00 sh
   29 root      0:00 ps auxww
</code></pre></div><div class=td-content style=page-break-before:always><h1 id=pg-89637410cacae45a36ab1cc278c482eb>3.4.2 - Controllers</h1></div><div class=td-content><h1 id=pg-d459b930218774655fa7fd1620625539>3.4.2.1 - ReplicaSet</h1><p>Tujuan dari ReplicaSet adalah untuk memelihara himpunan stabil dari replika Pod yang sedang berjalan pada satu waktu tertentu. Maka dari itu, ReplicaSet seringkali digunakan untuk menjamin ketersediaan dari beberapa Pod identik dalam jumlah tertentu.</p><h2 id=cara-kerja-replicaset>Cara kerja ReplicaSet</h2><p>Sebuah ReplicaSet didefinisikan dengan beberapa <em>field</em> termasuk selektor yang menentukan bagaimana mengidentifikasi Pod yang dapat diakuisisi, jumlah replika yang mengindikasi berapa jumlah Pod yang harus dikelola, dan sebuah templat pod yang menentukan data dari berbagai Pod baru yang harus dibuat untuk memenuhi kriteria jumlah replika. Sebuah ReplicaSet selanjutnya akan memenuhi tujuannya dengan membuat dan menghapus Pod sesuai dengan kebutuhan untuk mencapai jumlah yang diinginkan. Ketika ReplicaSet butuh untuk membuat Pod baru, templat Pod akan digunakan.</p><p>Tautan dari sebuah ReplicaSet terhadap Pod yang dimiliki adalah melalui <em>field</em> <a href=https://kubernetes.io/docs/concepts/workloads/controllers/garbage-collection/#owners-and-dependents>metadata.ownerReferences</a> pada Pod, yang menentukan sumber daya yang dimiliki oleh objek saat ini. Semua Pod yang diakuisisi oleh sebuah ReplicaSet masing-masing memiliki informasi yang mengidentifikasi ReplicaSet dalam <em>field</em> ownerReferences. Melalui tautan ini ReplicaSet dapat mengetahui keadaan dari Pod yang sedang dikelola dan melakukan perencanaan yang sesuai.</p><p>Sebuah ReplicaSet mengidentifikasi Pod baru untuk diakuisisi menggunakan selektornya. Jika terdapat sebuah Pod yang tidak memiliki OwnerReference atau OwnerReference yang dimiliki bukanlah sebuah <a href=https://kubernetes.io/docs/concepts/architecture/controller><em>Controller</em></a> dan sesuai dengan selektor dari ReplicaSet, maka Pod akan langsung diakuisisi oleh ReplicaSet tersebut.</p><h2 id=kapan-menggunakan-replicaset>Kapan menggunakan ReplicaSet</h2><p>Sebuah ReplicaSet memastikan replika-replika pod dalam jumlah yang ditentukan berjalan pada satu waktu tertentu. Namun demikian, sebuah Deployment adalah konsep dengan tingkatan yang lebih tinggi yang mengatur ReplicaSet dan mengubah Pod secara deklaratif serta berbagai fitur bermanfaat lainnya. Maka dari itu, kami merekomendasikan untuk menggunakan Deployment alih-alih menggunakan ReplicaSet secara langsung, kecuali jika kamu membutuhkan orkestrasi pembaruan yang khusus atau tidak membutuhkan pembaruan sama sekali.</p><p>Hal ini berarti kamu boleh jadi tidak akan membutuhkan manipulasi objek ReplicaSet: Gunakan Deployment dan definisikan aplikasi kamu pada bagian <em>spec</em>.</p><h2 id=contoh>Contoh</h2><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/controllers/frontend.yaml download=controllers/frontend.yaml><code>controllers/frontend.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("controllers-frontend-yaml")' title="Copy controllers/frontend.yaml to clipboard"></img></div><div class=includecode id=controllers-frontend-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ReplicaSet<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>guestbook<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># modify replicas according to your case</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>php-redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/google_samples/gb-frontend:v3<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Menyimpan <em>manifest</em> ini dalam <code>frontend.yaml</code> dan mengirimkannya ke klaster Kubernetes akan membuat ReplicaSet yang telah didefinisikan beserta dengan Pod yang dikelola.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://kubernetes.io/examples/controllers/frontend.yaml
</span></span></code></pre></div><p>Selanjutnya kamu bisa mendapatkan ReplicaSet yang sedang di-<em>deploy</em>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get rs
</span></span></code></pre></div><p>Dan melihat <em>frontend</em> yang telah dibuat:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME       DESIRED   CURRENT   READY   AGE
</span></span><span style=display:flex><span>frontend   <span style=color:#666>3</span>         <span style=color:#666>3</span>         <span style=color:#666>3</span>       6s
</span></span></code></pre></div><p>Kamu juga dapat memeriksa kondisi dari ReplicaSet:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe rs/frontend
</span></span></code></pre></div><p>Dan kamu akan melihat keluaran yang serupa dengan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>Name:		frontend
</span></span><span style=display:flex><span>Namespace:	default
</span></span><span style=display:flex><span>Selector:	<span style=color:#b8860b>tier</span><span style=color:#666>=</span>frontend,tier in <span style=color:#666>(</span>frontend<span style=color:#666>)</span>
</span></span><span style=display:flex><span>Labels:		<span style=color:#b8860b>app</span><span style=color:#666>=</span>guestbook
</span></span><span style=display:flex><span>		<span style=color:#b8860b>tier</span><span style=color:#666>=</span>frontend
</span></span><span style=display:flex><span>Annotations:	&lt;none&gt;
</span></span><span style=display:flex><span>Replicas:	<span style=color:#666>3</span> current / <span style=color:#666>3</span> desired
</span></span><span style=display:flex><span>Pods Status:	<span style=color:#666>3</span> Running / <span style=color:#666>0</span> Waiting / <span style=color:#666>0</span> Succeeded / <span style=color:#666>0</span> Failed
</span></span><span style=display:flex><span>Pod Template:
</span></span><span style=display:flex><span>  Labels:       <span style=color:#b8860b>app</span><span style=color:#666>=</span>guestbook
</span></span><span style=display:flex><span>                <span style=color:#b8860b>tier</span><span style=color:#666>=</span>frontend
</span></span><span style=display:flex><span>  Containers:
</span></span><span style=display:flex><span>   php-redis:
</span></span><span style=display:flex><span>    Image:      gcr.io/google_samples/gb-frontend:v3
</span></span><span style=display:flex><span>    Port:       80/TCP
</span></span><span style=display:flex><span>    Requests:
</span></span><span style=display:flex><span>      cpu:      100m
</span></span><span style=display:flex><span>      memory:   100Mi
</span></span><span style=display:flex><span>    Environment:
</span></span><span style=display:flex><span>      GET_HOSTS_FROM:   dns
</span></span><span style=display:flex><span>    Mounts:             &lt;none&gt;
</span></span><span style=display:flex><span>  Volumes:              &lt;none&gt;
</span></span><span style=display:flex><span>Events:
</span></span><span style=display:flex><span>  FirstSeen    LastSeen    Count    From                SubobjectPath    Type        Reason            Message
</span></span><span style=display:flex><span>  ---------    --------    -----    ----                -------------    --------    ------            -------
</span></span><span style=display:flex><span>  1m           1m          <span style=color:#666>1</span>        <span style=color:#666>{</span>replicaset-controller <span style=color:#666>}</span>             Normal      SuccessfulCreate  Created pod: frontend-qhloh
</span></span><span style=display:flex><span>  1m           1m          <span style=color:#666>1</span>        <span style=color:#666>{</span>replicaset-controller <span style=color:#666>}</span>             Normal      SuccessfulCreate  Created pod: frontend-dnjpy
</span></span><span style=display:flex><span>  1m           1m          <span style=color:#666>1</span>        <span style=color:#666>{</span>replicaset-controller <span style=color:#666>}</span>             Normal      SuccessfulCreate  Created pod: frontend-9si5l
</span></span></code></pre></div><p>Terakhir, kamu dapat memeriksa Pod yang dibawa:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get Pods
</span></span></code></pre></div><p>Kamu akan melihat informasi Pod yang serupa dengan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME             READY     STATUS    RESTARTS   AGE
</span></span><span style=display:flex><span>frontend-9si5l   1/1       Running   <span style=color:#666>0</span>          1m
</span></span><span style=display:flex><span>frontend-dnjpy   1/1       Running   <span style=color:#666>0</span>          1m
</span></span><span style=display:flex><span>frontend-qhloh   1/1       Running   <span style=color:#666>0</span>          1m
</span></span></code></pre></div><p>Kamu juga dapat memastikan bahwa referensi pemilik dari pod-pod ini telah disesuaikan terhadap ReplicaSet <em>frontend</em>.
Untuk melakukannya, <em>yaml</em> dari Pod yang sedang berjalan bisa didapatkan dengan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods frontend-9si5l -o yaml
</span></span></code></pre></div><p>Keluarannya akan terlihat serupa dengan contoh berikut ini, dengan informasi ReplicaSet <em>frontend</em> yang ditentukan pada <em>field</em> ownerReferences pada bagian metadata:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>apiVersion: v1
</span></span><span style=display:flex><span>kind: Pod
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  creationTimestamp: 2019-01-31T17:20:41Z
</span></span><span style=display:flex><span>  generateName: frontend-
</span></span><span style=display:flex><span>  labels:
</span></span><span style=display:flex><span>    tier: frontend
</span></span><span style=display:flex><span>  name: frontend-9si5l
</span></span><span style=display:flex><span>  namespace: default
</span></span><span style=display:flex><span>  ownerReferences:
</span></span><span style=display:flex><span>  - apiVersion: extensions/v1beta1
</span></span><span style=display:flex><span>    blockOwnerDeletion: <span style=color:#a2f>true</span>
</span></span><span style=display:flex><span>    controller: <span style=color:#a2f>true</span>
</span></span><span style=display:flex><span>    kind: ReplicaSet
</span></span><span style=display:flex><span>    name: frontend
</span></span><span style=display:flex><span>    uid: 892a2330-257c-11e9-aecd-025000000001
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><h2 id=akuisisi-pod-non-templat>Akuisisi Pod Non-Templat</h2><p>Walaupun kamu bisa membuat Pod biasa tanpa masalah, sangat direkomendasikan untuk memastikan Pod tersebut tidak memiliki label yang sama dengan selektor dari salah satu ReplicaSet yang kamu miliki. Hal in disebabkan sebuah ReplicaSet tidak dibatasi untuk memilki Pod sesuai dengan templatnya -- ReplicaSet dapat mengakuisisi Pod lain dengan cara yang telah dijelaskan pada bagian sebelumnya.</p><p>Mengambil contoh ReplicaSet <em>frontend</em> sebelumnya, dan Pod yang ditentukan pada <em>manifest</em> berikut:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/pods/pod-rs.yaml download=pods/pod-rs.yaml><code>pods/pod-rs.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-pod-rs-yaml")' title="Copy pods/pod-rs.yaml to clipboard"></img></div><div class=includecode id=pods-pod-rs-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pod1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/google-samples/hello-app:2.0<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pod2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/google-samples/hello-app:1.0<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Karena Pod tersebut tidak memiliki Controller (atau objek lain) sebagai referensi pemilik yang sesuai dengan selektor dari ReplicaSet <em>frontend</em>, Pod tersebut akan langsung diakuisisi oleh ReplicaSet.</p><p>Misalkan kamu membuat Pod tersebut setelah ReplicaSet <em>frontend</em> telah di-<em>deploy</em> dan telah mengkonfigurasi replika Pod awal untuk memenuhi kebutuhan jumlah replika:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://kubernetes.io/examples/pods/pod-rs.yaml
</span></span></code></pre></div><p>Pod baru akan diakuisisi oleh ReplicaSet, dan setelah itu langsung diterminasi ketika ReplicaSet melebihi jumlah yang diinginkan.</p><p>Memperoleh Pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get Pods
</span></span></code></pre></div><p>Keluaran menunjukkan bahwa Pod baru dalam keaadan telah diterminasi, atau sedang dalam proses terminasi:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME             READY   STATUS        RESTARTS   AGE
</span></span><span style=display:flex><span>frontend-9si5l   1/1     Running       <span style=color:#666>0</span>          1m
</span></span><span style=display:flex><span>frontend-dnjpy   1/1     Running       <span style=color:#666>0</span>          1m
</span></span><span style=display:flex><span>frontend-qhloh   1/1     Running       <span style=color:#666>0</span>          1m
</span></span><span style=display:flex><span>pod2             0/1     Terminating   <span style=color:#666>0</span>          4s
</span></span></code></pre></div><p>Jika kamu membuat Pod terlebih dahulu:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://kubernetes.io/examples/pods/pod-rs.yaml
</span></span></code></pre></div><p>Dan selanjutnya membuat ReplicaSet maka:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://kubernetes.io/examples/controllers/frontend.yaml
</span></span></code></pre></div><p>Kamu akan melihat bahwa ReplicaSet telah mengakuisisi Pod dan hanya membuat Pod yang baru sesuai dengan <code>spec</code> yang ditentukan hingga jumlah dari Pod yang baru dan yang orisinil sesuai dengan jumlah yang diinginkan. Dengan memperoleh Pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get Pods
</span></span></code></pre></div><p>Akan diperlihatkan pada keluarannya:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME             READY   STATUS    RESTARTS   AGE
</span></span><span style=display:flex><span>frontend-pxj4r   1/1     Running   <span style=color:#666>0</span>          5s
</span></span><span style=display:flex><span>pod1             1/1     Running   <span style=color:#666>0</span>          13s
</span></span><span style=display:flex><span>pod2             1/1     Running   <span style=color:#666>0</span>          13s
</span></span></code></pre></div><p>Dengan cara ini, sebuah ReplicaSet dapat memiliki himpunan berbagai Pod yang tidak homogen.</p><h2 id=menulis-manifest-replicaset>Menulis <em>manifest</em> ReplicaSet</h2><p>Seperti objek API Kubernetes lainnya, sebuah ReplicaSet membutuhkan <em>field</em> <code>apiVersion</code>, <code>kind</code>, dan <code>metadata</code>. Untuk ReplicaSet, nilai dari <code>kind</code> yang memungkinkan hanyalah ReplicaSet. Pada Kubernetes 1.9 versi API <code>apps/v1</code> pada <code>kind</code> ReplicaSet adalah versi saat ini dan diaktifkan secara <em>default</em>. Versi API <code>apps/v1beta2</code> telah dideprekasi. Lihat baris-baris awal pada contoh <code>frontend.yaml</code> untuk petunjuk.</p><p>Sebuah ReplicaSet juga membutuhkan <a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status>bagian <code>.spec</code></a>.</p><h3 id=templat-pod>Templat Pod</h3><p><code>.spec.template</code> adalah sebuah <a href=/docs/concepts/workloads/Pods/pod-overview/#pod-templates>templat pod</a> yang juga dibutuhkan untuk mempunyai label. Pada contoh <code>frontend.yaml</code> kita memiliki satu label: <code>tier: frontend</code>.
Hati-hati agar tidak tumpang tindih dengan selektor dari <em>controller</em> lain, agar mereka tidak mencoba untuk mengadopsi Pod ini.</p><p>Untuk <em>field</em> <a href=/docs/concepts/workloads/Pods/pod-lifecycle/#restart-policy><em>restart policy</em></a> dari templat, <code>.spec.template.spec.restartPolicy</code>, nilai yang diperbolehkan hanyalah <code>Always</code>, yang merupakan nilai <em>default</em>.</p><h3 id=selektor-pod>Selektor Pod</h3><p><em>Field</em> <code>.spec.selector</code> adalah sebuah <a href=/id/docs/concepts/overview/working-with-objects/labels/>selektor labe</a>. Seperti yang telah dibahas <a href=#how-a-replicaset-works>sebelumnya</a>, <em>field</em> ini adalah label yang digunakan untuk mengidentifikasi Pod yang memungkinkan untuk diakuisisi. Pada contoh <code>frontend.yaml</code>, selektornya adalah:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>matchLabels:
</span></span><span style=display:flex><span>	tier: frontend
</span></span></code></pre></div><p>Pada ReplicaSet, <code>.spec.template.metadata.labels</code> harus memiliki nilai yang sama dengan <code>spec.selector</code>, atau akan ditolak oleh API.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Untuk 2 ReplicaSet dengan nilai <code>.spec.selector</code> yang sama tetapi memiliki nilai yang berbeda pada <em>field</em> <code>.spec.template.metadata.labels</code> dan <code>.spec.template.spec</code>, setiap ReplicaSet akan mengabaikan Pod yang dibuat oleh ReplicaSet lain.</div><h3 id=replika>Replika</h3><p>Kamu dapat menentukan jumlah Pod yang seharusnya berjalan secara konkuren dengan mengatur nilai dari <code>.spec.replicas</code>. ReplicaSet akan membuat/menghapus Pod-nya hingga jumlahnya sesuai dengan <em>field</em> ini.</p><p>Jika nilai <code>.spec.replicas</code> tidak ditentukan maka akan diatur ke nilai <em>default</em> 1.</p><h2 id=menggunakan-replicaset>Menggunakan ReplicaSet</h2><h3 id=menghapus-replicaset-dan-pod-nya>Menghapus ReplicaSet dan Pod-nya</h3><p>Untuk menghapus sebuah ReplicaSet beserta dengan Pod-nya, gunakan <a href=/docs/reference/generated/kubectl/kubectl-commands#delete><code>kubectl delete</code></a>. <a href=/id/docs/concepts/workloads/controllers/garbage-collection/><em>Garbage collector</em></a> secara otomatis akan menghapus semua Pod dependen secara <em>default</em>.</p><p>Ketika menggunakan REST API atau <em>library</em> <code>client-go</code>, kamu harus mengatur nilai <code>propagationPolicy</code> menjadi <code>Background</code> atau <code>Foreground</code> pada opsi -d.
Sebagai contoh:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl proxy --port<span style=color:#666>=</span><span style=color:#666>8080</span>
</span></span><span style=display:flex><span>curl -X DELETE  <span style=color:#b44>&#39;localhost:8080/apis/extensions/v1beta1/namespaces/default/replicasets/frontend&#39;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>&gt; -d <span style=color:#b44>&#39;{&#34;kind&#34;:&#34;DeleteOptions&#34;,&#34;apiVersion&#34;:&#34;v1&#34;,&#34;propagationPolicy&#34;:&#34;Foreground&#34;}&#39;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>&gt; -H <span style=color:#b44>&#34;Content-Type: application/json&#34;</span>
</span></span></code></pre></div><h3 id=menghapus-hanya-replicaset>Menghapus hanya ReplicaSet</h3><p>Kamu dapat menghapus ReplicaSet tanpa memengaruhi Pod-nya menggunakan <a href=/docs/reference/generated/kubectl/kubectl-commands#delete><code>kubectl delete</code></a> dengan menggunakan opsi <code>--cascade=false</code>.
Ketika menggunakan REST API atau <em>library</em> <code>client-go</code>, kamu harus mengatur nilai <code>propagationPolicy</code> menjadi <code>Orphan</code>.
Sebagai contoh:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl proxy --port<span style=color:#666>=</span><span style=color:#666>8080</span>
</span></span><span style=display:flex><span>curl -X DELETE  <span style=color:#b44>&#39;localhost:8080/apis/extensions/v1beta1/namespaces/default/replicasets/frontend&#39;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>&gt; -d <span style=color:#b44>&#39;{&#34;kind&#34;:&#34;DeleteOptions&#34;,&#34;apiVersion&#34;:&#34;v1&#34;,&#34;propagationPolicy&#34;:&#34;Orphan&#34;}&#39;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>&gt; -H <span style=color:#b44>&#34;Content-Type: application/json&#34;</span>
</span></span></code></pre></div><p>Ketika ReplicaSet yang asli telah dihapus, kamu dapat membuat ReplicaSet baru untuk menggantikannya. Selama <em>field</em> <code>.spec.selector</code> yang lama dan baru memilki nilai yang sama, maka ReplicaSet baru akan mengadopsi Pod lama namun tidak serta merta membuat Pod yang sudah ada sama dan sesuai dengan templat Pod yang baru.
Untuk memperbarui Pod dengan <em>spec</em> baru dapat menggunakan <a href=/id/docs/concepts/workloads/controllers/deployment/#creating-a-deployment>Deployment</a> karena ReplicaSet tidak mendukung pembaruan secara langsung.</p><h3 id=mengisolasi-pod-dari-replicaset>Mengisolasi Pod dari ReplicaSet</h3><p>Kamu dapat menghapus Pod dari ReplicaSet dengan mengubah nilai labelnya. Cara ini dapat digunakan untuk menghapus Pod dari servis untuk keperluan <em>debugging</em>, <em>data recovery</em>, dan lainnya. Pod yang dihapus dengan cara ini akan digantikan seecara otomatis (dengan asumsi jumlah replika juga tidak berubah).</p><h3 id=mengatur-jumlah-pod-pada-replicaset>Mengatur jumlah Pod pada ReplicaSet</h3><p>Jumlah Pod pada ReplicaSet dapat diatur dengan mengubah nilai dari <em>field</em> <code>.spec.replicas</code>. Pengatur ReplicaSet akan memastikan Pod dengan jumlah yang telah ditentukan dan dengan nilai selektor yang sama sedang dalam keadaan berjalan.</p><h3 id=pengaturan-jumlah-pod-pada-replicaset-menggunakan-horizontal-pod-autoscaler>Pengaturan jumlah Pod pada ReplicaSet menggunakan Horizontal Pod Autoscaler</h3><p>Pengaturan jumlah Pod pada ReplicaSet juga dapat dilakukan mengunakan <a href=/docs/tasks/run-application/horizontal-pod-autoscale/>Horizontal Pod Autoscalers (HPA)</a>. Berikut adalah contoh HPA terhadap ReplicaSet yang telah dibuat pada contoh sebelumnya.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/controllers/hpa-rs.yaml download=controllers/hpa-rs.yaml><code>controllers/hpa-rs.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("controllers-hpa-rs-yaml")' title="Copy controllers/hpa-rs.yaml to clipboard"></img></div><div class=includecode id=controllers-hpa-rs-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>autoscaling/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>HorizontalPodAutoscaler<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>frontend-scaler<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scaleTargetRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ReplicaSet<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>minReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>maxReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>targetCPUUtilizationPercentage</span>:<span style=color:#bbb> </span><span style=color:#666>50</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Menyimpan <em>manifest</em> ini dalam <code>hpa-rs.yaml</code> dan mengirimkannya ke klaster Kubernetes akan membuat HPA tersebut yang akan mengatur jumlah Pod pada ReplicaSet yang telah didefinisikan bergantung terhadap penggunaan CPU dari Pod yang direplikasi.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/controllers/hpa-rs.yaml
</span></span></code></pre></div><p>Opsi lainnya adalah dengan menggunakan perintah <code>kubectl autoscale</code> untuk tujuan yang sama.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl autoscale rs frontend --max<span style=color:#666>=</span><span style=color:#666>10</span>
</span></span></code></pre></div><h2 id=alternatif-selain-replicaset>Alternatif selain ReplicaSet</h2><h3 id=deployment-direkomendasikan>Deployment (direkomendasikan)</h3><p><a href=/id/docs/concepts/workloads/controllers/deployment/><code>Deployment</code></a> adalah sebuah objek yang bisa memiliki ReplicaSet dan memperbarui ReplicaSet dan Pod-nya melalui <em>rolling update</em> deklaratif dan <em>server-side</em>.
Walaupun ReplicaSet dapat digunakan secara independen, seringkali ReplicaSet digunakan oleh Deployments sebagai mekanisme untuk mengorkestrasi pembuatan, penghapusan dan pembaruan Pod. Ketika kamu menggunakan Deployments kamu tidak perlu khawatir akan pengaturan dari ReplicaSet yang dibuat. Deployments memiliki dan mengatur ReplicaSet-nya sendiri.
Maka dari itu penggunaan Deployments direkomendasikan jika kamu menginginkan ReplicaSet.</p><h3 id=pod-sederhana>Pod sederhana</h3><p>Tidak seperti pada kasus ketika pengguna secara langsung membuat Pod, ReplicaSet akan menggantikan Pod yang dihapus atau diterminasi dengan alasan apapun, seperti pada kasus dimana terjadi kegagalan <em>node</em> atau pemeliharaan <em>node</em> yang disruptif, seperti pada kasus <em>upgrade</em> kernel. Karena alasan ini kami merekomendasikan kamu untuk menggunakan ReplicaSet walaupun jika aplikasimu membutuhkan hanya satu Pod. Hal ini mirip dengan pengawas proses, hanya saja pada kasus ini mengawasi banyak Pod pada berbagai <em>node</em> alih-alih berbagai proses individu pada sebuah <em>node</em>. ReplicaSet mendelegasikan proses pengulangan kembali dari kontainer lokal kepada agen yang terdapat di <em>node</em> (sebagai contoh, Kubelet atau Docker).</p><h3 id=job>Job</h3><p>Gunakan <a href=/docs/concepts/jobs/run-to-completion-finite-workloads/><code>Job</code></a> alih-alih ReplicaSet untuk Pod yang diharapkan untuk diterminasi secara sendirinya.</p><h3 id=daemonset>DaemonSet</h3><p>Gunakan <a href=/id/docs/concepts/workloads/controllers/daemonset/><code>DaemonSet</code></a> alih-alih ReplicaSet untuk Pod yang menyediakan fungsi pada level mesin, seperti <em>monitoring</em> mesin atau <em>logging</em> mesin. Pod ini memiliki waktu hidup yang bergantung terhadap waktu hidup mesin: Pod perlu untuk berjalan pada mesin sebelum Pod lain dijalankan, dan aman untuk diterminasi ketika mesin siap untuk di-<em>reboot</em> atau dimatikan.</p><h3 id=replicationcontroller>ReplicationController</h3><p>ReplicaSet adalah suksesor dari <a href=/id/docs/concepts/workloads/controllers/replicationcontroller/><em>ReplicationControllers</em></a>. Keduanya memenuhi tujuan yang sama dan memiliki perilaku yang serupa, kecuali bahwa ReplicationController tidak mendukung kebutuhan selektor <em>set-based</em> seperti yang dijelaskan pada <a href=/id/docs/concepts/overview/working-with-objects/labels/#label-selectors>panduan penggunaan label</a>. Pada kasus tersebut, ReplicaSet lebih direkomendasikan dibandingkan ReplicationController.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-27f1331d515d95f76aa1156088b4ad91>3.4.2.2 - ReplicationController</h1><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> <a href=/id/docs/concepts/workloads/controllers/deployment/><code>Deployment</code></a> yang mengonfigurasi <a href=/id/docs/concepts/workloads/controllers/replicaset/><code>ReplicaSet</code></a> sekarang menjadi cara yang direkomendasikan untuk melakukan replikasi.</div><p>Sebuah <em>ReplicationController</em> memastikan bahwa terdapat sejumlah Pod yang sedang berjalan dalam suatu waktu tertentu. Dengan kata lain, ReplicationController memastikan bahwa sebuah Pod atau sebuah kumpulan Pod yang homogen selalu berjalan dan tersedia.</p><h2 id=bagaimana-replicationcontroller-bekerja>Bagaimana ReplicationController Bekerja</h2><p>Jika terdapat terlalu banyak Pod, maka ReplicationController akan membatasi dan mematikan Pod-Pod yang berlebih. Jika terdapat terlalu sedikit, maka ReplicationController akan memulai dan menjalankan Pod-Pod baru lainnya. Tidak seperti Pod yang dibuat secara manual, Pod-Pod yang diatur oleh sebuah ReplicationController akan secara otomatis diganti jika mereka gagal, dihapus, ataupun dimatikan.
Sebagai contoh, Pod-Pod yang kamu miliki akan dibuat ulang dalam sebuah Node setelah terjadi proses pemeliharaan seperti pembaruan kernel. Untuk alasan ini, maka kamu sebaiknya memiliki sebuah ReplicationController bahkan ketika aplikasimu hanya membutuhkan satu buah Pod saja. Sebuah ReplicationController memiliki kemiripan dengan sebuah pengawas proses, tetapi alih-alih mengawasi sebuah proses individu pada sebuah Node, ReplicationController banyak Pod yang terdapat pada beberapa Node.</p><p>ReplicationController seringkali disingkat sebagai "rc" dalam diskusi, dan sebagai <em>shortcut</em> dalam perintah kubectl.</p><p>Sebuah contoh sederhana adalah membuat sebuah objek ReplicationController untuk menjalankan sebuah <em>instance</em> Pod secara berkelanjutan. Contoh pemakaian lainnya adalah untuk menjalankan beberapa replika identik dari sebuah servis yang direplikasi, seperti peladen web.</p><h2 id=menjalankan-sebuah-contoh-replicationcontroller>Menjalankan Sebuah Contoh ReplicationController</h2><p>Contoh ReplicationController ini mengonfigurasi tiga salinan dari peladen web nginx.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/controllers/replication.yaml download=controllers/replication.yaml><code>controllers/replication.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("controllers-replication-yaml")' title="Copy controllers/replication.yaml to clipboard"></img></div><div class=includecode id=controllers-replication-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ReplicationController<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span></span></span></code></pre></div></div></div><p>Jalankan contoh di atas dengan mengunduh berkas contoh dan menjalankan perintah ini:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/controllers/replication.yaml
</span></span></code></pre></div><pre tabindex=0><code>replicationcontroller/nginx created
</code></pre><p>Periksa status dari ReplicationController menggunakan perintah ini:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe replicationcontrollers/nginx
</span></span></code></pre></div><pre tabindex=0><code>Name:        nginx
Namespace:   default
Selector:    app=nginx
Labels:      app=nginx
Annotations:    &lt;none&gt;
Replicas:    3 current / 3 desired
Pods Status: 0 Running / 3 Waiting / 0 Succeeded / 0 Failed
Pod Template:
  Labels:       app=nginx
  Containers:
   nginx:
    Image:              nginx
    Port:               80/TCP
    Environment:        &lt;none&gt;
    Mounts:             &lt;none&gt;
  Volumes:              &lt;none&gt;
Events:
  FirstSeen       LastSeen     Count    From                        SubobjectPath    Type      Reason              Message
  ---------       --------     -----    ----                        -------------    ----      ------              -------
  20s             20s          1        {replication-controller }                    Normal    SuccessfulCreate    Created pod: nginx-qrm3m
  20s             20s          1        {replication-controller }                    Normal    SuccessfulCreate    Created pod: nginx-3ntk0
  20s             20s          1        {replication-controller }                    Normal    SuccessfulCreate    Created pod: nginx-4ok8v
</code></pre><p>Tiga Pod telah dibuat namun belum ada yang berjalan, kemungkinan karena <em>image</em> yang sedang di-<em>pull</em>.
Beberapa waktu kemudian, perintah yang sama akan menunjukkan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>Pods Status:    <span style=color:#666>3</span> Running / <span style=color:#666>0</span> Waiting / <span style=color:#666>0</span> Succeeded / <span style=color:#666>0</span> Failed
</span></span></code></pre></div><p>Untuk melihat semua Pod yang dibuat oleh ReplicationController dalam bentuk yang lebih mudah dibaca mesin, kamu dapat menggunakan perintah seperti ini:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#b8860b>pods</span><span style=color:#666>=</span><span style=color:#a2f;font-weight:700>$(</span>kubectl get pods --selector<span style=color:#666>=</span><span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx --output<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>={</span>.items..metadata.name<span style=color:#666>}</span><span style=color:#a2f;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b8860b>$pods</span>
</span></span></code></pre></div><pre tabindex=0><code>nginx-3ntk0 nginx-4ok8v nginx-qrm3m
</code></pre><p>Pada perintah di atas, selektor yang dimaksud adalah selektor yang sama dengan yang terdapat pada ReplicationController (yang dapat dilihat pada keluaran <code>kubectl describe</code>), dan dalam bentuk yang berbeda dengan yang terdapat pada <code>replication.yaml</code>. Opsi <code>--output=jsonpath</code> menentukan perintah untuh mendapatkan hanya nama dari setiap Pod yang ada pada daftar hasil.</p><h2 id=menulis-spesifikasi-replicationcontroller>Menulis Spesifikasi ReplicationController</h2><p>Seperti semua konfigurasi Kubernetes lainnya, sebuah ReplicationController membutuhkan <em>field</em> <code>apiVersion</code>, <code>kind</code>, dan <code>metadata</code>.</p><p>Untuk informasi umum mengenai berkas konfigurasi, kamu dapat melihat <a href=/id/docs/concepts/overview/working-with-objects/object-management/>pengaturan objek</a>.</p><p>Sebuah ReplicationController juga membutuhkan <a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status>bagian <code>.spec</code></a>.</p><h3 id=templat-pod>Templat Pod</h3><p><code>.spec.template</code> adalah satu-satunya <em>field</em> yang diwajibkan pada <code>.spec</code>.</p><p><code>.spec.template</code> adalah sebuah <a href=/id/docs/concepts/workloads/pods/pod-overview/#pod-templates>templat Pod</a>. Ia memiliki skema yang sama persis dengan sebuah <a href=/id/docs/concepts/workloads/pods/pod/>Pod</a>, namun dapat berbentuk <em>nested</em> dan tidak memiliki <em>field</em> <code>apiVersion</code> ataupun <code>kind</code>.</p><p>Selain <em>field-field</em> yang diwajibkan untuk sebuah Pod, templat Pod pada ReplicationController harus menentukan label dan kebijakan pengulangan kembali yang tepat. Untuk label, pastikan untuk tidak tumpang tindih dengan kontroler lain. Lihat <a href=#selektor-pod>selektor pod</a>.</p><p>Nilai yang diperbolehkan untuk <a href=/id/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy><code>.spec.template.spec.restartPolicy</code></a> hanyalah <code>Always</code>, yaitu nilai bawaan jika tidak ditentukan.</p><p>Untuk pengulangan kembali dari sebuah kontainer lokal, ReplicationController mendelegasikannya ke agen pada Node, contohnya <a href=/docs/admin/kubelet/>Kubelet</a> atau Docker.</p><h3 id=label-pada-replicationcontroller>Label pada ReplicationController</h3><p>ReplicationController itu sendiri dapat memiliki label (<code>.metadata.labels</code>). Biasanya, kamu akan mengaturnya untuk memiliki nilai yang sama dengan <code>.spec.template.metadata.labels</code>; jika <code>.metadata.labels</code> tidak ditentukan maka akan menggunakan nilai bawaan yaitu <code>.spec.template.metadata.labels</code>. Namun begitu, kedua label ini diperbolehkan untuk memiliki nilai yang berbeda, dan <code>.metadata.labels</code> tidak akan memengaruhi perilaku dari ReplicationController.</p><h3 id=selektor-pod>Selektor Pod</h3><p><em>Field</em> <code>.spec.selector</code> adalah sebuah <a href=/id/docs/concepts/overview/working-with-objects/labels/#label-selectors>selektor label</a>. Sebuah ReplicationController mengatur semua Pod dengan label yang sesuai dengan nilai selektor tersebut. Ia tidak membedakan antara Pod yang ia buat atau hapus atau Pod yang dibuat atau dihapus oleh orang atau proses lain. Hal ini memungkinkan ReplicationController untuk digantikan tanpa memengaruhi Pod-Pod yang sedang berjalan.</p><p>Jika ditentukan, <code>.spec.template.metadata.labels</code> harus memiliki nilai yang sama dengan <code>.spec.selector</code>, atau akan ditolak oleh API. Jika <code>.spec.selector</code> tidak ditentukan, maka akan menggunakan nilai bawaan yaitu <code>.spec.template.metadata.labels</code>.</p><p>Selain itu, kamu juga sebaiknya tidak membuat Pod dengan label yang cocok dengan selektor ini, baik secara langsung, dengan menggunakan ReplicationController lain, ataupun menggunakan kontroler lain seperti Job. Jika kamu melakukannya, ReplicationController akan menganggap bahwa ia telah membuat Pod-Pod lainnya. Kubernetes tidak akan menghentikan kamu untuk melakukan aksi ini.</p><p>Jika kamu pada akhirnya memiliki beberapa kontroler dengan selektor-selektor yang tumpang tindih, kamu harus mengatur penghapusannya sendiri (lihat <a href=#bekerja-dengan-replicationcontroller>di bawah</a>).</p><h3 id=beberapa-replika>Beberapa Replika</h3><p>Kamu dapat menentukan jumlah Pod yang seharusnya berjalan secara bersamaan dengan mengatur nilai <code>.spec.replicas</code> dengan jumlah Pod yang kamu inginkan untuk berjalan secara bersamaan. Jumlah yang berjalan dalam satu satuan waktu dapat lebih tinggi ataupun lebih rendah, seperti jika replika-replika tersebut melewati proses penambahan atau pengurangan, atau jika sebuah Pod melalui proses <em>graceful shutdown</em>, dan penggantinya telah dijalankan terlebih dahulu.</p><p>Jika kamu tidak menentukan nilai dari <code>.spec.replicas</code>, maka akan digunakan nilai bawaan 1.</p><h2 id=bekerja-dengan-replicationcontroller>Bekerja dengan ReplicationController</h2><h3 id=menghapus-sebuah-replicationcontroller-dan-pod-nya>Menghapus Sebuah ReplicationController dan Pod-nya</h3><p>Untuk menghapus sebuah ReplicationController dan Pod-Pod yang berhubungan dengannya, gunakan perintah <a href=/docs/reference/generated/kubectl/kubectl-commands#delete><code>kubectl delete</code></a>. Kubectl akan mengatur ReplicationController ke nol dan menunggunya untuk menghapus setiap Pod sebelum menghapus ReplicationController itu sendiri. Jika perintah kubectl ini terhenti, maka dapat diulang kembali.</p><p>Ketika menggunakan REST API atau <em>library</em> klien go, maka kamu perlu melakukan langkah-langkahnya secara eksplisit (mengatur replika-replika ke 0, menunggu penghapusan Pod, dan barulah menghapus ReplicationController).</p><h3 id=menghapus-hanya-replicationcontroller>Menghapus Hanya ReplicationController</h3><p>Kamu dapat menghapus ReplicationController tanpa memengaruhi Pod-Pod yang berhubungan dengannya.</p><p>Dengan menggunakan kubectl, tentukan opsi <code>--cascade=false</code> ke <a href=/docs/reference/generDeated/kubectl/kubectl-commands#delete><code>kubectl delete</code></a>.</p><p>Ketika menggunakan REST API atau <em>library</em> klien go, cukup hapus objek ReplicationController.</p><p>Ketika ReplicationController yang asli telah dihapus, kamu dapat membuat ReplicationController yang baru sebagai penggantinya. Selama <code>.spec.selector</code> yang lama dan baru memiliki nilai yang sama, maka ReplicationController baru akan mengadopsi Pod-Pod yang lama.
Walaupun begitu, ia tidak akan melakukan usaha apapun untuk membuat Pod-Pod yang telah ada sebelumnya untuk sesuai dengan templat Pod yang baru dan berbeda.
Untuk memperbarui Pod-Pod ke spesifikasi yang baru dengan cara yang terkontrol, gunakan <a href=#pembaruan-bergulir>pembaruan bergulir</a>.</p><h3 id=mengisolasi-pod-dari-replicationcontroller>Mengisolasi Pod dari ReplicationController</h3><p>Pod-Pod dapat dihapus dari kumpulan target sebuah ReplicationController dengan mengganti nilai dari labelnya. Teknik ini dapat digunakan untuk mencopot Pod-Pod dari servis untuk keperluan pengawakutuan (<em>debugging</em>), pemulihan data, dan lainnya. Pod-Pod yang dicopot dengan cara ini dapat digantikan secara otomatis (dengan asumsi bahwa jumlah replika juga tidak berubah).</p><h2 id=pola-penggunaan-umum>Pola penggunaan umum</h2><h3 id=penjadwalan-ulang>Penjadwalan ulang</h3><p>Seperti yang telah disebutkan sebelumnya, baik kamu memiliki hanya 1 Pod untuk tetap dijalankan, ataupun 1000, ReplicationController akan memastikan tersedianya jumlah Pod yang telat ditentukan, bahkan ketika terjadi kegagalan Node atau terminasi Pod (sebagai contoh karena adanya tindakan dari agen kontrol lain).</p><h3 id=penskalaan>Penskalaan</h3><p>ReplicationController memudahkan penskalaan jumlah replika, baik meningkatkan ataupun mengurangi, secara manual ataupun dengan agen kontrol penskalaan otomatis, dengan hanya mengubah nilai dari <em>field</em> <code>replicas</code>.</p><h3 id=pembaruan-bergulir>Pembaruan bergulir</h3><p>ReplicationController didesain untuk memfasilitasi pembaruan bergulir untuk sebuah servis dengan mengganti Pod-Pod satu per satu.</p><p>Seperti yang telah dijelaskan di <a href=http://issue.k8s.io/1353>#1353</a>, pendekatan yang direkomendasikan adalah dengan membuat ReplicationController baru dengan 1 replika, skala kontroler yang baru (+1) atau yang lama (-1) satu per satu, dan kemudian hapus kontroler lama setelah menyentuh angka 0 replika. Hal ini memungkinkan pembaruan dilakukan dengan dapat diprediksi terlepas dari adanya kegagalan yang tak terduga.</p><p>Idealnya, kontroler pembaruan bergulir akan memperhitungkan kesiapan dari aplikasi, dan memastikan cukupnya jumlah Pod yang secara produktif meladen kapanpun.</p><p>Dua ReplicationController diharuskan untuk memiliki setidaknya satu label yang berbeda, seperti <em>tag</em> <em>image</em> dari kontainer utama dari Pod, karena pembaruan bergulir biasanya dilakukan karena adanya pembaruan <em>image</em>.</p><p>Pembaruan bergulir diimplementasikan pada perkakas klien <a href=/docs/reference/generated/kubectl/kubectl-commands#rolling-update><code>kubectl rolling-update</code></a>. Lihat <a href=/docs/tasks/run-application/rolling-update-replication-controller/><code>kubectl rolling-update</code> task</a> untuk contoh-contoh yang lebih konkrit.</p><h3 id=operasi-rilis-majemuk>Operasi rilis majemuk</h3><p>Selain menjalankan beberapa rilis dari sebuah aplikasi ketika proses pembaruan bergulir sedang berjalan, adalah hal yang awam untuk menjalankan beberapa rilis untuk suatu periode waktu tertentu, atau bahkan secara kontinu, menggunakan operasi rilis majemuk. Operasi-operasi ini akan dibedakan menggunakan label.</p><p>Sebagai contoh, sebuah servis dapat menyasar semua Pod dengan <code>tier in (frontend), environment in (prod)</code>. Anggap kamu memiliki 10 Pod tiruan yang membangun <em>tier</em> ini tetapi kamu ingin bisa menggunakan 'canary' terhadap versi baru dari komponen ini. Kamu dapat mengatur sebuah ReplicationController dengan nilai <code>replicas</code> 9 untuk replika-replikanya, dengan label <code>tier=frontend, environment=prod, track=stable</code>, dan ReplicationController lainnya dengan nilai <code>replicas</code> 1 untuk canary, dengan label <code>tier=frontend, environment=prod, track=canary</code>. Sekarang servis sudah mencakup baik canary maupun Pod-Pod yang bukan canary. Kamu juga dapat mencoba-coba ReplicationController secara terpisah untuk melakukan pengujian, mengamati hasilnya, dan lainnya.</p><h3 id=menggunakan-replicationcontroller-dengan-service>Menggunakan ReplicationController dengan Service</h3><p>Beberapa ReplicationController dapat berada di belakang sebuah Service, sedemikian sehingga, sebagai contoh, sebagian <em>traffic</em> dapat ditujukan ke versi lama, dan sebagian lainnya ke versi yang baru.</p><p>Sebuah ReplicationController tidak akan berhenti dengan sendirinya, namun ia tidak diekspektasikan untuk berjalan selama Service-Service yang ada. Service dapat terdiri dari berbagai Pod yang dikontrol beberapa ReplicationController, dan terdapat kemungkinan bahwa beberapa ReplicationController untuk dibuat dan dimatikan dalam jangka waktu hidup Service (contohnya adalah untuk melakukan pembaruan Pod-Pod yang menjalankan Service). Baik Service itu sendiri dan kliennya harus tetap dalam keadaan tidak mempunyai pengetahuan terhadap ReplicationController yang memelihara Pod-Pod dari Service tersebut.</p><h2 id=menulis-program-untuk-replikasi>Menulis program untuk Replikasi</h2><p>Pod-Pod yang dibuat oleh ReplicationController ditujukan untuk dapat sepadan dan memiliki semantik yang identik, walaupun konfigurasi mereka dapat berbeda seiring keberjalanan waktunya. Ini adalah contoh yang cocok untuk peladen <em>stateless</em>, namun ReplicationController juga dapat digunakan untuk memelihara ketersediaan dari aplikasi-aplikasi yang <em>master-elected</em>, <em>sharded</em>, <em>worker-pool</em>. Aplikasi-aplikasi seperti itu sebaiknya menggunakan mekanisme penetapan kerja yang dinamis, seperti <a href=https://www.rabbitmq.com/tutorials/tutorial-two-python.html>antrian kerja RabbitMQ</a>, berlainan dengan pengubahan statis/satu kali dari konfigurasi setiap Pod, yang dipandang sebagai sebuah <em>anti-pattern</em>. Pengubahan apapun yang dilakukan terhadap Pod, seperti <em>auto-sizing</em> vertikal dari sumber daya (misalnya cpu atau memori), sebaiknya dilakukan oleh proses kontroller luring lainnya, dan bukan oleh ReplicationController itu sendiri.</p><h2 id=tanggung-jawab-replicationcontroller>Tanggung Jawab ReplicationController</h2><p>ReplicationController hanya memastikan ketersediaan dari sejumlah Pod yang cocok dengan selektor label dan berjalan dengan baik. Saat ini, hanya Pod yang diterminasi yang dijadikan pengecualian dari penghitungan. Kedepannya, <a href=http://issue.k8s.io/620>kesiapan</a> dan informasi yang ada lainnya dari sistem dapat menjadi pertimbangan, kami dapat meningkatkan kontrol terhadap kebijakan penggantian, dan kami berencana untuk menginformasikan kejadian (<em>event</em>) yang dapat digunakan klien eksternal untuk implementasi penggantian yang sesuai dan/atau kebijakan pengurangan.</p><p>ReplicationController akan selalu dibatasi terhadap tanggung jawab spesifik ini. Ia tidak akan melakukan <em>probe</em> kesiapan atau keaktifan. Daripada melakukan <em>auto-scaling</em>, ia ditujukan untuk dikontrol oleh <em>auto-scaler</em> eksternal (seperti yang didiskusikan pada <a href=http://issue.k8s.io/492>#492</a>), yang akan mengganti <em>field</em> <code>replicas</code>. Kami tidak akan menambahkan kebijakan penjadwalan (contohnya <a href=http://issue.k8s.io/367#issuecomment-48428019><em>spreading</em></a>) untuk ReplicationController. Ia juga tidak seharusnya melakukan verifikasi terhadap Pod-Pod yang sedang dikontrol yang cocok dengan spesifikasi templat saat ini, karena hal itu dapat menghambat <em>auto-sizing</em> dan proses otomatis lainnya. Demikian pula batas waktu penyelesaian, pengurutan <em>dependencies</em>, ekspansi konfigurasi, dan fitur-fitur lain yang seharusnya berada di komponen lain. Kami juga bahkan berencana untuk mengeluarkan mekanisme pembuatan Pod secara serentak (<a href=http://issue.k8s.io/170>#170</a>).</p><p>ReplicationController ditujukan untuk menjadi primitif komponen yang dapat dibangun untuk berbagai kebutuhan. Kami menargetkan API dengan tingkatan yang lebih tinggi dan/atau perkakas-perkakas untuk dibangun di atasnya dan primitif tambahan lainnya untuk kenyamanan pengguna kedepannya. Operasi-operasi makro yang sudah didukung oleh kubectl (<em>run</em>, <em>scale</em>, <em>rolling-update</em>) adalah contoh <em>proof-of-concept</em> dari konsep ini. Sebagai contohnya, kita dapat menganggap sesuatu seperti <a href=http://techblog.netflix.com/2012/06/asgard-web-based-cloud-management-and.html>Asgard</a> yang mengatur beberapa ReplicationController, <em>auto-scaler</em>, servis, kebijakan penjadwalan, canary, dan yang lainnya.</p><h2 id=objek-api>Objek API</h2><p>ReplicationController adalah sebuah sumber daya <em>top-level</em> pada REST API Kubernetes. Detil dari objek API dapat ditemukan di: <a href=/docs/reference/generated/kubernetes-api/v1.25/#replicationcontroller-v1-core>objek API ReplicationController</a>.</p><h2 id=alternatif-untuk-replicationcontroller>Alternatif untuk ReplicationController</h2><h3 id=replicaset>ReplicaSet</h3><p><a href=/id/docs/concepts/workloads/controllers/replicaset/><code>ReplicaSet</code></a> adalah kelanjutan dari ReplicationController yang mendukung selektor <a href=/id/docs/concepts/overview/working-with-objects/labels/#set-based-requirement>selektor label <em>set-based</em></a> yang baru. Umumnya digunakan oleh <a href=/id/docs/concepts/workloads/controllers/deployment/><code>Deployment</code></a> sebagai mekanisme untuk mengorkestrasi pembuatan, penghapusan, dan pembaruan Pod.
Perhatikan bahwa kami merekomendasikan untuk menggunakan Deployment sebagai ganti dari menggunakan ReplicaSet secara langsung, kecuali jika kamu membutuhkan orkestrasi pembaruan khusus atau tidak membutuhkan pembaruan sama sekali.</p><h3 id=deployment-direkomendasikan>Deployment (Direkomendasikan)</h3><p><a href=/id/docs/concepts/workloads/controllers/deployment/><code>Deployment</code></a> adalah objek API tingkat tinggi yang memperbarui ReplicaSet dan Pod-Pod di bawahnya yang mirip dengan cara kerja <code>kubectl rolling-update</code>. Deployment direkomendasikan jika kamu menginginkan fungsionalitas dari pembaruan bergulir ini, karena tidak seperti <code>kubectl rolling-update</code>, Deployment memiliki sifat deklaratif, <em>server-side</em>, dan memiliki beberapa fitur tambahan lainnya.</p><h3 id=pod-sederhana>Pod sederhana</h3><p>Tidak seperti pada kasus ketika pengguna secara langsung membuat Pod, ReplicationController menggantikan Pod-Pod yang dihapus atau dimatikan untuk alasan apapun, seperti pada kasus kegagalan Node atau pemeliharaan Node yang disruptif, seperti pembaruan kernel. Untuk alasan ini, kami merekomendasikan kamu untuk menggunakan ReplicationController bahkan ketika aplikasimu hanya membutuhkan satu Pod saja. Anggap hal ini mirip dengan pengawas proses, hanya pada kasus ini mengawasi banyak Pod yang terdapat pada berbagai Node dan bukan proses-proses tunggal pada satu Node. ReplicationController mendelegasikan pengulangan kontainer lokal ke agen yang terdapat dalam Node (contohnya Kubelet atau Docker).</p><h3 id=job>Job</h3><p>Gunakan <a href=/docs/concepts/jobs/run-to-completion-finite-workloads/><code>Job</code></a> sebagai ganti ReplicationController untuk Pod-Pod yang diharapkan diterminasi dengan sendirinya (seperti <em>batch jobs</em>).</p><h3 id=daemonset>DaemonSet</h3><p>Gunakan <a href=/id/docs/concepts/workloads/controllers/daemonset/><code>DaemonSet</code></a> sebagai ganti ReplicationController untuk Pod-Pod yang menyediakan fungsi pada level mesin, seperti pengamatan mesin atau pencatatan mesin. Pod-Pod ini memiliki waktu hidup yang bergantung dengan waktu hidup mesin: Pod butuh untuk dijalankan di mesin sebelum Pod-Pod lainnya dimulai, dan aman untuk diterminasi ketika mesin sudah siap untuk dinyalakan ulang atau dimatikan.</p><h2 id=informasi-lanjutan>Informasi lanjutan</h2><p>Baca <a href=/docs/tutorials/stateless-application/run-stateless-ap-replication-controller/>Menjalankan Kontroler Replikasi AP <em>Stateless</em></a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-a2dc0393e0c4079e1c504b6429844e86>3.4.2.3 - Deployment</h1><p>Deployment menyediakan pembaruan <a href=/id/docs/concepts/workloads/pods/pod/>Pods</a> dan
<a href=/id/docs/concepts/workloads/controllers/replicaset/>ReplicaSets</a> secara deklaratif.</p><p>Kamu mendeskripsikan sebuah state yang diinginkan dalam Deployment, kemudian Deployment <a class=glossary-tooltip title='Kontrol tertutup yang mengawasi kondisi bersama dari klaster melalui apiserver dan membuat perubahan yang mencoba untuk membawa kondisi saat ini ke kondisi yang diinginkan.' data-toggle=tooltip data-placement=top href=/id/docs/concepts/architecture/controller/ target=_blank aria-label=Pengontrol>Pengontrol</a> mengubah state sekarang menjadi seperti pada deskripsi secara bertahap. Kamu dapat mendefinisikan Deployment untuk membuat ReplicaSets baru atau untuk menghapus Deployment yang sudah ada dan mengadopsi semua resourcenya untuk Deployment baru.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Jangan mengganti ReplicaSets milik Deployment. Pertimbangkan untuk membuat isu pada repositori utama Kubernetes jika kasusmu tidak diatasi semua kasus di bawah.</div><h2 id=penggunaan>Penggunaan</h2><p>Berikut adalah penggunaan yang umum pada Deployment:</p><ul><li><a href=#membuat-deployment>Membuat Deployment untuk merilis ReplicaSet</a>. ReplicaSet membuat Pod di belakang layar. Cek status rilis untuk tahu proses rilis sukses atau tidak.</li><li><a href=#membarui-deployment>Mendeklarasikan state baru dari Pods</a> dengan membarui PodTemplateSpec milik Deployment. ReplicaSet baru akan dibuat dan Deployment mengatur perpindahan Pod secara teratur dari ReplicaSet lama ke ReplicaSet baru. Tiap ReplicaSet baru akan mengganti revisi Deployment.</li><li><a href=#membalikkan-deployment>Mengembalikan ke revisi Deployment sebelumnya</a> jika state Deployment sekarang tidak stabil. Tiap pengembalian mengganti revisi Deployment.</li><li><a href=#mengatur-skala-deployment>Memperbesar Deployment untuk memfasilitasi beban yang lebih</a>.</li><li><a href=#menjeda-dan-melanjutkan-deployment>Menjeda Deployment</a> untuk menerapkan perbaikan pada PodTemplateSpec-nya, lalu melanjutkan untuk memulai rilis baru.</li><li><a href=#status-deployment>Memakai status Deployment</a> sebagai indikator ketika rilis tersendat.</li><li><a href=#kebijakan-pembersihan>Membersihkan ReplicaSet lama</a> yang sudah tidak terpakai.</li></ul><h2 id=membuat-deployment>Membuat Deployment</h2><p>Berikut adalah contoh Deployment. Dia membuat ReplicaSet untuk membangkitkan tiga Pod <code>nginx</code>:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/controllers/nginx-deployment.yaml download=controllers/nginx-deployment.yaml><code>controllers/nginx-deployment.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("controllers-nginx-deployment-yaml")' title="Copy controllers/nginx-deployment.yaml to clipboard"></img></div><div class=includecode id=controllers-nginx-deployment-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.7.9<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Dalam contoh ini:</p><ul><li><p>Deployment baru akan dibuat dengan nama <code>nginx-deployment</code>, tertulis pada kolom <code>.metadata.name</code>.</p></li><li><p>Deployment membuat tiga Pod yang direplikasi, ditandai dengan kolom <code>replicas</code>.</p></li><li><p>Kolom <code>selector</code> mendefinisikan bagaimana Deployment menemukan Pod yang diatur.
Dalam kasus ini, kamu hanya perlu memilih sebuah label yang didefinisikan pada templat Pod (<code>app: nginx</code>).
Namun, aturan pemilihan yang lebih canggih mungkin dilakukan asal templat Pod-nya memenuhi aturan.<div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Kolom <code>matchLabels</code> berbentuk pasangan {key,value}. Sebuah {key,value} dalam <em>map</em> <code>matchLabels</code> ekuivalen dengan
elemen pada <code>matchExpressions</code>, yang mana kolom key adalah "key", operator adalah "In", dan larik values hanya berisi "value".
Semua prasyarat dari <code>matchLabels</code> maupun <code>matchExpressions</code> harus dipenuhi agar dapat dicocokkan.</div></p></li><li><p>Kolom <code>template</code> berisi sub kolom berikut:</p><ul><li>Pod dilabeli <code>app: nginx</code> dengan kolom <code>labels</code>.</li><li>Spesifikasi templat Pod atau kolom <code>.template.spec</code> menandakan bahwa Pod mennjalankan satu kontainer <code>nginx</code>,
yang menjalankan image <code>nginx</code> <a href=https://hub.docker.com/>Docker Hub</a> dengan versi 1.7.9.</li><li>Membuat satu kontainer bernama <code>nginx</code> sesuai kolom <code>name</code>.</li></ul><p>Ikuti langkah-langkah berikut untuk membuat Deployment di atas:</p><p>Sebelum memulai, pastikan klaster Kubernetes sedang menyala dan bekerja.</p><ol><li><p>Buat Deployment dengan menjalankan perintah berikut:</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Kamu dapat menambahkan argument <code>--record</code> untuk menulis perintah yang dijalankan pada anotasi sumber daya <code>kubernetes.io/change-cause</code>. Ini berguna untuk pemeriksaan di masa depan.
Contohnya yaitu untuk melihat perintah yang dijalankan pada tiap revisi Deployment.</div></li></ol><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/controllers/nginx-deployment.yaml
</span></span></code></pre></div><ol start=2><li>Jalankan <code>kubectl get deployments</code> untuk mengecek apakah Deployment telah dibuat. Jika Deployment masih sedang pembuatan, keluaran akan tampil seperti berikut:</li></ol><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME               DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
</span></span><span style=display:flex><span>nginx-deployment   <span style=color:#666>3</span>         <span style=color:#666>0</span>         <span style=color:#666>0</span>            <span style=color:#666>0</span>           1s
</span></span></code></pre></div><p>Ketika kamu memeriksa Deployments pada klastermu, kolom berikut akan tampil:</p><pre><code>* `NAME` menampilkan daftar nama Deployment pada klaster.
* `DESIRED` menampilkan jumlah replika aplikasi yang diinginkan sesuai yang didefinisikan saat pembuatan Deployment. Ini adalah _state_ yang diinginkan.
* `CURRENT` menampilkan berapa jumlah replika yang sedang berjalan.
* `UP-TO-DATE` menampilkan jumlah replika yang diperbarui agar sesuai state yang diinginkan.
* `AVAILABLE` menampilkan jumlah replika aplikasi yang dapat diakses pengguna.
* `AGE` menampilkan lama waktu aplikasi telah berjalan.
</code></pre><p>Perhatikan bahwa jumlah replika yang diinginkan adalah tiga sesuai kolom <code>.spec.replicas</code>.</p><ol start=3><li>Untuk melihat status rilis Deployment, jalankan <code>kubectl rollout status deployment.v1.apps/nginx-deployment</code>. Keluaran akan tampil seperti berikut:</li></ol><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>Waiting <span style=color:#a2f;font-weight:700>for</span> rollout to finish: <span style=color:#666>2</span> out of <span style=color:#666>3</span> new replicas have been updated...
</span></span><span style=display:flex><span>deployment <span style=color:#b44>&#34;nginx-deployment&#34;</span> successfully rolled out
</span></span></code></pre></div><ol start=4><li>Jalankan <code>kubectl get deployments</code> lagi beberapa saat kemudian. Keluaran akan tampil seperti berikut:</li></ol><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME               DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
</span></span><span style=display:flex><span>nginx-deployment   <span style=color:#666>3</span>         <span style=color:#666>3</span>         <span style=color:#666>3</span>            <span style=color:#666>3</span>           18s
</span></span></code></pre></div><p>Perhatikan bahwa Deployment telah membuat ketiga replika dan semua replika sudah merupakan yang terbaru (mereka mengandung pembaruan terakhir templat Pod) dan dapat diakses.</p><ol start=5><li>Untuk melihat ReplicaSet (<code>rs</code>) yang dibuat Deployment, jalankan <code>kubectl get rs</code>. Keluaran akan tampil seperti berikut:</li></ol><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME                          DESIRED   CURRENT   READY   AGE
</span></span><span style=display:flex><span>nginx-deployment-75675f5897   <span style=color:#666>3</span>         <span style=color:#666>3</span>         <span style=color:#666>3</span>       18s
</span></span></code></pre></div><p>Perhatikan bahwa nama ReplicaSet selalu dalam format <code>[NAMA-DEPLOYMENT]-[KATA-ACAK]</code>. Kata acak dibangkitkan secara acak dan menggunakan pod-template-hash sebagai benih.</p><ol start=6><li>Untuk melihat label yang dibangkitkan secara otomatis untuk tiap Pod, jalankan <code>kubectl get pods --show-labels</code>. Perintah akan menghasilkan keluaran berikut:</li></ol><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME                                READY     STATUS    RESTARTS   AGE       LABELS
</span></span><span style=display:flex><span>nginx-deployment-75675f5897-7ci7o   1/1       Running   <span style=color:#666>0</span>          18s       <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx,pod-template-hash<span style=color:#666>=</span><span style=color:#666>3123191453</span>
</span></span><span style=display:flex><span>nginx-deployment-75675f5897-kzszj   1/1       Running   <span style=color:#666>0</span>          18s       <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx,pod-template-hash<span style=color:#666>=</span><span style=color:#666>3123191453</span>
</span></span><span style=display:flex><span>nginx-deployment-75675f5897-qqcnn   1/1       Running   <span style=color:#666>0</span>          18s       <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx,pod-template-hash<span style=color:#666>=</span><span style=color:#666>3123191453</span>
</span></span></code></pre></div><p>ReplicaSet yang dibuat menjamin bahwa ada tiga Pod <code>nginx</code>.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Kamu harus memasukkan selektor dan label templat Pod yang benar pada Deployment (dalam kasus ini, <code>app: nginx</code>).
Jangan membuat label atau selektor yang beririsan dengan kontroler lain (termasuk Deployment dan StatefulSet lainnya). Kubernetes tidak akan mencegah adanya label yang beririsan.
Namun, jika beberapa kontroler memiliki selektor yang beririsan, kontroler itu mungkin akan konflik dan berjalan dengan tidak semestinya.</div></li></ul><h3 id=label-pod-template-hash>Label pod-template-hash</h3><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Jangan ubah label ini.</div><p>Label <code>pod-template-hash</code> ditambahkan oleh Deployment kontroler pada tiap ReplicaSet yang dibuat atau diadopsi Deployment.</p><p>Label ini menjamin anak-anak ReplicaSet milik Deployment tidak tumpang tindih. Dia dibangkitkan dengan melakukan hash pada <code>PodTemplate</code> milik ReplicaSet dan memakainya sebagai label untuk ditambahkan ke selektor ReplicaSet, label templat Pod, dan Pod apapun yang ReplicaSet miliki.</p><h2 id=membarui-deployment>Membarui Deployment</h2><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Rilis Deployment hanya dapat dipicu oleh perubahan templat Pod Deployment (yaitu, <code>.spec.template</code>), contohnya perubahan kolom label atau image container. Yang lain, seperti replika, tidak akan memicu rilis.</div><p>Ikuti langkah-langkah berikut untuk membarui Deployment:</p><ol><li><p>Ganti Pod nginx menjadi image <code>nginx:1.9.1</code> dari image <code>nginx:1.7.9</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl --record deployment.apps/nginx-deployment <span style=color:#a2f>set</span> image deployment.v1.apps/nginx-deployment <span style=color:#b8860b>nginx</span><span style=color:#666>=</span>nginx:1.9.1
</span></span></code></pre></div><p>Keluaran akan tampil seperti berikut:</p><pre tabindex=0><code>deployment.apps/nginx-deployment image updated
</code></pre><p>Alternatif lainnya, kamu dapat <code>edit</code> Deployment dan mengganti <code>.spec.template.spec.containers[0].image</code> dari <code>nginx:1.7.9</code> ke <code>nginx:1.9.1</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl edit deployment.v1.apps/nginx-deployment
</span></span></code></pre></div><p>Keluaran akan tampil seperti berikut:</p><pre tabindex=0><code>deployment.apps/nginx-deployment edited
</code></pre></li><li><p>Untuk melihat status rilis, jalankan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl rollout status deployment.v1.apps/nginx-deployment
</span></span></code></pre></div><p>Keluaran akan tampil seperti berikut:</p><pre tabindex=0><code>Waiting for rollout to finish: 2 out of 3 new replicas have been updated...
</code></pre><p>atau</p><pre tabindex=0><code>deployment &#34;nginx-deployment&#34; successfully rolled out
</code></pre></li></ol><p>Untuk menampilkan detail lain dari Deployment yang terbaru:</p><ul><li><p>Setelah rilis sukses, kamu dapat melihat Deployment dengan menjalankan <code>kubectl get deployments</code>.
Keluaran akan tampil seperti berikut:</p><pre tabindex=0><code>NAME               DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
nginx-deployment   3         3         3            3           36s
</code></pre></li><li><p>Jalankan <code>kubectl get rs</code> to see that the Deployment updated the Pods dengan membuat ReplicaSet baru dan
menggandakannya menjadi 3 replika, sembari menghapus ReplicaSet menjadi 0 replika.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get rs
</span></span></code></pre></div><p>Keluaran akan tampil seperti berikut:</p><pre tabindex=0><code>NAME                          DESIRED   CURRENT   READY   AGE
nginx-deployment-1564180365   3         3         3       6s
nginx-deployment-2035384211   0         0         0       36s
</code></pre></li><li><p>Menjalankan <code>get pods</code> sekarang hanya akan menampilkan Pod baru:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods
</span></span></code></pre></div><p>Keluaran akan tampil seperti berikut:</p><pre tabindex=0><code>NAME                                READY     STATUS    RESTARTS   AGE
nginx-deployment-1564180365-khku8   1/1       Running   0          14s
nginx-deployment-1564180365-nacti   1/1       Running   0          14s
nginx-deployment-1564180365-z9gth   1/1       Running   0          14s
</code></pre><p>Selanjutnya ketika ingin membarui Pod, kamu hanya perlu mengganti templat Pod Deployment lagi.</p><p>Deployment memastikan hanya ada beberapa Pod yang mati saat pembaruan berlangsung. Umumnya,
dia memastikan paling sedikit ada 75% jumlah Pod yang diinginkan menyala (25% maksimal tidak dapat diakses).</p><p>Deployment juga memastikan hanya ada beberapa Pod yang dibuat melebihi jumlah Pod yang diinginkan.
Umumnya, dia memastikan paling banyak ada 125% jumlah Pod yang diinginkan menyala (25% tambahan maksimal).</p><p>Misalnya, jika kamu lihat Deployment diatas lebih jauh, kamu akan melihat bahwa pertama-tama dia membuat Pod baru,
kemudian menghapus beberapa Pod lama, dan membuat yang baru. Dia tidak akan menghapus Pod lama sampai ada cukup
Pod baru menyala, dan pula tidak membuat Pod baru sampai ada cukup Pod lama telah mati.
Dia memastikan paling sedikit 2 Pod menyala dan paling banyak total 4 Pod menyala.</p></li><li><p>Melihat detil Deployment:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe deployments
</span></span></code></pre></div><p>Keluaran akan tampil seperti berikut:</p><pre tabindex=0><code>Name:                   nginx-deployment
Namespace:              default
CreationTimestamp:      Thu, 30 Nov 2017 10:56:25 +0000
Labels:                 app=nginx
Annotations:            deployment.kubernetes.io/revision=2
Selector:               app=nginx
Replicas:               3 desired | 3 updated | 3 total | 3 available | 0 unavailable
StrategyType:           RollingUpdate
MinReadySeconds:        0
RollingUpdateStrategy:  25% max unavailable, 25% max surge
Pod Template:
  Labels:  app=nginx
   Containers:
    nginx:
      Image:        nginx:1.9.1
      Port:         80/TCP
      Environment:  &lt;none&gt;
      Mounts:       &lt;none&gt;
    Volumes:        &lt;none&gt;
  Conditions:
    Type           Status  Reason
    ----           ------  ------
    Available      True    MinimumReplicasAvailable
    Progressing    True    NewReplicaSetAvailable
  OldReplicaSets:  &lt;none&gt;
  NewReplicaSet:   nginx-deployment-1564180365 (3/3 replicas created)
  Events:
    Type    Reason             Age   From                   Message
    ----    ------             ----  ----                   -------
    Normal  ScalingReplicaSet  2m    deployment-controller  Scaled up replica set nginx-deployment-2035384211 to 3
    Normal  ScalingReplicaSet  24s   deployment-controller  Scaled up replica set nginx-deployment-1564180365 to 1
    Normal  ScalingReplicaSet  22s   deployment-controller  Scaled down replica set nginx-deployment-2035384211 to 2
    Normal  ScalingReplicaSet  22s   deployment-controller  Scaled up replica set nginx-deployment-1564180365 to 2
    Normal  ScalingReplicaSet  19s   deployment-controller  Scaled down replica set nginx-deployment-2035384211 to 1
    Normal  ScalingReplicaSet  19s   deployment-controller  Scaled up replica set nginx-deployment-1564180365 to 3
    Normal  ScalingReplicaSet  14s   deployment-controller  Scaled down replica set nginx-deployment-2035384211 to 0
</code></pre><p>Disini bisa dilihat ketika pertama Deployment dibuat, dia membuat ReplicaSet (nginx-deployment-2035384211)
dan langsung menggandakannya menjadi 3 replika. Saat Deployment diperbarui, dia membuat ReplicaSet baru
(nginx-deployment-1564180365) dan menambah 1 replika kemudian mengecilkan ReplicaSet lama menjadi 2,
sehingga paling sedikit 2 Pod menyala dan paling banyak 4 Pod dibuat setiap saat. Dia kemudian lanjut menaik-turunkan
ReplicaSet baru dan ReplicaSet lama, dengan strategi pembaruan rolling yang sama.
Terakhir, kamu akan dapat 3 replika di ReplicaSet baru telah menyala, dan ReplicaSet lama akan hilang (berisi 0).</p></li></ul><h3 id=perpanjangan-alias-banyak-pembaruan-secara-langsung>Perpanjangan (alias banyak pembaruan secara langsung)</h3><p>Setiap kali Deployment baru is teramati oleh Deployment kontroler, ReplicaSet dibuat untuk membangkitkan Pod sesuai keinginan.
Jika Deployment diperbarui, ReplicaSet yang terkait Pod dengan label <code>.spec.selector</code> yang cocok,
namun kolom <code>.spec.template</code> pada templat tidak cocok akan dihapus. Kemudian, ReplicaSet baru akan
digandakan sebanyak <code>.spec.replicas</code> dan semua ReplicaSet lama dihapus.</p><p>Jika kamu mengubah Deployment saat rilis sedang berjalan, Deployment akan membuat ReplicaSet baru
tiap perubahan dan memulai penggandaan. Lalu, dia akan mengganti ReplicaSet yang dibuat sebelumnya
-- mereka ditambahkan ke dalam daftar ReplicaSet lama dan akan mulai dihapus.</p><p>Contohnya, ketika kamu membuat Deployment untuk membangkitkan 5 replika <code>nginx:1.7.9</code>,
kemudian membarui Deployment dengan versi <code>nginx:1.9.1</code> ketika ada 3 replika <code>nginx:1.7.9</code> yang dibuat.
Dalam kasus ini, Deployment akan segera menghapus 3 replika Pod <code>nginx:1.7.9</code> yang telah dibuat, dan mulai membuat
Pod <code>nginx:1.9.1</code>. Dia tidak akan menunggu kelima replika <code>nginx:1.7.9</code> selesai baru menjalankan perubahan.</p><h3 id=mengubah-selektor-label>Mengubah selektor label</h3><p>Umumnya, sekali dibuat, selektor label tidak boleh diubah. Sehingga disarankan untuk direncanakan dengan hati-hati sebelumnya.
Bagaimanapun, jika kamu perlu mengganti selektor label, lakukan dengan seksama dan pastikan kamu tahu segala konsekuensinya.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Pada versi API <code>apps/v1</code>, selektor label Deployment tidak bisa diubah ketika selesai dibuat.</div><ul><li>Penambahan selektor mensyaratkan label templat Pod di spek Deployment untuk diganti dengan label baru juga.
Jika tidak, galat validasi akan muncul. Perubahan haruslah tidak tumpang-tindih, dengan kata lain selektor baru tidak mencakup ReplicaSet dan Pod yang dibuat dengan selektor lama. Sehingga, semua ReplicaSet lama akan menggantung sedangkan ReplicaSet baru tetap dibuat.</li><li>Pengubahan selektor mengubah nilai pada kunci selektor -- menghasilkan perilaku yang sama dengan penambahan.</li><li>Penghapusan selektor menghilangkan kunci yang ada pada selektor Deployment -- tidak mensyaratkan perubahan apapun pada label templat Pod.
ReplicaSet yang ada tidak menggantung dan ReplicaSet baru tidak dibuat.
Tapi perhatikan bahwa label yang dihapus masih ada pada Pod dan ReplicaSet masing-masing.</li></ul><h2 id=membalikkan-deployment>Membalikkan Deployment</h2><p>Kadang, kamu mau membalikkan Deployment; misalnya, saat Deployment tidak stabil, seperti crash looping.
Umumnya, semua riwayat rilis Deployment disimpan oleh sistem sehingga kamu dapat kembali kapanpun kamu mau
(kamu dapat mengubahnya dengan mengubah batas riwayat revisi).</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Revisi Deployment dibuat saat rilis Deployment dipicu. Ini berarti revisi baru dibuat jika dan hanya jika
templat Pod Deployment (<code>.spec.template</code>) berubah, misalnya jika kamu membarui label atau image kontainer pada templat.
Pembaruan lain, seperti penggantian skala Deployment, tidak membuat revisi Deployment, jadi kamu dapat memfasilitasi
penggantian skala secara manual atau otomatis secara simultan. Artinya saat kamu membalikkan ke versi sebelumnya,
hanya bagian templat Pod Deployment yang dibalikkan.</div><ul><li><p>Misal kamu membuat saltik saat mengganti Deployment, dengan memberi nama image dengan <code>nginx:1.91</code> alih-alih <code>nginx:1.9.1</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>set</span> image deployment.v1.apps/nginx-deployment <span style=color:#b8860b>nginx</span><span style=color:#666>=</span>nginx:1.91 --record<span style=color:#666>=</span><span style=color:#a2f>true</span>
</span></span></code></pre></div><p>Keluaran akan tampil seperti berikut:</p><pre tabindex=0><code>deployment.apps/nginx-deployment image updated
</code></pre></li><li><p>Rilis akan tersendat. Kamu dapat memeriksanya dengan melihat status rilis:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl rollout status deployment.v1.apps/nginx-deployment
</span></span></code></pre></div><p>Keluaran akan tampil seperti berikut:</p><pre tabindex=0><code>Waiting for rollout to finish: 1 out of 3 new replicas have been updated...
</code></pre></li><li><p>Tekan Ctrl-C untuk menghentikan pemeriksaan status rilis di atas. Untuk info lebih lanjut
tentang rilis tersendat, <a href=#status-deployment>baca disini</a>.</p></li><li><p>Kamu lihat bahwa jumlah replika lama (<code>nginx-deployment-1564180365</code> dan <code>nginx-deployment-2035384211</code>) adalah 2, dan replika baru (nginx-deployment-3066724191) adalah 1.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get rs
</span></span></code></pre></div><p>Keluaran akan tampil seperti berikut:</p><pre tabindex=0><code>NAME                          DESIRED   CURRENT   READY   AGE
nginx-deployment-1564180365   3         3         3       25s
nginx-deployment-2035384211   0         0         0       36s
nginx-deployment-3066724191   1         1         0       6s
</code></pre></li><li><p>Lihat pada Pod yang dibuat. Akan ada 1 Pod dibuat dari ReplicaSet baru tersendat loop(?) ketika penarikan image.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods
</span></span></code></pre></div><p>Keluaran akan tampil seperti berikut:</p><pre tabindex=0><code>NAME                                READY     STATUS             RESTARTS   AGE
nginx-deployment-1564180365-70iae   1/1       Running            0          25s
nginx-deployment-1564180365-jbqqo   1/1       Running            0          25s
nginx-deployment-1564180365-hysrc   1/1       Running            0          25s
nginx-deployment-3066724191-08mng   0/1       ImagePullBackOff   0          6s
</code></pre><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Controller Deployment menghentikan rilis yang buruk secara otomatis dan juga berhenti meningkatkan ReplicaSet baru.
Ini tergantung pada parameter rollingUpdate (secara khusus <code>maxUnavailable</code>) yang dimasukkan.
Kubernetes umumnya mengatur jumlahnya menjadi 25%.</div></li><li><p>Tampilkan deskripsi Deployment:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe deployment
</span></span></code></pre></div><p>Keluaran akan tampil seperti berikut:</p><pre tabindex=0><code>Name:           nginx-deployment
Namespace:      default
CreationTimestamp:  Tue, 15 Mar 2016 14:48:04 -0700
Labels:         app=nginx
Selector:       app=nginx
Replicas:       3 desired | 1 updated | 4 total | 3 available | 1 unavailable
StrategyType:       RollingUpdate
MinReadySeconds:    0
RollingUpdateStrategy:  25% max unavailable, 25% max surge
Pod Template:
  Labels:  app=nginx
  Containers:
   nginx:
    Image:        nginx:1.91
    Port:         80/TCP
    Host Port:    0/TCP
    Environment:  &lt;none&gt;
    Mounts:       &lt;none&gt;
  Volumes:        &lt;none&gt;
Conditions:
  Type           Status  Reason
  ----           ------  ------
  Available      True    MinimumReplicasAvailable
  Progressing    True    ReplicaSetUpdated
OldReplicaSets:     nginx-deployment-1564180365 (3/3 replicas created)
NewReplicaSet:      nginx-deployment-3066724191 (1/1 replicas created)
Events:
  FirstSeen LastSeen    Count   From                    SubobjectPath   Type        Reason              Message
  --------- --------    -----   ----                    -------------   --------    ------              -------
  1m        1m          1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled up replica set nginx-deployment-2035384211 to 3
  22s       22s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled up replica set nginx-deployment-1564180365 to 1
  22s       22s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled down replica set nginx-deployment-2035384211 to 2
  22s       22s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled up replica set nginx-deployment-1564180365 to 2
  21s       21s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled down replica set nginx-deployment-2035384211 to 1
  21s       21s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled up replica set nginx-deployment-1564180365 to 3
  13s       13s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled down replica set nginx-deployment-2035384211 to 0
  13s       13s         1       {deployment-controller }                Normal      ScalingReplicaSet   Scaled up replica set nginx-deployment-3066724191 to 1
</code></pre><p>Untuk memperbaikinya, kamu harus kembali ke revisi Deployment yang sebelumnya stabil.</p></li></ul><h3 id=mengecek-riwayat-rilis-deployment>Mengecek Riwayat Rilis Deployment</h3><p>Ikuti langkah-langkah berikut untuk mengecek riwayat rilis:</p><ol><li><p>Pertama, cek revisi Deployment sekarang:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl rollout <span style=color:#a2f>history</span> deployment.v1.apps/nginx-deployment
</span></span></code></pre></div><p>Keluaran akan tampil seperti berikut:</p><pre tabindex=0><code>deployments &#34;nginx-deployment&#34;
REVISION    CHANGE-CAUSE
1           kubectl apply --filename=https://k8s.io/examples/controllers/nginx-deployment.yaml --record=true
2           kubectl set image deployment.v1.apps/nginx-deployment nginx=nginx:1.9.1 --record=true
3           kubectl set image deployment.v1.apps/nginx-deployment nginx=nginx:1.91 --record=true
</code></pre><p><code>CHANGE-CAUSE</code> disalin dari anotasi Deployment <code>kubernetes.io/change-cause</code> ke revisi saat pembuatan. Kamu dapat menentukan pesan <code>CHANGE-CAUSE</code> dengan:</p><ul><li>Menambahkan anotasi pada Deployment dengan <code>kubectl annotate deployment.v1.apps/nginx-deployment kubernetes.io/change-cause="image updated to 1.9.1"</code></li><li>Menambahkan argumen <code>--record</code> untuk menyimpan perintah <code>kubectl</code> yang menyebabkan perubahan sumber daya.</li><li>Mengganti manifest sumber daya secara manual.</li></ul></li><li><p>Untuk melihat detil tiap revisi, jalankan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl rollout <span style=color:#a2f>history</span> deployment.v1.apps/nginx-deployment --revision<span style=color:#666>=</span><span style=color:#666>2</span>
</span></span></code></pre></div><p>Keluaran akan tampil seperti berikut:</p><pre tabindex=0><code>deployments &#34;nginx-deployment&#34; revision 2
  Labels:       app=nginx
          pod-template-hash=1159050644
  Annotations:  kubernetes.io/change-cause=kubectl set image deployment.v1.apps/nginx-deployment nginx=nginx:1.9.1 --record=true
  Containers:
   nginx:
    Image:      nginx:1.9.1
    Port:       80/TCP
     QoS Tier:
        cpu:      BestEffort
        memory:   BestEffort
    Environment Variables:      &lt;none&gt;
  No volumes.
</code></pre></li></ol><h3 id=kembali-ke-revisi-sebelumnya>Kembali ke Revisi Sebelumnya</h3><p>Ikuti langkah-langkah berikut untuk membalikkan Deployment dari versi sekarang ke versi sebelumnya, yaitu versi 2.</p><ol><li><p>Sekarang kamu telah menentukan akan mengembalikan rilis sekarang ke sebelumnya:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl rollout undo deployment.v1.apps/nginx-deployment
</span></span></code></pre></div><p>Keluaran akan tampil seperti berikut:</p><pre tabindex=0><code>deployment.apps/nginx-deployment
</code></pre><p>Gantinya, kamu dapat kambali ke revisi tertentu dengan menambahkan argumen <code>--to-revision</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl rollout undo deployment.v1.apps/nginx-deployment --to-revision<span style=color:#666>=</span><span style=color:#666>2</span>
</span></span></code></pre></div><p>Keluaran akan tampil seperti berikut:</p><pre tabindex=0><code>deployment.apps/nginx-deployment
</code></pre><p>Untuk detil lebih lanjut perintah terkait rilis, baca <a href=/docs/reference/generated/kubectl/kubectl-commands#rollout><code>rilis kubectl</code></a>.</p><p>Deployment sekarang dikembalikan ke revisi stabil sebelumnya. Seperti terlihat, ada event <code>DeploymentRollback</code>
yang dibentuk oleh kontroler Deployment untuk pembalikan ke revisi 2.</p></li><li><p>Cek apakah rilis telah sukses dan Deployment berjalan seharusnya, jalankan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get deployment nginx-deployment
</span></span></code></pre></div><p>Keluaran akan tampil seperti berikut:</p><pre tabindex=0><code>NAME               DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
nginx-deployment   3         3         3            3           30m
</code></pre></li><li><p>Tampilkan deskripsi Deployment:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe deployment nginx-deployment
</span></span></code></pre></div><p>Keluaran akan tampil seperti berikut:</p><pre tabindex=0><code>Name:                   nginx-deployment
Namespace:              default
CreationTimestamp:      Sun, 02 Sep 2018 18:17:55 -0500
Labels:                 app=nginx
Annotations:            deployment.kubernetes.io/revision=4
                        kubernetes.io/change-cause=kubectl set image deployment.v1.apps/nginx-deployment nginx=nginx:1.9.1 --record=true
Selector:               app=nginx
Replicas:               3 desired | 3 updated | 3 total | 3 available | 0 unavailable
StrategyType:           RollingUpdate
MinReadySeconds:        0
RollingUpdateStrategy:  25% max unavailable, 25% max surge
Pod Template:
  Labels:  app=nginx
  Containers:
   nginx:
    Image:        nginx:1.9.1
    Port:         80/TCP
    Host Port:    0/TCP
    Environment:  &lt;none&gt;
    Mounts:       &lt;none&gt;
  Volumes:        &lt;none&gt;
Conditions:
  Type           Status  Reason
  ----           ------  ------
  Available      True    MinimumReplicasAvailable
  Progressing    True    NewReplicaSetAvailable
OldReplicaSets:  &lt;none&gt;
NewReplicaSet:   nginx-deployment-c4747d96c (3/3 replicas created)
Events:
  Type    Reason              Age   From                   Message
  ----    ------              ----  ----                   -------
  Normal  ScalingReplicaSet   12m   deployment-controller  Scaled up replica set nginx-deployment-75675f5897 to 3
  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled up replica set nginx-deployment-c4747d96c to 1
  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled down replica set nginx-deployment-75675f5897 to 2
  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled up replica set nginx-deployment-c4747d96c to 2
  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled down replica set nginx-deployment-75675f5897 to 1
  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled up replica set nginx-deployment-c4747d96c to 3
  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled down replica set nginx-deployment-75675f5897 to 0
  Normal  ScalingReplicaSet   11m   deployment-controller  Scaled up replica set nginx-deployment-595696685f to 1
  Normal  DeploymentRollback  15s   deployment-controller  Rolled back deployment &#34;nginx-deployment&#34; to revision 2
  Normal  ScalingReplicaSet   15s   deployment-controller  Scaled down replica set nginx-deployment-595696685f to 0
</code></pre></li></ol><h2 id=mengatur-skala-deployment>Mengatur Skala Deployment</h2><p>Kamu dapat mengatur skala Deployment dengan perintah berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl scale deployment.v1.apps/nginx-deployment --replicas<span style=color:#666>=</span><span style=color:#666>10</span>
</span></span></code></pre></div><p>Keluaran akan tampil seperti berikut:</p><pre tabindex=0><code>deployment.apps/nginx-deployment scaled
</code></pre><p>Dengan asumsi <a href=/docs/tasks/run-application/horizontal-pod-autoscale-walkthrough/>horizontal Pod autoscaling</a> dalam klaster dinyalakan,
kamu dapat mengatur autoscaler untuk Deployment-mu dan memilih jumlah minimal dan maksimal Pod yang mau dijalankan berdasarkan penggunaan CPU
dari Pod.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl autoscale deployment.v1.apps/nginx-deployment --min<span style=color:#666>=</span><span style=color:#666>10</span> --max<span style=color:#666>=</span><span style=color:#666>15</span> --cpu-percent<span style=color:#666>=</span><span style=color:#666>80</span>
</span></span></code></pre></div><p>Keluaran akan tampil seperti berikut:</p><pre tabindex=0><code>deployment.apps/nginx-deployment scaled
</code></pre><h3 id=pengaturan-skala-proporsional>Pengaturan skala proporsional</h3><p>Deployment RollingUpdate mendukung beberapa versi aplikasi berjalan secara bersamaan. Ketika kamu atau autoscaler
mengubah skala Deployment RollingUpdate yang ada di tengah rilis (yang sedang berjalan maupun terjeda),
kontroler Deployment menyeimbangkan replika tambahan dalam ReplicaSet aktif (ReplicaSet dengan Pod) untuk mencegah resiko.
Ini disebut <em>pengaturan skala proporsional</em>.</p><p>Sebagai contoh, kamu menjalankan Deployment dengan 10 replika, <a href=#max-surge>maxSurge</a>=3, dan <a href=#max-unavailable>maxUnavailable</a>=2.</p><ul><li><p>Pastikan ada 10 replica di Deployment-mu yang berjalan.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get deploy
</span></span></code></pre></div><p>Keluaran akan tampil seperti berikut:</p><pre tabindex=0><code>NAME                 DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
nginx-deployment     10        10        10           10          50s
</code></pre></li><li><p>Ganti ke image baru yang kebetulan tidak bisa ditemukan dari dalam klaster.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>set</span> image deployment.v1.apps/nginx-deployment <span style=color:#b8860b>nginx</span><span style=color:#666>=</span>nginx:sometag
</span></span></code></pre></div><p>Keluaran akan tampil seperti berikut:</p><pre tabindex=0><code>deployment.apps/nginx-deployment image updated
</code></pre></li><li><p>Penggantian image akan memulai rilis baru dengan ReplicaSet nginx-deployment-1989198191, namun dicegah karena
persyaratan <code>maxUnavailable</code> yang disebut di atas. Cek status rilis:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get rs
</span></span></code></pre></div><pre><code>Keluaran akan tampil seperti berikut:
</code></pre><pre tabindex=0><code>NAME                          DESIRED   CURRENT   READY     AGE
nginx-deployment-1989198191   5         5         0         9s
nginx-deployment-618515232    8         8         8         1m
</code></pre></li><li><p>Kemudian, permintaan peningkatan untuk Deployment akan masuk. Autoscaler menambah replika Deployment
menjadi 15. Controller Deployment perlu menentukan dimana 5 replika ini ditambahkan. Jika kamu memakai
pengaturan skala proporsional, kelima replika akan ditambahkan ke ReplicaSet baru. Dengan pengaturan skala proporsional,
kamu menyebarkan replika tambahan ke semua ReplicaSet. Proporsi terbesar ada pada ReplicaSet dengan
replika terbanyak dan proporsi yang lebih kecil untuk replika dengan ReplicaSet yang lebih sedikit.
Sisanya akan diberikan ReplicaSet dengan replika terbanyak. ReplicaSet tanpa replika tidak akan ditingkatkan.</p></li></ul><p>Dalam kasus kita di atas, 3 replika ditambahkan ke ReplicaSet lama dan 2 replika ditambahkan ke ReplicaSet baru.
Proses rilis akan segera memindahkan semua ReplicaSet baru, dengan asumsi semua replika dalam kondisi sehat.
Untuk memastikannya, jalankan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get deploy
</span></span></code></pre></div><p>Keluaran akan tampil seperti berikut:</p><pre tabindex=0><code>NAME                 DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
nginx-deployment     15        18        7            8           7m
</code></pre><p>Status rilis mengkonfirmasi bagaimana replika ditambahkan ke tiap ReplicaSet.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get rs
</span></span></code></pre></div><p>Keluaran akan tampil seperti berikut:</p><pre tabindex=0><code>NAME                          DESIRED   CURRENT   READY     AGE
nginx-deployment-1989198191   7         7         0         7m
nginx-deployment-618515232    11        11        11        7m
</code></pre><h2 id=menjeda-dan-melanjutkan-deployment>Menjeda dan Melanjutkan Deployment</h2><p>Kamu dapat menjeda Deployment sebelum memicu satu atau lebih pembaruan kemudian meneruskannya.
Hal ini memungkinkanmu menerapkan beberapa perbaikan selama selang jeda tanpa melakukan rilis yang tidak perlu.</p><ul><li><p>Sebagai contoh, Deployment yang baru dibuat:
Lihat detil Deployment:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get deploy
</span></span></code></pre></div><p>Keluaran akan tampil seperti berikut:</p><pre tabindex=0><code>NAME      DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
nginx     3         3         3            3           1m
</code></pre><p>Lihat status rilis:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get rs
</span></span></code></pre></div><p>Keluaran akan tampil seperti berikut:</p><pre tabindex=0><code>NAME               DESIRED   CURRENT   READY     AGE
nginx-2142116321   3         3         3         1m
</code></pre></li><li><p>Jeda dengan menjalankan perintah berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl rollout pause deployment.v1.apps/nginx-deployment
</span></span></code></pre></div><p>Keluaran akan tampil seperti berikut:</p><pre tabindex=0><code>deployment.apps/nginx-deployment paused
</code></pre></li><li><p>Lalu ganti kolom image Deployment:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>set</span> image deployment.v1.apps/nginx-deployment <span style=color:#b8860b>nginx</span><span style=color:#666>=</span>nginx:1.9.1
</span></span></code></pre></div><p>Keluaran akan tampil seperti berikut:</p><pre tabindex=0><code>deployment.apps/nginx-deployment image updated
</code></pre></li><li><p>Perhatikan tidak ada rilis baru yang muncul:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl rollout <span style=color:#a2f>history</span> deployment.v1.apps/nginx-deployment
</span></span></code></pre></div><p>Keluaran akan tampil seperti berikut:</p><pre tabindex=0><code>deployments &#34;nginx&#34;
REVISION  CHANGE-CAUSE
1   &lt;none&gt;
</code></pre></li><li><p>Lihat status rilis untuk memastikan Deployment berhasil diperbarui:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get rs
</span></span></code></pre></div><p>Keluaran akan tampil seperti berikut:</p><pre tabindex=0><code>NAME               DESIRED   CURRENT   READY     AGE
nginx-2142116321   3         3         3         2m
</code></pre></li><li><p>Kamu bisa membuat pembaruan sebanyak yang kamu mau. Contohnya pembaruan sumber daya yang akan dipakai:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>set</span> resources deployment.v1.apps/nginx-deployment -c<span style=color:#666>=</span>nginx --limits<span style=color:#666>=</span><span style=color:#b8860b>cpu</span><span style=color:#666>=</span>200m,memory<span style=color:#666>=</span>512Mi
</span></span></code></pre></div><p>Keluaran akan tampil seperti berikut:</p><pre tabindex=0><code>deployment.apps/nginx-deployment resource requirements updated
</code></pre><p>The state awal Deployment sebelum jeda akan melanjutkan fungsinya, tapi perubahan
Deployment tidak akan berefek apapun selama Deployment masih terjeda.</p></li><li><p>Kemudian, mulai kembali Deployment dan perhatikan ReplicaSet baru akan muncul dengan semua perubahan baru:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl rollout resume deployment.v1.apps/nginx-deployment
</span></span></code></pre></div><p>Keluaran akan tampil seperti berikut:</p><pre tabindex=0><code>deployment.apps/nginx-deployment resumed
</code></pre></li><li><p>Perhatikan status rilis sampai selesai.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get rs -w
</span></span></code></pre></div><p>Keluaran akan tampil seperti berikut:</p><pre tabindex=0><code>NAME               DESIRED   CURRENT   READY     AGE
nginx-2142116321   2         2         2         2m
nginx-3926361531   2         2         0         6s
nginx-3926361531   2         2         1         18s
nginx-2142116321   1         2         2         2m
nginx-2142116321   1         2         2         2m
nginx-3926361531   3         2         1         18s
nginx-3926361531   3         2         1         18s
nginx-2142116321   1         1         1         2m
nginx-3926361531   3         3         1         18s
nginx-3926361531   3         3         2         19s
nginx-2142116321   0         1         1         2m
nginx-2142116321   0         1         1         2m
nginx-2142116321   0         0         0         2m
nginx-3926361531   3         3         3         20s
</code></pre></li><li><p>Lihat status rilis terakhir:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get rs
</span></span></code></pre></div><p>Keluaran akan tampil seperti berikut:</p><pre tabindex=0><code>NAME               DESIRED   CURRENT   READY     AGE
nginx-2142116321   0         0         0         2m
nginx-3926361531   3         3         3         28s
</code></pre></li></ul><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Kamu tidak bisa membalikkan Deployment yang terjeda sampai dia diteruskan.</div><h2 id=status-deployment>Status Deployment</h2><p>Deployment melalui berbagai state dalam daur hidupnya. Dia dapat <a href=#deployment-berlangsung>berlangsung</a> selagi merilis ReplicaSet baru, bisa juga <a href=#deployment-selesai>selesai</a>,
atau juga <a href=#deployment-gagal>gagal</a>.</p><h3 id=deployment-berlangsung>Deployment Berlangsung</h3><p>Kubernetes menandai Deployment sebagai <em>progressing</em> saat salah satu tugas di bawah dikerjakan:</p><ul><li>Deployment membuat ReplicaSet baru.</li><li>Deployment menaikkan kapasitas ReplicaSet terbaru.</li><li>Deployment menurunkan kapasitas ReplicaSet yang lebih lama.</li><li>Pod baru menjadi siap atau dapat diakses (siap selama setidaknya <a href=#min-ready-seconds>MinReadySeconds</a>).</li></ul><p>Kamu dapat mengawasi perkembangan Deployment dengan <code>kubectl rollout status</code>.</p><h3 id=deployment-selesai>Deployment Selesai</h3><p>Kubernetes menandai Deployment sebagai <em>complete</em> saat memiliki karakteristik berikut:</p><ul><li>Semua replika terkait Deployment telah diperbarui ke versi terbaru yang dispecify, artinya semua pembaruan yang kamu inginkan telah selesai.</li><li>Semua replika terkait Deployment dapat diakses.</li><li>Tidak ada replika lama untuk Deployment yang berjalan.</li></ul><p>Kamu dapat mengecek apakah Deployment telah selesai dengan <code>kubectl rollout status</code>.
Jika rilis selesai, <code>kubectl rollout status</code> akan mengembalikan nilai balik nol.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl rollout status deployment.v1.apps/nginx-deployment
</span></span></code></pre></div><p>Keluaran akan tampil seperti berikut:</p><pre tabindex=0><code>Waiting for rollout to finish: 2 of 3 updated replicas are available...
deployment &#34;nginx-deployment&#34; successfully rolled out
$ echo $?
0
</code></pre><h3 id=deployment-gagal>Deployment Gagal</h3><p>Deployment-mu bisa saja terhenti saat mencoba deploy ReplicaSet terbaru tanpa pernah selesai.
Ini dapat terjadi karena faktor berikut:</p><ul><li>Kuota tidak mencukupi</li><li>Kegagalan pengecekan kesiapan</li><li>Galat saat mengunduh image</li><li>Tidak memiliki ijin</li><li>Limit ranges</li><li>Konfigurasi runtime aplikasi yang salah</li></ul><p>Salah satu cara untuk mendeteksi kondisi ini adalah untuk menjelaskan parameter tenggat pada spesifikasi Deployment:
(<a href=#progress-deadline-seconds><code>.spec.progressDeadlineSeconds</code></a>). <code>.spec.progressDeadlineSeconds</code> menyatakan
lama kontroler Deployment menunggu sebelum mengindikasikan (pada status Deployment) bahwa kemajuan Deployment
tersendat dalam detik.</p><p>Perintah <code>kubectl</code> berikut menetapkan spek dengan <code>progressDeadlineSeconds</code> untuk membuat kontroler
melaporkan kemajuan Deployment yang sedikit setelah 10 menit:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl patch deployment.v1.apps/nginx-deployment -p <span style=color:#b44>&#39;{&#34;spec&#34;:{&#34;progressDeadlineSeconds&#34;:600}}&#39;</span>
</span></span></code></pre></div><p>Keluaran akan tampil seperti berikut:</p><pre tabindex=0><code>deployment.apps/nginx-deployment patched
</code></pre><p>Ketika tenggat sudah lewat, kontroler Deployment menambah DeploymentCondition dengan atribut
berikut ke <code>.status.conditions</code> milik Deployment:</p><ul><li>Type=Progressing</li><li>Status=False</li><li>Reason=ProgressDeadlineExceeded</li></ul><p>Lihat <a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#typical-status-properties>konvensi Kubernetes API</a> untuk info lebih lanjut tentang kondisi status.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Kubernetes tidak melakukan apapun pada Deployment yang tersendat selain melaporkannya sebagai <code>Reason=ProgressDeadlineExceeded</code>.
Orkestrator yang lebih tinggi dapat memanfaatkannya untuk melakukan tindak lanjut. Misalnya, mengembalikan Deployment ke versi sebelumnya.</div><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Jika Deployment terjeda, Kubernetes tidak akan mengecek kemajuan pada selang itu.
Kamu dapat menjeda Deployment di tengah rilis dan melanjutkannya dengan aman tanpa memicu kondisi saat tenggat telah lewat.</div><p>Kamu dapat mengalami galat sejenak pada Deployment disebabkan timeout yang dipasang terlalu kecil atau
hal-hal lain yang terjadi sementara. Misalnya, kamu punya kuota yang tidak mencukupi. Jika kamu mendeskripsikan Deployment
kamu akan menjumpai pada bagian ini:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe deployment nginx-deployment
</span></span></code></pre></div><p>Keluaran akan tampil seperti berikut:</p><pre tabindex=0><code>&lt;...&gt;
Conditions:
  Type            Status  Reason
  ----            ------  ------
  Available       True    MinimumReplicasAvailable
  Progressing     True    ReplicaSetUpdated
  ReplicaFailure  True    FailedCreate
&lt;...&gt;
</code></pre><p>Jika kamu menjalankan <code>kubectl get deployment nginx-deployment -o yaml</code>, Deployment status akan muncul seperti berikut:</p><pre tabindex=0><code>status:
  availableReplicas: 2
  conditions:
  - lastTransitionTime: 2016-10-04T12:25:39Z
    lastUpdateTime: 2016-10-04T12:25:39Z
    message: Replica set &#34;nginx-deployment-4262182780&#34; is progressing.
    reason: ReplicaSetUpdated
    status: &#34;True&#34;
    type: Progressing
  - lastTransitionTime: 2016-10-04T12:25:42Z
    lastUpdateTime: 2016-10-04T12:25:42Z
    message: Deployment has minimum availability.
    reason: MinimumReplicasAvailable
    status: &#34;True&#34;
    type: Available
  - lastTransitionTime: 2016-10-04T12:25:39Z
    lastUpdateTime: 2016-10-04T12:25:39Z
    message: &#39;Error creating: pods &#34;nginx-deployment-4262182780-&#34; is forbidden: exceeded quota:
      object-counts, requested: pods=1, used: pods=3, limited: pods=2&#39;
    reason: FailedCreate
    status: &#34;True&#34;
    type: ReplicaFailure
  observedGeneration: 3
  replicas: 2
  unavailableReplicas: 2
</code></pre><p>Begitu tenggat kemajuan Deployment terlewat, Kubernetes membarui status dan alasan untuk kondisi Progressing:</p><pre tabindex=0><code>Conditions:
  Type            Status  Reason
  ----            ------  ------
  Available       True    MinimumReplicasAvailable
  Progressing     False   ProgressDeadlineExceeded
  ReplicaFailure  True    FailedCreate
</code></pre><p>Kamu dapat menangani isu keterbatasan kuota dengan menurunkan jumlah Deployment, bisa dengan menghapus kontrolers
yang sedang berjalan, atau dengan meningkatkan kuota pada namespace. Jika kuota tersedia, kemudian kontroler Deployment
akan dapat menyelesaikan rilis Deployment. Kamu akan melihat bahwa status Deployment berubah menjadi kondisi sukses (<code>Status=True</code> dan <code>Reason=NewReplicaSetAvailable</code>).</p><pre tabindex=0><code>Conditions:
  Type          Status  Reason
  ----          ------  ------
  Available     True    MinimumReplicasAvailable
  Progressing   True    NewReplicaSetAvailable
</code></pre><p><code>Type=Available</code> dengan <code>Status=True</code> artinya Deployment-mu punya ketersediaan minimum. Ketersediaan minimum diatur
oleh parameter yang dibuat pada strategi deployment. <code>Type=Progressing</code> dengan <code>Status=True</code> berarti Deployment
sedang dalam rilis dan masih berjalan atau sudah selesai berjalan dan jumlah minimum replika tersedia
(lihat bagian Alasan untuk kondisi tertentu - dalam kasus ini <code>Reason=NewReplicaSetAvailable</code> berarti Deployment telah selesai).</p><p>Kamu dapat mengecek apakah Deployment gagal berkembang dengan perintah <code>kubectl rollout status</code>. <code>kubectl rollout status</code>
mengembalikan nilai selain nol jika Deployment telah melewati tenggat kemajuan.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl rollout status deployment.v1.apps/nginx-deployment
</span></span></code></pre></div><p>Keluaran akan tampil seperti berikut:</p><pre tabindex=0><code>Waiting for rollout to finish: 2 out of 3 new replicas have been updated...
error: deployment &#34;nginx&#34; exceeded its progress deadline
$ echo $?
1
</code></pre><h3 id=menindak-deployment-yang-gagal>Menindak Deployment yang gagal</h3><p>Semua aksi yang dapat diterapkan pada Deployment yang selesai berjalan juga pada Deployment gagal. Kamu dapat menaik/turunkan replika, membalikkan ke versi sebelumnya, atau menjedanya jika kamu perlu menerapkan beberapa perbaikan pada templat Pod Deployment.</p><h2 id=kebijakan-pembersihan>Kebijakan Pembersihan</h2><p>Kamu dapat mengisi kolom <code>.spec.revisionHistoryLimit</code> di Deployment untuk menentukan banyak ReplicaSet
pada Deployment yang ingin dipertahankan. Sisanya akan di garbage-collected di balik layar. Umumnya, nilai kolom berisi 10.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Mengisi secara eksplisit dengan nilai 0 akan membuat pembersihan semua riwayat rilis Deployment
sehingga Deployment tidak akan dapat dikembalikan.</div><h2 id=deployment-canary>Deployment Canary</h2><p>Jika kamu ingin merilis ke sebagian pengguna atau server menggunakan Deployment,
kamu dapat membuat beberapa Deployment, satu tiap rilis, dengan mengikuti pola canary yang didesripsikan pada
<a href=/id/docs/concepts/cluster-administration/manage-deployment/#deploy-dengan-canary>mengelola sumber daya</a>.</p><h2 id=menulis-spesifikasi-deployment>Menulis Spesifikasi Deployment</h2><p>Sebagaimana konfigurasi Kubernetes lainnya, Deployment memerlukan kolom <code>apiVersion</code>, <code>kind</code>, dan <code>metadata</code>.
Untuk informasi umum tentang penggunaan berkas konfigurasi, lihat dokumen <a href=/id/docs/tutorials/stateless-application/run-stateless-application-deployment/>deploy aplikasi</a>,
mengatur kontainer, dan <a href=/id/docs/concepts/overview/working-with-objects/object-management/>memakai kubectl untuk mengatur sumber daya</a>.</p><p>Deployment juga perlu <a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status>bagian <code>.spec</code></a>.</p><h3 id=templat-pod>Templat Pod</h3><p>Dalam <code>.spec</code> hanya ada kolom <code>.spec.template</code> dan <code>.spec.selector</code> yang wajib diisi.</p><p><code>.spec.template</code> adalah <a href=/id/docs/concepts/workloads/pods/pod-overview/#templat-pod>templat Pod</a>. Dia memiliki skema yang sama dengan <a href=/id/docs/concepts/workloads/pods/pod/>Pod</a>. Bedanya dia bersarang dan tidak punya <code>apiVersion</code> atau <code>kind</code>.</p><p>Selain kolom wajib untuk Pod, templat Pod pada Deployment harus menentukan label dan aturan menjalankan ulang yang tepat.
Untuk label, pastikaan tidak bertumpang tindih dengan kontroler lainnya. Lihat <a href=#selektor>selektor</a>).</p><p><a href=/id/docs/concepts/workloads/pods/pod-lifecycle/#aturan-menjalankan-ulang><code>.spec.template.spec.restartPolicy</code></a> hanya boleh berisi <code>Always</code>,
yang tidak ditentukan pada bawaan.</p><h3 id=replika>Replika</h3><p><code>.spec.replicas</code> adalah kolom opsional yang mengatur jumlah Pod yang diinginkan. Setelan bawaannya berisi 1.</p><h3 id=selektor>Selektor</h3><p><code>.spec.selector</code> adalah kolom wajib yang mengatur <a href=/id/docs/concepts/overview/working-with-objects/labels/>selektor label</a>
untuk Pod yang dituju oleh Deployment ini.</p><p><code>.spec.selector</code> harus sesuai <code>.spec.template.metadata.labels</code>, atau akan ditolak oleh API.</p><p>Di versi API <code>apps/v1</code>, <code>.spec.selector</code> dan <code>.metadata.labels</code> tidak berisi <code>.spec.template.metadata.labels</code> jika tidak disetel.
Jadi mereka harus disetel secara eksplisit. Perhatikan juga <code>.spec.selector</code> tidak dapat diubah setelah Deployment dibuat pada <code>apps/v1</code>.</p><p>Deployment dapat mematikan Pod yang labelnya cocok dengan selektor jika templatnya berbeda
dari <code>.spec.template</code> atau total jumlah Pod melebihi <code>.spec.replicas</code>. Dia akan membuat Pod baru
dengan <code>.spec.template</code> jika jumlah Pod kurang dari yang diinginkan.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Kamu sebaiknya tidak membuat Pod lain yang labelnya cocok dengan selektor ini, baik secara langsung,
melalui Deployment lain, atau membuat kontroler lain seperti ReplicaSet atau ReplicationController.
Kalau kamu melakukannya, Deployment pertama akan mengira dia yang membuat Pod-pod ini.
Kubernetes tidak akan mencegahmu melakukannya.</div><p>Jika kamu punya beberapa kontroler dengan selektor bertindihan, mereka akan saling bertikai
dan tidak akan berjalan semestinya.</p><h3 id=strategi>Strategi</h3><p><code>.spec.strategy</code> mengatur strategi yang dipakai untuk mengganti Pod lama dengan yang baru.
<code>.spec.strategy.type</code> dapat berisi "Recreate" atau "RollingUpdate". Nilai bawaannya adalah "RollingUpdate".</p><h4 id=membuat-ulang-deployment>Membuat Ulang Deployment</h4><p>Semua Pod yang ada dimatikan sebelum yang baru dibuat ketika nilai <code>.spec.strategy.type==Recreate</code>.</p><h4 id=membarui-deployment-secara-bergulir>Membarui Deployment secara Bergulir</h4><p>Deployment membarui Pod secara bergulir
saat <code>.spec.strategy.type==RollingUpdate</code>. Kamu dapat menentukan <code>maxUnavailable</code> dan <code>maxSurge</code> untuk mengatur
proses pembaruan bergulir.</p><h5 id=ketidaktersediaan-maksimum>Ketidaktersediaan Maksimum</h5><p><code>.spec.strategy.rollingUpdate.maxUnavailable</code> adalah kolom opsional yang mengatur jumlah Pod maksimal
yang tidak tersedia selama proses pembaruan. Nilainya bisa berupa angka mutlak (contohnya 5)
atau persentase dari Pod yang diinginkan (contohnya 10%). Angka mutlak dihitung berdasarkan persentase
dengan pembulatan ke bawah. Nilai tidak bisa nol jika <code>.spec.strategy.rollingUpdate.maxSurge</code> juga nol.
Nilai bawaannya yaitu 25%.</p><p>Sebagai contoh, ketika nilai berisi 30%, ReplicaSet lama dapat segera diperkecil menjadi 70% dari Pod
yang diinginkan saat pembaruan bergulir dimulai. Seketika Pod baru siap, ReplicaSet lama dapat lebih diperkecil lagi,
diikuti dengan pembesaran ReplicaSet, menjamin total jumlah Pod yang siap kapanpun ketika pembaruan
paling sedikit 70% dari Pod yang diinginkan.</p><h5 id=kelebihan-maksimum>Kelebihan Maksimum</h5><p><code>.spec.strategy.rollingUpdate.maxSurge</code> adalah kolom opsional yang mengatur jumlah Pod maksimal yang
dapat dibuat melebihi jumlah Pod yang diinginkan. Nilainya bisa berupa angka mutlak (contohnya 5) atau persentase
dari Pod yang diinginkan (contohnya 10%). Nilai tidak bisa nol jika <code>MaxUnavailable</code> juga nol. Angka mutlak
dihitung berdasarkan persentase dengan pembulatan ke bawah. Nilai bawaannya yaitu 25%.</p><p>Sebagai contoh, ketika nilai berisi 30%, ReplicaSet baru dapat segera diperbesar saat pembaruan bergulir dimulai,
sehingga total jumlah Pod yang baru dan lama tidak melebihi 130% dari Pod yang diinginkan.
Saat Pod lama dimatikan, ReplicaSet baru dapat lebih diperbesar lagi, menjamin total jumlah Pod yang siap
kapanpun ketika pembaruan paling banyak 130% dari Pod yang diinginkan.</p><h3 id=tenggat-kemajuan-dalam-detik>Tenggat Kemajuan dalam Detik</h3><p><code>.spec.progressDeadlineSeconds</code> adalah kolom opsional yang mengatur lama tunggu dalam dalam detik untuk Deployment-mu berjalan
sebelum sistem melaporkan lagi bahwa Deployment <a href=#deployment-gagal>gagal</a> - ditunjukkan dengan kondisi <code>Type=Progressing</code>, <code>Status=False</code>,
dan <code>Reason=ProgressDeadlineExceeded</code> pada status sumber daya. Controller Deployment akan tetap mencoba ulang Deployment.
Nantinya begitu pengembalian otomatis diimplementasikan, kontroler Deployment akan membalikkan Deployment segera
saat dia menjumpai kondisi tersebut.</p><p>Jika ditentukan, kolom ini harus lebih besar dari <code>.spec.minReadySeconds</code>.</p><h3 id=lama-minimum-untuk-siap-dalam-detik>Lama Minimum untuk Siap dalam Detik</h3><p><code>.spec.minReadySeconds</code> adalah kolom opsional yang mengatur lama minimal sebuah Pod yang baru dibuat
seharusnya siap tanpa ada kontainer yang rusak, untuk dianggap tersedia, dalam detik.
Nilai bawaannya yaitu 0 (Pod akan dianggap tersedia segera ketika siap). Untuk mempelajari lebih lanjut
kapan Pod dianggap siap, lihat <a href=/id/docs/concepts/workloads/pods/pod-lifecycle/#pemeriksaan-kontainer>Pemeriksaan Kontainer</a>.</p><h3 id=kembali-ke>Kembali Ke</h3><p>Kolom <code>.spec.rollbackTo</code> telah ditinggalkan pada versi API <code>extensions/v1beta1</code> dan <code>apps/v1beta1</code>, dan sudah tidak didukung mulai versi API <code>apps/v1beta2</code>.
Sebagai gantinya, disarankan untuk menggunakan <code>kubectl rollout undo</code> sebagaimana diperkenalkan dalam <a href=#kembali-ke-revisi-sebelumnya>Kembali ke Revisi Sebelumnya</a>.</p><h3 id=batas-riwayat-revisi>Batas Riwayat Revisi</h3><p>Riwayat revisi Deployment disimpan dalam ReplicaSet yang dia kendalikan.</p><p><code>.spec.revisionHistoryLimit</code> adalah kolom opsional yang mengatur jumlah ReplicaSet lama yang dipertahankan
untuk memungkinkan pengembalian. ReplicaSet lama ini mengambil sumber daya dari <code>etcd</code> dan memunculkan keluaran
dari <code>kubectl get rs</code>. Konfigurasi tiap revisi Deployment disimpan pada ReplicaSet-nya; sehingga, begitu ReplicaSet lama dihapus,
kamu tidak mampu lagi membalikkan revisi Deployment-nya. Umumnya, 10 ReplicaSet lama akan dipertahankan,
namun nilai idealnya tergantung pada frekuensi dan stabilitas Deployment-deployment baru.</p><p>Lebih spesifik, mengisi kolom dengan nol berarti semua ReplicaSet lama dengan 0 replika akan dibersihkan.
Dalam kasus ini, rilis Deployment baru tidak dapat dibalikkan, sebab riwayat revisinya telah dibersihkan.</p><h3 id=terjeda>Terjeda</h3><p><code>.spec.paused</code> adalah kolom boolean opsional untuk menjeda dan melanjutkan Deployment. Perbedaan antara Deployment yang terjeda
dan yang tidak hanyalah perubahan apapun pada PodTemplateSpec Deployment terjeda tidak akan memicu rilis baru selama masih terjeda.
Deployment umumnya tidak terjeda saat dibuat.</p><h2 id=alternatif-untuk-deployment>Alternatif untuk Deployment</h2><h3 id=kubectl-rolling-update>kubectl rolling update</h3><p><a href=/id/docs/reference/generated/kubectl/kubectl-commands#rolling-update><code>kubectl rolling update</code></a> membarui Pod dan ReplicationController
dengan cara yang serupa. Namun, Deployments lebih disarankan karena deklaratif, berjalan di sisi server, dan punya fitur tambahan,
seperti pembalikkan ke revisi manapun sebelumnya bahkan setelah pembaruan rolling selesais.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-6d72299952c37ca8cc61b416e5bdbcd4>3.4.2.4 - StatefulSet</h1><p>StatefulSet merupakan salah satu objek API <em>workload</em> yang digunakan untuk aplikasi <em>stateful</em>.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> StatefulSet merupakan fitur stabil (GA) sejak versi 1.9.</div><p>Melakukan proses manajemen deployment dan <em>scaling</em> dari sebuah set <a class=glossary-tooltip title='Unit Kubernetes yang paling sederhana dan kecil. Sebuah Pod merepresentasikan sebuah set kontainer yang dijalankan pada kluster kamu.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pods>Pods</a>, <em>serta menjamin mekanisme <em>ordering</em> dan keunikan</em> dari Pod ini.</p><p>Seperti halnya <a class=glossary-tooltip title='Mengelola aplikasi yang direplikasi di dalam klastermu.' data-toggle=tooltip data-placement=top href=/id/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Deployment>Deployment</a>, sebuah StatefulSet akan melakukan proses manajemen Pod yang didasarkan pada spec container identik. Meskipun begitu tidak seperti sebuah Deployment, sebuah StatefulSet akan menjamin identitas setiap Pod yang ada. Pod ini akan dibuat berdasarkan spec yang sama, tetapi tidak dapat digantikan satu sama lainnya: setiap Pod memiliki identifier persisten yang akan di-maintain meskipun pod tersebut di (re)schedule.</p><p>Sebuah StatefulSet beroperasi dengan pola yang sama dengan Kontroler lainnya. Kamu dapat mendefinisikan state yang diinginkan pada objek StatefulSet, dan kontroler StatefulSet akan membuat update yang dibutuhkan dari <em>state</em> saat ini.</p><h2 id=menggunakan-statefulset>Menggunakan StatefulSet</h2><p>StatefulSet akan sangat bermanfaat apabila digunakan untuk aplikasi
yang membutuhkan salah satu atau beberapa fungsi berikut.</p><ul><li>Memiliki identitas jaringan unik yang stabil.</li><li>Penyimpanan persisten yang stabil.</li><li>Mekanisme <em>scaling</em> dan <em>deployment</em> yang <em>graceful</em> tertara berdasarkan urutan.</li><li>Mekanisme <em>rolling update</em> yang otomatis berdasarkan urutan.</li></ul><p>Stabil dalam poin-poin di atas memiliki arti yang sama dengan persisten pada
Pod saat dilakukan <em>(re)scheduling</em>. Jika suatu aplikasi tidak membutuhkan
identitas yang stabil atau <em>deployment</em> yang memiliki urutan, penghapusan, atau
mekanisme <em>scaling</em>, kamu harus melakukan <em>deploy</em> aplikasi dengan <em>controller</em> yang menyediakan
replika <em>stateless</em>. <em>Controller</em> seperti <a href=/id/docs/concepts/workloads/controllers/deployment/>Deployment</a> atau
<a href=/id/docs/concepts/workloads/controllers/replicaset/>ReplicaSet</a> akan lebih sesuai dengan kebutuhan kamu.</p><h2 id=keterbatasan>Keterbatasan</h2><ul><li>StatefulSet merupakan sumber daya beta sebelum 1.9 dan tidak tersedia
pada Kubernetes rilis sebelum versi 1.5.</li><li>Penyimpanan untuk sebuah Pod harus terlebih dahulu di-<em>provision</em> dengan menggunakan sebuah <a href=https://github.com/kubernetes/examples/tree/main/staging/persistent-volume-provisioning/README.md>Provisioner PersistentVolume</a> berdasarkan <code>storage class</code> yang dispesifikasikan, atau sudah ditentukan sebelumnya oleh administrator.</li><li>Menghapus dan/atau <em>scaling</em> sebuah StatefulSet <em>tidak akan</em> menghapus volume yang berkaitan dengan StatefulSet tersebut. Hal ini dilakukan untuk menjamin data yang disimpan, yang secara umum dinilai lebih berhaga dibandingkan dengan mekanisme penghapusan data secara otomatis pada sumber daya terkait.</li><li>StatefulSet saat ini membutuhkan sebuah <a href=/id/docs/concepts/services-networking/service/#headless-services>Headless Service</a> yang nantinya akan bertanggung jawab terhadap pada identitas jaringan pada Pod. Kamulah yang bertanggung jawab untuk membuat Service tersebut.</li><li>StatefulSet tidak menjamin terminasi Pod ketika sebuah StatefulSet dihapus. Untuk mendapatkan terminasi Pod yang terurut dan <em>graceful</em> pada StatefulSet, kita dapat melakukan <em>scale down</em> Pod ke 0 sebelum penghapusan.</li><li>Ketika menggunakan <a href=#mekanisme-strategi-update-rolling-update>Rolling Update</a> dengan
<a href=#kebijakan-manajemen-pod>Kebijakan Manajemen Pod</a> (<code>OrderedReady</code>) secara default,
hal ini memungkinkan untuk mendapatkan <em>state</em> yang lebih terperinci yang membutuhkan
<a href=#forced-rollback>mekanisme intervensi manual untuk perbaikan</a>.</li></ul><h2 id=komponen-komponen>Komponen-Komponen</h2><p>Contoh di bawah ini akna menunjukkan komponen-komponen penyusun StatefulSet.</p><ul><li>Sebuah Service Headless, dengan nama nginx, digunakan untuk mengontrol domain jaringan.</li><li>StatefulSet, dengan nama web, memiliki Spek yang mengindikasikan terdapat 3 replika Container yang akan dihidupkan pada Pod yang unik.</li><li><em>Field</em> <code>volumeClaimTemplates</code> akan menyediakan penyimpanan stabil menggunakan <a href=/id/docs/concepts/storage/persistent-volumes/>PersistentVolume</a> yang di-<em>provision</em> oleh sebuah Provisioner PersistentVolume.</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>web<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clusterIP</span>:<span style=color:#bbb> </span>None<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StatefulSet<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>web<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb> </span><span style=color:#080;font-style:italic># harus sesuai dengan .spec.template.metadata.labels</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>serviceName</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;nginx&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># nilai default-nya adalah 1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb> </span><span style=color:#080;font-style:italic># harus sesuai dengan .spec.selector.matchLabels</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>terminationGracePeriodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/nginx-slim:0.8<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>web<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>www<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/usr/share/nginx/html<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeClaimTemplates</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>www<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;ReadWriteOnce&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;my-storage-class&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>1Gi<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=selector-pod><em>Selector</em> Pod</h2><p>Kamu harus menspesifikasikan <em>field</em> <code>.spec.selector</code> dari sebuah StatefulSet untuk menyesuaikan dengan label yang ada pada <code>.spec.template.metadata.labels</code>. Sebelum Kubernetes 1.8, <em>field</em> <code>.spec.selector</code> dapat diabaikan. Sejak versi 1.8 dan versi selanjutnya, apabila tidak terdapat <em>selector</em> Pod yang sesuai maka akan menghasilkan eror pada validasi pembuatan StatefulSet.</p><h2 id=identitas-pod>Identitas Pod</h2><p>Pod pada StatefulSet memiliki identitas unik yang tersusun berdasarkan skala ordinal, sebuah
identitas jaringan yang stabil, serta penyimpanan yang stabil. Identitas yang ada pada Pod
ini akan tetap melekat, meskipun Pod tersebut dilakukan <em>(re)schedule</em> pada Node yang berbeda.</p><h3 id=indeks-ordinal>Indeks Ordinal</h3><p>Untuk sebuah StatefulSet dengan N buah replika, setiap Pod di dalam StatefulSet akan
diberi nama pada suatu indeks ordinal tertentu, dari 0 hingga N-1, yang unik pada Set ini.</p><h3 id=id-jaringan-yang-stabil>ID Jaringan yang Stabil</h3><p>Setiap Pod di dalam StatefulSet memiliki <em>hostname</em> diturunkan dari nama SatetulSet tersebut
serta ordinal Pod tersebut. Pola pada <em>hostname</em> yang terbentuk adalah
<code>$(statefulset name)-$(ordinal)</code>. Contoh di atas akan menghasilkan tiga Pod
dengan nama <code>web-0,web-1,web-2</code>.
Sebuah StatefulSet dapat menggunakan sebuah <a href=/id/docs/concepts/services-networking/service/#headless-services>Service Headless</a>
untuk mengontrol domain dari Pod yang ada. Domain yang diatur oleh Service ini memiliki format:
<code>$(service name).$(namespace).svc.cluster.local</code>, dimana "cluster.local" merupakan
domain klaster.
Seiring dibuatnya setiap Pod, Pod tersebut akan memiliki subdomain DNS-nya sendiri, yang memiliki format:
<code>$(podname).$(governing service domain)</code>, dimana Service yang mengatur didefinisikan oleh
<em>field</em> <code>serviceName</code> pada StatefulSet.</p><p>Seperti sudah disebutkan di dalam bagian <a href=#keterbatasan>keterbatasan</a>, kamulah yang bertanggung jawab
untuk membuat <a href=/id/docs/concepts/services-networking/service/#headless-services>Service Headless</a>
yang bertanggung jawab terhadap identitas jaringan pada Pod.</p><p>Di sini terdapat beberapa contoh penggunaan Domain Klaster, nama Service,
nama StatefulSet, dan bagaimana hal tersebut berdampak pada nama DNS dari Pod StatefulSet.</p><table><thead><tr><th>Domain Klaster</th><th>Service (ns/nama)</th><th>StatefulSet (ns/nama)</th><th>Domain StatefulSet</th><th>DNS Pod</th><th>Hostname Pod</th></tr></thead><tbody><tr><td>cluster.local</td><td>default/nginx</td><td>default/web</td><td>nginx.default.svc.cluster.local</td><td>web-{0..N-1}.nginx.default.svc.cluster.local</td><td>web-{0..N-1}</td></tr><tr><td>cluster.local</td><td>foo/nginx</td><td>foo/web</td><td>nginx.foo.svc.cluster.local</td><td>web-{0..N-1}.nginx.foo.svc.cluster.local</td><td>web-{0..N-1}</td></tr><tr><td>kube.local</td><td>foo/nginx</td><td>foo/web</td><td>nginx.foo.svc.kube.local</td><td>web-{0..N-1}.nginx.foo.svc.kube.local</td><td>web-{0..N-1}</td></tr></tbody></table><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Domain klaster akan diatur menjadi <code>cluster.local</code> kecuali
<a href=/id/docs/concepts/services-networking/dns-pod-service/>nilainya dikonfigurasi</a>.</div><h3 id=penyimpanan-stabil>Penyimpanan Stabil</h3><p>Kubernetes membuat sebuah <a href=/id/docs/concepts/storage/persistent-volumes/>PersistentVolume</a> untuk setiap
VolumeClaimTemplate. Pada contoh nginx di atas, setiap Pod akan menerima sebuah PersistentVolume
dengan StorageClass <code>my-storage-class</code> dan penyimpanan senilai 1 Gib yang sudah di-<em>provisioning</em>. Jika tidak ada StorageClass
yang dispesifikasikan, maka StorageClass <em>default</em> akan digunakan. Ketika sebuah Pod dilakukan <em>(re)schedule</em>
pada sebuah Node, <code>volumeMounts</code> akan me-<em>mount</em> PersistentVolumes yang terkait dengan
PersistentVolume Claim-nya. Perhatikan bahwa, PersistentVolume yang terkait dengan
PersistentVolumeClaim dari Pod tidak akan dihapus ketika Pod, atau StatefulSet dihapus.
Penghapusan ini harus dilakukan secara manual.</p><h3 id=label-pod-name>Label <em>Pod Name</em></h3><p>Ketika sebuah <em>controller</em> StatefulSet membuat sebuah Pod, <em>controller</em> ini akan menambahkan label, <code>statefulset.kubernetes.io/pod-name</code>,
yang akan diaktifkan pada nama Pod. Label ini akan mengizinkan kamu untuk meng-<em>attach</em> sebuah Service pada Pod spesifik tertentu.
di StatefulSet.</p><h2 id=jaminan-deployment-dan-mekanisme-scaling>Jaminan Deployment dan Mekanisme <em>Scaling</em></h2><ul><li>Untuk sebuah StatefulSet dengan N buah replika, ketika Pod di-<em>deploy</em>, Pod tersebut akan dibuat secara berurutan dengan urutan nilai {0..N-1}.</li><li>Ketika Pod dihapus, Pod tersebut akan dihentikan dengan urutan terbalik, yaitu {N-1..0}.</li><li>Sebelum operasi <em>scaling</em> diaplikasikan pada sebuah Pod, semua Pod sebelum Pod tersebut haruslah sudah dalam status Running dan Ready.</li><li>Sebelum sebuah Pod dihentikan, semua Pod setelah Pod tersebut haruslah sudah terlebih dahulu dihentikan.</li></ul><p>StatefulSet tidak boleh menspesifikasikan nilai dari <code>pod.Spec.TerminationGracePeriodSeconds</code> menjadi 0. Hal ini tidaklah aman dan tidak disarankan. Untuk penjelasan lebih lanjut, silakan lihat <a href=/docs/tasks/run-application/force-delete-stateful-set-pod/>penghapusan paksa Pod pada StatefulSet</a>.</p><p>Ketika contoh nginx di atas dibuat, tiga Pod akan di-<em>deploy</em> dengan urutan
web-0, web-1, web-2. web-1 tidak akan di-<em>deploy</em> sebelum web-0 berada dalam status
<a href=/docs/user-guide/pod-states/>Running dan Ready</a>, dan web-2 tidak akan di-<em>deploy</em> sebelum
web-1 berada dalam status Running dan Ready. Jika web-0 gagal, setelah web-1 berada dalam status Running and Ready,
tapi sebelum web-2 dibuat, maka web-2 tidak akan dibuat hingga web-0 sukses dibuat ulang dan
berada dalam status Running dan Ready.</p><p>Jika seorang pengguna akan melakukan mekanisme <em>scale</em> pada contoh di atas dengan cara melakukan <em>patch</em>,
pada StatefulSet sehingga <code>replicas=1</code>, maka web-2 akan dihentikan terlebih dahulu.
web-1 tidak akan dihentikan hingga web-2 benar-benar berhenti dan dihapus.
Jika web-0 gagal setelah web-2 diterminasi dan berada dalam status mati,
tetapi sebelum web-1 dihentikan, maka web-1 tidak akan dihentikan hingga
web-0 berada dalam status Running dan Ready.</p><h3 id=kebijakan-manajemen-pod>Kebijakan Manajemen Pod</h3><p>Pada Kubernetes versi 1.7 dan setelahnya, StatefulSet mengizinkan kamu untuk
melakukan mekanisme urutan tadi menjadi lebih fleksibel dengan tetap
menjamin keunikan dan identitas yang ada melalui <em>field</em> <code>.spec.podManagementPolicy</code>.</p><h4 id=manajemen-orderedready-pada-pod>Manajemen OrderedReady pada Pod</h4><p>Manajemen <code>OrderedReady</code> pada Pod merupakan nilai default dari StatefulSet.
Hal ini akan mengimplementasikan perilaku yang dijelaskan <a href=#jaminan-deployment-dan-mekanisme-scaling>di atas</a>.</p><h4 id=manajemen-pod-secara-paralel>Manajemen Pod secara Paralel</h4><p>Manajemen Pod secara <code>paralel</code> akan menyebabkan kontroler StatefulSet untuk
memulai atau menghentikan semua Pod yang ada secara paralel, dan tidak
menunggu Pod berada dalam status Running dan Ready atau sudah dihentikan secara menyeluruh
sebelum me-<em>launch</em> atau menghentikan Pod yang lain. Opsi ini hanya akan memengaruhi operasi
<em>scaling</em>. Operasi pembaruan tidak akan terpengaruh.</p><h2 id=strategi-update>Strategi Update</h2><p>Pada Kubernetes versi 1.7 dan setelahnya, <em>field</em> <code>.spec.updateStrategy</code> pada StatefulSet
memungkinkan-mu untuk melakukan konfigurasi dan menonaktifkan otomatisasi
<em>rolling updates</em> untuk container, label, resource request/limits, dan
annotation pada Pod yang ada di dalam sebuah StatefulSet.</p><h3 id=mekanisme-strategi-update-on-delete>Mekanisme Strategi Update <em>On Delete</em></h3><p>Mekanisme strategi update <code>OnDelete</code> mengimplementasikan perilaku legasi (versi 1.6 dan sebelumnya).
Ketika sebuah <em>field</em> <code>.spec.updateStrategy.type</code> pada StatefulSet diubah menjadi <code>OnDelete</code>
maka kontroler StatefulSet tidak akan secara otomatis melakukan update
pada Pod yang ada di dalam StatefulSet tersebut. Pengguna haruslah secara manual
melakukan penghapusan Pod agar kontroler membuat Pod baru yang mengandung modifikasi
yang dibuat pada <em>field</em> <code>.spec.template</code> StatefulSet.</p><h3 id=mekanisme-strategi-update-rolling-updates>Mekanisme Strategi Update <em>Rolling Updates</em></h3><p>Mekanisme strategi update <code>RollingUpdate</code> mengimplementasikan otomatisasi <em>rolling update</em>
untuk Pod yang ada pada StatefulSet. Strategi inilah yang diterapkan ketika <code>.spec.updateStrategy</code> tidak dispesifikasikan.
Ketika <em>field</em> <code>.spec.updateStrategy.type</code> diubah nilainya menjadi <code>RollingUpdate</code>, maka
kontroler StatefulSet akan menghapus dan membuat setiap Pod di dalam StatefulSet. Kemudian
hal ini akan diterapkan dengan urutan yang sama dengan mekanisme terminasi Pod (dari nilai ordinal terbesar ke terkecil),
yang kemudian akan melakukan update Pod satu per satu. Mekanisme ini akan memastikan sebuah Pod yang di-update
berada dalam status Running dan Ready sebelum meng-update Pod dengan nilai ordinal lebih rendah.</p><h4 id=mekanisme-strategi-update-dengan-partisi>Mekanisme Strategi Update dengan Partisi</h4><p>Mekanisme strategi update <code>RollingUpdate</code> dapat dipartisi, dengan cara menspesifikasikan nilai
dari <code>.spec.updateStrategy.rollingUpdate.partition</code>. Jika nilai dari <em>field</em> ini dispesifikasikan,
maka semua Pod dengan nilai ordinal yang lebih besar atau sama dengan nilai partisi akan diupdate ketika
nilai <code>.spec.template</code> pada StatefulSet diubah. Semua Pod dengan nilai ordinal yang lebih kecil
dari partisi tidak akan diupdate, dan, bahkan setelah Pod tersebut dihapus, Pod ini akan digantikan
dengan Pod versi sebelumnya. Jika nilai <code>.spec.updateStrategy.rollingUpdate.partition</code> lebih besar dari
nilai <code>.spec.replicas</code>, update pada <code>.spec.template</code> tidak akan dipropagasi pada Pod-Pod-nya.
Pada sebagian besar kasus, kamu tidak akan perlu menggunakan partisi, tapi hal tersebut
akan sangat berguna apabila kamu ingin mekakukan mekanisme update <em>canary</em>.</p><h4 id=mekanisme-strategi-update-yang-dipaksa-forced-rollback>Mekanisme Strategi Update yang Dipaksa (<em>Forced Rollback</em>)</h4><p>Ketika menggunakan strategi update <a href=#mekanisme-strategi-update-rolling-updates>Rolling Updates</a> dengan nilai default
<a href=#kebijakan-manajemen-pod>Kebijakan Manajemen Pod</a> (<code>OrderedReady</code>),
hal ini memungkinkan adanya kondisi <em>broken</em> yang membutuhkan intervensi secara manual
agar kondisi ini dapat diperbaiki.</p><p>Jika kamu melakukan update pada template Pod untuk konfigurasi
yang tidak pernah berada dalam status Running dan Ready (sebagai contohnya, apabila terdapat kode <em>binary</em> yang buruk atau error pada konfigurasi di level aplikasi),
maka StatefulSet akan menghentikan proses rollout dan berada dalam status <em>wait</em>.</p><p>Dalam kondisi ini, maka templat Pod tidak akan diubah secara otomatis pada konfigurasi sebelumnya
Hal ini terjadi karena adanya <a href=https://github.com/kubernetes/kubernetes/issues/67250>isu</a>,
StatefulSet akan tetap berada dalam kondisi <em>wait</em> untuk menunggu Pod yang bermasalah untuk menjadi Ready
(yang tidak akan terjadi) dan sebelum StatefulSet ini berusaha untuk melakukan <em>revert</em> pada konfigurasi sebelumnya.</p><p>Setelah melakukan mekanisme <em>revert</em> templat, kamu juga harus menghapus semua Pod di dalam
StatefulSet tersebut yang telah berusaha untuk menggunakan konfigurasi yang <em>broken</em>.
StatefulSet akan mulai membuat Pod dengan templat konfigurasi yang sudah di-<em>revert</em>.</p><h2 id=selanjutnya>Selanjutnya</h2><ul><li>Ikuti contoh yang ada pada <a href=/docs/tutorials/stateful-application/basic-stateful-set/>bagaimana cara melakukan deployi aplikasi stateful</a>.</li><li>Ikuti contoh yang ada pada <a href=/docs/tutorials/stateful-application/cassandra/>bagaimana cara melakukan deploy Cassandra dengan StatefulSets</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-41600eb8b6631c88848156f381e9d588>3.4.2.5 - DaemonSet</h1><p>DaemonSet memastikan semua atau sebagian Node memiliki salinan sebuah Pod.
Ketika Node baru ditambahkan ke klaster, Pod ditambahkan ke Node tersebut.
Ketika Node dihapus dari klaster, Pod akan dibersihkan oleh <em>garbage collector</em>.
Menghapus DaemonSet akan menghapus semua Pod yang ia buat.</p><p>Beberapa penggunaan umum DaemonSet, yaitu:</p><ul><li>menjalankan <em>daemon</em> penyimpanan di klaster, seperti <code>glusterd</code>, <code>ceph</code>, di
setiap Node.</li><li>menjalankan <em>daemon</em> pengumpulan log di semua Node, seperti <code>fluentd</code> atau
<code>logstash</code>.</li><li>menjalankan <em>daemon</em> pemantauan Node di setiap Node, seperti <a href=https://github.com/prometheus/node_exporter>Prometheus Node Exporter</a>, <a href=https://github.com/Flowmill/flowmill-k8s/>Flowmill</a>, <a href=https://docs.sysdig.com>Sysdig Agent</a>, <code>collectd</code>, <a href=https://www.dynatrace.com/technologies/kubernetes-monitoring/>Dynatrace OneAgent</a>, <a href=https://docs.appdynamics.com/display/CLOUD/Container+Visibility+with+Kubernetes>AppDynamics Agent</a>, <a href=https://docs.datadoghq.com/agent/kubernetes/daemonset_setup/>Datadog agent</a>, <a href=https://docs.newrelic.com/docs/integrations/kubernetes-integration/installation/kubernetes-installation-configuration>New Relic agent</a>, Ganglia <code>gmond</code> atau <a href=https://www.instana.com/supported-integrations/kubernetes-monitoring/>Instana Agent</a>.</li></ul><p>Dalam kasus sederhana, satu DaemonSet, mencakup semua Node, akan digunakan untuk
setiap jenis <em>daemon</em>. Pengaturan yang lebih rumit bisa saja menggunakan lebih
dari satu DaemonSet untuk satu jenis <em>daemon</em>, tapi dengan <em>flag</em> dan/atau
permintaan cpu/memori yang berbeda untuk jenis <em>hardware</em> yang berbeda.</p><h2 id=menulis-spek-daemonset>Menulis Spek DaemonSet</h2><h3 id=buat-daemonset>Buat DaemonSet</h3><p>Kamu bisa definisikan DaemonSet dalam berkas YAML. Contohnya, berkas
<code>daemonset.yaml</code> di bawah mendefinisikan DaemonSet yang menjalankan <em>image</em> Docker
fluentd-elasticsearch:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/controllers/daemonset.yaml download=controllers/daemonset.yaml><code>controllers/daemonset.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("controllers-daemonset-yaml")' title="Copy controllers/daemonset.yaml to clipboard"></img></div><div class=includecode id=controllers-daemonset-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>DaemonSet<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fluentd-elasticsearch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>k8s-app</span>:<span style=color:#bbb> </span>fluentd-logging<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fluentd-elasticsearch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fluentd-elasticsearch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>tolerations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>node-role.kubernetes.io/master<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>Exists<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span>NoSchedule<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fluentd-elasticsearch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>quay.io/fluentd_elasticsearch/fluentd:v2.5.2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>200Mi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>100m<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>200Mi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/log<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlibdockercontainers<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/lib/docker/containers<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>terminationGracePeriodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>30</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/var/log<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlibdockercontainers<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/var/lib/docker/containers<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><ul><li>Buat DaemonSet berdasarkan berkas YAML:</li></ul><pre tabindex=0><code>kubectl apply -f https://k8s.io/examples/controllers/daemonset.yaml
</code></pre><h3 id=field-wajib><em>Field</em> Wajib</h3><p>Seperti semua konfigurasi Kubernetes lainnya, DaemonSet membutuhkan <em>field</em>
<code>apiVersion</code>, <code>kind</code>, dan <code>metadata</code>. Untuk informasi umum tentang berkas konfigurasi, lihat dokumen <a href=/docs/user-guide/deploying-applications/>men-<em>deploy</em> aplikasi</a>,
<a href=/docs/tasks/>pengaturan kontainer</a>, dan <a href=/id/docs/concepts/overview/working-with-objects/object-management/>pengelolaan objek dengan kubectl</a>.</p><p>DaemonSet juga membutuhkan bagian <a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status><code>.spec</code></a>.</p><h3 id=templat-pod>Templat Pod</h3><p><code>.spec.template</code> adalah salah satu <em>field</em> wajib di dalam <code>.spec</code>.</p><p><code>.spec.template</code> adalah sebuah <a href=/id/docs/concepts/workloads/pods/pod-overview/#templat-pod>templat Pod</a>. Skemanya benar-benar sama dengan <a href=/id/docs/concepts/workloads/pods/pod/>Pod</a>, kecuali bagian bahwa ia bersarang/<em>nested</em> dan tidak memiliki <code>apiVersion</code> atau <code>kind</code>.</p><p>Selain <em>field</em> wajib untuk Pod, templat Pod di DaemonSet harus
menspesifikasikan label yang sesuai (lihat <a href=#selektor-pod>selektor Pod</a>).</p><p>Templat Pod di DaemonSet harus memiliki <a href=/id/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy><code>RestartPolicy</code></a>
yang bernilai <code>Always</code>, atau tidak dispesifikasikan, sehingga <em>default</em> menjadi <code>Always</code>.
DaemonSet dengan nilai <code>Always</code> membuat Pod akan selalu di-<em>restart</em> saat kontainer
keluar/berhenti atau terjadi <em>crash</em>.</p><h3 id=selektor-pod>Selektor Pod</h3><p><em>Field</em> <code>.spec.selector</code> adalah selektor Pod. Cara kerjanya sama dengan <code>.spec.selector</code> pada <a href=/docs/concepts/jobs/run-to-completion-finite-workloads/>Job</a>.</p><p>Pada Kubernetes 1.8, kamu harus menspesifikasikan selektor Pod yang cocok dengan label pada <code>.spec.template</code>.
Selektor Pod tidak akan lagi diberi nilai <em>default</em> ketika dibiarkan kosong. Nilai <em>default</em> selektor tidak
cocok dengan <code>kubectl apply</code>. Juga, sesudah DaemonSet dibuat, <code>.spec.selector</code> tidak dapat diubah.
Mengubah selektor Pod dapat menyebabkan Pod <em>orphan</em> yang tidak disengaja, dan membingungkan pengguna.</p><p>Objek <code>.spec.selector</code> memiliki dua <em>field</em>:</p><ul><li><code>matchLabels</code> - bekerja seperti <code>.spec.selector</code> pada <a href=/id/docs/concepts/workloads/controllers/replicationcontroller/>ReplicationController</a>.</li><li><code>matchExpressions</code> - bisa digunakan untuk membuat selektor yang lebih canggih
dengan mendefinisikan <em>key</em>, daftar <em>value</em> dan operator yang menyatakan
hubungan antara <em>key</em> dan <em>value</em>.</li></ul><p>Ketika keduanya dispesifikasikan hasilnya diperoleh dari operasi AND.</p><p>Jika <code>.spec.selector</code> dispesifikasikan, nilainya harus cocok dengan <code>.spec.template.metadata.labels</code>. Konfigurasi yang tidak cocok akan ditolak oleh API.</p><p>Selain itu kamu tidak seharusnya membuat Pod apapun yang labelnya cocok dengan
selektor tersebut, entah secara langsung, via DaemonSet lain, atau via <em>workload resource</em> lain seperti ReplicaSet.
Jika kamu coba buat, <a class=glossary-tooltip title='Kontrol tertutup yang mengawasi kondisi bersama dari klaster melalui apiserver dan membuat perubahan yang mencoba untuk membawa kondisi saat ini ke kondisi yang diinginkan.' data-toggle=tooltip data-placement=top href=/id/docs/concepts/architecture/controller/ target=_blank aria-label=Pengontrol>Pengontrol</a> DaemonSet akan
berpikir bahwa Pod tersebut dibuat olehnya. Kubernetes tidak akan menghentikan
kamu melakukannya. Contoh kasus di mana kamu mungkin melakukan ini dengan
membuat Pod dengan nilai yang berbeda di sebuah Node untuk <em>testing</em>.</p><h3 id=menjalankan-pod-di-sebagian-node>Menjalankan Pod di Sebagian Node</h3><p>Jika kamu menspesifikasikan <code>.spec.template.spec.nodeSelector</code>, maka <em>controller</em> DaemonSet akan
membuat Pod pada Node yang cocok dengan <a href=/id/docs/concepts/scheduling-eviction/assign-pod-node/>selektor
Node</a>. Demikian juga, jika kamu menspesifikasikan <code>.spec.template.spec.affinity</code>,
maka <em>controller</em> DaemonSet akan membuat Pod pada Node yang cocok dengan <a href=/id/docs/concepts/scheduling-eviction/assign-pod-node/>Node affinity</a>.
Jika kamu tidak menspesifikasikan sama sekali, maka <em>controller</em> DaemonSet akan
membuat Pod pada semua Node.</p><h2 id=bagaimana-pod-daemon-dijadwalkan>Bagaimana Pod Daemon Dijadwalkan</h2><h3 id=dijadwalkan-oleh-default-scheduler>Dijadwalkan oleh <em>default scheduler</em></h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes 1.17 [stable]</code></div><p>DaemonSet memastikan bahwa semua Node yang memenuhi syarat menjalankan salinan
Pod. Normalnya, Node yang menjalankan Pod dipilih oleh <em>scheduler</em> Kubernetes.
Namun, Pod DaemonSet dibuat dan dijadwalkan oleh <em>controller</em> DaemonSet. Hal ini
mendatangkan masalah-masalah berikut:</p><ul><li>Inkonsistensi perilaku Pod: Pod normal yang menunggu dijadwalkan akan dibuat
dalam keadaan <code>Pending</code>, tapi Pod DaemonSet tidak seperti itu. Ini
membingungkan untuk pengguna.</li><li><a href=/id/docs/concepts/configuration/pod-priority-preemption/>Pod preemption</a>
ditangani oleh <em>default scheduler</em>. Ketika <em>preemption</em> dinyalakan,
<em>controller</em> DaemonSet akan membuat keputusan penjadwalan tanpa
memperhitungkan prioritas Pod dan <em>preemption</em>.</li></ul><p><code>ScheduleDaemonSetPods</code> mengizinkan kamu untuk menjadwalkan DaemonSet
menggunakan <em>default scheduler</em> daripada <em>controller</em> DaemonSet, dengan
menambahkan syarat <code>NodeAffinity</code> pada Pod DaemonSet daripada syarat
<code>.spec.nodeName</code>. Kemudian, <em>default scheduler</em> digunakan untuk mengikat Pod ke
host target. Jika afinitas Node dari Pod DaemonSet sudah ada, maka ini
akan diganti. <em>Controller DaemonSet</em> hanya akan melakukan operasi-operasi ini
ketika membuat atau mengubah Pod DaemonSet, dan tidak ada perubahan yang terjadi
pada <code>spec.template</code> DaemonSet.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>nodeAffinity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>requiredDuringSchedulingIgnoredDuringExecution</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>nodeSelectorTerms</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>matchFields</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>metadata.name<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- target-host-name<span style=color:#bbb>
</span></span></span></code></pre></div><p>Sebagai tambahan, <em>toleration</em> <code>node.kubernetes.io/unschedulable:NoSchedule</code>
ditambahkan secara otomatis pada Pod DaemonSet. <em>Default scheduler</em> akan
mengabaikan Node <code>unschedulable</code> ketika menjadwalkan Pod DaemonSet.</p><h3 id=taint-dan-toleration><em>Taint</em> dan <em>Toleration</em></h3><p>Meskipun Pod Daemon menghormati
<a href=/id/docs/concepts/configuration/taint-and-toleration>taint dan toleration</a>,
<em>toleration</em> berikut ini akan otomatis ditambahkan ke Pod DaemonSet sesuai
dengan fitur yang bersangkutan.</p><table><thead><tr><th><em>Toleration Key</em></th><th><em>Effect</em></th><th>Versi</th><th>Deskripsi</th></tr></thead><tbody><tr><td><code>node.kubernetes.io/not-ready</code></td><td>NoExecute</td><td>1.13+</td><td>Pod DaemonSet tidak akan menjadi <em>evicted</em> ketika ada masalah Node seperti partisi jaringan.</td></tr><tr><td><code>node.kubernetes.io/unreachable</code></td><td>NoExecute</td><td>1.13+</td><td>Pod DaemonSet tidak akan menjadi <em>evicted</em> ketika ada masalah Node seperti partisi jaringan.</td></tr><tr><td><code>node.kubernetes.io/disk-pressure</code></td><td>NoSchedule</td><td>1.8+</td><td></td></tr><tr><td><code>node.kubernetes.io/memory-pressure</code></td><td>NoSchedule</td><td>1.8+</td><td></td></tr><tr><td><code>node.kubernetes.io/unschedulable</code></td><td>NoSchedule</td><td>1.12+</td><td>Pod DaemonSet mentoleransi atribut <code>unschedulable</code> <em>default scheduler</em>.</td></tr><tr><td><code>node.kubernetes.io/network-unavailable</code></td><td>NoSchedule</td><td>1.12+</td><td>Pod DaemonSet yang menggunakan jaringan host mentoleransi atribut <code>network-unavailable</code> <em>default scheduler</em>.</td></tr></tbody></table><h2 id=berkomunikasi-dengan-pod-daemon>Berkomunikasi dengan Pod Daemon</h2><p>Beberapa pola yang mungkin digunakan untuk berkomunikasi dengan Pod dalam DaemonSet, yaitu:</p><ul><li><strong>Push</strong>: Pod dalam DaemonSet diatur untuk mengirim pembaruan status ke servis lain,
contohnya <em>stats database</em>. Pod ini tidak memiliki klien.</li><li><strong>IP Node dan Konvensi Port</strong>: Pod dalam DaemonSet dapat menggunakan <code>hostPort</code>, sehingga Pod dapat diakses menggunakan IP Node. Klien tahu daftar IP Node dengan suatu cara, dan tahu port berdasarkan konvensi.</li><li><strong>DNS</strong>: Buat <a href=/id/docs/concepts/services-networking/service/#headless-services>headless service</a> dengan Pod selektor yang sama,
dan temukan DaemonSet menggunakan <em>resource</em> <code>endpoints</code> atau mengambil beberapa A <em>record</em> dari DNS.</li><li><strong>Service</strong>: Buat Servis dengan Pod selektor yang sama, dan gunakan Servis untuk mengakses <em>daemon</em> pada
Node random. (Tidak ada cara mengakses spesifik Node)</li></ul><h2 id=melakukan-pembaruan-daemonset>Melakukan Pembaruan DaemonSet</h2><p>Jika label Node berubah, DaemonSet akan menambahkan Pod ke Node cocok yang baru dan menghapus Pod dari
Node tidak cocok yang baru.</p><p>Kamu bisa mengubah Pod yang dibuat DaemonSet. Namun, Pod tidak membolehkan perubahan semua <em>field</em>.
Perlu diingat, <em>controller</em> DaemonSet akan menggunakan templat yang asli di waktu selanjutnya
Node baru (bahkan dengan nama yang sama) dibuat.</p><p>Kamu bisa menghapus DaemonSet. Jika kamu spesifikasikan <code>--cascade=false</code> dengan <code>kubectl</code>, maka
Pod akan dibiarkan pada Node. Jika kamu pada waktu kemudian membuat DaemonSet baru dengan selektor
yang sama, DaemonSet yang baru akan mengadopsi Pod yang sudah ada. Jika ada Pod yang perlu diganti,
DaemonSet akan mengganti sesuai dengan <code>updateStrategy</code>.</p><p>Kamu bisa <a href=/docs/tasks/manage-daemon/update-daemon-set/>melakukan rolling update</a> pada DaemonSet.</p><h2 id=alternatif-daemonset>Alternatif DaemonSet</h2><h3 id=init-scripts><em>Init Scripts</em></h3><p>Kamu mungkin menjalankan proses <em>daemon</em> dengan cara menjalankan mereka langsung pada Node (e.g.
menggunakan <code>init</code>, <code>upstartd</code>, atau <code>systemd</code>). Tidak ada salahnya seperti itu. Namun, ada beberapa
keuntungan menjalankan proses <em>daemon</em> via DaemonSet.</p><ul><li>Kemampuan memantau dan mengatur log <em>daemon</em> dengan cara yang sama dengan aplikasi.</li><li>Bahasa dan alat Konfigurasi yang sama (e.g. Templat Pod, <code>kubectl</code>) untuk <em>daemon</em> dan aplikasi.</li><li>Menjalankan <em>daemon</em> dalam kontainer dengan batasan <em>resource</em> meningkatkan isolasi antar <em>daemon</em> dari
kontainer aplikasi. Namun, hal ini juga bisa didapat dengan menjalankan <em>daemon</em> dalam kontainer tapi
tanpa Pod (e.g. dijalankan langsung via Docker).</li></ul><h3 id=pod-polosan>Pod Polosan</h3><p>Dimungkinkan untuk membuat Pod langsung dengan menspesifikasikan Node mana untuk dijalankan. Namun,
DaemonSet akan menggantikan Pod yang untuk suatu alasan dihapus atau dihentikan, seperti pada saat
kerusakan Node atau pemeliharaan Node yang mengganggu seperti pembaruan <em>kernel</em>. Oleh karena itu, kamu
perlu menggunakan DaemonSet daripada membuat Pod satu per satu.</p><h3 id=pod-statis>Pod Statis</h3><p>Dimungkinkan untuk membuat Pod dengan menulis sebuah berkas ke direktori tertentu yang di-<em>watch</em> oleh Kubelet.
Pod ini disebut dengan istilah <a href=/docs/concepts/cluster-administration/static-pod/>Pod statis</a>.
Berbeda dengan DaemonSet, Pod statis tidak dapat dikelola menggunakan kubectl atau klien API Kubernetes
yang lain. Pod statis tidak bergantung kepada apiserver, membuat Pod statis berguna pada kasus-kasus
<em>bootstrapping</em> klaster.</p><h3 id=deployment>Deployment</h3><p>DaemonSet mirip dengan <a href=/id/docs/concepts/workloads/controllers/deployment/>Deployment</a> sebab mereka
sama-sama membuat Pod, dan Pod yang mereka buat punya proses yang seharusnya tidak berhenti (e.g. peladen web,
peladen penyimpanan)</p><p>Gunakan Deployment untuk layanan <em>stateless</em>, seperti <em>frontend</em>, di mana proses <em>scaling</em> naik
dan turun jumlah replika dan <em>rolling update</em> lebih penting daripada mengatur secara tepat di
host mana Pod berjalan. Gunakan DaemonSet ketika penting untuk satu salinan Pod
selalu berjalan di semua atau sebagian host, dan ketika Pod perlu berjalan
sebelum Pod lainnya.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-9add0d2120634b63073ad08dc8683bd6>3.4.2.6 - Garbage Collection</h1><p>Peran daripada <em>garbage collector</em> Kubernetes adalah untuk menghapus objek tertentu yang sebelumnya mempunyai pemilik, tetapi tidak lagi mempunyai pemilik.</p><h2 id=pemilik-dan-dependen>Pemilik dan dependen</h2><p>Beberapa objek Kubernetes adalah pemilik dari objek lainnya. Sebagai contoh, sebuah ReplicaSet adalah pemilik dari sekumpulan Pod. Objek-objek yang dimiliki disebut <em>dependen</em> dari objek pemilik. Setiap objek dependen memiliki sebuah kolom <code>metadata.ownerReferences</code> yang menunjuk ke objek pemilik.</p><p>Terkadang, Kubernetes menentukan nilai dari <code>ownerReference</code> secara otomatis. Sebagai contoh, ketika kamu membuat sebuah ReplicaSet, Kubernetes secara otomatis akan menentukan tiap kolom <code>ownerReference</code> dari tiap Pod di dalam ReplicaSet. Pada versi 1.8, Kubernetes secara otomatis menentukan nilai dari <code>ownerReference</code> untuk objek yang diciptakan atau diadopsi oleh ReplicationController, ReplicaSet, StatefulSet, DaemonSet, Deployment, Job dan CronJob.</p><p>Kamu juga bisa menspesifikasikan hubungan antara pemilik dan dependen dengan cara menentukan kolom <code>ownerReference</code> secara manual.</p><p>Berikut adalah berkas untuk sebuah ReplicaSet yang memiliki tiga Pod:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/controllers/replicaset.yaml download=controllers/replicaset.yaml><code>controllers/replicaset.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("controllers-replicaset-yaml")' title="Copy controllers/replicaset.yaml to clipboard"></img></div><div class=includecode id=controllers-replicaset-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ReplicaSet<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-repset<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>pod-is-for</span>:<span style=color:#bbb> </span>garbage-collection-example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>pod-is-for</span>:<span style=color:#bbb> </span>garbage-collection-example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx</span></span></code></pre></div></div></div><p>Jika kamu membuat ReplicaSet tersebut dan kemudian melihat metadata Pod, kamu akan melihat kolom OwnerReferences:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/controllers/replicaset.yaml
</span></span><span style=display:flex><span>kubectl get pods --output<span style=color:#666>=</span>yaml
</span></span></code></pre></div><p>Keluaran menunjukkan bahwa pemilik Pod adalah sebuah ReplicaSet bernama <code>my-repset</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>apiVersion: v1
</span></span><span style=display:flex><span>kind: Pod
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  ...
</span></span><span style=display:flex><span>  ownerReferences:
</span></span><span style=display:flex><span>  - apiVersion: apps/v1
</span></span><span style=display:flex><span>    controller: <span style=color:#a2f>true</span>
</span></span><span style=display:flex><span>    blockOwnerDeletion: <span style=color:#a2f>true</span>
</span></span><span style=display:flex><span>    kind: ReplicaSet
</span></span><span style=display:flex><span>    name: my-repset
</span></span><span style=display:flex><span>    uid: d9607e19-f88f-11e6-a518-42010a800195
</span></span><span style=display:flex><span>  ...
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong><p>Referensi pemilik lintas <em>namespace</em> tidak diperbolehkan oleh desain. Artinya:</p><ol><li>Dependen dengan cakupan <em>namespace</em> hanya bisa menspesifikasikan pemilik jika berada di <em>namespace</em> yang sama, dan pemilik memiliki cakupan klaster.</li><li>Dependen dengan cakupan klaster hanya bisa menspesifikasikan pemilik yang memiliki cakupan klaster, tetapi tidak berlaku untuk pemilik yang memiliki cakupan klaster.</li></ol></div><h2 id=mengontrol-bagaimana-garbage-collector-menghapus-dependen>Mengontrol bagaimana <em>garbage collector</em> menghapus dependen</h2><p>Ketika kamu menghapus sebuah objek, kamu bisa menspesifikasi apakah dependen objek tersebut juga dihapus secara otomatis. Menghapus dependen secara otomatis disebut <em>cascading deletion</em>. <em>Cascading deletion</em> memiliki dua mode: <em>background</em> dan <em>foreground</em>.</p><h3 id=foreground-cascading-deletion>Foreground cascading deletion</h3><p>Pada <em>foreground cascading deletion</em>, pertama objek utama akan memasuki keadaan "<em>deletion in progress</em>". Pada saat keadaan "<em>deletion in progress</em>", kondisi-kondisi berikut bernilai benar:</p><ul><li>Objek masih terlihat via REST API</li><li><code>deletionTimestamp</code> objek telah ditentukan</li><li><code>metadata.finalizers</code> objek memiliki nilai <code>foregroundDeletion</code>.</li></ul><p>Ketika dalam keadaan "<em>deletion in progress</em>", <em>garbage collector</em> menghapus dependen dari objek. Ketika <em>garbage collector</em> telah menghapus semua "<em>blocking</em>" dependen (objek dengan <code>ownerReference.blockOwnerDeleteion=true</code>), <em>garbage collector</em> menghapus objek pemilik.</p><p>Jika kolom <code>ownerReferences</code> sebuah objek ditentukan oleh sebuah <em>controller</em> (seperti Deployment atau Replicaset), <code>blockOwnerDeletion</code> akan ditentukan secara otomatis dan kamu tidak perlu memodifikasi kolom ini secara manual.</p><h3 id=background-cascading-deletion>Background cascading deletion</h3><p>Pada <em>background cascading deletion</em>, Kubernetes segera menghapus objek pemilik dan <em>garbage collector</em> kemudian menghapus dependen pada <em>background</em>.</p><h3 id=mengatur-kebijakan-cascading-deletion>Mengatur kebijakan <em>cascading deletion</em></h3><p>Untuk mengatur kebijakan <em>cascading deletion</em>, tambahkan kolom <code>propagationPolicy</code> pada argumen <code>deleteOptions</code> ketika menghapus sebuah Object. Nilai yang dapat digunakan adalah "Orphan", "Foreground", atau "Background".</p><p>Sebelum Kubernetes 1.9, kebijakan <em>default</em> dari <em>garbage collection</em> untuk banyak <em>resource controller</em> adalah <strong>orphan</strong>. Ini meliputi ReplicationController, ReplicaSet, StatefulSet, DaemonSet, dan Deployment. Untuk jenis pada kelompok versi <code>extensions/v1beta1</code>, <code>apps/v1beta1</code>, dan <code>apps/v1beta2</code>, kecuali kamu menspesifikasikan dengan cara lain, objek dependen adalah <em>orphan</em> secara <em>default</em>. Pada Kubernetes 1.9, untuk semua jenis pada kelompok versi <code>apps/v1</code>, objek dependen dihapus secara <em>default</em>.</p><p>Berikut sebuah contoh yang menghapus dependen di <em>background</em>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl proxy --port<span style=color:#666>=</span><span style=color:#666>8080</span>
</span></span><span style=display:flex><span>curl -X DELETE localhost:8080/apis/apps/v1/namespaces/default/replicasets/my-repset <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>-d <span style=color:#b44>&#39;{&#34;kind&#34;:&#34;DeleteOptions&#34;,&#34;apiVersion&#34;:&#34;v1&#34;,&#34;propagationPolicy&#34;:&#34;Background&#34;}&#39;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>-H <span style=color:#b44>&#34;Content-Type: application/json&#34;</span>
</span></span></code></pre></div><p>Berikut adalah sebuah contoh yang mengapus dependen di <em>foreground</em>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl proxy --port<span style=color:#666>=</span><span style=color:#666>8080</span>
</span></span><span style=display:flex><span>curl -X DELETE localhost:8080/apis/apps/v1/namespaces/default/replicasets/my-repset <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>-d <span style=color:#b44>&#39;{&#34;kind&#34;:&#34;DeleteOptions&#34;,&#34;apiVersion&#34;:&#34;v1&#34;,&#34;propagationPolicy&#34;:&#34;Foreground&#34;}&#39;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>-H <span style=color:#b44>&#34;Content-Type: application/json&#34;</span>
</span></span></code></pre></div><p>Berikut adalah contoh <em>orphan</em> yang dependen:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl proxy --port<span style=color:#666>=</span><span style=color:#666>8080</span>
</span></span><span style=display:flex><span>curl -X DELETE localhost:8080/apis/apps/v1/namespaces/default/replicasets/my-repset <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>-d <span style=color:#b44>&#39;{&#34;kind&#34;:&#34;DeleteOptions&#34;,&#34;apiVersion&#34;:&#34;v1&#34;,&#34;propagationPolicy&#34;:&#34;Orphan&#34;}&#39;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>-H <span style=color:#b44>&#34;Content-Type: application/json&#34;</span>
</span></span></code></pre></div><p>kubectl juga mendukung <em>cascading deletion</em>. Untuk menghapus dependen secara otomatis dengan menggunakan kubectl, Ubah nilai <code>--cascade</code> menjadi <em>true</em>. Untuk <em>orphan</em> yang dependen, ubah nilai <code>--cascade</code> menjadi <em>false</em>. Nilai <em>default</em> untuk <code>--cascade</code> adalah <em>true</em>.</p><p>Berikut adalah contoh yang membuat dependen ReplicaSet menjadi <em>orphan</em>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete replicaset my-repset --cascade<span style=color:#666>=</span><span style=color:#a2f>false</span>
</span></span></code></pre></div><h3 id=catatan-tambahan-untuk-deployment>Catatan tambahan untuk Deployment</h3><p>Sebelum versi 1.7, ketika menggunakan <em>cascading delete</em> dengan Deployment, kamu <em>harus</em> menggunakan <code>propagationPolicy: Foreground</code> untuk menghapus tidak hanya ReplicaSet yang telah diciptakan, tetapi juga Pod yang mereka miliki. Jika tipe <em>propagationPolicy</em> tidak digunakan, hanya ReplicaSet yag akan dihapus, dan Pod akan menjadi <em>orphan</em>. Lihat <a href=https://github.com/kubernetes/kubeadm/issues/149#issuecomment-284766613>kubeadm/#149</a> untuk informasi lebih lanjut.</p><h2 id=isu-yang-diketahui>Isu yang diketahui</h2><p>Ditemukan pada <a href=https://github.com/kubernetes/kubernetes/issues/26120>#26120</a></p><h2 id=selanjutnya>Selanjutnya</h2><p><a href=https://git.k8s.io/community/contributors/design-proposals/api-machinery/garbage-collection.md>Dokumen Desain 1</a></p><p><a href=https://git.k8s.io/community/contributors/design-proposals/api-machinery/synchronous-garbage-collection.md>Dokumen Desain 2</a></p></div><div class=td-content style=page-break-before:always><h1 id=pg-4de50a37ebb6f2340484192126cb7a04>3.4.2.7 - Pengendali TTL untuk Sumber Daya yang Telah Selesai Digunakan</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.12 [alpha]</code></div><p>Pengendali TTL menyediakan mekanisme TTL yang membatasi umur dari suatu
objek sumber daya yang telah selesai digunakan. Pengendali TTL untuk saat ini hanya menangani
<a class=glossary-tooltip title='Tugas terbatas atau bertumpuk (batch) yang berjalan sampai selesai.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/job/ target=_blank aria-label=Jobs>Jobs</a>,
dan nantinya bisa saja digunakan untuk sumber daya lain yang telah selesai digunakan
misalnya saja Pod atau sumber daya khusus (<em>custom resource</em>) lainnya.</p><p>Peringatan Fitur Alpha: fitur ini tergolong datam fitur alpha dan dapat diaktifkan dengan
<a href=/docs/reference/command-line-tools-reference/feature-gates/><em>feature gate</em></a>
<code>TTLAfterFinished</code>.</p><h2 id=pengendali-ttl>Pengendali TTL</h2><p>Pengendali TTL untuk saat ini hanya mendukung Job. Sebuah operator klaster
dapat menggunakan fitur ini untuk membersihkan Job yang telah dieksekusi (baik
<code>Complete</code> atau <code>Failed</code>) secara otomatis dengan menentukan <em>field</em>
<code>.spec.ttlSecondsAfterFinished</code> pada Job, seperti yang tertera di
<a href=/id/docs/concepts/workloads/controllers/job/#clean-up-finished-jobs-automatically>contoh</a>.
Pengendali TTL akan berasumsi bahwa sebuah sumber daya dapat dihapus apabila
TTL dari sumber daya tersebut telah habis. Proses dihapusnya sumber daya ini
dilakukan secara berantai, dimana sumber daya lain yang
berkaitan akan ikut terhapus. Perhatikan bahwa ketika sebuah sumber daya dihapus,
siklus hidup yang ada akan menjaga bahwa <em>finalizer</em> akan tetap dijalankan sebagaimana mestinya.</p><p>Waktu TTL dalam detik dapat diatur kapan pun. Terdapat beberapa contoh untuk mengaktifkan <em>field</em>
<code>.spec.ttlSecondsAfterFinished</code> pada suatu Job:</p><ul><li>Spesifikasikan <em>field</em> ini pada <em>manifest</em> sumber daya, sehingga Job akan
dihapus secara otomatis beberapa saat setelah selesai dieksekusi.</li><li>Aktifkan <em>field</em> ini pada sumber daya yang sudah selesai dieksekusi untuk
menerapkan fitur ini.</li><li>Gunakan sebuah
<a href=/docs/reference/access-authn-authz/extensible-admission-controllers/#admission-webhooks>mengubah (<em>mutating</em>) _admission)</a>
untuk mengaktifkan <em>field</em> ini secara dinamis pada saat pembuatan sumber daya.
Administrator klaster dapat menggunakan hal ini untuk menjamin kebijakan (<em>policy</em>) TTL pada
sumber daya yang telah selesai digunakan.</li><li>Gunakan sebuah
<a href=/docs/reference/access-authn-authz/extensible-admission-controllers/#admission-webhooks>mengubah (<em>mutating</em>) _admission</a>
untuk mengaktifkan <em>field</em> ini secara dinamis setelah sumber daya
selesai digunakan dan TTL didefinisikan sesuai dengan status, label, atau hal lain
yang diinginkan.</li></ul><h2 id=peringatan>Peringatan</h2><h3 id=mengubah-ttl-detik>Mengubah TTL Detik</h3><p>Perhatikan bahwa periode TTL, yaitu <em>field</em> <code>.spec.ttlSecondsAfterFinished</code> pada Job,
dapat dimodifikasi baik setelah sumber daya dibuat atau setelah selesai digunakan.
Meskipun begitu, setelah Job dapat dihapus (TTL sudah habis), sistem tidak akan
menjamin Job tersebut akan tetap ada, meskipun nilai TTL berhasil diubah.</p><h3 id=time-skew><em>Time Skew</em></h3><p>Karena pengendali TTL menggunakan cap waktu (<em>timestamp</em>) yang disimpan di sumber daya
Kubernetes untuk menentukan apakah TTL sudah habis atau belum, fitur ini tidak sensitif
terhadap <em>time skew</em> yang ada pada klaster dan bisa saja menghapus objek pada waktu yang salah
bagi objek tersebut akibat adanya <em>time skew</em>.</p><p>Pada Kubernetes, NTP haruslah dilakukan pada semua node untuk mecegah adanya <em>time skew</em>
(lihat <a href=https://github.com/kubernetes/kubernetes/issues/6159#issuecomment-93844058>#6159</a>).
<em>Clock</em> tidak akan selalu tepat, meskipun begitu perbedaan yang ada haruslah diminimalisasi.
Perhatikan bahwa hal ini dapat terjadi apabila TTL diaktifkan dengan nilai selain 0.</p><h2 id=selanjutnya>Selanjutnya</h2><p><a href=/id/docs/concepts/workloads/controllers/jobs-run-to-completion/#clean-up-finished-jobs-automatically>Membersikan Job secara Otomatis</a></p><p><a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-apps/592-ttl-after-finish/README.md>Dokumentasi Rancangan</a></p></div><div class=td-content style=page-break-before:always><h1 id=pg-cc7cc3c4907039d9f863162e20bfbbef>3.4.2.8 - Jobs</h1><p>Sebuah Job membuat satu atau beberapa Pod dan menjamin bahwa jumlah Pod yang telah dispesifikasikan sebelumnya
berhasil dijalankan. Pada saat Pod telah dihentikan, Job akan menandainya sebagai Job yang sudah berhasil dijalankan.
Ketika jumlah sukses yang dispesifikasikan sebelumnya sudah terpenuhi, maka Job tersebut dianggap selesai.
Menghapus sebuah Job akan menghapus semua Pod yang dibuat oleh Job tersebut.</p><p>Sebuah kasus sederhana yang dapat diberikan adalah membuat sebuah objek Job untuk menjamin
sebuah Pod dijalankan hingga selesai. Objek Job ini akan membuat sebuah Pod baru apabila
Pod pertama gagal atau dihapus (salah satu contohnya adalah akibat adanya kegagalan pada
perangkat keras atau terjadinya <em>reboot</em> pada Node).</p><p>Kamu juga dapat menggunakan Job untuk menjalankan beberapa Pod secara paralel.</p><h2 id=menjalankan-contoh-job>Menjalankan Contoh Job</h2><p>Berikut merupakan contoh konfigurasi Job. Job ini melakukan komputasi π hingga
digit ke 2000 kemudian memberikan hasilnya sebagai keluaran. Job tersebut memerlukan
waktu 10 detik untuk dapat diselesaikan.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/controllers/job.yaml download=controllers/job.yaml><code>controllers/job.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("controllers-job-yaml")' title="Copy controllers/job.yaml to clipboard"></img></div><div class=includecode id=controllers-job-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>batch/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Job<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>perl<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;perl&#34;</span>,<span style=color:#bbb>  </span><span style=color:#b44>&#34;-Mbignum=bpi&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-wle&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;print bpi(2000)&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>backoffLimit</span>:<span style=color:#bbb> </span><span style=color:#666>4</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Kamu dapat menjalankan contoh tersebut dengan menjalankan perintah berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/controllers/job.yaml
</span></span></code></pre></div><pre tabindex=0><code>job &#34;pi&#34; created
</code></pre><p>Perhatikan status dari Job yang baru dibuat dengan menggunakan perintah<code>kubectl</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe jobs/pi
</span></span></code></pre></div><pre tabindex=0><code>Name:             pi
Namespace:        default
Selector:         controller-uid=b1db589a-2c8d-11e6-b324-0209dc45a495
Labels:           controller-uid=b1db589a-2c8d-11e6-b324-0209dc45a495
                  job-name=pi
Annotations:      &lt;none&gt;
Parallelism:      1
Completions:      1
Start Time:       Tue, 07 Jun 2016 10:56:16 +0200
Pods Statuses:    0 Running / 1 Succeeded / 0 Failed
Pod Template:
  Labels:       controller-uid=b1db589a-2c8d-11e6-b324-0209dc45a495
                job-name=pi
  Containers:
   pi:
    Image:      perl
    Port:
    Command:
      perl
      -Mbignum=bpi
      -wle
      print bpi(2000)
    Environment:        &lt;none&gt;
    Mounts:             &lt;none&gt;
  Volumes:              &lt;none&gt;
Events:
  FirstSeen    LastSeen    Count    From            SubobjectPath    Type        Reason            Message
  ---------    --------    -----    ----            -------------    --------    ------            -------
  1m           1m          1        {job-controller }                Normal      SuccessfulCreate  Created pod: pi-dtn4q
</code></pre><p>Untuk melihat Pod yang sudah selesai dari sebuah Job, kamu dapat menggunakan perintah <code>kubectl get pods</code>.</p><p>Untuk menampilkan semua Pod yang merupakan bagian dari suatu Job di mesin kamu dalam bentuk
yang mudah dipahami, kamu dapat menggunakan perintah berikut ini:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#b8860b>pods</span><span style=color:#666>=</span><span style=color:#a2f;font-weight:700>$(</span>kubectl get pods --selector<span style=color:#666>=</span>job-name<span style=color:#666>=</span>pi --output<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.items[*].metadata.name}&#39;</span><span style=color:#a2f;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b8860b>$pods</span>
</span></span></code></pre></div><pre tabindex=0><code>pi-aiw0a
</code></pre><p>Disini, selektor yang ada merupakan selektor yang sama dengan yang ada pada Job.
Opsi <code>--output=jsonpath</code> menspesifikasikan bahwa ekspresi yang hanya
menampilkan nama dari setiap Pod pada <em>list</em> yang dikembalikan.</p><p>Untuk melihat keluaran standar dari salah satu pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl logs <span style=color:#b8860b>$pods</span>
</span></span></code></pre></div><p>Keluaran yang dihasilkan akan sama dengan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632788659361533818279682303019520353018529689957736225994138912497217752834791315155748572424541506959508295331168617278558890750983817546374649393192550604009277016711390098488240128583616035637076601047101819429555961989467678374494482553797747268471040475346462080466842590694912933136770289891521047521620569660240580381501935112533824300355876402474964732639141992726042699227967823547816360093417216412199245863150302861829745557067498385054945885869269956909272107975093029553211653449872027559602364806654991198818347977535663698074265425278625518184175746728909777727938000816470600161452491921732172147723501414419735685481613611573525521334757418494684385233239073941433345477624168625189835694855620992192221842725502542568876717904946016534668049886272327917860857843838279679766814541009538837863609506800642251252051173929848960841284886269456042419652850222106611863067442786220391949450471237137869609563643719172874677646575739624138908658326459958133904780275901
</span></span></code></pre></div><h2 id=menulis-spek-job>Menulis Spek Job</h2><p>Sama halnya dengan konfigurasi Kubernetes lainnya, sebuah Job memerlukan <em>field</em>
<code>apiVersion</code>, <code>kind</code>, dan <code>metadata</code>.</p><p>Sebuah Job juga membutuhkan sebuah <a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status>bagian <code>.spec</code></a>.</p><h3 id=templat-pod>Templat Pod</h3><p><em>Field</em> <code>.spec.template</code> merupakan satu-satunya <em>field</em> wajib pada <code>.spec</code>.</p><p><em>Field</em> <code>.spec.template</code> merupakan sebuah <a href=/id/docs/concepts/workloads/pods/pod-overview/#pod-templates>templat Pod</a>. <em>Field</em> ini memiliki skema yang sama dengan yang ada pada <a href=/docs/user-guide/pods>Pod</a>,
kecuali <em>field</em> ini bersifat <em>nested</em> dan tidak memiliki <em>field</em> <code>apiVersion</code> atau <em>field</em> <code>kind</code>.</p><p>Sebagai tambahan dari <em>field</em> wajib pada sebuah Job, sebuah tempat pod pada Job
haruslah menspesifikasikan label yang sesuai (perhatikan <a href=#pod-selektor>selektor pod</a>)
dan sebuah mekanisme <em>restart</em> yang sesuai.</p><p>Hanya sebuah <a href=/id/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy><code>RestartPolicy</code></a> yang sesuai dengan <code>Never</code> atau <code>OnFailure</code> yang bersifat valid.</p><h3 id=selektor-pod>Selektor Pod</h3><p><em>Field</em> <code>.spec.selector</code> bersifat opsional. Dan dalam sebagian besar kasus, kamu tidak perlu memberikan
spesifikasi untuk hal ini. Perhatikan bagian <a href=#menspesifikasikan-selektor-pod-kamu-sendiri>menspesifikasikan selektor Pod kamu sendiri</a>.</p><h3 id=job-paralel>Job Paralel</h3><p>Terdapat tiga jenis utama dari <em>task</em> yang sesuai untuk dijalankan sebagai sebuah Job:</p><ol><li>Job non-paralel</li></ol><ul><li>secara umum, hanya sebuah Pod yang dimulai, kecuali jika Pod tersebut gagal.</li><li>Job akan dianggap sudah selesai dikerjakan apabila Pod dari Job tersebut sudah selesai dijalankan dan mengalami terminasi dengan status sukses.</li></ul><ol><li>Job paralel dengan <em>jumlah nilai penyelesaian tetap</em>:</li></ol><ul><li>berikan spesifikasi pada <code>.spec.completions</code> dengan nilai non-negatif.</li><li>Job yang ada merupakan representasi dari <em>task</em> yang dikerjakan, dan akan dianggap selesai apabila terdapat lebih dari satu Pod yang sukses untuk setiap nilai yang ada dalam jangkauan 1 hingga <code>.spec.completions</code>.</li><li><strong>belum diimplementasikan saat ini:</strong> Setiap Pod diberikan nilai indeks yang berbeda di dalam jangkauan 1 hingga <code>.spec.completions</code>.</li></ul><ol><li>Job paralel dengan sebuah <em><em>work queue</em></em>:</li></ol><ul><li>jangan berikan spesifikasi pada <code>.spec.completions</code>, nilai <em>default</em>-nya merupakan <code>.spec.parallelism</code>.</li><li>Pod yang ada haruslah dapat berkoordinasi satu sama lain atau dengan Service eksternal lain untuk menentukan apa yang setiap Pod tadi perlu lakukan. Sebagai contohnya, sebuah Pod bisa saja melakukan <em>fetch</em> job <em>batch</em> hingga N kali pada <em>work queue</em></li><li>setiap Pod secara independen mampu menentukan apakah Pod lainnya telah menyelesaikan tugasnya dengan baik atau belum, dengan kata lain suatu Job telah dikatakan selesai</li><li>ketika Pod mana pun dari sebuah Job berhenti dalam keadaan sukses, maka tidak ada Pod lain yang akan dibuat untuk Job tersebut.</li><li>apabila salah satu Pod sudah dihentikan sekali dalam keadaan sukses, maka Job akan ditandai sebagai sukses.</li><li>apabila sebuah Pod sudah dihentikan dalam keadaan sukses, tidak boleh ada Pod lain yang mengerjakan <em>task</em> tersebut. Dengan kata lain, semua Pod tersebut haruslah dalam keadaan akan dihentikan.</li></ul><p>Untuk sebuah Job yang non-paralel, kamu tidak perlu menspesifikasikan <em>field</em> <code>.spec.completions</code> dan <code>.spec.parallelism</code>. Ketika kedua <em>field</em> tersebut
dalam keadaan tidak dispesifikasikan, maka nilai <em>defult</em>-nya akan diubah menjadi 1.</p><p>Untuk sebuah Job dengan jumlah nilai penyelesaian tetap, kamu harus memberikan spesifikasi nilai
dari <code>.spec.completions</code> dengan nilai yang diinginkan. Kamu dapat menspesifikasikan <code>.spec.parallelism</code>,
atau jika kamu tidak melakukannya nilai dari <em>field</em> ini akan memiliki nilai default 1.</p><p>Untuk sebuah Job <em>work queue</em>, kamu harus meninggalkan spesifikasi <em>field</em> <code>.spec.completions</code> menjadi kosong, serta
memberikan nilai pada <code>.spec.parallelism</code> menjadi sebuah bilangan bulat non negatif.</p><p>Untuk informasi lebih lanjut mengenai bagaimana menggunakan Job dengan jenis yang berbeda, kamu
dapat melihat bagian <a href=#pola-job>pola job</a>.</p><h4 id=mengendalikan-paralelisme>Mengendalikan Paralelisme</h4><p>Paralelisme yang diminta (<code>.spec.parallelism</code>) dapat diaktifkan dengan cara
memberikan nilai bilangan bulat non-negatif. Jika tidak dispesifikasikan maka nilainya akan
secara default yaitu 1. Jika dispesifikasikan sebagai 0, maka Job akan secara otomatis dihentikan sementara
hingga nilainya dinaikkan.</p><p>Paralelisme yang sebenarnya (jumlah Pod yang dijalankan pada satu waktu tertentu)
bisa saja lebih atau kurang dari nilai yang diharapkan karena adanya alasan berikut:</p><ul><li>Untuk Job <em>fixed completion count</em>, nilai sebenarnya dari jumlah Pod yang dijalankan secara paralel tidak akan melebihi jumlah<br><em>completion</em> yang tersisa. Nilai yang lebih tinggi dari <code>.spec.parallelism</code> secara efektif, akan diabaikan.</li><li>Untuk Job <em>work queue</em>, tidak akan ada Pod yang dimulai setelah ada Pod yang berhasil -- meskipun begitu, sisa Pod yang ada akan diizinkan untuk menyelesaikan tugasnya.</li><li>Jika sebuah <a class=glossary-tooltip title='Kontrol tertutup yang mengawasi kondisi bersama dari klaster melalui apiserver dan membuat perubahan yang mencoba untuk membawa kondisi saat ini ke kondisi yang diinginkan.' data-toggle=tooltip data-placement=top href=/id/docs/concepts/architecture/controller/ target=_blank aria-label=Pengontrol>Pengontrol</a> Job tidak memiliki waktu untuk memberikan reaksi.</li><li>Jika sebuah <em>controller</em> Job gagal membuat Pod dengan alasan apa pun (kurangnya <code>ResourceQuota</code>, kurangnya <em>permission</em>, dkk.),
maka bisa saja terdapat lebih sedikit Pod dari yang diminta.</li><li>Jika <em>controller</em> Job melakukan <em>throttle</em> pembuatan Pod karena terdapat gagalnya pembuatan Pod yang berlebihan sebelumnya pada Job yang sama.</li><li>Ketika sebuah Pod dihentikan secara <em>graceful</em>, maka Pod tersebut akan membutuhkan waktu untuk berhenti.</li></ul><h2 id=mengatasi-kegagalan-pod-dan-container>Mengatasi Kegagalan Pod dan Container</h2><p>Sebuah Container pada sebuah Pod bisa saja mengalami kegagalan karena berbagai alasan
yang berbeda, misalnya saja karena proses yang ada di dalamnya berakhir dengan <em>exit code</em>
yang tidak sama dengan nol, atau Container yang ada di-<em>kill</em> karena menyalahi batasan memori, dkk.
Jika hal ini terjadi, dan <code>.spec.template.spec.restartPolicy = "OnFailure"</code>, maka Pod
akan tetap ada di dalam node, tetapi Container tersebut akan dijalankan kembali. Dengan demikian,
program kamu harus dapat mengatasi kasus dimana program tersebut di-<em>restart</em> secara lokal, atau jika
tidak maka spesifikasikan <code>.spec.template.spec.restartPolicy = "Never"</code>. Perhatikan
<a href=/id/docs/concepts/workloads/pods/pod-lifecycle/#example-states><em>lifecycle</em> pod</a> untuk informasi lebih lanjut mengenai <code>restartPolicy</code>.</p><p>Sebuah Pod juga dapat gagal secara menyeluruh, untuk beberapa alasan yang mungkin, misalnya saja,
ketika Pod tersebut dipindahkan dari Node (ketika Node diperbarui, di-<em>restart</em>, dihapus, dsb.), atau
jika sebuah Container dalam Pod gagal dan <code>.spec.template.spec.restartPolicy = "Never"</code>. Ketika
sebuah Pod gagal, maka <em>controller</em> Job akan membuat sebuah Pod baru. Ini berarti aplikasi kamu haruslah
bisa mengatasi kasus dimana aplikasimu dimulai pada Pod yang baru. Secara khusus apabila aplikasi kamu
berurusan dengan berkas temporer, <em>locks</em>, keluaran yang tak lengkap dan hal-hal terkait dengan
program yang dijalankan sebelumnya.</p><p>Perhatikan bahwa bahakan apabila kamu menspesifikasikan <code>.spec.parallelism = 1</code> dan <code>.spec.completions = 1</code> dan
<code>.spec.template.spec.restartPolicy = "Never"</code>, program yang sama bisa saja tetap dijalankan lebih dari sekali.</p><p>Jika kamu menspesifikasikan <code>.spec.parallelism</code> dan <code>.spec.completions</code> dengan nilai yang lebih besar dari 1,
maka bisa saja terdapat keadaan dimana terdapat beberapa Pod yang dijalankan pada waktu yang sama.
Dengan demikian, Pod kamu haruslah fleksibel terhadap adanya konkurensi.</p><h3 id=mekanisme-kebijakan-backoff-apabila-terjadi-kegagalan>Mekanisme Kebijakan <em>Backoff</em> apabila Terjadi Kegagalan</h3><p>Terdapat situasi dimana kamu ingin membuat suatu Job gagal
setelah dijalankan mekanisme <em>retry</em> beberapa kali akibat adanya kesalahan pada konfigurasi
dsb. Untuk melakukan hal tersebut, spesifikasikan <code>.spec.backoffLimit</code> dengan nilai <em>retry</em> yang diinginkan
sebelum menerjemahkan Job dalam keadaan gagal. Secara default, nilai dari <em>field</em> tersebut adalah 6.
Pod yang gagal dijalankan dan terkait dengan suatu Job tertentu akan dibuat kembali oleh
<em>controller</em> Job dengan <em>delay</em> <em>back-off</em> eksponensial (10 detik, 20 detik, 40 detik ...)
yang dibatasi pada 6 menit. Penghitungan <em>back-off</em> akan diulang jika tidak terdapat Pod baru yang gagal
sebelum siklus pengecekan status Job selanjutnya.</p><p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Isu <a href=https://github.com/kubernetes/kubernetes/issues/54870>#54870</a> masih ada untuk versi Kubernetes sebelum 1.12.</div><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Jika Job yang kamu miliki memiliki <code>restartPolicy = "OnFailure"</code>, perhatikan bahwa Container kamu yang menjalankan
Job tersebut akan dihentikan ketika limit <em>back-off</em> telah dicapai. Hal ini akan membuat proses <em>debugging</em> semakin sulit.
Dengan demikian, kami memberikan saran untuk menspesifikasikan <code>restartPolicy = "Never"</code> ketika melakukan
proses <em>debugging</em> atau menggunakan mekanisme <em>logging</em> untuk menjamin keluaran
dari Job yang gagal agar tidak terus menerus hilang.</div></p><h2 id=terminasi-dan-clean-up-job>Terminasi dan <em>Clean Up</em> Job</h2><p>Ketika sebuah Job selesai dijalankan, tidak akan ada lagi Pod yang dibuat,
meskipun begitu Pod yang ada juga tidak akan dihapus. Dengan demikian kamu masih bisa mengakses log
yang ada dari Pod yang sudah dalam status <em>complete</em> untuk mengecek apabila terjadi eror, <em>warning</em>, atau hal-hal
yang dapat digunakan untuk proses pelaporan dan identifikasi. Objek Job itu sendiri akan tetap ada,
sehingga kamu tetap bisa melihat statusnya. Penghapusan objek akan diserahkan sepenuhnya pada pengguna
apabila Job tidak lagi digunakan. Penghapusan Job dengan perintah <code>kubectl</code> (misalnya, <code>kubectl delete jobs/pi</code> atau <code>kubectl delete -f ./job.yaml</code>).
Ketika kamu menghapus Job menggunakan perintah <code>kubectl</code>, semua Pod yang terkait dengan Job tersebut akan ikut dihapus.</p><p>Secara <em>default</em>, sebuah Job akan dijalankan tanpa adanya interupsi kecuali terdapat Pod yang gagal, (<code>restartPolicy=Never</code>) atau terdapat
Container yang dihentikan dalam kondisi error (<code>restartPolicy=OnFailure</code>), suatu keadaan dimana Job akan dijalankan dengan mekanisme
yang dijelaskan di atas berdasarkan pada <code>.spec.backoffLimit</code>.
Apabila <code>.spec.backoffLimit</code> telah mencapai limit, maka Job akan ditandai sebagai gagal dan Pod yang saat ini sedang dijalankan juga akan dihentikan.</p><p>Cara lain untuk menghentikan sebuah Job adalah dengan mengatur <em>deadline</em> aktif.
Untuk melakukannya kamu dapat menspesifikasikan <em>field</em> <code>.spec.activeDeadlineSeconds</code>
dari sebuah Job dengan suatu angka dalam satuan detik. <em>Field</em> <code>activeDeadlineSeconds</code>
diterapkan pada durasi dari sebuah Job, tidak peduli seberapa banyak Pod yang dibuat.
Setelah sebuah Job mencapai limit <code>activeDeadlineSeconds</code>, semua Pod yang dijalankan akan dihentikan
dan status dari Job tersebut akan berubah menjadi <code>type: Failed</code> dengan <code>reason: DeadlineExceeded</code>.</p><p>Perhatikan bahwa <em>field</em> <code>.spec.activeDeadlineSeconds</code> pada Job memiliki tingkat
presedensi di atas <code>.spec.backoffLimit</code>. Dengan demikian, sebuah Job
yang sedang mencoba melakukan <em>restart</em> pada suatu Pod-nya tidak akan melakukan
pembuatan Pod yang baru apabila Job tersebut telah mencapai limit yang didefinisikan pada
<code>activeDeadlineSeconds</code>, bahkan apabila nilai dari <code>backoffLimit</code> belum tercapai.</p><p>Contoh:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>batch/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Job<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pi-with-timeout<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>backoffLimit</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>activeDeadlineSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>100</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>Containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>perl<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;perl&#34;</span>,<span style=color:#bbb>  </span><span style=color:#b44>&#34;-Mbignum=bpi&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-wle&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;print bpi(2000)&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></span></span></code></pre></div><p>Perhatikan bahwa baik spek Job dan <a href=/docs/concepts/workloads/pods/init-Containers/#detailed-behavior>spek templat Pod</a> di dalam Job memiliki <em>field</em> <code>activeDeadlineSeconds</code>.
Pastikan kamu telah menspesifikasikan nilai tersebut pada level yang dibutuhkan.</p><h2 id=mekanisme-clean-up-otomatis-pada-job-yang-sudah-selesai>Mekanisme <em>Clean Up</em> Otomatis pada Job yang Sudah Selesai</h2><p>Job yang sudah selesai biasanya tidak lagi dibutuhkan di dalam sistem. Tetap menjaga keberadaan
objek-objek tersebut di dalam sistem akan memberikan tekanan tambahan pada API server. Jika sebuah Job
yang diatur secara langsung oleh <em>controller</em> dengan level yang lebih tinggi, seperti
<a href=/id/docs/concepts/workloads/controllers/cron-jobs/>CronJob</a>, maka Job ini dapat
di-<em>clean up</em> oleh CronJob berdasarkan <em>policy</em> berbasis kapasitas yang dispesifikasikan.</p><h3 id=mekanisme-ttl-untuk-job-yang-telah-selesai-dijalankan>Mekanisme TTL untuk Job yang Telah Selesai Dijalankan</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.12 [alpha]</code></div><p>Salah satu cara untuk melakukan <em>clean up</em> Job yang telah selesai dijalankan
(baik dengan status <code>Complete</code> atau <code>Failed</code>) secara otomatis adalah dengan
menerapkan mekanisme TTL yang disediakan oleh
<a href=/id/docs/concepts/workloads/controllers/ttlafterfinished/><em>controller</em> TTL</a> untuk
sumber daya yang telah selesai digunakan, dengan cara menspesifikasikan
<em>field</em> <code>.spec.ttlSecondsAfterFinished</code> dari Job tersebut.</p><p>Ketika <em>controller</em> TTL melakukan proses <em>clean up</em> pada Job,
maka <em>controller</em> tersebut akan menghapus objek-objek terkait seperti Pod, serta Job itu sendiri.
Perhatikan bahwa ketika suatu Job dihapus, maka <em>lifecycle</em>-nya akan menjamin, mekanisme
<em>finalizer</em> yang ada akan tetap dihargai.</p><p>Sebagai contoh:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>batch/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Job<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pi-with-ttl<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ttlSecondsAfterFinished</span>:<span style=color:#bbb> </span><span style=color:#666>100</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>Containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>perl<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;perl&#34;</span>,<span style=color:#bbb>  </span><span style=color:#b44>&#34;-Mbignum=bpi&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-wle&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;print bpi(2000)&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></span></span></code></pre></div><p>Job <code>pi-with-ttl</code> akan dihapus secara otomatis, dalam jangka waktu <code>100</code>
detik setelah Job tersebut selesai dijalankan.</p><p>Jika <em>field</em> ini dispesifikasikan sebagai <code>0</code>, maka Job akan secara otomatis dihapus
segera setelah Job tersebut selesai dijalankan. Jika <em>field</em> tersebut tidak dispesifikasikan,
maka Job ini tidak akan dihapus oleh <em>controller</em> TTL setelah Job ini selesai dijalankan.</p><p>Perhatikan bahwa mekanisme TTL ini merupakan fitur alpha, dengan gerbang fitur <code>TTLAfterFinished</code>.
Untuk informasi lebih lanjut, kamu dapat membaca dokumentasi untuk
<a href=/id/docs/concepts/workloads/controllers/ttlafterfinished/><em>controller</em> TTL</a> untuk
sumber daya yang telah selesai dijalankan.</p><h2 id=pola-job>Pola Job</h2><p>Sebuah objek Job dapat digunakan untuk mendukung eksekusi paralel yang dapat diandalkan pada Pod.
Objek Job tidak di-desain untuk mendukung proses paralel bersifat <em>closely-communicating</em>,
seperti yang secara umum ditemukan dalam komputasi ilmiah. Meskipun begitu objek ini mendukung
set <em>work item</em> yang independen namun saling terkait satu sama lainnya. Ini termasuk surel yang harus dikirim,
<em>frame</em> yang harus di-<em>render</em>, berkas yang harus di-<em>transcoded</em>, jangkauan <em>key</em> yang ada
di dalam basis data NoSQL, dsb.</p><p>Pada suatu sistem yang kompleks, terdapat beberapa set <em>work item</em> yang berbeda.
Di sini, kami hanya mempertimbangkan <em>work item</em> yang ingin digunakan oleh pengguna
untuk melakukan manajemen secara bersamaan — sebuah <em>batch job</em>.</p><p>Terdapat beberapa perbedaan pola pada komputasi paralel,
setiap pola memiliki kelebihan dan kekurangannya masing-masing. Kekurangan dan kelebihan ini
dijabarkan sebagai berikut:</p><ul><li>Satu objek Job untuk setiap <em>work item</em>, atau sebuah Job untuk semua <em>work item</em>. Pilihan kedua akan lebih baik apabila digunakan untuk jumlah <em>work item</em> yang lebih besar.
Sementara itu, pilihan pertama akan mengakibatkan <em>overhead</em> bagi pengguna dan juga sistem
untuk mengaur jumlah objek Job yang cukup banyak.</li><li>Jumlah Pod yang dibuat sesuai dengan jumlah <em>work item</em> atau setiap Pod dapat memproses beberapa <em>work item</em> sekaligus.
Pilihan pertama secara umum memerlukan modifikasi lebih sedikit untuk kode dan Container yang suda ada. Pilihan kedua
akan lebih baik jika digunakan untuk jumlah <em>work item</em> yang lebih banyak, untuk alasan yang sama dengan poin sebelumnya.</li><li>Beberapa pendekatan menggunakan prinsip <em>work queue</em>. Hal ini membutuhkan sebuah <em>service queue</em> yang dijalankan,
serta modifikasi untuk program atau Container yang sudah ada untuk mengizinkannya menggunakan <em>working queue</em>.
Pendekatan lain akan lebih mudah untuk digunakan bagi aplikasi yang sudah ada.</li></ul><p><em>Tradeoff</em> yang dirangkum di sini, dengan kolom 2 dan 4 berkaitan dengan <em>tradeoff</em> yang dijelaskan di atas.
Nama dari pola yang ada juga terkait dengan contoh dan deskripsi lebih lanjut.</p><table><thead><tr><th>Pola</th><th style=text-align:center>Objek dengan satu Job</th><th style=text-align:center>Pod yang lebih sedikit tadi <em>work items</em>?</th><th style=text-align:center>Penggunaan app tanpa modifikasi?</th><th style=text-align:center>Dapat dijalankan pada Kube versi 1.1?</th></tr></thead><tbody><tr><td><a href=/docs/tasks/job/parallel-processing-expansion/>Perluasan Templat Job</a></td><td style=text-align:center></td><td style=text-align:center></td><td style=text-align:center>✓</td><td style=text-align:center>✓</td></tr><tr><td><a href=/docs/tasks/job/coarse-parallel-processing-work-queue/>Queue dengan Pod untuk setiap <em>Work Item</em></a></td><td style=text-align:center>✓</td><td style=text-align:center></td><td style=text-align:center>sometimes</td><td style=text-align:center>✓</td></tr><tr><td><a href=/docs/tasks/job/fine-parallel-processing-work-queue/>Queue dengan Variabel <em>Pod Count</em></a></td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td style=text-align:center></td><td style=text-align:center>✓</td></tr><tr><td>Job Single dengan penempatan Kerja Statis</td><td style=text-align:center>✓</td><td style=text-align:center></td><td style=text-align:center>✓</td><td style=text-align:center></td></tr></tbody></table><p>Ketika kamu menspesifikasikan <em>completion</em> dengan <code>.spec.completions</code>, setiap Pod yang dibuat oleh <em>controller</em> Job
memiliki <a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status><code>spec</code></a> yang identik. Artinya
semua Pod untuk sebuah <em>task</em> akan memiliki perintah yang sama serta <em>image</em>, volume, serta variabel <em>environment</em> yang (hampir) sama.
Pola ini merupakan salah satu cara berbeda yang diterapkan untuk mengatur Pod agar dapat bekerja untuk hal yang berbeda-beda.</p><p>Tabel ini menunjukkan pengaturan yang dibutuhkan untuk <code>.spec.parallelism</code> dan <code>.spec.completions</code> bagi setiap pola.
Disini, <code>W</code> merupakan jumlah dari <em>work item</em>.</p><table><thead><tr><th>Pattern</th><th style=text-align:center><code>.spec.completions</code></th><th style=text-align:center><code>.spec.parallelism</code></th></tr></thead><tbody><tr><td><a href=/docs/tasks/job/parallel-processing-expansion/>Job Template Expansion</a></td><td style=text-align:center>1</td><td style=text-align:center>should be 1</td></tr><tr><td><a href=/docs/tasks/job/coarse-parallel-processing-work-queue/>Queue with Pod Per Work Item</a></td><td style=text-align:center>W</td><td style=text-align:center>any</td></tr><tr><td><a href=/docs/tasks/job/fine-parallel-processing-work-queue/>Queue with Variable Pod Count</a></td><td style=text-align:center>1</td><td style=text-align:center>any</td></tr><tr><td>Single Job with Static Work Assignment</td><td style=text-align:center>W</td><td style=text-align:center>any</td></tr></tbody></table><h2 id=penggunaan-tingkat-lanjut>Penggunaan Tingkat Lanjut</h2><h3 id=menspesifikasikan-selektor-pod-kamu-sendiri>Menspesifikasikan Selektor Pod Kamu Sendiri</h3><p>Secara umum, ketika kamu membuat sebuah objek Job, kamu
tidak menspesifikasikan <code>.spec.selector</code>. Sistem akan memberikan nilai
default pada <em>field</em> ini ketika Job dibuat. Sistem akan memilih nilai dari selektor yang ada
dan memastikan nilainya tidak akan beririsan dengan Job lainnya.</p><p>Meskipun demikian, pada beberapa kasus, kamu bisa saja memiliki kebutuhan untuk meng-<em>override</em>
nilai dari selektor ini. Untuk melakukannya, kamu dapat menspesifikasikan <code>.spec.selector</code>
dari Job.</p><p>Berhati-hatilah ketika kamu melakukan proses ini. Jika kamu menspesifikasikan sebuah label
selektor yang tidak unik pada Pod yang ada di dalam Job tersebut, serta sesuai dengan Pod yang tidak
terkait dengan Job tadi, maka Pod dari Job yang tidak terkait dengan Job tadi akna dihapus, atau Job ini
akan menghitung <em>completion</em> dari Pod lain sebagai tolak ukur suksesnya Job tersebut, atau bisa saja salah satu
atau kedua Job tidak dapat membuat Pod baru yang digunakan untuk menyelesaikan Job tersebut.
Jika selektor yang tidak unik dipilih, maka <em>controller</em> lain (misalnya ReplicationController) dan Pod
yang ada di dalamnya bisa saja memiliki perilaku yang tidak dapat diprediksi. Kubernetes tidak akan
mencegah kemungkinan terjadinya hal ini ketika kamu menspesifikasikan nilai <code>.spec.selector</code>.</p><p>Berikut merupakan contoh skenario dimana kamu ingin menggunakan fitur ini.</p><p>Misalnya saja Job dengan nama <code>old</code> sudah dijalankan.
Dan kamu ingin Pod yang sudah dijalankan untuk tetap berada pada state tersebut,
tapi kamu juga ingin Pod selanjutnya yang dibuat untuk menggunakan templat Pod yang berbeda dan agar
Job tersebut memiliki nama yang berbeda. Kamu tidak dapat mengubah Job karena <em>field</em> ini
merupakan nilai yang tidak bisa diubah. Dengan demikian, kamu menghapus Job <code>old</code>
tetapi tetap membiarkan Pod yang ada untuk jalan, menggunakan perintah <code>kubectl delete jobs/old --cascade=false</code>.
Sebelum menghapus Job tadi, kamu mencatat selektor yang digunakan oleh Job tadi:</p><pre tabindex=0><code>kubectl get job old -o yaml
</code></pre><pre tabindex=0><code>kind: Job
metadata:
  name: old
  ...
spec:
  selector:
    matchLabels:
      controller-uid: a8f3d00d-c6d2-11e5-9f87-42010af00002
  ...
</code></pre><p>Kemudian kamu membuat sebuah Job baru dengan nama <code>new</code>
dan kamu secara eksplisit menspesifikasikan selektor yang sama.
Karena Pod dengan selektor yang sama memiliki label <code>controller-uid=a8f3d00d-c6d2-11e5-9f87-42010af00002</code>,
maka Pod-Pod lama tadi dikendalikan juga oleh Job <code>new</code>.</p><p>Kamu harus menspesifikasikan <code>manualSelector: true</code> pada Job yang baru
karena kamu tidak menggunakan selektor yang diberikan secara default oleh sistem.</p><pre tabindex=0><code>kind: Job
metadata:
  name: new
  ...
spec:
  manualSelector: true
  selector:
    matchLabels:
      controller-uid: a8f3d00d-c6d2-11e5-9f87-42010af00002
  ...
</code></pre><p>Job yang baru tadi kemudian akan memiliki uid yang berbeda dari <code>a8f3d00d-c6d2-11e5-9f87-42010af00002</code>. Pengaturan
<code>manualSelector: true</code> memberikan perintah pada sistem bahwa kamu mengetahui apa yang kamu lakukan
dan untuk mengizikan ketidaksesuaian ini untuk terjadi.</p><h2 id=alternatif>Alternatif</h2><h3 id=pod-polosan><em>Pod Polosan</em></h3><p>Ketika node dimana Pod dijalankan berada dalam kondisi <em>reboot</em> atau gagal, Pod tadi akan dihentikan
dan tidak akan di-restart. Meskipun demikian, sebuah Job akan membuat Pod baru yang menggantikan
Pod lama yang dihentikan. Untuk alasan inilah, kami memberikan rekomendasi agar kamu menggunakan sebuah Job dibandingkan dengan
Pod yang biasa, bahkan jika aplikasi yang kamu gunakan hanya memerlukan sebuah Pod.</p><h3 id=replication-controller>Replication Controller</h3><p>Job merupakan komplemen dari <a href=/docs/user-guide/replication-controller>Replication Controller</a>.
Sebuah Replication Controller mengatur Pod yang diharapkan untuk tidak dihentikan (misalnya, <em>web server</em>), dan sebuah Job
mengatur Pod yang diharapkan untuk berhenti (misalnya, <em>batch task</em>).</p><p>Seperti yang sudah dibahas pada <a href=/id/docs/concepts/workloads/pods/pod-lifecycle/><em>Lifecycle</em> Pod</a>, <code>Job</code> <em>hanya</em> pantas
digunakan untuk Pod dengan <code>RestartPolicy</code> yang sama dengan <code>OnFailure</code> atau <code>Never</code>.
(Perhatikan bahwa: Jika <code>RestartPolicy</code> tidak dispesifikasikan, nilai defaultnya adalah <code>Always</code>.)</p><h3 id=job-tunggal-akan-menginisiasi-kontroller-pod>Job Tunggal akan menginisiasi Kontroller Pod</h3><p>Pola lain yang mungkin diterapkan adalah untuk sebuah Job tunggal untuk membuat
sebuah Pod yang kemudian akan membuat Pod lainnya, bersifat selayaknya <em>controller</em> kustom
bagi Pod tersebut. Hal ini mengizinkan fleksibilitas optimal, tetapi cukup kompleks untuk digunakan
dan memiliki integrasi terbatas dengan Kubernetes.</p><p>Salah satu contoh dari pola ini adalah sebuah Job yang akan menginisiasi sebuah Pod
yang menjalankan <em>script</em> yang kemudian akan
menjalankan <em>controller</em> master Spark (kamu dapat melihatnya di <a href=https://github.com/kubernetes/examples/tree/main/staging/spark/README.md>contoh Spark</a>),
yang menjalankan <em>driver</em> Spark, dan kemudian melakukan mekanisme <em>clean up</em>.</p><p>Keuntungan dari pendekatan ini adalah proses keseluruhan yang memiliki jaminan <em>completion</em>
dari sebuah Job, tetapi kontrol secara mutlak atas Pod yang dibuat serta tugas yang diberikan pada Pod tersebut.</p><h2 id=cron-jobs>CronJob</h2><p>Kamu dapat menggunakan <a href=/id/docs/concepts/workloads/controllers/cron-jobs/><code>CronJob</code></a> untuk membuat Job yang akan
dijalankan pada waktu/tanggal yang spesifik, mirip dengan perangkat lunak <code>cron</code> yang ada pada Unix.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-2e4cec01c525b45eccd6010e21cc76d9>3.4.2.9 - CronJob</h1><p>Suatu CronJob menciptakan <a href=/id/docs/concepts/workloads/controllers/jobs-run-to-completion/>Job</a> yang dijadwalkan berdasarkan waktu tertentu.</p><p>Satu objek CronJob sepadan dengan satu baris pada <em>file</em> <em>crontab</em> (<em>cron table</em>). CronJob tersebut menjalankan suatu pekerjaan secara berkala
pada waktu tertentu, dituliskan dalam format <a href=https://en.wikipedia.org/wiki/Cron>Cron</a>.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Seluruh waktu <code>schedule:</code> pada <em><strong>CronJob</strong></em> mengikuti zona waktu dari <em>master</em> di mana Job diinisiasi.</div><p>Untuk panduan dalam berkreasi dengan <em>cron job</em>, dan contoh <em>spec file</em> untuk suatu <em>cron job</em>, lihat <a href=/id/docs/tasks/job/automated-tasks-with-cron-jobs>Menjalankan otomasi <em>task</em> dengan <em>cron job</em></a>.</p><h2 id=limitasi-cron-job>Limitasi <em>Cron Job</em></h2><p>Suatu <em>cron job</em> menciptakan <em>kurang lebih</em> satu objek Job setiap penjadwalan. Istilah yang digunakan adalah "<em>kurang lebih</em>" karena
terdapat beberapa kasus yang menyebabkan dua Job terbuat, atau tidak ada Job sama sekali yang terbuat. Kemungkinan-kemungkinan
seperti itu memang diusahakan untuk tidak sering terjadi, tapi tidak ada jaminan kemungkinan-kemungkinan tersebut tidak akan pernah terjadi.
Oleh karena itu, Job sudah sepantasnya memiliki sifat idempoten.</p><p>Jika pengaturan <code>startingDeadlineSeconds</code> menggunakan nilai yang besar atau tidak diatur (menggunakan nilai <em>default</em>)
dan jika pengaturan <code>concurrencyPolicy</code> dijadikan <code>Allow</code>, Job yang terbuat akan dijalankan paling tidak satu kali.</p><p>CronJob <em>controller</em> memeriksa berapa banyak jadwal yang terlewatkan sejak waktu terakhir eksekusi hingga saat ini. Jika terdapat lebih dari 100 jadwal yang terlewat, maka CronJob <em>controller</em> tidak memulai Job dan mencatat kesalahan:</p><pre tabindex=0><code>Cannot determine if job needs to be started. Too many missed start time (&gt; 100). Set or decrease .spec.startingDeadlineSeconds or check clock skew.
</code></pre><p>Perlu diingat bahwa jika pengaturan <code>startingDeadlineSeconds</code> memiliki suatu nilai (bukan <code>nil</code>), CronJob <em>controller</em> akan menghitung berapa banyak Job yang terlewatkan dari sejak <code>startingDeadlineSeconds</code> hingga sekarang dan bukan sejak waktu terakhir eksekusi. Misalnya: Jika <code>startingDeadlineSeconds</code> memiliki nilai <code>200</code>, CronJob <em>controller</em> akan menghitung berapa banyak Job yang terlewatkan dalam 200 detik terakhir.</p><p>Suatu CronJob dianggap terlewat jika ia gagal diciptakan pada waktu yang semestinya. Misalnya: Jika pengaturan <code>concurrencyPolicy</code> dijadikan <code>Forbid</code>
dan suatu CronJob dicoba dijadwalkan saat masih ada penjadwalan sebelumnya yang masih berjalan, maka ia akan dianggap terlewat.</p><p>Contoh: Suatu CronJob akan menjadwalkan Job baru tiap satu menit dimulai sejak <code>08:30:00</code>, dan <code>startingDeadlineSeconds</code> tidak diatur.
Jika CronJob <em>controller</em> tidak aktif dari <code>08:29:00</code> sampai <code>10:21:00</code>, Job tidak akan dijalankan karena jumlah Job yang terlewat
sudah lebih dari 100.</p><p>Sebagai ilustrasi lebih lanjut, misalkan suatu CronJob diatur untuk menjadwalkan Job baru setiap satu menit dimulai sejak <code>08:30:00</code>,
dan <code>startingDeadlineSeconds</code> memiliki nilai <code>200</code>. Jika CronJob <em>controller</em> tidak aktif seperti pada contoh sebelumnya (<code>08:29:00</code> sampai <code>10:21:00</code>),
Job akan tetap dijalankan pada 10:22:00. Hal ini terjadi karena CronJob <em>controller</em> memeriksa banyaknya jadwal yang terlewatkan pada 200 detik terakhir
(dalam kasus ini: 3 jadwal terlewat), dan bukan dari sejak waktu eksekusi terakhir.</p><p>CronJob hanya bertanggung-jawab untuk menciptakan Job yang sesuai dengan jadwalnya sendiri,
dan Job tersebut bertanggung jawab terhadap pengelolaan Pod yang direpresentasikan olehnya.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-0a0a7eca3e302a3c08f8c85e15d337fd>3.5 - Services, Load Balancing, dan Jaringan</h1></div><div class=td-content><h1 id=pg-5701136fd2ce258047b6ddc389112352>3.5.1 - Service</h1><p><a href=/id/docs/concepts/workloads/pods/pod/><code>Pod</code></a> pada Kubernetes bersifat <em>mortal</em>.
Artinya apabila <em>pod-pod</em> tersebut dibuat dan kemudian mati, <em>pod-pod</em> tersebut
tidak akan dihidupkan kembali. <a href=/id/docs/concepts/workloads/controllers/replicaset/><code>ReplicaSets</code></a> secara
khusus bertugas membuat dan menghapus <code>Pod</code> secara dinamis (misalnya, pada proses <em>scaling out</em> atau <em>scaling in</em>).
Meskipun setiap <code>Pod</code> memiliki alamat IP-nya masing-masing, kamu tidak dapat mengandalkan alamat IP
yang diberikan pada <em>pod-pod</em> tersebut, karena alamat IP yang diberikan tidak stabil.
Hal ini kemudian menimbulkan pertanyaan baru: apabila sebuah sekumpulan <code>Pod</code> (yang selanjutnya kita sebut <em>backend</em>)
menyediakan <em>service</em> bagi sebuah sekumpulan <code>Pod</code> lain (yang selanjutnya kita sebut <em>frontend</em>) di dalam
klaster Kubernetes, bagaimana cara <em>frontend</em> menemukan <em>backend</em> mana yang digunakan?</p><p>Inilah alasan kenapa <code>Service</code> ada.</p><p>Sebuah <code>Service</code> pada Kubernetes adalah sebuah abstraksi yang memberikan definisi
set logis yang terdiri beberapa <code>Pod</code> serta <em>policy</em> bagaimana cara kamu mengakses sekumpulan <code>Pod</code> tadi - seringkali disebut sebagai <em>microservices</em>.
Set <code>Pod</code> yang dirujuk oleh suatu <code>Service</code> (biasanya) ditentukan oleh sebuah <a href=/id/docs/concepts/overview/working-with-objects/labels/#label-selectors><code>Label Selector</code></a>
(lihat penjelasan di bawah untuk mengetahui alasan kenapa kamu mungkin saja membutuhkan <code>Service</code> tanpa
sebuah <em>selector</em>).</p><p>Sebagai contoh, misalnya terdapat sebuah <em>backend</em> yang menyediakan fungsionalitas <em>image-processing</em>
yang memiliki 3 buah <em>replica</em>. <em>Replica-replica</em> tadi sifatnya sepadan - dengan kata lain <em>frontend</em>
tidak peduli <em>backend</em> manakah yang digunakan. Meskipun <code>Pod</code> penyusun sekumpulan <em>backend</em> bisa berubah,
<em>frontend</em> tidak perlu peduli bagaimana proses ini dijalankan atau menyimpan <em>list</em> dari <em>backend-backend</em>
yang ada saat itu. <code>Service</code> memiliki tujuan untuk <em>decouple</em> mekanisme ini.</p><p>Untuk aplikasi yang dijalankan di atas Kubernetes, Kubernetes menyediakan API <em>endpoint</em> sederhana
yang terus diubah apabila <em>state</em> sebuah sekumpulan <code>Pod</code> di dalam suatu <code>Service</code> berubah. Untuk
aplikasi <em>non-native</em>, Kubernetes menyediakan <em>bridge</em> yang berbasis <em>virtual-IP</em> bagi <code>Service</code>
yang diarahkan pada <code>Pod</code> <em>backend</em>.</p><h2 id=mendefinisikan-sebuah-service>Mendefinisikan sebuah <code>Service</code></h2><p>Sebuah <code>Service</code> di Kubernetes adalah sebuah objek REST, layaknya sebuah <code>Pod</code>. Seperti semua
objek <em>REST</em>, definisi <code>Service</code> dapat dikirim dengan <em>method POST</em> pada <em>apiserver</em> untuk membuat
sebuah instans baru. Sebagai contoh, misalnya saja kamu memiliki satu sekumpulan <code>Pod</code> yang mengekspos <em>port</em>
9376 dan memiliki <em>label</em> <code>"app=MyApp"</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Spesifikasi ini akan ditranslasikan sebagai sebuah objek <code>Service</code> baru dengan nama <code>"my-service"</code>
dengan <em>target port</em> 9376 pada setiap <code>Pod</code> yang memiliki <em>label</em> <code>"app=MyApp"</code>. <code>Service</code> ini
juga akan memiliki alamat IP tersendiri (yang terkadang disebut sebagai <em>"cluster IP"</em>), yang nantinya
akan digunakan oleh <em>service proxy</em> (lihat di bagian bawah). <em>Selector</em> pada <code>Service</code> akan selalu dievaluasi
dan hasilnya akan kembali dikirim dengan menggunakan <em>method POST</em> ke objek <code>Endpoints</code>
yang juga disebut <code>"my-service"</code>.</p><p>Perhatikan bahwa sebuah <code>Service</code> dapat melakukan pemetaan setiap <em>incoming port</em> pada <code>targetPort</code>
mana pun. Secara <em>default</em>, <em>field</em> <code>targetPort</code> akan memiliki <em>value</em> yang sama dengan <em>value</em> dari <em>field</em> <code>port</code>.
Hal menarik lainnya adalah <em>value</em> dari <code>targetPort</code> bisa saja berupa string yang merujuk pada nama
dari <em>port</em> yang didefinisikan pada <code>Pod</code> <em>backend</em>. Nomor <em>port</em> yang diberikan pada <em>port</em> dengan nama
tadi bisa saja memiliki nilai yang berbeda di setiap <code>Pod</code> <em>backend</em>. Hal ini memberikan fleksibilitas
pada saat kamu melakukan <em>deploy</em> atau melakukan perubahan terhadap <code>Service</code>. Misalnya saja suatu saat
kamu ingin mengubah nomor <em>port</em> yang ada pada <code>Pod</code> <em>backend</em> pada rilis selanjutnya tanpa menyebabkan
permasalahan pada sisi klien.</p><p>Secara <em>default</em>, protokol yang digunakan pada <em>service</em> adalah <code>TCP</code>, tapi kamu bisa saja menggunakan
<a href=#protokol-yang-tersedia>protokol yang tersedia</a>. Karena banyak <code>Service</code> memiliki kebutuhan untuk
mengekspos lebih dari sebuah <em>port</em>, Kubernetes menawarkan definisi <em>multiple</em> <em>port</em> pada sebuah objek
<em>Service</em>. Setiap definisi <em>port</em> dapat memiliki protokol yang berbeda.</p><h3 id=service-tanpa-selector><code>Service</code> tanpa <em>selector</em></h3><p>Secara umum, <code>Service</code> memberikan abstraksi mekanisme yang dilakukan untuk mengakses <code>Pod</code>, tapi
mereka juga melakukan abstraksi bagi <em>backend</em> lainnya. Misalnya saja:</p><ul><li>Kamu ingin memiliki sebuah basis data eksternal di <em>environment</em> <em>production</em> tapi pada tahap <em>test</em>,
kamu ingin menggunakan basis datamu sendiri.</li><li>Kamu ingin merujuk <em>service</em> kamu pada <em>service</em> lainnya yang berada pada
<a href=/id/docs/concepts/overview/working-with-objects/namespaces/><em>Namespace</em></a> yang berbeda atau bahkan klaster yang berbeda.</li><li>Kamu melakukan migrasi <em>workloads</em> ke Kubernetes dan beberapa <em>backend</em> yang kamu miliki masih
berada di luar klaster Kubernetes.</li></ul><p>Berdasarkan skenario-skenario di atas, kamu dapat membuat sebuah <code>Service</code> tanpa <em>selector</em>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Karena <code>Service</code> ini tidak memiliki <em>selector</em>, objek <code>Endpoints</code> bagi <code>Service</code> ini tidak akan dibuat.
Dengan demikian, kamu bisa membuat <code>Endpoints</code> yang kamu inginkan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Endpoints<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>subsets</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>addresses</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>ip</span>:<span style=color:#bbb> </span><span style=color:#666>1.2.3.4</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Perhatikan bahwa alamat IP yang kamu buat untuk <code>Endpoints</code> tidak boleh berupa
<em>loopback</em> (127.0.0.0/8), <em>link-local</em> (169.254.0.0/16), atau <em>link-local multicast</em> (224.0.0.0/24).
Alamat IP tersebut juga tidak boleh berupa <em>cluster IP</em> dari <code>Service</code> Kubernetes lainnya,
karena <code>kube-proxy</code> belum menyediakan dukungan IP virtual sebagai <em>destination</em>.</div><p>Cara mengakses suatu <code>Service</code> tanpa <em>selector</em> sama saja dengan mengakses suatu <code>Service</code>
dengan <em>selector</em>. Trafik yang ada akan di-<em>route</em> ke <code>Endpoints</code> yang dispesifikasikan oleh
pengguna (dalam contoh kali ini adalah <code>1.2.3.4:9376</code>).</p><p>Sebuah <code>ExternalName</code> <code>Service</code> merupakan kasus spesial dari <code>Service</code>
dimana <code>Service</code> tidak memiliki <em>selector</em> dan menggunakan penamaan <em>DNS</em>. Untuk
informasi lebih lanjut silahkan baca bagian <a href=#externalname>ExternalName</a>.</p><h2 id=ip-virtual-dan-proxy-service>IP Virtual dan <em>proxy</em> <code>Service</code></h2><p>Setiap <em>node</em> di klaster Kubernetes menjalankan <code>kube-proxy</code>. <code>kube-proxy</code>
bertanggung jawab terhadap implementasi IP virtual bagi <em>Services</em> dengan tipe
selain <a href=#externalname><code>ExternalName</code></a>.</p><p>Pada Kubernetes versi v1.0, <em>Services</em> adalah "layer 4" (TCP/UDP pada IP), <em>proxy</em>
yang digunakan murni berada pada <em>userspace</em>. Pada Kubernetes v1.1, API <code>Ingress</code>
ditambahkan untuk merepresentasikan "layer 7"(HTTP), <em>proxy</em> <code>iptables</code> juga ditambahkan
dan menjadi mode operasi <em>default</em> sejak Kubernetes v1.2. Pada Kubernetes v1.8.0-beta.0,
<em>proxy</em> <em>ipvs</em> juga ditambahkan.</p><h3 id=mode-proxy-userspace>Mode <em>Proxy</em>: <em>userspace</em></h3><p>Pada mode ini, <code>kube-proxy</code> mengamati master Kubernetes apabila terjadi penambahan
atau penghapusan objek <code>Service</code> dan <code>Endpoints</code>. Untuk setiap <code>Service</code>, <code>kube-proxy</code>
akan membuka sebuah <em>port</em> (yang dipilih secara acak) pada <em>node</em> lokal. Koneksi
pada <em>"proxy port"</em> ini akan dihubungkan pada salah satu <code>Pod</code> <em>backend</em> dari <code>Service</code>
(yang tercatat pada <code>Endpoints</code>). <code>Pod</code> <em>backend</em> yang akan digunakan akan diputuskan berdasarkan
<code>SessionAffinity</code> pada <code>Service</code>. Langkah terakhir yang dilakukan oleh <code>kube-proxy</code>
adalah melakukan instalasi <em>rules</em> <code>iptables</code> yang akan mengarahkan trafik yang ada pada
<code>clusterIP</code> (IP virtual) dan <em>port</em> dari <code>Service</code> serta melakukan <em>redirect</em> trafik ke <em>proxy</em>
yang memproksikan <code>Pod</code> <em>backend</em>. Secara <em>default</em>, mekanisme <em>routing</em> yang dipakai adalah
<em>round robin</em>.</p><p><img src=/images/docs/services-userspace-overview.svg alt="Ikhtisar diagram Services pada proxy userspace"></p><h3 id=mode-proxy-iptables>Mode <em>Proxy</em>: iptables</h3><p>Pada mode ini, <code>kube-proxy</code> mengamati master Kubernetes apabila terjadi penambahan
atau penghapusan objek <code>Service</code> dan <code>Endpoints</code>. Untuk setiap <code>Service</code>,
<code>kube-proxy</code> akan melakukan instalasi <em>rules</em> <code>iptables</code> yang akan mengarahkan
trafik ke <code>clusterIP</code> (IP virtual) dan <em>port</em> dari <code>Service</code>. Untuk setiap objek <code>Endpoints</code>,
<code>kube-proxy</code> akan melakukan instalasi <em>rules</em> <code>iptables</code> yang akan memilih satu buah <code>Pod</code>
<em>backend</em>. Secara <em>default</em>, pemilihan <em>backend</em> ini dilakukan secara acak.</p><p>Tentu saja, <code>iptables</code> yang digunakan tidak boleh melakukan <em>switching</em>
antara <em>userspace</em> dan <em>kernelspace</em>, mekanisme ini harus lebih kokoh dan lebih cepat
dibandingkan dengan <em>userspace</em> <em>proxy</em>. Meskipun begitu, berbeda dengan mekanisme
<em>proxy</em> <em>userspace</em>, <em>proxy</em> <code>iptables</code> tidak bisa secara langsung menjalankan mekanisme
<em>retry</em> ke <code>Pod</code> lain apabila <code>Pod</code> yang sudah dipilih sebelumnya tidak memberikan respons,
dengan kata lain hal ini akan sangat bergantung pada
<a href=/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/#defining-readiness-probes>readiness probes</a>.</p><p><img src=/images/docs/services-iptables-overview.svg alt="Ikhtisar diagram Services pada proxy iptables"></p><h3 id=mode-proxy-ipvs>Mode <em>Proxy</em>: ipvs</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.9 [beta]</code></div><p>Pada mode ini, <code>kube-proxy</code> mengamati <em>Services</em> dan <code>Endpoints</code>, kemudian memanggil
<em>interface</em> <em>netlink</em> untuk membuat <em>rules</em> <em>ipvs</em> yang sesuai serta melakukan sinkronisasi
<em>rules</em> <em>ipvs</em> dengan <em>Services</em> dan <code>Endpoints</code> Kubernetes secara periodik, untuk memastikan
status <em>ipvs</em> konsisten dengan apa yang diharapkan. Ketika sebuah <em>Services</em> diakses,
trafik yang ada akan diarahkan ke salah satu <code>Pod</code> <em>backend</em>.</p><p>Sama halnya dengan <code>iptables</code>, <em>ipvs</em> juga berdasarkan pada fungsi <em>hook</em> <em>netfilter</em>,
bedanya adalah <em>ipvs</em> menggunakan struktur data <em>hash table</em> dan bekerja di <em>kernelspace</em>.
Dengan kata lain <em>ipvs</em> melakukan <em>redirect</em> trafik dengan lebih cepat dan dengan performa yang lebih
baik ketika melakukan sinkronisasi <em>rules</em> <em>proxy</em>. Selain itu, <em>ipvs</em> juga menyediakan
lebih banyak opsi algoritma <em>load balancing</em>:</p><ul><li><code>rr</code>: round-robin</li><li><code>lc</code>: least connection</li><li><code>dh</code>: destination hashing</li><li><code>sh</code>: source hashing</li><li><code>sed</code>: shortest expected delay</li><li><code>nq</code>: never queue</li></ul><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Mode <em>ipvs</em> menggunakan <em>module</em> <em>IPVS</em> <em>kernel</em> yang diinstal pada <em>node</em>
sebelum <code>kube-proxy</code> dijalankan. Ketika <code>kube-proxy</code> dijalankan dengan mode <em>proxy</em> <em>ipvs</em>,
<code>kube-proxy</code> akan melakukan proses validasi, apakah <em>module</em> <em>IPVS</em> sudah diinstal di <em>node</em>,
jika <em>module</em> tersebut belum diinstal, maka <code>kube-proxy</code> akan menggunakan mode <code>iptables</code>.</div><p><img src=/images/docs/services-ipvs-overview.svg alt="Ikhtisar diagram Services pada proxy ipvs"></p><p>Dari sekian model <em>proxy</em> yang ada, trafik <em>inbound</em> apa pun yang ada diterima oleh <em>IP:Port</em> pada <code>Service</code>
akan dilanjutkan melalui <em>proxy</em> pada <em>backend</em> yang sesuai, dan klien tidak perlu mengetahui
apa informasi mendetail soal Kubernetes, <code>Service</code>, atau <code>Pod</code>. afinitas <em>session</em> (<em>session affinity</em>) berbasis
<em>Client-IP</em> dapat dipilih dengan cara menerapkan nilai <em>"ClientIP"</em> pada <code>service.spec.sessionAffinity</code>
(nilai <em>default</em> untuk hal ini adalah <em>"None"</em>), kamu juga dapat mengatur nilai maximum <em>session</em>
<em>timeout</em> yang ada dengan mengatur opsi <code>service.spec.sessionAffinityConfig.clientIP.timeoutSeconds</code> jika
sebelumnya kamu sudah menerapkan nilai <em>"ClusterIP"</em> pada <code>service.spec.sessionAffinity</code>
(nilai <em>default</em> untuk opsi ini adalah <em>"10800"</em>).</p><h2 id=multi-port-services><em>Multi-Port Services</em></h2><p>Banyak <em>Services</em> dengan kebutuhan untuk mengekspos lebih dari satu <em>port</em>.
Untuk kebutuhan inilah, Kubernetes mendukung <em>multiple</em> <em>port</em> <em>definitions</em> pada objek <code>Service</code>.
Ketika menggunakan <em>multiple</em> <em>port</em>, kamu harus memberikan nama pada setiap <em>port</em> yang didefinisikan,
sehingga <em>Endpoint</em> yang dibentuk tidak ambigu. Contoh:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>http<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>https<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>443</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9377</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Perhatikan bahwa penamaan <em>port</em> hanya boleh terdiri dari karakter <em>alphanumeric</em> <em>lowercase</em>
dan <em>-</em>, serta harus dimulai dan diakhiri dengan karakter <em>alphanumeric</em>, misalnya saja <code>123-abc</code> dan <code>web</code>
merupakan penamaan yang valid, tapi <code>123_abc</code> dan <code>-web</code> bukan merupakan penamaan yang valid.</p><h2 id=memilih-sendiri-alamat-ip-yang-kamu-inginkan>Memilih sendiri alamat IP yang kamu inginkan</h2><p>Kamu dapat memberikan spesifikasi alamat <em>cluster IP</em> yang kamu inginkan
sebagai bagian dari <em>request</em> pembuatan objek <code>Service</code>. Untuk melakukan hal ini,
kamu harus mengisi <em>fields</em> <code>.spec.clusterIP</code> field. Contoh penggunaannya adalah sebagai berikut,
misalnya saja kamu sudah memiliki <em>entry</em> DNS yang ingin kamu gunakan kembali,
atau sebuah sistem <em>legacy</em> yang sudah diatur pada alamat IP spesifik
dan sulit untuk diubah. Alamat IP yang ingin digunakan pengguna haruslah merupakan alamat IP
yang valid dan berada di dalam <em>range</em> <em>CIDR</em> <code>service-cluster-ip-range</code> yang dispesifikasikan di dalam
penanda yang diberikan <em>apiserver</em>. Jika <em>value</em> yang diberikan tidak valid, <em>apiserver</em> akan
mengembalikan <em>response</em> <em>code</em> HTTP <em>422</em> yang mengindikasikan <em>value</em> yang diberikan tidak valid.</p><h3 id=mengapa-tidak-menggunakan-dns-round-robin>Mengapa tidak menggunakan DNS <em>round-robin</em>?</h3><p>Pertanyaan yang selalu muncul adalah kenapa kita menggunakan IP virtual dan bukan
DNS <em>round-robin</em> standar? Terdapat beberapa alasan dibalik semua itu:</p><ul><li>Terdapat sejarah panjang dimana <em>library</em> DNS tidak mengikuti <em>TTL</em> DNS dan
melakukan <em>caching</em> hasil dari <em>lookup</em> yang dilakukan.</li><li>Banyak aplikasi yang melakukan <em>lookup</em> DNS hanya sekali dan kemudian melakukan <em>cache</em> hasil yang diperoleh.</li><li>Bahkan apabila aplikasi dan <em>library</em> melakukan resolusi ulang yang <em>proper</em>, <em>load</em> dari setiap
klien yang melakukan resolusi ulang DNS akan sulit untuk di <em>manage</em>.</li></ul><p>Kami berusaha untuk mengurangi ketertarikan pengguna untuk melakukan yang mungkin akan menyusahkan pengguna.
Dengan demikian, apabila terdapat justifikasi yang cukup kuat, kami mungkin saja memberikan implementasi
alternatif yang ada.</p><h2 id=discovering-services><em>Discovering services</em></h2><p>Kubernetes mendukung 2 buah mode primer untuk melakukan <code>Service</code> - variabel <em>environment</em> dan DNS.</p><h3 id=variabel-environment>Variabel <em>Environment</em></h3><p>Ketika sebuah <code>Pod</code> dijalankan pada <em>node</em>, <em>kubelet</em> menambahkan seperangkat variabel <em>environment</em>
untuk setiap <code>Service</code> yang aktif. <em>Environment</em> yang didukung adalah <a href=https://docs.docker.com/userguide/dockerlinks/>Docker links compatible</a> variabel (perhatikan
<a href=http://releases.k8s.io/main/pkg/kubelet/envvars/envvars.go#L49>makeLinkVariables</a>)
dan variabel <code>{SVCNAME}_SERVICE_HOST</code> dan <code>{SVCNAME}_SERVICE_PORT</code>, dinama nama <code>Service</code> akan diubah
menjadi huruf kapital dan tanda <em>minus</em> akan diubah menjadi <em>underscore</em>.</p><p>Sebagai contoh, <code>Service</code> <code>"redis-master"</code> yang mengekspos <em>port</em> TCP 6379 serta <em>alamat</em>
<em>cluster IP</em> <em>10.0.0.11</em> akan memiliki <em>environment</em> sebagai berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#b8860b>REDIS_MASTER_SERVICE_HOST</span><span style=color:#666>=</span>10.0.0.11
</span></span><span style=display:flex><span><span style=color:#b8860b>REDIS_MASTER_SERVICE_PORT</span><span style=color:#666>=</span><span style=color:#666>6379</span>
</span></span><span style=display:flex><span><span style=color:#b8860b>REDIS_MASTER_PORT</span><span style=color:#666>=</span>tcp://10.0.0.11:6379
</span></span><span style=display:flex><span><span style=color:#b8860b>REDIS_MASTER_PORT_6379_TCP</span><span style=color:#666>=</span>tcp://10.0.0.11:6379
</span></span><span style=display:flex><span><span style=color:#b8860b>REDIS_MASTER_PORT_6379_TCP_PROTO</span><span style=color:#666>=</span>tcp
</span></span><span style=display:flex><span><span style=color:#b8860b>REDIS_MASTER_PORT_6379_TCP_PORT</span><span style=color:#666>=</span><span style=color:#666>6379</span>
</span></span><span style=display:flex><span><span style=color:#b8860b>REDIS_MASTER_PORT_6379_TCP_ADDR</span><span style=color:#666>=</span>10.0.0.11
</span></span></code></pre></div><p>Hal ini merupakan kebutuhan yang urutannya harus diperhatikan - <code>Service</code> apa pun yang
akan diakses oleh sebuah <code>Pod</code> harus dibuat sebelum <code>Pod</code> tersebut dibuat,
jika tidak variabel <em>environment</em> tidak akan diinisiasi.
Meskipun begitu, DNS tidak memiliki keterbatasan ini.</p><h3 id=dns>DNS</h3><p>Salah satu <a href=/id/docs/concepts/cluster-administration/addons/><em>add-on</em></a> opsional
(meskipun sangat dianjurkan) adalah server DNS. Server DNS bertugas untuk mengamati apakah
terdapat objek <code>Service</code> baru yang dibuat dan kemudian bertugas menyediakan DNS baru untuk
<em>Service</em> tersebut. Jika DNS ini diaktifkan untuk seluruh klaster, maka semua <code>Pod</code> akan secara otomatis
dapat melakukan resolusi DNS.</p><p>Sebagai contoh, apabila kamu memiliki sebuah <code>Service</code> dengan nama <code>"my-service"</code> pada <em>Namespace</em>
<em>"my-ns"</em>, maka <em>record</em> DNS <code>"my-service.my-ns"</code> akan dibuat. <code>Pod</code> yang berada di dalam
<em>Namespace</em> <em>"my-ns"</em> dapat langsung melakukan <em>lookup</em> dengan hanya menggunakan <code>"my-service"</code>.
Sedangkan <code>Pod</code> yang berada di luar <em>Namespace</em> <em>my-ns"</em> harus menggunakan <code>"my-service.my-ns"</code>.
Hasil dari resolusi ini menrupakan <em>cluster IP</em>.</p><p>Kubernetes juga menyediakan <em>record</em> DNS SRV (service) untuk <em>named ports</em>. Jika
<em>Service</em> <code>"my-service.my-ns"</code> memiliki <em>port</em> dengan nama <code>"http"</code> dengan protokol <code>TCP</code>,
kamu dapat melakukan <em>query</em> DNS SRV untuk <code>"_http._tcp.my-service.my-ns"</code> untuk mengetahui
nomor <em>port</em> yang digunakan oleh <em>http</em>.</p><p>Server DNS Kubernetes adalah satu-satunya cara untuk mengakses
<em>Service</em> dengan tipe <code>ExternalName</code>. Informasi lebih lanjut tersedia di
<a href=/id/docs/concepts/services-networking/dns-pod-service/>DNS <em>Pods</em> dan <em>Services</em></a>.</p><h2 id=service-headless><code>Service</code> <em>headless</em></h2><p>Terkadang kamu tidak membutuhkan mekanisme <em>load-balancing</em> dan sebuah <em>single</em> IP <em>Sevice</em>.
Dalam kasus ini, kamu dapat membuat <em>"headless"</em> <code>Service</code> dengan cara memberikan spesifikasi
<em>None</em> pada <em>cluster IP</em> (<code>.spec.clusterIP</code>).</p><p>Opsi ini memungkinkan pengguna mengurangi ketergantungan terhadap sistem Kubernetes
dengan cara memberikan kebebasan untuk mekanisme <em>service discovery</em>. Aplikasi akan
tetap membutuhkan mekanisme <em>self-registration</em> dan <em>adapter service discovery</em>
lain yang dapat digunakan berdasarkan API ini.</p><p>Untuk <code>Service</code> <em>"headless"</em> alokasi <em>cluster IP</em> tidak dilakukan dan <code>kube-proxy</code>
tidak me-<em>manage</em> <em>Service-Service</em>, serta tidak terdapat mekanisme <em>load balancing</em>
yang dilakukan. Bagaimana konfigurasi otomatis bagi DNS dilakukan bergantung pada
apakah <code>Service</code> tersebut memiliki <em>selector</em> yang dispesifikasikan.</p><h3 id=dengan-selector>Dengan <em>selector</em></h3><p>Untuk <code>Service</code> <em>"headless"</em> dengan <em>selector</em>, kontroler <code>Endpoints</code> akan membuat suatu
<em>record</em> <code>Endpoints</code> di API, serta melakukan modifikasi konfigurasi DNS untuk mengembalikan
<em>A records (alamat)</em> yang merujuk secara langsung pada <code>Pod</code> <em>backend</em>.</p><h3 id=tanpa-selector>Tanpa <em>selector</em></h3><p>Untuk <code>Service</code> <em>"headless"</em> tanpa <em>selector</em>, kontroler <code>Endpoints</code>
tidak akan membuat <em>record</em> <em>Enpoints</em>. Meskipun demikian,
sistem DNS tetap melakukan konfigurasi salah satu dari:</p><ul><li><em>record</em> CNAME untuk <a href=#externalname><code>ExternalName</code></a>-tipe services.</li><li><em>record</em> untuk semua <code>Endpoints</code> yang memiliki nama <code>Service</code> yang sama, untuk
tipe lainnya.</li></ul><h2 id=mekanisme-publish-service-jenis-jenis-service>Mekanisme <em>publish</em> <code>Service</code> - jenis-jenis <code>Service</code></h2><p>Untuk beberapa bagian dari aplikasi yang kamu miliki (misalnya saja, <em>frontend</em>),
bisa saja kamu memiliki kebutuhan untuk mengekspos <code>Service</code> yang kamu miliki
ke alamat IP eksternal (di luar klaster Kubernetes).</p><p><code>ServiceTypes</code> yang ada pada Kubernetes memungkinkan kamu untuk menentukan
jenis <code>Service</code> apakah yang kamu butuhkan. Secara <em>default</em>, jenis <code>Service</code>
yang diberikan adalah <code>ClusterIP</code>.</p><p><em>Value</em> dan perilaku dari tipe <code>Service</code> dijelaskan sebagai berikut:</p><ul><li><code>ClusterIP</code>: Mengekspos <code>Service</code> ke <em>range</em> alamat IP di dalam klaster. Apabila kamu memilih <em>value</em> ini
<code>Service</code> yang kamu miliki hanya dapat diakses secara internal. tipe ini adalah
<em>default</em> <em>value</em> dari <em>ServiceType</em>.</li><li><a href=#type-nodeport><code>NodePort</code></a>: Mengekspos <code>Service</code> pada setiap IP <em>node</em> pada <em>port</em> statis
atau <em>port</em> yang sama. Sebuah <code>Service</code> <code>ClusterIP</code>, yang mana <code>Service</code> <code>NodePort</code> akan di-<em>route</em>
, dibuat secara otomatis. Kamu dapat mengakses <code>Service</code> dengan tipe ini,
dari luar klaster melalui <code>&lt;NodeIP>:&lt;NodePort></code>.</li><li><a href=#loadbalancer><code>LoadBalancer</code></a>: Mengekspos <code>Service</code> secara eksternal dengan menggunakan <code>LoadBalancer</code>
yang disediakan oleh penyedia layanan <em>cloud</em>. <code>Service</code> dengan tipe <code>NodePort</code> dan <code>ClusterIP</code>,
dimana trafik akan di-<em>route</em>, akan dibuat secara otomatis.</li><li><a href=#externalname><code>ExternalName</code></a>: Melakukan pemetaan <code>Service</code> ke konten
dari <em>field</em> <code>externalName</code> (misalnya: <code>foo.bar.example.com</code>), dengan cara mengembalikan
catatan <code>CNAME</code> beserta <em>value</em>-nya. Tidak ada metode <em>proxy</em> apa pun yang diaktifkan. Mekanisme ini
setidaknya membutuhkan <code>kube-dns</code> versi 1.7.</li></ul><h3 id=type-nodeport>Type NodePort</h3><p>Jika kamu menerapkan <em>value</em> <code>NodePort</code> pada <em>field</em> <em>type</em>, master Kubernetes akan mengalokasikan
<em>port</em> dari <em>range</em> yang dispesifikasikan oleh penanda <code>--service-node-port-range</code> (secara <em>default</em>, 30000-32767)
dan setiap <em>Node</em> akan memproksikan <em>port</em> tersebut (setiap <em>Node</em> akan memiliki nomor <em>port</em> yang sama) ke <code>Service</code>
yang kamu miliki. <code>Port</code> tersebut akan dilaporkan pada <em>field</em> <code>.spec.ports[*].nodePort</code> di <code>Service</code> kamu.</p><p>Jika kamu ingin memberikan spesifikasi IP tertentu untuk melakukan <em>poxy</em> pada <em>port</em>.
kamu dapat mengatur penanda <code>--nodeport-addresses</code> pada <code>kube-proxy</code> untuk <em>range</em> alamat IP
tertentu (mekanisme ini didukung sejak v1.10). Sebuah daftar yang dipisahkan koma (misalnya, <em>10.0.0.0/8</em>, <em>1.2.3.4/32</em>)
digunakan untuk mem-<em>filter</em> alamat IP lokal ke <em>node</em> ini. Misalnya saja kamu memulai <code>kube-proxy</code> dengan penanda
<code>--nodeport-addresses=127.0.0.0/8</code>, maka <code>kube-proxy</code> hanya akan memilih <em>interface</em> <em>loopback</em> untuk <code>Service</code> dengan tipe
<code>NodePort</code>. Penanda <code>--nodeport-addresses</code> memiliki nilai <em>default</em> kosong (<code>[]</code>), yang artinya akan memilih semua <em>interface</em> yang ada
dan sesuai dengan perilaku <code>NodePort</code> <em>default</em>.</p><p>Jika kamu menginginkan nomor <em>port</em> yang berbeda, kamu dapat memberikan spesifikasi
<em>value</em> dari <em>field</em> <em>nodePort</em>, dan sistem yang ada akan mengalokasikan <em>port</em> tersebut untuk kamu,
jika <em>port</em> tersebut belum digunakan (perhatikan bahwa jika kamu menggunakan teknik ini, kamu perlu
mempertimbangkan <em>collision</em> yang mungkin terjadi dan bagaimana cara mengatasi hal tersebut)
atau transaksi API yang dilakukan akan gagal.</p><p>Hal ini memberikan kebebasan bagi pengembang untuk memilih <em>load balancer</em> yang akan digunakan, terutama apabila
<em>load balancer</em> yang ingin digunakan belum didukung sepenuhnya oleh Kubernetes.</p><p>Perhatikan bahwa <code>Service</code> dapat diakses baik dengan menggunakan <code>&lt;NodeIP>:spec.ports[*].nodePort</code>
atau <code>.spec.clusterIP:spec.ports[*].port</code>. (Jika penanda <code>--nodeport-addresses</code> diterapkan, <nodeip>dapat di-<em>filter</em> dengan salah satu atau lebih <em>NodeIP</em>.)</p><h3 id=loadbalancer>Type LoadBalancer</h3><p>Pada penyedia layanan <em>cloud</em> yang menyediakan pilihan <em>load balancer</em> eksternal, pengaturan <em>field</em> <em>type</em>
ke <code>LoadBalancer</code> akan secara otomatis melakukan proses <em>provision</em> <em>load balancer</em> untuk <code>Service</code> yang kamu buat.
Informasi mengenai <em>load balancer</em> yang dibuat akan ditampilkan pada <em>field</em> <code>.status.loadBalancer</code>
pada <code>Service</code> kamu. Contohnya:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clusterIP</span>:<span style=color:#bbb> </span><span style=color:#666>10.0.171.239</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>loadBalancerIP</span>:<span style=color:#bbb> </span><span style=color:#666>78.11.24.19</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>LoadBalancer<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>loadBalancer</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ingress</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>ip</span>:<span style=color:#bbb> </span><span style=color:#666>146.148.47.155</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Trafik dari <em>load balancer</em> eksternal akan diarahkan pada <code>Pod</code> <em>backend</em>, meskipun mekanisme
bagaimana hal ini dilakukan bergantung pada penyedia layanan <em>cloud</em>. Beberapa penyedia layanan
<em>cloud</em> mengizinkan konfigurasi untuk <em>value</em> <code>loadBalancerIP</code>. Dalam kasus tersebut, <em>load balancer</em> akan dibuat
dengan <em>loadbalancerIP</em> yang dispesifikasikan. Jika <em>value</em> dari <code>loadBalancerIP</code> tidak dispesifikasikan.
sebuah IP sementara akan diberikan pada <em>loadBalancer</em>. Jika <code>loadBalancerIP</code> dispesifikasikan,
tetapi penyedia layanan <em>cloud</em> tidak mendukung hal ini, maka <em>field</em> yang ada akan diabaikan.</p><p><strong>Catatan Khusus untuk Azure</strong>: Untuk spesifikasi <code>loadBalancerIP</code> publik yang didefinisikan oleh pengguna,
sebuah alamat IP statis publik akan disediakan terlebih dahulu, dan alamat IP tersebut harus berada di
<em>resource group</em> dari <em>resource</em> yang secara otomatis dibuat oleh klaster. Misalnya saja, <code>MC_myResourceGroup_myAKSCluster_eastus</code>.
Berikan spesifikasi alamat IP sebagai <code>loadBalancerIP</code>. Pastikan kamu sudah melakukan <em>update</em> pada
<em>securityGroupName</em> pada <em>file</em> konfigurasi penyedia layanan <em>cloud</em>.
Untuk informasi lebih lanjut mengenai <em>permission</em> untuk <code>CreatingLoadBalancerFailed</code> kamu dapat membaca <em>troubleshooting</em> untuk
<a href=https://docs.microsoft.com/en-us/azure/aks/static-ip>Penggunaan alamat IP statis pada <em>load balancer</em> Azure Kubernetes Service (AKS)</a> atau
<a href=https://github.com/Azure/AKS/issues/357><em>CreatingLoadBalancerFailed</em> pada klaster AKS dengan <em>advanced networking</em></a>.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Dukungan untuk SCTP <em>load balancer</em> dari penyedia layanan <em>cloud</em> bergantung pada
implementasi <em>load balancer</em> yang disediakan oleh penyedia layanan <em>cloud</em> tersebut.
Jika SCTP tidak didukung oleh <em>load balancer</em> penyedia layanan publik maka <em>request</em> pembuatan <code>Service</code>
akan tetap diterima, meskipun proses pembuatan <em>load balancer</em> itu sendiri gagal.</div><h4 id=load-balancer-internal><em>Load balancer</em> internal</h4><p>Di dalam <em>environment</em>, terkadang terdapat kebutuhan untuk melakukan <em>route</em> trafik antar
<em>Service</em> yang berada di dalam satu VPC.</p><p>Di dalam <em>environment</em> <em>split-horizon DNS</em> kamu akan membutuhkan dua <em>service</em> yang mampu
melakukan mekanisme <em>route</em> trafik eskternal maupun internal ke <em>endpoints</em> yang kamu miliki.</p><p>Hal ini dapat diraih dengan cara menambahkan anotasi berikut untuk <em>service</em> yang disediakan oleh
penyedia layanan <em>cloud</em>.</p><ul class="nav nav-tabs" id=service-tabs role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#service-tabs-0 role=tab aria-controls=service-tabs-0 aria-selected=true>Default</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#service-tabs-1 role=tab aria-controls=service-tabs-1>GCP</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#service-tabs-2 role=tab aria-controls=service-tabs-2>AWS</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#service-tabs-3 role=tab aria-controls=service-tabs-3>Azure</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#service-tabs-4 role=tab aria-controls=service-tabs-4>OpenStack</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#service-tabs-5 role=tab aria-controls=service-tabs-5>Baidu Cloud</a></li></ul><div class=tab-content id=service-tabs><div id=service-tabs-0 class="tab-pane show active" role=tabpanel aria-labelledby=service-tabs-0><p><p>Pilih salah satu <em>tab</em>.</p></div><div id=service-tabs-1 class=tab-pane role=tabpanel aria-labelledby=service-tabs-1><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>[...]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cloud.google.com/load-balancer-type</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Internal&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>[...]<span style=color:#bbb>
</span></span></span></code></pre></div><p>Gunakan <em>cloud.google.com/load-balancer-type: "internal"</em> untuk master dengan versi 1.7.0 to 1.7.3.
Untuk informasi lebih lanjut, dilahkan baca <a href=https://cloud.google.com/kubernetes-engine/docs/internal-load-balancing>dokumentasi</a>.</p></div><div id=service-tabs-2 class=tab-pane role=tabpanel aria-labelledby=service-tabs-2><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>[...]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-internal</span>:<span style=color:#bbb> </span><span style=color:#666>0.0.0.0</span>/0<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>[...]<span style=color:#bbb>
</span></span></span></code></pre></div></div><div id=service-tabs-3 class=tab-pane role=tabpanel aria-labelledby=service-tabs-3><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>[...]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/azure-load-balancer-internal</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>[...]<span style=color:#bbb>
</span></span></span></code></pre></div></div><div id=service-tabs-4 class=tab-pane role=tabpanel aria-labelledby=service-tabs-4><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>[...]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/openstack-internal-load-balancer</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>[...]<span style=color:#bbb>
</span></span></span></code></pre></div></div><div id=service-tabs-5 class=tab-pane role=tabpanel aria-labelledby=service-tabs-5><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>[...]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/cce-load-balancer-internal-vpc</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>[...]<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><h4 id=dukungan-untuk-ssl-di-aws>Dukungan untuk SSL di AWS</h4><p>Dukungan parsial untuk SSL bagi klaster yang dijalankan di AWS mulai diterapkan,
mulai versi 1.3 terdapat 3 anotasi yang dapat ditambahkan pada <code>Service</code> dengan tipe
<code>LoadBalancer</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-ssl-cert</span>:<span style=color:#bbb> </span>arn:aws:acm:us-east-1:123456789012:certificate/12345678-1234-1234-1234-123456789012<span style=color:#bbb>
</span></span></span></code></pre></div><p>Anotasi pertama memberikan spesifikasi ARN dari sertifikat yang akan digunakan.
Sertifikat yang digunakan bisa saja berasal dari <em>third party</em> yang diunggah ke IAM atau
sertifikat yang dibuat secara langsung dengan menggunakan sertifikat manajer AWS.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-backend-protocol</span>:<span style=color:#bbb> </span>(https|http|ssl|tcp)<span style=color:#bbb>
</span></span></span></code></pre></div><p>Anotasi kedua memberikan spesifikasi bagi protokol yang digunakan oleh <code>Pod</code> untuk saling berkomunikasi.
Untuk HTTPS dan SSL, ELB membutuhkan <code>Pod</code> untuk melakukan autentikasi terhadap dirinya sendiri melalui
koneksi yang dienkripsi.</p><p>Protokol HTTP dan HTTPS akan memilih mekanisme <em>proxy</em> di tingkatan ke-7:
ELB akan melakukan terminasi koneksi dengan pengguna, melakukan proses <em>parsing</em> <em>headers</em>, serta
memasukkan <em>value</em> bagi <em>header</em> <code>X-Forwarded-For</code> dengan alamat IP pengguna (<em>Pod</em> hanya dapat melihat
alamat IP dari ELB pada akhir koneksi yang diberikan) ketika melakukan <em>forwarding</em> suatu <em>request</em>.</p><p>Protokol TCP dan SSL akan memilih mekanisme <em>proxy</em> pada tingkatan 4: ELB akan melakukan <em>forwarding</em> trafik
tanpa melakukan modifikasi <em>headers</em>.</p><p>Pada <em>environment</em> campuran dimana beberapa <em>port</em> diamankan sementara <em>port</em> lainnya dalam kondisi tidak dienkripsi,
anotasi-anotasi berikut dapat digunakan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-backend-protocol</span>:<span style=color:#bbb> </span>http<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-ssl-ports</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;443,8443&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Pada contoh di atas, jika <code>Service</code> memiliki 3 buah <em>port</em>, yaitu: <code>80</code>, <code>443</code>, dan
<code>8443</code>, maka <code>443</code> adan <code>8443</code> akan menggunakan sertifikat SSL, tetapi <code>80</code> hanya akan
di-<em>proxy</em> menggunakan protokol HTTP.</p><p>Mulai versi 1.9, <code>Service</code> juga dapat menggunakan <a href=http://docs.aws.amazon.com/elasticloadbalancing/latest/classic/elb-security-policy-table.html><em>predefined</em> <em>policy</em></a>
untuk HTTPS atau <em>listener</em> SSL. Untuk melihat <em>policy</em> apa saja yang dapat digunakan, kamu dapat menjalankan perintah <em>awscli</em>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>aws elb describe-load-balancer-policies --query <span style=color:#b44>&#39;PolicyDescriptions[].PolicyName&#39;</span>
</span></span></code></pre></div><p><em>Policy</em> ini kemudian dapat dispesifikasikan menggunakan anotasi
"<em>service.beta.kubernetes.io/aws-load-balancer-ssl-negotiation-policy</em>", contohnya:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-ssl-negotiation-policy</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;ELBSecurityPolicy-TLS-1-2-2017-01&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><h4 id=protokol-proxy-pada-aws>Protokol PROXY pada AWS</h4><p>Untuk mengaktifkan dukungan <a href=https://www.haproxy.org/download/1.8/doc/proxy-protocol.txt>protokol PROXY</a>
untuk klaster yang dijalankan di AWS, kamu dapat menggunakan anotasi di bawah ini:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-proxy-protocol</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;*&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Sejak versi 1.3.0, penggunaan anotasi berlaku untuk semua <em>port</em> yang diproksi oleh ELB
dan tidak dapat diatur sebaliknya.</p><h4 id=akses-log-elb-pada-aws>Akses <em>Log</em> ELB pada AWS</h4><p>Terdapat beberapa anotasi yang digunakan untuk melakukan manajemen
akses <em>log</em> untuk ELB pada AWS.</p><p>Anotasi <code>service.beta.kubernetes.io/aws-load-balancer-access-log-enabled</code>
mengatur akses <em>log</em> mana sajakah yang diaktifkan.</p><p>Anotasi <code>service.beta.kubernetes.io/aws-load-balancer-access-log-emit-interval</code>
mengatur interval (dalam menit) publikasi akses <em>log</em>. Kamu dapat memberikan spesifikasi interval
diantara <em>range</em> 5-60 menit.</p><p>Anotasi <code>service.beta.kubernetes.io/aws-load-balancer-access-log-s3-bucket-name</code>
mengatur nama <em>bucket</em> Amazon S3 dimana akses <em>log</em> <em>load balancer</em> disimpan.</p><p>Anotasi <code>service.beta.kubernetes.io/aws-load-balancer-access-log-s3-bucket-prefix</code>
memberikan spesifikasi hierarki logis yang kamu buat untuk <em>bucket</em> Amazon S3 yang kamu buat.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-access-log-enabled</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># Specifies whether access logs are enabled for the load balancer</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-access-log-emit-interval</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;60&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># The interval for publishing the access logs. You can specify an interval of either 5 or 60 (minutes).</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-access-log-s3-bucket-name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;my-bucket&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># The name of the Amazon S3 bucket where the access logs are stored</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-access-log-s3-bucket-prefix</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;my-bucket-prefix/prod&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># The logical hierarchy you created for your Amazon S3 bucket, for example _my-bucket-prefix/prod_</span><span style=color:#bbb>
</span></span></span></code></pre></div><h4 id=mekanisme-draining-koneksi-pada-aws>Mekanisme <em>Draining</em> Koneksi pada AWS</h4><p>Mekanisme <em>draining</em> untuk ELB klasik dapat dilakukan dengan menggunakan anotasi
<code>service.beta.kubernetes.io/aws-load-balancer-connection-draining-enabled</code> serta mengatur
<em>value</em>-nya menjadi <code>"true"</code>. Anotasi
<code>service.beta.kubernetes.io/aws-load-balancer-connection-draining-timeout</code> juga
dapat digunakan untuk mengatur <em>maximum time</em> (dalam detik), untuk menjaga koneksi yang ada
agar selalu terbuka sebelum melakukan <em>deregistering</em> <em>instance</em>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-connection-draining-enabled</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-connection-draining-timeout</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;60&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><h4 id=anotasi-elb-lainnya>Anotasi ELB lainnya</h4><p>Terdapat beberapa anotasi lain yang dapat digunakan untuk mengatur ELB klasik
sebagaimana dijelaskan seperti di bawah ini:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-connection-idle-timeout</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;60&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># The time, in seconds, that the connection is allowed to be idle (no data has been sent over the connection) before it is closed by the load balancer</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-cross-zone-load-balancing-enabled</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># Specifies whether cross-zone load balancing is enabled for the load balancer</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-additional-resource-tags</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;environment=prod,owner=devops&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># A comma-separated list of key-value pairs which will be recorded as</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># additional tags in the ELB.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-healthcheck-healthy-threshold</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># The number of successive successful health checks required for a backend to</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># be considered healthy for traffic. Defaults to 2, must be between 2 and 10</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-healthcheck-unhealthy-threshold</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;3&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># The number of unsuccessful health checks required for a backend to be</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># considered unhealthy for traffic. Defaults to 6, must be between 2 and 10</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-healthcheck-interval</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;20&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># The approximate interval, in seconds, between health checks of an</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># individual instance. Defaults to 10, must be between 5 and 300</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-healthcheck-timeout</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;5&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># The amount of time, in seconds, during which no response means a failed</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># health check. This value must be less than the service.beta.kubernetes.io/aws-load-balancer-healthcheck-interval</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># value. Defaults to 5, must be between 2 and 60</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-extra-security-groups</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;sg-53fae93f,sg-42efd82e&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># A list of additional security groups to be added to ELB</span><span style=color:#bbb>
</span></span></span></code></pre></div><h4 id=dukungan-network-load-balancer-nlb-pada-aws-alpha>Dukungan <em>Network Load Balancer</em> (NLB) pada AWS [alpha]</h4><div class="alert alert-danger warning callout" role=alert><strong>Peringatan:</strong> Ini merupakan tingkatan <em>alpha</em> dan tidak direkomendasikan untuk digunakan pada <em>environment</em> <em>production</em>.</div><p>Sejak versi 1.9.0, Kubernetes mendukung <em>Network Load Balancer</em> (NLB). Untuk
menggunakan NLB pada AWS, gunakan anotasi <code>service.beta.kubernetes.io/aws-load-balancer-type</code>
dan atur <em>value</em>-nya dengan <code>nlb</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-type</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;nlb&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Tidak seperti ELB klasik, NLB, melakukan <em>forwarding</em> IP klien melalui <em>node</em>.
Jika <em>field</em> <code>.spec.externalTrafficPolicy</code> diatur <em>value</em>-nya menjadi <code>Cluster</code>, maka
alamat IP klien tidak akan diteruskan pada <code>Pod</code>.</p><p>Dengan mengatur <em>value</em> dari <em>field</em> <code>.spec.externalTrafficPolicy</code> ke <code>Local</code>,
alamat IP klien akan diteruskan ke <code>Pod</code>, tapi hal ini bisa menyebabkan distribusi trafik
yang tidak merata. <em>Node</em> yang tidak memiliki <code>Pod</code> untuk <code>Service</code> dengan tipe <code>LoadBalancer</code>
akan menyebabkan kegagalan <em>health check</em> <em>NLB Target</em> pada tahapan <em>auto-assigned</em> <code>.spec.healthCheckNodePort</code>
dan tidak akan menerima trafik apa pun.</p><p>Untuk menghasilkan distribusi trafik yang merata, kamu dapat menggunakan
<em>DaemonSet</em> atau melakukan spesifikasi
<a href=/id/docs/concepts/scheduling-eviction/assign-pod-node/#inter-pod-affinity-and-anti-affinity-beta-feature>pod anti-affinity</a>
agar <code>Pod</code> tidak di-<em>assign</em> ke <em>node</em> yang sama.</p><p>NLB juga dapat digunakan dengan anotasi <a href=/id/docs/concepts/services-networking/service/#internal-load-balancer>internal load balancer</a>.</p><p>Agar trafik klien berhasil mencapai <em>instances</em> dibelakang ELB,
<em>security group</em> dari <em>node</em> akan diberikan <em>rules</em> IP sebagai berikut:</p><table><thead><tr><th><em>Rule</em></th><th>Protokol</th><th><code>Port</code></th><th><em>IpRange(s)</em></th><th>Deskripsi <em>IpRange</em></th></tr></thead><tbody><tr><td><em>Health Check</em></td><td>TCP</td><td>NodePort(s) (<code>.spec.healthCheckNodePort</code> for <em>.spec.externalTrafficPolicy = Local</em>)</td><td>VPC CIDR</td><td>kubernetes.io/rule/nlb/health=&lt;loadBalancerName></td></tr><tr><td><em>Client Traffic</em></td><td>TCP</td><td>NodePort(s)</td><td><code>.spec.loadBalancerSourceRanges</code> (defaults to <code>0.0.0.0/0</code>)</td><td>kubernetes.io/rule/nlb/client=&lt;loadBalancerName></td></tr><tr><td><em>MTU Discovery</em></td><td>ICMP</td><td>3,4</td><td><code>.spec.loadBalancerSourceRanges</code> (defaults to <code>0.0.0.0/0</code>)</td><td>kubernetes.io/rule/nlb/mtu=&lt;loadBalancerName></td></tr></tbody></table><p>Perhatikan bahwa jika <code>.spec.loadBalancerSourceRanges</code> tidak dispesifikasikan,
Kubernetes akan mengizinkan trafik dari <code>0.0.0.0/0</code> ke <em>Node Security Group</em>.
Jika <em>node</em> memiliki akses publik, maka kamu harus memperhatikan tersebut karena trafik yang tidak berasal
dari NLB juga dapat mengakses semua <em>instance</em> di <em>security group</em> tersebut.</p><p>Untuk membatasi klien IP mana yang dapat mengakses NLB,
kamu harus memberikan spesifikasi <em>loadBalancerSourceRanges</em>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>loadBalancerSourceRanges</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;143.231.0.0/16&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> NLB hanya dapat digunakan dengan beberapa kelas <em>instance</em> tertentu baca <a href=http://docs.aws.amazon.com/elasticloadbalancing/latest/network/target-group-register-targets.html#register-deregister-targets>dokumentasi AWS</a>
untuk mengetahui lebih lanjut <em>intance</em> apa saja yang didukung.</div><h3 id=externalname>Tipe ExternalName</h3><p>Service dengan tipe <code>ExternalName</code> melakukan pemetaan antara <code>Service</code> dan DNS, dan bukan
ke <em>selector</em> seperti <code>my-service</code> atau <code>cassandra</code>. Kamu memberikan spesifikasi <code>spec.externalName</code>
pada <code>Service</code> tersebut.</p><p>Definisi <code>Service</code> ini, sebagai contoh, melaukan pemetaan
<code>Service</code> <code>my-service</code> pada <em>namespace</em> <code>prod</code> ke DNS <code>my.database.example.com</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>prod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>ExternalName<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>externalName</span>:<span style=color:#bbb> </span>my.database.example.com<span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> <code>ExternalName</code> menerima alamat IPv4 dalam bentuk string,
tapi karena DNS tersusun atas angka dan bukan sebagai alamat IP.
<code>ExternalName</code> yang menyerupai alamat IPv4 tidak bisa di-<em>resolve</em> oleh <em>CoreDNS</em>
atau <em>ingress-nginx</em> karena <code>ExternalName</code> memang ditujukan bagi penamaan <em>canonical</em> DNS.
Untuk melakukan <em>hardcode</em> alamat IP, kamu dapat menggunakan <em>headless</em> <code>Service</code> sebagai alternatif.</div><p>Ketika melakukan pencarian <em>host</em> <code>my-service.prod.svc.cluster.local</code>,
servis DNS klaster akan mengembalikan <em>record</em> <code>CNAME</code> dengan <em>value</em> <code>my.database.example.com</code>.
Mekanisme akses pada <code>my-service</code> bekerja dengan cara yang sama dengan
<code>Service</code> pada umumnya, perbedaan yang krusial untuk hal ini adalah mekanisme <em>redirection</em>
terjadi pada tingkatan DNS dan bukan melalui <em>proxy forward</em>. Apabila kamu berniat memindahkan basis data
yang kamu pakai ke dalam klaster, kamu hanya perlu mengganti instans basis data kamu dan menjalankannya
di dalam <code>Pod</code>, menambahkan <em>selector</em> atau <em>endpoint</em> yang sesuai, serta mengupah <em>type</em> dari
<em>Service</em> yang kamu gunakan.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Bagian ini berasal dari tulisan <a href=https://akomljen.com/kubernetes-tips-part-1/>Tips Kubernetes - Bagian
1</a> oleh <a href=https://akomljen.com/>Alen Komljen</a>.</div><h3 id=ip-eksternal>IP Eksternal</h3><p>Jika terdapat sebuah alamat IP eksternal yang melakukan mekanisme <em>route</em> ke satu atau lebih <em>node</em> yang ada di klaster, <code>Service</code> Kubernetes dapat diekspos
dengan menggunakan <code>externalIP</code>. Trafik yang diarahkan ke klaster dengan IP eksternal
(sebagai destinasi IP), pada <em>port</em> <code>Service</code> akan di-<em>route</em> ke salah satu <em>endpoint</em> <code>Service</code>.
<em>Value</em> dari <code>externalIP</code> tidak diatur oleh Kubernetes dan merupakan tanggung jawab
dari administrator klaster.</p><p>Pada <em>ServiceSpec</em>, kamu dapat memberikan spesifikasi <code>externalIP</code> dan <code>ServiceTypes</code>.
Pada contoh di bawah ini. <code>"my-service"</code> dapat diakses oleh klien pada "<code>80.11.12.10:80</code>" (<code>externalIP:port</code>).</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>http<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>externalIPs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#666>80.11.12.10</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=kekurangan>Kekurangan</h2><p>Penggunaan <em>proxy</em> <em>userspace</em> untuk VIP dapat digunakan untuk skala kecil hingga menengah,
meski begitu hal ini tidak <em>scalable</em> untuk klaster yang sangat besar dan memiliki ribuan <code>Service</code>.
Perhatikan <a href=http://issue.k8s.io/1107>Desain proposal orisinil untuk <em>portal</em></a> untuk informasi
lebih lanjut.</p><p>Penggunaan <em>proxy</em> <em>userspace</em> menghilangkan <em>source-IP</em> dari <em>packet</em> yang mengakses
sebuah <code>Service</code>. Hal ini membuat mekanisme <em>firewall</em> menjadi sulit untuk diterapkan.
<em>Proxy</em> <code>iptables</code> tidak menghilangkan <em>source IP</em> yang berasal dari dalam klaster,
meski begitu, hal ini masih berimbas pada klien yang berasal dari <code>Service</code> dengan tipe
<em>load-balancer</em> atau <em>node-port</em>.</p><p><em>Field</em> tipe didesain sebagai fungsionalitas yang berantai - setiap tingkatan
menambahkan tambahan pada tingkatansebelumnya. Hal ini tidak selalu berlaku bagi
semua penyedia layanan <em>cloud</em> (misalnya saja Google Compute Engine tidak perlu
melakukan alokasi <code>NodePort</code> untuk membuat <code>LoadBalancer</code> bekerja sebagaimana mestinya,
hal ini berbeda dengan AWS yang memerlukan hal ini, setidaknya untuk API yang mereka miliki
saat ini).</p><h2 id=pengerjaan-lebih-lanjut>Pengerjaan lebih lanjut</h2><p>Di masa mendatang, kami berencana untuk membuat <em>policy</em> <em>proxy</em> menjadi lebih
bervariasi dan bukan hanya <em>round robin</em>, misalnya saja <em>master-elected</em> atau <em>sharded</em>.
Kami juga berharap bahwa beberapa <code>Service</code> bisa saja memiliki <em>load balancer</em> yang sebenarnya,
suatu kasus dimana VIP akan secara langsung mengantarkan paket.</p><p>Kami ingin meningkatkan dukungan lebih lanjut untuk <code>Service</code> dengan tingkatan <code>Service</code> L7(HTTP).</p><p>Kami ingin memiliki mode <em>ingress</em> yang lebih fleksibel untuk <code>Service</code> yang
mencakup mode <code>ClusterIP</code>, <code>NodePort</code>, dan <code>LoadBalancer</code> dan banyak lagi.</p><h2 id=detail-mendalam-mengenai-ip-virtual>Detail mendalam mengenai IP virtual</h2><p>Informasi sebelumnya sudah cukup bagi sebagian orang yang hanya ingin menggunakan
<em>Service</em>. Meskipun begitu, terdapat banyak hal yang sebenarnya terjadi dan akan
sangat bermanfaat untuk dipelajari lebih lanjut.</p><h3 id=menghindari-collison>Menghindari <em>collison</em></h3><p>Salah satu filosofi Kubernetes adalah pengguna tidak mungkin menghadapi situasi
dimana apa yang mereka mengalami kegagalan tanpa adanya alasan yang jelas. Dalam kasus ini,
kita akan coba memahami lebih lanjut mengenai <em>network port</em> - pengguna tidak seharusnya memilih
nomor <em>port</em> jika hal itu memungkinkan terjadinya <em>collision</em> dengan pengguna lainnya. Hal ini
merupakan mekanisme isolasi kegagalan.</p><p>Agar pengguna dapat menentukan nomor <em>port</em> bagi <code>Service</code> mereka, kita harus
memastikan bahwa tidak ada dua <code>Service</code> yang mengalami <em>collision</em>. Kita melakukan
hal tersebut dengan cara melakukan alokasi alamat IP pada setiap <code>Service</code>.</p><p>Untuk memastikan setiap <code>Service</code> memiliki alamat IP yang unik, sebuah <em>allocator</em>
internal akan secara atomik melakukan pemetaan alokasi global di dalam <em>etcd</em> ketika
membuat sebuah <code>Service</code> baru. Pemetaan objek harus tersedia pada <em>registry</em> <code>Service</code>
dimana <code>Service</code> akan diberikan sebuah IP, jika tidak, proses pembuatan <code>Service</code> akan gagal
dan sebuah pesan akan memberikan informasi bahwa alamat IP tidak dapat dialokasikan.
Sebuah <em>backgroud</em> <em>controller</em> bertanggung jawab terhadap mekanisme pemetaan tersebut (migrasi
dari versi Kubernetes yang digunakan dalam <em>memory locking</em>) sekaligus melakukan pengecekan
terhadap <em>assignment</em> yang tidak valid yang terjadi akibat intervensi administrator dan melakukan
penghapusan daftar IP yang dialokasikan tapi tidak digunakan oleh <code>Service</code> mana pun.</p><h3 id=ip-dan-vip>IP dan VIP</h3><p>Tidak seperti alamat IP <code>Pod</code>, yang akan di <em>route</em> ke destinasi yang "pasti",
IP <code>Service</code> tidak mengarahkan <em>request</em> hanya pada satu <em>host</em>. Sebagai gantinya,
kita mneggunakan <code>iptables</code> (logika pemrosesan paket pada Linux) untuk melakukan definisi
alamat IP virtual yang secara transparan akan diarahkan sesuai kebutuhan. Ketika klien
dihubungkan pada VIP, trafik yang ada akan secara otomatis dialihkan pada <em>endpoint</em> yang sesuai.
Variabel <em>environment</em> dan DNS untuk <code>Service</code> terdiri dalam bentuk VIP dan <em>port</em>.</p><p>Kami mendukung tiga jenis mode <em>proxy</em> - <em>userspace</em>, <code>iptables</code>, dan <em>ipvs</em> yang memiliki
perbedaan cara kerja satu sama lainnya.</p><h4 id=userspace><em>Userspace</em></h4><p>Sebagai contoh, anggaplah kita memiliki aplikasi <em>image processing</em> seperti yang sudah
disebutkan di atas. Ketika <code>Service</code> <em>backend</em> dibuat, <em>master</em> Kubernetes akan mengalokasikan
sebuah alamat IP virtual, misalnya 10.0.0.1. Dengan asumsi <em>port</em> dari <code>Service</code> tersebut adalah <em>1234</em>,
maka <code>Service</code> tersebut akan diamati oleh semua <em>instance</em> <code>kube-proxy</code> yang ada di klaster.
Ketika sebuah <em>proxy</em> mendapati sebuah <code>Service</code> baru, <em>proxy</em> tersebut akan membuka sebuah <em>port</em>
<em>acak</em>, menyediakan <code>iptables</code> yang mengarahkan VIP pada <em>port</em> yang baru saja dibuat, dan mulai
koneksi pada <em>port</em> tersebut.</p><p>Ketika sebuah klien terhubung ke VIP dan terdapat <em>rules</em> <code>iptables</code>
yang diterapkan, paket akan diarahkan ke <em>port</em> dari <em>proxy</em> <code>Service</code> itu sendiri.
<em>Proxy</em> <code>Service</code> akan memilih sebuah <em>backend</em>, dan mulai melakukan mekanisme <em>proxy</em>
trafik dari klien ke <em>backend</em>.</p><p>Dengan demikian, pemilik <code>Service</code> dapat memilih <em>port</em> mana pun yang dia inginkan
tanpa adanya kemungkinan terjadinya <em>collision</em>. Klien dapat dengan mudah mengakses IP dan <em>port</em>,
tanpa harus mengetahui <code>Pod</code> mana yang sebenarnya diakses.</p><h4 id=iptables><em>Iptables</em></h4><p>Kembali, bayangkan apabila kita memiliki aplikasi <em>image processing</em> seperti yang sudah
disebutkan di atas. Ketika <code>Service</code> <em>backend</em> dibuat, <em>master</em> Kubernetes akan mengalokasikan
sebuah alamat IP virtual, misalnya 10.0.0.1. Dengan asumsi <em>port</em> dari <code>Service</code> tersebut adalah <em>1234</em>,
maka <code>Service</code> tersebut akan diamati oleh semua <em>instance</em> <code>kube-proxy</code> yang ada di klaster.
Ketika sebuah <em>proxy</em> mendapati sebuah <code>Service</code> baru, <em>proxy</em> tersebut akan melakukan instalasi
serangkaian <em>rules</em> <code>iptables</code> yang akan melakukan <em>redirect</em> VIP ke <em>rules</em> tiap <code>Service</code>. <em>Rules</em>
untuk tiap <code>Service</code> ini terkait dengan <em>rules</em> tiap <code>Endpoints</code> yang mengarahkan (destinasi NAT)
ke <em>backend</em>.</p><p>Ketika sebuah klien terhubung ke VIP dan terdapat _rules _iptables
yang diterapkan. Sebuah <em>backend</em> akan dipilih (hal ini dapat dilakukan berdasarkan <em>session affinity</em>
maupun secara <em>acak</em>) dan paket-paket yang ada akan diarahkan ke <em>backend</em>. Tidak seperti mekanisme
yang terjadi di <em>userspace</em>, paket-paket yang ada tidak pernah disalin ke <em>userspace</em>, <code>kube-proxy</code>
tidak harus aktif untuk menjamin kerja VIP, serta IP klien juga tidak perlu diubah.</p><p>Tahapan yang dijalankan sama dengan tahapan yang dijalankan ketika trafik masuk melalui sebuah <em>node-port</em>
atau <em>load-balancer</em>, meskipun pada dua kasus di atas klien IP tidak akan mengalami perubahan.</p><h4 id=ipvs><em>Ipvs</em></h4><p>Operasi <code>iptables</code> berlangsung secara lambat pada klaster dengan skala besar (lebih dari 10.000 <code>Service</code>).
<em>IPVS</em> didesain untuk mekanisme <em>load balance</em> dan berbasis pada <em>hash tables</em> yang berada di dalam <em>kernel</em>.
Dengan demikian kita dapat mendapatkan performa yang konsisten pada jumlah <code>Service</code> yang cukup besar dengan
menggunakan <code>kube-proxy</code> berbasis <em>ipvs</em>. Sementara itu, <code>kube-proxy</code> berbasis <em>ipvs</em> memiliki algoritma
<em>load balance</em> yang lebih bervariasi (misalnya saja <em>least conns</em>, <em>locality</em>, <em>weighted</em>, <em>persistence</em>).</p><h2 id=objek-api>Objek API</h2><p><em>Service</em> merupakan <em>resource</em> <em>top-level</em> pada API Kubernetes.
Penjelasan lebih lanjut mengenai objek API dapat ditemukan pada:
<a href=/docs/reference/generated/kubernetes-api/v1.25/#service-v1-core>objek API <code>Service</code></a>.</p><h2 id=protokol-yang-tersedia>Protokol yang didukung</h2><h3 id=tcp>TCP</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.0 [stable]</code></div><p>Kamu dapat menggunakan TCP untuk <code>Service</code> dengan <em>type</em> apa pun, dan protokol ini merupakan
protokol <em>default</em> yang digunakan.</p><h3 id=udp>UDP</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.0 [stable]</code></div><p>Kamu dapat menggunakan UDP untuk sebagian besar <code>Service</code>.
Untuk <code>Service</code> dengan <em>type=LoadBalancer</em>, dukungan terhadap UDP
bergantung pada penyedia layanan <em>cloud</em> yang kamu gunakan.</p><h3 id=http>HTTP</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.1 [stable]</code></div><p>Apabila penyedia layanan <em>cloud</em> yang kamu gunakan mendukung, kamu dapat menggunakan
<em>Service</em> dengan <em>type</em> <code>LoadBalancer</code> untuk melakukan mekanisme <em>reverse</em> <em>proxy</em>
bagi HTTP/HTTPS, dan melakukan <em>forwarding</em> ke <code>Endpoints</code> dari _Service.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Kamu juga dapat menggunakan <a class=glossary-tooltip title='Sebuah obyek API yang mengatur akses eksternal terhadap Service yang ada di dalam klaster, biasanya dalam bentuk request HTTP.' data-toggle=tooltip data-placement=top href=/docs/concepts/services-networking/ingress/ target=_blank aria-label=Ingress>Ingress</a> sebagai salah satu
alternatif penggunaan <code>Service</code> untuk HTTP/HTTPS.</div><h3 id=protokol-proxy>Protokol PROXY</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.1 [stable]</code></div><p>Apabila penyedia layanan <em>cloud</em> yang kamu gunakan mendukung, (misalnya saja, <a href=/id/docs/concepts/cluster-administration/cloud-providers/#aws>AWS</a>),
<em>Service</em> dengan <em>type</em> <code>LoadBalancer</code> untuk melakukan konfigurasi <em>load balancer</em>
di luar Kubernetes sendiri, serta akan melakukan <em>forwarding</em> koneksi yang memiliki prefiks
<a href=https://www.haproxy.org/download/1.8/doc/proxy-protocol.txt>protokol PROXY</a>.</p><p><em>Load balancer</em> akan melakukan serangkaian inisiasi <em>octet</em> yang memberikan
deskripsi koneksi yang datang, dengan bentuk yang menyerupai:</p><pre tabindex=0><code>PROXY TCP4 192.0.2.202 10.0.42.7 12345 7\r\n
</code></pre><p>yang kemudian diikuti data dari klien.</p><h3 id=sctp>SCTP</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.12 [alpha]</code></div><p>Kubernetes memberikan dukungan bagi SCTP sebagai <em>value</em> dari <em>definition</em> yang ada pada
<em>Service</em>, <code>Endpoints</code>, <code>NetworkPolicy</code> dan <code>Pod</code> sebagai fitur <em>alpha</em>. Untuk mengaktifkan fitur ini,
administrator klaster harus mengaktifkan <em>feature gate</em> <em>SCTPSupport</em> pada <em>apiserver</em>, contohnya
<code>“--feature-gates=SCTPSupport=true,...”</code>. Ketika <em>fature gate</em> ini diaktifkan, pengguna dapat
memberikan <em>value</em> SCTP pada <em>field</em> <em>protocol</em> <code>Service</code>, <code>Endpoints</code>, <code>NetworkPolicy</code> dan <code>Pod</code>.
Kubernetes kemudian akan melakukan pengaturan agar jaringan yang digunakan agar jaringan tersebut menggunakan SCTP,
seperti halnya Kubernetes mengatur jaringan agar menggunakan TCP.</p><h4 id=kelemahan-penggunaan-sctp>Perhatian</h4><h5 id=kelemahan-sctp-multihomed>Dukungan untuk asoasiasi <em>multihomed</em> SCTP</h5><p>Dukungan untuk asosiasi <em>multihomed</em> SCTP membutuhkan <em>plugin</em> CNI yang dapat memberikan
pengalokasian <em>multiple interface</em> serta alamat IP pada sebuah <code>Pod</code>.</p><p>NAT untuk asosiasi <em>multihomed</em> SCTP membutuhkan logika khusus pada modul kernel terkait.</p><h5 id=kelemahan-sctp-loadbalancer-service-type><code>Service</code> dengan <em>type=LoadBalancer</em></h5><p>Sebuah <code>Service</code> dengan <em>type</em> <code>LoadBalancer</code> dan protokol SCTP dapat dibuat
hanya jika implementasi <em>load balancer</em> penyedia layanan <em>cloud</em> menyediakan dukungan
bagi protokol SCTP. Apabila hal ini tidak terpenuhi, maka <em>request</em> pembuatan <em>Servixe</em> ini akan ditolak.
<em>Load balancer</em> yang disediakan oleh penyedia layanan <em>cloud</em> yang ada saat ini (<em>Azure</em>, <em>AWS</em>, <em>CloudStack</em>, <em>GCE</em>, <em>OpenStack</em>) tidak mendukung SCTP.</p><h5 id=kelemahan-sctp-windows-os>Windows</h5><p>SCTP tidak didukung pada <em>node</em> berbasis Windows.</p><h5 id=kelemahan-sctp-kube-proxy-userspace><em>Kube-proxy</em> <em>userspace</em></h5><p><em>Kube-proxy</em> tidak mendukung manajemen asosiasi SCTP ketika hal ini dilakukan pada mode
<em>userspace</em></p><h2 id=selanjutnya>Selanjutnya</h2><p>Baca <a href=/docs/tasks/access-application-cluster/connecting-frontend-backend/>Bagaimana cara menghubungkan <em>Front End</em> ke <em>Back End</em> menggunakan sebuah <code>Service</code></a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-3a38878244d862dfdb8d7adb32f77584>3.5.2 - Topologi Service (Service Topology)</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.17 [alpha]</code></div><p>Topologi Service memungkinkan Service untuk
merutekan lalu lintas jaringan berdasarkan topologi Node dalam klaster. Misalnya, suatu
layanan dapat menentukan lalu lintas jaringan yang lebih diutamakan untuk dirutekan ke
beberapa <em>endpoint</em> yang berada pada Node yang sama dengan klien, atau pada
<em>availability zone</em> yang sama.</p><h2 id=pengantar>Pengantar</h2><p>Secara bawaan lalu lintas jaringan yang dikirim ke <code>ClusterIP</code> atau <code>NodePort</code> dari Service
dapat dialihkan ke alamat <em>backend</em> untuk Service tersebut. Sejak Kubernetes 1.7
dimungkinkan untuk merutekan lalu lintas jaringan "eksternal" ke Pod yang berjalan di
Node yang menerima lalu lintas jaringan, tetapi fitur ini tidak didukung untuk <code>ClusterIP</code> dari
Service, dan topologi yang lebih kompleks — seperti rute zonasi —
belum memungkinkan. Fitur topologi Service mengatasi kekurangan ini dengan
mengizinkan pembuat layanan untuk mendefinisikan kebijakan dalam merutekan lalu lintas jaringan
berdasarkan label Node untuk Node-Node asal dan tujuan.</p><p>Dengan menggunakan label Node yang sesuai antara asal dan tujuan, operator dapat
menunjuk kelompok Node mana yang "lebih dekat" dan mana yang "lebih jauh" antara satu sama lain,
dengan menggunakan metrik apa pun yang masuk akal untuk memenuhi persyaratan
dari operator itu. Untuk sebagian besar operator di publik <em>cloud</em>, misalnya, ada
preferensi untuk menjaga layanan lalu lintas jaringan dalam zona yang sama, karena lalu lintas jaringan
antar zona memiliki biaya yang dibebankan, sementara lalu lintas jaringan
dalam zona yang sama tidak ada biaya. Kebutuhan umum lainnya termasuk kemampuan untuk merutekan
lalu lintas jaringan ke Pod lokal yang dikelola oleh sebuah DaemonSet, atau menjaga lalu lintas jaringan ke
Node yang terhubung ke <em>top-of-rack switch</em> yang sama untuk mendapatkan
latensi yang terendah.</p><h2 id=menggunakan-topologi-service>Menggunakan Topologi Service</h2><p>Jika klaster kamu mengaktifkan topologi Service kamu dapat mengontrol rute lalu lintas jaringan Service
dengan mengatur bagian <code>topologyKeys</code> pada spesifikasi Service. Bagian ini
adalah daftar urutan label-label Node yang akan digunakan untuk mengurutkan <em>endpoint</em>
saat mengakses Service ini. Lalu lintas jaringan akan diarahkan ke Node yang nilai
label pertamanya cocok dengan nilai dari Node asal untuk label yang sama. Jika
tidak ada <em>backend</em> untuk Service pada Node yang sesuai, maka label kedua akan
dipertimbangkan, dan seterusnya, sampai tidak ada label yang tersisa.</p><p>Jika tidak ditemukan kecocokan, lalu lintas jaringan akan ditolak, sama seperti jika tidak ada
sama sekali <em>backend</em> untuk Service tersebut. Artinya, <em>endpoint</em> dipilih
berdasarkan kunci topologi yang pertama yang tersedia pada <em>backend</em>. Jika dalam
bagian ini ditentukan dan semua entri tidak memiliki <em>backend</em> yang sesuai dengan
topologi klien, maka Service tidak memiliki <em>backend</em> untuk klien dan koneksi harus
digagalkan. Nilai khusus <code>"*"</code> dapat digunakan untuk mengartikan "topologi
apa saja". Nilai <em>catch-all</em> ini, jika digunakan, maka hanya sebagai
nilai terakhir dalam daftar.</p><p>Jika <code>topologyKeys</code> tidak ditentukan atau kosong, tidak ada batasan topologi
yang akan diterapkan.</p><p>Seandainya sebuah klaster dengan Node yang dilabeli dengan nama <em>host</em> ,
nama zona, dan nama wilayah mereka, maka kamu dapat mengatur nilai
<code>topologyKeys</code> dari sebuah Service untuk mengarahkan lalu lintas jaringan seperti berikut ini.</p><ul><li>Hanya ke <em>endpoint</em> dalam Node yang sama, gagal jika tidak ada <em>endpoint</em> pada Node: <code>["kubernetes.io/hostname"]</code>.</li><li>Lebih memilih ke <em>endpoint</em> dalam Node yang sama, jika tidak ditemukan maka ke <em>endpoint</em> pada zona yang sama, diikuti oleh wilayah yang sama, dan selain itu akan gagal: <code>["kubernetes.io/hostname ", "topology.kubernetes.io/zone", "topology.kubernetes.io/region"]</code>. Ini mungkin berguna, misalnya, dalam kasus di mana lokalitas data sangatlah penting.</li><li>Lebih memilih ke <em>endpoint</em> dalam zona yang sama, tetapi memilih <em>endpoint</em> mana saja yang tersedia apabila tidak ada yang tersedia dalam zona ini: <code>["topology.kubernetes.io/zone ","*"]</code>.</li></ul><h2 id=batasan>Batasan</h2><ul><li>Topologi Service tidak kompatibel dengan <code>externalTrafficPolicy=Local</code>, dan karena itu Service tidak dapat menggunakan kedua fitur ini sekaligus. Dimungkinkan untuk menggunakan kedua fitur pada klaster yang sama untuk Service yang berbeda, bukan untuk Service yang sama.</li><li>Untuk saat ini kunci topologi yang valid hanya terbatas pada <code>kubernetes.io/hostname</code>, <code>topology.kubernetes.io/zone</code>, dan <code>topology.kubernetes.io/region</code>, tetapi akan digeneralisasikan ke label Node yang lain di masa depan.</li><li>Kunci topologi harus merupakan kunci label yang valid dan paling banyak hanya 16 kunci yang dapat ditentukan.</li><li>Nilai <em>catch-all</em>, <code>"*"</code>, harus menjadi nilai terakhir pada kunci topologi, jika nilai itu digunakan.</li></ul><h2 id=contoh>Contoh</h2><p>Berikut ini adalah contoh umum penggunaan fitur topologi Service.</p><h3 id=hanya-pada-endpoint-pada-node-lokal>Hanya pada <em>endpoint</em> pada Node lokal</h3><p>Service yang hanya merutekan ke <em>endpoint</em> pada Node lokal. Jika tidak ada <em>endpoint</em> pada Node, lalu lintas jaringan akan dihentikan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>my-app<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>topologyKeys</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;kubernetes.io/hostname&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=lebih-memilih-endpoint-pada-node-lokal>Lebih memilih <em>endpoint</em> pada Node lokal</h3><p>Service yang lebih memilih <em>endpoint</em> pada Node lokal, namun akan memilih ke <em>endpoint</em>
dalam klaster jika <em>endpoint</em> pada Node lokal tidak ada:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>my-app<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>topologyKeys</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;kubernetes.io/hostname&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;*&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=hanya-untuk-endpoint-pada-zona-atau-wilayah-yang-sama>Hanya untuk <em>endpoint</em> pada zona atau wilayah yang sama</h3><p>Service yang lebih memilih <em>endpoint</em> dalam zona yang sama daripada wilayah yang sama. Jika tidak ada <em>endpoint</em> pada<br>keduanya, maka lalu lintas jaringan akan dihentikan.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>my-app<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>topologyKeys</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;topology.kubernetes.io/zone&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;topology.kubernetes.io/region&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=lebih-memilih-endpoint-pada-node-lokal-zona-yang-sama-dan-kemudian-wilayah-yang-sama>Lebih memilih <em>endpoint</em> pada Node lokal, zona yang sama, dan kemudian wilayah yang sama</h3><p>Service yang lebih memilih <em>endpoint</em> pada Node lokal, zona yang sama, dan kemudian baru wilayah yang sama,
namun jika tetap tidak ditemukan maka akan memilih <em>endpoint</em> diseluruh klaster.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>my-app<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>topologyKeys</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;kubernetes.io/hostname&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;topology.kubernetes.io/zone&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;topology.kubernetes.io/region&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;*&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=selanjutnya>Selanjutnya</h2><ul><li>Baca tentang <a href=/docs/tasks/administer-cluster/enabling-service-topology>mengaktifkan topologi Service</a></li><li>Baca <a href=/id/docs/concepts/services-networking/connect-applications-service/>menghubungkan aplikasi dengan Service</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-f51db1097575de8072afe1f5b156a70c>3.5.3 - EndpointSlice</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.17 [beta]</code></div><p>EndpointSlice menyediakan sebuah cara yang mudah untuk melacak <em>endpoint</em> jaringan dalam sebuah
klaster Kubernetes. EndpointSlice memberikan alternatif yang lebih <em>scalable</em> dan lebih dapat diperluas dibandingkan dengan Endpoints.</p><h2 id=motivasi>Motivasi</h2><p>Endpoints API telah menyediakan sebuah cara yang mudah dan sederhana untuk
melacak <em>endpoint</em> jaringan pada Kubernetes. Sayangnya, seiring dengan besarnya klaster Kubernetes
dan Service, batasan-batasan yang dimiliki API tersebut semakin terlihat.
Terutama, hal tersebut termasuk kendala-kendala mengenai proses <em>scaling</em> <em>endpoint</em> jaringan
dalam jumlah yang besar.</p><p>Karena semua <em>endpoint</em> jaringan untuk sebuah Service disimpan dalam satu sumber daya
Endpoints, sumber daya tersebut dapat menjadi cukup besar. Hal itu dapat mempengaruhi kinerja
dari komponen-komponen Kubernetes (terutama <em>master control plane</em>) dan menyebabkan
lalu lintas jaringan dan pemrosesan yang cukup besar ketika Endpoints berubah.
EndpointSlice membantu kamu menghindari masalah-masalah tersebut dan juga menyediakan platform
yang dapat diperluas untuk fitur-fitur tambahan seperti <em>topological routing</em>.</p><h2 id=sumber-daya-endpointslice>Sumber daya EndpointSlice</h2><p>Pada Kubernetes, sebuah EndpointSlice memiliki referensi-referensi terhadap sekumpulan <em>endpoint</em>
jaringan. <em>Controller</em> EndpointSlice secara otomatis membuat EndpointSlice
untuk sebuah Service Kubernetes ketika sebuah <a class=glossary-tooltip title='Allows users to filter a list of resources based on labels.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/labels/ target=_blank aria-label=selektor>selektor</a> dituliskan. EndpointSlice tersebut akan memiliki
referensi-referensi menuju Pod manapun yang cocok dengan selektor pada Service tersebut. EndpointSlice mengelompokkan
<em>endpoint</em> jaringan berdasarkan kombinasi Service dan Port yang unik.
Nama dari sebuah objek EndpointSlice haruslah berupa
<a href=/id/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>nama subdomain DNS</a> yang sah.</p><p>Sebagai contoh, berikut merupakan sampel sumber daya EndpointSlice untuk sebuah Service Kubernetes
yang bernama <code>example</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>discovery.k8s.io/v1beta1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>EndpointSlice<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example-abc<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/service-name</span>:<span style=color:#bbb> </span>example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>addressType</span>:<span style=color:#bbb> </span>IPv4<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>http<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>endpoints</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>addresses</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;10.1.2.3&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>conditions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>ready</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hostname</span>:<span style=color:#bbb> </span>pod-1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>topology</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>kubernetes.io/hostname</span>:<span style=color:#bbb> </span>node-1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>topology.kubernetes.io/zone</span>:<span style=color:#bbb> </span>us-west2-a<span style=color:#bbb>
</span></span></span></code></pre></div><p>Secara bawaan, setiap EndpointSlice yang dikelola oleh <em>controller</em> EndpointSlice tidak akan memiliki
lebih dari 100 <em>endpoint</em>. Di bawah skala tersebut, EndpointSlice akan memetakan 1:1
dengan Endpoints dan Service dan akan memiliki kinerja yang sama.</p><p>EndpointSlice dapat bertindak sebagai sumber kebenaran untuk kube-proxy sebagai acuan mengenai
bagaimana cara untuk merutekan lalu lintas jaringan internal. Ketika diaktifkan, EndpointSlice semestinya memberikan peningkatan
kinerja untuk Service yang memiliki Endpoints dalam jumlah besar.</p><h3 id=tipe-tipe-alamat>Tipe-tipe Alamat</h3><p>EndpointSlice mendukung tiga tipe alamat:</p><ul><li>IPv4</li><li>IPv6</li><li>FQDN (<em>Fully Qualified Domain Name</em>)</li></ul><h3 id=topologi>Topologi</h3><p>Setiap <em>endpoint</em> pada EndpointSlice dapat memiliki informasi topologi yang relevan.
Hal ini digunakan untuk mengindikasikan di mana <em>endpoint</em> berada, berisi informasi mengenai
Node yang bersangkutan, zona, dan wilayah. Ketika nilai-nilai tersebut tersedia,
label-label Topology berikut akan ditambahkan oleh <em>controller</em> EndpointSlice:</p><ul><li><code>kubernetes.io/hostname</code> - Nama dari Node tempat <em>endpoint</em> berada.</li><li><code>topology.kubernetes.io/zone</code> - Zona tempat <em>endpoint</em> berada.</li><li><code>topology.kubernetes.io/region</code> - Region tempat <em>endpoint</em> berada.</li></ul><p>Nilai-nilai dari label-label berikut berasal dari sumber daya yang diasosiasikan dengan tiap
<em>endpoint</em> pada sebuah <em>slice</em>. Label <em>hostname</em> merepresentasikan nilai dari kolom NodeName
pada Pod yang bersangkutan. Label zona dan wilayah merepresentasikan nilai
dari label-label dengan nama yang sama pada Node yang bersangkutan.</p><h3 id=pengelolaan>Pengelolaan</h3><p>Secara bawaan, EndpointSlice dibuat dan dikelola oleh <em>controller</em>
EndpointSlice. Ada berbagai macam kasus lain untuk EndpointSlice, seperti
implementasi <em>service mesh</em>, yang memungkinkan adanya entitas atau <em>controller</em> lain
yang dapat mengelola beberapa EndpointSlice sekaligus. Untuk memastikan beberapa entitas dapat
mengelola EndpointSlice tanpa mengganggu satu sama lain, sebuah
label <code>endpointslice.kubernetes.io/managed-by</code> digunakan untuk mengindikasikan entitas
yang mengelola sebuah EndpointSlice. <em>Controller</em> EndpointSlice akan menambahkan
<code>endpointslice-controller.k8s.io</code> sebagai nilai dari label tersebut pada seluruh
EndpointSlice yang dikelolanya. Entitas lain yang mengelola EndpointSlice juga diharuskan untuk
menambahkan nilai yang unik untuk label tersebut.</p><h3 id=kepemilikan>Kepemilikan</h3><p>Pada kebanyakan kasus, EndpointSlice akan dimiliki oleh Service yang diikutinya. Hal ini diindikasikan dengan referensi pemilik pada tiap EndpointSlice dan
juga label <code>kubernetes.io/service-name</code> yang memudahkan pencarian seluruh
EndpointSlice yang dimiliki oleh sebuah Service.</p><h2 id=controller-endpointslice><em>Controller</em> EndpointSlice</h2><p><em>Controller</em> EndpointSlice mengamati Service dan Pod untuk memastikan EndpointSlice
yang bersangkutan berada dalam kondisi terkini. <em>Controller</em> EndpointSlice akan mengelola EndpointSlice untuk
setiap Service yang memiliki selektor. Ini akan merepresentasikan IP dari Pod
yang cocok dengan selektor dari Service tersebut.</p><h3 id=ukuran-endpointslice>Ukuran EndpointSlice</h3><p>Secara bawaan, jumlah <em>endpoint</em> yang dapat dimiliki tiap EndpointSlice dibatasi sebanyak 100 <em>endpoint</em>. Kamu dapat
mengaturnya melalui opsi <code>--max-endpoints-per-slice</code> <a class=glossary-tooltip title='Komponen control plane yang menjalankan pengontrol.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-controller-manager/ target=_blank aria-label=kube-controller-manager>kube-controller-manager</a> sampai dengan
jumlah maksimum sebanyak 1000 <em>endpoint</em>.</p><h3 id=distribusi-endpointslice>Distribusi EndpointSlice</h3><p>Tiap EndpointSlice memiliki sekumpulan <em>port</em> yang berlaku untuk seluruh <em>endpoint</em> dalam sebuah sumber daya. Ketika nama <em>port</em> digunakan untuk sebuah Service, Pod mungkin mendapatkan
nomor target <em>port</em> yang berbeda-beda untuk nama <em>port</em> yang sama, sehingga membutuhkan
EndpointSlice yang berbeda. Hal ini mirip dengan logika mengenai bagaimana <em>subset</em> dikelompokkan
dengan Endpoints.</p><p><em>Controller EndpointSlice</em> akan mencoba untuk mengisi EndpointSlice sebanyak mungkin, tetapi tidak
secara aktif melakukan <em>rebalance</em> terhadap EndpointSlice tersebut. Logika dari <em>controller</em> cukup sederhana:</p><ol><li>Melakukan iterasi terhadap EndpointSlice yang sudah ada, menghapus <em>endpoint</em> yang sudah tidak lagi
dibutuhkan dan memperbarui <em>endpoint</em> yang sesuai yang mungkin telah berubah.</li><li>Melakukan iterasi terhadap EndpointSlice yang sudah dimodifikasi pada langkah pertama dan
mengisinya dengan <em>endpoint</em> baru yang dibutuhkan.</li><li>Jika masih tersisa <em>endpoint</em> baru untuk ditambahkan, mencoba untuk menambahkannya pada
<em>slice</em> yang tidak berubah sebelumnya dan/atau membuat <em>slice</em> yang baru.</li></ol><p>Terlebih penting, langkah ketiga memprioritaskan untuk membatasi pembaruan EndpointSlice terhadap
distribusi dari EndpointSlice yang benar-benar penuh. Sebagai contoh, jika ada 10
<em>endpoint</em> baru untuk ditambahkan dan ada 2 EndpointSlice yang masing-masing memiliki ruang untuk 5 <em>endpoint</em> baru,
pendekatan ini akan membuat sebuah EndpointSlice baru daripada mengisi 2
EndpointSlice yang sudah ada. Dengan kata lain, pembuatan sebuah EndpointSlice
lebih diutamakan daripada pembaruan beberapa EndpointSlice.</p><p>Dengan kube-proxy yang berjalan pada tiap Node dan mengamati EndpointSlice, setiap perubahan
pada sebuah EndpointSlice menjadi sangat mahal karena hal tersebut akan dikirimkan ke
setiap Node dalam klaster. Pendekatan ini ditujukan untuk membatasi jumlah
perubahan yang perlu dikirimkan ke setiap Node, meskipun hal tersebut berdampak pada banyaknya
EndpointSlice yang tidak penuh.</p><p>Pada praktiknya, distribusi yang kurang ideal seperti ini akan jarang ditemukan. Kebanyakan perubahan yang diproses oleh <em>controller</em> EndpointSlice akan cukup kecil untuk dapat masuk pada
EndpointSlice yang sudah ada, dan jika tidak, cepat atau lambat sebuah EndpointSlice baru
akan segera dibutuhkan. Pembaruan bertahap (<em>rolling update</em>) dari Deployment juga menyediakan sebuah proses
pengemasan ulang EndpointSlice yang natural seiring dengan digantikannya seluruh Pod dan <em>endpoint</em> yang
bersangkutan.</p><h2 id=selanjutnya>Selanjutnya</h2><ul><li><a href=/docs/tasks/administer-cluster/enabling-endpointslices>Mengaktifkan EndpointSlice</a></li><li>Baca <a href=/id/docs/concepts/services-networking/connect-applications-service/>Menghubungkan Aplikasi dengan Service</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-91cb8a4438b003df11bc1c426a81b756>3.5.4 - DNS untuk Service dan Pod</h1><p>Laman ini menyediakan ikhtisar dari dukungan DNS oleh Kubernetes.</p><h2 id=pendahuluan>Pendahuluan</h2><p>Kubernetes DNS melakukan <em>scheduling</em> DNS Pod dan Service yang ada pada klaster, serta
melakukan konfigurasi kubelet untuk memberikan informasi bagi setiap Container
untuk menggunakan DNS Service IP untuk melakukan resolusi DNS.</p><h3 id=apa-sajakah-yang-mendapatkan-nama-dns>Apa Sajakah yang Mendapatkan Nama DNS?</h3><p>Setiap Service yang didefinisikan di dalam klaster (termasuk server DNS itu sendiri)
memiliki nama DNS. Secara default, sebuah <em>list</em> pencarian DNS pada Pod klien
akan mencantumkan <em>namespace</em> Pod itu sendiri serta domain <em>default</em> klaster. Hal ini dapat diilustrasikan
dengan contoh berikut:</p><p>Asumsikan sebuah Service dengan nama <code>foo</code> pada Kubernetes dengan <em>namespace</em> <code>bar</code>.
Sebuah Pod yang dijalankan di <em>namespace</em> <code>bar</code> dapat melakukan resolusi
terhadap Service ini dengan melakukan <em>query</em> DNS
untuk <code>foo</code>. Sebuah Pod yang dijalankan pada namespace <code>quux</code> dapat melakukan
resolusi Service ini dengan melakukan <em>query</em> DNS untuk <code>foo.bar</code>.</p><p>Bagian di bawah ini akan menampilkan detail tipe rekaman serta <em>layout</em> yang didukung.
<em>Layout</em> atau nama <em>query</em> lain yang dapat digunakan dianggap sebagai detail implementasi
yang bisa saja berubah tanpa adanya pemberitahuan sebelumnya. Untuk informasi spesifikasi
terbaru kamu dapat membaca <a href=https://github.com/kubernetes/dns/blob/master/docs/specification.md>Service Discovery pada Kubernetes berbasis DNS</a>.</p><h2 id=service>Service</h2><h3 id=a-record>A record</h3><p>Service "Normal" (bukan <em>headless</em>) akan diberikan sebuah A <em>record</em> untuk sebuah nama dalam bentuk
<code>my-svc.my-namespace.svc.cluster-domain.example</code>. Inilah yang kemudian digunakan untuk melakukan
resolusi IP klaster dari Service tersebut.</p><p>Service "Headless" (tanpa IP klaster) juga memiliki sebuah A <em>record</em> DNS dengan format
<code>my-svc.my-namespace.svc.cluster-domain.example</code>. Tidak seperti halnya Service normal,
DNS ini akan melakukan resolusi pada serangkauan IP dari Pod yang dipilih oleh Service tadi.
Klien diharapkan untuk mengkonsumsi serangkaian IP ini atau cara lain yang digunakan adalah pemilihan
menggunakan penjadwalan Round-Robin dari set yang ada.</p><h3 id=srv-record>SRV <em>record</em></h3><p>SRV <em>record</em> dibuat untuk port bernama yang merupakan bagian dari Service normal maupun <a href=/id/docs/concepts/services-networking/service/#headless-services>Headless
Services</a>.
Untuk setiap port bernama, SRV <em>record</em> akan memiliki format
<code>_my-port-name._my-port-protocol.my-svc.my-namespace.svc.cluster-domain.example</code>.
Untuk sebuah Service normal, ini akan melakukan resolusi pada nomor port dan
nama domain: <code>my-svc.my-namespace.svc.cluster-domain.example</code>.
Untuk Service headless, ini akan melakukan resolusi pada serangkaian Pod yang merupakan <em>backend</em> dari Service
tersebut yang memiliki format: <code>auto-generated-name.my-svc.my-namespace.svc.cluster-domain.example</code>.</p><h2 id=pod>Pod</h2><h3 id=hostname-pod-dan-field-subdomain>Hostname Pod dan <em>Field</em> Subdomain</h3><p>Saat ini ketika sebuah Pod dibuat, <em>hostname</em>-nya adalah nilai dari <code>metadata.name</code>.</p><p>Spek Pod memiliki <em>field</em> opsional <code>hostname</code>, yang dapat digunakan untuk menspesifikasikan
<em>hostname</em> Pod. Ketika dispesifikasikan, maka nama ini akan didahulukan di atas nama Pod .
Misalnya, sebuah Pod dengan <code>hostname</code> yang diberikan nilai "<code>my-host</code>", maka <em>hostname</em> Pod tersebut akan menjadi "<code>my-host</code>".</p><p>Spek Pod juga memiliki <em>field</em> opsional <code>subdomain</code> yang dapat digunakan untuk menspesifikasikan
subdomain Pod tersebut. Misalnya saja sebuah Pod dengan <code>hostname</code> yang diberi nilai "<code>foo</code>", dan <code>subdomain</code>
yang diberi nilai "<code>bar</code>", pada <em>namespace</em> "<code>my-namespace</code>", akan memiliki <em>fully qualified
domain name</em> (FQDN) "<code>foo.bar.my-namespace.svc.cluster-domain.example</code>".</p><p>Contoh:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default-subdomain<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clusterIP</span>:<span style=color:#bbb> </span>None<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb> </span><span style=color:#080;font-style:italic># Actually, no port is needed.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>1234</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>1234</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>busybox1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostname</span>:<span style=color:#bbb> </span>busybox-1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>subdomain</span>:<span style=color:#bbb> </span>default-subdomain<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- sleep<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;3600&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>busybox2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostname</span>:<span style=color:#bbb> </span>busybox-2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>subdomain</span>:<span style=color:#bbb> </span>default-subdomain<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- sleep<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;3600&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span></code></pre></div><p>Jika terdapat sebuah Service <em>headless</em> memiliki nama yang sama dengan
subdomain dari suatu Pod pada <em>namespace</em> yang sama, server KubeDNS klaster akan mengembalikan
A <em>record</em> untuk FQDN Pod.
Sebagai contoh, misalnya terdapat sebuah Pod dengan <em>hostname</em> "<code>busybox-1</code>" dan
subdomain "<code>default-subdomain</code>", serta sebuah Service <em>headless</em> dengan nama "<code>default-subdomain</code>"<br>berada pada suatu <em>namespace</em> yang sama, maka Pod tersebut akan menerima FQDN dirinya sendiri
sebagai "<code>busybox-1.default-subdomain.my-namespace.svc.cluster-domain.example</code>". DNS mengembalikan
A <em>record</em> pada nama tersebut dan mengarahkannya pada IP Pod. Baik Pod "<code>busybox1</code>" dan
"<code>busybox2</code>" bisa saja memiliki A <em>record</em> yang berbeda.</p><p>Objek Endpoint dapat menspesifikasikan <code>hostname</code> untuk alamat <em>endpoint</em> manapun
beserta dengan alamat IP-nya.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Karena A <em>record</em> tidak dibuat untuk sebuah Pod, maka <code>hostname</code> diperlukan
agar sebuah Pod memiliki A <em>record</em>. Sebuah Pod yang tidak memiliki <code>hostname</code>
tetapi memiliki <code>subdomain</code> hanya akan membuat sebuah A <em>record</em> untuk Service <em>headless</em>
(<code>default-subdomain.my-namespace.svc.cluster-domain.example</code>), yang merujuk pada IP dari
Pod tersebut. Pod juga harus dalam status <em>ready</em> agar dapat memiliki A <em>record</em> kecuali
<em>field</em> <code>publishNotReadyAddresses=True</code> diaktifkan pada Service.</div><h3 id=kebijakan-dns-pod>Kebijakan DNS Pod</h3><p>Kebijakan DNS dapat diaktifkan untuk setiap Pod. Kubernetes saat ini mendukung
kebijakan DNS spesifik Pod (<em>pod-specific DNS policies</em>). Kebijakan ini
dispesifikasikan pada <em>field</em> <code>dnsPolicy</code> yang ada pada spek Pod.</p><ul><li>"<code>Default</code>": Pod akan mewarisi konfigurasi resolusi yang berasal dari Node
dimana Pod tersebut dijalankan.
Silakan baca <a href=/docs/tasks/administer-cluster/dns-custom-nameservers/#inheriting-dns-from-the-node>diskusi terkait</a>
untuk detailnya.</li><li>"<code>ClusterFirst</code>": <em>Query</em> DNS apa pun yang tidak sesuai dengan sufiks domain klaster yang sudah dikonfigurasi
misalnya "<code>www.kubernetes.io</code>", akan di-<em>forward</em> ke <em>nameserver</em> <em>upstream</em> yang diwarisi dari Node.
Administrator klaster bisa saja memiliki <em>stub-domain</em> atau DNS <em>usptream</em> lain yang sudah dikonfigurasi.
Silakan lihat <a href=/docs/tasks/administer-cluster/dns-custom-nameservers/#impacts-on-pods>diskusi terkait</a>
untuk detail lebih lanjut mengenai bagaimana <em>query</em> DNS melakukan hal tersebut.</li><li>"<code>ClusterFirstWithHostNet</code>": Untuk Pod yang dijalankan dengan menggunakan <code>hostNetwork</code>, kamu harus
secara eksplisit mengaktifkan kebijakan DNS-nya menjadi "<code>ClusterFirstWithHostNet</code>".</li><li>"<code>None</code>": Hal ini mengisikan sebuah Pod untuk mengabaikan konfigurasi DNS dari <em>environment</em> Kubernetes
Semua pengaturan DNS disediakan menngunakan <em>field</em> <code>dnsConfig</code> yang ada pada spek Pod.
Silakan lihat <a href=#konfigurasi-dns-pod>konfigurasi DNS Pod</a> di bawah.</li></ul><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> "Default" bukan merupakan nilai <em>default</em> kebijakan DNS.
Jika <code>dnsPolicy</code> tidak secara eksplisit dispesifikasikan, maka “ClusterFirst” akan digunakan.</div><p>Contoh di bawah ini menunjukkan sebuah Pod dengan kebijakan
DNS yang diubah menjadi "<code>ClusterFirstWithHostNet</code>" karena <em>field</em> <code>hostNetwork</code>
diubah menjadi <code>true</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- sleep<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;3600&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>IfNotPresent<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Always<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostNetwork</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>dnsPolicy</span>:<span style=color:#bbb> </span>ClusterFirstWithHostNet<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=konfigurasi-dns-pod>Konfigurasi DNS Pod</h3><p>Konfigurasi DNS Pod mengizinkan pengguna untuk memiliki
lebih banyak kontrol terhadap pengaturan DNS pada Pod.</p><p><em>Field</em> <code>dnsConfig</code> bersifat opsional dan dapat digunakan dengan
pengaturan <code>dnsPolicy</code> apa pun.
Meskipun begitu, ketika <em>field</em> <code>dnsPolicy</code> pada sebuah Pod diubah menjadi "<code>None</code>",
maka <em>field</em> <code>dnsConfig</code> harus dispesifikasikan.</p><p>Berikut merupakan properti yang dapat dispesifikasikan oleh pengguna
pada <em>field</em> <code>dnsConfig</code>:</p><ul><li><code>nameservers</code>: serangkaian alamat IP yang akan digunakan sebagai server DNS bagi Pod.
Jumlah maksimum dari IP yang dapat didaftarkan pada <em>field</em> ini adalah tiga buah IP.
Ketika sebuah <code>dnsPolicy</code> pada Pod diubah menjadi "<code>None</code>", maka list ini setidaknya
harus mengandung sebuah alamat IP, selain kasus tersebut properti ini bersifat opsional.
Server yang didaftarkan akan digabungkan di dalam <em>nameserver</em> dasar yang dihasilkan dari
kebijakan DNS yang dispesifikasikan, apabila terdapat duplikat terhadap alamat yang didaftarkan
maka alamat tersebut akan dihapus.</li><li><code>searches</code>: merupakan serangkaian domain pencarian DNS yang digunakan untuk proses <em>lookup</em> pada Pod.
Properti ini bersifat opsional. Ketika dispesifikasikan, list yang disediakan akan digabungkan dengan
nama domain pencarian dasar yang dihasilkan dari kebijakan DNS yang dipilih. Alamat yang duplikat akan dihapus.
Nilai maksimum domain pencarian yang dapat didaftarkan adalah 6 domain.</li><li><code>options</code>: merupakan sebuah list opsional yang berisikan objek dimana setiap objek
bisa saja memiliki properti <code>name</code> (yang bersifat wajib). Isi dari properti ini
akan digabungkan dengan opsi yang dihasilkan kebijakan DNS yang digunakan.
Alamat yang duplikat akan dihapus.</li></ul><p>Di bawah ini merupakan contoh sebuah Pod dengan pengaturan DNS kustom:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/service/networking/custom-dns.yaml download=service/networking/custom-dns.yaml><code>service/networking/custom-dns.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("service-networking-custom-dns-yaml")' title="Copy service/networking/custom-dns.yaml to clipboard"></img></div><div class=includecode id=service-networking-custom-dns-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dns-example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>dnsPolicy</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;None&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>dnsConfig</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>nameservers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#666>1.2.3.4</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>searches</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- ns1.svc.cluster-domain.example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- my.dns.search.suffix<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>options</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>ndots<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>edns0<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Ketika Pod diatas dibuat, maka Container <code>test</code>
memiliki isi berkas <code>/etc/resolv.conf</code> sebagai berikut:</p><pre tabindex=0><code>nameserver 1.2.3.4
search ns1.svc.cluster-domain.example my.dns.search.suffix
options ndots:2 edns0
</code></pre><p>Untuk pengaturan IPv6, <em>path</em> pencarian dan name server harus dispesifikasikan sebagai berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> -it dns-example -- cat /etc/resolv.conf
</span></span></code></pre></div><p>Keluaran yang dihasilkan akan menyerupai:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>nameserver fd00:79:30::a
</span></span><span style=display:flex><span>search default.svc.cluster-domain.example svc.cluster-domain.example cluster-domain.example
</span></span><span style=display:flex><span>options ndots:5
</span></span></code></pre></div><h3 id=keberadaan-fitur>Keberadaan Fitur (<em>Feature Availability</em>)</h3><p>Keberadaan Pod DNS Config dan DNS Policy "<code>None</code>"" diilustrasikan pada tabel di bawah ini.</p><table><thead><tr><th style=text-align:center>versi k8s</th><th style=text-align:center>Dukungan Fitur</th></tr></thead><tbody><tr><td style=text-align:center>1.14</td><td style=text-align:center>Stable</td></tr><tr><td style=text-align:center>1.10</td><td style=text-align:center>Beta (aktif secara default)</td></tr><tr><td style=text-align:center>1.9</td><td style=text-align:center>Alpha</td></tr></tbody></table><h2 id=selanjutnya>Selanjutnya</h2><p>Untuk petunjuk lebih lanjut mengenai administrasi konfigurasi DNS, kamu dapat membaca
<a href=/docs/tasks/administer-cluster/dns-custom-nameservers/>Cara Melakukan Konfigurasi Service DNS</a></p></div><div class=td-content style=page-break-before:always><h1 id=pg-f804ac0532fcade3966ea2e3769ca031>3.5.5 - Menghubungkan aplikasi dengan Service</h1><h2 id=model-kubernetes-untuk-menghubungkan-kontainer>Model Kubernetes untuk menghubungkan kontainer</h2><p>Sekarang kamu memiliki aplikasi yang telah direplikasi, kamu dapat mengeksposnya di jaringan. Sebelum membahas pendekatan jaringan di Kubernetes, akan lebih baik jika kamu paham bagaimana jaringan bekerja di dalam <em>Docker</em>.</p><p>Secara <em>default</em>, <em>Docker</em> menggunakan jaringan <em>host</em>, jadi kontainer dapat berkomunikasi dengan kontainer lainnya jika mereka berada di dalam <em>node</em> yang sama. Agar kontainer <em>Docker</em> dapat berkomunikasi antar <em>node</em>, masing-masing kontainer tersebut harus diberikan <em>port</em> yang berbeda di alamat IP <em>node</em> tersebut, yang akan diteruskan (<em>proxied</em>) ke dalam kontainer. Artinya adalah para kontainer di dalam sebuah <em>node</em> harus berkoordinasi <em>port</em> mana yang akan digunakan atau dialokasikan secara otomatis.</p><p>Akan sulit untuk mengkoordinasikan <em>port</em> yang digunakan oleh banyak pengembang. Kubernetes mengasumsikan bahwa <em>Pod</em> dapat berkomunikasi dengan <em>Pod</em> lain, terlepas di <em>Node</em> mana <em>Pod</em> tersebut di <em>deploy</em>. Kubernetes memberikan setiap <em>Pod</em> alamat <em>ClusterIP</em> sehingga kamu tidak perlu secara explisit membuat jalur antara <em>Pod</em> ataupun memetakan <em>port</em> kontainer ke dalam <em>port</em> di dalam <em>Node</em> tersebut. Ini berarti kontainer di dalam sebuah <em>Pod</em> dapat berkomunikasi dengan <em>localhost</em> via <em>port</em>, dan setiap <em>Pod</em> di dalam klaster dapat berkomunikasi tanpa <em>NAT</em>. Panduan ini akan membahas bagaimana kamu dapat menjalankan sebuah layanan atau aplikasi di dalam model jaringan di atas.</p><p>Panduan ini menggunakan server <em>nginx</em> sederhana untuk mendemonstrasikan konsepnya. Konsep yang sama juga ditulis lebih lengkap di <a href=https://kubernetes.io/blog/2015/07/strong-simple-ssl-for-kubernetes>Aplikasi Jenkins CI</a>.</p><h2 id=mengekspos-pod-ke-dalam-klaster>Mengekspos Pod ke dalam klaster</h2><p>Kita melakukan ini di beberapa contoh sebelumnya, tetapi mari kita lakukan sekali lagi dan berfokus pada prespektif jaringannya. Buat sebuah <em>nginx Pod</em>, dan perhatikan bahwa templat tersebut mempunyai spesifikasi <em>port</em> kontainer:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/service/networking/run-my-nginx.yaml download=service/networking/run-my-nginx.yaml><code>service/networking/run-my-nginx.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("service-networking-run-my-nginx-yaml")' title="Copy service/networking/run-my-nginx.yaml to clipboard"></img></div><div class=includecode id=service-networking-run-my-nginx-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Ini membuat aplikasi tersebut dapat diakses dari <em>node</em> manapun di dalam klaster kamu. Cek lokasi <em>node</em> dimana <em>Pod</em> tersebut berjalan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f ./run-my-nginx.yaml
</span></span><span style=display:flex><span>kubectl get pods -l <span style=color:#b8860b>run</span><span style=color:#666>=</span>my-nginx -o wide
</span></span></code></pre></div><pre tabindex=0><code>NAME                        READY     STATUS    RESTARTS   AGE       IP            NODE
my-nginx-3800858182-jr4a2   1/1       Running   0          13s       10.244.3.4    kubernetes-minion-905m
my-nginx-3800858182-kna2y   1/1       Running   0          13s       10.244.2.5    kubernetes-minion-ljyd
</code></pre><p>Cek IP dari <em>Pod</em> kamu:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l <span style=color:#b8860b>run</span><span style=color:#666>=</span>my-nginx -o yaml | grep podIP
</span></span><span style=display:flex><span>    podIP: 10.244.3.4
</span></span><span style=display:flex><span>    podIP: 10.244.2.5
</span></span></code></pre></div><p>Kamu dapat melakukan akses dengan <em>ssh</em> ke dalam <em>node</em> di dalam klaster dan mengakses IP <em>Pod</em> tersebut menggunakan <em>curl</em>. Perlu dicatat bahwa kontainer tersebut tidak menggunakan <em>port</em> 80 di dalam <em>node</em>, atau aturan <em>NAT</em> khusus untuk merutekan trafik ke dalam <em>Pod</em>. Ini berarti kamu dapat menjalankan banyak <em>nginx Pod</em> di <em>node</em> yang sama dimana setiap <em>Pod</em> dapat menggunakan <em>containerPort</em> yang sama, kamu dapat mengakses semua itu dari <em>Pod</em> lain ataupun dari <em>node</em> di dalam klaster menggunakan IP. Seperti <em>Docker</em>, <em>port</em> masih dapat di publikasi ke dalam * interface node*, tetapi kebutuhan seperti ini sudah berkurang karena model jaringannya.</p><p>Kamu dapat membaca lebih detail <a href=/id/docs/concepts/cluster-administration/networking/#how-to-achieve-this>bagaimana kita melakukan ini</a> jika kamu penasaran.</p><h2 id=membuat-service>Membuat Service</h2><p>Kita mempunyai <em>Pod</em> yang menjalankan <em>nginx</em> di dalam klaster. Teorinya, kamu dapat berkomunikasi ke <em>Pod</em> tersebut secara langsung, tapi apa yang terjadi jika sebuah <em>node</em> mati? <em>Pod</em> di dalam <em>node</em> tersebut ikut mati, dan <em>Deployment</em> akan membuat <em>Pod</em> baru, dengan IP yang berbeda. Ini adalah masalah yang <em>Service</em> selesaikan.</p><p><em>Service</em> Kubernetes adalah sebuah abstraksi yang mendefinisikan sekumpulan <em>Pod</em> yang menyediakan fungsi yang sama dan berjalan di dalam klaster. Saat dibuat, setiap <em>Service</em> diberikan sebuah alamat IP (disebut juga <em>ClusterIP</em>). Alamat ini akan terus ada, dan tidak akan pernah berubah selama <em>Service</em> hidup. <em>Pod</em> dapat berkomunikasi dengan <em>Service</em> dan trafik yang menuju <em>Service</em> tersebut akan otomatis dilakukan mekanisme <em>load balancing</em> ke <em>Pod</em> yang merupakan anggota dari <em>Service</em> tersebut.</p><p>Kamu dapat membuat <em>Service</em> untuk replika 2 <em>nginx</em> dengan <code>kubectl explose</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl expose deployment/my-nginx
</span></span></code></pre></div><pre tabindex=0><code>service/my-nginx exposed
</code></pre><p>Perintah di atas sama dengan <code>kubectl apply -f</code> dengan <em>yaml</em> sebagai berikut:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/service/networking/nginx-svc.yaml download=service/networking/nginx-svc.yaml><code>service/networking/nginx-svc.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("service-networking-nginx-svc-yaml")' title="Copy service/networking/nginx-svc.yaml to clipboard"></img></div><div class=includecode id=service-networking-nginx-svc-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Spesifikasi ini akan membuat <em>Service</em> yang membuka <em>TCP port 80</em> di setiap <em>Pod</em> dengan label <code>run: my-nginx</code> dan mengeksposnya ke dalam <em>port Service</em> (<code>targetPort</code>: adalah port kontainer yang menerima trafik, <code>port</code> adalah <em>service port</em> yang dapat berupa <em>port</em> apapun yang digunakan <em>Pod</em> lain untuk mengakses <em>Service</em>).</p><p>Lihat <a href=/docs/reference/generated/kubernetes-api/v1.25/#service-v1-core>Service</a>
objek <em>API</em> untuk melihat daftar <em>field</em> apa saja yang didukung di definisi <em>Service</em>. Cek <em>Service</em> kamu:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get svc my-nginx
</span></span></code></pre></div><pre tabindex=0><code>NAME       TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)   AGE
my-nginx   ClusterIP   10.0.162.149   &lt;none&gt;        80/TCP    21s
</code></pre><p>Seperti yang disebutkan sebelumnya, sebuah <em>Service</em> berisi sekumpulan <em>Pod</em>. <em>Pod</em> diekspos melalui <code>endpoints</code>. <em>Service selector</em> akan mengecek <em>Pod</em> secara terus-menerus dan hasilnya akan dikirim (<em>POSTed</em>) ke objek <em>endpoint</em> yang bernama <code>my-nginx</code>. Saat sebuah <em>Pod</em> mati, <em>IP Pod</em> di dalam <em>endpoint</em> tersebut akan otomatis dihapus, dan <em>Pod</em> baru yang sesuai dengan <em>Service selector</em> akan otomatis ditambahkan ke dalam <em>endpoint</em>. Cek <em>endpoint</em> dan perhatikan bahwa IP sama dengan <em>Pod</em> yang dibuat di langkah pertama:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe svc my-nginx
</span></span></code></pre></div><pre tabindex=0><code>Name:                my-nginx
Namespace:           default
Labels:              run=my-nginx
Annotations:         &lt;none&gt;
Selector:            run=my-nginx
Type:                ClusterIP
IP:                  10.0.162.149
Port:                &lt;unset&gt; 80/TCP
Endpoints:           10.244.2.5:80,10.244.3.4:80
Session Affinity:    None
Events:              &lt;none&gt;
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get ep my-nginx
</span></span></code></pre></div><pre tabindex=0><code>NAME       ENDPOINTS                     AGE
my-nginx   10.244.2.5:80,10.244.3.4:80   1m
</code></pre><p>Kamu sekarang dapat melakukan <em>curl</em> ke dalam <em>nginx Service</em> di <code>&lt;CLUSTER-IP>:&lt;PORT></code> dari <em>node</em> manapun di klaster. Perlu dicatat bahwa <em>Service IP</em> adalah IP virtual, IP tersebut tidak pernah ada di <em>interface node</em> manapun. Jika kamu penasaran bagaimana konsep ini bekerja, kamu dapat membaca lebih lanjut tentang <a href=/id/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies>service proxy</a>.</p><h2 id=mengakses-service>Mengakses Service</h2><p>Kubernetes mendukung 2 mode utama untuk menemukan sebuah <em>Service</em> - variabel <em>environment</em> dan <em>DNS</em>.
<em>DNS</em> membutuhkan <a href=http://releases.k8s.io/main/cluster/addons/dns/coredns>tambahan CoreDNS di dalam klaster</a>.</p><h3 id=variabel-environment>Variabel Environment</h3><p>Saat sebuah <em>Pod</em> berjalan di <em>Node</em>, <em>kubelet</em> akan menambahkan variabel <em>environment</em> untuk setiap <em>Service</em> yang aktif ke dalam <em>Pod</em>. Ini menimbulkan beberapa masalah. Untuk melihatnya, periksa <em>environment</em> dari <em>Pod nginx</em> yang telah kamu buat (nama <em>Pod</em>-mu akan berbeda-beda):</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> my-nginx-3800858182-jr4a2 -- printenv | grep SERVICE
</span></span></code></pre></div><pre tabindex=0><code>KUBERNETES_SERVICE_HOST=10.0.0.1
KUBERNETES_SERVICE_PORT=443
KUBERNETES_SERVICE_PORT_HTTPS=443
</code></pre><p>Perlu dicatat tidak ada variabel <em>environment</em> yang menunjukan <em>Service</em> yang kamu buat. Ini terjadi karena kamu membuat replika terlebih dahulu sebelum membuat <em>Service</em>. Kerugian lain ditimbulkan adalah bahwa komponen <em>scheduler</em> mungkin saja bisa menempatkan semua <em>Pod</em> di dalam satu <em>Node</em>, yang akan membuat keseluruhan <em>Service</em> mati jika <em>Node</em> tersebut mati. Kita dapat menyelesaikan masalah ini dengan menghapus 2 <em>Pod</em> tersebut dan menunggu <em>Deployment</em> untuk membuat <em>Pod</em> kembali. Kali ini <em>Service</em> ada sebelum replika <em>Pod</em> tersebut ada. Ini akan memberikan kamu <em>scheduler-level Service</em> (jika semua <em>Node</em> kamu mempunyai kapasitas yang sama), serta variabel <em>environment</em> yang benar:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl scale deployment my-nginx --replicas<span style=color:#666>=</span>0; kubectl scale deployment my-nginx --replicas<span style=color:#666>=</span>2;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl get pods -l <span style=color:#b8860b>run</span><span style=color:#666>=</span>my-nginx -o wide
</span></span></code></pre></div><pre tabindex=0><code>NAME                        READY     STATUS    RESTARTS   AGE     IP            NODE
my-nginx-3800858182-e9ihh   1/1       Running   0          5s      10.244.2.7    kubernetes-minion-ljyd
my-nginx-3800858182-j4rm4   1/1       Running   0          5s      10.244.3.8    kubernetes-minion-905m
</code></pre><p>Kamu mungkin saja melihat <em>Pod</em> dengan nama yang berbeda, hal ini terjadi karena <em>Pod-Pod</em> itu dihapus dan dibuat ulang.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> my-nginx-3800858182-e9ihh -- printenv | grep SERVICE
</span></span></code></pre></div><pre tabindex=0><code>KUBERNETES_SERVICE_PORT=443
MY_NGINX_SERVICE_HOST=10.0.162.149
KUBERNETES_SERVICE_HOST=10.0.0.1
MY_NGINX_SERVICE_PORT=80
KUBERNETES_SERVICE_PORT_HTTPS=443
</code></pre><h3 id=dns>DNS</h3><p>Kubernetes menawarkan sebuah layanan <em>DNS</em> klaster tambahan yang secara otomatis memberikan sebuah nama <em>dns</em> pada <em>Service</em>. Kamu dapat mengecek jika <em>DNS</em> berjalan di dalam klaster Kubernetes:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get services kube-dns --namespace<span style=color:#666>=</span>kube-system
</span></span></code></pre></div><pre tabindex=0><code>NAME       TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)         AGE
kube-dns   ClusterIP   10.0.0.10    &lt;none&gt;        53/UDP,53/TCP   8m
</code></pre><p>Jika <em>DNS</em> belum berjalan, kamu dapat <a href=http://releases.k8s.io/main/cluster/addons/dns/kube-dns/README.md#how-do-i-configure-it>mengaktifkannya</a>.</p><p>Sisa panduan ini mengasumsikan kamu mempunyai <em>Service</em> dengan IP (my-nginx), dan sebuah server <em>DNS</em> yang memberikan nama ke dalam IP tersebut (CoreDNS klaster), jadi kamu dapat berkomunikasi dengan <em>Service</em> dari <em>Pod</em> lain di dalam klaster menggunakan metode standar (contohnya <em>gethostbyname</em>). Jalankan aplikasi <em>curl</em> lain untuk melakukan pengujian ini:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl run curl --image<span style=color:#666>=</span>radial/busyboxplus:curl -i --tty
</span></span></code></pre></div><pre tabindex=0><code>Waiting for pod default/curl-131556218-9fnch to be running, status is Pending, pod ready: false
Hit enter for command prompt
</code></pre><p>Lalu tekan <em>enter</em> dan jalankan <code>nslookup my-nginx</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#666>[</span> root@curl-131556218-9fnch:/ <span style=color:#666>]</span>$ nslookup my-nginx
</span></span><span style=display:flex><span>Server:    10.0.0.10
</span></span><span style=display:flex><span>Address 1: 10.0.0.10
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Name:      my-nginx
</span></span><span style=display:flex><span>Address 1: 10.0.162.149
</span></span></code></pre></div><h2 id=mengamankan-service>Mengamankan Service</h2><p>Hingga sekarang kita hanya mengakses <em>nginx</em> server dari dalam klaster. Sebelum mengekspos <em>Service</em> ke internet, kamu harus memastikan bahwa kanal komunikasi aman. Untuk melakukan hal tersebut, kamu membutuhkan:</p><ul><li><em>Self signed certificates</em> untuk <em>https</em> (kecuali jika kamu sudah mempunyai <em>identity certificate</em>)</li><li>Sebuah server <em>nginx</em> yang terkonfigurasi untuk menggunakan <em>certificate</em> tersebut</li><li>Sebuah <a href=/id/docs/concepts/configuration/secret/>secret</a> yang membuat setifikat tersebut dapat diakses oleh <em>pod</em></li></ul><p>Kamu dapat melihat semua itu di <a href=https://github.com/kubernetes/examples/tree/main/staging/https-nginx/>contoh nginx https</a>. Contoh ini mengaharuskan kamu melakukan instalasi <em>go</em> dan <em>make</em>. Jika kamu tidak ingin melakukan instalasi tersebut, ikuti langkah-langkah manualnya nanti, singkatnya:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>make keys <span style=color:#b8860b>KEY</span><span style=color:#666>=</span>/tmp/nginx.key <span style=color:#b8860b>CERT</span><span style=color:#666>=</span>/tmp/nginx.crt
</span></span><span style=display:flex><span>kubectl create secret tls nginxsecret --key /tmp/nginx.key --cert /tmp/nginx.crt
</span></span></code></pre></div><pre tabindex=0><code>secret/nginxsecret created
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get secrets
</span></span></code></pre></div><pre tabindex=0><code>NAME                  TYPE                                  DATA      AGE
default-token-il9rc   kubernetes.io/service-account-token   1         1d
nginxsecret           Opaque                                2         1m
</code></pre><p>Berikut ini adalah langkah-langkah manual yang harus diikuti jika kamu mengalami masalah menjalankan <em>make</em> (pada windows contohnya):</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic>#membuat sebuah key-pair public private</span>
</span></span><span style=display:flex><span>openssl req -x509 -nodes -days <span style=color:#666>365</span> -newkey rsa:2048 -keyout /d/tmp/nginx.key -out /d/tmp/nginx.crt -subj <span style=color:#b44>&#34;/CN=my-nginx/O=my-nginx&#34;</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic>#rubah key tersebut ke dalam pengkodean base64</span>
</span></span><span style=display:flex><span>cat /d/tmp/nginx.crt | base64
</span></span><span style=display:flex><span>cat /d/tmp/nginx.key | base64
</span></span></code></pre></div><p>Gunakan hasil keluaran dari perintah sebelumnya untuk membuat sebuah file <em>yaml</em> seperti berikut. Nilai yang dikodekan <em>base64</em> harus berada di dalam satu baris.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;v1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Secret&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;nginxsecret&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;default&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nginx.crt</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURIekNDQWdlZ0F3SUJBZ0lKQUp5M3lQK0pzMlpJTUEwR0NTcUdTSWIzRFFFQkJRVUFNQ1l4RVRBUEJnTlYKQkFNVENHNW5hVzU0YzNaak1SRXdEd1lEVlFRS0V3aHVaMmx1ZUhOMll6QWVGdzB4TnpFd01qWXdOekEzTVRKYQpGdzB4T0RFd01qWXdOekEzTVRKYU1DWXhFVEFQQmdOVkJBTVRDRzVuYVc1NGMzWmpNUkV3RHdZRFZRUUtFd2h1CloybHVlSE4yWXpDQ0FTSXdEUVlKS29aSWh2Y05BUUVCQlFBRGdnRVBBRENDQVFvQ2dnRUJBSjFxSU1SOVdWM0IKMlZIQlRMRmtobDRONXljMEJxYUhIQktMSnJMcy8vdzZhU3hRS29GbHlJSU94NGUrMlN5ajBFcndCLzlYTnBwbQppeW1CL3JkRldkOXg5UWhBQUxCZkVaTmNiV3NsTVFVcnhBZW50VWt1dk1vLzgvMHRpbGhjc3paenJEYVJ4NEo5Ci82UVRtVVI3a0ZTWUpOWTVQZkR3cGc3dlVvaDZmZ1Voam92VG42eHNVR0M2QURVODBpNXFlZWhNeVI1N2lmU2YKNHZpaXdIY3hnL3lZR1JBRS9mRTRqakxCdmdONjc2SU90S01rZXV3R0ljNDFhd05tNnNTSzRqYUNGeGpYSnZaZQp2by9kTlEybHhHWCtKT2l3SEhXbXNhdGp4WTRaNVk3R1ZoK0QrWnYvcW1mMFgvbVY0Rmo1NzV3ajFMWVBocWtsCmdhSXZYRyt4U1FVQ0F3RUFBYU5RTUU0d0hRWURWUjBPQkJZRUZPNG9OWkI3YXc1OUlsYkROMzhIYkduYnhFVjcKTUI4R0ExVWRJd1FZTUJhQUZPNG9OWkI3YXc1OUlsYkROMzhIYkduYnhFVjdNQXdHQTFVZEV3UUZNQU1CQWY4dwpEUVlKS29aSWh2Y05BUUVGQlFBRGdnRUJBRVhTMW9FU0lFaXdyMDhWcVA0K2NwTHI3TW5FMTducDBvMm14alFvCjRGb0RvRjdRZnZqeE04Tzd2TjB0clcxb2pGSW0vWDE4ZnZaL3k4ZzVaWG40Vm8zc3hKVmRBcStNZC9jTStzUGEKNmJjTkNUekZqeFpUV0UrKzE5NS9zb2dmOUZ3VDVDK3U2Q3B5N0M3MTZvUXRUakViV05VdEt4cXI0Nk1OZWNCMApwRFhWZmdWQTRadkR4NFo3S2RiZDY5eXM3OVFHYmg5ZW1PZ05NZFlsSUswSGt0ejF5WU4vbVpmK3FqTkJqbWZjCkNnMnlwbGQ0Wi8rUUNQZjl3SkoybFIrY2FnT0R4elBWcGxNSEcybzgvTHFDdnh6elZPUDUxeXdLZEtxaUMwSVEKQ0I5T2wwWW5scE9UNEh1b2hSUzBPOStlMm9KdFZsNUIyczRpbDlhZ3RTVXFxUlU9Ci0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0K&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nginx.key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;LS0tLS1CRUdJTiBQUklWQVRFIEtFWS0tLS0tCk1JSUV2UUlCQURBTkJna3Foa2lHOXcwQkFRRUZBQVNDQktjd2dnU2pBZ0VBQW9JQkFRQ2RhaURFZlZsZHdkbFIKd1V5eFpJWmVEZWNuTkFhbWh4d1NpeWF5N1AvOE9ta3NVQ3FCWmNpQ0RzZUh2dGtzbzlCSzhBZi9WemFhWm9zcApnZjYzUlZuZmNmVUlRQUN3WHhHVFhHMXJKVEVGSzhRSHA3VkpMcnpLUC9QOUxZcFlYTE0yYzZ3MmtjZUNmZitrCkU1bEVlNUJVbUNUV09UM3c4S1lPNzFLSWVuNEZJWTZMMDUrc2JGQmd1Z0ExUE5JdWFubm9UTWtlZTRuMG4rTDQKb3NCM01ZUDhtQmtRQlAzeE9JNHl3YjREZXUraURyU2pKSHJzQmlIT05Xc0RadXJFaXVJMmdoY1kxeWIyWHI2UAozVFVOcGNSbC9pVG9zQngxcHJHclk4V09HZVdPeGxZZmcvbWIvNnBuOUYvNWxlQlkrZStjSTlTMkQ0YXBKWUdpCkwxeHZzVWtGQWdNQkFBRUNnZ0VBZFhCK0xkbk8ySElOTGo5bWRsb25IUGlHWWVzZ294RGQwci9hQ1Zkank4dlEKTjIwL3FQWkUxek1yall6Ry9kVGhTMmMwc0QxaTBXSjdwR1lGb0xtdXlWTjltY0FXUTM5SjM0VHZaU2FFSWZWNgo5TE1jUHhNTmFsNjRLMFRVbUFQZytGam9QSFlhUUxLOERLOUtnNXNrSE5pOWNzMlY5ckd6VWlVZWtBL0RBUlBTClI3L2ZjUFBacDRuRWVBZmI3WTk1R1llb1p5V21SU3VKdlNyblBESGtUdW1vVlVWdkxMRHRzaG9reUxiTWVtN3oKMmJzVmpwSW1GTHJqbGtmQXlpNHg0WjJrV3YyMFRrdWtsZU1jaVlMbjk4QWxiRi9DSmRLM3QraTRoMTVlR2ZQegpoTnh3bk9QdlVTaDR2Q0o3c2Q5TmtEUGJvS2JneVVHOXBYamZhRGR2UVFLQmdRRFFLM01nUkhkQ1pKNVFqZWFKClFGdXF4cHdnNzhZTjQyL1NwenlUYmtGcVFoQWtyczJxWGx1MDZBRzhrZzIzQkswaHkzaE9zSGgxcXRVK3NHZVAKOWRERHBsUWV0ODZsY2FlR3hoc0V0L1R6cEdtNGFKSm5oNzVVaTVGZk9QTDhPTm1FZ3MxMVRhUldhNzZxelRyMgphRlpjQ2pWV1g0YnRSTHVwSkgrMjZnY0FhUUtCZ1FEQmxVSUUzTnNVOFBBZEYvL25sQVB5VWs1T3lDdWc3dmVyClUycXlrdXFzYnBkSi9hODViT1JhM05IVmpVM25uRGpHVHBWaE9JeXg5TEFrc2RwZEFjVmxvcG9HODhXYk9lMTAKMUdqbnkySmdDK3JVWUZiRGtpUGx1K09IYnRnOXFYcGJMSHBzUVpsMGhucDBYSFNYVm9CMUliQndnMGEyOFVadApCbFBtWmc2d1BRS0JnRHVIUVV2SDZHYTNDVUsxNFdmOFhIcFFnMU16M2VvWTBPQm5iSDRvZUZKZmcraEppSXlnCm9RN3hqWldVR3BIc3AyblRtcHErQWlSNzdyRVhsdlhtOElVU2FsbkNiRGlKY01Pc29RdFBZNS9NczJMRm5LQTQKaENmL0pWb2FtZm1nZEN0ZGtFMXNINE9MR2lJVHdEbTRpb0dWZGIwMllnbzFyb2htNUpLMUI3MkpBb0dBUW01UQpHNDhXOTVhL0w1eSt5dCsyZ3YvUHM2VnBvMjZlTzRNQ3lJazJVem9ZWE9IYnNkODJkaC8xT2sybGdHZlI2K3VuCnc1YytZUXRSTHlhQmd3MUtpbGhFZDBKTWU3cGpUSVpnQWJ0LzVPbnlDak9OVXN2aDJjS2lrQ1Z2dTZsZlBjNkQKckliT2ZIaHhxV0RZK2Q1TGN1YSt2NzJ0RkxhenJsSlBsRzlOZHhrQ2dZRUF5elIzT3UyMDNRVVV6bUlCRkwzZAp4Wm5XZ0JLSEo3TnNxcGFWb2RjL0d5aGVycjFDZzE2MmJaSjJDV2RsZkI0VEdtUjZZdmxTZEFOOFRwUWhFbUtKCnFBLzVzdHdxNWd0WGVLOVJmMWxXK29xNThRNTBxMmk1NVdUTThoSDZhTjlaMTltZ0FGdE5VdGNqQUx2dFYxdEYKWSs4WFJkSHJaRnBIWll2NWkwVW1VbGc9Ci0tLS0tRU5EIFBSSVZBVEUgS0VZLS0tLS0K&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Sekarang buat <em>secrets</em> menggunakan file tersebut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f nginxsecrets.yaml
</span></span><span style=display:flex><span>kubectl get secrets
</span></span></code></pre></div><pre tabindex=0><code>NAME                  TYPE                                  DATA      AGE
default-token-il9rc   kubernetes.io/service-account-token   1         1d
nginxsecret           Opaque                                2         1m
</code></pre><p>Sekarang modifikasi replika <em>nginx</em> untuk menjalankan server <em>https</em> menggunakan <em>certificate</em> di dalam <em>secret</em> dan <em>Service</em> untuk mengekspos semua <em>port</em> (80 dan 443):</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/service/networking/nginx-secure-app.yaml download=service/networking/nginx-secure-app.yaml><code>service/networking/nginx-secure-app.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("service-networking-nginx-secure-app-yaml")' title="Copy service/networking/nginx-secure-app.yaml to clipboard"></img></div><div class=includecode id=service-networking-nginx-secure-app-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>NodePort<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>http<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>443</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>https<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>nginxsecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginxhttps<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>bprashanth/nginxhttps:1.0<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>443</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/nginx/ssl<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Berikut catatan penting tentang manifes <em>nginx-secure-app</em>:</p><ul><li>di dalam file tersebut, ada spesifikasi <em>Deployment</em> dan <em>Service</em></li><li>ada <a href=https://github.com/kubernetes/examples/tree/main/staging/https-nginx/default.conf>server nginx</a> yang melayani trafik <em>HTTP</em> di <em>port</em> 80 dan trafik <em>HTTPS</em> di <em>port</em> 443, dan <em>Service nginx</em> yang mengekspos kedua <em>port</em> tersebut.</li><li>Setiap kontainer mempunyai akses ke <em>key</em> melalui <em>volume</em> yang di <em>mount</em> pada <code>/etc/nginx/ssl</code>. Ini adalah konfigurasi sebelum server <em>nginx</em> dijalankan.</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete deployments,svc my-nginx; kubectl create -f ./nginx-secure-app.yaml
</span></span></code></pre></div><p>Pada tahapan ini, kamu dapat berkomunikasi dengan server <em>nginx</em> dari <em>node</em> manapun.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l <span style=color:#b8860b>run</span><span style=color:#666>=</span>my-nginx -o custom-columns<span style=color:#666>=</span>POD_IP:.status.podIPs
</span></span><span style=display:flex><span>    POD_IP
</span></span><span style=display:flex><span>    <span style=color:#666>[</span>map<span style=color:#666>[</span>ip:10.244.3.5<span style=color:#666>]]</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>node $ curl -k https://10.244.3.5
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;
</span></span></code></pre></div><p>Perlu dicatat bahwa kita menggunakan parameter <code>-k</code> saat menggunakan <em>curl</em>, ini karena kita tidak tau apapun tentang <em>Pod</em> yang menjalankan <em>nginx</em> saat pembuatan seritifikat, jadi kita harus memberitahu <em>curl</em> untuk mengabaikan ketidakcocokan <em>CName</em>. Dengan membuat <em>Service</em>, kita menghubungkan <em>CName</em> yang digunakan pada <em>certificate</em> dengan nama pada <em>DNS</em> yang digunakan <em>Pod</em>. Lakukan pengujian dari sebuah <em>Pod</em> (<em>secret</em> yang sama digunakan untuk agar mudah, <em>Pod</em> tersebut hanya membutuhkan <em>nginx.crt</em> untuk mengakses <em>Service</em>)</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/service/networking/curlpod.yaml download=service/networking/curlpod.yaml><code>service/networking/curlpod.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("service-networking-curlpod-yaml")' title="Copy service/networking/curlpod.yaml to clipboard"></img></div><div class=includecode id=service-networking-curlpod-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>curl-deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>curlpod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>curlpod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>nginxsecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>curlpod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- sh<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- -c<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- while true; do sleep 1; done<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>radial/busyboxplus:curl<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/nginx/ssl<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f ./curlpod.yaml
</span></span><span style=display:flex><span>kubectl get pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>curlpod
</span></span></code></pre></div><pre tabindex=0><code>NAME                               READY     STATUS    RESTARTS   AGE
curl-deployment-1515033274-1410r   1/1       Running   0          1m
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> curl-deployment-1515033274-1410r -- curl https://my-nginx --cacert /etc/nginx/ssl/nginx.crt
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>&lt;title&gt;Welcome to nginx!&lt;/title&gt;
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><h2 id=mengekspos-service>Mengekspos Service</h2><p>Kamu mungkin ingin mengekspos <em>Service</em> ke alamat IP eksternal. Kubernetes mendukung dua cara untuk melakukan ini: <em>NodePort</em> dan <em>LoadBalancer</em>. <em>Service</em> yang dibuat tadi sudah menggunakan <code>NodePort</code>, jadi replika <em>nginx</em> sudah siap untuk menerima trafik dari internet jika <em>Node</em> kamu mempunyai IP publik.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get svc my-nginx -o yaml | grep nodePort -C <span style=color:#666>5</span>
</span></span><span style=display:flex><span>  uid: 07191fb3-f61a-11e5-8ae5-42010af00002
</span></span><span style=display:flex><span>spec:
</span></span><span style=display:flex><span>  clusterIP: 10.0.162.149
</span></span><span style=display:flex><span>  ports:
</span></span><span style=display:flex><span>  - name: http
</span></span><span style=display:flex><span>    nodePort: <span style=color:#666>31704</span>
</span></span><span style=display:flex><span>    port: <span style=color:#666>8080</span>
</span></span><span style=display:flex><span>    protocol: TCP
</span></span><span style=display:flex><span>    targetPort: <span style=color:#666>80</span>
</span></span><span style=display:flex><span>  - name: https
</span></span><span style=display:flex><span>    nodePort: <span style=color:#666>32453</span>
</span></span><span style=display:flex><span>    port: <span style=color:#666>443</span>
</span></span><span style=display:flex><span>    protocol: TCP
</span></span><span style=display:flex><span>    targetPort: <span style=color:#666>443</span>
</span></span><span style=display:flex><span>  selector:
</span></span><span style=display:flex><span>    run: my-nginx
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get nodes -o yaml | grep ExternalIP -C <span style=color:#666>1</span>
</span></span><span style=display:flex><span>    - address: 104.197.41.11
</span></span><span style=display:flex><span>      type: ExternalIP
</span></span><span style=display:flex><span>    allocatable:
</span></span><span style=display:flex><span>--
</span></span><span style=display:flex><span>    - address: 23.251.152.56
</span></span><span style=display:flex><span>      type: ExternalIP
</span></span><span style=display:flex><span>    allocatable:
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ curl https://&lt;EXTERNAL-IP&gt;:&lt;NODE-PORT&gt; -k
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;
</span></span></code></pre></div><p>Mari coba membuat ulang <em>Service</em> menggunakan <em>cloud load balancer</em>, ubah saja <code>type</code> <em>Service</em> <code>my-nginx</code> dari <code>NodePort</code> ke <code>LoadBalancer</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl edit svc my-nginx
</span></span><span style=display:flex><span>kubectl get svc my-nginx
</span></span></code></pre></div><pre tabindex=0><code>NAME       TYPE        CLUSTER-IP     EXTERNAL-IP        PORT(S)               AGE
my-nginx   ClusterIP   10.0.162.149   162.222.184.144    80/TCP,81/TCP,82/TCP  21s
</code></pre><pre tabindex=0><code>curl https://&lt;EXTERNAL-IP&gt; -k
...
&lt;title&gt;Welcome to nginx!&lt;/title&gt;
</code></pre><p>IP address pada kolom <code>EXTERNAL-IP</code> menunjukan IP yang tersedia di internet. Sedangkan kolom <code>CLUSTER-IP</code> merupakan IP yang hanya tersedia di dalam klaster kamu (<em>IP private</em>).</p><p>Perhatikan pada <em>AWS</em>, tipe <code>LoadBalancer</code> membuat sebuah <em>ELB</em>, yang menggunakan <em>hostname</em> yang panjang, bukan IP. Karena tidak semua keluar pada standar keluaran <code>kubectl get svc</code>. Jadi kamu harus menggunakan <code>kubectl describe service my-nginx</code> untuk melihatnya. Kamu akan melihat seperti ini:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe service my-nginx
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>LoadBalancer Ingress:   a320587ffd19711e5a37606cf4a74574-1142138393.us-east-1.elb.amazonaws.com
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><h2 id=selanjutnya>Selanjutnya</h2><p>Kubernetes juga mendukung <em>Federated Service</em>, yang bisa mempengaruhi banyak klaster dan penyedia layanan <em>cloud</em>, untuk meningkatkan ketersediaan, peningkatan toleransi kesalahan, dan pengembangan dari <em>Service</em> kamu. Lihat <a href=/id/docs/concepts/cluster-administration/federation-service-discovery/>Panduan Federated Service</a> untuk informasi lebih lanjut.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-199bcc92443dbc9bed44819467d7eb75>3.5.6 - Ingress</h1><p>Sebuah obyek API yang mengatur akses eksternal terhadap <em>Service</em> yang ada di dalam klaster, biasanya dalam bentuk <em>request</em> HTTP.</p><p>Ingress juga menyediakan <em>load balancing</em>, terminasi SSL, serta <em>name-based virtual hosting</em>.</p><h2 id=terminologi>Terminologi</h2><p>Untuk memudahkan, di awal akan dijelaskan beberapa terminologi yang sering dipakai:</p><ul><li>Node: Sebuah mesin fisik atau virtual yang berada di dalam klaster Kubernetes.</li><li>Klaster: Sekelompok node yang merupakan <em>resource</em> komputasi primer yang diatur oleh Kubernetes, biasanya diproteksi dari internet dengan menggunakan <em>firewall</em>.</li><li><em>Edge router</em>: Sebuah <em>router</em> mengatur <em>policy firewall</em> pada klaster kamu. <em>Router</em> ini bisa saja berupa <em>gateway</em> yang diatur oleh penyedia layanan <em>cloud</em> maupun perangkat keras.</li><li>Jaringan klaster: Seperangkat <em>links</em> baik logis maupus fisik, yang memfasilitasi komunikasi di dalam klaster berdasarkan <a href=/id/docs/concepts/cluster-administration/networking/>model jaringan Kubernetes</a>.</li><li><em>Service</em>: Sebuah <a href=/id/docs/concepts/services-networking/service/><em>Service</em></a> yang mengidentifikasi beberapa <em>Pod</em> dengan menggunakan <em>selector label</em>. Secara umum, semua <em>Service</em> diasumsikan hanya memiliki IP virtual yang hanya dapat diakses dari dalam jaringan klaster.</li></ul><h2 id=apakah-ingress-itu>Apakah <em>Ingress</em> itu?</h2><p>Ingress ditambahkan sejak Kubernetes v1.1, mengekspos rute HTTP dan HTTPS ke berbagai
<a href=/docs/concepts/services-networking/service/ target=_blank>services</a> di dalam klaster.
Mekanisme <em>routing</em> trafik dikendalikan oleh aturan-aturan yang didefinisikan pada <em>Ingress</em>.</p><pre tabindex=0><code class=language-none data-lang=none>    internet
        |
   [ Ingress ]
   --|-----|--
   [ Services ]
</code></pre><p>Sebuah <em>Ingress</em> dapat dikonfigurasi agar berbagai <em>Service</em> memiliki URL yang dapat diakses dari eksternal (luar klaster), melakukan <em>load balance</em> pada trafik, terminasi SSL, serta Virtual Host berbasis Nama.
Sebuah <a href=/id/docs/concepts/services-networking/ingress-controllers>kontroler Ingress</a> bertanggung jawab untuk menjalankan fungsi Ingress yaitu sebagai <em>loadbalancer</em>, meskipun dapat juga digunakan untuk mengatur <em>edge router</em> atau <em>frontend</em> tambahan untuk menerima trafik.</p><p>Sebuah <em>Ingress</em> tidak mengekspos sembarang <em>port</em> atau protokol. Mengekspos <em>Service</em> untuk protokol selain HTTP ke HTTPS internet biasanya dilakukan dengan menggunakan
<em>service</em> dengan tipe <a href=/id/docs/concepts/services-networking/service/#nodeport>Service.Type=NodePort</a> atau
<a href=/id/docs/concepts/services-networking/service/#loadbalancer>Service.Type=LoadBalancer</a>.</p><h2 id=prasyarat>Prasyarat</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.1 [beta]</code></div><p>Sebelum kamu mulai menggunakan <em>Ingress</em>, ada beberapa hal yang perlu kamu ketahui sebelumnya. <em>Ingress</em> merupakan <em>resource</em> dengan tipe beta.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Kamu harus terlebih dahulu memiliki <a href=/id/docs/concepts/services-networking/ingress-controllers>kontroler Ingress</a> untuk dapat memenuhi <em>Ingress</em>. Membuat sebuah <em>Ingress</em> tanpa adanya kontroler <em>Ingres</em> tidak akan berdampak apa pun.</div><p>GCE/Google Kubernetes Engine melakukan deploy kontroler <em>Ingress</em> pada <em>master</em>. Perhatikan laman berikut
<a href=https://github.com/kubernetes/ingress-gce/blob/master/BETA_LIMITATIONS.md#glbc-beta-limitations>keterbatasan versi beta</a>
kontroler ini jika kamu menggunakan GCE/GKE.</p><p>Jika kamu menggunakan <em>environment</em> selain GCE/Google Kubernetes Engine, kemungkinan besar kamu harus
<a href=https://kubernetes.github.io/ingress-nginx/deploy/>melakukan proses deploy kontroler ingress kamu sendiri</a>. Terdapat beberapa jenis
<a href=/id/docs/concepts/services-networking/ingress-controllers>kontroler Ingress</a> yang bisa kamu pilih.</p><h3 id=sebelum-kamu-memulai>Sebelum kamu memulai</h3><p>Secara ideal, semua kontroler Ingress harus memenuhi spesifikasi ini, tetapi beberapa
kontroler beroperasi sedikit berbeda satu sama lain.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Pastikan kamu sudah terlebih dahulu memahami dokumentasi kontroler Ingress yang akan kamu pakai sebelum memutuskan untuk memakai kontroler tersebut.</div><h2 id=resource-ingress><em>Resource</em> Ingress</h2><p>Berikut ini merupakan salah satu contoh konfigurasi Ingress yang minimum:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1beta1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Ingress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-ingress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>nginx.ingress.kubernetes.io/rewrite-target</span>:<span style=color:#bbb> </span>/<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/testpath<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>serviceName</span>:<span style=color:#bbb> </span>test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>servicePort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Seperti layaknya <em>resource</em> Kubernetes yang lain, sebuah Ingress membutuhkan <em>field</em> <code>apiVersion</code>, <code>kind</code>, dan <code>metadata</code>.
Untuk informasi umum soal bagaimana cara bekerja dengan menggunakan berkas konfigurasi, silahkan merujuk pada <a href=/docs/tasks/run-application/run-stateless-application-deployment/>melakukan deploy aplikasi</a>, <a href=/id/docs/tasks/configure-pod-container/configure-pod-configmap/>konfigurasi kontainer</a>, <a href=/id/docs/concepts/cluster-administration/manage-deployment/>mengatur <em>resource</em></a>.
Ingress seringkali menggunakan anotasi untuk melakukan konfigurasi beberapa opsi yang ada bergantung pada kontroler Ingress yang digunakan, sebagai contohnya
adalah <a href=https://github.com/kubernetes/ingress-nginx/blob/master/docs/examples/rewrite/README.md>anotasi rewrite-target</a>.
<a href=/id/docs/concepts/services-networking/ingress-controllers>Kontroler Ingress</a> yang berbeda memiliki jenis anotasi yang berbeda. Pastikan kamu sudah terlebih dahulu memahami dokumentasi
kontroler Ingress yang akan kamu pakai untuk mengetahui jenis anotasi apa sajakah yang disediakan.</p><p><a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status>Spesifikasi</a> Ingress
memiliki segala informasi yang dibutuhkan untuk melakukan proses konfigurasi <em>loadbalancer</em> atau server proxy. Hal yang terpenting adalah
bagian inilah yang mengandung semua <em>rules</em> yang nantinya akan digunakan untuk menyesuaikan trafik yang masuk. <em>Resource</em> Ingress hanya menyediakan
fitur <em>rules</em> untuk mengarahkan trafik dengan protokol HTTP.</p><h3 id=rule-ingress><em>Rule</em> Ingress</h3><p>Setiap <em>rule</em> HTTP mengandung informasi berikut:</p><ul><li><em>Host</em> opsional. Di dalam contoh ini, tidak ada <em>host</em> yang diberikan, dengan kata lain, semua <em>rules</em> berlaku untuk <em>inbound</em>
trafik HTTP bagi alamat IP yang dispesifikasikan. JIka sebuah <em>host</em> dispesifikasikan (misalnya saja,
foo.bar.com), maka <em>rules</em> yang ada akan berlaku bagi <em>host</em> tersebut.</li><li>Sederetan <em>path</em> (misalnya, /testpath), setiap <em>path</em> ini akan memiliki pasangan berupa sebuah <em>backend</em> yang didefinisikan dengan <code>serviceName</code>
dan <code>servicePort</code>. Baik <em>host</em> dan <em>path</em> harus sesuai dengan konten dari <em>request</em> yang masuk sebelum
<em>loadbalancer</em> akan mengarahkan trafik pada <em>service</em> yang sesuai.</li><li>Suatu <em>backend</em> adalah kombinasi <em>service</em> dan <em>port</em> seperti yang dideskripsikan di
<a href=/id/docs/concepts/services-networking/service/>dokumentasi <em>Service</em></a>. <em>Request</em> HTTP (dan HTTPS) yang sesuai dengan
<em>host</em> dan <em>path</em> yang ada pada <em>rule</em> akan diteruskan pada <em>backend</em> terkait.</li></ul><p><em>Backend default</em> seringkali dikonfigurasi pada kontroler kontroler Ingress, tugas <em>backend default</em> ini adalah
mengarahkan <em>request</em> yang tidak sesuai dengan <em>path</em> yang tersedia pada spesifikasi.</p><h3 id=backend-default><em>Backend Default</em></h3><p>Sebuah Ingress yang tidak memiliki <em>rules</em> akan mengarahkan semua trafik pada sebuah <em>backend default</em>. <em>Backend default</em> inilah yang
biasanya bisa dimasukkan sebagai salah satu opsi konfigurasi dari <a href=/id/docs/concepts/services-networking/ingress-controllers>kontroler Ingress</a> dan tidak dimasukkan dalam spesifikasi <em>resource</em> Ingress.</p><p>Jika tidak ada <em>host</em> atau <em>path</em> yang sesuai dengan <em>request</em> HTTP pada objek Ingress, maka trafik tersebut
akan diarahkan pada <em>backend default</em>.</p><h2 id=jenis-ingress>Jenis Ingress</h2><h3 id=ingress-dengan-satu-service>Ingress dengan satu Service</h3><p>Terdapat konsep Kubernetes yang memungkinkan kamu untuk mengekspos sebuah Service, lihat <a href=#alternatif-lain>alternatif lain</a>.
Kamu juga bisa membuat spesifikasi Ingress dengan <em>backend default</em> yang tidak memiliki <em>rules</em>.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/service/networking/ingress.yaml download=service/networking/ingress.yaml><code>service/networking/ingress.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("service-networking-ingress-yaml")' title="Copy service/networking/ingress.yaml to clipboard"></img></div><div class=includecode id=service-networking-ingress-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1beta1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Ingress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-ingress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>serviceName</span>:<span style=color:#bbb> </span>testsvc<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>servicePort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Jika kamu menggunakan <code>kubectl apply -f</code> kamu dapat melihat:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get ingress test-ingress
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME           HOSTS     ADDRESS           PORTS     AGE
</span></span><span style=display:flex><span>test-ingress   *         107.178.254.228   <span style=color:#666>80</span>        59s
</span></span></code></pre></div><p>Dimana <code>107.178.254.228</code> merupakan alamat IP yang dialokasikan oleh kontroler Ingress untuk
memenuhi Ingress ini.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Kontroler Ingress dan <em>load balancer</em> membutuhkan waktu sekitar satu hingga dua menit untuk mengalokasikan alamat IP.
Hingga alamat IP berhasil dialokasikan, kamu akan melihat tampilan kolom <code>ADDRESS</code> sebagai <code>&lt;pending></code>.</div><h3 id=fanout-sederhana><em>Fanout</em> sederhana</h3><p>Sebuah konfigurasi fanout akan melakukan <em>route</em> trafik dari sebuah alamat IP ke banyak Service,
berdasarkan URI HTTP yang diberikan. Sebuah Ingress memungkinkan kamu untuk memiliki jumlah <em>loadbalancer</em> minimum.
Contohnya, konfigurasi seperti di bawah ini:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>foo.bar.com -&gt; 178.91.123.132 -&gt; / foo    service1:4200
</span></span><span style=display:flex><span>                                 / bar    service2:8080
</span></span></code></pre></div><p>akan memerlukan konfigurasi Ingress seperti:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1beta1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Ingress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>simple-fanout-example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>nginx.ingress.kubernetes.io/rewrite-target</span>:<span style=color:#bbb> </span>/<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>host</span>:<span style=color:#bbb> </span>foo.bar.com<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>serviceName</span>:<span style=color:#bbb> </span>service1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>servicePort</span>:<span style=color:#bbb> </span><span style=color:#666>4200</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/bar<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>serviceName</span>:<span style=color:#bbb> </span>service2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>servicePort</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Ketika kamu membuat Ingress dengan perintah <code>kubectl apply -f</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe ingress simple-fanout-example
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>Name:             simple-fanout-example
</span></span><span style=display:flex><span>Namespace:        default
</span></span><span style=display:flex><span>Address:          178.91.123.132
</span></span><span style=display:flex><span>Default backend:  default-http-backend:80 <span style=color:#666>(</span>10.8.2.3:8080<span style=color:#666>)</span>
</span></span><span style=display:flex><span>Rules:
</span></span><span style=display:flex><span>  Host         Path  Backends
</span></span><span style=display:flex><span>  ----         ----  --------
</span></span><span style=display:flex><span>  foo.bar.com
</span></span><span style=display:flex><span>               /foo   service1:4200 <span style=color:#666>(</span>10.8.0.90:4200<span style=color:#666>)</span>
</span></span><span style=display:flex><span>               /bar   service2:8080 <span style=color:#666>(</span>10.8.0.91:8080<span style=color:#666>)</span>
</span></span><span style=display:flex><span>Annotations:
</span></span><span style=display:flex><span>  nginx.ingress.kubernetes.io/rewrite-target:  /
</span></span><span style=display:flex><span>Events:
</span></span><span style=display:flex><span>  Type     Reason  Age                From                     Message
</span></span><span style=display:flex><span>  ----     ------  ----               ----                     -------
</span></span><span style=display:flex><span>  Normal   ADD     22s                loadbalancer-controller  default/test
</span></span></code></pre></div><p>Kontroler Ingress akan menyediakan <em>loadbalancer</em> (implementasinya tergantung dari jenis Ingress yang digunakan), selama <em>service-service</em> yang didefinisikan (<code>s1</code>, <code>s2</code>) ada.
Apabila <em>Ingress</em> selesai dibuat, maka kamu dapat melihat alamat IP dari berbagai <em>loadbalancer</em>
pada kolom <code>address</code>.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Kamu mungkin saja membutuhkan konfigurasi default-http-backend <a href=/id/docs/concepts/services-networking/service/>Service</a>
bergantung pada <a href=/id/docs/concepts/services-networking/ingress-controllers>kontroler Ingress</a> yang kamu pakai.</div><h3 id=virtual-host-berbasis-nama>Virtual Host berbasis Nama</h3><p>Virtual Host berbasis Nama memungkinkan mekanisme <em>routing</em> berdasarkan trafik HTTP ke beberapa <em>host name</em> dengan alamat IP yang sama.</p><pre tabindex=0><code class=language-none data-lang=none>foo.bar.com --|                 |-&gt; foo.bar.com s1:80
              | 178.91.123.132  |
bar.foo.com --|                 |-&gt; bar.foo.com s2:80
</code></pre><p>Ingress di bawah ini memberikan perintah pada <em>loadbalancer</em> untuk melakukan mekanisme <em>routing</em> berdasarkan
<a href=https://tools.ietf.org/html/rfc7230#section-5.4>header host</a>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1beta1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Ingress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>name-virtual-host-ingress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>host</span>:<span style=color:#bbb> </span>foo.bar.com<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>serviceName</span>:<span style=color:#bbb> </span>service1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>servicePort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>host</span>:<span style=color:#bbb> </span>bar.foo.com<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>serviceName</span>:<span style=color:#bbb> </span>service2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>servicePort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Jika kamu membuat sebuah Ingress tanpa mendefinisikan <em>host</em> apa pun, maka
trafik web ke alamat IP dari kontroler Ingress tetap dapat dilakukan tanpa harus
menyesuaikan aturan <em>name based virtual host</em>. Sebagai contoh,
<em>resource</em> Ingress di bawah ini akan melakukan pemetaan trafik
dari <code>first.bar.com</code> ke <code>service1</code>, <code>second.foo.com</code> ke <code>service2</code>, dan trafik lain
ke alamat IP tanpa <em>host name</em> yang didefinisikan di dalam <em>request</em> (yang tidak memiliki <em>request header</em>) ke <code>service3</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1beta1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Ingress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>name-virtual-host-ingress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>host</span>:<span style=color:#bbb> </span>first.bar.com<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>serviceName</span>:<span style=color:#bbb> </span>service1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>servicePort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>host</span>:<span style=color:#bbb> </span>second.foo.com<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>serviceName</span>:<span style=color:#bbb> </span>service2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>servicePort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>serviceName</span>:<span style=color:#bbb> </span>service3<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>servicePort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=tls>TLS</h3><p>Kamu dapat mengamankan <em>Ingress</em> yang kamu miliki dengan memberikan spesifikasi <a href=/id/docs/concepts/configuration/secret>secret</a>
yang mengandung <em>private key</em> dan sertifikat TLS. Saat ini, Ingress hanya
memiliki fitur untuk melakukan konfigurasi <em>single TLS port</em>, yaitu 443, serta melakukan terminasi TLS.
Jika <em>section</em> TLS pada Ingress memiliki spesifikasi <em>host</em> yang berbeda,
<em>rules</em> yang ada akan dimultiplekskan pada <em>port</em> yang sama berdasarkan
<em>hostname</em> yang dispesifikasikan melalui ekstensi TLS SNI. <em>Secret</em> TLS harus memiliki
<code>key</code> bernama <code>tls.crt</code> dan <code>tls.key</code> yang mengandung <em>private key</em> dan sertifikat TLS, contohnya:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>tls.crt</span>:<span style=color:#bbb> </span>base64 encoded cert<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>tls.key</span>:<span style=color:#bbb> </span>base64 encoded key<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>testsecret-tls<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>kubernetes.io/tls<span style=color:#bbb>
</span></span></span></code></pre></div><p>Ketika kamu menambahkan <em>secret</em> pada Ingress maka kontroler Ingress akan memberikan perintah untuk
memproteksi <em>channel</em> dari klien ke <em>loadbalancer</em> menggunakan TLS.
Kamu harus memastikan <em>secret</em> TLS yang digunakan memiliki sertifikat yang mengandung
CN untuk <code>sslexample.foo.com</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1beta1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Ingress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>tls-example-ingress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>tls</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>hosts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- sslexample.foo.com<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>testsecret-tls<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>host</span>:<span style=color:#bbb> </span>sslexample.foo.com<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>serviceName</span>:<span style=color:#bbb> </span>service1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>servicePort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Terdapat perbedaan di antara beberapa fitur TLS
yang disediakan oleh berbagai kontroler Ingress. Perhatikan dokumentasi
<a href=https://git.k8s.io/ingress-nginx/README.md#https>nginx</a>,
<a href=https://git.k8s.io/ingress-gce/README.md#frontend-https>GCE</a>, atau
kontroler Ingress spesifik <em>platform</em> lainnya untuk memahami cara kerja TLS
pada <strong>environment</strong> yang kamu miliki.</div><h3 id=loadbalancing><em>Loadbalancing</em></h3><p>Sebuah kontroler Ingress sudah dibekali dengan beberapa <em>policy</em> terkait mekanisme <em>load balance</em>
yang nantinya akan diterapkan pada semua Ingress, misalnya saja algoritma <em>load balancing</em>, <em>backend
weight scheme</em>, dan lain sebagainya. Beberapa konsep <em>load balance</em> yang lebih <em>advance</em>
(misalnya saja <em>persistent sessions</em>, <em>dynamic weights</em>) belum diekspos melalui Ingress.
Meskipun begitu, kamu masih bisa menggunakan fitur ini melalui
<a href=https://github.com/kubernetes/ingress-nginx>loadbalancer service</a>.</p><p>Perlu diketahui bahwa meskipun <em>health check</em> tidak diekspos secara langsung
melalui Ingress, terdapat beberapa konsep di Kubernetes yang sejalan dengan hal ini, misalnya
<a href=/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/>readiness probes</a>
yang memungkinkan kamu untuk memperoleh hasil yang sama. Silahkan pelajari lebih lanjut dokumentasi
kontroler yang kamu pakai untuk mengetahui bagaimana implementasi <em>health checks</em> pada kontroler yang kamu pilih (<a href=https://git.k8s.io/ingress-nginx/README.md>nginx</a>,
<a href=https://git.k8s.io/ingress-gce/README.md#health-checks>GCE</a>).</p><h2 id=mengubah-ingress>Mengubah Ingress</h2><p>Untuk mengubah Ingress yang sudah ada dan menambahkan <em>host</em> baru, kamu dapat mengubahnya dengan mode <em>edit</em>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe ingress <span style=color:#a2f>test</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>Name:             <span style=color:#a2f>test</span>
</span></span><span style=display:flex><span>Namespace:        default
</span></span><span style=display:flex><span>Address:          178.91.123.132
</span></span><span style=display:flex><span>Default backend:  default-http-backend:80 <span style=color:#666>(</span>10.8.2.3:8080<span style=color:#666>)</span>
</span></span><span style=display:flex><span>Rules:
</span></span><span style=display:flex><span>  Host         Path  Backends
</span></span><span style=display:flex><span>  ----         ----  --------
</span></span><span style=display:flex><span>  foo.bar.com
</span></span><span style=display:flex><span>               /foo   s1:80 <span style=color:#666>(</span>10.8.0.90:80<span style=color:#666>)</span>
</span></span><span style=display:flex><span>Annotations:
</span></span><span style=display:flex><span>  nginx.ingress.kubernetes.io/rewrite-target:  /
</span></span><span style=display:flex><span>Events:
</span></span><span style=display:flex><span>  Type     Reason  Age                From                     Message
</span></span><span style=display:flex><span>  ----     ------  ----               ----                     -------
</span></span><span style=display:flex><span>  Normal   ADD     35s                loadbalancer-controller  default/test
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl edit ingress <span style=color:#a2f>test</span>
</span></span></code></pre></div><p>Sebuah editor akan muncul dan menampilkan konfigurasi Ingress kamu
dalam format YAML apabila kamu telah menjalankan perintah di atas.
Ubah untuk menambahkan <em>host</em>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>host</span>:<span style=color:#bbb> </span>foo.bar.com<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>serviceName</span>:<span style=color:#bbb> </span>s1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>servicePort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>host</span>:<span style=color:#bbb> </span>bar.baz.com<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>http</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>paths</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>backend</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>serviceName</span>:<span style=color:#bbb> </span>s2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>servicePort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>..<span style=color:#bbb>
</span></span></span></code></pre></div><p>Menyimpan konfigurasi dalam bentuk YAML ini akan mengubah <em>resource</em> pada API server,
yang kemudian akan memberi tahu kontroler Ingress untuk mengubah konfigurasi <em>loadbalancer</em>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe ingress <span style=color:#a2f>test</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>Name:             <span style=color:#a2f>test</span>
</span></span><span style=display:flex><span>Namespace:        default
</span></span><span style=display:flex><span>Address:          178.91.123.132
</span></span><span style=display:flex><span>Default backend:  default-http-backend:80 <span style=color:#666>(</span>10.8.2.3:8080<span style=color:#666>)</span>
</span></span><span style=display:flex><span>Rules:
</span></span><span style=display:flex><span>  Host         Path  Backends
</span></span><span style=display:flex><span>  ----         ----  --------
</span></span><span style=display:flex><span>  foo.bar.com
</span></span><span style=display:flex><span>               /foo   s1:80 <span style=color:#666>(</span>10.8.0.90:80<span style=color:#666>)</span>
</span></span><span style=display:flex><span>  bar.baz.com
</span></span><span style=display:flex><span>               /foo   s2:80 <span style=color:#666>(</span>10.8.0.91:80<span style=color:#666>)</span>
</span></span><span style=display:flex><span>Annotations:
</span></span><span style=display:flex><span>  nginx.ingress.kubernetes.io/rewrite-target:  /
</span></span><span style=display:flex><span>Events:
</span></span><span style=display:flex><span>  Type     Reason  Age                From                     Message
</span></span><span style=display:flex><span>  ----     ------  ----               ----                     -------
</span></span><span style=display:flex><span>  Normal   ADD     45s                loadbalancer-controller  default/test
</span></span></code></pre></div><p>Kamu juga dapat mengubah Ingress dengan menggunakan perintah <code>kubectl replace -f</code> pada berkas konfigurasi
Ingress yang ingin diubah.</p><h2 id=mekanisme-failing-pada-beberapa-zona-availability>Mekanisme <em>failing</em> pada beberapa zona <em>availability</em></h2><p>Teknik untuk menyeimbangkan persebaran trafik pada <em>failure domain</em> berbeda antar penyedia layanan <em>cloud</em>.
Kamu dapat mempelajari dokumentasi yang relevan bagi <a href=/id/docs/concepts/services-networking/ingress-controllers>kontoler Ingress</a>
untuk informasi yang lebih detail. Kamu juga dapat mempelajari <a href=/id/docs/concepts/cluster-administration/federation/>dokumentasi federasi</a>
untuk informasi lebih detail soal bagaimana melakukan <em>deploy</em> untuk federasi klaster.</p><h2 id=pengembangan-selanjutnya>Pengembangan selanjutnya</h2><p>Silahkan amati <a href=https://github.com/kubernetes/community/tree/master/sig-network>SIG Network</a>
untuk detail lebih lanjut mengenai perubahan Ingress dan <em>resource</em> terkait lainnya. Kamu juga bisa melihat
<a href=https://github.com/kubernetes/ingress/tree/master>repositori Ingress</a> untuk informasi yang lebih detail
soal perubahan berbagai kontroler.</p><h2 id=alternatif-lain>Alternatif lain</h2><p>Kamu dapat mengekspos sebuah <em>Service</em> dalam berbagai cara, tanpa harus menggunakan <em>resource</em> Ingress, dengan menggunakan:</p><ul><li><a href=/id/docs/concepts/services-networking/service/#loadbalancer>Service.Type=LoadBalancer</a></li><li><a href=/id/docs/concepts/services-networking/service/#nodeport>Service.Type=NodePort</a></li><li><a href=https://git.k8s.io/contrib/for-demos/proxy-to-service>Port Proxy</a></li></ul><h2 id=selanjutnya>Selanjutnya</h2><ul><li><a href=/docs/tasks/access-application-cluster/ingress-minikube>Melakukan konfigurasi Ingress pada Minikube dengan kontroler NGINX</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-5a8edeb1f2dc8e38cd6d561bb08b0d78>3.5.7 - Kontroler Ingress</h1><p>Agar Ingress dapat bekerja sebagaimana mestinya,
sebuah klaster harus memiliki paling tidak sebuah kontroler Ingress.</p><p>Berbeda dengan kontroler-kontroler lainnya yang dijalankan
sebagai bagian dari <em>binary</em> <code>kube-controller-manager</code>, kontroler Ingress
tidak secara otomatis dijalankan di dalam klaster. Kamu bisa menggunakan
laman ini untuk memilih implementasi kontroler Ingress yang kamu pikir
paling sesuai dengan kebutuhan kamu.</p><p>Kubernetes sebagai sebuah proyek, saat ini, mendukung dan memaintain kontroler-kontroler <a href=https://git.k8s.io/ingress-gce/README.md>GCE</a> dan
<a href=https://git.k8s.io/ingress-nginx/README.md>nginx</a>.</p><h2 id=kontroler-kontroler-lainnya>Kontroler-kontroler lainnya</h2><ul><li><a href=https://www.getambassador.io/>Ambassador</a> <em>API Gateway</em> merupakan ingress berbasis <a href=https://www.envoyproxy.io>Envoy</a>
kontroler dengan dukungan <a href=https://www.getambassador.io/docs>komunitas</a> atau
<a href=https://www.getambassador.io/pro/>komersial</a> dari <a href=https://www.datawire.io/>Datawire</a>.</li><li><a href=https://appscode.com>AppsCode Inc.</a> menawarkan dukungan dan pemeliharaan untuk ingress berbasis <a href=http://www.haproxy.org/>HAProxy</a>, <a href=https://appscode.com/products/voyager>Voyager</a>.</li><li><a href=https://projectcontour.io/>Contour</a> merupakan ingress berbasis <a href=https://www.envoyproxy.io/>Envoy</a>
yang disediakan dan didukung oleh VMware.</li><li>Citrix menyediakan sebuah <a href=https://github.com/citrix/citrix-k8s-ingress-controller>kontroler Ingress</a> untuk perangkat keras (MPX), virtualisasi (VPX) dan <a href=https://www.citrix.com/products/citrix-adc/cpx-express.html>kontainerisasi cuma-cuma (CPX) ADC</a> untuk mesin <a href=https://github.com/citrix/citrix-k8s-ingress-controller/tree/master/deployment/baremetal><em>baremetal</em></a> dan penyedia layanan <a href=https://github.com/citrix/citrix-k8s-ingress-controller/tree/master/deployment><em>cloud</em></a> deployments.</li><li>F5 Networks menyediakan <a href=https://support.f5.com/csp/article/K86859508>dukungan dan pemeliharaan</a>
untuk <a href=http://clouddocs.f5.com/products/connectors/k8s-bigip-ctlr/latest>kontroler F5 BIG-IP bagi Kubernetes</a>.</li><li><a href=https://gloo.solo.io>Gloo</a> adalah sebuah proyek kontroler Ingress <em>open source</em> berbasis <a href=https://www.envoyproxy.io>Envoy</a> yang menawarkan fungsionalitas <em>API Gateway</em> dengan dukungan <em>enterprise</em> dari <a href=https://www.solo.io>solo.io</a>.</li><li>Kontroler Ingress berbasis <a href=http://www.haproxy.org/>HAProxy</a>
<a href=https://github.com/jcmoraisjr/haproxy-ingress>jcmoraisjr/haproxy-ingress</a> yang disebutkan di dalam artikel
<a href=https://www.haproxy.com/blog/haproxy_ingress_controller_for_kubernetes/>HAProxy Ingress Controller for Kubernetes</a>.
<a href=https://www.haproxy.com/>HAProxy Technologies</a> menawarkan dukungan dan pemeliharaan bagi HAProxy Enterprise dan
Ingress kontroler <a href=https://github.com/jcmoraisjr/haproxy-ingress>jcmoraisjr/haproxy-ingress</a>.</li><li>Kontroler Ingress berbasis <a href=https://istio.io/>Istio</a>
<a href=https://istio.io/docs/tasks/traffic-management/ingress/>Control Ingress Traffic</a>.</li><li><a href=https://konghq.com/>Kong</a> menawarkan dukungan dan pemeliharaan <a href=https://discuss.konghq.com/c/kubernetes>komunitas</a> atau
<a href=https://konghq.com/kong-enterprise/>komersial</a>
<a href=https://github.com/Kong/kubernetes-ingress-controller>Kontroler Ingress untuk Kubernetes</a>.</li><li><a href=https://www.nginx.com/>NGINX, Inc.</a> menawarkan dukungan dan pemeliharaan <a href=https://www.nginx.com/products/nginx/kubernetes-ingress-controller>Kontroler Ingress NGINX untuk Kubernetes</a>.</li><li><a href=https://github.com/containous/traefik>Traefik</a> adalah sebuah kontroler Ingress yang menyediakan semua fitur secara lengkap (fully featured)
(<a href=https://letsencrypt.org>Let's Encrypt</a>, <em>secrets</em>, <em>http2</em>, <em>websocket</em>), dengan tambahan dukungan
komersial oleh <a href=https://containo.us/services>Containous</a>.</li></ul><h2 id=menggunakan-beberapa-jenis-kontroler-ingress-sekaligus>Menggunakan beberapa jenis kontroler Ingress sekaligus</h2><p>Kamu dapat melakukan <em>deploy</em> <a href=https://git.k8s.io/ingress-nginx/docs/user-guide/multiple-ingress.md#multiple-ingress-controllers>berapa pun banyaknya kontroler Ingress</a>
dalam sebuah klaster. Jika kamu ingin membuat Ingress, kamu tinggal memberikan anotasi setiap Ingress sesuai dengan
<a href=https://git.k8s.io/ingress-gce/docs/faq/README.md#how-do-i-run-multiple-ingress-controllers-in-the-same-cluster><code>ingress.class</code></a>
yang sesuai untuk menandai kontroler Ingress mana yang digunakan jika terdapat lebih dari satu kontroler Ingress yang ada di
klaster kamu.</p><p>Apabila kamu tidak mendefinisikan <code>class</code> yang dipakai, penyedia layanan <em>cloud</em> kamu akan menggunakan kontroler Ingress <em>default</em> yang mereka miliki.</p><p>Idealnya, semua ingress harus memenuhi spesifikasi ini, tetapi berbagai jenis
kontroler Ingress bisa saja memiliki sedikit perbedaan cara kerja.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Pastikan kamu sudah terlebih dahulu memahami dokumentasi kontroler Ingress yang akan kamu pakai sebelum memutuskan untuk memakai kontroler tersebut.</div><h2 id=selanjutnya>Selanjutnya</h2><ul><li>Pelajari <a href=/id/docs/concepts/services-networking/ingress/>Ingress</a> lebih lanjut.</li><li><a href=/docs/tasks/access-application-cluster/ingress-minikube>Melakukan konfigurasi Ingress pada Minikube dengan kontroler NGINX</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-ded1daafdcd293023ee333728007ca61>3.5.8 - NetworkPolicy</h1><nav id=TableOfContents><ul><li><a href=#prasyarat>Prasyarat</a></li><li><a href=#pod-yang-terisolasi-dan-tidak-terisolasi>Pod yang terisolasi dan tidak terisolasi</a></li><li><a href=#resource-networkpolicy><em>Resource</em> <code>NetworkPolicy</code></a></li><li><a href=#perilaku-selektor-to-dan-from>Perilaku selektor <code>to</code> dan <code>from</code></a></li><li><a href=#policy-default><em>Policy</em> <em>Default</em></a><ul><li><a href=#default-tolak-semua-trafik-ingress><em>Default</em>: tolak semua trafik <em>ingress</em></a></li><li><a href=#default-izinkan-semua-trafik-ingress><em>Default</em>: izinkan semua trafik <em>ingress</em></a></li><li><a href=#default-tolak-semua-trafik-egress><em>Default</em>: tolak semua trafik <em>egress</em></a></li><li><a href=#default-izinkan-semua-trafik-egress><em>Default</em>: izinkan semua trafik <em>egress</em></a></li><li><a href=#default-tolak-semua-trafik-ingress-dan-egress><em>Default</em>: tolak semua trafik <em>ingress</em> dan <em>egress</em></a></li></ul></li><li><a href=#dukungan-terhadap-sctp>Dukungan terhadap SCTP</a></li><li><a href=#selanjutnya>Selanjutnya</a></li></ul></nav><p>Sebuah NetworkPolicy adalah spesifikasi dari sekelompok Pod atau <em>endpoint</em> yang diizinkan untuk saling berkomunikasi.</p><p><code>NetworkPolicy</code> menggunakan label untuk memilih Pod serta mendefinisikan serangkaian <em>rule</em> yang digunakan
untuk mendefinisikan trafik yang diizinkan untuk suatu Pod tertentu.</p><h2 id=prasyarat>Prasyarat</h2><p>NetworkPolicy diimplementasikan dengan menggunakan <em>plugin</em> jaringan,
dengan demikian kamu harus memiliki penyedia jaringan yang mendukung <code>NetworkPolicy</code> -
membuat <em>resource</em> tanpa adanya <em>controller</em> tidak akan berdampak apa pun.</p><h2 id=pod-yang-terisolasi-dan-tidak-terisolasi>Pod yang terisolasi dan tidak terisolasi</h2><p>Secara <em>default</em>, Pod bersifat tidak terisolasi; Pod-Pod tersebut
menerima trafik dari <em>resource</em> apa pun.</p><p>Pod menjadi terisolasi apabila terdapat <code>NetworkPolicy</code> yang dikenakan pada Pod-Pod tersebut.
Apabila terdapat <code>NetworkPolicy</code> di dalam <em>namespace</em> yang dikenakan pada suatu Pod, Pod tersebut
akan menolak koneksi yang tidak diizinkan <code>NetworkPolicy</code>. (Pod lain dalam <em>namespace</em>
yang tidak dikenakan <code>NetworkPolicy</code> akan tetap menerima trafik dari semua <em>resource</em>.)</p><h2 id=resource-networkpolicy><em>Resource</em> <code>NetworkPolicy</code></h2><p>Lihat <a href=/docs/reference/generated/kubernetes-api/v1.25/#networkpolicy-v1-networking-k8s-io><code>NetworkPolicy</code></a> untuk definisi lengkap <em>resource</em>.</p><p>Sebuah contoh <code>NetworkPolicy</code> akan terlihat seperti berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>NetworkPolicy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-network-policy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>podSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>role</span>:<span style=color:#bbb> </span>db<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>policyTypes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- Ingress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- Egress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ingress</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>from</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>ipBlock</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cidr</span>:<span style=color:#bbb> </span><span style=color:#666>172.17.0.0</span>/16<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>except</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:#666>172.17.1.0</span>/24<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>namespaceSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>project</span>:<span style=color:#bbb> </span>myproject<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>podSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>role</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>6379</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>egress</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>to</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>ipBlock</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cidr</span>:<span style=color:#bbb> </span><span style=color:#666>10.0.0.0</span>/24<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>5978</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Mengirimkan ini ke API server dengan metode POST tidak akan berdampak apa pun
kecuali penyedia jaringan mendukung network policy.</p><p><strong><em>Field-field</em> yang bersifat wajib</strong>: Sama dengan seluruh <em>config</em> Kubernetes lainnya, sebuah <code>NetworkPolicy</code>
membutuhkan <em>field-field</em> <code>apiVersion</code>, <code>kind</code>, dan <code>metadata</code>. Informasi generik mengenai
bagaimana bekerja dengan <em>file</em> <code>config</code>, dapat dilihat di
<a href=/id/docs/tasks/configure-pod-container/configure-pod-configmap/>Konfigurasi Kontainer menggunakan <code>ConfigMap</code></a>,
serta <a href=/id/docs/tasks/manage-kubernetes-objects/>Manajemen Objek</a>.</p><p><strong>spec</strong>: <code>NetworkPolicy</code> <a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status>spec</a> memiliki semua informasi yang harus diberikan untuk memberikan definisi <em>network policy</em> yang ada pada <em>namespace</em> tertentu.</p><p><strong>podSelector</strong>: Setiap <code>NetworkPolicy</code> memiliki sebuah <code>podSelector</code> yang bertugas memfilter Pod-Pod yang dikenai <em>policy</em> tersebut. Contoh yang ada memfilter Pod dengan label <code>"role=db"</code>. Sebuah <code>podSelector</code> yang empty akan memilih semua Pod yang ada di dalam <em>namespace</em>.</p><p><strong>policyTypes</strong>: Setiap <code>NetworkPolicy</code> memiliki sebuah daftar <code>policyTypes</code> yang dapat berupa <code>Ingress</code>, <code>Egress</code>, atau keduanya. <em>Field</em> <code>policyTypes</code> mengindikasikan apakah suatu <em>policy</em> diberikan pada trafik <em>ingress</em>, <em>egress</em>, atau camputan <em>ingress</em> dan <em>egress</em> pada Pod tertentu. Jika tidak ada <code>policyTypes</code> tyang diberikan pada <code>NetworkPolicy</code> maka <code>Ingress</code> <em>default</em> akan diterapkan dan <code>Egress</code> akan diterapkan apabila <em>policy</em> tersebut memberikan spesifikasi <em>egress</em>.</p><p><strong>ingress</strong>: Setiap <code>NetworkPolicy</code> bisa saja memberikan serangkaian whitelist <em>rule-rule</em> <code>ingress</code>. Setiap <em>rule</em> mengizinkan trafik yang sesuai dengan <em>section</em> <code>from</code> dan <code>ports</code>. Contoh <em>policy</em> yang diberikan memiliki sebuah <em>rule</em>, yang sesuai dengan trafik pada sebuah <code>port</code> <em>single</em>, bagian pertama dispesifikasikan melalui <code>ipBlock</code>, yang kedua melalui <code>namespaceSelector</code> dan yang ketiga melalui <code>podSelector</code>.</p><p><strong>egress</strong>: Setiap <code>NetworkPolicy</code> bisa saja meliputi serangkaian <em>whitelist</em> <em>rule-rule</em> <code>egress</code>. Setiap <em>rule</em> mengizinkan trafik yang sesuai dengan <em>section</em> <code>to</code> dan <code>ports</code>. Contoh <em>policy</em> yang diberikan memiliki sebuah <em>rule</em>, yang sesuai dengan <code>port</code> <em>single</em> pada destinasi <code>10.0.0.0/24</code>.</p><p>Pada contoh, <code>NetworkPolicy</code> melakukan hal berikut:</p><ol><li><p>Mengisolasi Pod-Pod dengan label <code>"role=db"</code> pada <em>namespace</em> <code>"default"</code> baik untuk <code>ingress</code> atau <code>egress</code>.</p></li><li><p>(<em>Rule</em> <code>Ingress</code>) mengizinkan koneksi ke semua Pod pada <em>namespace</em> <code>“default”</code> dengan label <code>“role=db”</code> untuk protokol TCP <code>port</code> <code>6379</code> dari:</p><ul><li>semua Pod pada <em>namespace</em> <code>"default"</code> dengan label <code>"role=frontend"</code></li><li>semua Pod dalam sebuah <em>namespace</em> dengan label <code>"project=myproject"</code></li><li>alamat IP pada <em>range</em> <code>172.17.0.0–172.17.0.255</code> dan <code>172.17.2.0–172.17.255.255</code> (yaitu, semua <code>172.17.0.0/16</code> kecuali <code>172.17.1.0/24</code>)</li></ul></li><li><p>(<em>Rule</em> Egress) mengizinkan koneksi dari semua Pod pada <em>namespace</em> <code>"default"</code> dengan label <code>"role=db"</code> ke CIDR <code>10.0.0.0/24</code> untuk protokol TCP pada <code>port</code> <code>5978</code></p></li></ol><p>Lihat mekanisme <a href=/docs/tasks/administer-cluster/declare-network-policy/>Deklarasi <em>Network Policy</em></a> untuk penjelasan lebih mendalam.</p><h2 id=perilaku-selektor-to-dan-from>Perilaku selektor <code>to</code> dan <code>from</code></h2><p>Terdapat empat jenis selektor yang dapat dispesifikasikan dalam <code>section</code> <code>ingress</code> <code>from</code> atau <code>section</code> <code>egress</code> <code>to</code>:</p><p><strong>podSelector</strong>: Ini digunakan untuk memfilter Pod tertentu pada <em>namespace</em> dimana <code>NetworkPolicy</code> berada yang akan mengatur destinasi <em>ingress</em> atau <em>egress</em>.</p><p><strong>namespaceSelector</strong>: Ini digunakan untuk memfilter <em>namespace</em> tertentu dimana semua Pod diperbolehkan sebagai <em>source</em> <code>ingress</code> atau destinasi <code>egress</code>.</p><p><strong>namespaceSelector</strong> <em>and</em> <strong>podSelector</strong>: Sebuah entri <code>to</code>/<code>from</code> yang memberikan spesifikasi <code>namespaceSelector</code> dan <code>podSelector</code> serta memilih Pod-Pod tertentu yang ada di dalam <em>namespace</em>. Pastikan kamu menggunakan sintaks YAML yang tepat; <code>policy</code> ini:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ingress</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>from</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>namespaceSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb> </span>alice<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>podSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>role</span>:<span style=color:#bbb> </span>client<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span></code></pre></div><p>mengandung sebuah elemen <code>from</code> yang mengizinkan koneksi dari Pod-Pod dengan label <code>role=client</code> di <em>namespace</em> dengan label <code>user=alice</code>. Akan tetapi, <em>policy</em> <em>ini</em>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ingress</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>from</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>namespaceSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb> </span>alice<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>podSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>role</span>:<span style=color:#bbb> </span>client<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span></code></pre></div><p>mengandung dua elemen pada <em>array</em> <code>from</code>, dan mengizinkan koneksi dari Pod pada Namespace lokal dengan label
<code>role=client</code>, <em>atau</em> dari Pod di <em>namespace</em> apa pun dengan label <code>user=alice</code>.</p><p>Ketika kamu merasa ragu, gunakan <code>kubectl describe</code> untuk melihat bagaimana Kubernetes
menginterpretasikan <em>policy</em> tersebut.</p><p><strong>ipBlock</strong>: Ini digunakan untuk memilih <em>range</em> IP CIDR tertentu untuk berperan sebagai
<em>source</em> <em>ingress</em> atau destinasi <em>egress</em>. Alamat yang digunakan harus merupakan
alamat IP eksternal klaster, karena alamat IP Pod bersifat <em>ephemeral</em> dan tidak dapat ditebak.</p><p>Mekanisme <em>ingress</em> dan <em>egress</em> klaster seringkali membutuhkan mekanisme <em>rewrite</em> alamat IP <em>source</em> dan destinasi
paket. Pada kasus-kasus dimana hal ini, tidak dapat dipastikan bahwa apakah hal ini
terjadi sebelum atau setelah pemrosesan <code>NetworkPolicy</code>, dan perilaku yang ada mungkin saja berbeda
untuk kombinasi <em>plugin</em> jaringan, penyedia layanan <em>cloud</em>, serta implementasi <code>Service</code> yang berbeda.</p><p>Pada <em>ingress</em>, artinya bisa saja kamu melakukan <em>filter</em> paket yang masuk berdasarkan <code>source IP</code>,
sementara di kasus lain "source IP" yang digunakan oleh Network Policy adalah alamat IP <code>LoadBalancer</code>,
<em>node</em> dimana Pod berada, dsb.</p><p>Pada <em>egress</em>, bisa saja sebuah koneksi dari Pod ke IP <code>Service</code> di-<em>rewrite</em> ke IP eksternal klaster
atau bahkan tidak termasuk di dalam <code>ipBlock</code> <em>policy</em>.</p><h2 id=policy-default><em>Policy</em> <em>Default</em></h2><p>Secara <em>default</em>, jika tidak ada <em>policy</em> yang ada dalam suatu <em>namespace</em>, maka semua trafik <em>ingress</em> dan <em>egress</em> yang diizinkan ke atau dari Pod dalam <em>namespace</em>.
Contoh di bawah ini akan memberikan gambaran bagaimana kamu dapat mengubah perilaku <em>default</em> pada sebuah <em>namespace</em>.</p><h3 id=default-tolak-semua-trafik-ingress><em>Default</em>: tolak semua trafik <em>ingress</em></h3><p>Kamu dapat membuat <em>policy</em> isolasi <code>"default"</code> untuk sebuah <em>namespace</em>
dengan membuat sebuah <code>NetworkPolicy</code> yang memilih semua Pod tapi tidak mengizinkan
trafik <em>ingress</em> masuk ke Pod-Pod tersebut.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>NetworkPolicy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default-deny<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>podSelector</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>policyTypes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- Ingress<span style=color:#bbb>
</span></span></span></code></pre></div><p>Hal ini menjamin bahwa bahkan Pod yang tidak dipilih oleh <code>NetworkPolicy</code> lain masih terisolasi.
<em>Policy</em> ini tidak mengubah perilaku <em>default</em> dari <em>egress</em>.</p><h3 id=default-izinkan-semua-trafik-ingress><em>Default</em>: izinkan semua trafik <em>ingress</em></h3><p>Jika kamu ingin mengizinkan semua trafik <em>ingress</em> pada semua Pod dalam sebuah <em>namespace</em>
(bahkan jika <em>policy</em> ditambahkan dan menyebabkan beberapa Pod menjadi terisolasi), kamu
dapat secara eksplisit mengizinkan semua trafik bagi <em>namespace</em> tersebut.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>NetworkPolicy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>allow-all<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>podSelector</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ingress</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- {}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>policyTypes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- Ingress<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=default-tolak-semua-trafik-egress><em>Default</em>: tolak semua trafik <em>egress</em></h3><p>Kamu dapat membuat <em>policy</em> isolasi <code>"default"</code> untuk sebuah <em>namespace</em>
dengan membuat sebuah <code>NetworkPolicy</code> yang memilih semua Pod tapi tidak mengizinkan
trafik <em>egress</em> keluar dari Pod-Pod tersebut.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>NetworkPolicy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default-deny<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>podSelector</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>policyTypes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- Egress<span style=color:#bbb>
</span></span></span></code></pre></div><p>Hal ini menjamin bahwa bahkan Pod yang tidak dipilih oleh <code>NetworkPolicy</code> lain masih terisolasi.
<em>Policy</em> ini tidak mengubah perilaku <em>default</em> dari <em>ingress</em>.</p><h3 id=default-izinkan-semua-trafik-egress><em>Default</em>: izinkan semua trafik <em>egress</em></h3><p>Jika kamu ingin mengizinkan semua trafik <em>egress</em> pada semua Pod dalam sebuah <em>namespace</em>
(bahkan jika <em>policy</em> ditambahkan dan menyebabkan beberapa Pod menjadi terisolasi), kamu
dapat secara eksplisit mengizinkan semua trafik bagi <em>namespace</em> tersebut.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>NetworkPolicy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>allow-all<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>podSelector</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>egress</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- {}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>policyTypes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- Egress<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=default-tolak-semua-trafik-ingress-dan-egress><em>Default</em>: tolak semua trafik <em>ingress</em> dan <em>egress</em></h3><p>Kamu dapat membuat sebuah <em>policy</em> <em>"default"</em> jika kamu ingin menolak semua trafik <em>ingress</em> maupun <em>egress</em> pada semua Pod dalam sebuah <em>namespace</em>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>NetworkPolicy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default-deny<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>podSelector</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>policyTypes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- Ingress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- Egress<span style=color:#bbb>
</span></span></span></code></pre></div><p>Hal ini menjamin bahwa bahkan Pod yang tidak dipilih oleh <code>NetworkPolicy</code> tidak akan mengizinkan trafik <em>ingress</em> atau <em>egress</em>.</p><h2 id=dukungan-terhadap-sctp>Dukungan terhadap SCTP</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.12 [alpha]</code></div><p>Kubernetes mendukung SCTP sebagai <em>value</em> <code>protocol</code> pada definisi <code>NetworkPolicy</code> sebagai fitur alpha. Untuk mengaktifkan fitur ini, administrator klaster harus mengaktifkan gerbang fitur <code>SCTPSupport</code> pada <code>apiserver</code>, contohnya <code>“--feature-gates=SCTPSupport=true,...”</code>. Ketika gerbang fitur ini diaktifkan, pengguna dapat menerapkan <code>value</code> dari <em>field</em> <code>protocol</code> pada <code>NetworkPolicy</code> menjadi <code>SCTP</code>. Kubernetes akan mengatur jaringan sesuai dengan SCTP, seperti halnya koneksi TCP.</p><p><em>Plugin</em> CNI harus mendukung SCTP sebagai <em>value</em> dari <code>protocol</code> pada <code>NetworkPolicy</code>.</p><h2 id=selanjutnya>Selanjutnya</h2><ul><li>Lihat <a href=/docs/tasks/administer-cluster/declare-network-policy/>Deklarasi <em>Network Policy</em></a> untuk melihat lebih banyak contoh penggunaan.</li><li>Baca lebih lanjut soal <a href=https://github.com/ahmetb/kubernetes-network-policy-recipes>panduan</a> bagi skenario generik <em>resource</em> <code>NetworkPolicy</code>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-509638b5ca0e420fa426f14f34e2d3b1>3.5.9 - Menambahkan Entry pada /etc/hosts Pod dengan HostAliases</h1><nav id=TableOfContents><ul><li><a href=#isi-default-pada-berkas-hosts>Isi Default pada Berkas <code>Hosts</code></a></li><li><a href=#menambahkan-entri-tambahan-dengan-hostaliases>Menambahkan Entri Tambahan dengan HostAliases</a></li><li><a href=#kenapa-kubelet-melakukan-mekanisme-manajemen-berkas-hosts>Kenapa Kubelet Melakukan Mekanisme Manajemen Berkas <code>Hosts</code>?</a></li></ul></nav><p>Menambahkan entri pada berkas /etc/hosts Pod akan melakukan <em>override</em>
resolusi <em>hostname</em> pada level Pod ketika DNS dan opsi lainnya tidak tersedia.
Pada versi 1.7, pengguna dapat menambahkan entri yang diinginkan beserta <em>field</em> HostAliases
pada PodSpec.</p><p>Modifikasi yang dilakukan tanpa menggunakan HostAliases tidaklah disarankan
karena berkas ini diatur oleh Kubelet dan dapat di-<em>override</em> ketika Pod dibuat/di-<em>restart</em>.</p><h2 id=isi-default-pada-berkas-hosts>Isi Default pada Berkas <code>Hosts</code></h2><p>Misalnya saja kamu mempunyai sebuah Pod Nginx yang memiliki sebuah IP Pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl run nginx --image nginx --generator<span style=color:#666>=</span>run-pod/v1
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>pod/nginx created
</span></span></code></pre></div><p>Perhatikan IP Pod tersebut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods --output<span style=color:#666>=</span>wide
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME     READY     STATUS    RESTARTS   AGE    IP           NODE
</span></span><span style=display:flex><span>nginx    1/1       Running   <span style=color:#666>0</span>          13s    10.200.0.4   worker0
</span></span></code></pre></div><p><em>File</em> <code>hosts</code> yang ada akan tampak sebagai berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> nginx -- cat /etc/hosts
</span></span></code></pre></div><pre tabindex=0><code class=language-none data-lang=none># Berkas hosts yang dikelola Kubernetes
127.0.0.1	localhost
::1	localhost ip6-localhost ip6-loopback
fe00::0	ip6-localnet
fe00::0	ip6-mcastprefix
fe00::1	ip6-allnodes
fe00::2	ip6-allrouters
10.200.0.4	nginx
</code></pre><p>Secara default, berkas <code>hosts</code> hanya berisikan <em>boilerplate</em> alamat IP IPv4 and IPv6 seperti
<code>localhost</code> dan hostname dari Pod itu sendiri.</p><h2 id=menambahkan-entri-tambahan-dengan-hostaliases>Menambahkan Entri Tambahan dengan HostAliases</h2><p>Selain <em>boilerplate default</em>, kita dapat menambahkan entri pada berkas
<code>hosts</code> untuk melakukan resolusi <code>foo.local</code>, <code>bar.local</code> pada <code>127.0.0.1</code> dan <code>foo.remote</code>,
<code>bar.remote</code> pada <code>10.1.2.3</code>, kita dapat melakukannya dengan cara menambahkan
HostAliases pada Pod di bawah <em>field</em> <code>.spec.hostAliases</code>:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/service/networking/hostaliases-pod.yaml download=service/networking/hostaliases-pod.yaml><code>service/networking/hostaliases-pod.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("service-networking-hostaliases-pod-yaml")' title="Copy service/networking/hostaliases-pod.yaml to clipboard"></img></div><div class=includecode id=service-networking-hostaliases-pod-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hostaliases-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostAliases</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>ip</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;127.0.0.1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hostnames</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;foo.local&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;bar.local&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>ip</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;10.1.2.3&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hostnames</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;foo.remote&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;bar.remote&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cat-hosts<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- cat<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;/etc/hosts&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Pod ini kemudian dapat dihidupkan dengan perintah berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f hostaliases-pod.yaml
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>pod/hostaliases-pod created
</span></span></code></pre></div><p>Perhatikan IP dan status Pod tersebut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod --output<span style=color:#666>=</span>wide
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME                           READY     STATUS      RESTARTS   AGE       IP              NODE
</span></span><span style=display:flex><span>hostaliases-pod                0/1       Completed   <span style=color:#666>0</span>          6s        10.200.0.5      worker0
</span></span></code></pre></div><p><em>File</em> <code>hosts</code> yang ada akan tampak sebagai berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl logs hostaliases-pod
</span></span></code></pre></div><pre tabindex=0><code class=language-none data-lang=none># Berkas hosts yang dikelola Kubernetes
127.0.0.1	localhost
::1	localhost ip6-localhost ip6-loopback
fe00::0	ip6-localnet
fe00::0	ip6-mcastprefix
fe00::1	ip6-allnodes
fe00::2	ip6-allrouters
10.200.0.5	hostaliases-pod

# Entries added by HostAliases.
127.0.0.1	foo.local	bar.local
10.1.2.3	foo.remote	bar.remote
</code></pre><p>Dengan tambahan entri yang telah dispesifikasikan sebelumnya.</p><h2 id=kenapa-kubelet-melakukan-mekanisme-manajemen-berkas-hosts>Kenapa Kubelet Melakukan Mekanisme Manajemen Berkas <code>Hosts</code>?</h2><p>Kubelet <a href=https://github.com/kubernetes/kubernetes/issues/14633>melakukan proses manajemen</a>
berkas <code>hosts</code> untuk setiap container yang ada pada Pod untuk mencegah Docker melakukan
<a href=https://github.com/moby/moby/issues/17190>modifikasi</a> pada berkas tersebut
setelah kontainer dihidupkan.</p><p>Karena sifat dari berkas tersebut yang secara otomatis di-<em>manage</em>,
semua hal yang didefinisikan oleh pengguna akan ditimpa (<em>overwrite</em>) ketika berkas
<code>hosts</code> di-<em>mount</em> kembali oleh Kubelet ketika ada kontainer yang di-<em>restart</em>
atau Pod di-<em>schedule</em> ulang. Dengan demikian tidak dianjurkan untuk
memodifikasi berkas tersebut secara langsung.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-21f8d19c60c33914baab66224c3d46a7>3.5.10 - Dual-stack IPv4/IPv6</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.16 [alpha]</code></div><p><em>Dual-stack</em> IPv4/IPv6 memungkinkan pengalokasian alamat IPv4 dan IPv6 untuk
<a class=glossary-tooltip title='Unit Kubernetes yang paling sederhana dan kecil. Sebuah Pod merepresentasikan sebuah set kontainer yang dijalankan pada kluster kamu.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a> dan <a class=glossary-tooltip title='Sebuah Cara untuk mengekspos aplikasi yang berjalan pada sebuah kumpulan Pod sebagai layanan jaringan.' data-toggle=tooltip data-placement=top href=/docs/concepts/services-networking/service/ target=_blank aria-label=Service>Service</a>.</p><p>Jika kamu mengaktifkan jaringan <em>dual-stack</em> IPv4/IPv6 untuk klaster Kubernetes
kamu, klaster akan mendukung pengalokasian kedua alamat IPv4 dan IPv6 secara
bersamaan.</p><h2 id=fitur-fitur-yang-didukung>Fitur-fitur yang didukung</h2><p>Mengaktifkan <em>dual-stack</em> IPv4 / IPv6 pada klaster Kubernetes kamu untuk
menyediakan fitur-fitur berikut ini:</p><ul><li>Jaringan Pod <em>dual-stack</em> (pengalokasian sebuah alamat IPv4 dan IPv6 untuk setiap Pod)</li><li>Service yang mendukung IPv4 dan IPv6 (setiap Service hanya untuk satu keluarga alamat)</li><li>Perutean Pod ke luar klaster (misalnya Internet) melalui antarmuka IPv4 dan IPv6</li></ul><h2 id=prasyarat>Prasyarat</h2><p>Prasyarat berikut diperlukan untuk menggunakan <em>dual-stack</em> IPv4/IPv6 pada
klaster Kubernetes :</p><ul><li>Kubernetes versi 1.16 atau yang lebih baru</li><li>Dukungan dari penyedia layanan untuk jaringan <em>dual-stack</em> (Penyedia layanan <em>cloud</em> atau yang lainnya harus dapat menyediakan antarmuka jaringan IPv4/IPv6 yang dapat dirutekan) untuk Node Kubernetes</li><li>Sebuah <em>plugin</em> jaringan yang mendukung <em>dual-stack</em> (seperti Kubenet atau Calico)</li><li>Kube-proxy yang berjalan dalam mode IPVS</li></ul><h2 id=mengaktifkan-dual-stack-ipv4-ipv6>Mengaktifkan <em>dual-stack</em> IPv4/IPv6</h2><p>Untuk mengaktifkan <em>dual-stack</em> IPv4/IPv6, aktifkan <a href=/docs/reference/command-line-tools-reference/feature-gates/>gerbang fitur (<em>feature gate</em>)</a> <code>IPv6DualStack</code>
untuk komponen-komponen yang relevan dari klaster kamu, dan tetapkan jaringan
<em>dual-stack</em> pada klaster:</p><ul><li>kube-controller-manager:<ul><li><code>--feature-gates="IPv6DualStack=true"</code></li><li><code>--cluster-cidr=&lt;IPv4 CIDR>,&lt;IPv6 CIDR></code> misalnya <code>--cluster-cidr=10.244.0.0/16,fc00::/24</code></li><li><code>--service-cluster-ip-range=&lt;IPv4 CIDR>,&lt;IPv6 CIDR></code></li><li><code>--node-cidr-mask-size-ipv4|--node-cidr-mask-size-ipv6</code> nilai bawaannya adalah /24
untuk IPv4 dan /64 untuk IPv6</li></ul></li><li>kubelet:<ul><li><code>--feature-gates="IPv6DualStack=true"</code></li></ul></li><li>kube-proxy:<ul><li><code>--proxy-mode=ipvs</code></li><li><code>--cluster-cidr=&lt;IPv4 CIDR>,&lt;IPv6 CIDR></code></li><li><code>--feature-gates="IPv6DualStack=true"</code></li></ul></li></ul><div class="alert alert-warning caution callout" role=alert><strong>Perhatian:</strong> Jika kamu menentukan blok alamat IPv6 yang lebih besar dari /24 melalui
<code>--cluster-cidr</code> pada baris perintah, maka penetapan tersebut akan gagal.</div><h2 id=service>Service</h2><p>Jika klaster kamu mengaktifkan jaringan <em>dual-stack</em> IPv4/IPv6, maka kamu dapat
membuat <a class=glossary-tooltip title='Sebuah Cara untuk mengekspos aplikasi yang berjalan pada sebuah kumpulan Pod sebagai layanan jaringan.' data-toggle=tooltip data-placement=top href=/docs/concepts/services-networking/service/ target=_blank aria-label=Service>Service</a> dengan
alamat IPv4 atau IPv6. Kamu dapat memilih keluarga alamat untuk clusterIP<br>Service kamu dengan mengatur bagian, <code>.spec.ipFamily</code>, pada Service tersebut.
Kamu hanya dapat mengatur bagian ini saat membuat Service baru. Mengatur bagian
<code>.spec.ipFamily</code> bersifat opsional dan hanya boleh digunakan jika kamu berencana
untuk mengaktifkan <a class=glossary-tooltip title='Sebuah Cara untuk mengekspos aplikasi yang berjalan pada sebuah kumpulan Pod sebagai layanan jaringan.' data-toggle=tooltip data-placement=top href=/docs/concepts/services-networking/service/ target=_blank aria-label='Service '>Service</a>
dan <a class=glossary-tooltip title='Sebuah obyek API yang mengatur akses eksternal terhadap Service yang ada di dalam klaster, biasanya dalam bentuk request HTTP.' data-toggle=tooltip data-placement=top href=/docs/concepts/services-networking/ingress/ target=_blank aria-label='Ingress '>Ingress</a> IPv4 dan IPv6
pada klaster kamu. Konfigurasi bagian ini bukanlah syarat untuk lalu lintas
[<em>egress</em>] (#lalu-lintas-egress).</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Keluarga alamat bawaan untuk klaster kamu adalah keluarga alamat dari rentang
clusterIP Service pertama yang dikonfigurasi melalui opsi
<code>--service-cluster-ip-range</code> pada kube-controller-manager.</div><p>Kamu dapat mengatur <code>.spec.ipFamily</code> menjadi salah satu dari:</p><ul><li><code>IPv4</code>: Dimana server API akan mengalokasikan IP dari <code>service-cluster-ip-range</code> yaitu <code>ipv4</code></li><li><code>IPv6</code>: Dimana server API akan mengalokasikan IP dari <code>service-cluster-ip-range</code> yaitu <code>ipv6</code></li></ul><p>Spesifikasi Service berikut ini tidak memasukkan bagian <code>ipFamily</code>.
Kubernetes akan mengalokasikan alamat IP (atau yang dikenal juga sebagai
"<em>cluster IP</em>") dari <code>service-cluster-ip-range</code> yang dikonfigurasi pertama kali
untuk Service ini.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/service/networking/dual-stack-default-svc.yaml download=service/networking/dual-stack-default-svc.yaml><code>service/networking/dual-stack-default-svc.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("service-networking-dual-stack-default-svc-yaml")' title="Copy service/networking/dual-stack-default-svc.yaml to clipboard"></img></div><div class=includecode id=service-networking-dual-stack-default-svc-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span></span></span></code></pre></div></div></div><p>Spesifikasi Service berikut memasukkan bagian <code>ipFamily</code>. Sehingga Kubernetes
akan mengalokasikan alamat IPv6 (atau yang dikenal juga sebagai "<em>cluster IP</em>")
dari <code>service-cluster-ip-range</code> yang dikonfigurasi untuk Service ini.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/service/networking/dual-stack-ipv6-svc.yaml download=service/networking/dual-stack-ipv6-svc.yaml><code>service/networking/dual-stack-ipv6-svc.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("service-networking-dual-stack-ipv6-svc-yaml")' title="Copy service/networking/dual-stack-ipv6-svc.yaml to clipboard"></img></div><div class=includecode id=service-networking-dual-stack-ipv6-svc-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ipFamily</span>:<span style=color:#bbb> </span>IPv6<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span></span></span></code></pre></div></div></div><p>Sebagai perbandingan, spesifikasi Service berikut ini akan dialokasikan sebuah alamat
IPv4 (atau yang dikenal juga sebagai "<em>cluster IP</em>") dari <code>service-cluster-ip-range</code>
yang dikonfigurasi untuk Service ini.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/service/networking/dual-stack-ipv4-svc.yaml download=service/networking/dual-stack-ipv4-svc.yaml><code>service/networking/dual-stack-ipv4-svc.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("service-networking-dual-stack-ipv4-svc-yaml")' title="Copy service/networking/dual-stack-ipv4-svc.yaml to clipboard"></img></div><div class=includecode id=service-networking-dual-stack-ipv4-svc-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ipFamily</span>:<span style=color:#bbb> </span>IPv4<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span></span></span></code></pre></div></div></div><h3 id=tipe-loadbalancer>Tipe <em>LoadBalancer</em></h3><p>Penyedia layanan <em>cloud</em> yang mendukung IPv6 untuk pengaturan beban eksternal,
Mengatur bagian <code>type</code> menjadi <code>LoadBalancer</code> sebagai tambahan terhadap mengatur bagian
<code>ipFamily</code> menjadi <code>IPv6</code> menyediakan sebuah <em>cloud load balancer</em> untuk Service kamu.</p><h2 id=lalu-lintas-egress>Lalu lintas <em>egress</em></h2><p>Penggunaan blok alamat IPv6 yang dapat dirutekan dan yang tidak dapat dirutekan
secara publik diperbolehkan selama <a class=glossary-tooltip title='Container network interface (CNI) plugins are a type of Network plugin that adheres to the appc/CNI specification.' data-toggle=tooltip data-placement=top href=/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/ target=_blank aria-label=CNI>CNI</a>
dari penyedia layanan dapat mengimplementasikan transportasinya. Jika kamu memiliki
Pod yang menggunakan IPv6 yang dapat dirutekan secara publik dan ingin agar Pod
mencapai tujuan di luar klaster (misalnya Internet publik), kamu harus mengatur
IP samaran untuk lalu lintas keluar dan balasannya. <a href=https://github.com/kubernetes-incubator/ip-masq-agent><em>ip-masq-agent</em></a>
bersifat <em>dual-stack aware</em>, jadi kamu bisa menggunakan ip-masq-agent untuk
<em>masquerading</em> IP dari klaster <em>dual-stack</em>.</p><h2 id=masalah-masalah-yang-diketahui>Masalah-masalah yang diketahui</h2><ul><li>Kubenet memaksa pelaporan posisi IP untuk IPv4,IPv6 IP (--cluster-cidr)</li></ul><h2 id=selanjutnya>Selanjutnya</h2><ul><li><a href=/docs/tasks/network/validate-dual-stack>Validasi jaringan <em>dual-stack</em> IPv4/IPv6</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-f018f568c6723865753f150c3c59bdda>3.6 - Storage</h1></div><div class=td-content><h1 id=pg-27795584640a03bd2024f1fe3b3ab754>3.6.1 - Volume</h1><p>Berkas-berkas yang disimpan di <em>disk</em> di dalam Container bersifat tidak permanen (akan terhapus seiring dengan dihapusnya Container/Pod), yang menimbulkan beberapa masalah untuk aplikasi biasa saat berjalan di dalam Container. Pertama, saat sebuah Container mengalami kegagalan, Kubelet akan memulai kembali Container tersebut, tetapi semua berkas di dalamnya akan hilang - Container berjalan dalam kondisi yang bersih. Kedua, saat menjalankan banyak Container bersamaan di dalam sebuah <code>Pod</code>, biasanya diperlukan untuk saling berbagi berkas-berkas di antara Container-container tersebut. Kedua masalah tersebut dipecahkan oleh abstraksi <code>Volume</code> pada Kubernetes.</p><p>Pengetahuan tentang <a href=/docs/user-guide/pods>Pod</a> disarankan.</p><h2 id=latar-belakang>Latar Belakang</h2><p>Docker juga memiliki konsep <em><a href=https://docs.docker.com/storage/>volume</a></em>, walaupun konsepnya Docker agak lebih fleksibel dan kurang dikelola. Pada Docker, sebuah volume adalah sesederhana sebuah direktori pada <em>disk</em> atau di dalam Container lainnya. <em>Lifetime</em> tidak dikelola dan hingga baru-baru ini hanya ada volume yang didukung <em>disk</em> lokal. Docker sekarang menyediakan <em>driver</em> untuk volume, namun fungsionalitasnya masih sangat terbatas (misalnya hingga Docker 1.7 hanya ada satu <em>driver</em> volume yang diizinkan untuk setiap Container, dan tidak ada cara untuk menyampaikan parameter kepada volume).</p><p>Sebaliknya, sebuah Volume Kubernetes memiliki <em>lifetime</em> yang gamblang - sama dengan <em>lifetime</em> Pod yang berisi Volume tersebut. Oleh karena itu, sebuah Volume bertahan lebih lama dari Container-container yang berjalan di dalam Pod tersebut, dan data di Volum tersebut juga dipertahankan melewati diulangnya Container. Tentu saja, saat sebuah Pod berakhir, Volume tersebut juga akan berakhir/terhapus. Dan mungkin lebih penting lagi, Kubernetes mendukung banyak jenis Volume, dan sebuah Pod dapat menggunakan sebanyak apapun Volume secara bersamaan.</p><p>Pada intinya, sebuah volume hanyalah sebuah direktori, dan mungkin berisi data, yang dapat diakses oleh Container-container di dalam Pod. Bagaimana direktori tersebut dibuat, medium yang menyokongnya, dan isinya ditentukan oleh jenis volume yang digunakan.</p><p>Untuk menggunakan sebuah volume, sebuah Pod memerinci volume-volume yang akan disediakan untuk Pod tersebut (kolom <code>.spec.volumes</code>) dan di mana volume-volume tersebut akan ditambatkan (di-<em>mount</em>) di dalam Container-container di Pod (kolom <code>.spec.containers.volumeMounts</code>).</p><p>Sebuah proses di dalam Container memiliki sudut pandang <em>filesystem</em> yang disusun dari <em>image</em> dan volume Dockernya. <a href=https://docs.docker.com/userguide/dockerimages/>Docker Image</a> berada pada bagian teratas hierarki <em>filesystem</em>, dan volume manapun yang ditambatkan pada <em>path</em> yang diperinci di dalam Image tersebut. Volume tidak dapat ditambatkan pada volume lain atau memiliki <em>hard link</em> ke volume lain. Setiap Container di dalam Pod harus secara independen memerinci di mana tiap Volume ditambatkan.</p><h2 id=jenis-jenis-volume>Jenis-jenis Volume</h2><p>Kubernetes mendukung beberapa jenis Volume:</p><ul><li><a href=#awselasticblockstore>awsElasticBlockStore</a></li><li><a href=#azuredisk>azureDisk</a></li><li><a href=#azurefile>azureFile</a></li><li><a href=#cephfs>cephfs</a></li><li><a href=#cinder>cinder</a></li><li><a href=#configmap>configMap</a></li><li><a href=#csi>csi</a></li><li><a href=#downwardapi>downwardAPI</a></li><li><a href=#emptydir>emptyDir</a></li><li><a href=#fc>fc (fibre channel)</a></li><li><a href=#flexVolume>flexVolume</a></li><li><a href=#flocker>flocker</a></li><li><a href=#gcepersistentdisk>gcePersistentDisk</a></li><li><a href=#gitrepo>gitRepo (deprecated)</a></li><li><a href=#glusterfs>glusterfs</a></li><li><a href=#hostpath>hostPath</a></li><li><a href=#iscsi>iscsi</a></li><li><a href=#local>local</a></li><li><a href=#nfs>nfs</a></li><li><a href=#persistentvolumeclaim>persistentVolumeClaim</a></li><li><a href=#projected>projected</a></li><li><a href=#portworxvolume>portworxVolume</a></li><li><a href=#quobyte>quobyte</a></li><li><a href=#rbd>rbd</a></li><li><a href=#scaleio>scaleIO</a></li><li><a href=#secret>secret</a></li><li><a href=#storageos>storageos</a></li><li><a href=#vspherevolume>vsphereVolume</a></li></ul><p>Kami menyambut kontribusi tambahan.</p><h3 id=awselasticblockstore>awsElasticBlockStore</h3><p>Sebuah Volume <code>awsElasticBlockStore</code> menambatkan sebuah <a href=http://aws.amazon.com/ebs>Volume EBS</a> Amazon Web Services (AWS) ke dalam Pod kamu. Hal ini berarti bahwa sebuah Volume EBS dapat sebelumnya diisi terlebih dahulu dengan data, dan data dapat "dipindahkan" diantara banyak Pod.</p><div class="alert alert-warning caution callout" role=alert><strong>Perhatian:</strong> Kamu harus membuat sebuah volume EBS menggunakan <code>awscli</code> dengan perintah <code>aws ec2 create-volume</code> atau menggunakan AWS API sebelum kamu dapat menggunakannya.</div><p>Ada beberapa batasan saat menggunakan Volume <code>awsElasticBlockStore</code>:</p><ul><li>Node di mana Pod berjalan haruslah merupakan <em>instance</em> AWS EC2.</li><li><em>Instance</em> tersebut mesti berada pada <em>region</em> <strong>dan</strong> <em>availability-zone</em> yang sama dengan volume EBS.</li><li>EBS hanya mendukung penambatan pada satu <em>instance</em> EC2 pada saat yang bersamaan.</li></ul><h4 id=membuat-sebuah-volume-ebs>Membuat sebuah Volume EBS</h4><p>Sebelum kamu dapat menggunakan sebuah volume EBS pada sebuah Pod, kamu harus membuatnya pada AWS terlebih dahulu.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>aws ec2 create-volume --availability-zone<span style=color:#666>=</span>eu-west-1a --size<span style=color:#666>=</span><span style=color:#666>10</span> --volume-type<span style=color:#666>=</span>gp2
</span></span></code></pre></div><p>Pastikan <em>availability zone</em> yang kamu masukkan sama dengan <em>availability zone</em> klaster kamu. (Dan pastikan juga ukuran dan jenis EBSnya sesuai dengan penggunaan yang kamu butuhkan!)</p><h4 id=contoh-konfigurasi-aws-ebs>Contoh Konfigurasi AWS EBS</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-ebs<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/test-webserver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/test-ebs<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># volume EBS ini harus sudah dibuat di AWS</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>awsElasticBlockStore</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeID</span>:<span style=color:#bbb> </span>&lt;volume-id&gt;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>fsType</span>:<span style=color:#bbb> </span>ext4<span style=color:#bbb>
</span></span></span></code></pre></div><h4 id=migrasi-csi-awselasticblocstore>Migrasi CSI awsElasticBlocStore</h4><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.14 [alpha]</code></div><p>Pada saat fitur migrasi CSI (Container Storage Interface) untuk <code>awsElasticBlockStore</code> diaktifkan, fitur ini akan menterjemahkan semua operasi <em>plugin</em> dari <em>plugin</em> yang sudah ada di kode inti Kubernetes ke bentuk Driver CSI <code>ebs.csi.aws.com</code>. Untuk menggunakan fitur ini, <a href=https://github.com/kubernetes-sigs/aws-ebs-csi-driver>Driver CSI AWS EBS</a> harus dinstal di klaster dan fitur Alpha <code>CSIMigration</code> serta <code>CSIMigrationAWS</code> harus diaktifkan.</p><h3 id=azuredisk>azureDisk</h3><p>Sebuah <code>azureDisk</code> digunakan untuk menambatkan sebuah <a href=https://azure.microsoft.com/en-us/documentation/articles/virtual-machines-linux-about-disks-vhds/>Data Disk</a> Microsoft Azure ke dalam sebuah Pod.</p><p>Selengkapnya dapat ditemukan <a href=https://github.com/kubernetes/examples/tree/main/staging/volumes/azure_disk/README.md>di sini</a>.</p><h4 id=migrasi-csi-azuredisk>Migrasi CSI azureDisk</h4><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.15 [alpha]</code></div><p>Pada saat fitur migrasi CSI untuk <code>azureDisk</code> diaktifkan, fitur ini akan menterjemahkan semua operasi <em>plugin</em> dari <em>plugin</em> yang sudah ada di kode inti Kubernetes ke bentuk Driver CSI <code>disk.csi.azure.com</code>. Untuk menggunakan fitur ini, <a href=https://github.com/kubernetes-sigs/azuredisk-csi-driver>Driver CSI Azure Disk</a> harus dinstal di klaster dan fitur Alpha <code>CSIMigration</code> serta <code>CSIMigrationAzureDisk</code> harus diaktifkan.</p><h3 id=azurefile>azureFile</h3><p>Sebuah <code>azureFile</code> digunakan untuk menambatkan sebuah Microsoft Azure File Volume (SMB 2.1 dan 3.0) ke dalam sebuah Pod.</p><p>Selengkapnya dapat ditemukan <a href=https://github.com/kubernetes/examples/tree/main/staging/volumes/azure_file/README.md>di sini</a>.</p><h4 id=migrasi-csi-azurefile>Migrasi CSI azureFile</h4><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.15 [alpha]</code></div><p>Pada saat fitur migrasi CSI untuk <code>azureFile</code> diaktifkan, fitur ini akan menterjemahkan semua operasi <em>plugin</em> dari <em>plugin</em> yang sudah ada di kode inti Kubernetes ke bentuk Driver CSI <code>file.csi.azure.com</code>. Untuk menggunakan fitur ini, <a href=https://github.com/kubernetes-sigs/azuredisk-csi-driver>Driver CSI Azure File</a> harus dinstal di klaster dan fitur Alpha <code>CSIMigration</code> serta <code>CSIMigrationAzureFile</code> harus diaktifkan.</p><h3 id=cephfs>cephfs</h3><p>Sebuah Volume <code>cephfs</code> memungkinkan sebuah volume CephFS yang sudah ada untuk ditambatkan ke dalam Pod kamu. Berbeda dengan <code>emptyDir</code>, yang juga ikut dihapus saat Pod dihapus, isi data di dalam sebuah volume CephFS akan dipertahankan dan Volume tersebut hanya dilepaskan tambatannya (<em>mount</em>-nya). Hal ini berarti bahwa sebuah Volume CephFS dapat sebelumnya diisi terlebih dahulu dengan data, dan data dapat "dipindahkan" diantara banyak Pod.</p><div class="alert alert-warning caution callout" role=alert><strong>Perhatian:</strong> Kamu harus memiliki server Ceph sendiri dan mengekspor <em>share</em>-nya sebelum kamu dapat menggunakannya.</div><p>Selengkapnya, lihat <a href=https://github.com/kubernetes/examples/tree/main/staging/volumes/cephfs/>contoh CephFS</a>.</p><h3 id=cinder>cinder</h3><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Prasyarat: Kubernetes dengan penyedia layanan <em>cloud</em> OpenStack yang telah dikonfigurasikan. Untuk konfigurasi penyedia layanan <em>cloud</em>, silahkan lihat <a href=https://kubernetes.io/docs/concepts/cluster-administration/cloud-providers/#openstack>penyedia layanan cloud openstack</a>.</div><p><code>cinder</code> digunakan untuk menambatkan Volume Cinder ke dalam Pod kamu.</p><h4 id=contoh-konfigurasi-volume-cinder>Contoh Konfigurasi Volume Cinder</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-cinder<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/test-webserver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-cinder-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/test-cinder<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># Volume OpenStack ini harus sudah ada sebelumnya.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cinder</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeID</span>:<span style=color:#bbb> </span>&lt;volume-id&gt;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>fsType</span>:<span style=color:#bbb> </span>ext4<span style=color:#bbb>
</span></span></span></code></pre></div><h4 id=migrasi-csi-cinder>Migrasi CSI Cinder</h4><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.14 [alpha]</code></div><p>Pada saat fitur migrasi CSI untuk Cinder diaktifkan, fitur ini akan menterjemahkan semua operasi <em>plugin</em> dari <em>plugin</em> yang sudah ada di kode inti Kubernetes ke bentuk Driver CSI <code>cinder.csi.openstack.com</code>. Untuk menggunakan fitur ini, <a href=https://github.com/kubernetes/cloud-provider-openstack/blob/master/docs/using-cinder-csi-plugin.md>Driver CSI Openstack Cinder</a> harus dinstal di klaster dan fitur Alpha <code>CSIMigration</code> serta <code>CSIMigrationOpenStack</code> harus diaktifkan.</p><h3 id=configmap>configMap</h3><p>Sumber daya <a href=/id/docs/tasks/configure-pod-container/configure-pod-configmap/><code>configMap</code></a> memungkinkan kamu untuk menyuntikkan data konfigurasi ke dalam Pod.
Data yang ditaruh di dalam sebuah objek <code>ConfigMap</code> dapat dirujuk dalam sebuah Volume dengan tipe <code>configMap</code> dan kemudian digunakan oleh aplikasi/container yang berjalan di dalam sebuah Pod.</p><p>Saat mereferensikan sebuah objek <code>configMap</code>, kamu tinggal memasukkan nama ConfigMap tersebut ke dalam rincian Volume yang bersangkutan. Kamu juga dapat mengganti <em>path</em> spesifik yang akan digunakan pada ConfigMap. Misalnya, untuk menambatkan ConfigMap <code>log-config</code> pada Pod yang diberi nama <code>configmap-pod</code>, kamu dapat menggunakan YAML ini:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>configmap-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config-vol<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config-vol<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>configMap</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>log-config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>log_level<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>log_level<span style=color:#bbb>
</span></span></span></code></pre></div><p>ConfigMap <code>log-config</code> ditambatkan sebagai sebuah Volume, dan semua isinya yang ditaruh di dalam entri <code>log_level</code>-nya ditambatkan dalam Pod tersebut pada <em>path</em> "<code>/etc/config/log_level</code>".
Perlu dicatat bahwa <em>path</em> tersebut berasal dari isian <code>mountPath</code> pada Volume, dan <code>path</code> yang ditunjuk dengan <code>key</code> bernama <code>log_level</code>.</p><div class="alert alert-warning caution callout" role=alert><strong>Perhatian:</strong> Kamu harus membuat sebuah <a href=/id/docs/tasks/configure-pod-container/configure-pod-configmap/>ConfigMap</a> sebelum kamu dapat menggunakannya.</div><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Sebuah Container yang menggunakan sebuah ConfigMap sebagai tambatan Volume <a href=#menggunakan-subpath>subPath</a> tidak akan menerima pembaruan ConfigMap.</div><h3 id=downwardapi>downwardAPI</h3><p>Sebuah Volume <code>downwardAPI</code> digunakan untuk menyediakan data <code>downward API</code> kepada aplikasi.
Volume ini menambatkan sebuah direktori dan menulis data yang diminta pada berkas-berkas teks biasa.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Sebuah Container yang menggunakan Downward API sebagai tambatan Volume <a href=#menggunakan-subpath>subPath</a> tidak akan menerima pembaruan Downward API.</div><p>Lihat <a href=/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information/>contoh Volume <code>downwardAPI</code></a> untuk lebih detilnya.</p><h3 id=emptydir>emptyDir</h3><p>Sebuah Volume <code>emptyDir</code> pertama kali dibuat saat sebuah Pod dimasukkan ke dalam sebuah Node, dan akan terus ada selama Pod tersebut berjalan di Node tersebut. Sesuai dengan namanya, Volume ini awalnya kosong. Container-container di dalam Pod dapat membaca dan menulis berkas-berkas yang sama di dalam Volume <code>emptyDir</code>, walaupun Volume tersebut dapat ditambatkan pada <code>path</code> yang sama maupun berbeda pada setiap Container. Saat sebuah Pod dihapus dari sebuah Node untuk alasan apapun, data di dalam <code>emptyDir</code> tersebut dihapus untuk selamanya.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Sebuah Container yang gagal <em>TIDAK AKAN</em> menghapus sebuah Pod dari sebuah Node, sehingga data di dalam sebuah <code>emptyDir</code> akan aman jika Container di dalam Podnya gagal.</div><p>Beberapa kegunaan <code>emptyDir</code> adalah sebagai berikut:</p><ul><li><em>Scratch space</em>, misalnya untuk <em>merge sort</em> menggunakan berkas-berkas di <em>disk</em></li><li><em>Checkpointing</em> untuk komputasi panjang yang dipulihkan dari proses yang sebelumnya mengalami kegagalan</li><li>Menyimpan berkas-berkas yang diambil oleh Container aplikasi <em>Content Manager</em> saat sebuah peladen web melayani data tersebut</li></ul><p>Secara bawaan, <code>emptyDir</code> ditaruh pada media penyimpanan apapun yang menyokong Node yang bersangkuta - mungkin sebuah <em>disk</em> atau SSD atau penyimpanan berbasis jaringan, tergantung lingkungan Node yang kamu miliki. Tetapi, kamu juga dapat menyetel bagian <code>emptyDir.medium</code> menjadi <code>"Memory"</code> untuk memberitahukan pada Kubernetes untuk menggunakan sebuah <code>tmpfs</code> (<em>filesystem</em> berbasis RAM) sebagai gantinya. <code>tmpfs</code> memang sangan cepat, tetapi kamu harus sadar bahwa ia tidak seperti <em>disk</em>, data di <code>tmpfs</code> akan terhapus saat Node tersebut diulang kembali. Selain itu, berkas apapun yang kamu tulis akan dihitung terhadap <code>limit</code> <code>memory</code> milik Container kamu.</p><h4 id=contoh-pod>Contoh Pod</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-pd<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/test-webserver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/cache<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cache-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cache-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=fc>fc (fibre channel)</h3><p>Sebuah Volume <code>fc</code> memunginkan sebuah <em>volume</em> <em>fibre channel</em> yang sudah ada untuk ditambatkan ke sebuah Pod.
Kamu dapat menentukan satu atau banyak target <em>World Wide Names</em> menggunakan parameter <code>targetWWNs</code> pada konfigurasi Volume kamu. Jika banyak WWN ditentukan, maka <code>targetWWNs</code> mengharapkan bahwa WWN tersebut berasal dari koneksi <em>multi-path</em>.</p><div class="alert alert-warning caution callout" role=alert><strong>Perhatian:</strong> Sebelumnya, kamu harus mengkonfigurasikan <em>FC SAN Zoning</em> untuk mengalokasikan dan melakukan <em>masking</em> terhadap LUN (<em>volume</em>) tersebut terhadap target WWN sehingga Node-node Kubernetes dapat mengakses mereka.</div><p>Lihat <a href=https://github.com/kubernetes/examples/tree/main/staging/volumes/fibre_channel>Contoh FC</a> untuk lebih detilnya.</p><h3 id=flocker>flocker</h3><p><a href=https://github.com/ClusterHQ/flocker>Flocker</a> adalah sebuah proyek <em>open-source</em> yg berfungsi sebagai pengatur <em>volume</em> data Container yang diklasterkan. Flocker menyediakan pengelolaan dan orkestrasi <em>volume</em> yang disokong oleh banyak jenis media penyimpanan.</p><p>Sebuah Volume <code>flockere</code> memungkinkan sebuah <em>dataset</em> Flocker untuk ditambatkan ke dalam sebuah Pod. Jika <em>dataset</em> tersebut belum ada di dalam Flocker, maka ia harus dibuat terlebih dahulu dengan menggunakan Flocker CLI atau menggunakan Flocker API. Jika <em>dataset</em> tersebut sudah ada, ia akan ditambatkan kembali oleh Flocker ke Node di mana Pod tersebut dijadwalkan. Hal ini berarti data dapat dioper diantara Pod-pod sesuai dengan kebutuhan.</p><div class="alert alert-warning caution callout" role=alert><strong>Perhatian:</strong> Kamu harus memiliki instalasi Flocker yang sudah berjalan sebelum kamu dapat menggunakannya.</div><p>Lihat <a href=https://github.com/kubernetes/examples/tree/main/staging/volumes/flocker>Contoh Flocker</a> untuk lebih detil.</p><h3 id=gcepersistentdisk>gcePersistentDisk</h3><p>Sebuah <em>volume</em> <code>gcePersistentDisk</code> menambatkan sebuah <a href=http://cloud.google.com/compute/docs/disks>PersistentDisk</a> Google Compute Engine (GCE) ke dalam Pod kamu. Tidak seperti <code>emptyDir</code> yang ikut dihapus saat Pod dihapus, isi dari sebuah PD dipertahankan dan <em>volume</em>-nya hanya dilepaskan tambatannya. Hal ini berarti sebuah PD dapat diisi terlebih dahulu dengan data, dan data tersebut dapat "dioper" diantara Pod-pod.</p><div class="alert alert-warning caution callout" role=alert><strong>Perhatian:</strong> Kamu harus membuat sebuah PD menggunakan <code>gcloud</code> atau GCE API atau GCP UI sebelum kamu dapat menggunakannya.</div><p>Ada beberapa batasan saat menggunakan sebuah <code>gcePersistentDisk</code>:</p><ul><li>Node-node di mana Pod-pod berjalan haruslah GCE VM.</li><li>VM tersebut harus berada pada proyek GCE yang sama dan <em>zone</em> yang sama dengan PD tersebut</li></ul><p>Sebuah fitur PD yaitu mereka dapat ditambatkan sebagai <em>read-only</em> secara bersamaan oleh beberapa pengguna. Hal ini berarti kamu dapat mengisi data terlebih dahulu dan menyediakan data tersebut secara paralel untuk sebanyak apapun Pod yang kamu butuhkan. Sayangnya, PD hanya dapat ditambatkan kepada satu pengguna saja pada mode <em>read-write</em> - yaitu, tidak boleh ada banyak penulis secara bersamaan.</p><p>Menggunakan sebuah PD pada sebuah Pod yang diatur oleh sebuah <code>ReplicationController</code> akan gagal, kecuali jika PD tersebut berada pada mode <code>read-only</code>, atau jumlah <code>replica</code>-nya adalah 0 atau 1.</p><h4 id=membuat-sebuah-pd>Membuat sebuah PD</h4><p>Sebelum kamu dapat menggunakan sebuah PD dengan sebuah Pod, kamu harus membuat PD tersebut terlebih dahulu.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>gcloud compute disks create --size<span style=color:#666>=</span>500GB --zone<span style=color:#666>=</span>us-central1-a my-data-disk
</span></span></code></pre></div><h4 id=contoh-pod-1>Contoh Pod</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-pd<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/test-webserver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/test-pd<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># GCE PD ini harus sudah ada.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>gcePersistentDisk</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>pdName</span>:<span style=color:#bbb> </span>my-data-disk<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>fsType</span>:<span style=color:#bbb> </span>ext4<span style=color:#bbb>
</span></span></span></code></pre></div><h4 id=regional-persistent-disks>Regional Persistent Disks</h4><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.10 [beta]</code></div><p>Fitur <a href=https://cloud.google.com/compute/docs/disks/#repds>Regional Persistent Disks</a> memungkinkan pembuatan Persistent Disk yang berada pada beberapa <em>zone</em> pada <em>region</em> yang sama. Untuk menggunakan fitur ini, Volume tersebut harus dibuat sebagai sebuah PersistentVolume; mereferensikan Volume tersebut langsung dari sebuah Pod tidak didukung.</p><h4 id=menyediakan-sebuah-regional-pd-persistentvolume-secara-manual>Menyediakan sebuah Regional PD PersistentVolume Secara Manual</h4><p>Penyediaan secara dinamis mungkin dilakukan dengan sebuah <a href=/id/docs/concepts/storage/storage-classes/#gce-pd>StorageClass untuk GCE PD</a>.
Sebelum membuat sebuah PersistentVolume, kamu harus membuat PD-nya:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>gcloud beta compute disks create --size<span style=color:#666>=</span>500GB my-data-disk
</span></span><span style=display:flex><span>    --region us-central1
</span></span><span style=display:flex><span>    --replica-zones us-central1-a,us-central1-b
</span></span></code></pre></div><p>Contoh spesifikasi PersistentVolume:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>failure-domain.beta.kubernetes.io/zone</span>:<span style=color:#bbb> </span>us-central1-a__us-central1-b<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>capacity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>400Gi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- ReadWriteOnce<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>gcePersistentDisk</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>pdName</span>:<span style=color:#bbb> </span>my-data-disk<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>fsType</span>:<span style=color:#bbb> </span>ext4<span style=color:#bbb>
</span></span></span></code></pre></div><h4 id=migrasi-csi-gce-pd>Migrasi CSI GCE PD</h4><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.14 [alpha]</code></div><p>Pada saat fitur migrasi CSI untuk GCE PD diaktifkan, fitur ini akan menterjemahkan semua operasi <em>plugin</em> dari <em>plugin</em> yang sudah ada di kode inti Kubernetes ke bentuk Driver CSI <code>pd.csi.storage.gke.io</code>. Untuk menggunakan fitur ini, <a href=https://github.com/kubernetes-sigs/gcp-compute-persistent-disk-csi-driver>Driver CSI GCE PD</a> harus dinstal di klaster dan fitur Alpha <code>CSIMigration</code> serta <code>CSIMigrationGCE</code> harus diaktifkan.</p><h3 id=gitrepo>gitRepo (kedaluwarsa)</h3><div class="alert alert-danger warning callout" role=alert><strong>Peringatan:</strong> Tipe Volume <code>gitRepo</code> telah kedaluwarsa. Untuk membuat sebuah Container dengan sebuah <em>git repo</em>, tambatkan sebuah <a href=#emptydir>EmptyDir</a> ke dalam sebuah InitContainer yang akan mengklon <em>repo</em> tersebut menggunakan git, dan kemudian tambatkan <a href=#emptydir>EmptyDir</a> tersebut ke dalam Container Pod tersebut.</div><p>Sebuah Volume <code>gitRepo</code> adalah sebuah percontohan yang menunjukkan apa yang dapat dilakukan dengan <em>plugin</em> volume. Ia menambatkan sebuah direktori kosong dan mengklon sebuah <em>repository</em> git ke dalamnya untuk digunakan oleh Pod kamu. Ke depannya, Volume seperti ini dapat dipindahkan ke model yang bahkan lebih terpisah, daripada melakukan ekstensi pada Kubernetes API untuk setiap kasus serupa.</p><p>Berikut sebuah contoh Volume gitRepo:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>server<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/mypath<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>git-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>git-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>gitRepo</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>repository</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;git@somewhere:me/my-git-repository.git&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>revision</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;22f1d8406d464b0c0874075539c1f2e96c253775&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=glusterfs>glusterfs</h3><p>Sebuah Volume <code>glusterfs</code> memungkinkan sebuah volume <a href=http://www.gluster.org>Glusterfs</a> (sebuah proyek <em>open-source</em> <em>filesystem</em> berbasis jaringan) untuk ditambatkan ke dalam Pod kamu.
Tidak seperti <code>emptyDir</code> yang ikut dihapus saat Pod dihapus, isi dari sebuah <code>glusterfs</code> dipertahankan dan <em>volume</em>-nya hanya dilepaskan tambatannya. Hal ini berarti sebuah <code>glusterfs</code> dapat diisi terlebih dahulu dengan data, dan data tersebut dapat "dioper" diantara Pod-pod. GlusterFS dapat ditambatkan kepada beberapa penulis secara bersamaan.</p><div class="alert alert-warning caution callout" role=alert><strong>Perhatian:</strong> Kamu harus mempunyai instalasi GlusterFS terlebih dahulu sebelum dapat kamu gunakan.</div><p>Lihat <a href=https://github.com/kubernetes/examples/tree/main/staging/volumes/glusterfs>contoh GlusterFS</a> untuk lebih detil.</p><h3 id=hostpath>hostPath</h3><p>Sebuah Volume <code>hostPath</code> menambatkan sebuah berkas atau direktori dari <em>filesystem</em> Node di mana Pod kamu berjalan ke dalam Pod kamu.
Hal ini bukanlah sesuatu yang dibutuhkan oleh sebagian besar Pod kamu, tetapi hal ini menawarkan sebuah mekanisme pintu darurat untuk beberapa aplikasi.</p><p>Contohnya, beberapa kegunaan <code>hostPath</code> adalah sebagai berikut:</p><ul><li>Menjalankan sebuah Container yang membutuhkan akses terhadap sistem dalaman Docker; misalnya menggunakan <code>hostPath</code> dari <code>/var/lib/docker</code></li><li>Menjalankan cAdvisor di dalam sebuah Container; menggunakan <code>hostPath</code> dari <code>/sys</code></li><li>Memungkinkan sebuah Pod untuk merinci apakah <code>hostPath</code> harus sudah ada sebelum dijalankannya Pod, apakah ia harus dibuat, dan sebagai apa ia harus dibuat.</li></ul><p>Sebagai tambahan pada <code>path</code> yang dibutuhkan, pengguna dapat secara opsional merinci <code>type</code> untuk sebuah <code>hostPath</code>.</p><p>Nilai yang didukung untuk kolom <code>type</code> adalah:`</p><table><thead><tr><th style=text-align:left>Nilai</th><th style=text-align:left>Perilaku</th></tr></thead><tbody><tr><td style=text-align:left></td><td style=text-align:left>String kosong (bawaan) adalah untuk kecocokan dengan versi-versi bawah, yang berarti bahwa tidak ada pemeriksaan yang dilakukan sebelum menambatkan Volume hostPath.</td></tr><tr><td style=text-align:left><code>DirectoryOrCreate</code></td><td style=text-align:left>Jika tidak ada yang tersedia pada <code>path</code> yang dirinci, sebuah direktori kosong akan dibuat sesuai kebutuhan, dengan <em>permission</em> yang disetel menjadi 0755, dan mempunyai grup dan kepemilikan yang sama dengan Kubelet.</td></tr><tr><td style=text-align:left><code>Directory</code></td><td style=text-align:left>Sebuah direktori harus sudah tersedia pada <code>path</code> yang dirinci</td></tr><tr><td style=text-align:left><code>FileOrCreate</code></td><td style=text-align:left>Jika tidak ada yang tersedia pada <code>path</code> yang dirinci, maka sebuah berkas kosong akan dibuat sesuai kebutuhan dengan <em>permission</em> yang disetel menjadi 0644, dan mempunyai grup dan kepemilikan yang sama dengan Kubelet.</td></tr><tr><td style=text-align:left><code>File</code></td><td style=text-align:left>Sebuah berkas harus sudah tersedia pada <code>path</code> yang dirinci</td></tr><tr><td style=text-align:left><code>Socket</code></td><td style=text-align:left>Sebuah <em>socket</em> UNIX harus sudah tersedia pada <code>path</code> yang dirinci</td></tr><tr><td style=text-align:left><code>CharDevice</code></td><td style=text-align:left>Sebuah <em>character device</em> sudah tersedia pada <code>path</code> yang dirinci</td></tr><tr><td style=text-align:left><code>BlockDevice</code></td><td style=text-align:left>Sebuah <em>block device</em> harus sudah tersedia pada <code>path</code> yang dirinci</td></tr></tbody></table><p>Berhati-hatilah saat menggunakan tipe volume ini, karena:</p><ul><li>Pod-pod dengan konfigurasi identik (misalnya dibuat dari podTemplate) mungkin berperilaku berbeda pada Node-node yang berbeda oleh karena berkas-berkas yang berbeda pada Node-node tersebut.</li><li>Saat Kubernetes menambahkan penjadwalan yang sadar terhadap sumber-daya klaster, sesuai yang telah direncanakan, ia tidak dapat melakukan perhitungan terhadap sumber daya yang digunakan oleh sebuah <code>hostPath</code></li><li>Berkas-berkas atau direktori-direktori yang dibuat pada <em>host-host</em> bersangkutan hanya dapat ditulis oleh <code>root</code>. Kamu butuh antara menjalankan proses aplikasi kamu sebagai <code>root</code> pada sebuah <a href=/docs/user-guide/security-context>privileged Container</a> atau mengubah <em>permission</em> berkas kamu pada <em>host</em> tersebut agar dapat menulis pada Volume <code>hostPath</code></li></ul><h4 id=contoh-pod-2>Contoh Pod</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-pd<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/test-webserver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/test-pd<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># Lokasi direktori pada host</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/data<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># kolom ini bersifat opsional</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Directory<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=iscsi>iscsi</h3><p>Sebuah Volume <code>iscsi</code> memungkinkan sebuah volume iSCSI (<em>SCSI over IP</em>) yang sudah ada untuk ditambatkan ke dalam Pod kamu.
Tidak seperti <code>emptyDir</code> yang ikut dihapus saat Pod dihapus, isi dari sebuah <code>iscsi</code> dipertahankan dan <em>volume</em>-nya hanya dilepaskan tambatannya. Hal ini berarti sebuah <code>iscsi</code> dapat diisi terlebih dahulu dengan data, dan data tersebut dapat "dioper" diantara Pod-pod.</p><div class="alert alert-warning caution callout" role=alert><strong>Perhatian:</strong> Kamu harus memiliki peladen iSCSI yang berjalan dengan volume iSCSI yang telah dibuat terlebih dahulu untuk dapat menggunakannya.</div><p>Salah satu fitur iSCSI yaitu mereka dapat ditambatkan sebagai <em>read-only</em> secara bersamaan oleh beberapa pengguna. Hal ini berarti kamu dapat mengisi data terlebih dahulu dan menyediakan data tersebut secara paralel untuk sebanyak apapun Pod yang kamu butuhkan. Sayangnya, iSCSI hanya dapat ditambatkan kepada satu pengguna saja pada mode <em>read-write</em> - yaitu, tidak boleh ada banyak penulis secara bersamaan.</p><p>Lihat <a href=https://github.com/kubernetes/examples/tree/main/staging/volumes/iscsi>contoh iSCSI</a> untuk lebih detil.</p><h3 id=local>local</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.14 [stable]</code></div><p>Sebuah Volume <code>local</code> merepresentasikan sebuah media penyimpanan lokal yang ditambatkan, seperti <em>disk</em>, partisi, atau direktori.</p><p>Volume <code>local</code> hanya dapat digunakan sebagai PersistentVolume yang dibuat secara statis. <em>Dynamic provisioning</em> belum didukung untuk Volume <code>local</code>.</p><p>Dibandingkan dengan Volume <code>hostPath</code>, Volume <code>local</code> dapat digunakan secara <em>durable</em> dan portabel tanpa harus menjadwalkan Pod ke Node secara manual, dikarenakan sistem mengetahui pembatasan yang berlaku terhadap Volume pada Node tersebut, dengan cara melihat <code>node affinity</code> pada PersistentVolume-nya.</p><p>Tetapi, Volume <code>local</code> masih bergantung pada ketersediaan Node yang bersangkutan, dan tidak semua aplikasi cocok menggunakannya. Jika sebuah Node tiba-tiba gagal, maka Volume <code>local</code> pada Node tersebut menjadi tidak dapat diakses juga, dan Pod yang menggunakannya tidak dapat dijalankan. Aplikasi yang menggunakan Volume<code>local</code> harus dapat mentoleransi hal ini dan juga potensi kehilangan data, tergantung pada karakteristik ketahanan <em>disk</em> yang digunakan.</p><p>Berikut sebuah contoh spesifikasi PersistentVolume menggunakan sebuah Volume <code>local</code> dan <code>nodeAffinity</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example-pv<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>capacity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>100Gi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># kolom volumeMode membutuhkan diaktifkannya feature gate Alpha</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeMode</span>:<span style=color:#bbb> </span>Filesystem<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- ReadWriteOnce<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>persistentVolumeReclaimPolicy</span>:<span style=color:#bbb> </span>Delete<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>local-storage<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>local</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/mnt/disks/ssd1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodeAffinity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>required</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>nodeSelectorTerms</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>kubernetes.io/hostname<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>- example-node<span style=color:#bbb>
</span></span></span></code></pre></div><p>Kolom <code>nodeAffinity</code> ada PersistentVolue dibutuhkan saat menggunakan Volume <code>local</code>. Ia memungkinkan Kubernetes Scheduler untuk menjadwalkan Pod-pod dengan tepat menggunakan Volume <code>local</code> pada Node yang tepat.</p><p>Kolom <code>volumeMode</code> pada PersistentVolume sekarang dapat disetel menjadi "Block" (menggantikan nilai bawaan "Filesystem") untuk membuka Volume <code>local</code> tersebut sebagai media penyimpanan blok mentah. Hal ini membutuhkan diaktifkannya <em>Alpha feature gate</em> <code>BlockVolume</code>.</p><p>Saat menggunakan Volume <code>local</code>, disarankan untuk membuat sebuah StorageClass dengan <code>volumeBindingMode</code> yang disetel menjadi <code>WaitForFirstConsumer</code>. Lihat<a href=/id/docs/concepts/storage/storage-classes/#local>contohnya</a>. Menunda pengikatan Volume memastikan bahwa keputusan pengikatan PersistentVolumeClaim juga akan dievaluasi terhadap batasan-batasan Node yang berlaku pada Pod, seperti kebutuhan sumber daya Node, <code>nodeSelector</code>, <code>podAffinity</code>, dan <code>podAntiAffinity</code>.</p><p>Sebuah penyedia statis eksternal dapat berjalan secara terpisah untuk memperbaik pengaturan siklus hidup Volume <code>local</code>. Perlu dicatat bahwa penyedia ini belum mendukung <em>dynamic provisioning</em>. Untuk contoh bagaimana menjalankan penyedia Volume <code>local</code> eksternal, lihat <a href=https://github.com/kubernetes-sigs/sig-storage-local-static-provisioner>petunjuk penggunaannya</a>.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> PersistentVolume lokal membutuhkan pembersihan dan penghapusan secara manual oleh pengguna jika penyedia eksternal tidak digunakan untuk mengatur siklus hidup Volume <code>lokal</code> tersebut.</div><h3 id=nfs>nfs</h3><p>Sebuah Volume <code>nfs</code> memungkinkan sebuah NFS (Network File System) yang sudah ada untuk ditambatkan ke dalam Pod kamu.
Tidak seperti <code>emptyDir</code> yang ikut dihapus saat Pod dihapus, isi dari sebuah <code>nfs</code> dipertahankan dan <em>volume</em>-nya hanya dilepaskan tambatannya. Hal ini berarti sebuah <code>nfs</code> dapat diisi terlebih dahulu dengan data, dan data tersebut dapat "dioper" diantara Pod-pod. NFS juga dapat ditambatkan oleh beberapa penulis secara sekaligus.</p><div class="alert alert-warning caution callout" role=alert><strong>Perhatian:</strong> Kamu harus memiliki peladen NFS yang berjalan dengan <em>share</em> yang diekspor sebelum kamu dapat menggunakannya.</div><p>Lihat <a href=https://github.com/kubernetes/examples/tree/main/staging/volumes/nfs>contoh NFS</a> untuk lebih lanjut.</p><h3 id=persistentvolumeclaim>persistentVolumeClaim</h3><p>Sebuah Volume <code>persistentVolumeClaim</code> digunakan untuk menambatkan sebuah <a href=/id/docs/concepts/storage/persistent-volumes/>PersistentVolume</a> ke dalam sebuag Pod. PersistentVolume adalah sebuah cara bagi pengguna untuk "mengklaim" penyimpanan yang <em>durable</em> (seperti sebuah GCE PD atau sebuah volume iSCSI) tanpa mengetahui detil lingkungan <em>cloud</em> yang bersangkutan.</p><p>Lihat <a href=/id/docs/concepts/storage/persistent-volumes/>contoh PersistentVolumes</a> untuk lebih lanjut.</p><h3 id=projected>projected</h3><p>Sebuah Volume <code>projected</code> memetakan beberapa sumber Volume yang sudah ada ke dalam direktori yang sama.</p><p>Saat ini, tipe-tipe sumber Volume berikut dapat diproyeksikan:</p><ul><li><a href=#secret><code>secret</code></a></li><li><a href=#downwardapi><code>downwardAPI</code></a></li><li><a href=#configmap><code>configMap</code></a></li><li><code>serviceAccountToken</code></li></ul><p>Semua sumber harus berada pada <code>namespace</code> yang sama dengan Pod yang menggunakannya. Untuk lebih lanjut, lihat <a href=https://github.com/kubernetes/community/blob/main/contributors/design-proposals/node/all-in-one-volume.md>dokumen desain Volume</a>.</p><p>Proyeksi <code>serviceAccountToken</code> adalah fitur yang diperkenalkan pada Kubernetes 1.11 dan dipromosikan menjadi Beta pada 1.12.
Untuk mengaktifkan fitur inipada 1.11, kamu harus menyetel <a href=/docs/reference/command-line-tools-reference/feature-gates/>feature gate</a> <code>TokenRequestProjection</code> secara eksplisit menjadi <code>True</code>.</p><h4 id=contoh-pod-dengan-sebuah-secret-downward-api-dan-configmap>Contoh Pod dengan sebuah Secret, Downward API, dan ConfigMap.</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>volume-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>container-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>all-in-one<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/projected-volume&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>all-in-one<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>projected</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>sources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>username<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>my-group/my-username<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>downwardAPI</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- <span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;labels&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>fieldRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>fieldPath</span>:<span style=color:#bbb> </span>metadata.labels<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- <span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;cpu_limit&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>resourceFieldRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>containerName</span>:<span style=color:#bbb> </span>container-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>resource</span>:<span style=color:#bbb> </span>limits.cpu<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>configMap</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myconfigmap<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>my-group/my-config<span style=color:#bbb>
</span></span></span></code></pre></div><h4 id=contoh-pod-dengan-banyak-secret-dengan-mode-permission-bukan-bawaan>Contoh Pod dengan banyak Secret dengan mode permission bukan bawaan</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>volume-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>container-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>all-in-one<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/projected-volume&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>all-in-one<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>projected</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>sources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>username<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>my-group/my-username<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>password<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>my-group/my-password<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>mode</span>:<span style=color:#bbb> </span><span style=color:#666>511</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Setiap sumber Volume <code>projected</code> terdaftar pada spesifikasi di kolom <code>sources</code>. Parameter-parameter tersebut hampir sama persis dengan dua pengecualian berikut:</p><ul><li>Untuk Secret, kolom <code>secretName</code> telah diganti menjadi <code>name</code> agar konsisten dengan penamaan ConfigMap.</li><li>Kolom <code>defaultMode</code> hanya dapat dispesifikasikan pada tingkat <code>projected</code> dan tidak untuk setiap sumber Volume. Tetapi, seperti yang ditunjukkan di atas, kamu dapat secara eksplisit menyetel <code>mode</code> untuk setiap proyeksi.</li></ul><p>Saat fitur <code>TokenRequestProjection</code> diaktifkan, kamu dapat menyuntikkan <em>token</em> untuk <a href=/docs/reference/access-authn-authz/authentication/#service-account-tokens>ServiceAccount</a> yang bersangkutan ke dalam Pod pada <code>path</code> yang diinginkan. Berikut contohnya:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>sa-token-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>container-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>token-vol<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/service-account&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>token-vol<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>projected</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>sources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>serviceAccountToken</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>audience</span>:<span style=color:#bbb> </span>api<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>expirationSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>3600</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>token<span style=color:#bbb>
</span></span></span></code></pre></div><p>Contoh Pod tersebut memiliki Volume <code>projected</code> yang berisi token ServiceAccount yang disuntikkan. Token ini dapat digunakan oleh Container dalam Pod untuk mengakses Kubernetes API Server misalnya. Kolom <code>audience</code> berisi audiensi token yang dituju. Sebuah penerima token tersebut harus mengidentifikasikan dirinya dengan tanda pengenal yang dispesifikasikan pada <code>audience</code> token tersebut, atau jika tidak, harus menolak token tersebut. Kolom ini bersifat opsional dan secara bawaan akan berisi tanda pengenal API Server.</p><p>Kolom <code>expirationSeconds</code> adalah masa berlaku yang diinginkan untuk token ServiceAccount tersebut. Secara bawaan, nilainya adalah 1 jam dan harus paling singkat bernilai 10 menit (600 detik). Seorang administrator juga dapat membatasi nilai maksimumnya dengan menyetel opsi <code>--service-account-max-token-expiration</code> pada API Server. Kolom <code>path</code> menunjukkan <em>relative path</em> untuk menambatkan Volume <code>projected</code> tersebut.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Sebuah Container yang menggunakan sebuah sumber Volume <code>projected</code> sebagai tambatan Volume <a href=#menggunakan-subpath>subPath</a> tidak akan menerima pembaruan pada sumber Volume tersebut.</div><h3 id=portworxvolume>portworxVolume</h3><p>Sebuah <code>portworxVolume</code> adalah sebuah penyimpanan blok elastis yang berjalan secara <em>hyperconverged</em> dengan Kubernetes. <a href=https://portworx.com/use-case/kubernetes-storage/>Portworx</a> mengambil sidik jari media penyimpanan pada sebuah <em>server</em>, mengklasifikasikannya berdasarkan kemampuannya, dan mengagregasikan kapasitasnya di banyak <em>server</em>. Portworx berjalan secara <em>in-guest</em> pada mesin virtual atau pada Node Linux <em>bare metal</em>.</p><p>Sebuah <code>portworxVolume</code> dapat dibuat secara dinamis melalui Kubernetes, atau ia juga dapat disediakan terlebih dahulu dan dirujuk dari dalam Pod Kubernetes. Berikut contoh sebuah Pod yang mereferensikan PortworxVolume yang telah disediakan terlebih dahulu:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-portworx-volume-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/test-webserver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/mnt<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pxvol<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pxvol<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># Volume Portworx ini harus sudah tersedia.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>portworxVolume</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeID</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;pxvol&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>fsType</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&lt;fs-type&gt;&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-warning caution callout" role=alert><strong>Perhatian:</strong> Pastikan kamu sudah memiliki PortworxVolume dengan nama <code>pxvol</code> sebelum dapat menggunakannya pada Pod.</div><p>Lihat <a href=https://github.com/kubernetes/examples/tree/main/staging/volumes/portworx/README.md>di sini</a> untuk lebih lanjut.</p><h3 id=quobyte>quobyte</h3><p>Sebuah Volume <code>quobyte</code> memungkinkan sebuah volume <a href=http://www.quobyte.com>Quobyte</a> yang sudah tersedia untuk ditambatkan ke dalam Pod kamu.</p><div class="alert alert-warning caution callout" role=alert><strong>Perhatian:</strong> Kamu harus sudah memiliki instalasi Quobyte dengan volume yang sudah disediakan terlebih dahulu untuk dapat menggunakannya.</div><p>Quobyte mendukung <a class=glossary-tooltip title='The Container Storage Interface (CSI) defines a standard interface to expose storage systems to containers.' data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/#csi target=_blank aria-label='Container Storage Interface'>Container Storage Interface</a>.
CSI adalah <em>plugin</em> yang direkomendasikan untuk menggunakan Volume Quobyte di dalam Kubernetes. Ada <a href=https://github.com/quobyte/quobyte-csi#quobyte-csi>petunjuk dan contoh</a> untuk menggunakan Quobyte menggunakan CSI pada proyek GitHub Quobyte.j</p><h3 id=rbd>rbd</h3><p>Sebuah Volume <code>rbd</code> memungkinkan sebuah volume <a href=http://ceph.com/docs/master/rbd/rbd/>Rados Block Device</a> ditambatkan ke dalam Pod kamu.
Tidak seperti <code>emptyDir</code> yang ikut dihapus saat Pod dihapus, isi dari sebuah <code>rbd</code> dipertahankan dan <em>volume</em>-nya hanya dilepaskan tambatannya. Hal ini berarti sebuah <code>rbd</code> dapat diisi terlebih dahulu dengan data, dan data tersebut dapat "dioper" diantara Pod-pod.</p><div class="alert alert-warning caution callout" role=alert><strong>Perhatian:</strong> Kamu harus memiliki instalasi Ceph yang berjalan sebelum kamu dapat menggunakan RBD.</div><p>Sebuah fitur RBD yaitu mereka dapat ditambatkan sebagai <em>read-only</em> secara bersamaan oleh beberapa pengguna. Hal ini berarti kamu dapat mengisi data terlebih dahulu dan menyediakan data tersebut secara paralel untuk sebanyak apapun Pod yang kamu butuhkan. Sayangnya, RBD hanya dapat ditambatkan kepada satu pengguna saja pada mode <em>read-write</em> - yaitu, tidak boleh ada banyak penulis secara bersamaan.</p><p>Lihat <a href=https://github.com/kubernetes/examples/tree/main/staging/volumes/rbd>contoh RBD</a> untuk lebih lanjut.</p><h3 id=scaleio>scaleIO</h3><p>ScaleIO adalah <em>platform</em> penyimpanan berbasis perangkat lunak yang dapat menggunakan perangkat keras yang sudah tersedia untuk membuat klaster-klaster media penyimpanan terhubung jaringan yang <em>scalable</em>. <em>Plugin</em> Volume <code>scaleIO</code> memungkinkan Pod-pod yang di-<em>deploy</em> untuk mengakses Volume-volume ScaleIO yang telah tersedia (atau dapat menyediakan volume-volume untuk PersistentVolumeClaim secara dinamis, lihat <a href=/id/docs/concepts/storage/persistent-volumes/#scaleio>Persistent Volume ScaleIO</a>).</p><div class="alert alert-warning caution callout" role=alert><strong>Perhatian:</strong> Kamu harus memiliki klaster ScaleIO yang berjalan dengan volume-volume yang sudah dibuat sebelum kamu dapat menggunakannya.</div><p>Berikut contoh konfigurasi sebuah Pod yang menggunakan ScaleIO:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pod-0<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/test-webserver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pod-0<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/test-pd<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>vol-0<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>vol-0<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>scaleIO</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>gateway</span>:<span style=color:#bbb> </span>https://localhost:443/api<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>system</span>:<span style=color:#bbb> </span>scaleio<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>protectionDomain</span>:<span style=color:#bbb> </span>sd0<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storagePool</span>:<span style=color:#bbb> </span>sp1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeName</span>:<span style=color:#bbb> </span>vol-0<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secretRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>sio-secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>fsType</span>:<span style=color:#bbb> </span>xfs<span style=color:#bbb>
</span></span></span></code></pre></div><p>Lihat <a href=https://github.com/kubernetes/examples/tree/main/staging/volumes/scaleio>contoh ScaleIO</a> untuk lebih lanjut.</p><h3 id=secret>secret</h3><p>Sebuah Volume <code>secret</code> digunakan untuk memberikan informasi yang bersifat sensitif, seperti kata sandi, kepada Pod-pod. Kamu dapat menaruh <code>secret</code> dalam Kubernetes API dan menambatkan mereka sebagai berkas-berkas untuk digunakan oleh Pod-pod tanpa harus terikat pada Kubernetes secara langsung. Volume <code>secret</code> didukung oleh tmpfs (<em>filesystem</em> yang didukung oleh RAM) sehingga mereka tidak pernah ditulis pada media penyimpanan yang <em>non-volatile</em>.</p><div class="alert alert-warning caution callout" role=alert><strong>Perhatian:</strong> Kamu harus membuat sebuah <code>secret</code> di dalam Kubernetes API sebelum kamu dapat menggunakannya.</div><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Sebuah Container yang menggunakan sebuah Secret sebagai sebuah Volume <a href=#menggunakan-subpath>subPath</a> tidak akan mendapatkan pembaruan terhadap Secret.</div><p>Secret dijelaskan lebih lanjut <a href=/docs/user-guide/secrets>di sini</a>.</p><h3 id=storageos>storageOS</h3><p>Sebuah Volume <code>storageos</code> memungkinkan volume <a href=https://www.storageos.com>StorageOS</a> yang sudah tersedia untuk ditambatkan ke dalam Pod kamu.</p><p>StorageOS berjalan sebagai sebuah COntainer di dalam lingkungan Kubernetes kamu, membuat penyimpanan yang lokal atau penyimpanan yang sedang dipasang untuk diakses dari Node manapun di dalam klaster Kubernetes.
Data dapat direplikasikan untuk melindungi dari kegagalan Node. <em>Thin provisioning</em> dan kompresi dapat meningkatkan utilisasi dan mengurangi biaya.</p><p>Di dalam intinya, StorageOS menyediakan penyimpanan blok kepada Container-container, yang dapat diakses melalui sebuah <em>filesystem</em>.</p><p>Container StorageOS membutuhkan Linux 64-bit dan tidak memiliki ketergantungan tambahan apapun.
Tersedia pula sebuah lisensi gratis untuk <em>developer</em>.</p><div class="alert alert-warning caution callout" role=alert><strong>Perhatian:</strong> Kamu harus menjalankan Container StorageOS pada setiap Node yang ingin mengakses volume-volume StorageOS atau yang akan berkontribusi pada kapasitas penyimpanan di klaster StorageOS. Untuk petunjuk instalasi, lihat <a href=https://docs.storageos.com>dokumentasi StorageOS</a>.</div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>role</span>:<span style=color:#bbb> </span>master<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-storageos-redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>master<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>kubernetes/redis:v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MASTER<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>6379</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/redis-master-data<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>redis-data<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>redis-data<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storageos</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># Volume `redis-vol01` harus sudah tersedia di dalam StorageOS pada Namespace `default`</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeName</span>:<span style=color:#bbb> </span>redis-vol01<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>fsType</span>:<span style=color:#bbb> </span>ext4<span style=color:#bbb>
</span></span></span></code></pre></div><p>Untuk lebih lanjut, termasuk Dynamic Provisioning dan Persistent Volume Claim, lihat <a href=https://github.com/kubernetes/examples/blob/master/staging/volumes/storageos>contoh-contoh StorageOS</a>.</p><h3 id=vspherevolume>vsphereVolume</h3><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Prasyarat: Kubernetes dengan Cloud Provider vSphere yang telah dikonfigurasikan. Untuk konfigurasi cloudprovider, silahkan lihat <a href=https://vmware.github.io/vsphere-storage-for-kubernetes/documentation/>petunjuk memulai vSphere</a>.</div><p>Sebuah <code>vsphereVolume</code> digunakan untuk menambatkan sebuah Volume VMDK vSphere ke dalam Pod kamu. Isi dari sebuah volume dipertahankan pada saat tambatannya dilepas. Ia mendukung penyimpanan data VMFS dan VSAN.</p><div class="alert alert-warning caution callout" role=alert><strong>Perhatian:</strong> Kamu harus membuat VMDK menggunakan satu dari cara-cara berikut sebelum menggunakannya dengan Pod.</div><h4 id=membuat-sebuah-volume-vmdk>Membuat sebuah Volume VMDK</h4><p>Pilih satu dari beberapa cara berikut untuk membuat sebuah VMDK.</p><ul class="nav nav-tabs" id=tabs-volumes role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tabs-volumes-0 role=tab aria-controls=tabs-volumes-0 aria-selected=true>Create using vmkfstools</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tabs-volumes-1 role=tab aria-controls=tabs-volumes-1>Create using vmware-vdiskmanager</a></li></ul><div class=tab-content id=tabs-volumes><div id=tabs-volumes-0 class="tab-pane show active" role=tabpanel aria-labelledby=tabs-volumes-0><p><p>Pertama-tama, ssh ke dalam ESX, kemudian gunakan perintah berikut untuk membuat sebuah VMDK:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>vmkfstools -c 2G /vmfs/volumes/DatastoreName/volumes/myDisk.vmdk
</span></span></code></pre></div></div><div id=tabs-volumes-1 class=tab-pane role=tabpanel aria-labelledby=tabs-volumes-1><p><p>Gunakan perintah berikut untuk membuat sebuah VMDK:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>vmware-vdiskmanager -c -t <span style=color:#666>0</span> -s 40GB -a lsilogic myDisk.vmdk
</span></span></code></pre></div></div></div><h4 id=contoh-konfigurasi-vsphere-vmdk>Contoh Konfigurasi vSphere VMDK</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-vmdk<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/test-webserver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/test-vmdk<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># Volume VMDK ini harus sudah tersedia.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>vsphereVolume</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumePath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;[DatastoreName] volumes/myDisk&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>fsType</span>:<span style=color:#bbb> </span>ext4<span style=color:#bbb>
</span></span></span></code></pre></div><p>Lebih banyak contoh dapat ditemukan <a href=https://github.com/kubernetes/examples/tree/master/staging/volumes/vsphere>di sini</a>.</p><h2 id=menggunakan-subpath>Menggunakan subPath</h2><p>Terkadang, diperlukan untuk membagi sebuah Volume untuk banyak kegunaan berbeda pada sebuah Pod. Kolom <code>volumeMounts.subPath</code> dapat digunakan untuk merinci sebuah <em>sub-path</em> di dalam Volume yang dimaksud, menggantikan <em>root path</em>-nya.</p><p>Berikut contoh sebuah Pod dengan <em>stack</em> LAMP (Linux Apache Mysql PHP) menggunakan sebuah Volume yang dibagi-bagi.
Isi HTML-nya dipetakan ke dalam direktori <code>html</code>-nya, dan <em>database</em>-nya akan disimpan di dalam direktori <code>mysql</code>-nya.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-lamp-site<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MYSQL_ROOT_PASSWORD<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;rootpasswd&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/lib/mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>site-data<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>subPath</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>php<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>php:7.0-apache<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/www/html<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>site-data<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>subPath</span>:<span style=color:#bbb> </span>html<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>site-data<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>persistentVolumeClaim</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>claimName</span>:<span style=color:#bbb> </span>my-lamp-site-data<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=menggunakan-subpath-dengan-environment-variable-yang-diekspansi>Menggunakan subPath dengan <em>environment variable</em> yang diekspansi</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.15 [beta]</code></div><p>Gunakan kolom <code>subPathExpr</code> untuk membuat nama-nama direktori <code>subPath</code> dari <em>environment variable</em> Downward API.
Sebelum kamu menggunakan fitur ini, kamu harus mengaktifkan <em>feature gate</em> <code>VolumeSubpathEnvExpansion</code>. Kolom <code>subPath</code> dan <code>subPathExpr</code> bersifat <em>mutually exclusive</em>.</p><p>Pada contoh ini, sebuah Pod menggunakan <code>subPathExpr</code> untuk membuat sebuah direktori <code>pod1</code> di dalam Volume hostPath <code>/var/log/pods</code>, menggunakan nama Pod dari Downward API. Direktori <em>host</em> <code>/var/log/pods/pod1</code> ditambatkan pada <code>/logs</code> di dalam Container-nya.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pod1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>container1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>POD_NAME<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>fieldRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>fieldPath</span>:<span style=color:#bbb> </span>metadata.name<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;while [ true ]; do echo &#39;Hello&#39;; sleep 10; done | tee -a /logs/hello.txt&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>workdir1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/logs<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>subPathExpr</span>:<span style=color:#bbb> </span>$(POD_NAME)<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>workdir1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/var/log/pods<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=sumber-sumber>Sumber-sumber</h2><p>Media penyimpanan (Disk, SSD, dll.) dari sebuah Volume <code>emptyDir</code> ditentukan oleh medium dari <em>filesystem</em> yang menyimpan direktori <em>root</em> dari Kubelet (biasanya <code>/var/lib/kubelet</code>). Tidak ada batasan berapa banyak ruang yang dapat digunakan oleh Volume <code>emptyDir</code> dan <code>hostPath</code>, dan tidak ada isolasi antara Container-container atau antara Pod-pod.</p><p>Ke depannya, kita mengharapkan Volume <code>emptyDir</code> dan <code>hostPath</code> akan dapat meminta jumlah ruangan penyimpanan tertentu dengan mengunakan spesifikasi [resource]<a href=/docs/user-guide/compute-resources>resource</a>, dan memilih tipe media penyimpanan yang akan digunakan, untuk klaster yang memiliki beberapa jenis media penyimpanan.</p><h2 id=plugin-volume-yang-out-of-tree><em>Plugin</em> Volume yang Out-of-Tree</h2><p><em>Plugin</em> Volume yang Out-of-tree termasuk Container Storage Interface (CSI) dan Flexvolume. Mereka memungkinkan <em>vendor</em> penyimpanan untuk membuat plugin penyimpanan buatan tanpa perlu menambahkannya pada <em>repository</em> Kubernetes.</p><p>Sebelum dikenalkannya CSI dan Flexvolume, semua <em>plugin</em> volume (seperti jenis-jenis volume yang terdaftar di atas) berada pada "in-tree", yang berarti bahwa mereka dibangun, di-<em>link</em>, di-<em>compile</em>, dan didistribusikan bersama-sama dengan kode inti Kubernetes dan mengekstensi inti dari Kubernetes API. Hal ini berarti menambah sistem penyimpanan baru ke dalam Kubernetes (sebuah <em>plugin</em> volume) membutukan penambahan kode tersebut ke dalam <em>repository</em> kode inti Kubernetes.</p><p>CSI dan Flexvolume memungkinkan <em>plugin</em> volume untuk dikembangkan secara terpisah dari kode inti Kubernetes, dan diinstal pada klaster Kubernetes sebagai ekstensi.</p><p>Bagi <em>vendor-vendor</em> penyimpanan yang ingin membuat sebuah <em>plugin</em> volume yang out-of-tree, lihat <a href=https://github.com/kubernetes/community/blob/master/sig-storage/volume-plugin-faq.md>FAQ ini</a>.</p><h3 id=csi>CSI</h3><p><a href=https://github.com/container-storage-interface/spec/blob/master/spec.md>Container Storage Interface</a> (CSI) mendefinisikan standar antarmuka untuk sistem orkestrasi (seperti Kubernetes) untuk mengekspos sistem penyimpanan apapun ke dalam beban kerja Container mereka.</p><p>Silahkan lihat <a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/container-storage-interface.md>proposal desain CSI</a> untuk lebih lanjut.</p><p>Dukungan untuk CSI dikenalkan sebagai Alpha pada Kubernetes v1.9, dan menjadi Beta pada Kubernetes v1.10, dan menjadi GA pada Kubernetes v1.13.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Dukungan untuk spesifikasi CSI pada versi 0.2 dan 0.3 telah kedaluwarsa pada Kubernetes v1.13 dan akan dihapus pada rilis-rilis di masa depan.</div><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> <em>Driver-driver</em> CSI mungkin tidak cocok pada semua rilis Kubernetes.
Silahkan lihat dokumentasi <em>driver</em> CSI yang bersangkutan untuk petunjuk penggunaan yang didukung untuk setiap rilis Kubernetes, dan untuk melihat matriks kompabilitasnya.</div><p>Saat sebuah <em>driver</em> volume CSI dipasang pada klaster Kubernetes, pengguna dapat menggunakan tipe Volume <code>csi</code> untuk menambatkan volume-volume yang diekspos oleh <em>driver</em> CSI tersebut.</p><p>Tipe Volume <code>csi</code> tidak mendukung referensi secara langsung dari Pod dan hanya dapat dirujuk di dalam sebuah Pod melalui sebuah objek <code>PersistentVolumeClaim</code>.</p><p>Kolom-kolom berikut tersedia untuk administrator-administrator penyimpanan untuk mengkonfigurasi sebuah Persistent Volume CSI.</p><ul><li><code>driver</code>: Sebuah nilai string yang merinci nama dari <em>driver</em> volume yang akan digunakan.
Nilai ini harus sesuai dengan nilai yang dikembalikan oleh <code>GetPluginInfoResponse</code> dari _driver_CSI seperti yang didefinisikan pada <a href=https://github.com/container-storage-interface/spec/blob/master/spec.md#getplugininfo>spesifikasi CSI</a>.
Ia digunakan oleh Kubernetes untuk mengidentifikasikan <em>driver</em> CSI mana yang akan dipanggil, dan oleh komponen <em>driver</em> CSI untuk mengidentifikasikan objek PersistentVolume mana yang dimiliki oleh <em>driver</em> CSI tersebut.</li><li><code>volumeHandle</code>: Sebuah nilai string yang secara unik mengidentifikasikan volume tersebut.
Nilai ini harus sesuai dengan nilai yang dikembalikan oleh kolom <code>volume.id</code> dari <code>CreateVolumeResponse</code> dari <em>driver</em> CSI seperti yang didefinisikan pada <a href=https://github.com/container-storage-interface/spec/blob/master/spec.md#createvolume>spesifikasi CSI</a>.
Nilai tersebut dioper sebagai <code>volume_id</code> pada semua panggilan terhadap <em>driver</em> volume CSI saat mereferensikan volume yang bersangkutan.</li><li><code>readOnly</code>: Sebuah nilai boolean bersifat opsional yang mengindikasikan jika sebuah volume akan dijadikan sebagai "ControllerPublished" (ditambatkan) sebagai <em>read-only</em>.
Nilai bawaannya adalah <code>false</code>. Nilai ini dioper ke <em>driver</em> CSI melalui kolom <code>readonly</code> pada <code>ControllerPublishVolumeRequest</code>.</li><li><code>fsType</code>: Jika nilai <code>VolumeMode</code> milik PV adalah <code>FileSystem</code>, maka kolom ini dapat digunakan untuk menunjukkan <em>filesystem</em> yang akan digunakan untu menambatkan volume tersebut.
Jika volume tersebut belum diformat dan memformat tidak didukung, maka nilai ini akan digunakan untuk memformat volume tersebut. Nilai ini dioper kepada <em>driver</em> CSI melalui kolom <code>VolumeCapability</code> dari <code>ControllerPublishVolumeRequest</code>, <code>NodeStageVolumeRequest</code>, dan <code>NodePublishVolumeRequest</code>.</li><li><code>volumeAttributes</code>: Sebuah <em>map</em> dari string kepada string yang merinci properti statis dari sebuah volume.
Nilai <em>map</em> ini harus sesuai dengan <em>map</em> yang dikembalikan di dalam kolom <code>volume.attributes</code> pada <code>CreateVolumeResponse</code> dari <em>driver</em> CSI seperti yang didefinisikan pada <a href=https://github.com/container-storage-interface/spec/blob/master/spec.md#createvolume>spesifikasi CSI</a>.
<em>Map</em> tersebut dioper kepada <em>driver</em> CSI melalui kolom <code>volume_attributes</code> pada<code>ControllerPublishVolumeRequest</code>, <code>NodeStageVolumeRequests</code>, dan <code>NodePublishVolumeRequest</code>.</li><li><code>controllerPublishSecretRef</code>: Sebuah referensi ke objek Secret yang berisi informasi sensitif untuk diberikan pada <em>driver</em> CSI untuk menyelesaikan panggilan <code>ControllerPublishVolume</code> dan <code>ControllerUnpublishVolume</code>.
Kolom ini bersifat opsional, dan dapat bernilai kosong jika tidak ada Secret yang dibutuhkan. Jika objek Secret berisi lebih dari satu <em>secret</em>, maka semua <em>secret</em> tersebut akan diberikan.</li><li><code>nodeStageSecretRef</code>: Sebuah referensi ke objek Secret yang berisi informasi sensitif untuk diberikan pada <em>driver</em> CSI untuk menyelesaikan panggilan <code>NodeStageVolume</code>. Kolom ini bersifat opsional, dan dapat bernilai kosong jika tidak ada Secret yang dibutuhkan. Jika objek Secret berisi lebih dari satu <em>secret</em>, maka semua <em>secret</em> tersebut akan diberikan.</li><li><code>nodePublishSecretRef</code>: Sebuah referensi ke objek Secret yang berisi informasi sensitif untuk diberikan pada <em>driver</em> CSI untuk menyelesaikan panggilan <code>NodePublishVolume</code>. Kolom ini bersifat opsional, dan dapat bernilai kosong jika tidak ada Secret yang dibutuhkan. Jika objek Secret berisi lebih dari satu <em>secret</em>, maka semua <em>secret</em> tersebut akan diberikan.</li></ul><h4 id=dukungan-csi-untuk-volume-blok-raw>Dukungan CSI untuk volume blok <em>raw</em></h4><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.14 [beta]</code></div><p>Dimulai pada versi 1.11, CSI memperkenalkan dukungak untuk volume blok <em>raw</em>, yang bergantung pada fitur volume blok <em>raw</em> yang dikenalkan pada versi Kubernetes sebelumnya. Fitur ini akan memungkinkan <em>vendor-vendor</em> dengan <em>driver</em> CSI eksternal untuk mengimplementasi dukungan volume blok <em>raw</em> pada beban kerja Kubernetes.</p><p>Dukungan untuk volume blok CSI bersifat <em>feature-gate</em>, tapi secara bawaan diaktifkan. Kedua <em>feature-gate</em> yang harus diaktifkan adalah <code>BlockVolume</code> dan <code>CSIBlockVolume</code>.</p><p>Pelajari cara <a href=/id/docs/concepts/storage/persistent-volumes/#raw-block-volume-support>menyiapkan PV/PVC dengan dukungan volume blok <em>raw</em></a>.</p><h4 id=volume-csi-sementara>Volume CSI Sementara</h4><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.15 [alpha]</code></div><p>FItur ini memungkinkan volume CSI untuk dipasang secara langsung pada spesifikasi Pod, menggantikan spesifikasi pada PersistentVolume. Volume yang dirinci melalui cara ini bersifat sementara tidak akan dipertahankan saat Pod diulang kembali.</p><p>Contoh:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-csi-app<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/data&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-csi-inline-vol<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;sleep&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;1000000&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-csi-inline-vol<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>csi</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>driver</span>:<span style=color:#bbb> </span>inline.storage.kubernetes.io<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeAttributes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>foo</span>:<span style=color:#bbb> </span>bar<span style=color:#bbb>
</span></span></span></code></pre></div><p>Fitur ini memerlukan diaktifkannya <em>feature-gate</em> CSIInlineVolume:</p><pre tabindex=0><code>--feature-gates=CSIInlineVolume=true
</code></pre><p>Volume CSI sementara hanya didukung oleh sebagian dari <em>driver-driver</em> CSI. Silahkan lihat daftar <em>driver</em> CSI <a href=https://kubernetes-csi.github.io/docs/drivers.html>di sini</a>.</p><h1 id=sumber-sumber-untuk-developer>Sumber-sumber untuk <em>developer</em></h1><p>Untuk informasi bagaimana mengembangkan sebuah <em>driver</em> CSI, lihat <a href=https://kubernetes-csi.github.io/docs/>dokumentasi kubernetes-csi</a>.</p><h4 id=migrasi-ke-driver-driver-csi-dari-plugin-in-tree>Migrasi ke <em>driver-driver</em> CSI dari <em>plugin</em> in-tree</h4><h4 id=migrating-to-csi-drivers-from-in-tree-plugins>Migrating to CSI drivers from in-tree plugins</h4><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.14 [alpha]</code></div><p>Fitur CSI Migration, saat diaktifkan, akan mengarahkan operasi-operasi terhadap <em>plugin-plugin</em> in-tree yang sudah ada ke <em>plugin-plugin</em> CSI yang sesuai (yang diharap sudah dipasang dan dikonfigurasi). Fitur ini mengimplementasi logika translasi dan terjemahan yang dibutuhkan untuk mengarahkan ulang operasi-operasi bersangkutan dengan mulus. Hasilnya, operator-operator tidak perlu membuat perubahan konfigurasi apapun pada StorageClass, PV, atau PVC yang sudah ada (mengacu pada <em>plugin</em> in-tree) saat melakukan transisi pada <em>driver</em> CSI yang menggantikan <em>plugin</em> in-tree yang bersangkutan.</p><p>Pada keadaan Alpha, operasi-operasi dan fitur-fitur yang didukung termasuk <em>provisioning/delete</em>, <em>attach/detach</em>, <em>mount/unmount</em>, dan mengubah ukuran volume-volume.</p><p><em>Plugin-plugin</em> in-tree yang mendukung CSI Migration dan mempunyai <em>driver</em> CSI yang sesuai yang telah diimplementasikan terdaftar pada bagian "Jenis-jenis Volume" di atas.</p><h3 id=flexVolume>Flexvolume</h3><p>Flexvolume adalah antarmuka <em>plugin</em> out-of-tree yang telah ada sejak Kubernetes versi 1.2 (sebelum CSI). Ia menggunakan model berbasis <em>exec</em> untuk berhubungan dengan <em>driver-driver</em>. Program <em>driver</em> Flexvolume harus dipasan pada <em>volume plugin path</em> yang telah didefinisikan sebelumnya pada setiap Node (dan pada beberapa kasus, di Master).</p><p>Pod-pod berinteraksi dengan <em>driver-driver</em> Flexvolume melalui <em>plugin</em> in-tree <code>flexvolume</code>.
Untuk lebih lanjut, dapat ditemukan <a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-storage/flexvolume.md>di sini</a>.</p><h2 id=mount-propagation><em>Mount Propagation</em></h2><p><em>Mount propagation</em> memungkinkan berbagi volume-volume yang ditambatkan oleh sebuah Container kepada Container-container lain di dalam Pod yang sama, atau bahkan pada Pod lainnya di dalam Node yang sama.</p><p><em>Mount propagation</em> dari sebuah volume diatur oleh kolom <code>mountPropagation</code> di dalam <code>Container.volumeMounts</code>.
Nilai-nilainya adalah sebagai berikut:</p><ul><li><p><code>None</code> - Tambatan volume ini tidak akan menerima apapun tambatan selanjutnya yang ditambatkan pada volume ini atau apapun sub-direktori yang dimilikinya oleh <em>host</em>.
Dengan cara yang sama, tidak ada tambatan yang dibuat oleh Container yang dapat terlihat pada <em>host</em>. Ini adalah mode bawaan.</p><p>Mode ini setara dengan <em>mount propagation</em> <code>private</code>, seperti yang dideskripsikan pada <a href=https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt>dokumentasi kernel Linux</a></p></li><li><p><code>HostToContainer</code> - Tambatan volume ini akan menerima semua tambatan selanjutnya yang ditambatkan pada volume ini atau pada apapun sub-direktori yang dimilikinya.</p><p>Dalam kata lain, jika <em>host</em> yang bersangkutan menambatkan apapun di dalam tambatan volume, Container akan melihatnya ditambatkan di sana.</p><p>Secara serupa, jika ada Pod dengan <em>mount propagation</em> <code>Bidirectional</code> terhadap volume yang sama menambatkan apapun ke situ, maka Container dengan <em>mount propagation</em> <code>HostToContainer</code> akan melihatnya.</p><p>Mode ini setara dengan <em>mount propagation</em> <code>rslave</code>, seperti yang dideskripsikan pada <a href=https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt>dokumentasi kernel Linux</a></p></li><li><p><code>Bidirectional</code> - Tambatan volume ini memiliki perilaku yang sama dengan tambatan <code>HostToContainer</code>.
Sebagai tambahannya, semua tambatan volume yang dibuat oleh Container akan dipropagasi kembali kepada <em>host</em> yang bersangkutan dan ke semua Container dari semua Pod yang menggunakan volume yang sama.</p><p>Contoh kasus umum untuk mode ini adalah Pod dengan sebuah Flexvolume atau <em>driver</em> CSI atau sebuah Pod yang perlu menambatkan sesuatu pada <em>host</em>-nya dengan menggunakan Volume <code>hostPath</code>.</p><p>Mode ini setara dengan <em>mount propagation</em> <code>rshared</code>, seperti yang dideskripsikan pada <a href=https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt>dokumentasi kernel Linux</a></p></li></ul><div class="alert alert-warning caution callout" role=alert><strong>Perhatian:</strong> <em>Mount propagation</em> <code>Bidirectional</code> bisa jadi berbahaya. Ia dapat merusak sistem operasi <em>host</em>-nya, sehingga hanya diizinkan pada Container yang <em>privileged</em>. Keterbiasaan dengan perilaku kernel Linux sangat dianjurkan.
Sebagai tambahan, tambatan volume apapun yang dibuat oleh Container-container di dalam Pod-pod harus dihancurkan (dilepaskan tambatannya) oleh Container-container pada saat terminasi.</div><h3 id=konfigurasi>Konfigurasi</h3><p>Sebelum <em>mount propagation</em> dapat bekerja dengan baik pada beberapa instalasi (CoreOS, RedHat/Centos, Ubuntu), <em>mount share</em> harus dikonfigurasi dengan benar pada Docker, seperti yang ditunjukkan di bawah.</p><p>Sunting berkas servis <code>systemd</code> Docker kamu. Setel <code>MountFlags</code> sebagai berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#b8860b>MountFlags</span><span style=color:#666>=</span>shared
</span></span></code></pre></div><p>Atau, hapus <code>MountFlags=slave</code> jika ada. Kemudian, ulang kembali <em>daemon</em> Docker-nya:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sudo systemctl daemon-reload
</span></span><span style=display:flex><span>sudo systemctl restart docker
</span></span></code></pre></div><h2 id=selanjutnya>Selanjutnya</h2><ul><li>Ikuti contoh <a href=/docs/tutorials/stateful-application/mysql-wordpress-persistent-volume/>memasang WordPress dan MySQL dengan Persistent Volume</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-ffd12528a12882b282e1bd19e29f9e75>3.6.2 - Persistent Volume</h1><p>Dokumen ini menjelaskan kondisi terkini dari <code>PersistentVolumes</code> pada Kubernetes. Disarankan telah memiliki familiaritas dengan <a href=/id/docs/concepts/storage/volumes/>volume</a>.</p><h2 id=pengenalan>Pengenalan</h2><p>Mengelola penyimpanan adalah hal yang berbeda dengan mengelola komputasi. Sub-sistem <code>PersistentVolume</code> (PV) menyediakan API untuk para pengguna dan administrator yang mengabstraksi detail-detail tentang bagaimana penyimpanan disediakan dari bagaimana penyimpanan dikonsumsi. Untuk melakukan ini, kami mengenalkan dua sumber daya API baru: <code>PersistentVolume</code> (PV) dan <code>PersistentVolumeClaim</code> (PVC).</p><p>Sebuah <code>PersistentVolume</code> (PV) adalah suatu bagian dari penyimpanan pada klaster yang telah disediakan oleh seorang administrator. PV merupakan sebuah sumber daya pada klaster sama halnya dengan <em>node</em> yang juga merupakan sumber daya klaster. PV adalah <em>volume plugin</em> seperti <em>Volumes</em>, tetapi memiliki siklus hidup yang independen dari <em>pod</em> individual yang menggunakan PV tersebut. Objek API ini menangkap detail-detail implementasi dari penyimpanan, seperti NFS, iSCSI, atau sistem penyimpanan yang spesifik pada penyedia layanan <em>cloud</em>.</p><p>Sebuah <code>PersistentVolumeClaim</code> (PVC) merupakan permintaan penyimpanan oleh pengguna. PVC mirip dengan sebuah <em>pod</em>. <em>Pod</em> mengonsumsi sumber daya <em>node</em> dan PVC mengonsumsi sumber daya PV. <em>Pods</em> dapat meminta taraf-taraf spesifik dari sumber daya (CPU dan Memory). Klaim dapat meminta ukuran dan mode akses yang spesifik (seperti, dapat dipasang sekali sebagai <em>read/write</em> atau lain kali sebagai <em>read-only</em>).</p><p>Meskipun <code>PersistentVolumeClaims</code> mengizinkan pengguna untuk mengkonsumsi sumber daya penyimpanan
abstrak, pada umumnya para pengguna membutuhkan <code>PersistentVolumes</code> dengan properti yang
bermacam-macam, seperti performa, untuk mengatasi masalah yang berbeda. Para administrator klaster
harus dapat menawarkan berbagai macam <code>PersistentVolumes</code> yang berbeda tidak hanya pada ukuran dan
mode akses, tanpa memaparkan detail-detail bagaimana cara volume tersebut diimplementasikan
kepada para pengguna. Untuk mengatasi hal ini maka dibutuhkan sumber daya
<code>StorageClass</code>.</p><p>Silakan lihat <a href=/id/docs/tasks/configure-pod-container/configure-persistent-volume-storage/>panduan mendetail dengan contoh-contoh yang sudah berjalan</a>.</p><h2 id=siklus-hidup-dari-sebuah-volume-dan-klaim>Siklus hidup dari sebuah volume dan klaim</h2><p>PV adalah sumber daya dalam sebuah klaster. PVC adalah permintaan terhadap sumber daya tersebut dan juga berperan sebagai pemeriksaan klaim dari sumber daya yang diminta. Interaksi antara PV dan PVC mengikuti siklus hidup berikut ini:</p><h3 id=penyediaan>Penyediaan</h3><p>Ada dua cara untuk menyediakan PV: secara statis atau dinamis.</p><h4 id=statis>Statis</h4><p>Seorang administrator klaster membuat beberapa PV. PV yang telah dibuat membawa detail-detail dari penyimpanan yang sesungguhnya tersedia untuk digunakan oleh pengguna klaster. PV tersebut ada pada Kubernetes API dan siap untuk digunakan.</p><h4 id=dinamis>Dinamis</h4><p>Ketika tidak ada PV statis yang dibuat oleh administrator yang sesuai dengan <code>PersistentVolumeClaim</code> (PVC) yang dibuat oleh pengguna, klaster akan mencoba untuk menyediakan volume khusus sesuai permintaan PVC.
Penyediaan dinamis ini berbasis <code>StorageClass</code>: artinya PVC harus meminta sebuah <em>storage class</em> dan <em>storage class</em> tersebut harus sudah dibuat dan dikonfigurasi oleh administrator agar penyediaan dinamis bisa terjadi. Klaim yang meminta PV dengan <em>storage class</em> <code>""</code> secara efektif telah menonaktifkan penyediaan dinamis.</p><p>Untuk mengaktifkan penyediaan <em>storage</em> dinamis berdasarkan <em>storage class</em>, administrator klaster harus mengaktifkan <a href=/docs/reference/access-authn-authz/admission-controllers/#defaultstorageclass><em>admission controller</em></a>
<code>DefaultStorageClass</code> pada API <em>server</em>. Hal ini dapat dilakukan, dengan cara memastikan <code>DefaultStorageClass</code> ada di antara urutan daftar <em>value</em> yang dibatasi koma untuk <em>flag</em> <code>--enable-admission-plugins</code> pada komponen API <em>server</em>. Untuk informasi lebih lanjut mengenai <em>flag</em> perintah pada API <em>server</em>, silakan cek dokumentasi,
<a href=/docs/admin/kube-apiserver/>kube-apiserver</a>.</p><h3 id=pengikatan>Pengikatan</h3><p>Seorang pengguna membuat, atau telah membuat (dalam kasus penyediaan dinamis), sebuah <code>PersistentVolumeClaim</code> (PVC) dengan jumlah penyimpanan spesifik yang diminta dan dengan mode akses tertentu. Sebuah <em>control loop</em> pada <em>master</em> akan melihat adanya PVC baru, mencari PV yang cocok (jika memungkinkan), dan mengikat PVC dengan PV tersebut. Jika sebuah PV disediakan secara dinamis untuk sebuah PVC baru, <em>loop</em> tersebut akan selalu mengikat PV tersebut pada PVC yang baru dibuat itu. Jika tidak, pengguna akan selalu mendapatkan setidaknya apa yang dimintanya, tetapi volume tersebut mungkin lebih dari apa yang diminta sebelumnya. Setelah terikat, ikatan <code>PersistentVolumeClaim</code> (PVC) bersifat eksklusif, terlepas dari bagaimana caranya mereka bisa terikat. Sebuah ikatan PVC ke PV merupakan pemetaan satu ke satu.</p><p>Klaim akan berada dalam kondisi tidak terikat tanpa kepastian jika tidak ada volume yang cocok. Klaim akan terikat dengan volume yang cocok ketika ada volume yang cocok. Sebagai contoh, sebuah klaster yang sudah menyediakan banyak PV berukuran 50Gi tidak akan cocok dengan PVC yang meminta 100Gi. PVC hanya akan terikat ketika ada PV 100Gi yang ditambahkan ke klaster.</p><h3 id=penggunaan>Penggunaan</h3><p><em>Pod</em> menggunakan klaim sebagai volume. Klaster menginspeksi klaim untuk menemukan volume yang terikat dengan klaim tersebut dan memasangkan volume tersebut ke pada <em>pod</em>. Untuk volume yang mendukung banyak mode akses, pengguna yang menentukan mode yang diinginkan ketika menggunakan klaim sebagai volume dalam sebuah <em>pod</em>.</p><p>Ketika pengguna memiliki klaim dan klaim tersebut telah terikat, PV yang terikat menjadi hak penggunanya selama yang dibutuhkan. Pengguna menjadwalkan <em>pod</em> dan mengakses PV yang sudah diklaim dengan menambahkan <code>persistentVolumeClaim</code> pada blok volume pada <em>Pod</em> miliknya. <a href=#claims-as-volumes>Lihat pranala di bawah untuk detail-detail mengenai sintaks</a>.</p><h3 id=object-penyimpanan-dalam-perlindungan-penggunaan>Object Penyimpanan dalam Perlindungan Penggunaan</h3><p>Tujuan dari Objek Penyimpanan dalam Perlindungan Penggunan adalah untuk memastikan <em>Persistent Volume Claim</em> (PVC) yang sedang aktif digunakan oleh sebuah <em>pod</em> dan <em>Persistent Volume</em> (PV) yang terikat pada PVC tersebut tidak dihapus dari sistem karena hal ini dapat menyebabkan kehilangan data.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> PVC dikatakan aktif digunakan oleh sebuah <em>pod</em> ketika sebuah objek <em>pod</em> ada yang menggunakan PVC tersebut.</div><p>Jika seorang pengguna menghapus PVC yang sedang aktif digunakan oleh sebuah <em>pod</em>, PVC tersebut tidak akan langsung dihapus. Penghapusan PVC akan ditunda sampai PVC tidak lagi aktif digunakan oleh <em>pod</em> manapun, dan juga ketika admin menghapus sebuah PV yang terikat dengan sebuah PVC, PV tersebut tidak akan langsung dihapus. Penghapusan PV akan ditunda sampai PV tidak lagi terikat dengan sebuah PVC.</p><p>Kamu dapat melihat PVC yang dilindungi ketika status PVC berisi <code>Terminating</code> dan daftar <code>Finalizers</code> meliputi <code>kubernetes.io/pvc-protection</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe pvc hostpath
</span></span><span style=display:flex><span>Name:          hostpath
</span></span><span style=display:flex><span>Namespace:     default
</span></span><span style=display:flex><span>StorageClass:  example-hostpath
</span></span><span style=display:flex><span>Status:        Terminating
</span></span><span style=display:flex><span>Volume:
</span></span><span style=display:flex><span>Labels:        &lt;none&gt;
</span></span><span style=display:flex><span>Annotations:   volume.beta.kubernetes.io/storage-class<span style=color:#666>=</span>example-hostpath
</span></span><span style=display:flex><span>               volume.beta.kubernetes.io/storage-provisioner<span style=color:#666>=</span>example.com/hostpath
</span></span><span style=display:flex><span>Finalizers:    <span style=color:#666>[</span>kubernetes.io/pvc-protection<span style=color:#666>]</span>
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>Kamu dapat melihat sebuah PV dilindungi ketika status PV berisi <code>Terminating</code> dan daftar <code>Finalizers</code> juga meliputi <code>kubernetes.io/pv-protection</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe pv task-pv-volume
</span></span><span style=display:flex><span>Name:            task-pv-volume
</span></span><span style=display:flex><span>Labels:          <span style=color:#b8860b>type</span><span style=color:#666>=</span><span style=color:#a2f>local</span>
</span></span><span style=display:flex><span>Annotations:     &lt;none&gt;
</span></span><span style=display:flex><span>Finalizers:      <span style=color:#666>[</span>kubernetes.io/pv-protection<span style=color:#666>]</span>
</span></span><span style=display:flex><span>StorageClass:    standard
</span></span><span style=display:flex><span>Status:          Available
</span></span><span style=display:flex><span>Claim:
</span></span><span style=display:flex><span>Reclaim Policy:  Delete
</span></span><span style=display:flex><span>Access Modes:    RWO
</span></span><span style=display:flex><span>Capacity:        1Gi
</span></span><span style=display:flex><span>Message:
</span></span><span style=display:flex><span>Source:
</span></span><span style=display:flex><span>    Type:          HostPath <span style=color:#666>(</span>bare host directory volume<span style=color:#666>)</span>
</span></span><span style=display:flex><span>    Path:          /tmp/data
</span></span><span style=display:flex><span>    HostPathType:
</span></span><span style=display:flex><span>Events:            &lt;none&gt;
</span></span></code></pre></div><h3 id=melakukan-reklaim>Melakukan Reklaim</h3><p>Ketika seorang pengguna telah selesai dengan volumenya, ia dapat menghapus objek PVC dari API yang memungkinkan untuk reklamasi dari sumber daya tersebut. Kebijakan reklaim dari sebuah <code>PersistentVolume</code> (PV) menyatakan apa yang dilakukan klaster setelah volume dilepaskan dari klaimnya. Saat ini, volume dapat dipertahankan (<em>Retained</em>), didaur ulang (<em>Recycled</em>), atau dihapus (<em>Deleted</em>).</p><h4 id=retain><em>Retain</em></h4><p><code>Retain</code> merupakan kebijakan reklaim yang mengizinkan reklamasi manual dari sebuah sumber daya. Ketika <code>PersistentVolumeClaim</code> (PVC) dihapus, <code>PersistentVolume</code> (PV) masih akan tetap ada dan volume tersebut dianggap "terlepas" . Tetapi PV tersebut belum tersedia untuk klaim lainnya karena data milik pengklaim sebelumnya masih terdapat pada volume. Seorang administrator dapat mereklaim volume secara manual melalui beberapa langkah.</p><ol><li>Menghapus <code>PersistentVolume</code> (PV). Aset <em>storage</em> yang terasosiasi dengan infrastruktur eksternal (seperti AWS EBS, GCE PD, Azure Disk, atau Cinder Volume) akan tetap ada setelah PV dihapus.</li><li>Secara manual membersihkan data pada aset <em>storage</em> terkait.</li><li>Secara manual menghapus aset <em>storage</em>, atau jika kamu ingin menggunakan aset <em>storage</em> yang sama, buatlah sebuah <code>PersistentVolume</code> baru dengan definisi aset <em>storage</em> tersebut.</li></ol><h4 id=delete><em>Delete</em></h4><p>Untuk <em>volume plugin</em> yang mendukung kebijakan reklaim <code>Delete</code>, penghapusan akan menghilangkan kedua objek dari Kubernetes, <code>PersistentVolume</code> (PV) dan juga aset <em>storage</em> yang terasosiasi pada infrastruktur eksternal seperti, AWS EBS, GCE PD, Azure Disk, atau Cinder Volume. Volume yang disediakan secara dinamis mewarisi <a href=#reclaim-policy>kebijakan reklaim dari <code>StorageClass</code> miliknya</a>, yang secara bawaan adalah <code>Delete</code>. Administrator harus mengkonfigurasi <code>StorageClass</code> sesuai ekspektasi pengguna, jika tidak maka PV tersebut harus diubah atau ditambal setelah dibuat nanti. Lihat <a href=/docs/tasks/administer-cluster/change-pv-reclaim-policy/>Mengganti Kebijakan Reklaim pada PersistentVolume</a>.</p><h4 id=recycle><em>Recycle</em></h4><div class="alert alert-danger warning callout" role=alert><strong>Peringatan:</strong> Kebijakan reklaim <code>Recycle</code> sudah ditinggalkan. Sebagai gantinya, pendekatan yang direkomendasikan adalah menggunakan penyediaan dinamis.</div><p>Jika didukung oleh <em>plugin volume</em> yang berada di baliknya, kebijakan reklaim <code>Recycle</code> melakukan penghapusan dasar (<code>rm -rf /thevolume/*</code>) pada volume dan membuatnya kembali tersedia untuk klaim baru.</p><p>Namun, seorang administrator dapat mengkonfigurasi templat <em>recycler pod</em> kustom menggunakan argumen baris perintah <em>controller manager</em> Kubernetes sebagaimana dijelaskan <a href=/docs/admin/kube-controller-manager/>di sini</a>. Templat <em>reycler pod</em> kustom harus memiliki spesifikasi <code>volumes</code>, seperti yang ditunjukkan pada contoh di bawah:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pv-recycler<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>vol<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/any/path/it/will/be/replaced<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pv-recycler<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;k8s.gcr.io/busybox&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;/bin/sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;test -e /scrub &amp;&amp; rm -rf /scrub/..?* /scrub/.[!.]* /scrub/*  &amp;&amp; test -z \&#34;$(ls -A /scrub)\&#34; || exit 1&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>vol<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/scrub<span style=color:#bbb>
</span></span></span></code></pre></div><p>Namun, alamat yang dispesifikasikan pada templat <em>recycler pod</em> kustom pada bagian <code>volumes</code> diganti dengan alamat pada volume yang akan didaur ulang.</p><h3 id=memperluas-persistent-volumes-claim>Memperluas <em>Persistent Volumes Claim</em></h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.11 [beta]</code></div><p>Dukungan untuk memperluas PersistentVolumeClaim (PVC) sekarang sudah diaktifkan sejak awal. Kamu dapat memperluas
tipe-tipe volume berikut:</p><ul><li>gcePersistentDisk</li><li>awsElasticBlockStore</li><li>Cinder</li><li>glusterfs</li><li>rbd</li><li>Azure File</li><li>Azure Disk</li><li>Portworx</li><li>FlexVolumes</li><li>CSI</li></ul><p>Kamu hanya dapat memperluas sebuah PVC jika kolom <code>allowVolumeExpansion</code> dipasang sebagai benar pada <em>storage class</em> miliknya.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>gluster-vol-default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/glusterfs<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resturl</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;http://192.168.10.100:8080&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restuser</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>secretNamespace</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>allowVolumeExpansion</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Untuk meminta volume yang lebih besar pada sebuah PVC, ubah objek PVC dan spesifikasikan ukuran yang lebih
besar. Hal ini akan memicu perluasan dari volume yang berada di balik <code>PersistentVolume</code> (PV). Sebuah
<code>PersistentVolume</code> (PV) baru tidak akan dibuat untuk memenuhi klaim tersebut. Sebaliknya, volume yang sudah ada akan diatur ulang ukurannya.</p><h4 id=perluasan-volume-csi>Perluasan Volume CSI</h4><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.14 [alpha]</code></div><p>Perluasan volume CSI mengharuskan kamu untuk mengaktifkan gerbang fitur <code>ExpandCSIVolumes</code> dan juga membutuhkan <em>driver</em> CSI yang spesifik untuk mendukung perluasan volume. Silakan merujuk pada dokumentasi <em>driver</em> spesifik CSI untuk informasi lebih lanjut.</p><h4 id=mengubah-ukuran-sebuah-volume-yang-memiliki-file-system>Mengubah ukuran sebuah volume yang memiliki <em>file system</em></h4><p>Kamu hanya dapat mengubah ukuran volume yang memiliki <em>file system</em> jika <em>file system</em> tersebut adalah XFS, Ext3, atau Ext4.</p><p>Ketika sebuah volume memiliki <em>file system</em>, <em>file system</em> tersebut hanya akan diubah ukurannya ketika sebuah <em>pod</em> baru dinyalakan menggunakan
<code>PersistentVolumeClaim</code> (PVC) dalam mode <em>ReadWrite</em>. Maka dari itu, jika sebuah <em>pod</em> atau <em>deployment</em> menggunakan sebuah volume dan
kamu ingin memperluasnya, kamu harus menghapus atau membuat ulang <em>pod</em> tersebut setelah volume selesai diperluas oleh penyedia <em>cloud</em> dalam <em>controller-manager</em>. Kamu dapat melihat status dari operasi pengubahan ukuran dengan menjalankan perintah <code>kubectl describe pvc</code>:</p><pre tabindex=0><code>kubectl describe pvc &lt;pvc_name&gt;
</code></pre><p>Jika <code>PersistentVolumeClaim</code> (PVC) memiliki status <code>FileSystemResizePending</code>, maka berarti aman untuk membuat ulang <em>pod</em> menggunakan PersistentVolumeClaim (PVC) tersebut.</p><p>FlexVolumes mengizinkan pengubahan ukuran jika <em>driver</em> diatur dengan kapabilitas <code>RequiresFSResize</code> menjadi "<em>true</em>".
FlexVolume dapat diubah ukurannya pada saat <em>pod</em> mengalami <em>restart</em>.</p><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.11 [alpha]</code></div><h4 id=mengubah-ukuran-persistentvolumeclaim-pvc-yang-sedang-digunakan>Mengubah ukuran PersistentVolumeClaim (PVC) yang sedang digunakan</h4><p>Memperluas PVC yang sedang digunakan merupakan fitur alfa. Untuk menggunakannya, aktifkan gerbang fitur <code>ExpandInUsePersistentVolumes</code>.
Pada kasus ini, kamu tidak perlu menghapus dan membuat ulang sebuah <em>Pod</em> atau <em>deployment</em> yang menggunakan PVC yang telah ada.
PVC manapun yang sedang digunakan secara otomatis menjadi tersedia untuk <em>pod</em> yang menggunakannya segera setelah <em>file system</em> miliknya diperluas.
Fitur ini tidak memiliki efek pada PVC yang tidak sedang digunakan oleh <em>Pod</em> atau <em>deployment</em>. Kamu harus membuat sebuah <em>Pod</em> yang
menggunakan PVC sebelum perluasan dapat selesai dilakukan.</p><p>Memperluas PVC yang sedang digunakan sudah ditambahkan pada rilis 1.13. Untuk mengaktifkan fitur ini gunakan <code>ExpandInUsePersistentVolumes</code> dan gerbang fitur <code>ExpandPersistentVolumes</code>. Gerbang fitur <code>ExpandPersistentVolumes</code> sudah diaktifkan sejak awal. Jika <code>ExpandInUsePersistentVolumes</code> sudah terpasang, FlexVolume dapat diubah ukurannya secara langsung tanpa perlu melakukan <em>restart</em> pada <em>pod</em>.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Pengubahan ukuran FlexVolume hanya mungkin dilakukan ketika <em>driver</em> yang menjalankannya mendukung pengubahan ukuran.</div><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Memperluas volume EBS merupakan operasi yang memakan waktu. Terlebih lagi, ada kuota per volume untuk satu kali modifikasi setiap 6 jam.</div><h2 id=tipe-tipe-persistent-volume>Tipe-tipe <em>Persistent Volume</em></h2><p>Tipe-tipe <code>PersistentVolume</code> (PV) diimplementasikan sebagai <em>plugin</em>. Kubernetes saat ini mendukung <em>plugin</em> berikut:</p><ul><li>GCEPersistentDisk</li><li>AWSElasticBlockStore</li><li>AzureFile</li><li>AzureDisk</li><li>FC (Fibre Channel)</li><li>FlexVolume</li><li>Flocker</li><li>NFS</li><li>iSCSI</li><li>RBD (Ceph Block Device)</li><li>CephFS</li><li>Cinder (OpenStack block storage)</li><li>Glusterfs</li><li>VsphereVolume</li><li>Quobyte Volumes</li><li>HostPath (Hanya untuk pengujian <em>single node</em> -- penyimpanan lokal tidak didukung dan TIDAK AKAN BEKERJA pada klaster <em>multi-node</em>)</li><li>Portworx Volumes</li><li>ScaleIO Volumes</li><li>StorageOS</li></ul><h2 id=persistent-volume><em>Persistent Volume</em></h2><p>Setiap PV memiliki sebuah <em>spec</em> dan status, yang merupakan spesifikasi dan status dari volume tersebut.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pv0003<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>capacity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>5Gi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeMode</span>:<span style=color:#bbb> </span>Filesystem<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>persistentVolumeReclaimPolicy</span>:<span style=color:#bbb> </span>Recycle<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>slow<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>mountOptions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- hard<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- nfsvers=4.1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nfs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/tmp<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>server</span>:<span style=color:#bbb> </span><span style=color:#666>172.17.0.2</span><span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Program pembantu yang berkaitan dengan tipe volume bisa saja diperlukan untuk mengonsumsi sebuah PersistentVolume di dalam klaster. Contoh ini menggunakan PersistentVolume dengan tipe NFS dan program pembantu /sbin/mount.nfs diperlukan untuk mendukung proses mounting sistem berkas (filesystem) NFS.</div><h3 id=kapasitas>Kapasitas</h3><p>Secara umum, sebuah PV akan memiliki kapasitas <em>storage</em> tertentu. Hal ini ditentukan menggunakan atribut <code>capacity</code> pada PV. Lihat <a href=https://git.k8s.io/community/contributors/design-proposals/scheduling/resources.md>Model Sumber Daya</a> Kubernetes untuk memahami satuan yang diharapkan pada atribut <code>capacity</code>.</p><p>Saat ini, ukuran <em>storage</em> merupakan satu-satunya sumber daya yang dapat ditentukan atau diminta. Atribut-atribut lainnya di masa depan dapat mencakup IOPS, <em>throughput</em>, dsb.</p><h3 id=mode-volume>Mode Volume</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.13 [beta]</code></div><p>Sebelum Kubernetes 1.9, semua <em>volume plugin</em> akan membuat sebuah <em>filesystem</em> pada PersistentVolume (PV).
Sekarang, kamu dapat menentukan nilai dari <code>volumeMode</code> menjadi <code>block</code> untuk menggunakan perangkat <em>raw block</em>, atau <code>filesystem</code>
untuk menggunakan sebuah <em>filesystem</em>. <code>filesystem</code> menjadi standar yang digunakan jika nilainya dihilangkan. Hal ini merupakan parameter API
opsional.</p><h3 id=mode-akses>Mode Akses</h3><p>Sebuah <code>PersistentVolume</code> (PV) dapat dipasangkan pada sebuah <em>host</em> dengan cara apapun yang didukung oleh penyedia sumber daya. Seperti ditunjukkan pada tabel di bawah, para penyedia akan memiliki kapabilitas yang berbeda-beda dan setiap mode akses PV akan ditentukan menjadi mode-mode spesifik yang didukung oleh tiap volume tersebut. Sebagai contoh, NFS dapat mendukung banyak klien <em>read/write</em>, tetapi sebuah NFS PV tertentu mungkin diekspor pada server sebagai <em>read-only</em>. Setiap PV memilik seperangkat mode aksesnya sendiri yang menjelaskan kapabilitas dari PV tersebut.</p><p>Beberapa mode akses tersebut antara lain:</p><ul><li>ReadWriteOnce -- volume dapat dipasang sebagai <em>read-write</em> oleh satu <em>node</em></li><li>ReadOnlyMany -- volume dapat dipasang sebagai <em>read-only</em> oleh banyak <em>node</em></li><li>ReadWriteMany -- volume dapat dipasang sebagai <em>read-write</em> oleh banyak <em>node</em></li></ul><p>Pada CLI, mode-mode akses tersebut disingkat menjadi:</p><ul><li>RWO - ReadWriteOnce</li><li>ROX - ReadOnlyMany</li><li>RWX - ReadWriteMany</li></ul><blockquote><p><strong>Penting!</strong> Sebuah volume hanya dapat dipasang menggunakan satu mode akses dalam satu waktu, meskipun volume tersebut mendukung banyak mode. Sebagai contoh, sebuah GCEPersistentDisk dapat dipasangkan sebagai ReadWriteOnce oleh satu <em>node</em> atau ReadOnlyMany oleh banyak node, tetapi tidak dalam waktu yang bersamaan.</p></blockquote><table><thead><tr><th style=text-align:left>Volume Plugin</th><th style=text-align:center>ReadWriteOnce</th><th style=text-align:center>ReadOnlyMany</th><th style=text-align:center>ReadWriteMany</th></tr></thead><tbody><tr><td style=text-align:left>AWSElasticBlockStore</td><td style=text-align:center>✓</td><td style=text-align:center>-</td><td style=text-align:center>-</td></tr><tr><td style=text-align:left>AzureFile</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td></tr><tr><td style=text-align:left>AzureDisk</td><td style=text-align:center>✓</td><td style=text-align:center>-</td><td style=text-align:center>-</td></tr><tr><td style=text-align:left>CephFS</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td></tr><tr><td style=text-align:left>Cinder</td><td style=text-align:center>✓</td><td style=text-align:center>-</td><td style=text-align:center>-</td></tr><tr><td style=text-align:left>FC</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td style=text-align:center>-</td></tr><tr><td style=text-align:left>FlexVolume</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td style=text-align:center>depends on the driver</td></tr><tr><td style=text-align:left>Flocker</td><td style=text-align:center>✓</td><td style=text-align:center>-</td><td style=text-align:center>-</td></tr><tr><td style=text-align:left>GCEPersistentDisk</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td style=text-align:center>-</td></tr><tr><td style=text-align:left>Glusterfs</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td></tr><tr><td style=text-align:left>HostPath</td><td style=text-align:center>✓</td><td style=text-align:center>-</td><td style=text-align:center>-</td></tr><tr><td style=text-align:left>iSCSI</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td style=text-align:center>-</td></tr><tr><td style=text-align:left>Quobyte</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td></tr><tr><td style=text-align:left>NFS</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td></tr><tr><td style=text-align:left>RBD</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td style=text-align:center>-</td></tr><tr><td style=text-align:left>VsphereVolume</td><td style=text-align:center>✓</td><td style=text-align:center>-</td><td style=text-align:center>- (works when pods are collocated)</td></tr><tr><td style=text-align:left>PortworxVolume</td><td style=text-align:center>✓</td><td style=text-align:center>-</td><td style=text-align:center>✓</td></tr><tr><td style=text-align:left>ScaleIO</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td style=text-align:center>-</td></tr><tr><td style=text-align:left>StorageOS</td><td style=text-align:center>✓</td><td style=text-align:center>-</td><td style=text-align:center>-</td></tr></tbody></table><h3 id=kelas>Kelas</h3><p>Sebuah PV bisa memiliki sebuah kelas, yang dispesifikasi dalam pengaturan atribut
<code>storageClassName</code> menjadi nama
<a href=/id/docs/concepts/storage/storage-classes/>StorageClass</a>.
Sebuah PV dari kelas tertentu hanya dapat terikat dengan PVC yang meminta
kelas tersebut. Sebuah PV tanpa <code>storageClassName</code> tidak memiliki kelas dan hanya dapat terikat
dengan PVC yang tidak meminta kelas tertentu.</p><p>Dahulu, anotasi <code>volume.beta.kubernetes.io/storage-class</code> digunakan sebagai ganti
atribut <code>storageClassName</code>. Anotasi ini masih dapat bekerja, namun
akan dihilangkan sepenuhnya pada rilis Kubernetes mendatang.</p><h3 id=kebijakan-reklaim>Kebijakan Reklaim</h3><p>Kebijakan-kebijakan reklaim saat ini antara lain:</p><ul><li>Retain -- reklamasi manual</li><li>Recycle -- penghapusan dasar (<code>rm -rf /thevolume/*</code>)</li><li>Delete -- aset <em>storage</em> terasosiasi seperti AWS EBS, GCE PD, Azure Disk, atau OpenStack Cinder volume akan dihapus</li></ul><p>Saat ini, hanya NFS dan HostPath yang mendukung daur ulang. AWS EBS, GCE PD, Azure Disk, dan Cinder Volume mendukung penghapusan.</p><h3 id=opsi-pemasangan>Opsi Pemasangan</h3><p>Seorang administrator Kubernetes dapat menspesifikasi opsi pemasangan tambahan untuk ketika sebuah <em>Persistent Volume</em> dipasangkan pada sebuah <em>node</em>.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Tidak semua tipe <em>Persistent Volume</em> mendukung opsi pemasanagan.</div><p>Tipe-tipe volume yang mendukung opsi pemasangan antara lain:</p><ul><li>AWSElasticBlockStore</li><li>AzureDisk</li><li>AzureFile</li><li>CephFS</li><li>Cinder (OpenStack block storage)</li><li>GCEPersistentDisk</li><li>Glusterfs</li><li>NFS</li><li>Quobyte Volumes</li><li>RBD (Ceph Block Device)</li><li>StorageOS</li><li>VsphereVolume</li><li>iSCSI</li></ul><p>Opsi pemasangan tidak divalidasi, sehingga pemasangan akan gagal jika salah satunya tidak valid.</p><p>Dahulu, anotasi <code>volume.beta.kubernetes.io/mount-options</code> digunakan sebagai ganti
atribut <code>mountOptions</code>. Anotasi ini masih dapat bekerja, namun
akan dihilangkan sepenuhnya pada rilis Kubernetes mendatang.</p><h3 id=afinitas-node>Afinitas Node</h3><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Untuk kebanyakan tipe volume, kamu tidak perlu memasang kolom ini. Kolom ini secara otomatis terisi untuk tipe blok volume <a href=/id/docs/concepts/storage/volumes/#awselasticblockstore>AWS EBS</a>, <a href=/id/docs/concepts/storage/volumes/#gcepersistentdisk>GCE PD</a> dan <a href=/id/docs/concepts/storage/volumes/#azuredisk>Azure Disk</a>. Kamu harus mengaturnya secara eksplisit untuk volume <a href=/id/docs/concepts/storage/volumes/#local>lokal</a>.</div><p>Sebuah PV dapat menspesifikasi <a href=/docs/reference/generated/kubernetes-api/v1.25/#volumenodeaffinity-v1-core>afinitas node</a> untuk mendefinisikan batasan yang membatasi <em>node</em> mana saja yang dapat mengakses volume tersebut. <em>Pod</em> yang menggunakan sebuah PV hanya akan bisa dijadwalkan ke <em>node</em> yang dipilih oleh afinitas <em>node</em>.</p><h3 id=fase>Fase</h3><p>Sebuah volume akan berada dalam salah satu fase di bawah ini:</p><ul><li>Available -- sumber daya bebas yang belum terikat dengan sebuah klaim</li><li>Bound -- volume sudah terikat dengan sebuah klaim</li><li>Released -- klaim sudah dihapus, tetapi sumber daya masih belum direklaim oleh klaster</li><li>Failed -- volume gagal menjalankan reklamasi otomatis</li></ul><p>CLI akan menunjukkan nama dari PVC yang terikat pada PV.</p><h2 id=persistentvolumeclaims>PersistentVolumeClaims</h2><p>Setiap PVC memiliki <em>spec</em> dan status, yang merupakan spesifikasi dan status dari klaim.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myclaim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeMode</span>:<span style=color:#bbb> </span>Filesystem<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>8Gi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>slow<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>release</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;stable&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- {<span style=color:green;font-weight:700>key: environment, operator: In, values</span>:<span style=color:#bbb> </span>[dev]}<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=mode-akses-1>Mode Akses</h3><p>Klaim menggunakan penulisan yang sama dengan volume ketika meminta <em>storage</em> dengan mode akses tertentu.</p><h3 id=mode-volume-1>Mode Volume</h3><p>Klaim menggunakan penulisan yang sama dengan volume untuk mengindikasikan konsumsi dari volume sebagai <em>filesystem</em> ataupun perangkat <em>block</em>.</p><h3 id=sumber-daya>Sumber daya</h3><p>Klaim, seperti <em>pod</em>, bisa meminta sumber daya dengan jumlah tertentu. Pada kasus ini, permintaan untuk <em>storage</em>. <a href=https://git.k8s.io/community/contributors/design-proposals/scheduling/resources.md>Model sumber daya</a> yang sama berlaku untuk baik volume maupun klaim.</p><h3 id=selector><em>Selector</em></h3><p>Klaim dapat menspesifikasi <a href=/id/docs/concepts/overview/working-with-objects/labels/#label-selectors><em>label selector</em></a> untuk memilih serangkaian volume lebih jauh. Hanya volume yang cocok labelnya dengan <em>selector</em> yang dapat terikat dengan klaim. <em>Selector</em> dapat terdiri dari dua kolom:</p><ul><li><code>matchLabels</code> - volume harus memiliki label dengan nilai ini</li><li><code>matchExpressions</code> - daftar dari persyaratan yang dibuat dengan menentukan kunci, daftar nilai, dan operator yang menghubungkan kunci dengan nilai. Operator yang valid meliputi In, NotIn, Exists, dan DoesNotExist.</li></ul><p>Semua persyaratan tersebut, dari <code>matchLabels</code> dan <code>matchExpressions</code> akan dilakukan operasi AND bersama – semuanya harus dipenuhi untuk mendapatkan kecocokan.</p><h3 id=kelas-1>Kelas</h3><p>Sebuah klaim dapat meminta kelas tertentu dengan menspesifikasi nama dari
<a href=/id/docs/concepts/storage/storage-classes/>StorageClass</a>
menggunakan atribut <code>storageClassName</code>.
Hanya PV dari kelas yang diminta, yang memiliki <code>storageClassName</code> yang sama dengan PVC, yang dapat
terikat dengan PVC.</p><p>PVC tidak harus meminta sebuah kelas. Sebuah PVC dengan <code>storageClassName</code> miliknya bernilai
<code>""</code> akan selalu diinterpretasikan sebagai meminta PV tanpa kelas, jadi PVC
hanya bisa terikat ke PV tanpa kelas (tanpa anotasi atau bernilai
<code>""</code>). Sebuah PVC tanpa <code>storageClassName</code> tidaklah sama dan diperlakukan berbeda
oleh klaster tergantung apakah
<a href=/docs/reference/access-authn-authz/admission-controllers/#defaultstorageclass><em>admission plugin</em> <code>DefaultStorageClass</code></a>
dinyalakan.</p><ul><li>Jika <em>admission plugin</em> dinyalakan, administrator bisa menspesifikasi
<code>StorageClass</code> standar. Seluruh PVC yang tidak memiliki <code>storageClassName</code> dapat terikat hanya ke
PVs standar. Menspesifikasikan <code>StorageClass</code> standar dapat dilakukan dengan mengatur
anotasi <code>storageclass.kubernetes.io/is-default-class</code> menjadi "<em>true</em>" pada
sebuah objek <code>StorageClass</code>. Jika administrator tidak menspesifikasikan standar apapun,
klaster menanggapi pembuatan PVC sekan-akan <em>admission plugin</em> dimatikan. Jika
ada lebih dari satu setelan standar dispesifikasikan, <em>admission plugin</em> melarang pembuatan seluruh
PVC.</li><li>Jika <em>admission plugin</em> dimatikan, tidak ada pilihan menggunakan
<code>StorageClass</code> standar. Semua PVC yang tidak memiliki <code>storageClassName</code> hanya dapat diikat ke PV yang
tidak memiliki kelas. Pada kasus ini, PVC yang tidak memiliki <code>storageClassName</code> diperlakukan
sama seperti PVC yang memiliki <code>storageClassName</code> bernilai <code>""</code>.</li></ul><p>Tergantung metode instalasi, sebuah StorageClass dari setelan standar dapat dibuat
ke klaster Kubernetes oleh <em>addon manager</em> pada saat instalasi.</p><p>Ketika sebuah PVC menspesifikasi sebuah <code>selector</code> selain meminta <code>StorageClass</code>,
kebutuhan tersebut akan digabungkan dengan operasi AND bersama: hanya PV dari kelas yang diminta dan dengan
label yang diminta yang dapat terikat ke PVC.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Saat ini, sebuah PVC dengan <code>selector</code> yang tak kosong tidak dapat memiliki PV yang disediakan secara dinamis untuknya.</div><p>Dahulu, anotasi <code>volume.beta.kubernetes.io/storage-class</code> digunakan sebagai ganti
atribut <code>storageClassName</code>. Anotasi ini masih dapat bekerja, namun
akan dihilangkan sepenuhnya pada rilis Kubernetes mendatang.</p><h2 id=klaim-sebagai-volume>Klaim sebagai Volume</h2><p><em>Pod</em> mengakses <em>storage</em> dengan menggunakan klaim sebagai volume. Klaim harus berada pada <em>namespace</em> yang sama dengan <em>pod</em> yang menggunakan klaim tersebut. Klaster menemukan klaim pada <em>namespace</em> yang sama dengan <em>pod</em> dan menggunakannya untuk mendapatkan <code>PersistentVolume</code> (PV) yang ada di baliknya. Volume tersebut kemudian dipasangkan ke <em>host</em> dan lalu ke <em>pod</em>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myfrontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/var/www/html&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypd<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypd<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>persistentVolumeClaim</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>claimName</span>:<span style=color:#bbb> </span>myclaim<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=catatan-mengenai-namespace>Catatan Mengenai <em>Namespace</em></h3><p>Ikatan <code>PersistentVolumes</code> bersifat eksklusif, dan karena <code>PersistentVolumeClaims</code> merupakan objek yang berada pada <em>namespace</em>, pemasangan klaim dengan "banyak" mode (<code>ROX</code>, <code>RWX</code>) hanya dimungkinkan jika berada dalam satu <em>namespace</em> yang sama.</p><h2 id=dukungan-volume-raw-block>Dukungan Volume <em>Raw Block</em></h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.13 [beta]</code></div><p><em>Volume plugins</em> berikut mendukung volume <em>raw block</em>, termasuk penyediaan dinamis jika
mungkin diterapkan.</p><ul><li>AWSElasticBlockStore</li><li>AzureDisk</li><li>FC (Fibre Channel)</li><li>GCEPersistentDisk</li><li>iSCSI</li><li>Local volume</li><li>RBD (Ceph Block Device)</li><li>VsphereVolume (alpha)</li></ul><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Hanya FC dan volume iSCSI yang mendukung volume <em>raw block</em> pada Kubernetes 1.9.
Dukungan untuk <em>plugin</em> lainnya ditambahkan pada 1.10.</div><h3 id=persistent-volume-menggunakan-volume-raw-block><em>Persistent Volume</em> menggunakan Volume <em>Raw Block</em></h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>block-pv<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>capacity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>10Gi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeMode</span>:<span style=color:#bbb> </span>Block<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>persistentVolumeReclaimPolicy</span>:<span style=color:#bbb> </span>Retain<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>fc</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetWWNs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;50060e801049cfd1&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>lun</span>:<span style=color:#bbb> </span><span style=color:#666>0</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=persistent-volume-claim-meminta-volume-raw-block><em>Persistent Volume Claim</em> meminta Volume <em>Raw Block</em></h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>block-pvc<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeMode</span>:<span style=color:#bbb> </span>Block<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>10Gi<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=spesifikasi-pod-yang-menambahkan-alamat-perangkat-raw-block-pada-kontainer>Spesifikasi <em>Pod</em> yang menambahkan alamat Perangkat <em>Raw Block</em> pada kontainer</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pod-with-block-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fc-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>fedora:26<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;/bin/sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;tail -f /dev/null&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeDevices</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>data<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>devicePath</span>:<span style=color:#bbb> </span>/dev/xvda<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>data<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>persistentVolumeClaim</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>claimName</span>:<span style=color:#bbb> </span>block-pvc<span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Ketika menambahkan sebuah perangkat <em>raw block</em> untuk sebuah <em>Pod</em>, kita menspesifikasi alamat perangkat dalam kontainer alih-alih alamat pemasangan.</div><h3 id=mengikat-block-volume>Mengikat <em>Block Volume</em></h3><p>Jika seorang pengguna meminta sebuah volume <em>raw block</em> dengan mengindikasikannya menggunakan kolom <code>volumeMode</code> pada <em>spec</em> <code>PersistentVolumeClaim</code> (PVC), aturan pengikatannya sedikit berbeda dibanding rilis-rilis sebelumnya yang tidak memerhatikan mode ini sebagai bagian dari <em>spec</em>.
Di bawah merupakan tabel dari kemungkinan kombinasi yang pengguna dan admin dapat spesifikasikan untuk meminta sebuah perangkat <em>raw block</em>. Tabel tersebut mengindikasikan apakah volume akan terikat atau tidak jika dikombinasikan dengan cara tertentu:
Matriks pengikatan volume untuk volume yang disediakan secara statis:</p><table><thead><tr><th>PV volumeMode</th><th style=text-align:center>PVC volumeMode</th><th style=text-align:right>Hasil</th></tr></thead><tbody><tr><td>unspecified</td><td style=text-align:center>unspecified</td><td style=text-align:right>TERIKAT</td></tr><tr><td>unspecified</td><td style=text-align:center>Block</td><td style=text-align:right>TIDAK TERIKAT</td></tr><tr><td>unspecified</td><td style=text-align:center>Filesystem</td><td style=text-align:right>TERIKAT</td></tr><tr><td>Block</td><td style=text-align:center>unspecified</td><td style=text-align:right>TIDAK TERIKAT</td></tr><tr><td>Block</td><td style=text-align:center>Block</td><td style=text-align:right>TERIKAT</td></tr><tr><td>Block</td><td style=text-align:center>Filesystem</td><td style=text-align:right>TIDAK TERIKAT</td></tr><tr><td>Filesystem</td><td style=text-align:center>Filesystem</td><td style=text-align:right>TERIKAT</td></tr><tr><td>Filesystem</td><td style=text-align:center>Block</td><td style=text-align:right>TIDAK TERIKAT</td></tr><tr><td>Filesystem</td><td style=text-align:center>unspecified</td><td style=text-align:right>TERIKAT</td></tr></tbody></table><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Hanya volume yang disediakan secara statis yang didukung untuk rilis alfa. Administrator harus memperhatikan nilai-nilai tersebut ketika mengerjakan perangkat-perangkat <em>raw block</em>.</div><h2 id=volume-snapshot-dan-dukungan-pemulihan-volume-dari-snapshot><em>Volume Snapshot</em> dan Dukungan Pemulihan Volume dari <em>Snapshot</em></h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.12 [alpha]</code></div><p>Fitur <em>volume snapshot</em> ditambahkan hanya untuk mendukung <em>CSI Volume Plugins</em>. Untuk lebih detail, lihat <a href=/id/docs/concepts/storage/volume-snapshots/><em>volume snapshots</em></a>.</p><p>Untuk mengaktifkan dukungan pemulihan sebuah volume dari sebuah sumber data <em>volume snapshot</em>, aktifkan
gerbang fitur <code>VolumeSnapshotDataSource</code> pada apiserver dan <em>controller-manager</em>.</p><h3 id=membuat-persistent-volume-claim-dari-volume-snapshot>Membuat <em>Persistent Volume Claim</em> dari <em>Volume Snapshot</em></h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>restore-pvc<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>csi-hostpath-sc<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>dataSource</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>new-snapshot-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>VolumeSnapshot<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>snapshot.storage.k8s.io<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>10Gi<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=menulis-konfigurasi-portabel>Menulis Konfigurasi Portabel</h2><p>Jika kamu menulis templat konfigurasi atau contoh yang dapat berjalan pada berbagai macam klaster
dan membutuhkan <em>persistent storage</em>, kami merekomendasikan agar kamu menggunakan pola berikut:</p><ul><li>Masukkan objek PersistentVolumeClaim (PVC) pada kumpulan <em>config</em> (bersamaan dengan
Deployments, ConfigMaps, dsb).</li><li>Jangan memasukkan objek PersistentVolume (PV) pada <em>config</em>, karena pengguna yang menginstantiasi
<em>config</em> tersebut kemungkinan tidak memiliki izin untuk membuat PersistentVolume (PV).</li><li>Berikan pengguna opsi untuk menyediakan nama <em>storage class</em> ketika menginstantiasi
templat.<ul><li>Jika pengguna menyediakan nama <em>storage class</em>, taruh nilai tersebut pada
kolom <code>persistentVolumeClaim.storageClassName</code>.
Hal ini akan membuat PVC agar sesuai dengan <em>storage class</em>
yang tepat jika klaster memiliki banyak StorageClass yang diaktifkan oleh admin.</li><li>Jika pengguna tidak menyediakan nama <em>storage class</em>, biarkan
kolom <code>persistentVolumeClaim.storageClassName</code> kosong.<ul><li>Hal ini kakan membuat sebuah PV disediakan secara otomatis untuk pengguna dengan
StorageClass standar pada klaster. Banyak lingkungan klaster memiliki
StorageClass standar yang sudah terpasang, atau administrator dapat membuat
StorageClass standar sendiri.</li></ul></li></ul></li><li>Dalam pembuatan, perhatikan PVC yang tidak kunjung terikat setelah beberapa lama
dan beritahukan hal ini pada pengguna, karena hal ini dapat mengindikasikan klaster tidak
memiliki dukungan penyimpanan dinamis (di mana pengguna harus membuat PV yang sesuai)
atau klaster tidak memiliki sistem penyimpanan (di mana penggun tidak dapat membuat
PVC yang membutuhkan <em>config</em>).</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-c262af210c6828dec445d2f55a1d877a>3.6.3 - VolumeSnapshot</h1><p><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.12 [alpha]</code></div>Laman ini menjelaskan tentang fitur VolumeSnapshot pada Kubernetes. Sebelum lanjut membaca, sangat disarankan untuk memahami <a href=/id/docs/concepts/storage/persistent-volumes/>PersistentVolume</a> terlebih dahulu.</p><h2 id=pengenalan>Pengenalan</h2><p>Seperti halnya sumber daya API PersistentVolume dan PersistentVolumeClaim yang digunakan oleh para pengguna dan administrator untuk menyediakan volume, sumber daya API VolumeSnapshotContent dan VolumeSnapshot digunakan mereka untuk membuat <em>snapshot</em> volume.</p><p>VolumeSnapshotContent merupakan suatu <em>snapshot</em> yang diambil dari sebuah volume dari dalam klaster yang telah disediakan oleh administrator. Sepert layaknya PersistentVolume, VolumeSnapshotContent juga merupakan bagian dari sumber daya klaster.</p><p>VolumeSnapshot merupakan suatu permintaan <em>snapshot</em> dari volume oleh pengguna. Mirip seperti halnya PersistentVolumeClaim.</p><p>Walaupun VolumeSnapshot membuat pengguna bisa mengonsumsi abstraksi dari sumber daya penyimpanan, administrator klaster tetap perlu
menawarkan berbagai macam tipe VolumeSnapshotContent, tanpa perlu mengekspos pengguna pada detail bagaimana <em>snapshot</em>
volume tersebut harus tersediakan. Bagi yang memerlukan hal ini, ada yang namanya sumber daya VolumeSnapshotClass.</p><p>Para pengguna tetap perlu mengetahui beberapa hal di bawah ketika menggunakan fitur ini:</p><ul><li>Objek API VolumeSnapshot, VolumeSnapshotContent, dan VolumeSnapshotClass adalah CRD, bukan bagian dari API inti.</li><li>Fitur VolumeSnapshot hanya tersedia untuk CSI <em>driver</em>.</li><li>Sebagai bagian dari proses <em>deploy</em>, tim Kubernetes menyediakan Container <em>sidecar</em> bantuan untuk <em>controller snapshot</em> berrnama <code>external-snapshotter</code>. Container ini melakukan <em>watch</em> pada objek VolumeSnapshot dan memicu operasi CreateSnapshot dan DeleteSnapshot terhadap sebuah <em>endpoint</em> CSI.</li><li><em>Driver</em> CSI ada yang telah implementasi fitur VolumeSnapshot, ada juga yang belum. <em>Driver</em> CSI yang telah menyediakan dukungan terhadap fitur VolumeSnapshot kemungkinan besar menggunakan <code>external-snapshotter</code>.</li><li><em>Driver</em> CSI yang mendukung VolumeSnapshot akan secara otomatis melakukan instalasi CRD untuk VolumeSnapshot.</li></ul><h2 id=siklus-hidup-volumesnapshot-dan-volumesnapshotcontent>Siklus hidup VolumeSnapshot dan VolumeSnapshotContent</h2><p>VolumeSnapshotContent merupakan bagian dari sumber daya klaster. VolumeSnapshot merupakan permintaan terhadap sumber daya tersebut. Interaksi antara VolumeSnapshotContent dan VolumeSnapshot mengikuti siklus hidup berikut ini:</p><h3 id=penyediaan-volumesnapshot>Penyediaan VolumeSnapshot</h3><p>Ada dua cara untuk menyediakan <em>snapshot</em>: secara statis maupun dinamis.</p><h4 id=statis>Statis</h4><p>Seorang administrator klaster membuat beberapa VolumeSnapshotContent, yang masing-masing memiliki detail tentang penyimpanan sebenarnya yang dapat dipergunakan oleh para pengguna. VolumeSnapshotContent tersebut dapat dikonsumsi melalui API Kubernetes.</p><h4 id=dinamis>Dinamis</h4><p>Ketika VolumeSnapshotContent yang dibuat oleh administrator tidak ada yang sesuai dengan VolumeSnapshot yang dibuat pengguna, klaster bisa saja
mencoba untuk menyediakan sebuah VolumeSnapshot secara dinamis, khususnya untuk objek VolumeSnapshot.
Proses penyediaan ini berdasarkan VolumeSnapshotClasses: VolumeSnapshot harus meminta sebuah <a href=/id/docs/concepts/storage/volume-snapshot-classes/>VolumeSnapshotClass</a>
dan administrator harus membuat serta mengatur <em>class</em> tersebut supaya penyediaan dinamis bisa terjadi.</p><h3 id=ikatan-binding>Ikatan (<em>Binding</em>)</h3><p>Seorang pengguna akan membuat (atau telah membuat, dalam kasus penyediaan dinamis) sebuah VolumeSnapshot dengan ukuran penyimpanan yang diminta beserta mode akses tertentu. Suatu <em>loop</em> kontrol melakukan <em>watch</em> terhadap VolumeSnapshot baru, mencari VolumeSnapshotContent yang sesuai (jika memungkinkan), dan mengikat (<em>bind</em>) keduanya. Jika VolumeSnapshotContent secara dinamis disediakan untuk VolumeSnapshot yang baru,
<em>loop</em> akan terus mengikat VolumeSnapshotContent dengan VolumeSnapshot. Ketika telah terikat (<em>bound</em>), VolumeSnapshot <em>bind</em> bersifat eksklusif, terlepas dari bagaimana proses <em>bind</em> dilakukan. Ikatan (<em>binding</em>) antara suatu VolumeSnapshot dengan VolumeSnapshotContent bersifat 1:1 <em>mapping</em>.</p><p>VolumeSnapshot akan tetap tidak terikat (<em>unbound</em>) tanpa ada batas waktu, jika VolumeSnapshotContent yang sesuai tidak ditemukan. VolumeSnapshot akan menjadi terikat (<em>bound</em>) ketika VolumeSnapshotContent yang sesuai menjadi ada.</p><h3 id=persistentvolumeclaim-dengan-in-use-protection>PersistentVolumeClaim dengan <em>in-Use Protection</em></h3><p>Tujuan dari objek PersistentVolumeClaim dengan fitur <em>in Use Protection</em> adalah memastikan objek API PVC yang masih dalam penggunaan (<em>in-use</em>) tidak akan dihilangkan dari sistem (penghilangan akan menyebabkan hilangnya data).</p><p>Jika sebuah PVC sedang digunakan secara aktif oleh proses <em>snapshot</em> yang digunakan sebagai sumbernya (<em>source</em>), artinya PVC sedang dalam penggunaan (<em>in-use</em>). Jika seorang pengguna menghapus suatu objek API PVC saat dalam penggunaan sebagai sumber <em>snapshot</em>, objek PVC tidak akan dihilangkan segera. Namun, penghapusan objek PVC akan ditunda sampai PVCC tidak lagi secara aktif digunakan oleh proses <em>snapshot</em> manapun. Suatu PVC tidak lagi diguunakan sebagai suumber <em>snapshot</em> ketika <code>ReadyToUse</code> dari <code>Status</code> <em>snapshot</em> menjadi <code>true</code>.</p><h3 id=penghapusan>Penghapusan</h3><p>Proses penghapusan akan menghilangkan objek VolumeSnapshot dari API Kubernetes, beserta aset penyimpanan terkait pada infrastruktur eksternal.</p><h2 id=volumesnapshotcontent>VolumeSnapshotContent</h2><p>Setiap VolumeSnapshotContent memiliki sebuah <em>spec</em>, yang merepresentasikan spesifikasi dari <em>snapshot</em> volume tersebut.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>snapshot.storage.k8s.io/v1alpha1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>VolumeSnapshotContent<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>new-snapshot-content-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>snapshotClassName</span>:<span style=color:#bbb> </span>csi-hostpath-snapclass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>source</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pvc-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeSnapshotSource</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>csiVolumeSnapshotSource</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>creationTime</span>:<span style=color:#bbb>    </span><span style=color:#666>1535478900692119403</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>driver</span>:<span style=color:#bbb>          </span>csi-hostpath<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>restoreSize</span>:<span style=color:#bbb>     </span>10Gi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>snapshotHandle</span>:<span style=color:#bbb>  </span>7bdd0de3-aaeb-11e8-9aae-0242ac110002<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=class><em>Class</em></h3><p>Suatu VolumeSnapshotContent dapat memiliki suatu <em>class</em>, yang didapat dengan mengatur atribut
<code>snapshotClassName</code> dengan nama dari <a href=/id/docs/concepts/storage/volume-snapshot-classes/>VolumeSnapshotClass</a>.
VolumeSnapshotContent dari <em>class</em> tertentu hanya dapat terikat (<em>bound</em>) dengan VolumeSnapshot yang
"meminta" <em>class</em> tersebut. VolumeSnapshotContent tanpa <code>snapshotClassName</code> tidak memiliki <em>class</em> dan hanya dapat
terikat (<em>bound</em>) dengan VolumeSnapshot yang "meminta" untuk tidak menggunakan <em>class</em>.</p><h2 id=volumesnapshot>VolumeSnapshot</h2><p>Masing-masing VolumeSnapshot memiliki sebuah <em>spec</em> dan status, yang merepresentasikan spesifikasi dan status dari <em>snapshot</em> volume tersebut.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>snapshot.storage.k8s.io/v1alpha1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>VolumeSnapshot<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>new-snapshot-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>snapshotClassName</span>:<span style=color:#bbb> </span>csi-hostpath-snapclass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>source</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pvc-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=class-1><em>Class</em></h3><p>Suatu VolumeSnapshot dapat meminta sebuah <em>class</em> tertentu dengan mengatur nama dari
<a href=/id/docs/concepts/storage/volume-snapshot-classes/>VolumeSnapshotClass</a>
menggunakan atribut <code>snapshotClassName</code>.
Hanya VolumeSnapshotContent dari <em>class</em> yang diminta, memiliki <code>snapshotClassName</code> yang sama
dengan VolumeSnapshot, dapat terikat (<em>bound</em>) dengan VolumeSnapshot tersebut.</p><h2 id=penyediaan-provisioning-volume-dari-snapshot>Penyediaan (<em>Provisioning</em>) Volume dari <em>Snapshot</em></h2><p>Kamu dapat menyediakan sebuah volume baru, yang telah terisi dengan data dari suatu <em>snapshot</em>, dengan
menggunakan <em>field</em> <code>dataSource</code> pada objek PersistentVolumeClaim.</p><p>Untuk detailnya bisa dilihat pada <a href=/id/docs/concepts/storage/persistent-volumes/#volume-snapshot-and-restore-volume-from-snapshot-support>VolumeSnapshot and Mengembalikan Volume dari <em>Snapshot</em></a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-707ca81a34eb1ca202f34692e9917d1e>3.6.4 - Pengklonaan Volume CSI</h1><p><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.16 [beta]</code></div>Dokumen ini mendeskripsikan konsep pengklonaan Volume CSI yang telah tersedia di dalam Kubernetes. Pengetahuan tentang <a href=/id/docs/concepts/storage/volumes>Volume</a> disarankan.</p><h2 id=introduction>Introduction</h2><p>Fitur <a class=glossary-tooltip title='The Container Storage Interface (CSI) defines a standard interface to expose storage systems to containers.' data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/#csi target=_blank aria-label=CSI>CSI</a> Volume Cloning menambahkan dukungan untuk merinci <a class=glossary-tooltip title='Mengklaim sumber daya penyimpanan yang didefinisikan di dalam suatu PersistentVolume, sehingga PersistentVolume tersebut dapat dipasang (mounted) sebagai sebuah volume pada suatu Container.' data-toggle=tooltip data-placement=top href=/id/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims target=_blank aria-label=PVC>PVC</a> yang telah tersedia pada kolom <code>dataSource</code> untuk mengindikasikan bahwa seorang pengguna ingin melakukan pengklonaan terhadap sebuah <a class=glossary-tooltip title='Sebuah direktori yang mengandung data, dapat diakses o;eh kontainer-kontainer di dalam pod.' data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/ target=_blank aria-label=Volume>Volume</a>.</p><p>Sebuah klona didefinisikan sebagai sebuah duplikat dari sebuah Volume Kubernetes yang telah tersedia yang dapat digunakan sebagai sebuah Volume standar. Perbedaannya hanyalah pada saat penyediaannya, daripada membuat sebuah Volume kosong yang "baru", peranti penyokongnya membuat sebuah duplikat sama persis dari Volume yang dirinci.</p><p>Implementasi dari pengklonaan, dari sudut pandang API Kubernetes, secara sederhana menambahkan kemampuan untuk merinci sebuah PVC yang telah tersedia sebagai sebuah dataSource saat pembuatan PVC. PVC sumber harus tertambat (<em>bound</em>) dan tersedia (tidak sedang digunakan).</p><p>Pengguna-pengguna mesti menyadari hal-hal berikut saat menggunakan fitur ini:</p><ul><li>Dukungan pengklonaan (<code>VolumePVCDataSource</code>) hanya tersedia untuk <em>driver-driver</em> CSI.</li><li>Dukungan pengklonaan hanya tersedia untuk penyedia-penyedia dinamis.</li><li><em>Driver-driver</em> CSI mungkin telah atau belum mengimplementasi fungsi pengklonaan Volume.</li><li>Kamu hanya dapat mengklonakan sebuah PVC saat ia tersedia pada Namespace yang sama dengan PVC tujuan (sumber dan tujuan harus berada pada Namespace yang sama).</li><li>Pengklonaan hanya didukung pada Storage Class yang sama.<ul><li>Volume tujuan harus memiliki Storage Class yang sama dengan sumbernya.</li><li>Storage Class bawaan dapat digunakan dan <code>storageClassName</code> dihilangkan dari <code>spec</code></li></ul></li></ul><h2 id=penyediaan>Penyediaan</h2><p>Klona-klona disediakan sama seperti PVC lainnya dengan pengecualian dengan penambahan sebuah <code>dataSource</code> yang merujuk pada sebuah PVC yang telah tersedia pada Namespace yang sama.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>clone-of-pvc-1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>myns<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- ReadWriteOnce<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>cloning<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>5Gi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>dataSource</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pvc-1<span style=color:#bbb>
</span></span></span></code></pre></div><p>Hasilnya adalah sebuah PVC baru dengan nama <code>clone-of-pvc-1</code> yang memiliki isi yang sama dengan sumber yang dirinci <code>pvc-1</code>.</p><h2 id=penggunaan>Penggunaan</h2><p>Setelah tersedianya PVC baru tersebut, PVC baru yang diklonakan tersebut digunakan sama seperti PVC lainnya. Juga diharapkan pada titik ini bahwa PVC baru tersebut adalah sebuah objek terpisah yang independen. Ia dapat digunakan, diklonakan, di-<em>snapshot</em>, atau dihapus secara terpisah dan tanpa perlu memikirkan PVC dataSource aslinya. Hal ini juga berarti bahwa sumber tidak terikat sama sekali dengan klona yang baru dibuat tersebut, dan dapat diubah atau dihapus tanpa memengaruhi klona yang baru dibuat tersebut.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-f0276d05eef111249272a1c932a91e2c>3.6.5 - StorageClass</h1><p>Dokumen ini mendeskripsikan konsep StorageClass yang ada pada Kubernetes.
Sebelum lanjut membaca, sangat dianjurkan untuk memiliki pengetahuan terhadap
<a href=/id/docs/concepts/storage/volumes/>volumes</a> dan
<a href=/id/docs/concepts/storage/persistent-volumes>peristent volume</a> terlebih dahulu.</p><h2 id=pengenalan>Pengenalan</h2><p>Sebuah StorageClass menyediakan cara bagi administrator untuk
mendeskripsikan "kelas" dari penyimpanan yang mereka sediakan.
Kelas yang berbeda bisa saja memiliki perbedaan dari segi kualitas
servis yang disediakan, pemulihan (<em>backup</em>) kebijakan, atau kebijakan lain yang ditentukan
oleh administrator klaster. Kubernetes sendiri tidak dipengaruhi oleh
kelas apakah yang digunakan pada mekanisme penyimpanan yang digunakan.
Mekanisme ini seringkali disebut sebagai <em>"profiles"</em> pada sistem penyimpanan
yang lain.</p><h2 id=sumber-daya-storageclass>Sumber daya StorageClass</h2><p>Setiap StorageClass (kelas penyimpanan) memiliki <em>field-field</em> mendasar seperti
<code>provisioner</code>, <code>parameters</code>, dan <code>reclaimPolicy</code>, yang digunakan ketika
<code>PersistentVolume</code> yang dimiliki oleh kelas tersebut perlu disediakan (di-<em>provision</em>).</p><p>Nama yang digunakan oleh suatu StorageClass sifatnya penting, karena
ini merupakan cara yang digunakan oleh pengguna untuk meminta
penyimpanan dengan kelas tertentu. Administrator dapat menentukan
nama dan parameter lain dari suatu kelas ketika membuat suatu objek <code>StorageClass</code>,
dan objek yang sudah dibuat tidak dapat diubah lagi definisinya.</p><p>Administrator dapat memberikan spesifikasi StorageClass <em>default</em> bagi
PVC yang tidak membutuhkan kelas tertentu untuk dapat melakukan mekanisme <em>bind</em>:
kamu dapat membaca <a href=/id/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims>bagian <code>PersistentVolumeClaim</code></a>
untuk penjelasan lebih lanjut.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>standard<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/aws-ebs<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>gp2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>reclaimPolicy</span>:<span style=color:#bbb> </span>Retain<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>mountOptions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- debug<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>volumeBindingMode</span>:<span style=color:#bbb> </span>Immediate<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=provisioner><em>Provisioner</em></h3><p>Setiap kelas penyimpanan (<em>storage class</em>) memiliki sebuah <em>provisioner</em> yang
menentukan <em>plugin</em> manakah yang digunakan ketika sebuah PV disediakan (di-<em>provision</em>).
<em>Field</em> ini haruslah didefinisikan.</p><table><thead><tr><th style=text-align:left>Plugin Volume</th><th style=text-align:center>Provisioner Internal</th><th style=text-align:center>Contoh Konfigurasi</th></tr></thead><tbody><tr><td style=text-align:left>AWSElasticBlockStore</td><td style=text-align:center>✓</td><td style=text-align:center><a href=#aws-ebs>AWS EBS</a></td></tr><tr><td style=text-align:left>AzureFile</td><td style=text-align:center>✓</td><td style=text-align:center><a href=#azure-file>Azure File</a></td></tr><tr><td style=text-align:left>AzureDisk</td><td style=text-align:center>✓</td><td style=text-align:center><a href=#azure-disk>Azure Disk</a></td></tr><tr><td style=text-align:left>CephFS</td><td style=text-align:center>-</td><td style=text-align:center>-</td></tr><tr><td style=text-align:left>Cinder</td><td style=text-align:center>✓</td><td style=text-align:center><a href=#openstack-cinder>OpenStack Cinder</a></td></tr><tr><td style=text-align:left>FC</td><td style=text-align:center>-</td><td style=text-align:center>-</td></tr><tr><td style=text-align:left>Flexvolume</td><td style=text-align:center>-</td><td style=text-align:center>-</td></tr><tr><td style=text-align:left>Flocker</td><td style=text-align:center>✓</td><td style=text-align:center>-</td></tr><tr><td style=text-align:left>GCEPersistentDisk</td><td style=text-align:center>✓</td><td style=text-align:center><a href=#gce-pd>GCE PD</a></td></tr><tr><td style=text-align:left>Glusterfs</td><td style=text-align:center>✓</td><td style=text-align:center><a href=#glusterfs>Glusterfs</a></td></tr><tr><td style=text-align:left>iSCSI</td><td style=text-align:center>-</td><td style=text-align:center>-</td></tr><tr><td style=text-align:left>Quobyte</td><td style=text-align:center>✓</td><td style=text-align:center><a href=#quobyte>Quobyte</a></td></tr><tr><td style=text-align:left>NFS</td><td style=text-align:center>-</td><td style=text-align:center>-</td></tr><tr><td style=text-align:left>RBD</td><td style=text-align:center>✓</td><td style=text-align:center><a href=#ceph-rbd>Ceph RBD</a></td></tr><tr><td style=text-align:left>VsphereVolume</td><td style=text-align:center>✓</td><td style=text-align:center><a href=#vsphere>vSphere</a></td></tr><tr><td style=text-align:left>PortworxVolume</td><td style=text-align:center>✓</td><td style=text-align:center><a href=#portworx-volume>Portworx Volume</a></td></tr><tr><td style=text-align:left>ScaleIO</td><td style=text-align:center>✓</td><td style=text-align:center><a href=#scaleio>ScaleIO</a></td></tr><tr><td style=text-align:left>StorageOS</td><td style=text-align:center>✓</td><td style=text-align:center><a href=#storageos>StorageOS</a></td></tr><tr><td style=text-align:left>Local</td><td style=text-align:center>-</td><td style=text-align:center><a href=#local>Local</a></td></tr></tbody></table><p>Kamu tidak dibatasi untuk hanya menggunakan <em>provisioner</em> internal yang disediakan
pada list yang tersedia (yang memiliki nama dengan prefix "kubernetes.io" dan
didistribusikan bersamaan dengan Kubernetes). Kamu juga dapat menjalankan dan
mendefinisikan <em>provisioner</em> eksternal yang merupakan program independen selama
program tersebut menerapkan <a href=https://github.com/kubernetes/design-proposals-archive/blob/main/storage/volume-provisioning.md>spesifikasi</a>
yang didefinisikan oleh Kubernetes. Penulis dari <em>provisioner</em> eksternal Kubernetes
memiliki kuasa penuh akan tempat dimana kode sumber yang mereka tulis, bagaimana
mekanisme penyediaan (<em>provisioning</em>) dilakukan, serta bagaimana hal tersebut dapat dijalankan,
serta <em>plugin</em> volume apakah yang digunakan (termasuk Flex), dkk.
Repositori <a href=https://github.com/kubernetes-incubator/external-storage>kubernetes-incubator/external-storage</a>
menyimpan <em>library</em> yang dibutukan untuk menulis <em>provisioner</em> eksternal
yang mengimplementasi spesifikasi serta beberapa <em>provisioner</em> eksternal yang
dipelihara oleh komunitas.</p><p>Sebagai contoh, NFS tidak menyediakan <em>provisioner</em> internal, tetapi
sebuah <em>provisioner</em> eksternal dapat digunakan. Beberapa <em>provisioner</em> eksternal
dapat ditemukan di bawah repositori <a href=https://github.com/kubernetes-incubator/external-storage>kubernetes-incubator/external-storage</a>.
Di sana juga terdapat beberapa kasus dimana vendor penyimpanan <em>3rd party</em>
menyediakan <em>provisioner</em> eksternal yang mereka sediakan sendiri.</p><h3 id=perolehan-kembali-untuk-kebijakan-reclaim-policy>Perolehan Kembali untuk Kebijakan (<em>Reclaim Policy</em>)</h3><p><em>Persistent Volumes</em> yang secara dinamis dibuat oleh sebuah kelas penyimpanan
akan memiliki <em>reclaim policy</em> yang didefinisikan di dalam <em>field</em> <code>reclaimPolicy</code>
dari kelas tersebut, yang nilainya dapat diisi dengan <code>Delete</code> atau <code>Retain</code>.
Jika tidak terdapat <code>reclaimPolicy</code> yang dispesifikasikan ketika sebuah objek
StorageClass dibuat, maka nilai default bagi kelas tersebut adalah <code>Delete</code>.</p><p>PersistentVolume yang dibuat secara manual dan diatur dengan menggunakan
kelas penyimpanan akan menggunakan <em>reclaim policy</em> apapun yang diberikan
pada saat objek tersebut dibuat.</p><h3 id=pilihan-mount>Pilihan <em>Mount</em></h3><p>PersistentVolume yang secara dinamis dibuat oleh sebuah kelas penyimpanan
akan memiliki pilihan <em>mount</em> yang dapat dispesifikasikan pada <em>field</em>
<code>mountOptions</code> dari kelas tersebut.</p><p>Jika sebuah <em>plugin</em> volume tidak mendukung pilihan <em>mount</em>
yang dispesifikasikan, mekanisme penyediaan (<em>provision</em>) akan digagalkan. Pilihan <em>mount</em>
yang akan divalidasi pada kelas penyimpanan maupun PV, maka <em>mount</em> tersebut
akan gagal apabila salah satu dari keduanya bersifat invalid.</p><h3 id=mode-volume-binding>Mode Volume <em>Binding</em></h3><p><em>Field</em> <code>volumeBindingMode</code> mengontrol kapan mekanisme <a href=/id/docs/concepts/storage/persistent-volumes/#provisioning><em>binding</em> volume dan
<em>provisioning</em> dinamis</a>
harus dilakukan.</p><p>Secara <em>default</em>, ketika mode <code>Immediate</code> yang mengindikasikan
terjadinya volume <em>binding</em> dan <em>provisioning</em> dinamis terjadi ketika
PersistentVolumeClaim dibuat. Untuk <em>backend</em> penyimpanan yang dibatasi oleh
topologi tertentu dan tidak dapat diakses secara global dari semua Node
yang ada di klaster, PersistentVolume akan di-<em>bound</em> atau di-<em>provision</em>
tanpa perlu memenuhi persyaratan <em>scheduling</em> dari Pod. Hal ini dapat menyebabkan
adanya Pod yang tidak mendapatkan mekanisme <em>scheduling</em>.</p><p>Seorang administrator klaster dapat mengatasi hal tersebut dengan cara memberikan
spesifikasi mode <code>WaitForFirstConsumer</code> yang akan memperlambat mekanisme <em>provisioning</em>
dan <em>binding</em> dari sebuah PersistentVolume hingga sebuah Pod yang menggunakan
PersistentVolumeClaim dibuat. PersistentVolume akan dipilih atau di-<em>provisioning</em>
sesuai dengan topologi yang dispesifikasikan oleh limitasi yang diberikan
oleh mekanisme <em>scheduling</em> Pod. Hal ini termasuk, tetapi tidak hanya terbatas pada,
<a href=/id/docs/concepts/configuration/manage-compute-resources-container>persyaratan sumber daya</a>,
<a href=/id/docs/concepts/scheduling-eviction/assign-pod-node/#nodeselector><em>node selector</em></a>,
<a href=/id/docs/concepts/scheduling-evictionassign-pod-node/#affinity-and-anti-affinity>afinitas dan
anti-afinitas Pod</a>,
serta <a href=/id/docs/concepts/scheduling-eviction/taint-and-toleration><em>taint</em> dan <em>toleration</em></a>.</p><p>Beberapa <em>plugin</em> di bawah ini mendukung <code>WaitForFirstConsumer</code> dengan <em>provisioning</em>
dinamis:</p><ul><li><a href=#aws-ebs>AWSElasticBlockStore</a></li><li><a href=#gce-pd>GCEPersistentDisk</a></li><li><a href=#azure-disk>AzureDisk</a></li></ul><p>Beberapa <em>plugin</em> di bawah ini mendukung <code>WaitForFirstConsumer</code> dengan <em>binding</em>
PersistentVolume yang terlebih dahulu dibuat:</p><ul><li>Semua hal di atas</li><li><a href=#lokal>Lokal</a></li></ul><p><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes 1.14 [beta]</code></div><a href=/id/docs/concepts/storage/volumes/#csi>Volume-volume CSI</a> juga didukung
dengan adanya <em>provisioning</em> dinamis serta PV yang telah terlebih dahulu dibuat,
meskipun demikian, akan lebih baik apabila kamu melihat dokumentasi
untuk driver spesifik CSI untuk melihat topologi <em>key</em> yang didukung
beserta contoh penggunaannya. <em>Feature gate</em> <code>CSINodeInfo</code> haruslah diaktifkan.</p><h3 id=topologi-yang-diizinkan>Topologi yang Diizinkan</h3><p>Ketika sebuah operator klaster memberikan spesifikasi <code>WaitForFirstConsumer</code> pada
mode <code>binding</code> volume, mekanisme pembatasan (restriksi) <code>provisioning</code> tidak lagi dibutuhkan
pada sebagian besar kasus. Meskipun begitu, apabila hal tersebut masih dibutuhkan,
<code>field</code> <code>allowedTopologies</code> dapat dispesifikasikan.</p><p>Contoh ini memberikan demonstrasi bagaimana cara membatasi topologi
dari volume yang di-<em>provision</em> pada suatu zona spesifik serta harus digunakan
sebagai pengganti parameter <code>zone</code> dam <code>zones</code> untuk <code>plugin</code> yang akan digunakan.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>standard<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/gce-pd<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>pd-standard<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>volumeBindingMode</span>:<span style=color:#bbb> </span>WaitForFirstConsumer<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>allowedTopologies</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>matchLabelExpressions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>failure-domain.beta.kubernetes.io/zone<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- us-central-1a<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- us-central-1b<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=parameter-parameter>Parameter-Parameter</h2><p>Kelas-kelas penyimpanan memiliki parameter yang mendeskripsikan
volume yang dimiliki oleh kelas penyimpanan tersebut. Parameter yang berbeda
bisa saja diterima bergantung pada <code>provisioner</code>. Sebagai contohnya, nilai <code>io1</code>,
untuk parameter <code>type</code>, dan parameter <code>iopsPerGB</code> spesifik terhadap EBS.
Ketika sebuah parameter diabaikan, beberapa nilai <em>default</em> akan digunakan sebagai
gantinya.</p><h3 id=aws-ebs>AWS EBS</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>slow<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/aws-ebs<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>io1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>iopsPerGB</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;10&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>fsType</span>:<span style=color:#bbb> </span>ext4<span style=color:#bbb>
</span></span></span></code></pre></div><ul><li><code>type</code>: <code>io1</code>, <code>gp2</code>, <code>sc1</code>, <code>st1</code>. Lihat
<a href=http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html>dokumentasi AWS</a>
untuk detail lebih lanjut. Nilai <em>default</em>: <code>gp2</code>.</li><li><code>zone</code> (<em>deprecated</em>): zona AWS. Jika tidak terdapat nilai <code>zone</code> atau <code>zones</code>
yang dispesifikasikan, volume secara generik dijadwalkan dengan menggunakan
penjadwalan <code>round-robin-ed</code> pada semua zona aktif yang ada pada klaster Kubernetes
yang memiliki <em>node</em>.</li><li><code>zones</code> (<em>deprecated</em>): Nilai terpisahkan koma yang merupakan barisan zona pada AWS.
Jika tidak terdapat nilai <code>zone</code> atau <code>zones</code> yang dispesifikasikan,
volume secara generik dijadwalkan dengan menggunakan penjadwalan
<code>round-robin-ed</code> pada semua zona aktif yang ada pada klaster Kubernetes
yang memiliki <em>node</em>.</li><li><code>iopsPerGB</code>: hanya untuk volume <code>io1</code>. Operasi per detik per GiB. Volume <em>plugin</em>
AWS mengalikan nilai ini dengan ukuran volume yang dibutuhkan untuk menghitung IOPS
dari volume (nilai maksimum yang didukung adalah 20,000 IOPS baca <a href=http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html>dokumentasi
AWS</a>.
Nilai masukan yang diharapkan merupakan string, misalnya <code>"10"</code>, bukan <code>10</code>.</li><li><code>fsType</code>: fsType yang didukung oleh Kubernetes. Nilai <em>default</em>-nya adalah: <code>"ext4"</code>.</li><li><code>encrypted</code>: menyatakan dimana volume EBS harus dienkripsi atau tidak.
Nilai yang valid adalah <code>"true"</code> atau <code>"false"</code> (dalam string bukan boolean i.e. <code>"true"</code>, bukan <code>true</code>).</li><li><code>kmsKeyId</code>: opsional. Merupakan nama dari Amazon Resource Name dari <em>key</em> yang digunakan
untuk melakukan enkripsi volume. Jika nilai ini tidak disediakan tetapi nilai dari
<em>field</em> <code>encrypted</code> adalah <em>true</em>, sebuah <em>key</em> akan dibuat oleh AWS. Perhatikan dokumentasi AWS
untuk mengetahui nilai yang valid bagi ARN.</li></ul><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Parameter <code>zone</code> dan <code>zones</code> sudah terdeprekasi dan digantikan oleh
<a href=#topologi-yang-diizinkan>allowedTopologies</a></div><h3 id=pd-gce>PD GCE</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>slow<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/gce-pd<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>pd-standard<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replication-type</span>:<span style=color:#bbb> </span>none<span style=color:#bbb>
</span></span></span></code></pre></div><ul><li><code>type</code>: <code>pd-standard</code> atau <code>pd-ssd</code>. Nilai <em>default</em>: <code>pd-standard</code></li><li><code>zone</code> (<em>deprecated</em>): zona GCE. Jika tidak terdapat nilai <code>zone</code> atau <code>zones</code>
yang dispesifikasikan, volume secara generik dijadwalkan dengan menggunakan
penjadwalan <code>round-robin-ed</code> pada semua zona aktif yang ada pada klaster Kubernetes
yang memiliki <em>node</em>.</li><li><code>zones</code> (<em>deprecated</em>): Nilai terpisahkan koma yang merupakan barisan zona.
Jika tidak terdapat nilai <code>zone</code> atau <code>zones</code> yang dispesifikasikan,
volume secara generik dijadwalkan dengan menggunakan penjadwalan
<code>round-robin-ed</code> pada semua zona aktif yang ada pada klaster Kubernetes
yang memiliki <em>node</em>.</li><li><code>replication-type</code>: <code>none</code> atau <code>regional-pd</code>. Nilai <em>default</em>: <code>none</code>.</li></ul><p>Jika <code>replication-type</code> diubah menjadi <code>none</code>, sebuah PD reguler (zonal) akan
di-<em>provisioning</em>.</p><p>Jika <code>replication-type</code> diubah menjadi <code>regional-pd</code>, sebuah
<a href=https://cloud.google.com/compute/docs/disks/#repds><em>Persistent</em> Disk Regional (PD Regional)</a>
akan di-<em>provisioning</em>. Pada kasus ini, pengguna harus menggunakan <code>zones</code>
dan bukan <code>zone</code> untuk menspesifikasikan zona replikasi yang diinginkan. Jika terdapat
tepat dua zona yang dispesifikasikan, PD Regional akan di-<em>provisioning</em> pada
zona replikasi yang diinginkan. Jika terdapat lebih dari 2 zona yang dispesifikasikan,
Kubernetes akan memilih secara acak zona dari zona-zona yang dispesifikasikan. Jika
parameter <code>zones</code> tidak diinisialisasi, Kubernetes akan memilih secara acak dari
zona yang diatur oleh klaster Kubernetes.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Parameter <code>zone</code> dan <code>zones</code> sudah <em>deprecated</em> dan digantikan oleh
<a href=#topologi-yang-diizinkan>allowedTopologies</a></div><h3 id=glusterfs>Glusterfs</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>slow<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/glusterfs<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resturl</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;http://127.0.0.1:8081&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clusterid</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;630372ccdc720a92c681fb928f27b53f&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restauthenabled</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restuser</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;admin&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>secretNamespace</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;default&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;heketi-secret&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>gidMin</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;40000&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>gidMax</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;50000&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumetype</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;replicate:3&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><ul><li><p><code>resturl</code>: Servis REST Gluster/URL servis Heketi yang digunakan untuk
melakukan <em>provisioning</em> volume gluster sesuai dengan kebutuhan. Format secara umum
haruslah dalam bentuk <code>IPaddress:Port</code> dan hal ini merupakan parameter wajib untuk
<em>provisioner</em> dinamis GlusterFS. Jika servis Heketi diekspos sebagai servis yang dapat
melakukan <em>routing</em> pada pengaturan openshift/kubernetes, ini dapat memiliki
format yang sesuai dengan <code>http://heketi-storage-project.cloudapps.mystorage.com</code>
dimana fqdn yang ada merupakan URL servis Heketi yang dapat di-<em>resolve</em>.</p></li><li><p><code>restauthenabled</code> : Servis REST Gluster menyediakan nilai boolean yang dapat digunakan
untuk mengajukan <code>authentication</code> untuk server REST yang ada. Jika nilai yang disediakan
adalah <code>"true"</code>, dengan kondisi dimana <code>restuser</code> dan <code>restuserkey</code> atau <code>secretNamespace</code> + <code>secretName</code>
harus diisi. Opsi ini sudah_deprecated_, mekanisme otentikasi akan diizinkan apabila
salah satu dari <em>field</em> <code>restuser</code>, <code>restuserkey</code>, <code>secretName</code> atau <code>secretNamespace</code> diterapkan.</p></li><li><p><code>restuser</code> : Pengguna servis REST Gluster/Heketi yang memiliki akses
untuk membuat volume di dalam Trusted Pool Gluster.</p></li><li><p><code>restuserkey</code> : Password pengguna servis REST Gluster/Heketi
yang digunakan untuk mekanisme otentikasi server REST. Parameter ini <em>deprecated</em>
dan digantikan dengan parameter <code>secretNamespace</code> + <code>secretName</code>.</p></li><li><p><code>secretNamespace</code>, <code>secretName</code> : Identifikasi instans Secret yang mengandung
password pengguna yang digunakan untuk berkomunikasi dengan servis REST Gluster.
Parameter ini dianggap opsional, password kosong dapat digunakan ketika
nilai dari <code>secretNamespace</code> dan <code>secretName</code> tidak dispesifikasikan.
Secret yang disediakan haruslah memiliki tipe <code>"kubernetes.io/glusterfs"</code>,
yang dapat dibuat dengan menggunakan mekanisme dibawah ini:</p><pre tabindex=0><code>kubectl create secret generic heketi-secret \
  --type=&#34;kubernetes.io/glusterfs&#34; --from-literal=key=&#39;opensesame&#39; \
  --namespace=default
</code></pre><p>Contoh Secret dapat ditemukan pada berkas berikut
<a href=https://github.com/kubernetes/examples/tree/master/staging/persistent-volume-provisioning/glusterfs/glusterfs-secret.yaml>glusterfs-provisioning-secret.yaml</a>.</p></li><li><p><code>clusterid</code>: <code>630372ccdc720a92c681fb928f27b53f</code> merupakan ID dari klaster
yang akan digunakan oleh Heketi ketikan melakukan <em>provisioning</em> volume. ID ini juga
dapat berupa serangkaian list, misalnya: <code>"8452344e2becec931ece4e33c4674e4e,42982310de6c63381718ccfa6d8cf397"</code>.
Parameter ini merupakan parameter opsional.</p></li><li><p><code>gidMin</code>, <code>gidMax</code> : Nilai minimum dan maksimum dari GID untuk kelas penyimpanan (<em>storage class</em>).
Sebuah nilai unik dari GID di dalam <em>range</em> ( gidMin-gidMax ) ini akan digunakan untuk melakukan
<em>provisioning</em> volume secara dinamis. Nilai ini bersifat opsional. Jika tidak dispesifikasikan,
volume akan secara default di-<em>provisioning</em> dalam <em>range</em> 2000-2147483647 yang merupakan nilai default
dari gidMin dan gidMax.</p></li><li><p><code>volumetype</code> : Tipe volume beserta paremeter-nya dapat diatur dengan menggunakan nilai opsional
berikut. Jika tipe dari volume tidak dispesifikasikan, maka <em>provisioner</em> akan memutuskan tipe
volume apakah yang akan digunakan.</p><p>Sebagai contoh:</p><ul><li><p>Volume replika: <code>volumetype: replicate:3</code> dimana '3' merupakan jumlah replika.</p></li><li><p>Persebaran (<em>Disperse</em>)/EC volume: <code>volumetype: disperse:4:2</code> dimana'4' merupakan data dan '2' merupakan jumlah redundansi.</p></li><li><p>Distribusi volume: <code>volumetype: none</code></p></li></ul><p>Untuk tipe volume apa saja yang tersedia dan berbagai opsi administrasi yang ada, kamu dapat membaca
<a href=https://access.redhat.com/documentation/en-us/red_hat_gluster_storage/>Petunjuk Administrasi</a>.</p><p>Untuk informasi lebih lanjut, kamu dapat membaca
<a href=https://github.com/heketi/heketi/wiki/Setting-up-the-topology>Bagaimana Cara Mengatur Heketi</a>.</p><p>Ketika PersistentVolume di-<em>provisioning</em> secara dinamis, plugin Gluster secara otomatis
akan membuat <em>endpoint</em> serta sebuah servis <em>headless</em> dengan nama <code>gluster-dynamic-&lt;claimname></code>.
<em>Endpoint</em> dinamis dan servis secara otomatis akan dihapus ketika PVC dihapus.</p></li></ul><h3 id=openstack-cinder>OpenStack Cinder</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>gold<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/cinder<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>availability</span>:<span style=color:#bbb> </span>nova<span style=color:#bbb>
</span></span></span></code></pre></div><ul><li><code>availability</code>: Zona <em>Availability</em>. Jika tidak dispesifikasikan, secara umum volume akan
diatur dengan menggunakan algoritma <em>round-robin</em> pada semua zona aktif
dimana klaster Kubernetes memiliki sebuah node.</li></ul><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes 1.11 [deprecated]</code></div><p><em>Provisioner</em> internal OpenStack ini sudah <em>deprecated</em>. Kamu dapat menggunakan <a href=https://github.com/kubernetes/cloud-provider-openstack><em>provider</em> eksternal penyedia layanan <em>cloud</em> untuk OpenStack</a>.</div><h3 id=vsphere>vSphere</h3><ol><li><p>Buatlah sebuah StorageClass dengan menggunakan sebuah format disk yang dispesifikasikan oleh pengguna.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fast<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/vsphere-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>diskformat</span>:<span style=color:#bbb> </span>zeroedthick<span style=color:#bbb>
</span></span></span></code></pre></div><p><code>diskformat</code>: <code>thin</code>, <code>zeroedthick</code> dan <code>eagerzeroedthick</code>. Nilai default: <code>"thin"</code>.</p></li><li><p>Buatlah sebuah StorageClass dengan menggunakan sebuah format disk pada <em>datastore</em> yang dispesifikasikan oleh pengguna.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fast<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/vsphere-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>diskformat</span>:<span style=color:#bbb> </span>zeroedthick<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>datastore</span>:<span style=color:#bbb> </span>VSANDatastore<span style=color:#bbb>
</span></span></span></code></pre></div><p><code>datastore</code>: Pengguna juga dapat menspesifikasikan <em>datastore</em> pada StorageClass.
Volume akan dibuat pada datastore yang dispesifikasikan pada kelas penyimpanan,
dalam hal ini adalah <code>VSANDatastore</code>. <em>Field</em> ini bersifat opsional. Jika <em>datastore</em>
tidak dispesifikasikan, maka volume akan dibuat dengan menggunakan <em>datastore</em> yang dispesifikasikan
pada berkas konfigurasi vSphere yang digunakan untuk menginisialisasi penyedia layanan cloud vSphere.</p></li><li><p>Manajemen Kebijakan Penyimpanan di dalam Kubernetes</p><ul><li><p>Menggunakan kebijakan (<em>policy</em>) yang ada pada vCenter</p><p>Salah satu dari fitur paling penting yang ada pada vSphere untuk manajemen penyimpanan
adalah manajemen bebasis <em>policy</em>. Storage Policy Based Management (SPBM) adalah <em>framework</em>
yang menyediakan sebuah <em>control plane</em> terpadu pada <em>data service</em> yang meluas dan
solusi penyimpanannya yang tersedia. SPBM memungkinkan administrator vSphere menghadapi
permasalahan yang mungkin muncul seperti <em>capacity planning</em>, membedakan level servis, dan
melakukan manajemen <em>headroom capacity</em>.</p><p><em>Policy</em> SPBM dapat dispesifikasikan pada StorageClass menggunakan parameter
<code>storagePolicyName</code>.</p></li><li><p>Dukungan <em>policy</em> SAN virtual di dalam Kubernetes</p><p>Administrator <em>Vsphere Infrastructure</em> (VI) akan memiliki kemampuan
untuk menspesifikasikan Virtual SAN Storage Capabilities khusus
selama masa <em>provisioning</em> volume secara dinamis. Persyaratan kapabilitas
penyimpanan diubah menjadi sebuah <em>policy</em> Virtual SAN yang nantinya akan
dimasukkan ke dalam lapisan Virtual SAN ketika sebuah <em>persitent volume</em> (penyimpanan
virtual) dibuat. Penyimpanan virtual kemudian akan didistribusikan pada semua
<em>datastore</em> Virtual SAN untuk memenuhi kebutuhan ini.</p><p>Kamu dapat melihat <a href=https://vmware.github.io/vsphere-storage-for-kubernetes/documentation/policy-based-mgmt.html><em>Policy</em> Penyimpanan Berdasarkan Manajemen untuk <em>Provisioning</em> Dinamis Volume</a>
untuk detil lebih lanjut mengenai penggunaan <em>policy</em> penyimpanan untuk manajemen <em>persistent volume</em>.</p></li></ul></li></ol><p>Terdapat beberapa
<a href=https://github.com/kubernetes/examples/tree/master/staging/volumes/vsphere>contoh vSphere</a>
yang dapat kamu gunakan untuk mencoba manajemen <em>persistent volume</em> di dalam Kubernetes untuk vSpehere.</p><h3 id=rbd-ceph>RBD Ceph</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fast<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/rbd<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>monitors</span>:<span style=color:#bbb> </span><span style=color:#666>10.16.153.105</span>:<span style=color:#666>6789</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>adminId</span>:<span style=color:#bbb> </span>kube<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>adminSecretName</span>:<span style=color:#bbb> </span>ceph-secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>adminSecretNamespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>pool</span>:<span style=color:#bbb> </span>kube<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>userId</span>:<span style=color:#bbb> </span>kube<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>userSecretName</span>:<span style=color:#bbb> </span>ceph-secret-user<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>userSecretNamespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>fsType</span>:<span style=color:#bbb> </span>ext4<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>imageFormat</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>imageFeatures</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;layering&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><ul><li><p><code>monitors</code>: Monitor Ceph, merupakan nilai yang dipisahkan oleh koma (csv). Parameter ini dibutuhkan.</p></li><li><p><code>adminId</code>: ID klien Ceph yang dapat digunakan untuk membuat images di dalam pool.
Nilai <em>default</em>-nya adalah "admin".</p></li><li><p><code>adminSecretName</code>: Nama Secret untuk <code>adminId</code>. Parameter ini dibutuhkan.
Secret yang dibutuhkan haruslah memiliki tipe "kubernetes.io/rbd".</p></li><li><p><code>adminSecretNamespace</code>: Namespace untuk <code>adminSecretName</code>. Nilai <em>default</em>-nya adalah "default".</p></li><li><p><code>pool</code>: Pool Ceph RBD. Nilai <em>default</em>-nya adalah "rbd".</p></li><li><p><code>userId</code>: Klien ID Ceph yang digunakan untuk melakukan pemetaan image RBD. Nilai <em>default</em>-nya sama dengan
<code>adminId</code>.</p></li><li><p><code>userSecretName</code>: Nama Secret Ceph untuk <code>userId</code> yang digunakan untuk memetakan image RBD.
Secret ini harus berada pada namespace yang sama dengan PVC. Parameter ini dibutuhkan.
Secret yang disediakan haruslah memiliki tipe "kubernetes.io/rbd", dibuat dengan cara:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret generic ceph-secret --type<span style=color:#666>=</span><span style=color:#b44>&#34;kubernetes.io/rbd&#34;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --from-literal<span style=color:#666>=</span><span style=color:#b8860b>key</span><span style=color:#666>=</span><span style=color:#b44>&#39;QVFEQ1pMdFhPUnQrSmhBQUFYaERWNHJsZ3BsMmNjcDR6RFZST0E9PQ==&#39;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --namespace<span style=color:#666>=</span>kube-system
</span></span></code></pre></div></li><li><p><code>userSecretNamespace</code>: Namespace untuk <code>userSecretName</code>.</p></li><li><p><code>fsType</code>: fsType yang didukung oleh kubernetes. Nilai <em>default</em>-nya adalah: <code>"ext4"</code>.</p></li><li><p><code>imageFormat</code>: Format image Ceph RBD, nilai yang mungkin adalah "1" atau "2". Nilai <em>default</em>-nya adalah "2".</p></li><li><p><code>imageFeatures</code>: Parameter ini bersifat opsional dan hanya dapat digunakan jika kamu mengganti nilai
dari <code>imageFormat</code> ke "2". Saat ini fitur yang didukung hanyalah <code>layering</code>.
Nilai <em>default</em>-nya adalah "", dan tidak ada fitur yang diaktifkan.</p></li></ul><h3 id=quobyte>Quobyte</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>slow<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/quobyte<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>quobyteAPIServer</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;http://138.68.74.142:7860&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>registry</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;138.68.74.142:7861&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>adminSecretName</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;quobyte-admin-secret&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>adminSecretNamespace</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;kube-system&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;root&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>group</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;root&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>quobyteConfig</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;BASE&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>quobyteTenant</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;DEFAULT&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><ul><li><p><code>quobyteAPIServer</code>: API Server dari Quobyte dalam format
<code>"http(s)://api-server:7860"</code></p></li><li><p><code>registry</code>: Registri Quobyte yang digunakan untuk melakukan <em>mount</em> volume. Kamu dapat menspesifikasikan
registri yang kamu inginkan dengan format pasangan <code>&lt;host>:&lt;port></code> atau jika kamu ingin mendefinisikan
beberapa registri sekaligus kamu dapat menempatkan koma diantara setiap pasangan <code>&lt;host>:&lt;port></code> yang ada,
misalnya <code>&lt;host1>:&lt;port>,&lt;host2>:&lt;port>,&lt;host3>:&lt;port></code>.
Host dapat berupa alamat IP atau DNS.</p></li><li><p><code>adminSecretNamespace</code>: Namespace <code>adminSecretName</code>. Nilai default-nya adalah "default".</p></li><li><p><code>adminSecretName</code>: Secret yang mengandung informasi mengenai pengguna Quobyte dan
password yang digunakan untuk melakukan otentikasi API server. Secret yang digunakan
haruslah memiliki tipe "kubernetes.io/quobyte", yang dibuat dengan mekanisme berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret generic quobyte-admin-secret <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --type<span style=color:#666>=</span><span style=color:#b44>&#34;kubernetes.io/quobyte&#34;</span> --from-literal<span style=color:#666>=</span><span style=color:#b8860b>key</span><span style=color:#666>=</span><span style=color:#b44>&#39;opensesame&#39;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --namespace<span style=color:#666>=</span>kube-system
</span></span></code></pre></div></li><li><p><code>user</code>: Melakukan pemetaan terhadap semua akses yang dimiliki pengguna.
Nilai <em>default</em>-nya adalah "root".</p></li><li><p><code>group</code>: Melakukan pemetaan terhadap semua group. Nilai <em>default</em>-nya adalah "nfsnobody".</p></li><li><p><code>quobyteConfig</code>: Menggunakan konfigurasi spesifik untuk membuat volume.
Kamu dapat membuat sebuah file konfigurasi atau melakukan modifikasi terhadap konfigurasi yang sudah ada
dengan menggunakan tatap muka Web atau CLI quobyte. Nilai <em>default</em>-nya adalah "BASE".</p></li><li><p><code>quobyteTenant</code>: Menggunakan ID tenant yang dispesifikasikan untuk membuat/menghapus volume.
<em>Tenant</em> Quobyte haruslah sudah berada di dalam Quobyte. Nilai <em>default</em>-nya adalah "DEFAULT".</p></li></ul><h3 id=azure-disk>Azure Disk</h3><h4 id=kelas-penyimpanan-disk-azure-yang-tidak-dikelola>Kelas Penyimpanan Disk Azure yang Tidak Dikelola</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>slow<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/azure-disk<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>skuName</span>:<span style=color:#bbb> </span>Standard_LRS<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>location</span>:<span style=color:#bbb> </span>eastus<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageAccount</span>:<span style=color:#bbb> </span>azure_storage_account_name<span style=color:#bbb>
</span></span></span></code></pre></div><ul><li><code>skuName</code>: Akun penyimpanan Azure yang ada pada tingkatan Sku. Nilai <em>default</em>-nya adalah kosong.</li><li><code>location</code>: Lokasi akun penyimpanan Azure. Nilai <em>default</em>-nya adalah kosong.</li><li><code>storageAccount</code>: Nama akun penyimpanan Azure. Jika sebuan akun penyimpanan disediakan,
akun tersebut haruslah berada pada grup sumber daya yang ada dengan klaster,
dan <code>location</code> akan diabaikan. Jika sebuah akun penyimpanan tidak disediakan, sebuah akun penyimpanan
baru akan dibuat pada grup sumber daya yang ada dengan klaster.</li></ul><h4 id=kelas-penyimpanan-disk-azure-yang-baru-mulai-versi-v1-7-2>Kelas Penyimpanan Disk Azure yang Baru (mulai versi v1.7.2)</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>slow<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/azure-disk<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageaccounttype</span>:<span style=color:#bbb> </span>Standard_LRS<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>managed<span style=color:#bbb>
</span></span></span></code></pre></div><ul><li><code>storageaccounttype</code>: Akun penyimpanan Azure yang ada pada tingkatan Sku. Nilai <em>default</em>-nya adalah kosong.</li><li><code>kind</code>: Nilai yang mungkin adalah <code>shared</code>, <code>dedicated</code>, dan <code>managed</code> (default).
Ketika <code>kind</code> yang digunakan adalah <code>shared</code>, semua disk yang tidak di-<em>manage</em> akan
dibuat pada beberapa akun penyimpanan yang ada pada grup sumber daya yang sama dengan klaster.
Ketika <code>kind</code> yang digunakan adalah <code>dedicated</code>, sebuah akun penyimpanan
baru akan dibuat pada grup sumber daya yang ada dengan klaster. Ketika <code>kind</code> yang digunakan adalah
<code>managed</code>, semua disk yang dikelola akan dibuat pada grup sumber daya yang ada dengan klaster.</li></ul><ul><li>VM premium dapat di-<em>attach</em> baik pada Standard_LRS dan Premium_LRS disks, sementara Standard
VM hanya dapat di-<em>attach</em> pada disk Standard_LRS.</li><li>VM yang dikelola hanya dapat meng-<em>attach</em> disk yang dikelola dan VM yang tidak dikelola hanya dapat
meng-<em>attach</em> disk yang tidak dikelola.</li></ul><h3 id=berkas-azure>Berkas Azure</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>azurefile<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/azure-file<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>skuName</span>:<span style=color:#bbb> </span>Standard_LRS<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>location</span>:<span style=color:#bbb> </span>eastus<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageAccount</span>:<span style=color:#bbb> </span>azure_storage_account_name<span style=color:#bbb>
</span></span></span></code></pre></div><ul><li><code>skuName</code>: Akun penyimpanan Azure yang ada pada tingkatan Sku. Nilai <em>default</em>-nya adalah kosong.</li><li><code>location</code>: Lokasi akun penyimpanan Azure. Nilai <em>default</em>-nya adalah kosong.</li><li><code>storageAccount</code>: Nama akun penyimpanan Azure. Nilai <em>default</em>-nya adalah kosong. Jika sebuah penyimpanan
tidak memiliki sebuah akun yang disediakan, semua akun penyimpanan yang diasosiasikan dengan
grup sumber daya yang ada dan kemudian melakukan pencarian terhadap akun yang sesuai dengan
<code>skuName</code> dan <code>location</code>. Jika sebuah akun penyimpanan disediakan, akun tersebut haruslah berada
di dalam grup sumber daya yang sama dengan klaster, serta <code>skuName</code> dan <code>location</code> akan diabaikan.</li></ul><p>Selama <em>provision</em>, sebuah secret dibuat untuk menyimpan <em>credentials</em>. Jika klaster
menggunakan konsep <a href=/id/docs/reference/access-authn-authz/rbac/>RBAC</a> dan
<a href=/id/docs/reference/access-authn-authz/rbac/#controller-roles><em>Roles</em> Controller</a>,
menambahkan kapabilitas <code>create</code> untuk sumber daya <code>secret</code> bagi clusterrole
<code>system:controller:persistent-volume-binder</code>.</p><h3 id=volume-portworx>Volume Portworx</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>portworx-io-priority-high<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/portworx-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>repl</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>snap_interval</span>:<span style=color:#bbb>   </span><span style=color:#b44>&#34;70&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>io_priority</span>:<span style=color:#bbb>  </span><span style=color:#b44>&#34;high&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><ul><li><code>fs</code>: filesystem yang akan digunakan: <code>none/xfs/ext4</code> (nilai default-nya: <code>ext4</code>).</li><li><code>block_size</code>: ukuran block dalam Kbytes (nilai <em>default</em>-nya: <code>32</code>).</li><li><code>repl</code>: jumlah replika <em>synchronous</em> yang dapat disediakan dalam bentuk
faktor replikasi <code>1..3</code> (nilai <em>default</em>-nya: <code>1</code>) Nilai yang diharapkan dalam bentuk String
<code>"1"</code> dan bukan <code>1</code>.</li><li><code>io_priority</code>: menentukan apakah volume yang dibuat akan dari penyimpanan dengan kualitas
tinggi atau rendah dengan urutan prioritas <code>high/medium/low</code> (nilai <em>default</em>-nya: <code>low</code>).</li><li><code>snap_interval</code>: interval waktu dalam menit yang digunakan untuk melakukan <em>trigger</em> <em>snapshots</em>.
<em>Snapshots</em> dibuat secara inkremen berdasarkan perbedaan yang ada dengan <em>snapshot</em> yang dibuat sebelumnya,
nilai perbedaan 0 akan menonaktifkan pembuatan <em>snapshot</em> (nilai default-nya: <code>0</code>). Sebuah string merupakan nilai
yang diharapkan <code>"70"</code> dan bukan <code>70</code>.</li><li><code>aggregation_level</code>: menspesifikasikan jumlah <em>chunks</em> dimana volume akan didistribusikan,
0 mengindikasikan volume yang <em>non-aggregate</em> (nilai default-nya: <code>0</code>). Sebuah string merupakan nilai
yang diharapkan <code>"0"</code> dan bukan <code>0</code>.</li><li><code>ephemeral</code>: menentukan apakah volume harus dihapus setelah di-<em>unmount</em>
atau harus tetap ada. Penggunaan <code>emptyDir</code> dapat diubah menjadi true dan penggunaan
<code>persistent volumes</code> untuk basisdata seperti Cassandra harus diubah menjadi false<code>, true/false</code> (nilai default-nya: <code>false</code>). Sebuah string merupakan nilai
yang diharapkan <code>"true"</code> dan bukan <code>true</code>.</li></ul><h3 id=scaleio>ScaleIO</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>slow<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/scaleio<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>gateway</span>:<span style=color:#bbb> </span>https://192.168.99.200:443/api<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>system</span>:<span style=color:#bbb> </span>scaleio<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>protectionDomain</span>:<span style=color:#bbb> </span>pd0<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storagePool</span>:<span style=color:#bbb> </span>sp1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageMode</span>:<span style=color:#bbb> </span>ThinProvisioned<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>secretRef</span>:<span style=color:#bbb> </span>sio-secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>fsType</span>:<span style=color:#bbb> </span>xfs<span style=color:#bbb>
</span></span></span></code></pre></div><ul><li><code>provisioner</code>: atribut yang nilainya merupakan <code>kubernetes.io/scaleio</code></li><li><code>gateway</code>: alamat <em>gateway</em> ScaleIO (wajib)</li><li><code>system</code>: nama sistem ScaleIO (wajib)</li><li><code>protectionDomain</code>: nama domain proteksi ScaleIO (wajib)</li><li><code>storagePool</code>: nama pool volume penyimpanan (wajib)</li><li><code>storageMode</code>: mode <em>provisioning</em> penyimpanan: <code>ThinProvisioned</code> (default) atau
<code>ThickProvisioned</code></li><li><code>secretRef</code>: penunjuk pada objek Secret yang dikonfigurasi (wajib)</li><li><code>readOnly</code>: menentukan mode akses terhadap volume yang di-<em>mount</em> (nilai default-nya: false)</li><li><code>fsType</code>: filesystem yang digunakan untuk volume (nilai default-nya: ext4)</li></ul><p>Plugin volume ScaleIO Kubernetes membutuhkan objek Secret yang suda dikonfigurasi sebelumnya.
Secret ini harus dibuat dengan tipe <code>kubernetes.io/scaleio</code> dan menggunakan namespace yang sama
dengan PVC yang dirujuk, seperti ditunjukkan pada contoh yang ada:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret generic sio-secret --type<span style=color:#666>=</span><span style=color:#b44>&#34;kubernetes.io/scaleio&#34;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>--from-literal<span style=color:#666>=</span><span style=color:#b8860b>username</span><span style=color:#666>=</span>sioadmin --from-literal<span style=color:#666>=</span><span style=color:#b8860b>password</span><span style=color:#666>=</span><span style=color:#b8860b>d2NABDNjMA</span><span style=color:#666>==</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>--namespace<span style=color:#666>=</span>default
</span></span></code></pre></div><h3 id=storageos>StorageOS</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fast<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/storageos<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>pool</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>description</span>:<span style=color:#bbb> </span>Kubernetes volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>fsType</span>:<span style=color:#bbb> </span>ext4<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>adminSecretNamespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>adminSecretName</span>:<span style=color:#bbb> </span>storageos-secret<span style=color:#bbb>
</span></span></span></code></pre></div><ul><li><code>pool</code>: Nama kapasitas distribusi StorageOS yang digunakan untuk melakukan
<em>provisioning</em> volume. <em>Pool</em> default akan digunakan apabila nilainya tidak dispesifikasikan.</li><li><code>description</code>: Deskripsi untuk melakukan <em>assignment</em> volume yang baru dibuat secara dinamis.
Semua deskripsi volume akan bernilai sama untuk kelas penyimpanan yang sama, meskipun begitu
kelas penyimpanan yang berbeda dapat digunakan untuk membuat deskripsi yang berbeda untuk penggunaan
yang berbeda. Nilai default-nya adalah <code>Kubernetes volume</code>.</li><li><code>fsType</code>: Tipe filesystem default yang digunakan. Perhatikan bahwa aturan
yang didefinisikan oleh pengguna di dalam StirageOS dapat meng-<em>override</em> nilai ini.
Nilai default-nya adalah <code>ext4</code>.</li><li><code>adminSecretNamespace</code>: Namespace dimana konfigurasi secret API berada. Hal ini bersifat wajib
apabila adminSecretName diaktifkan.</li><li><code>adminSecretName</code>: Nama secret yang digunakan untuk memperoleh <em>credentials</em> StorageOS
API. Jika tidak dispesifikasikan, nilaidefault akan digunakan.</li></ul><p>Plugin volume dapat menggunakan objek Secret untuk menspesifikasikan
endpoint dan kredensial yang digunakan untuk mengakses API StorageOS.
Hal ini hanya akan dibutuhkan apabila terdapat perubahan pada nilai <em>default</em>.
Secret ini harus dibuat dengan tipe <code>kubernetes.io/storageos</code>,
seperti ditunjukkan pada contoh yang ada:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret generic storageos-secret <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>--type<span style=color:#666>=</span><span style=color:#b44>&#34;kubernetes.io/storageos&#34;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>--from-literal<span style=color:#666>=</span><span style=color:#b8860b>apiAddress</span><span style=color:#666>=</span>tcp://localhost:5705 <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>--from-literal<span style=color:#666>=</span><span style=color:#b8860b>apiUsername</span><span style=color:#666>=</span>storageos <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>--from-literal<span style=color:#666>=</span><span style=color:#b8860b>apiPassword</span><span style=color:#666>=</span>storageos <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>--namespace<span style=color:#666>=</span>default
</span></span></code></pre></div><p>Secret yang digunakan untuk melakukan <em>provisioning</em> volume secara dinamis
dapat dibuat di namespace apapun dan dirujuk dengan menggunakan parameter <code>adminSecretNamespace</code>.
Secret yang digunakan oleh volume yang sedang di-<em>provisioning</em> harus dibuat pada namespace yang sama
dengan PVC yang merujuk secret tersebut.</p><h3 id=lokal>Lokal</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.14 [stable]</code></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>local-storage<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/no-provisioner<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>volumeBindingMode</span>:<span style=color:#bbb> </span>WaitForFirstConsumer<span style=color:#bbb>
</span></span></span></code></pre></div><p>Volume lokal tidak mendukung adanya <em>provisioning</em> secara dinamis,
meskipun begitu sebuah StorageClass akan tetap dibuat untuk mencegah terjadinya <em>bind</em> volume
sampai <em>scheduling</em> pod dilakukan. Hal ini dispesifikasikan oleh mode <em>binding</em> volume
<code>WaitForFirstConsumer</code>.</p><p>Memperlambat <em>binding</em> volume mengizinkan <em>scheduler</em> untuk memastikan
batasan <em>scheduling</em> semua pod ketika memilih PersistentVolume untuk sebuah PersistentVolumeClaim.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-4d00116c86dade62bdd5be7dc2afa1ca>3.6.6 - VolumeSnapshotClass</h1><p>Laman ini menjelaskan tentang konsep VolumeSnapshotClass pada Kubernetes. Sebelum melanjutkan,
sangat disarankan untuk membaca <a href=/id/docs/concepts/storage/volume-snapshots/><em>snapshot</em> volume</a>
dan <a href=/id/docs/concepts/storage/storage-classes>kelas penyimpanan (<em>storage class</em>)</a> terlebih dahulu.</p><h2 id=pengenalan>Pengenalan</h2><p>Seperti halnya StorageClass yang menyediakan cara bagi admin untuk mendefinisikan
"kelas" penyimpanan yang mereka tawarkan saat proses penyediaan sebuah volume, VolumeSnapshotClass
menyediakan cara untuk mendefinisikan "kelas" penyimpanan saat menyediakan <em>snapshot</em> volume.</p><h2 id=sumber-daya-volumesnapshotclass>Sumber Daya VolumeSnapshotClass</h2><p>Masing-masing VolumeSnapshotClass terdiri dari <em>field</em> <code>snapshotter</code> dan <code>parameters</code>,
yang digunakan saat sebuah VolumeSnapshot yang dimiliki kelas tersebut perlu untuk
disediakan secara dinamis.</p><p>Nama yang dimiliki suatu objek VolumeSnapshotClass sangatlah penting, karena digunakan
oleh pengguna saat meminta sebuah kelas tertentu. Admin dapat mengatur nama dan parameter
lainnya dari sebuah kelas saat pertama kali membuat objek VolumeSnapshotClass. Objek
tidak dapat diubah setelah dibuat.</p><p>Admin dapat mengatur VolumeSnapshotClass <em>default</em> untuk VolumeSnapshot yang tidak
memiliki spesifikasi kelas apapun.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>snapshot.storage.k8s.io/v1alpha1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>VolumeSnapshotClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>csi-hostpath-snapclass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>snapshotter</span>:<span style=color:#bbb> </span>csi-hostpath<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=snapshotter><code>snapshotter</code></h3><p>VolumeSnapshotClass memiliki sebuah <code>snapshotter</code> yang menentukan plugin volume CSI
apa yang digunakan untuk penyediaan VolumeSnapshot. <em>Field</em> ini wajib diatur.</p><h3 id=parameters><code>parameters</code></h3><p>VolumeSnapshotClass memiliki parameter-parameter yang menggambarkan <em>snapshot</em> volume
di dalam VolumeSnapshotClass. Parameter-parameter yang berbeda diperbolehkan tergantung
dari <code>shapshotter</code>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-018f0a7fc6e2f6d16da37702fc39b4f3>3.6.7 - Penyediaan Volume Dinamis</h1><p>Penyediaan volume dinamis memungkinkan volume penyimpanan untuk dibuat sesuai permintaan (<em>on-demand</em>).
Tanpa adanya penyediaan dinamis (<em>dynamic provisioning</em>), untuk membuat volume penyimpanan baru, admin klaster secara manual harus
memanggil penyedia layanan cloud atau layanan penyimpanan, dan kemudian membuat <a href=/id/docs/concepts/storage/persistent-volumes/>objek PersistentVolume</a>
sebagai representasi di Kubernetes. Fitur penyediaan dinamis menghilangkan kebutuhan admin klaster untuk menyediakan
penyimpanan sebelumnya (<em>pre-provision</em>). Dengan demikian, penyimpanan akan tersedia secara otomatis
ketika diminta oleh pengguna.</p><h2 id=latar-belakang>Latar Belakang</h2><p>Penyediaan volume dinamis diimplementasi berdasarkan objek API StorageClass dari
grup API <code>storage.k8s.io</code>. Seorang admin klaster dapat mendefinisikan berbagai macam
objek StorageClass sesuai kebutuhan, masing-masing menentukan <em>plugin volume</em> (disebut
juga <em>provisioner</em>) yang menyediakan sebuah volume beserta kumpulan parameter untuk
diteruskan oleh <em>provisioner</em> ketika proses penyediaan.</p><p>Seorang klaster admin dapat mendefinisikan dan mengekspos berbagai templat penyimpanan
(dari sistem penyimpanan yang sama maupun berbeda) di dalam klaster, masing-masing dengan
kumpulan parameter tertentu. Desain ini memastikan bahwa pengguna tidak perlu khawatir betapa
rumitnya mekanisme penyediaan penyimpanan, tapi tetap memiliki kemampuan untuk
memilih berbagai macam pilihan penyimpanan.</p><p>Info lebih lanjut mengenai <em>storage class</em> dapat dilihat <a href=/id/docs/concepts/storage/storage-classes/>di sini</a>.</p><h2 id=mengaktifkan-penyediaan-dinamis-dynamic-provisioning>Mengaktifkan Penyediaan Dinamis (<em>Dynamic Provisioning</em>)</h2><p>Untuk mengaktifkan penyediaan dinamis, seorang admin klaster perlu untuk
terlebih dahulu membuat (<em>pre-create</em>) satu atau beberapa objek StorageClass
untuk pengguna.
Objek StorageClass mendefinisikan <em>provisioner</em> mana yang seharusnya digunakan
dan parameter apa yang seharusnya diberikan pada <em>provisioner</em> tersebut saat
penyediaan dinamis dipanggil.
Manifestasi berikut ini membuat sebuah StorageClass "slow" yang
menyediakan <em>persistent</em> disk standar.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>slow<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/gce-pd<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>pd-standard<span style=color:#bbb>
</span></span></span></code></pre></div><p>Manifestasi berikut ini membuat sebuah StorageClass "fast" yang menyediakan
SSD <em>persistent</em> disk.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fast<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/gce-pd<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>pd-ssd<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=menggunakan-penyediaan-dinamis>Menggunakan Penyediaan Dinamis</h2><p>Pengguna dapat melakukan permintaan untuk penyediaan penyimpanan dinamis dengan
memasukkan StorageClass di dalam PersistentVolumeClaim. Sebelum Kubernetes v1.6,
ini dapat dilakukan melalui anotasi <code>volume.beta.kubernetes.io/storage-class</code>.
Hanya saja, anotasi ini sudah usang sejak v1.6. Pengguna sekarang dapat dan seharusnya
menggunakan <em>field</em> <code>storageClassName</code> dari objek PersistentVolumeClaim. Nilai
dari <em>field</em> ini haruslah sesuai dengan nama StorageClass yang dikonfigurasi oleh
admin (lihat bagian <a href=#enabling-dynamic-provisioning>di bawah</a>).</p><p>Untuk memilih StorageClass "fast", sebagai contoh, pengguna dapat membuat
PersistentVolumeClaim seperti ini:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>claim1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>fast<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>30Gi<span style=color:#bbb>
</span></span></span></code></pre></div><p>Klaim ini menghasilkan <em>persistent</em> disk SSD yang disediakan secara otomatis.
Ketika klaim dihilangkan, volume akan musnah.</p><h2 id=perilaku-default>Perilaku <em>Default</em></h2><p>Penyediaan dinamis dapat diaktifkan pada setiap klaster supaya semua klaim
dapat disediakan secara dinamis jika tidak ada StorageClass yang dispesifikasikan.
Seorang klaster admin dapat mengaktifkan perilaku ini dengan cara:</p><ul><li>Menandai satu objek StorageClass sebagai <em>default</em>;</li><li>Memastikan bahwa <a href=/docs/reference/access-authn-authz/admission-controllers/#defaultstorageclass><em>admission controller</em> <code>DefaultStorageClass</code></a>
telah aktif pada API server.</li></ul><p>Seorang admin dapat menandai StorageClass yang spesifik sebagai <em>default</em> dengan menambahkan
anotasi <code>storageclass.kubernetes.io/is-default-class</code>.
Ketika StorageClass default tersebut ada pada klaster dan pengguna membuat PersistentVolumeClaim
tanpa menspesifikasikan <code>storageClassName</code>, <em>admission controller</em> <code>DefaultStorageClass</code> secara
otomatis menambahkan <em>field</em> <code>storageClassName</code> dengan StorageClass <em>default</em>.</p><p>Perhatikan bahwa hanya bisa ada satu <em>default</em> StorageClass pada sebuah klaster,
atau PersistentVolumeClaim tanpa menspesifikasikan <code>storageClassName</code> secara eksplisit
tidak bisa terbuat.</p><h2 id=kesadaran-awareness-topologi>Kesadaran (<em>Awareness</em>) Topologi</h2><p>Pada klaster <a href=/docs/setup/multiple-zones>Multi-Zona</a>, Pod dapat tersebar di banyak Zona
pada sebuah Region. Penyimpanan dengan <em>backend</em> Zona-Tunggal seharusnya disediakan pada
Zona-Zona dimana Pod dijalankan. Hal ini dapat dicapai dengan mengatur
<a href=/id/docs/concepts/storage/storage-classes/#volume-binding-mode>Mode Volume Binding</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-b2e4b16ac37988c678a3312a4a6639f8>3.6.8 - Limit Volume yang Spesifik terhadap Node</h1><p>Laman ini menjelaskan soal jumlah volume maksimal yang dapat dihubungkan
ke sebuah Node untuk berbagai penyedia layanan cloud.</p><p>Penyedia layanan cloud seperti Google, Amazon, dan Microsoft pada umumnya memiliki
keterbatasan dalam jumlah volume yang bisa terhubung ke sebuah Node. Keterbatasn ini
sangatlah penting untuk diketahui Kubernetes dalam menentukan keputusan. Jika tidak,
Pod-pod yang telah dijadwalkan pada sebuah Node akan macet dan menunggu terus-menerus
untuk terhubung pada volume.</p><h2 id=limit-default-pada-kubernetes>Limit <em>default</em> pada Kubernetes</h2><p>Kubernetes <em>scheduler</em> memiliki limit <em>default</em> untuk jumlah volume
yang dapat terhubung pada sebuah Node:</p><table><tr><th>Penyedia layanan cloud</th><th>Jumlah volume maksimal per Node</th></tr><tr><td><a href=https://aws.amazon.com/ebs/>Amazon Elastic Block Store (EBS)</a></td><td>39</td></tr><tr><td><a href=https://cloud.google.com/persistent-disk/>Google Persistent Disk</a></td><td>16</td></tr><tr><td><a href=https://azure.microsoft.com/en-us/services/storage/main-disks/>Microsoft Azure Disk Storage</a></td><td>16</td></tr></table><h2 id=limit-custom>Limit <em>custom</em></h2><p>Kamu dapat mengganti limit-limit ini dengan mengkonfigurasi nilai dari
variabel <em>environment</em> <code>KUBE_MAX_PD_VOLS</code>, lalu menjalankan <em>scheduler</em>.</p><p>Berhati-hatilah jika kamu menerapkan limit yang lebih besar dari limit <em>default</em>.
Perhatikan dokumentasi penyedia layanan cloud untuk hal ini, dan pastikan Node
benar-benar dapat mendukung nilai limit yang kamu inginkan.</p><p>Limit ini diterapkan untuk seluruh klaster, jadi akan berdampak pada semua Node.</p><h2 id=limit-volume-dinamis>Limit volume dinamis</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.12 [beta]</code></div><p>Sebagai fitur Alpha, Kubernetes 1.11 memperkenalkan dukungan untuk limit volume yang dinamis berdasarkan tipe Node.
Pada Kubernettes 1.12, fitur ini telah mendapat promosi ke Beta dan akan diaktifkan secara <em>default</em>.</p><p>Limit volume dinamis mendukung tipe-tipe volume berikut:</p><ul><li>Amazon EBS</li><li>Google Persistent Disk</li><li>Azure Disk</li><li>CSI</li></ul><p>Ketika fitur limit volume dinamis diaktifkan, Kubernetes secara otomatis
menentukan tipe Node dan menerapkan jumlah volume dengan tepat, berapa yang bisa
terhubung Node. Sebagai contoh:</p><ul><li><p>Pada
<a href=https://cloud.google.com/compute/>Google Compute Engine</a>,
maskimal 128 jumlah volumes dapat terhubung pada sebuah node, <a href=https://cloud.google.com/compute/docs/disks/#pdnumberlimits>tergantung dari
tipe node</a>.</p></li><li><p>Untuk Amazon EBS disk pada tipe instans M5,C5,R5,T3 dan Z1D, Kubernetes hanya memperbolehkan 25
volume dapat terhubung pada sebuah Node. Untuk tipe instans lainnya pada
<a href=https://aws.amazon.com/ec2/>Amazon Elastic Compute Cloud (EC2)</a>,
Kubernetes memperbolehkan 39 jumlah volume dapat terhubung pada sebuah Node.</p></li><li><p>Pada Azure, maksimal 64 jumlah disk dapat terhubung pada suatu node, tergantung dari tipe node. Untuk perinciannya
bisa dilihat pada <a href=https://docs.microsoft.com/en-us/azure/virtual-machines/windows/sizes>Ukuran mesin virtual (VM) di Azure</a>.</p></li><li><p>Untuk CSI, driver manapun yang memberitahukan (<em>advertise</em>) limit volume terhubung melalui spek CSI akan memiliki limit tersebut yang disediakan
sebagai properti Node dan Scheduler tidak akan menjadwalkan Pod dengan volume pada Node manapun yang sudah penuh kapasitasnya. Untuk penjelasan lebih jauh
lihat <a href=https://github.com/container-storage-interface/spec/blob/master/spec.md#nodegetinfo>spek CSI</a>.</p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-275bea454e1cf4c5adeca4058b5af988>3.7 - Konfigurasi</h1></div><div class=td-content><h1 id=pg-ddef6fd0e47bb51c6f05e8e7fb11d2dd>3.7.1 - Konfigurasi dan Penerapan Konsep</h1><p>Dokumen ini menyoroti dan memperkuat pemahaman konsep konfigurasi yang dikenalkan di seluruh panduan pengguna, dokumentasi Memulai, dan contoh-contoh.</p><p>Dokumentasi ini terbuka. Jika Anda menemukan sesuatu yang tidak ada dalam daftar ini tetapi mungkin bermanfaat bagi orang lain, jangan ragu untuk mengajukan issue atau mengirimkan PR.</p><h2 id=tip-konfigurasi-secara-umum>Tip konfigurasi secara umum</h2><ul><li><p>Saat mendefinisikan konfigurasi, tentukan versi API stabil terbaru.</p></li><li><p>File konfigurasi harus disimpan dalam version control sebelum di push ke cluster. Ini memungkinkan Anda untuk dengan cepat mengembalikan perubahan konfigurasi jika perlu. Ini juga membantu penciptaan dan restorasi cluster.</p></li><li><p>Tulis file konfigurasi Anda menggunakan YAML tidak dengan JSON. Meskipun format ini dapat digunakan secara bergantian di hampir semua skenario, YAML cenderung lebih ramah pengguna.</p></li><li><p>Kelompokkan objek terkait ke dalam satu file yang memungkinkan. Satu file seringkali lebih mudah dikelola daripada beberapa file. Lihat pada <a href=https://github.com/kubernetes/examples/tree/master/guestbook/all-in-one/guestbook-all-in-one.yaml>guestbook-all-in-one.yaml</a> sebagai contoh file sintaks ini.</p></li><li><p>Perhatikan juga bahwa banyak perintah <code>kubectl</code> dapat dipanggil pada direktori. Misalnya, Anda dapat memanggil <code>kubectl apply</code> pada direktori file konfigurasi.</p></li><li><p>Jangan tentukan nilai default yang tidak perlu: sederhana, konfigurasi minimal akan membuat kesalahan lebih kecil.</p></li><li><p>Masukkan deskripsi objek dalam anotasi, untuk memungkinkan introspeksi yang lebih baik.</p></li></ul><h2 id=naked-pods-vs-replicasets-deployments-and-jobs>"Naked" Pods vs ReplicaSets, Deployments, and Jobs</h2><ul><li><p>Jangan gunakan Pods naked (artinya, Pods tidak terikat dengan a <a href=/id/docs/concepts/workloads/controllers/replicaset/>ReplicaSet</a> a <a href=/id/docs/concepts/workloads/controllers/deployment/>Deployment</a>) jika kamu bisa menghindarinya. Pod naked tidak akan dijadwal ulang jika terjadi kegagalan pada node.</p><p>Deployment, yang keduanya menciptakan ReplicaSet untuk memastikan bahwa jumlah Pod yang diinginkan selalu tersedia, dan menentukan strategi untuk mengganti Pods (seperti <a href=/id/docs/concepts/workloads/controllers/deployment/#rolling-update-deployment>RollingUpdate</a>), hampir selalu lebih disukai daripada membuat Pods secara langsung, kecuali untuk beberapa yang eksplisit <a href=/id/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy><code>restartPolicy: Never</code></a> banyak skenario . A <a href=/id/docs/concepts/workloads/controllers/job/>Job</a> mungkin juga sesuai.</p></li></ul><h2 id=services>Services</h2><ul><li><p>Buat <a href=/id/docs/concepts/services-networking/service/>Service</a> sebelum workloads backend terkait (Penyebaran atau ReplicaSets), dan sebelum workloads apa pun yang perlu mengaksesnya. Ketika Kubernetes memulai sebuah container, ia menyediakan environment variabel yang menunjuk ke semua Layanan yang berjalan ketika container itu dimulai. Misalnya, jika Layanan bernama <code>foo</code> ada, semua container akan mendapatkan variabel berikut di environment awalnya:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#b8860b>FOO_SERVICE_HOST</span><span style=color:#666>=</span>&lt;the host the Service is running on&gt;
</span></span><span style=display:flex><span><span style=color:#b8860b>FOO_SERVICE_PORT</span><span style=color:#666>=</span>&lt;the port the Service is running on&gt;
</span></span></code></pre></div><p>*Ini menunjukan persyaratan pemesanan * - <code>Service</code> apa pun yang ingin diakses oleh <code>Pod</code> harus dibuat sebelum <code>Pod</code> itu sendiri, atau environment variabel tidak akan diisi. DNS tidak memiliki batasan ini.</p></li><li><p>Opsional (meskipun sangat disarankan) <a href=/id/docs/concepts/cluster-administration/addons/>cluster add-on</a> adalah server DNS.
Server DNS melihat API Kubernetes untuk <code>Service</code> baru dan membuat satu set catatan DNS untuk masing-masing. Jika DNS telah diaktifkan di seluruh cluster maka semua <code>Pods</code> harus dapat melakukan resolusi nama<code>Service</code> secara otomatis.</p></li><li><p>Jangan tentukan <code>hostPort</code> untuk Pod kecuali jika benar-benar diperlukan. Ketika Anda bind Pod ke <code>hostPort</code>, hal itu membatasi jumlah tempat Pod dapat dijadwalkan, karena setiap kombinasi &lt;<code>hostIP</code>, <code>hostPort</code>, <code>protokol</code>> harus unik. Jika Anda tidak menentukan <code>hostIP</code> dan <code>protokol</code> secara eksplisit, Kubernetes akan menggunakan <code>0.0.0.0</code> sebagai <code>hostIP</code> dan <code>TCP</code> sebagai default <code>protokol</code>.</p><p>Jika kamu hanya perlu akses ke port untuk keperluan debugging, Anda bisa menggunakan <a href=/id/docs/tasks/access-application-cluster/access-cluster/#manually-constructing-apiserver-proxy-urls>apiserver proxy</a> atau <a href=/id/docs/tasks/access-application-cluster/port-forward-access-application-cluster/><code>kubectl port-forward</code></a>.</p><p>Jika Anda secara eksplisit perlu mengekspos port Pod pada node, pertimbangkan untuk menggunakan <a href=/id/docs/concepts/services-networking/service/#nodeport>NodePort</a> Service sebelum beralih ke <code>hostPort</code>.</p></li><li><p>Hindari menggunakan <code>hostNetwork</code>, untuk alasan yang sama seperti <code>hostPort</code>.</p></li><li><p>Gunakan [headless Services](/id/docs/concepts/services-networking/service/#headless-
services) (yang memiliki <code>ClusterIP</code> dari <code>None</code>) untuk Service discovery yang mudah ketika Anda tidak membutuhkan <code>kube-proxy</code> load balancing.</p></li></ul><h2 id=menggunakan-label>Menggunakan label</h2><ul><li>Deklarasi dan gunakan [labels] (/id/docs/concepts/overview/working-with-objects/labels/) untuk identifikasi <strong>semantic attributes</strong> aplikasi atau Deployment kamu, seperti <code>{ app: myapp, tier: frontend, phase: test, deployment: v3 }</code>. Kamu dapat menggunakan label ini untuk memilih Pod yang sesuai untuk sumber daya lainnya; misalnya, Service yang memilih semua <code>tier: frontend</code> Pods, atau semua komponen <code>phase: test</code> dari <code>app: myapp</code>. Lihat <a href=https://github.com/kubernetes/examples/tree/main/guestbook/>guestbook</a> aplikasi untuk contoh-contoh pendekatan ini.</li></ul><p>Service dapat dibuat untuk menjangkau beberapa Penyebaran dengan menghilangkan label khusus rilis dari pemilihnya. <a href=/id/docs/concepts/workloads/controllers/deployment/>Deployments</a> membuatnya mudah untuk memperbarui Service yang sedang berjalan tanpa downtime.</p><p>Keadaan objek yang diinginkan dideskripsikan oleh Deployment, dan jika perubahan terhadap spesifikasi tersebut adalah <em>applied</em>, Deployment controller mengubah keadaan aktual ke keadaan yang diinginkan pada tingkat yang terkontrol.</p><ul><li>Kamu dapat memanipulasi label untuk debugging. Karena Kubernetes controller (seperti ReplicaSet) dan Service Match dengan Pods menggunakan label pemilih, menghapus label yang relevan dari Pod akan menghentikannya dari dianggap oleh Controller atau dari lalu lintas yang dilayani oleh Service. Jika Anda menghapus label dari Pod yang ada, Controller akan membuat Pod baru untuk menggantikannya. Ini adalah cara yang berguna untuk men-debug Pod yang sebelumnya "live" di Environment "quarantine". Untuk menghapus atau menambahkan label secara interaktif, gunakan <a href=/docs/reference/generated/kubectl/kubectl-commands#label><code>kubectl label</code></a>.</li></ul><h2 id=container-images>Container Images</h2><p>Ini <a href=/id/docs/concepts/containers/images/#updating-images>imagePullPolicy</a> dan tag dari image mempengaruhi ketika <a href=/docs/admin/kubelet/>kubelet</a> mencoba menarik image yang ditentukan</p><ul><li><p><code>imagePullPolicy: IfNotPresent</code>: image ditarik hanya jika belum ada secara lokal.</p></li><li><p><code>imagePullPolicy: Always</code>: Image ditarik setiap kali pod dimulai.</p></li><li><p><code>imagePullPolicy</code> dihilangkan dan tag imagenya adalah <code>:latest</code> atau dihilangkan:<code>always</code> diterapkan.</p></li><li><p><code>imagePullPolicy</code> dihilangkan dan tag image ada tetapi tidak <code>:latest</code>:<code> IfNotPresent</code> diterapkan.</p></li><li><p><code>imagePullPolicy: Never</code>: image diasumsikan ada secara lokal. Tidak ada upaya yang dilakukan untuk menarik image.</p></li></ul><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Untuk memastikan container selalu menggunakan versi image yang sama, Anda bisa menentukannya <a href=https://docs.docker.com/engine/reference/commandline/pull/#pull-an-image-by-digest-immutable-identifier>digest</a>, untuk contoh <code>sha256:45b23dee08af5e43a7fea6c4cf9c25ccf269ee113168c19722f87876677c5cb2</code>. digest mengidentifikasi secara unik versi image tertentu, sehingga tidak pernah diperbarui oleh Kubernetes kecuali Anda mengubah nilai digest.</div><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Anda harus menghindari penggunaan tag <code>: latest</code> saat menempatkan container dalam produksi karena lebih sulit untuk melacak versi image mana yang sedang berjalan dan lebih sulit untuk memutar kembali dengan benar.</div><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Semantik caching dari penyedia gambar yang mendasarinya membuat bahkan <code>imagePullPolicy: Always</code> efisien. Dengan Docker, misalnya, jika image sudah ada, upaya pull cepat karena semua lapisan image di-cache dan tidak perlu mengunduh image.</div><h2 id=menggunakan-kubectl>Menggunakan kubectl</h2><ul><li><p>Gunakan <code>kubectl apply -f &lt;directory></code>. Ini mencari konfigurasi Kubernetes di semua file <code>.yaml</code>, <code>.yml</code>, dan <code>.json</code> di <code>&lt;directory></code> dan meneruskannya ke <code>apply</code>.</p></li><li><p>Gunakan label selector untuk operasi <code>get</code> dan <code>delete</code> alih-alih nama objek tertentu. Lihat bagian di <a href=/id/docs/concepts/overview/working-with-objects/labels/#label-selectors>label selectors</a> dan <a href=/id/docs/concepts/cluster-administration/manage-deployment/#using-labels-effectively>using labels effectively</a>.</p></li><li><p>Gunakan <code>kubectl run</code> dan <code>kubectl expose</code> untuk dengan cepat membuat Deployment dan Service single-container. Lihat <a href=/docs/tasks/access-application-cluster/service-access-application-cluster/>Use a Service to Access an Application in a Cluster</a> untuk Contoh.</p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-4c9401ed6b037e1adb958cbce20630c7>3.7.2 - Mengatur Sumber Daya Komputasi untuk Container</h1><p>Saat kamu membuat spesifikasi sebuah <a href=/id/docs/concepts/workloads/pods/pod/>Pod</a>, kamu
dapat secara opsional menentukan seberapa banyak CPU dan memori (RAM) yang dibutuhkan
oleh setiap Container. Saat Container-Container menentukan <em>request</em> (permintaan) sumber daya,
scheduler dapat membuat keputusan yang lebih baik mengenai Node mana yang akan dipilih
untuk menaruh Pod-Pod. Dan saat limit (batas) sumber daya Container-Container telah ditentukan,
maka kemungkinan rebutan sumber daya pada sebuah Node dapat dihindari.
Untuk informasi lebih lanjut mengenai perbedaan <code>request</code> dan <code>limit</code>, lihat <a href=https://git.k8s.io/community/contributors/design-proposals/node/resource-qos.md>QoS Sumber Daya</a>.</p><h2 id=jenis-jenis-sumber-daya>Jenis-jenis sumber daya</h2><p><em>CPU</em> dan <em>memori</em> masing-masing merupakan <em>jenis sumber daya</em> (<em>resource type</em>).
Sebuah jenis sumber daya memiliki satuan dasar. CPU ditentukan dalam satuan jumlah <em>core</em>,
dan memori ditentukan dalam satuan <em>bytes</em>. Jika kamu menggunakan Kubernetes v1.14 keatas,
kamu dapat menentukan sumber daya <em>huge page</em>. <em>Huge page</em> adalah fitur khusus Linux
di mana kernel Node mengalokasikan blok-blok memori yang jauh lebih besar daripada ukuran
<em>page</em> bawaannya.</p><p>Sebagai contoh, pada sebuah sistem di mana ukuran <em>page</em> bawaannya adalah 4KiB, kamu
dapat menentukan sebuah limit, <code>hugepages-2Mi: 80Mi</code>. Jika kontainer mencoba mengalokasikan
lebih dari 40 <em>huge page</em> berukuran 20MiB (total 80MiB), maka alokasi tersebut akan gagal.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Kamu tidak dapat melakukan <em>overcommit</em> terhadap sumber daya <code>hugepages-*</code>.
Hal ini berbeda dari sumber daya <code>memory</code> dan <code>cpu</code> (yang dapat di-<em>overcommit</em>).</div><p>CPU dan memori secara kolektif disebut sebagai <em>sumber daya komputasi</em>, atau cukup
<em>sumber daya</em> saja. Sumber daya komputasi adalah jumlah yang dapat diminta, dialokasikan,
dan dikonsumsi. Mereka berbeda dengan <a href=/id/docs/concepts/overview/kubernetes-api/>sumber daya API</a>.
Sumber daya API, seperti Pod dan <a href=/id/docs/concepts/services-networking/service/>Service</a> adalah
objek-objek yang dapat dibaca dan diubah melalui Kubernetes API Server.</p><h2 id=request-dan-limit-sumber-daya-dari-pod-dan-container>Request dan Limit Sumber daya dari Pod dan Container</h2><p>Setiap Container dari sebuah Pod dapat menentukan satu atau lebih dari hal-hal berikut:</p><ul><li><code>spec.containers[].resources.limits.cpu</code></li><li><code>spec.containers[].resources.limits.memory</code></li><li><code>spec.containers[].resources.limits.hugepages-&lt;size></code></li><li><code>spec.containers[].resources.requests.cpu</code></li><li><code>spec.containers[].resources.requests.memory</code></li><li><code>spec.containers[].resources.requests.hugepages-&lt;size></code></li></ul><p>Walaupun <code>requests</code> dan <code>limits</code> hanya dapat ditentukan pada Container individual, akan
lebih mudah untuk membahas tentang request dan limit sumber daya dari Pod. Sebuah
<em>request/limit sumber daya Pod</em> untuk jenis sumber daya tertentu adalah jumlah dari
request/limit sumber daya pada jenis tersebut untuk semua Container di dalam Pod tersebut.</p><h2 id=arti-dari-cpu>Arti dari CPU</h2><p>Limit dan request untuk sumber daya CPU diukur dalam satuan <em>cpu</em>.
Satu cpu, dalam Kubernetes, adalah sama dengan:</p><ul><li>1 vCPU AWS</li><li>1 Core GCP</li><li>1 vCore Azure</li><li>1 vCPU IBM</li><li>1 <em>Hyperthread</em> pada sebuah prosesor Intel <em>bare-metal</em> dengan Hyperthreading</li></ul><p>Request dalam bentuk pecahan diizinkan. Sebuah Container dengan
<code>spec.containers[].resources.requests.cpu</code> bernilai <code>0.5</code> dijamin mendapat
setengah CPU dibandingkan dengan yang meminta 1 CPU. Ekspresi nilai <code>0.1</code> ekuivalen
dengan ekspresi nilai <code>100m</code>, yang dapat dibaca sebagai "seratus milicpu". Beberapa
orang juga membacanya dengan "seratus milicore", dan keduanya ini dimengerti sebagai
hal yang sama. Sebuah request dengan angka di belakang koma, seperti <code>0.1</code> dikonversi
menjadi <code>100m</code> oleh API, dan presisi yang lebih kecil lagi dari <code>1m</code> tidak dibolehkan.
Untuk alasan ini, bentuk <code>100m</code> mungkin lebih disukai.</p><p>CPU juga selalu diminta dalam jumlah yang mutlak, tidak sebagai jumlah yang relatif;
0.1 adalah jumlah CPU yang sama pada sebuah mesin <em>single-core</em>, <em>dual-core</em>, atau
<em>48-core</em>.</p><h2 id=arti-dari-memori>Arti dari Memori</h2><p>Limit dan request untuk <code>memory</code> diukur dalam satuan <em>bytes</em>. Kamu dapat mengekspresikan
memori sebagai <em>plain integer</em> atau sebagai sebuah <em>fixed-point integer</em> menggunakan
satu dari sufiks-sufiks berikut: E, P, T, G, M, K. Kamu juga dapat menggunakan bentuk
pangkat dua ekuivalennya: Ei, Pi, Ti, Gi, Mi, Ki.
Sebagai contoh, nilai-nilai berikut kurang lebih sama:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>128974848, 129e6, 129M, 123Mi
</span></span></code></pre></div><p>Berikut sebuah contoh.
Pod berikut memiliki dua Container. Setiap Container memiliki request 0.25 cpu dan
64MiB (2<sup>26</sup> bytes) memori. Setiap Container memiliki limit 0.5 cpu dan
128MiB memori. Kamu dapat berkata bahwa Pod tersebut memiliki request 0.5 cpu dan
128MiB memori, dan memiliki limit 1 cpu dan 265MiB memori.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>db<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MYSQL_ROOT_PASSWORD<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;password&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;64Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;250m&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;128Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;500m&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>wp<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;64Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;250m&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;128Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;500m&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=bagaimana-pod-pod-dengan-request-sumber-daya-dijadwalkan>Bagaimana Pod-Pod dengan request sumber daya dijadwalkan</h2><p>Saat kamu membuat sebuah Pod, Kubernetes scheduler akan memilih sebuah Node
untuk Pod tersebut untuk dijalankan. Setiap Node memiliki kapasitas maksimum
untuk setiap jenis sumber daya: jumlah CPU dan memori yang dapat disediakan
oleh Node tersebut untuk Pod-Pod. Scheduler memastikan bahwa, untuk setiap
jenis sumber daya, jumlah semua request sumber daya dari Container-Container
yang dijadwalkan lebih kecil dari kapasitas Node tersebut. Perlu dicatat
bahwa walaupun penggunaan sumber daya memori atau CPU aktual/sesungguhnya pada
Node-Node sangat rendah, scheduler tetap akan menolak untuk menaruh sebuah
Pod pada sebuah Node jika pemeriksaan kapasitasnya gagal. Hal ini adalah untuk
menjaga dari kekurangan sumber daya pada sebuah Node saat penggunaan sumber daya
meningkat suatu waktu, misalnya pada saat titik puncak <em>traffic</em> harian.</p><h2 id=bagaimana-pod-pod-dengan-limit-sumber-daya-dijalankan>Bagaimana Pod-Pod dengan limit sumber daya dijalankan</h2><p>Saat Kubelet menjalankan sebuah Container dari sebuah Pod, Kubelet tersebut
mengoper limit CPU dan memori ke <em>runtime</em> kontainer.</p><p>Ketika menggunakan Docker:</p><ul><li><p><code>spec.containers[].resources.requests.cpu</code> diubah menjadi nilai <em>core</em>-nya,
yang mungkin berbentuk angka pecahan, dan dikalikan dengan 1024. Nilai yang
lebih besar antara angka ini atau 2 digunakan sebagai nilai dari <em>flag</em>
<a href=https://docs.docker.com/engine/reference/run/#cpu-share-constraint><code>--cpu-shares</code></a>
pada perintah <code>docker run</code>.</p></li><li><p><code>spec.containers[].resources.limits.cpu</code> diubah menjadi nilai <em>millicore</em>-nya dan
dikalikan dengan 100. Nilai hasilnya adalah jumlah waktu CPU yang dapat digunakan oleh
sebuah kontainer setiap 100 milidetik. Sebuah kontainer tidak dapat menggunakan lebih
dari jatah waktu CPU-nya selama selang waktu ini.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Periode kuota bawaan adalah 100ms. Resolusi minimum dari kuota CPU adalah 1 milidetik.</div></li><li><p><code>spec.containers[].resources.limits.memory</code> diubah menjadi sebuah bilangan bulat, dan
digunakan sebagai nilai dari <em>flag</em> <a href=https://docs.docker.com/engine/reference/run/#/user-memory-constraints><code>--memory</code></a>
dari perintah <code>docker run</code>.</p></li></ul><p>Jika sebuah Container melebihi batas memorinya, Container tersebut mungkin akan diterminasi.
Jika Container tersebut dapat diulang kembali, Kubelet akan mengulangnya kembali, sama
seperti jenis kegagalan lainnya.</p><p>Jika sebuah Container melebihi request memorinya, kemungkinan Pod-nya akan dipindahkan
kapanpun Node tersebut kehabisan memori.</p><p>Sebuah Container mungkin atau mungkin tidak diizinkan untuk melebihi limit CPU-nya
untuk periode waktu yang lama. Tetapi, Container tersebut tidak akan diterminasi karena
penggunaan CPU yang berlebihan.</p><p>Untuk menentukan apabila sebuah Container tidak dapat dijadwalkan atau sedang diterminasi
karena limit sumber dayanya, lihat bagian <a href=#penyelesaian-masalah>Penyelesaian Masalah</a>.</p><h2 id=memantau-penggunaan-sumber-daya-komputasi>Memantau penggunaan sumber daya komputasi</h2><p>Penggunaan sumber daya dari sebuah Pod dilaporkan sebagai bagian dari kondisi Pod.</p><p>Jika <a href=http://releases.k8s.io/main/cluster/addons/cluster-monitoring/README.md><em>monitoring</em> opsional</a> diaktifkan pada klaster kamu, maka penggunaan sumber daya Pod dapat diambil
dari sistem <em>monitoring</em> kamu.</p><h2 id=penyelesaian-masalah>Penyelesaian Masalah</h2><h3 id=pod-pod-saya-berkondisi-pending-tertunda-dengan-event-message-failedscheduling>Pod-Pod saya berkondisi Pending (tertunda) dengan <em>event message</em> failedScheduling</h3><p>Jika scheduler tidak dapat menemukan Node manapun yang muat untuk sebuah Pod,
Pod tersebut tidak akan dijadwalkan hingga ditemukannya sebuah tempat yang
muat. Sebuah <em>event</em> akan muncul setiap kali scheduler gagal menemukan tempat
untuk Pod tersebut, seperti berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe pod frontend | grep -A <span style=color:#666>3</span> Events
</span></span></code></pre></div><pre tabindex=0><code>Events:
  FirstSeen LastSeen   Count  From          Subobject   PathReason      Message
  36s   5s     6      {scheduler }              FailedScheduling  Failed for reason PodExceedsFreeCPU and possibly others
</code></pre><p>Pada contoh di atas, Pod bernama "frontend" gagal dijadwalkan karena kekurangan
sumber daya CPU pada Node tersebut. Pesan kesalahan yang serupa dapat juga menunjukkan
kegagalan karena kekurangan memori (PodExceedsFreeMemroy). Secara umum, jika sebuah
Pod berkondisi Pending (tertunda) dengan sebuah pesan seperti ini, ada beberapa hal yang
dapat dicoba:</p><ul><li>Tambah lebih banyak Node pada klaster.</li><li>Terminasi Pod-Pod yang tidak dibutuhkan untuk memberikan ruangan untuk Pod-Pod yang
tertunda.</li><li>Periksa jika nilai request Pod tersebut tidak lebih besar dari Node-node yang ada.
Contohnya, jika semua Node memiliki kapasitas <code>cpu: 1</code>, maka Pod dengan request
<code>cpu: 1.1</code> tidak akan pernah dijadwalkan.</li></ul><p>Kamu dapat memeriksa kapasitas Node-Node dan jumlah-jumlah yang telah dialokasikan
dengan perintah <code>kubectl describe nodes</code>. Contohnya:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe nodes e2e-test-node-pool-4lw4
</span></span></code></pre></div><pre tabindex=0><code>Name:            e2e-test-node-pool-4lw4
[ ... lines removed for clarity ...]
Capacity:
 cpu:                               2
 memory:                            7679792Ki
 pods:                              110
Allocatable:
 cpu:                               1800m
 memory:                            7474992Ki
 pods:                              110
[ ... beberapa baris dihapus untuk kejelasan ...]
Non-terminated Pods:        (5 in total)
  Namespace    Name                                  CPU Requests  CPU Limits  Memory Requests  Memory Limits
  ---------    ----                                  ------------  ----------  ---------------  -------------
  kube-system  fluentd-gcp-v1.38-28bv1               100m (5%)     0 (0%)      200Mi (2%)       200Mi (2%)
  kube-system  kube-dns-3297075139-61lj3             260m (13%)    0 (0%)      100Mi (1%)       170Mi (2%)
  kube-system  kube-proxy-e2e-test-...               100m (5%)     0 (0%)      0 (0%)           0 (0%)
  kube-system  monitoring-influxdb-grafana-v4-z1m12  200m (10%)    200m (10%)  600Mi (8%)       600Mi (8%)
  kube-system  node-problem-detector-v0.1-fj7m3      20m (1%)      200m (10%)  20Mi (0%)        100Mi (1%)
Allocated resources:
  (Total limit mungkin melebihi 100 persen, misalnya, karena _overcommit_.)
  CPU Requests    CPU Limits    Memory Requests    Memory Limits
  ------------    ----------    ---------------    -------------
  680m (34%)      400m (20%)    920Mi (12%)        1070Mi (14%)
</code></pre><p>Pada keluaran di atas, kamu dapat melihat bahwa jika sebuah Pod meminta lebih dari
1120m CPU atau 6.23Gi memori, Pod tersebut tidak akan muat pada Node tersebut.</p><p>Dengan melihat pada bagian <code>Pods</code>, kamu dapat melihat Pod-Pod mana saja yang memakan
sumber daya pada Node tersebut.
Jumlah sumber daya yang tersedia untuk Pod-Pod kurang dari kapasitas Node, karena
<em>daemon</em> sistem menggunakan sebagian dari sumber daya yang ada. Kolom <code>allocatable</code> pada
<a href=/docs/reference/generated/kubernetes-api/v1.25/#nodestatus-v1-core>NodeStatus</a>
memberikan jumlah sumber daya yang tersedia untuk Pod-Pod. Untuk lebih lanjut, lihat
<a href=https://git.k8s.io/community/contributors/design-proposals/node/node-allocatable.md>Sumber daya Node yang dapat dialokasikan</a>.</p><p>Fitur <a href=/id/docs/concepts/policy/resource-quotas/>kuota sumber daya</a> dapat disetel untuk
membatasi jumlah sumber daya yang dapat digunakan. Jika dipakai bersama dengan Namespace,
kuota sumber daya dapat mencegah suatu tim menghabiskan semua sumber daya.</p><h3 id=container-saya-diterminasi>Container saya diterminasi</h3><p>Container kamu mungkin diterminasi karena Container tersebut melebihi batasnya. Untuk
memeriksa jika sebuah Container diterminasi karena ia melebihi batas sumber dayanya,
gunakan perintah <code>kubectl describe pod</code> pada Pod yang bersangkutan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe pod simmemleak-hra99
</span></span></code></pre></div><pre tabindex=0><code>Name:                           simmemleak-hra99
Namespace:                      default
Image(s):                       saadali/simmemleak
Node:                           kubernetes-node-tf0f/10.240.216.66
Labels:                         name=simmemleak
Status:                         Running
Reason:
Message:
IP:                             10.244.2.75
Replication Controllers:        simmemleak (1/1 replicas created)
Containers:
  simmemleak:
    Image:  saadali/simmemleak
    Limits:
      cpu:                      100m
      memory:                   50Mi
    State:                      Running
      Started:                  Tue, 07 Jul 2015 12:54:41 -0700
    Last Termination State:     Terminated
      Exit Code:                1
      Started:                  Fri, 07 Jul 2015 12:54:30 -0700
      Finished:                 Fri, 07 Jul 2015 12:54:33 -0700
    Ready:                      False
    Restart Count:              5
Conditions:
  Type      Status
  Ready     False
Events:
  FirstSeen                         LastSeen                         Count  From                              SubobjectPath                       Reason      Message
  Tue, 07 Jul 2015 12:53:51 -0700   Tue, 07 Jul 2015 12:53:51 -0700  1      {scheduler }                                                          scheduled   Successfully assigned simmemleak-hra99 to kubernetes-node-tf0f
  Tue, 07 Jul 2015 12:53:51 -0700   Tue, 07 Jul 2015 12:53:51 -0700  1      {kubelet kubernetes-node-tf0f}    implicitly required container POD   pulled      Pod container image &#34;k8s.gcr.io/pause:0.8.0&#34; already present on machine
  Tue, 07 Jul 2015 12:53:51 -0700   Tue, 07 Jul 2015 12:53:51 -0700  1      {kubelet kubernetes-node-tf0f}    implicitly required container POD   created     Created with docker id 6a41280f516d
  Tue, 07 Jul 2015 12:53:51 -0700   Tue, 07 Jul 2015 12:53:51 -0700  1      {kubelet kubernetes-node-tf0f}    implicitly required container POD   started     Started with docker id 6a41280f516d
  Tue, 07 Jul 2015 12:53:51 -0700   Tue, 07 Jul 2015 12:53:51 -0700  1      {kubelet kubernetes-node-tf0f}    spec.containers{simmemleak}         created     Created with docker id 87348f12526a
</code></pre><p>Pada contoh di atas, <code>Restart Count: 5</code> menunjukkan bahwa Container <code>simmemleak</code>
pada Pod tersebut diterminasi dan diulang kembali sebanyak lima kali.</p><p>Kamu dapat menggunakan perintah <code>kubectl get pod</code> dengan opsi <code>-o go-template=...</code> untuk
mengambil kondisi dari Container-Container yang sebelumnya diterminasi:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod -o go-template<span style=color:#666>=</span><span style=color:#b44>&#39;{{range.status.containerStatuses}}{{&#34;Container Name: &#34;}}{{.name}}{{&#34;\r\nLastState: &#34;}}{{.lastState}}{{end}}&#39;</span>  simmemleak-hra99
</span></span></code></pre></div><pre tabindex=0><code>Container Name: simmemleak
LastState: map[terminated:map[exitCode:137 reason:OOM Killed startedAt:2015-07-07T20:58:43Z finishedAt:2015-07-07T20:58:43Z containerID:docker://0e4095bba1feccdfe7ef9fb6ebffe972b4b14285d5acdec6f0d3ae8a22fad8b2]]
</code></pre><p>Kamu dapat lihat bahwa Container tersebut diterminasi karena <code>reason:OOM Killed</code>, di mana
<code>OOM</code> merupakan singkatan dari <em>Out Of Memory</em>, atau kehabisan memori.</p><h2 id=penyimpanan-lokal-sementara>Penyimpanan lokal sementara</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.25 [beta]</code></div><p>Kubernetes versi 1.8 memperkenalkan sebuah sumber daya baru, <em>ephemeral-storage</em> untuk mengatur penyimpanan lokal yang bersifat sementara. Pada setiap Node Kubernetes, direktori <em>root</em> dari Kubelet (secara bawaan /var/lib/kubelet) dan direktori log (/var/log) ditaruh pada partisi <em>root</em> dari Node tersebut. Partisi ini juga digunakan bersama oleh Pod-Pod melalui volume emptyDir, log kontainer, lapisan <em>image</em>, dan lapisan kontainer yang dapat ditulis.</p><p>Partisi ini bersifat "sementara" dan aplikasi-aplikasi tidak dapat mengharapkan SLA kinerja (misalnya <em>Disk IOPS</em>) dari partisi ini. Pengelolaan penyimpanan lokal sementara hanya berlaku untuk partisi <em>root</em>; partisi opsional untuk lapisan <em>image</em> dan lapisan yang dapat ditulis berada di luar ruang lingkup.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Jika sebuah partisi <em>runtime</em> opsional digunakan, partisi <em>root</em> tidak akan menyimpan lapisan <em>image</em> ataupun lapisan yang dapat ditulis manapun.</div><h3 id=menyetel-request-dan-limit-dari-penyimpanan-lokal-sementara>Menyetel request dan limit dari penyimpanan lokal sementara</h3><p>Setiap Container dari sebuah Pod dapat menentukan satu atau lebih dari hal-hal berikut:</p><ul><li><code>spec.containers[].resources.limits.ephemeral-storage</code></li><li><code>spec.containers[].resources.requests.ephemeral-storage</code></li></ul><p>Limit dan request untuk <code>ephemeral-storage</code> diukur dalam satuan <em>bytes</em>. Kamu dapat menyatakan
penyimpanan dalam bilangan bulat biasa, atau sebagai <em>fixed-point integer</em> menggunakan satu dari
sufiks-sufiks ini: E, P, T, G, M, K. Kamu jika dapat menggunakan bentuk pangkat dua ekuivalennya:
Ei, Pi, Ti, Gi, Mi, Ki. Contohnya, nilai-nilai berikut kurang lebih sama:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>128974848, 129e6, 129M, 123Mi
</span></span></code></pre></div><p>Contohnya, Pod berikut memiliki dua Container. Setiap Container memiliki request 2GiB untuk penyimpanan lokal sementara. Setiap Container memiliki limit 4GiB untuk penyimpanan lokal sementara. Maka, Pod tersebut memiliki jumlah request 4GiB penyimpanan lokal sementara, dan limit 8GiB.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>db<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MYSQL_ROOT_PASSWORD<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;password&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ephemeral-storage</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2Gi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ephemeral-storage</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;4Gi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>wp<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ephemeral-storage</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2Gi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ephemeral-storage</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;4Gi&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=bagaimana-pod-pod-dengan-request-ephemeral-storage-dijadwalkan>Bagaimana Pod-Pod dengan request ephemeral-storage dijadwalkan</h3><p>Saat kamu membuat sebuah Pod, Kubernetes scheduler memilih sebuah Node di mana Pod
tersebut akan dijalankan. Setiap Node memiliki jumlah maksimum penyimpanan lokal sementara yang dapat disediakan.
Untuk lebih lanjut, lihat <a href=/docs/tasks/administer-cluster/reserve-compute-resources/#node-allocatable>"Hal-hal yang dapat dialokasikan Node"</a>.</p><p>Scheduler memastikan bahwa jumlah dari request-request sumber daya dari Container-Container yang dijadwalkan lebih kecil dari kapasitas Node.</p><h3 id=bagaimana-pod-pod-dengan-limit-ephemeral-storage-dijalankan>Bagaimana Pod-Pod dengan limit ephemeral-storage dijalankan</h3><p>Untuk isolasi pada tingkat kontainer, jika lapisan yang dapat ditulis dari sebuah Container dan penggunaan log melebihi limit penyimpanannya, maka Pod tersebut akan dipindahkan. Untuk isolasi pada tingkat Pod, jika jumlah dari penyimpanan lokal sementara dari semua Container dan juga volume emptyDir milik Pod melebihi limit, maka Pod teresebut akan dipindahkan.</p><h3 id=memantau-penggunaan-ephemeral-storage>Memantau penggunaan ephemeral-storage</h3><p>Saat penyimpanan lokal sementara digunakan, ia dipantau terus-menerus
oleh Kubelet. Pemantauan dilakukan dengan cara memindai setiap volume
emptyDir, direktori log, dan lapisan yang dapat ditulis secara periodik.
Dimulai dari Kubernetes 1.15, volume emptyDir (tetapi tidak direktori log
atau lapisan yang dapat ditulis) dapat, sebagai pilihan dari operator
klaster, dikelola dengan menggunakan <a href=http://xfs.org/docs/xfsdocs-xml-dev/XFS_User_Guide/tmp/en-US/html/xfs-quotas.html><em>project quotas</em></a>.
<em>Project quotas</em> aslinya diimplementasikan dalam XFS, dan baru-baru ini
telah diubah ke ext4fs. <em>Project quotas</em> dapat digunakan baik untuk
<em>monitoring</em> dan pemaksaan; sejak Kubernetes 1.16, mereka tersedia sebagai
fitur <em>alpha</em> untuk <em>monitoring</em> saja.</p><p><em>Quota</em> lebih cepat dan akurat dibandingkan pemindaian direktori. Saat
sebuah direktori ditentukan untuk sebuah proyek, semua berkas yang dibuat
pada direktori tersebut dibuat untuk proyek tersebut, dan kernel hanya
perlu melacak berapa banyak blok yang digunakan oleh berkas-berkas pada
proyek tersebut. Jika sebuah berkas dibuat dan dihapus, tetapi tetap dengan
sebuah <em>file descriptor</em> yang terbuka, maka berkas tersebut tetap akan
memakan ruangan penyimpanan. Ruangan ini akan dilacak oleh <em>quota</em> tersebut,
tetapi tidak akan terlihat oleh sebuah pemindaian direktori.</p><p>Kubernetes menggunakan ID proyek yang dimulai dari 1048576. ID-ID yang
digunakan akan didaftarkan di dalam <code>/etc/projects</code> dan <code>/etc/projid</code>.
Jika ID-ID proyek pada kisaran ini digunakan untuk tujuan lain pada sistem,
ID-ID proyek tersebut harus terdaftar di dalam <code>/etc/projects</code> dan <code>/etc/projid</code>
untuk mencegah Kubernetes menggunakan ID-ID tersebut.</p><p>Untuk mengaktifkan penggunaan <em>project quotas</em>, operator klaster
harus melakukan hal-hal berikut:</p><ul><li><p>Aktifkan <em>feature gate</em> <code>LocalStorageCapacityIsolationFSQuotaMonitoring=true</code>
pada konfigurasi Kubelet. Nilainya secara bawaan <code>false</code> pada
Kubernetes 1.16, jadi harus secara eksplisit disetel menjadi <code>true</code>.</p></li><li><p>Pastikan bahwa partisi <em>root</em> (atau partisi opsional <em>runtime</em>)
telah dibangun (<em>build</em>) dengan mengaktifkan <em>project quotas</em>. Semua sistem berkas (<em>filesystem</em>)
XFS mendukung <em>project quotas</em>, tetapi sistem berkas ext4 harus dibangun
secara khusus untuk mendukungnya</p></li><li><p>Pastikan bahwa partisi <em>root</em> (atau partisi opsional <em>runtime</em>) ditambatkan (<em>mount</em>)
dengan <em>project quotas</em> yang telah diaktifkan.</p></li></ul><h4 id=membangun-dan-menambatkan-sistem-berkas-dengan-project-quotas-yang-telah-diaktifkan>Membangun dan menambatkan sistem berkas dengan <em>project quotas</em> yang telah diaktifkan</h4><p>Sistem berkas XFS tidak membutuhkan tindakan khusus saat dibangun;
mereka secara otomatis telah dibangun dengan <em>project quotas</em> yang
telah diaktifkan.</p><p>Sistem berkas <em>ext4fs</em> harus dibangun dengan mengaktifkan <em>quotas</em>,
kemudian mereka harus diaktifkan pada sistem berkas tersebut.</p><pre tabindex=0><code>% sudo mkfs.ext4 other_ext4fs_args... -E quotatype=prjquota /dev/block_device
% sudo tune2fs -O project -Q prjquota /dev/block_device
</code></pre><p>Untuk menambatkan sistem berkasnya, baik ext4fs dan XFS membutuhkan opsi
<code>prjquota</code> disetel di dalam <code>/etc/fstab</code>:</p><pre tabindex=0><code>/dev/block_device	/var/kubernetes_data	defaults,prjquota	0	0
</code></pre><h2 id=sumber-daya-yang-diperluas>Sumber daya yang diperluas</h2><p>Sumber daya yang diperluas (<em>Extended Resource</em>) adalah nama sumber daya di luar domain <code>kubernetes.io</code>.
Mereka memungkinkan operator klaster untuk menyatakan dan pengguna untuk menggunakan
sumber daya di luar sumber daya bawaan Kubernetes.</p><p>Ada dua langkah untuk menggunakan sumber daya yang diperluas. Pertama, operator
klaster harus menyatakan sebuah Extended Resource. Kedua, pengguna harus meminta
sumber daya yang diperluas tersebut di dalam Pod.</p><h3 id=mengelola-sumber-daya-yang-diperluas>Mengelola sumber daya yang diperluas</h3><h4 id=sumber-daya-yang-diperluas-pada-tingkat-node>Sumber daya yang diperluas pada tingkat Node</h4><p>Sumber daya yang diperluas pada tingkat Node terikat pada Node.</p><h5 id=sumber-daya-device-plugin-yang-dikelola>Sumber daya Device Plugin yang dikelola</h5><p>Lihat <a href=/id/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/>Device
Plugin</a> untuk
cara menyatakan sumber daya <em>device plugin</em> yang dikelola pada setiap node.</p><h5 id=sumber-daya-lainnya>Sumber daya lainnya</h5><p>Untuk menyatakan sebuah sumber daya yang diperluas tingkat Node, operator klaster
dapat mengirimkan permintaan HTTP <code>PATCH</code> ke API server untuk menentukan kuantitas
sumber daya yang tersedia pada kolom <code>status.capacity</code> untuk Node pada klaster.
Setelah itu, <code>status.capacity</code> pada Node akan memiliki sumber daya baru tersebut.
Kolom <code>status.allocatable</code> diperbarui secara otomatis dengan sumber daya baru
tersebut secara <em>asynchrounous</em> oleh Kubelet. Perlu dicatat bahwa karena scheduler
menggunakan nilai <code>status.allocatable</code> milik Node saat mengevaluasi muat atau tidaknya
Pod, mungkin ada waktu jeda pendek antara melakukan <code>PATCH</code> terhadap kapasitas Node
dengan sumber daya baru dengan Pod pertama yang meminta sumber daya tersebut untuk
dapat dijadwalkan pada Node tersebut.</p><p><strong>Contoh:</strong></p><p>Berikut sebuah contoh yang menunjukkan bagaimana cara menggunakan <code>curl</code> untuk
mengirim permintaan HTTP yang menyatakan lima sumber daya "example.com/foo" pada
Node <code>k8s-node-1</code> yang memiliki master <code>k8s-master</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl --header <span style=color:#b44>&#34;Content-Type: application/json-patch+json&#34;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>--request PATCH <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>--data <span style=color:#b44>&#39;[{&#34;op&#34;: &#34;add&#34;, &#34;path&#34;: &#34;/status/capacity/example.com~1foo&#34;, &#34;value&#34;: &#34;5&#34;}]&#39;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>http://k8s-master:8080/api/v1/nodes/k8s-node-1/status
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Pada permintaan HTTP di atas, <code>~1</code> adalah <em>encoding</em> untuk karakter <code>/</code> pada jalur (<em>path</em>) <em>patch</em>.
Nilai jalur operasi tersebut di dalam JSON-Patch diinterpretasikan sebagai sebuah JSON-Pointer.
Untuk lebih lanjut, lihat <a href=https://tools.ietf.org/html/rfc6901#section-3>IETF RFC 6901, bagian 3</a>.</div><h4 id=sumber-daya-yang-diperluas-pada-tingkat-klaster>Sumber daya yang diperluas pada tingkat klaster</h4><p>Sumber daya yang diperluas pada tingkat klaster tidak terikat pada Node. Mereka
biasanya dikelola oleh <em>scheduler extender</em>, yang menangani penggunaan sumber daya
dan kuota sumber daya.</p><p>Kamu dapat menentukan sumber daya yang diperluas yang ditangani oleh <em>scheduler extender</em>
pada <a href=https://github.com/kubernetes/kubernetes/blob/release-1.10/pkg/scheduler/api/v1/types.go#L31>konfigurasi kebijakan scheduler</a>.</p><p><strong>Contoh:</strong></p><p>Konfigurasi untuk sebuah kebijakan scheduler berikut menunjukkan bahwa
sumber daya yang diperluas pada tingkat klaster "example.com/foo" ditangani
oleh <em>scheduler extender</em>.</p><ul><li>Scheduler mengirim sebuah Pod ke <em>scheduler extender</em> hanya jika Pod tersebut
meminta "example.com/foo".</li><li>Kolom <code>ignoredByScheduler</code> menentukan bahwa scheduler tidak memeriksa sumber daya
"example.com/foo" pada predikat <code>PodFitsResources</code> miliknya.</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;Policy&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;v1&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;extenders&#34;</span>: [
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;urlPrefix&#34;</span>:<span style=color:#b44>&#34;&lt;extender-endpoint&gt;&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;bindVerb&#34;</span>: <span style=color:#b44>&#34;bind&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;managedResources&#34;</span>: [
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>          <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;example.com/foo&#34;</span>,
</span></span><span style=display:flex><span>          <span style=color:green;font-weight:700>&#34;ignoredByScheduler&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>      ]
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  ]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=menggunakan-sumber-daya-yang-diperluas>Menggunakan sumber daya yang diperluas</h3><p>Pengguna dapat menggunakan sumber daya yang diperluas di dalam spesifikasi Pod
seperti CPU dan memori. Scheduler menangani akuntansi sumber daya tersebut agar
tidak ada alokasi untuk yang melebihi jumlah yang tersedia.</p><p>API server membatasi jumlah sumber daya yang diperluas dalam bentuk
bilangan bulat. Contoh jumlah yang <em>valid</em> adalah <code>3</code>, <code>3000m</code>, dan
<code>3Ki</code>. Contoh jumlah yang <em>tidak valid</em> adalah <code>0.5</code> dan <code>1500m</code>.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Sumber daya yang diperluas menggantikan Opaque Integer Resource.
Pengguna dapat menggunakan prefiks nama domain selain <code>kubernetes.io</code> yang sudah dipakai.</div><p>Untuk menggunakan sebuah sumber daya yang diperluas di sebuah Pod, masukkan nama
sumber daya tersebut sebagai nilai <em>key</em> dari map <code>spec.containers[].resources.limit</code>
pada spesifikasi Container.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Sumber daya yang diperluas tidak dapat di-<em>overcommit</em>, sehingga
request dan limit nilainya harus sama jika keduanya ada di spesifikasi
sebuah Container.</div><p>Sebuah Pod hanya dijadwalkan jika semua request sumber dayanya terpenuhi, termasuk
CPU, memori, dan sumber daya yang diperluas manapun. Pod tersebut akan tetap
berada pada kondisi <code>PENDING</code> selama request sumber daya tersebut tidak terpenuhi.</p><p><strong>Contoh:</strong></p><p>Pod di bawah meminta 2 CPU dan 1 "example.com/foo" (sebuah sumber daya yang diperluas).</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>myimage<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>example.com/foo</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>example.com/foo</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=selanjutnya>Selanjutnya</h2><ul><li><p>Dapatkan pengalaman langsung <a href=/docs/tasks/configure-pod-container/assign-memory-resource/>menentukan sumber daya memori untuk Container dan Pod</a>.</p></li><li><p>Dapatkan pengalaman langsung <a href=/docs/tasks/configure-pod-container/assign-cpu-resource/>menentukan sumber daya CPU untuk Container dan Pod</a>.</p></li><li><p><a href=/docs/reference/generated/kubernetes-api/v1.25/#container-v1-core>Container API</a></p></li><li><p><a href=/docs/reference/generated/kubernetes-api/v1.25/#resourcerequirements-v1-core>ResourceRequirements</a></p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-e511ed821ada65d0053341dbd8ad2bb5>3.7.3 - Secret</h1><p>Objek <code>secret</code> pada Kubernetes mengizinkan kamu menyimpan dan mengatur informasi yang sifatnya sensitif, seperti
<em>password</em>, token OAuth, dan ssh <em>keys</em>. Menyimpan informasi yang sifatnya sensitif ini ke dalam <code>secret</code>
cenderung lebih aman dan fleksible jika dibandingkan dengan menyimpan informasi tersebut secara apa adanya pada definisi <a class=glossary-tooltip title='Unit Kubernetes yang paling sederhana dan kecil. Sebuah Pod merepresentasikan sebuah set kontainer yang dijalankan pada kluster kamu.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a> atau di dalam <a class=glossary-tooltip title='Instans yang disimpan dari sebuah Container yang memuat seperangkat perangkat lunak yang dibutuhkan untuk menjalankan sebuah aplikasi.' data-toggle=tooltip data-placement=top href='/id/docs/reference/glossary/?all=true#term-image' target=_blank aria-label='container image'>container image</a>.
Silahkan lihat <a href=https://git.k8s.io/community/contributors/design-proposals/auth/secrets.md>Dokumen desain Secret</a> untuk informasi yang sifatnya mendetail.</p><h2 id=ikhtisar-secret>Ikhtisar Secret</h2><p>Sebuah Secret merupakan sebuah objek yang mengandung informasi yang sifatnya
sensitif, seperti <em>password</em>, token, atau <em>key</em>. Informasi tersebut sebenarnya bisa saja
disimpan di dalam spesifikasi Pod atau <em>image</em>; meskipun demikian, melakukan penyimpanan
di dalam objek Secret mengizinkan pengguna untuk memiliki kontrol lebih lanjut mengenai
bagaimana Secret ini disimpan, serta mencegah tereksposnya informasi sensitif secara
tidak disengaja.</p><p>Baik pengguna dan sistem memiliki kemampuan untuk membuat objek Secret.</p><p>Untuk menggunakan Secret, sebuah Pod haruslah merujuk pada Secret tersebut.
Sebuah Secret dapat digunakan di dalam sebuah Pod melalui dua cara:
sebagai <em>file</em> yang ada di dalam <em>volume</em> <a class=glossary-tooltip title='Sebuah direktori yang mengandung data, dapat diakses o;eh kontainer-kontainer di dalam pod.' data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/ target=_blank aria-label=volume>volume</a>
yang di-<em>mount</em> pada salah satu container Pod, atau digunakan oleh kubelet
ketika menarik <em>image</em> yang digunakan di dalam Pod.</p><h3 id=secret-built-in>Secret <em>Built-in</em></h3><h4 id=sebuah-service-account-akan-secara-otomatis-dibuat-dan-meng-attach-secret-dengan-kredensial-api>Sebuah <em>Service Account</em> akan Secara Otomatis Dibuat dan Meng-<em>attach</em> Secret dengan Kredensial API</h4><p>Kubernetes secara otomatis membuat secret yang mengandung kredensial
yang digunakan untuk mengakses API, serta secara otomatis memerintahkan Pod untuk menggunakan
Secret ini.</p><p>Mekanisme otomatisasi pembuatan secret dan penggunaan kredensial API dapat di nonaktifkan
atau di-<em>override</em> jika kamu menginginkannya. Meskipun begitu, jika apa yang kamu butuhkan
hanyalah mengakses apiserver secara aman, maka mekanisme <em>default</em> inilah yang disarankan.</p><p>Baca lebih lanjut dokumentasi <a href=/id/docs/tasks/configure-pod-container/configure-service-account/><em>Service Account</em></a>
untuk informasi lebih lanjut mengenai bagaimana cara kerja <em>Service Account</em>.</p><h3 id=membuat-objek-secret-kamu-sendiri>Membuat Objek Secret Kamu Sendiri</h3><h4 id=membuat-secret-dengan-menggunakan-kubectl>Membuat Secret dengan Menggunakan kubectl</h4><p>Misalnya saja, beberapa Pod memerlukan akses ke sebuah basis data. Kemudian <em>username</em>
dan <em>password</em> yang harus digunakan oleh Pod-Pod tersebut berada pada mesin lokal kamu
dalam bentuk <em>file-file</em> <code>./username.txt</code> dan <code>./password.txt</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Buatlah berkas yang selanjutnya akan digunakan pada contoh-contoh selanjutnya</span>
</span></span><span style=display:flex><span><span style=color:#a2f>echo</span> -n <span style=color:#b44>&#39;admin&#39;</span> &gt; ./username.txt
</span></span><span style=display:flex><span><span style=color:#a2f>echo</span> -n <span style=color:#b44>&#39;1f2d1e2e67df&#39;</span> &gt; ./password.txt
</span></span></code></pre></div><p>Perintah <code>kubectl create secret</code> akan mengemas <em>file-file</em> ini menjadi Secret dan
membuat sebuah objek pada Apiserver.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret generic db-user-pass --from-file<span style=color:#666>=</span>./username.txt --from-file<span style=color:#666>=</span>./password.txt
</span></span></code></pre></div><pre tabindex=0><code>secret &#34;db-user-pass&#34; created
</code></pre><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Karakter spesial seperti <code>$</code>, <code>\*</code>, and <code>!</code> membutuhkan mekanisme <em>escaping</em>.
Jika <em>password</em> yang kamu gunakan mengandung karakter spesial, kamu perlu melakukan <em>escape</em> karakter dengan menggunakan karakter <code>\\</code>. Contohnya, apabila <em>password</em> yang kamu miliki adalah <code>S!B\*d$zDsb</code>, maka kamu harus memanggil perintah kubectl dengan cara berikut:
kubectl create secret generic dev-db-secret --from-literal=username=devuser --from-literal=password=S\!B\\*d\$zDsb
Perhatikan bahwa kamu tidak perlu melakukan <em>escape</em> karakter apabila massukan yang kamu berikan merupakan <em>file</em> (<code>--from-file</code>).</div><p>Kamu dapat memastikan apakah suatu Secret sudah dibuat atau belum dengan menggunakan perintah:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get secrets
</span></span></code></pre></div><pre tabindex=0><code>NAME                  TYPE                                  DATA      AGE
db-user-pass          Opaque                                2         51s
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe secrets/db-user-pass
</span></span></code></pre></div><pre tabindex=0><code>Name:            db-user-pass
Namespace:       default
Labels:          &lt;none&gt;
Annotations:     &lt;none&gt;

Type:            Opaque

Data
====
password.txt:    12 bytes
username.txt:    5 bytes
</code></pre><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Perintah-perintah <code>kubectl get</code> dan <code>kubectl describe</code> secara <em>default</em> akan
mencegah ditampilkannya informasi yang ada di dalam Secret.
Hal ini dilakukan untuk melindungi agar Secret tidak terekspos secara tidak disengaja oleh orang lain,
atau tersimpan di dalam <em>log</em> <em>terminal</em>.</div><p>Kamu dapat membaca <a href=#decoding-a-secret>bagaimana cara melakukan <em>decode</em> sebuah secret</a>
untuk mengetahui bagaimana cara melihat isi dari Secret.</p><h4 id=membuat-secret-secara-manual>Membuat Secret Secara Manual</h4><p>Kamu dapat membuat sebuah Secret dengan terlebih dahulu membuat <em>file</em> yang berisikan
informasi yang ingin kamu jadikan Secret dalam bentuk yaml atau json dan kemudian membuat objek
dengan menggunakan <em>file</em> tersebut. <a href=/docs/reference/generated/kubernetes-api/v1.12/#secret-v1-core>Secret</a>
mengandung dua buah <em>map</em>: <em>data</em> dan <em>stringData</em>. <em>Field</em> <em>data</em> digunakan untuk menyimpan sembarang data,
yang di-<em>encode</em> menggunakan base64. Sementara itu <em>stringData</em> disediakan untuk memudahkan kamu untuk menyimpan
informasi sensitif dalam format yang tidak di-<em>encode</em>.</p><p>Sebagai contoh, untuk menyimpan dua buah string di dalam Secret dengan menggunakan <em>field</em> data, ubahlah
informasi tersebut ke dalam base64 dengan menggunakan mekanisme sebagai berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>echo</span> -n <span style=color:#b44>&#39;admin&#39;</span> | base64
</span></span><span style=display:flex><span><span style=color:#b8860b>YWRtaW4</span><span style=color:#666>=</span>
</span></span><span style=display:flex><span><span style=color:#a2f>echo</span> -n <span style=color:#b44>&#39;1f2d1e2e67df&#39;</span> | base64
</span></span><span style=display:flex><span>MWYyZDFlMmU2N2Rm
</span></span></code></pre></div><p>Buatlah sebuah Secret yang memiliki bentuk sebagai berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Opaque<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>username</span>:<span style=color:#bbb> </span>YWRtaW4=<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>password</span>:<span style=color:#bbb> </span>MWYyZDFlMmU2N2Rm<span style=color:#bbb>
</span></span></span></code></pre></div><p>Kemudian buatlah Secret menggunakan perintah <a href=/docs/reference/generated/kubectl/kubectl-commands#apply><code>kubectl apply</code></a>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f ./secret.yaml
</span></span></code></pre></div><pre tabindex=0><code>secret &#34;mysecret&#34; created
</code></pre><p>Untuk beberapa skenario, kamu bisa saja ingin menggunakan opsi <em>field</em> stringData.
<em>Field</em> ini mengizinkan kamu untuk memberikan masukan berupa informasi yang belum di-<em>encode</em> secara langsung
pada sebuah Secret, informasi dalam bentuk string ini kemudian akan di-<em>encode</em> ketika Secret dibuat maupun diubah.</p><p>Contoh praktikal dari hal ini adalah ketika kamu melakukan proses <em>deploy</em> aplikasi
yang menggunakan Secret sebagai penyimpanan <em>file</em> konfigurasi, dan kamu ingin mengisi
bagian dari konfigurasi <em>file</em> tersebut ketika aplikasi di_deploy_.</p><p>Jika kamu ingin aplikasi kamu menggunakan <em>file</em> konfigurasi berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiUrl</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;https://my.api.com/api/v1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>username</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;user&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>password</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;password&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Kamu dapat menyimpan Secret ini dengan menggunakan cara berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Opaque<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>stringData</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>config.yaml</span>:<span style=color:#bbb> </span>|-<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    apiUrl: &#34;https://my.api.com/api/v1&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    username: {{username}}
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    password: {{password}}</span><span style=color:#bbb>    
</span></span></span></code></pre></div><p>Alat <em>deployment</em> yang kamu gunakan kemudian akan mengubah templat variabel <code>{{username}}</code> dan <code>{{password}}</code>
sebelum menjalankan perintah <code>kubectl apply</code>.</p><p>stringData merupakan <em>field</em> yang sifatnya <em>write-only</em> untuk alasan kenyamanan pengguna.
<em>Field</em> ini tidak pernah ditampilkan ketika Secret dibaca. Sebagai contoh, misalkan saja kamu menjalankan
perintah sebagai berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get secret mysecret -o yaml
</span></span></code></pre></div><p>Keluaran yang diberikan kurang lebih akan ditampilkan sebagai berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2018-11-15T20:40:59Z<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;7225&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selfLink</span>:<span style=color:#bbb> </span>/api/v1/namespaces/default/secrets/mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>c280ad2e-e916-11e8-98f2-025000000001<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Opaque<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>config.yaml</span>:<span style=color:#bbb> </span>YXBpVXJsOiAiaHR0cHM6Ly9teS5hcGkuY29tL2FwaS92MSIKdXNlcm5hbWU6IHt7dXNlcm5hbWV9fQpwYXNzd29yZDoge3twYXNzd29yZH19<span style=color:#bbb>
</span></span></span></code></pre></div><p>Jika sebuah <em>field</em> dispesifikasikan dalam bentuk data maupun stringData,
maka nilai dari stringData-lah yang akan digunakan. Sebagai contoh, misalkan saja terdapat
definisi Secret sebagai berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Opaque<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>username</span>:<span style=color:#bbb> </span>YWRtaW4=<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>stringData</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>username</span>:<span style=color:#bbb> </span>administrator<span style=color:#bbb>
</span></span></span></code></pre></div><p>Akan menghasilkan Secret sebagai berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2018-11-15T20:46:46Z<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;7579&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selfLink</span>:<span style=color:#bbb> </span>/api/v1/namespaces/default/secrets/mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>91460ecb-e917-11e8-98f2-025000000001<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Opaque<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>username</span>:<span style=color:#bbb> </span>YWRtaW5pc3RyYXRvcg==<span style=color:#bbb>
</span></span></span></code></pre></div><p>Dimana string <code>YWRtaW5pc3RyYXRvcg==</code> akan di-<em>decode</em> sebagai <code>administrator</code>.</p><p><em>Key</em> dari data dan stringData yang boleh tersusun atas karakter alfanumerik,
'-', '_' atau '.'.</p><p><strong>Catatan <em>Encoding</em>:</strong> <em>Value</em> dari JSON dan YAML yang sudah diseriakisasi dari data Secret
akan di-<em>encode</em> ke dalam string base64. <em>Newline</em> dianggap tidak valid pada string ini dan harus
dihilangkan. Ketika pengguna Darwin/macOS menggunakan alat <code>base64</code>, maka pengguna
tersebut harus menghindari opsi <code>-b</code> yang digunakan untuk memecah baris yang terlalu panjang.
Sebaliknya pengguna Linux <em>harus</em> menambahkan opsi <code>-w 0</code> pada perintah <code>base64</code> atau
melakukan mekanisme <em>pipeline</em> <code>base64 | tr -d '\n'</code> jika tidak terdapat opsi <code>-w</code>.</p><h4 id=membuat-secret-dengan-menggunakan-generator>Membuat Secret dengan Menggunakan <em>Generator</em></h4><p>Kubectl mendukung <a href=/docs/tasks/manage-kubernetes-objects/kustomization/>mekanisme manajemen objek dengan menggunakan Kustomize</a>
sejak versi 1.14. Dengan fitur baru ini, kamu juga dapat membuat sebuah Secret dari sebuah <em>generator</em>
dan kemudian mengaplikasikannya untuk membuat sebuah objek pada Apiserver. <em>Generator</em> yang digunakan haruslah
dispesifikasikan di dalam sebuah <em>file</em> <code>kustomization.yaml</code> di dalam sebuah direktori.</p><p>Sebagai contoh, untuk menghasilan sebuah Secret dari <em>file-file</em> <code>./username.txt</code> dan <code>./password.txt</code></p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Membuat sebuah berkas kustomization.yaml dengan SecretGenerator</span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt;./kustomization.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>secretGenerator:
</span></span></span><span style=display:flex><span><span style=color:#b44>- name: db-user-pass
</span></span></span><span style=display:flex><span><span style=color:#b44>  files:
</span></span></span><span style=display:flex><span><span style=color:#b44>  - username.txt
</span></span></span><span style=display:flex><span><span style=color:#b44>  - password.txt
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>Gunakan direktori <em>kustomization</em> untuk membuat objek Secret yang diinginkan.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ kubectl apply -k .
</span></span><span style=display:flex><span>secret/db-user-pass-96mffmfh4k created
</span></span></code></pre></div><p>Kamu dapat memastikan Secret tersebut sudah dibuat dengan menggunakan perintah berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ kubectl get secrets
</span></span><span style=display:flex><span>NAME                             TYPE                                  DATA      AGE
</span></span><span style=display:flex><span>db-user-pass-96mffmfh4k          Opaque                                <span style=color:#666>2</span>         51s
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ kubectl describe secrets/db-user-pass-96mffmfh4k
</span></span><span style=display:flex><span>Name:            db-user-pass
</span></span><span style=display:flex><span>Namespace:       default
</span></span><span style=display:flex><span>Labels:          &lt;none&gt;
</span></span><span style=display:flex><span>Annotations:     &lt;none&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Type:            Opaque
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#b8860b>Data</span>
</span></span><span style=display:flex><span><span style=color:#666>====</span>
</span></span><span style=display:flex><span>password.txt:    <span style=color:#666>12</span> bytes
</span></span><span style=display:flex><span>username.txt:    <span style=color:#666>5</span> bytes
</span></span></code></pre></div><p>Sebagai contoh, untuk membuat sebuah Secret dari literal <code>username=admin</code> dan <code>password=secret</code>,
kamu dapat menspesifikasikan <em>generator</em> Secret pada <em>file</em> <code>kustomization.yaml</code> sebagai</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Membuat sebuah berkas kustomization.yaml dengan menggunakan SecretGenerator</span>
</span></span><span style=display:flex><span>$ cat <span style=color:#b44>&lt;&lt;EOF &gt;./kustomization.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>secretGenerator:
</span></span></span><span style=display:flex><span><span style=color:#b44>- name: db-user-pass
</span></span></span><span style=display:flex><span><span style=color:#b44>  literals:
</span></span></span><span style=display:flex><span><span style=color:#b44>  - username=admin
</span></span></span><span style=display:flex><span><span style=color:#b44>  - password=secret
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>Aplikasikan direktori <em>kustomization</em> untuk membuat objek Secret.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ kubectl apply -k .
</span></span><span style=display:flex><span>secret/db-user-pass-dddghtt9b5 created
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Secret yang dihasilkan nantinya akan memiliki tambahan sufix dengan cara melakukan teknik <em>hashing</em>
pada isi Secret tersebut. Hal ini dilakukan untuk menjamin dibuatnya sebuah Secret baru setiap kali terjadi
perubahan isi dari Secret tersebut.</div><h4 id=melakukan-proses-decode-pada-secret>Melakukan Proses <em>Decode</em> pada Secret</h4><p>Secret dapat dibaca dengan menggunakan perintah <code>kubectl get secret</code>.
Misalnya saja, untuk membaca Secret yang dibuat pada bagian sebelumya:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get secret mysecret -o yaml
</span></span></code></pre></div><pre tabindex=0><code>apiVersion: v1
kind: Secret
metadata:
  creationTimestamp: 2016-01-22T18:41:56Z
  name: mysecret
  namespace: default
  resourceVersion: &#34;164619&#34;
  selfLink: /api/v1/namespaces/default/secrets/mysecret
  uid: cfee02d6-c137-11e5-8d73-42010af00002
type: Opaque
data:
  username: YWRtaW4=
  password: MWYyZDFlMmU2N2Rm
</code></pre><p>Kemudian lakukan mekanisme <em>decode</em> <em>field</em> <em>password</em>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b44>&#39;MWYyZDFlMmU2N2Rm&#39;</span> | base64 --decode
</span></span></code></pre></div><pre tabindex=0><code>1f2d1e2e67df
</code></pre><h2 id=menggunakan-secret>Menggunakan Secret</h2><p>Secret dapat di-<em>mount</em> sebagai <em>volume</em> data atau dapat diekspos sebagai <a class=glossary-tooltip title='Variabel lingkungan Container merupakan pasangan nama=nilai yang dapat digunakan untuk menyediakan informasi penting bagi Container yang dijalankan pada Pod.' data-toggle=tooltip data-placement=top href=/docs/concepts/containers/container-environment-variables/ target=_blank aria-label='variabel-variabel environment'>variabel-variabel environment</a>
dapat digunakan di dalam Pod. Secret ini juga dapat digunakan secara langsug
oleh bagian lain dari sistem, tanpa secara langsung berkaitan dengan Pod.
Sebagai contoh, Secret dapat berisikan kredensial bagian suatu sistem lain yang digunakan
untuk berinteraksi dengan sistem eksternal yang kamu butuhkan.</p><h3 id=menggunakan-secret-sebagai-file-melalui-pod>Menggunakan Secret sebagai <em>File</em> melalui Pod</h3><p>Berikut adalah langkah yang harus kamu penuhi agar kamu dapat menggunakan Secret di dalam <em>volume</em> dalam sebuah Pod:</p><ol><li>Buatlah sebuah Secret, atau gunakan sebuah Secret yang sudah kamu buat sebelumnya. Beberapa Pod dapat merujuk pada sebuah Secret yang sama.</li><li>Modifikasi definisi Pod kamu dengan cara menambahkan sebuah <em>volume</em> di bawah <code>.spec.volumes[]</code>. Berilah <em>volume</em> tersebut nama, dan pastikan <em>field</em> <code>.spec.volumes[].secret.secretName</code> merujuk pada nama yang sama dengan objek secret.</li><li>Tambahkan <em>field</em> <code>.spec.containers[].volumeMounts[]</code> pada setiap container yang membutuhkan Secret. Berikan spesifikasi <code>.spec.containers[].volumeMounts[].readOnly = true</code> dan <code>.spec.containers[].volumeMounts[].mountPath</code> pada direktori dimana Secret tersebut diletakkan.</li><li>Modifikasi image dan/atau <em>command line</em> kamu agar program yang kamu miliki merujuk pada <em>file</em> di dalam direktori tersebut. Setiap <em>key</em> pada map <code>data</code> Secret akan menjadi nama dari sebuah <em>file</em> pada <code>mountPath</code>.</li></ol><p>Berikut merupakan salah satu contoh dimana sebuah Pod melakukan proses <em>mount</em> Secret pada sebuah <em>volume</em>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/foo&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span></code></pre></div><p>Setiap Secret yang ingin kamu gunakan harus dirujuk pada <em>field</em> <code>.spec.volumes</code>.</p><p>Jika terdapat lebih dari satu container di dalam Pod,
maka setiap container akan membutuhkan blok <code>volumeMounts</code>-nya masing-masing,
meskipun demikian hanya sebuah <em>field</em> <code>.spec.volumes</code> yang dibutuhkan untuk setiap Secret.</p><p>Kamu dapat menyimpan banyak <em>file</em> ke dalam satu Secret,
atau menggunakan banyak Secret, hal ini tentunya bergantung pada preferensi pengguna.</p><p><strong>Proyeksi <em>key</em> Secret pada Suatu <em>Path</em> Spesifik</strong></p><p>Kita juga dapat mengontrol <em>path</em> di dalam <em>volume</em> di mana sebuah Secret diproyeksikan.
Kamu dapat menggunakan <em>field</em> <code>.spec.volumes[].secret.items</code> untuk mengubah
<em>path</em> target dari setiap <em>key</em>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/foo&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>username<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>my-group/my-username<span style=color:#bbb>
</span></span></span></code></pre></div><p>Apa yang akan terjadi jika kita menggunakan definisi di atas:</p><ul><li>Secret <code>username</code> akan disimpan pada <em>file</em> <code>/etc/foo/my-group/my-username</code> dan bukan <code>/etc/foo/username</code>.</li><li>Secret <code>password</code> tidak akan diproyeksikan.</li></ul><p>Jika <em>field</em> <code>.spec.volumes[].secret.items</code> digunakan, hanya <em>key-key</em> yang dispesifikan di dalam
<code>items</code> yang diproyeksikan. Untuk mengonsumsi semua <em>key-key</em> yang ada dari Secret,
semua <em>key</em> yang ada harus didaftarkan pada <em>field</em> <code>items</code>.
Semua <em>key</em> yang didaftarkan juga harus ada di dalam Secret tadi.
Jika tidak, <em>volume</em> yang didefinisikan tidak akan dibuat.</p><p><strong><em>Permission</em> <em>File-File</em> Secret</strong></p><p>Kamu juga dapat menspesifikasikan mode <em>permission</em> dari <em>file</em> Secret yang kamu inginkan.
Jika kamu tidak menspesifikasikan hal tersebut, maka nilai <em>default</em> yang akan diberikan adalah <code>0644</code> is used by default.
Kamu dapat memberikan mode <em>default</em> untuk semua Secret yang ada serta melakukan mekanisme <em>override</em> <em>permission</em>
pada setiap <em>key</em> jika memang diperlukan.</p><p>Sebagai contoh, kamu dapat memberikan spesifikasi mode <em>default</em> sebagai berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/foo&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>defaultMode</span>:<span style=color:#bbb> </span><span style=color:#666>256</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Kemudian, sebuah Secret akan di-<em>mount</em> pada <code>/etc/foo</code>, selanjutnya semua <em>file</em>
yang dibuat pada <em>volume</em> secret tersebut akan memiliki <em>permission</em> <code>0400</code>.</p><p>Perhatikan bahwa spesifikasi JSON tidak mendukung notasi <em>octal</em>, dengan demikian gunakanlah
<em>value</em> 256 untuk <em>permission</em> 0400. Jika kamu menggunakan format YAML untuk spesifikasi Pod,
kamu dapat menggunakan notasi <em>octal</em> untuk memberikan spesifikasi <em>permission</em> dengan cara yang lebih
natural.</p><p>Kamu juga dapat melakukan mekanisme pemetaan, seperti yang sudah dilakukan pada contoh sebelumnya,
dan kemudian memberikan spesifikasi <em>permission</em> yang berbeda untuk <em>file</em> yang berbeda.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/foo&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>username<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>my-group/my-username<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>mode</span>:<span style=color:#bbb> </span><span style=color:#666>511</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Pada kasus tersebut, <em>file</em> yang dihasilkan pada <code>/etc/foo/my-group/my-username</code> akan memiliki
<em>permission</em> <code>0777</code>. Karena terdapat batasan pada representasi JSON, maka kamu
harus memberikan spesifikasi mode <em>permission</em> dalam bentuk notasi desimal.</p><p>Perhatikan bahwa <em>permission</em> ini bida saja ditampilkan dalam bentuk notasi desimal,
hal ini akan ditampilkan pada bagian selanjutnya.</p><p><strong>Mengonsumsi <em>Value</em> dari Secret melalui Volume</strong></p><p>Di dalam sebuah container dimana <em>volume</em> secret di-<em>mount</em>,
<em>key</em> dari Secret akan ditampilkan sebagai <em>file</em> dan <em>value</em> dari Secret yang berada dalam bentuk
base64 ini akan di-<em>decode</em> dam disimpan pada <em>file-file</em> tadi.
Berikut merupakan hasil dari eksekusi perintah di dalam container berdasarkan contoh
yang telah dipaparkan di atas:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>ls /etc/foo/
</span></span></code></pre></div><pre tabindex=0><code>username
password
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat /etc/foo/username
</span></span></code></pre></div><pre tabindex=0><code>admin
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat /etc/foo/password
</span></span></code></pre></div><pre tabindex=0><code>1f2d1e2e67df
</code></pre><p>Program di dalam container bertanggung jawab untuk membaca Secret
dari <em>file-file</em> yang ada.</p><p><strong>Secret yang di-<em>mount</em> Akan Diubah Secara Otomatis</strong></p><p>Ketika sebuah Secret yang sedang digunakan di dalam <em>volume</em> diubah,
maka <em>key</em> yang ada juga akan diubah. Kubelet akan melakukan mekanisme pengecekan secara periodik
apakah terdapat perubahan pada Secret yang telah di-<em>mount</em>. Meskipun demikian,
proses pengecekan ini dilakukan dengan menggunakan <em>cache</em> lokal untuk mendapatkan <em>value</em> saat ini
dari sebuah Secret. Tipe <em>cache</em> yang ada dapat diatur dengan menggunakan
(<em>field</em> <code>ConfigMapAndSecretChangeDetectionStrategy</code> pada
<a href=https://github.com/kubernetes/kubernetes/blob/main/staging/src/k8s.io/kubelet/config/v1beta1/types.go><em>struct</em> KubeletConfiguration</a>).
Mekanisme ini kemudian dapat diteruskan dengan mekanisme <em>watch</em>(<em>default</em>), ttl, atau melakukan pengalihan semua
<em>request</em> secara langsung pada kube-apiserver.
Sebagai hasilnya, <em>delay</em> total dari pertama kali Secret diubah hingga dilakukannya mekanisme
proyeksi <em>key</em> yang baru pada Pod berlangsung dalam jangka waktu sinkronisasi periodik kubelet +
<em>delay</em> propagasi <em>cache</em>, dimana <em>delay</em> propagasi <em>cache</em> bergantung pada jenis <em>cache</em> yang digunakan
(ini sama dengan <em>delay</em> propagasi <em>watch</em>, ttl dari <em>cache</em>, atau nol).</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Sebuah container menggunakan Secret sebagai
<a href=/id/docs/concepts/storage/volumes#using-subpath>subPath</a> dari <em>volume</em>
yang di-<em>mount</em> tidak akan menerima perubahan Secret.</div><h3 id=menggunakan-secret-sebagai-variabel-environment>Menggunakan Secret sebagai Variabel <em>Environment</em></h3><p>Berikut merupakan langkah-langkah yang harus kamu terapkan,
untuk menggunakan secret sebagai <a class=glossary-tooltip title='Variabel lingkungan Container merupakan pasangan nama=nilai yang dapat digunakan untuk menyediakan informasi penting bagi Container yang dijalankan pada Pod.' data-toggle=tooltip data-placement=top href=/docs/concepts/containers/container-environment-variables/ target=_blank aria-label='variabel _environment_'>variabel _environment_</a>
pada sebuah Pod:</p><ol><li>Buatlah sebuah Secret, atau gunakan sebuah Secret yang sudah kamu buat sebelumnya. Beberapa Pod dapat merujuk pada sebuah Secret yang sama.</li><li>Modifikasi definisi Pod pada setiap container dimana kamu menginginkan container tersebut dapat mengonsumsi your Pod definition in each container that you wish to consume the value of a secret key to add an environment variabele for each secret key you wish to consume. The environment variabele that consumes the secret key should populate the secret's name and key in <code>env[].valueFrom.secretKeyRef</code>.</li><li>Modifikasi <em>image</em> dan/atau <em>command line</em> kamu agar program yang kamu miliki merujuk pada <em>value</em> yang sudah didefinisikan pada variabel <em>environment</em>.</li></ol><p>Berikut merupakan contoh dimana sebuah Pod menggunakan Secret sebagai variabel <em>environment</em>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-env-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mycontainer<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>SECRET_USERNAME<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>secretKeyRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>username<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>SECRET_PASSWORD<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>secretKeyRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>password<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></span></span></code></pre></div><p><strong>Menggunakan Secret dari Variabel <em>Environment</em></strong></p><p>Di dalam sebuah container yang mengkonsumsi Secret pada sebuah variabel <em>environment</em>, <em>key</em> dari sebuah secret
akan ditampilkan sebagai variabel <em>environment</em> pada umumnya dengan <em>value</em> berupa informasi yang telah di-<em>decode</em>
ke dalam base64. Berikut merupakan hasil yang didapatkan apabila perintah-perintah di bawah ini
dijalankan dari dalam container yang didefinisikan di atas:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b8860b>$SECRET_USERNAME</span>
</span></span></code></pre></div><pre tabindex=0><code>admin
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b8860b>$SECRET_PASSWORD</span>
</span></span></code></pre></div><pre tabindex=0><code>1f2d1e2e67df
</code></pre><h3 id=menggunakan-imagepullsecrets>Menggunakan imagePullSecrets</h3><p>Sebuah <code>imagePullSecret</code> merupakan salah satu cara yang dapat digunakan untuk menempatkan secret
yang mengandung <em>password</em> dari registri Docker (atau registri <em>image</em> lainnya)
pada Kubelet, sehingga Kubelet dapat mengunduh <em>image</em> dan menempatkannya pada Pod.</p><p><strong>Memberikan spesifikasi manual dari sebuah imagePullSecret</strong></p><p>Penggunaan imagePullSecrets dideskripsikan di dalam <a href=/id/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod>dokumentasi <em>image</em></a></p><h3 id=mekanisme-yang-dapat-diterapkan-agar-imagepullsecrets-dapat-secara-otomatis-digunakan>Mekanisme yang Dapat Diterapkan agar imagePullSecrets dapat Secara Otomatis Digunakan</h3><p>Kamu dapat secara manual membuat sebuah imagePullSecret, serta merujuk imagePullSecret
yang sudah kamu buat dari sebuah serviceAccount. Semua Pod yang dibuat dengan menggunakan
serviceAccount tadi atau serviceAccount <em>default</em> akan menerima <em>field</em> imagePullSecret dari
serviceAccount yang digunakan.
Bacalah <a href=/id/docs/tasks/configure-pod-container/configure-service-account/#add-imagepullsecrets-to-a-service-account>Cara menambahkan ImagePullSecrets pada sebuah <em>service account</em></a>
untuk informasi lebih detail soal proses yang dijalankan.</p><h3 id=mekanisme-mounting-otomatis-dari-secret-yang-sudah-dibuat>Mekanisme <em>Mounting</em> Otomatis dari Secret yang Sudah Dibuat</h3><p>Secret yang dibuat secara manual (misalnya, secret yang mengandung token yang dapat digunakan
untuk mengakses akun GitHub) dapat di-<em>mount</em> secara otomatis pada sebuah Pod berdasarkan <em>service account</em>
yang digunakan oleh Pod tadi.
Baca <a href=/docs/tasks/inject-data-application/podpreset/>Bagaimana Penggunaan PodPreset untuk Memasukkan Informasi ke Dalam Pod</a> untuk informasi lebih lanjut.</p><h2 id=detail>Detail</h2><h3 id=batasan-batasan>Batasan-Batasan</h3><p>Sumber dari <em>secret volume</em> akan divalidasi untuk menjamin rujukan pada
objek yang dispesifikasikan mengarah pada objek dengan <em>type</em> <code>Secret</code>.
Oleh karenanya, sebuah <em>secret</em> harus dibuat sebelum Pod yang merujuk pada <em>secret</em>
tersebut dibuat.</p><p>Sebuah objek API Secret berada di dalam sebuah <a class=glossary-tooltip title='Sebuah abstraksi yang digunakan oleh Kubernetes untuk mendukung multipel klaster virtual pada klaster fisik yang sama.' data-toggle=tooltip data-placement=top href=/id/docs/concepts/overview/working-with-objects/namespaces target=_blank aria-label=namespace>namespace</a>.
Objek-objek ini hanya dapat dirujuk oleh Pod-Pod yang ada pada namespace yang sama.</p><p>Secret memiliki batasi dalam hal ukuran maksimalnya yaitu hanya sampai 1MiB per objek.
Oleh karena itulah, pembuatan secret dalam ukuran yang sangat besar tidak dianjurkan
karena dapat menghabiskan sumber daya apiserver dan memori kubelet. Meskipun demikian,
pembuatan banyak secret dengan ukuran kecil juga dapat menhabiskan memori. Pembatasan
sumber daya yang diizinkan untuk pembuatan secret merupakan salah satu fitur tambahan
yang direncanakan kedepannya.</p><p>Kubelet hanya mendukung penggunaan secret oleh Pod apabila Pod tersebut
didapatkan melalui apiserver. Hal ini termasuk Pod yang dibuat dengan menggunakan
kubectl, atau secara tak langsung melalui <em>replication controller</em>. Hal ini tidak
termasuk Pod yang dibuat melalui <em>flag</em> <code>--manifest-url</code> yang ada pada kubelet,
maupun REST API yang disediakan (hal ini bukanlah merupakan mekanisme umum yang dilakukan
untuk membuat sebuah Pod).</p><p>Secret harus dibuat sebelum digunakan oleh Pod sebagai variabel <em>environment</em>,
kecuali apabila variabel <em>environment</em> ini dianggap opsional. Rujukan pada Secret
yang tidak dapat dipenuhi akan menyebabkan Pod gagal <em>start</em>.</p><p>Rujukan melalui <code>secretKeyRef</code> pada <em>key</em> yang tidak ada pada <em>named</em> Secret
akan akan menyebabkan Pod gagal <em>start</em>.</p><p>Secret yang digunakan untuk memenuhi variabel <em>environment</em> melalui <code>envFrom</code> yang
memiliki <em>key</em> yang dianggap memiliki penamaan yang tidak valid akan diabaikan.
Hal ini akan akan menyebabkan Pod gagal <em>start</em>. Selanjutnya akan terdapat <em>event</em>
dengan alasan <code>InvalidvariabeleNames</code> dan pesan yang berisikan <em>list</em> dari
<em>key</em> yang diabaikan akibat penamaan yang tidak valid. Contoh yang ada akan menunjukkan
sebuah pod yang merujuk pada secret <code>default/mysecret</code> yang mengandung dua buah <em>key</em>
yang tidak valid, yaitu 1badkey dan 2alsobad.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get events
</span></span></code></pre></div><pre tabindex=0><code>LASTSEEN   FIRSTSEEN   COUNT     NAME            KIND      SUBOBJECT                         TYPE      REASON
0s         0s          1         dapi-test-pod   Pod                                         Warning   InvalidEnvironmentvariabeleNames   kubelet, 127.0.0.1      Keys [1badkey, 2alsobad] from the EnvFrom secret default/mysecret were skipped since they are considered invalid environment variabele names.
</code></pre><h3 id=interaksi-secret-dan-pod-lifetime>Interaksi Secret dan Pod Lifetime</h3><p>Ketika sebuah pod dibuat melalui API, tidak terdapat mekanisme pengecekan
yang digunakan untuk mengetahui apakah sebuah Secret yang dirujuk sudah dibuat
atau belum. Ketika sebuah Pod di-<em>schedule</em>, kubelet akan mencoba mengambil
informasi mengenai <em>value</em> dari secret tadi. Jika secret tidak dapat diambil
<em>value</em>-nya dengan alasan temporer karena hilangnya koneksi ke API server atau
secret yang dirujuk tidak ada, kubelet akan melakukan mekanisme <em>retry</em> secara periodik.
Kubelet juga akan memberikan laporan mengenai <em>event</em> yang terjadi pada Pod serta alasan
kenapa Pod tersebut belum di-<em>start</em>. Apabila Secret berhasil didapatkan, kubelet
akan membuat dan me-<em>mount</em> volume yang mengandung secret tersebut. Tidak akan ada
container dalam pod yang akan di-<em>start</em> hingga semua volume pod berhasil di-<em>mount</em>.</p><h2 id=contoh-contoh-penggunaan>Contoh-Contoh Penggunaan</h2><h3 id=contoh-penggunaan-pod-dengan-ssh-key>Contoh Penggunaan: Pod dengan <em>ssh key</em></h3><p>Buatlah sebuah kustomization.yaml dengan SecretGenerator yang mengandung beberapa <em>ssh key</em>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret generic ssh-key-secret --from-file<span style=color:#666>=</span>ssh-privatekey<span style=color:#666>=</span>/path/to/.ssh/id_rsa --from-file<span style=color:#666>=</span>ssh-publickey<span style=color:#666>=</span>/path/to/.ssh/id_rsa.pub
</span></span></code></pre></div><pre tabindex=0><code>secret &#34;ssh-key-secret&#34; created
</code></pre><div class="alert alert-warning caution callout" role=alert><strong>Perhatian:</strong> Pikirkanlah terlebih dahulu sebelum kamu menggunakan <em>ssh key</em> milikmu sendiri: pengguna lain pada kluster tersebut bisa saja memiliki akses pada secret yang kamu definisikan.
Gunakanlah service account untuk membagi informasi yang kamu inginkan di dalam kluster tersebut, dengan demikian kamu dapat membatalkan service account tersebut apabila secret tersebut disalahgunakan.</div><p>Sekarang, kita dapat membuat sebuah pod yang merujuk pada secret dengan <em>ssh key</em> yang sudah
dibuat tadi serta menggunakannya melalui sebuah volume yang di-<em>mount</em>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-test-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>ssh-key-secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>ssh-test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>mySshImage<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/secret-volume&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Ketika sebuah perintah dijalankan di dalam container, bagian dari <em>key</em> tadi akan
terdapat pada:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>/etc/secret-volume/ssh-publickey
</span></span><span style=display:flex><span>/etc/secret-volume/ssh-privatekey
</span></span></code></pre></div><p>container kemudian dapat menggunakan secret secara bebas untuk
membuat koneksi ssh.</p><h3 id=contoh-penggunaan-pod-dengan-kredensial-prod-test>Contoh Penggunaan: Pod dengan kredensial prod / test</h3><p>Contoh ini memberikan ilustrasi pod yang mengonsumsi secret yang mengandung
kredensial dari <em>environment</em> <em>production</em> atau <em>environment</em> <em>test</em>.</p><p>Buatlah suatu kustomization.yaml dengan SecretGenerator</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret generic prod-db-secret --from-literal<span style=color:#666>=</span><span style=color:#b8860b>username</span><span style=color:#666>=</span>produser --from-literal<span style=color:#666>=</span><span style=color:#b8860b>password</span><span style=color:#666>=</span>Y4nys7f11
</span></span></code></pre></div><pre tabindex=0><code>secret &#34;prod-db-secret&#34; created
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret generic test-db-secret --from-literal<span style=color:#666>=</span><span style=color:#b8860b>username</span><span style=color:#666>=</span>testuser --from-literal<span style=color:#666>=</span><span style=color:#b8860b>password</span><span style=color:#666>=</span>iluvtests
</span></span></code></pre></div><pre tabindex=0><code>secret &#34;test-db-secret&#34; created
</code></pre><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong><p>Karakter spesial seperti <code>$</code>, <code>\*</code>, dan <code>!</code> membutuhkan mekanisme <em>escaping</em>.
Jika password yang kamu gunakan memiliki karakter spesial, kamu dapat melakukan mekanisme <em>escape</em>
dengan karakter <code>\\</code> character. Sebagai contohnya, jika <em>password</em> kamu yang sebenarnya adalah
<code>S!B\*d$zDsb</code>, maka kamu harus memanggil perintah eksekusi dengan cara sebagai berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret generic dev-db-secret --from-literal<span style=color:#666>=</span><span style=color:#b8860b>username</span><span style=color:#666>=</span>devuser --from-literal<span style=color:#666>=</span><span style=color:#b8860b>password</span><span style=color:#666>=</span>S<span style=color:#b62;font-weight:700>\\</span>!B<span style=color:#b62;font-weight:700>\\\*</span>d<span style=color:#b62;font-weight:700>\\</span><span style=color:#b8860b>$zDsb</span>
</span></span></code></pre></div><p>Kamu tidak perlu melakukan mekanisme <em>escape</em> karakter apabila menggunakan opsi melalui <em>file</em> (<code>--from-file</code>).</p></div><p>Kemudian buatlah Pod-Pod yang dibutuhkan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ cat <span style=color:#b44>&lt;&lt;EOF &gt; pod.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: List
</span></span></span><span style=display:flex><span><span style=color:#b44>items:
</span></span></span><span style=display:flex><span><span style=color:#b44>- kind: Pod
</span></span></span><span style=display:flex><span><span style=color:#b44>  apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>  metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>    name: prod-db-client-pod
</span></span></span><span style=display:flex><span><span style=color:#b44>    labels:
</span></span></span><span style=display:flex><span><span style=color:#b44>      name: prod-db-client
</span></span></span><span style=display:flex><span><span style=color:#b44>  spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>    volumes:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - name: secret-volume
</span></span></span><span style=display:flex><span><span style=color:#b44>      secret:
</span></span></span><span style=display:flex><span><span style=color:#b44>        secretName: prod-db-secret
</span></span></span><span style=display:flex><span><span style=color:#b44>    containers:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - name: db-client-container
</span></span></span><span style=display:flex><span><span style=color:#b44>      image: myClientImage
</span></span></span><span style=display:flex><span><span style=color:#b44>      volumeMounts:
</span></span></span><span style=display:flex><span><span style=color:#b44>      - name: secret-volume
</span></span></span><span style=display:flex><span><span style=color:#b44>        readOnly: true
</span></span></span><span style=display:flex><span><span style=color:#b44>        mountPath: &#34;/etc/secret-volume&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44>- kind: Pod
</span></span></span><span style=display:flex><span><span style=color:#b44>  apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>  metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>    name: test-db-client-pod
</span></span></span><span style=display:flex><span><span style=color:#b44>    labels:
</span></span></span><span style=display:flex><span><span style=color:#b44>      name: test-db-client
</span></span></span><span style=display:flex><span><span style=color:#b44>  spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>    volumes:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - name: secret-volume
</span></span></span><span style=display:flex><span><span style=color:#b44>      secret:
</span></span></span><span style=display:flex><span><span style=color:#b44>        secretName: test-db-secret
</span></span></span><span style=display:flex><span><span style=color:#b44>    containers:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - name: db-client-container
</span></span></span><span style=display:flex><span><span style=color:#b44>      image: myClientImage
</span></span></span><span style=display:flex><span><span style=color:#b44>      volumeMounts:
</span></span></span><span style=display:flex><span><span style=color:#b44>      - name: secret-volume
</span></span></span><span style=display:flex><span><span style=color:#b44>        readOnly: true
</span></span></span><span style=display:flex><span><span style=color:#b44>        mountPath: &#34;/etc/secret-volume&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>Tambahkan Pod-Pod terkait pada <em>file</em> kustomization.yaml yang sama</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ cat <span style=color:#b44>&lt;&lt;EOF &gt;&gt; kustomization.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>resources:
</span></span></span><span style=display:flex><span><span style=color:#b44>- pod.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>Terapkan semua perubahan pada objek-objek tadi ke Apiserver dengan menggunakan</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply --k .
</span></span></code></pre></div><p>Kedua container kemudian akan memiliki <em>file-file</em> berikut ini di dalam
<em>filesystem</em> keduanya dengan <em>value</em> sebagai berikut untuk masing-masing <em>environment</em>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>/etc/secret-volume/username
</span></span><span style=display:flex><span>/etc/secret-volume/password
</span></span></code></pre></div><p>Perhatikan bahwa <em>specs</em> untuk kedua pod berbeda hanya pada satu <em>field</em> saja;
hal ini bertujuan untuk memfasilitasi adanya kapabilitas yang berbeda dari templat
konfigurasi umum yang tersedia.</p><p>Kamu dapat mensimplifikasi spesifikasi dasar Pod dengan menggunakan dua buah <em>service account</em> yang berbeda:
misalnya saja salah satunya disebut sebagai <code>prod-user</code> dengan <code>prod-db-secret</code>, dan satunya lagi disebut
<code>test-user</code> dengan <code>test-db-secret</code>. Kemudian spesifikasi Pod tadi dapat diringkas menjadi:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>prod-db-client-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>prod-db-client<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>serviceAccount</span>:<span style=color:#bbb> </span>prod-db-client<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>db-client-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>myClientImage<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=contoh-penggunaan-dotfiles-pada-volume-secret>Contoh Penggunaan: <em>Dotfiles</em> pada volume secret</h3><p>Dengan tujuan membuat data yang ada 'tersembunyi' (misalnya, di dalam sebuah <em>file</em> dengan nama yang dimulai
dengan karakter titik), kamu dapat melakukannya dengan cara yang cukup sederhana, yaitu cukup dengan membuat
karakter awal <em>key</em> yang kamu inginkan dengan titik. Contohnya, ketika sebuah secret di bawah ini di-<em>mount</em>
pada sebuah volume:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dotfile-secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>.secret-file</span>:<span style=color:#bbb> </span>dmFsdWUtMg0KDQo=<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-dotfiles-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>dotfile-secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dotfile-test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- ls<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;-l&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;/etc/secret-volume&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/secret-volume&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Volume <code>secret-volume</code> akan mengandung sebuah <em>file</em>, yang disebut sebagai <code>.secret-file</code>, serta
container <code>dotfile-test-container</code> akan memiliki <em>file</em> konfigurasinya pada <em>path</em>
<code>/etc/secret-volume/.secret-file</code>.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> <em>File-file</em> yang diawali dengan karakter titik akan "tersembunyi" dari keluaran perintah <code>ls -l</code>;
kamu harus menggunakan perintah <code>ls -la</code> untuk melihat <em>file-file</em> tadi dari sebuah direktori.</div><h3 id=contoh-penggunaan-secret-yang-dapat-diakses-hanya-pada-salah-satu-container-di-dalam-pod>Contoh Penggunaan: Secret yang dapat diakses hanya pada salah satu container di dalam pod</h3><p>Misalkan terdapat sebuah program yang memiliki kebutuhan untuk menangani <em>request</em> HTTP,
melakukan logika bisnis yang kompleks, serta kemudian menandai beberapa <em>message</em> yang ada
dengan menggunakan HMAC. Karena program ini memiliki logika aplikasi yang cukup kompleks,
maka bisa jadi terdapat beberapa celah terjadinya eksploitasi <em>remote</em> <em>file</em> pada server,
yang nantinya bisa saja mengekspos <em>private key</em> yang ada pada <em>attacker</em>.</p><p>Hal ini dapat dipisah menjadi dua buah proses yang berbeda di dalam dua container:
sebuah container <em>frontend</em> yang menangani interaksi pengguna dan logika bisnis, tetapi
tidak memiliki kapabilitas untuk melihat <em>private key</em>; container lain memiliki kapabilitas
melihat <em>private key</em> yang ada dan memiliki fungsi untuk menandai <em>request</em> yang berasal
dari <em>frontend</em> (melalui jaringan <em>localhost</em>).</p><p>Dengan strategi ini, seorang <em>attacker</em> harus melakukan teknik tambahan
untuk memaksa aplikasi melakukan hal yang acak, yang kemudian menyebabkan
mekanisme pembacaan <em>file</em> menjadi lebih susah.</p><h2 id=best-practices><em>Best practices</em></h2><h3 id=klien-yang-menggunakan-api-secret>Klien yang menggunakan API secret</h3><p>Ketika men-<em>deploy</em> aplikasi yang berinteraksi dengan API secret, akses yang dilakukan
haruslah dibatasi menggunakan <a href=/docs/reference/access-authn-authz/authorization/><em>policy</em> autorisasi</a> seperti <a href=/docs/reference/access-authn-authz/rbac/>RBAC</a>.</p><p>Secret seringkali menyimpan <em>value</em> yang memiliki jangkauan spektrum
kepentingan, yang mungkin saja dapat menyebabkan terjadinya eskalasi baik
di dalam Kubernetes (misalnya saja token dari sebuah <em>service account</em>) maupun<br>sistem eksternal. Bahkan apabila setiap aplikasi secara individual memiliki
kapabilitas untuk memahami tingkatan yang dimilikinya untuk berinteraksi dengan secret tertentu,
aplikasi lain dalam namespace itu bisa saja menyebabkan asumsi tersebut menjadi tidak valid.</p><p>Karena alasan-alasan yang sudah disebutkan tadi <em>request</em> <code>watch</code> dan <code>list</code> untuk sebuah
secret di dalam suatu namespace merupakan kapabilitas yang sebisa mungkin harus dihindari,
karena menampilkan semua secret yang ada berimplikasi pada akses untuk melihat isi yang ada
pada secret yang ada. Kapabilitas untuk melakukan <em>request</em> <code>watch</code> dan <code>list</code> pada semua secret di kluster
hanya boleh dimiliki oleh komponen pada sistem level yang paling <em>previleged</em>.</p><p>Aplikasi yang membutuhkan akses ke API secret harus melakukan <em>request</em> <code>get</code> pada
secret yang dibutuhkan. Hal ini memungkinkan administrator untuk membatasi
akses pada semua secret dengan tetap memberikan <a href=/id/docs/reference/access-authn-authz/rbac/#referring-to-resources>akses pada instans secret tertentu</a>
yang dibutuhkan aplikasi.</p><p>Untuk meningkatkan performa dengan menggunakan iterasi <code>get</code>, klien dapat mendesain
sumber daya yang merujuk pada suatu secret dan kemudian melakukan <code>watch</code> pada secret tersebut,
serta melakukan <em>request</em> secret ketika terjadi perubahan pada rujukan tadi. Sebagai tambahan, <a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/bulk_watch.md>API "bulk watch"</a>
yang dapat memberikan kapabilitas <code>watch</code> individual pada sumber daya melalui klien juga sudah direncanakan,
dan kemungkinan akan diimplementasikan dirilis Kubernetes selanjutnya.</p><h2 id=properti-keamanan>Properti Keamanan</h2><h3 id=proteksi>Proteksi</h3><p>Karena objek <code>secret</code> dapat dibuat secara independen dengan <code>pod</code> yang menggunakannya,
risiko tereksposnya secret di dalam workflow pembuatan, pemantauan, serta pengubahan pod.
Sistem yang ada juga dapat memberikan tindakan pencegahan ketika berinteraksi dengan <code>secret</code>,
misalnya saja tidak melakukan penulisan isi <code>secret</code> ke dalam disk apabila hal tersebut
memungkinkan.</p><p>Sebuah secret hanya diberikan pada node apabila pod yang ada di dalam node
membutuhkan secret tersebut. Kubelet menyimpan secret yang ada pada <code>tmpfs</code>
sehingga secret tidak ditulis pada disk. Setelah pod yang bergantung pada secret tersebut dihapus,
maka kubelet juga akan menghapus salinan lokal data secret.</p><p>Di dalam sebuah node bisa saja terdapat beberapa secret yang dibutuhkan
oleh pod yang ada di dalamnya. Meskipun demikian, hanya secret yang di-<em>request</em>
oleh sebuah pod saja yang dapat dilihat oleh container yang ada di dalamnya.
Dengan demikian, sebuah Pod tidak memiliki akses untuk melihat secret yang ada
pada pod yang lain.</p><p>Di dalam sebuah pod bisa jadi terdapat beberapa container.
Meskipun demikian, agar sebuah container bisa mengakses <em>volume secret</em>, container
tersebut haruslah mengirimkan <em>request</em> <code>volumeMounts</code> yang ada dapat diakses dari
container tersebut. Pengetahuan ini dapat digunakan untuk membentuk <a href=#contoh-penggunaan-secret-yang-dapat-diakses-hanya-pada-salah-satu-container-di-dalam-pod>partisi security
pada level pod</a>.</p><p>Pada sebagian besar distribusi yang dipelihara projek Kubernetes,
komunikasi antara pengguna dan apiserver serta apisserver dan kubelet dilindungi dengan menggunakan SSL/TLS.
Dengan demikian, secret dalam keadaan dilindungi ketika ditransmisi.</p><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.13 [beta]</code></div><p>Kamu dapat mengaktifkan <a href=/docs/tasks/administer-cluster/encrypt-data/>enkripsi pada rest</a>
untuk data secret, sehingga secret yang ada tidak akan ditulis ke dalam <a class=glossary-tooltip title='Penyimpanan key value konsisten yang digunakan sebagai penyimpanan data klaster Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/tasks/administer-cluster/configure-upgrade-etcd/ target=_blank aria-label=etcd>etcd</a>
dalam keadaan tidak terenkripsi.</p><h3 id=resiko>Resiko</h3><ul><li>Pada API server, data secret disimpan di dalam <a class=glossary-tooltip title='Penyimpanan key value konsisten yang digunakan sebagai penyimpanan data klaster Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/tasks/administer-cluster/configure-upgrade-etcd/ target=_blank aria-label=etcd>etcd</a>;
dengan demikian:<ul><li>Administrator harus mengaktifkan enkripsi pada rest untuk data kluster (membutuhkan versi v1.13 atau lebih)</li><li>Administrator harus membatasi akses etcd pada pengguna dengan kapabilitas admin</li><li>Administrator bisa saja menghapus data disk yang sudah tidak lagi digunakan oleh etcd</li><li>Jika etcd dijalankan di dalam kluster, administrator harus memastikan SSL/TLS
digunakan pada proses komunikasi peer-to-peer etcd.</li></ul></li><li>Jika kamu melakukan konfigurasi melalui sebuah <em>file</em> manifest (JSON or YAML)
yang menyimpan data secret dalam bentuk base64, membagi atau menyimpan secret ini
dalam repositori kode sumber sama artinya dengan memberikan informasi mengenai data secret.
Mekanisme <em>encoding</em> base64 bukanlah merupakan teknik enkripsi dan nilainya dianggap sama saja dengan <em>plain text</em>.</li><li>Aplikasi masih harus melindungi <em>value</em> dari secret setelah membaca nilainya dari suatu volume
dengan demikian risiko terjadinya <em>logging</em> secret secara tidak engaja dapat dihindari.</li><li>Seorang pengguna yang dapat membuat suatu pod yang menggunakan secret, juga dapat melihat <em>value</em> secret.
Bahkan apabila <em>policy</em> apiserver tidak memberikan kapabilitas untuk membaca objek secret, pengguna
dapat menjalankan pod yang mengekspos secret.</li><li>Saat ini, semua orang dengan akses <em>root</em> pada node dapat membaca secret <em>apapun</em> dari apiserver,<br>dengan cara meniru kubelet. Meskipun begitu, terdapat fitur yang direncanakan pada rilis selanjutnya yang memungkinkan pengiriman secret hanya dapat
mengirimkan secret pada node yang membutuhkan secret tersebut untuk membatasi adanya eksploitasi akses <em>root</em> pada node ini.</li></ul><h2 id=selanjutnya>Selanjutnya</h2></div><div class=td-content style=page-break-before:always><h1 id=pg-ab6d20f33ad930a67ee7ef57bff6c75e>3.7.4 - Mengatur Akses Klaster Menggunakan Berkas kubeconfig</h1><p>Gunakan berkas kubeconfig untuk mengatur informasi mengenai klaster, pengguna,
<em>namespace</em>, dan mekanisme autentikasi. Perintah <code>kubectl</code> menggunakan berkas
kubeconfig untuk mencari informasi yang dibutuhkan untuk memilih klaster dan
berkomunikasi dengan API server dari suatu klaster.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Sebuah berkas yang digunakan untuk mengatur akses pada klaster disebut dengan
berkas kubeconfig. Ini cara yang umum digunakan untuk mereferensikan berkas
konfigurasi. Ini tidak berarti ada berkas dengan nama <code>kubeconfig</code>.</div><p>Secara <em>default</em>, <code>kubectl</code> mencari berkas dengan nama <code>config</code> pada direktori
<code>$HOME/.kube</code>. Kamu bisa mengatur lokasi berkas kubeconfig dengan mengatur
nilai <code>KUBECONFIG</code> pada variabel <em>environment</em> atau dengan mengatur menggunakan
tanda <a href=/docs/reference/generated/kubectl/kubectl/><code>--kubeconfig</code></a>.</p><p>Instruksi langkah demi langkah untuk membuat dan menentukan berkas kubeconfig,
bisa mengacu pada [Mengatur Akses Pada Beberapa Klaster]
(/id/docs/tasks/access-application-cluster/configure-access-multiple-clusters).</p><h2 id=mendukung-beberapa-klaster-pengguna-dan-mekanisme-autentikasi>Mendukung beberapa klaster, pengguna, dan mekanisme autentikasi</h2><p>Misalkan kamu memiliki beberapa klaster, pengguna serta komponen dapat melakukan
autentikasi dengan berbagai cara. Sebagai contoh:</p><ul><li>Kubelet yang berjalan dapat melakukan autentikasi dengan menggunakan sertifikat</li><li>Pengguna bisa melakukan autentikasi dengan menggunakan token</li><li>Administrator bisa memiliki beberapa sertifikat yang diberikan kepada pengguna
individu.</li></ul><p>Dengan berkas kubeconfig, kamu bisa mengatur klaster, pengguna, dan <em>namespace</em>.
Kamu juga bisa menentukan konteks untuk mempercepat dan mempermudah perpindahan
antara klaster dan <em>namespace</em>.</p><h2 id=konteks>Konteks</h2><p>Sebuah elemen konteks pada berkas kubeconfig digunakan untuk mengelompokkan
parameter akses dengan nama yang mudah. Setiap konteks akan memiliki 3 parameter:
klaster, pengguna, dan <em>namespace</em>. Secara <em>default</em>, perintah <code>kubectl</code> menggunakan
parameter dari konteks yang aktif untuk berkomunikasi dengan klaster.</p><p>Untuk memilih konteks yang aktif, bisa menggunakan perintah berikut:</p><pre tabindex=0><code>kubectl config use-context
</code></pre><h2 id=variabel-environment-kubeconfig>Variabel <em>environment</em> KUBECONFIG</h2><p>Variabel <em>environment</em> <code>KUBECONFIG</code> berisikan beberapa berkas kubeconfig. Untuk
Linux dan Mac, beberapa berkas tersebut dipisahkan dengan tanda titik dua (:).
Untuk Windows, dipisahkan dengan menggunakan tanda titik koma (;). Variabel
<em>environment</em> <code>KUBECONFIG</code> tidak diwajibkan untuk ada. Jika variabel <em>environment</em>
<code>KUBECONFIG</code> tidak ada, maka <code>kubectl</code> akan menggunakan berkas kubeconfig pada
<code>$HOME/.kube/config</code>.</p><p>Jika variabel <em>environment</em> <code>KUBECONFIG</code> ternyata ada, maka <code>kubectl</code> akan menggunakan
konfigurasi yang merupakan hasil gabungan dari berkas-berkas yang terdapat pada
variabel <em>environment</em> <code>KUBECONFIG</code>.</p><h2 id=menggabungkan-berkas-berkas-kubeconfig>Menggabungkan berkas-berkas kubeconfig</h2><p>Untuk melihat konfigurasimu, gunakan perintah berikut ini:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config view
</span></span></code></pre></div><p>Seperti yang dijelaskan sebelumnya, hasil perintah diatas bisa berasal dari sebuah
berkas kubeconfig, atau bisa juga merupakan hasil gabungan dari beberapa berkas kubeconfig.</p><p>Berikut adalah aturan yang digunakan <code>kubectl</code> ketika menggabungkan beberapa berkas
kubeconfig:</p><ol><li><p>Jika menggunakan tanda <code>--kubeconfig</code>, maka akan menggunakan berkas yang ditentukan.
Tidak digabungkan. Hanya 1 tanda <code>--kubeconfig</code> yang diperbolehkan.</p><p>Sebaliknya, jika variabel <em>environment</em> <code>KUBECONFIG</code> digunakan, maka akan menggunakan
ini sebagai berkas-berkas yang akan digabungkan. Penggabungan berkas-berkas yang terdapat
pada variabel <em>environment</em> <code>KUBECONFIG</code> akan mengikuti aturan sebagai berikut:</p><ul><li>Mengabaikan berkas tanpa nama.</li><li>Mengeluarkan pesan kesalahan untuk berkas dengan isi yang tidak dapat dideserialisasi.</li><li>Berkas pertama yang menentukan nilai atau <em>key</em> pada <em>map</em> maka akan digunakan
pada <em>map</em> tersebut.</li><li>Tidak pernah mengubah nilai atau <em>key</em> dari suatu <em>map</em>.
Contoh: Pertahankan konteks pada berkas pertama yang mengatur <code>current-context</code>.
Contoh: Jika terdapat dua berkas yang menentukan nilai <code>red-user</code>, maka hanya gunakan
nilai <code>red-user</code> dari berkas pertama.
Meskipun berkas kedua tidak memiliki entri yang bertentangan pada <code>red-user</code>,
abaikan mereka.</li></ul><p>Beberapa contoh pengaturan variabel <em>environment</em> <code>KUBECONFIG</code>, bisa melihat pada
<a href=/id/docs/tasks/access-application-cluster/configure-access-multiple-clusters/#set-the-kubeconfig-environment-variable>pengaturan vaiabel <em>environment</em> KUBECONFIG</a>.</p><p>Sebaliknya, bisa menggunakan berkas kubeconfig <em>default</em>, <code>$HOME/.kube/config</code>,
tanpa melakukan penggabungan.</p></li><li><p>Konteks ditentukan oleh yang pertama sesuai dari pilihan berikut:</p><ol><li>Menggunakan tanda <code>--context</code> pada perintah</li><li>Menggunakan nilai <code>current-context</code> dari hasil gabungan berkas kubeconfig.</li></ol><p>Konteks yang kosong masih diperbolehkan pada tahap ini.</p></li><li><p>Menentukan klaster dan pengguna. Pada tahap ini, mungkin akan ada atau tidak ada konteks.
Menentukan klaster dan pengguna berdasarkan yang pertama sesuai dengan pilihan berikut,
yang mana akan dijalankan dua kali: sekali untuk pengguna dan sekali untuk klaster:</p><ol><li>Jika ada, maka gunakan tanda pada perintah: <code>--user</code> atau <code>--cluster</code>.</li><li>Jika konteks tidak kosong, maka pengguna dan klaster didapat dari konteks.</li></ol><p>Pengguna dan klaster masih diperbolehkan kosong pada tahap ini.</p></li><li><p>Menentukan informasi klaster sebenarnya yang akan digunakan. Pada tahap ini, mungkin
akan ada atau tidak ada informasi klaster. Membentuk informasi klaster berdasarkan urutan
berikut dan yang pertama sesuai akan digunakan:</p><ol><li>Jika ada, maka gunakan tanda pada perintah: <code>--server</code>, <code>--certificate-authority</code>, <code>--insecure-skip-tls-verify</code>.</li><li>Jika terdapat atribut informasi klaster dari hasil gabungan berkas kubeconfig,
maka gunakan itu.</li><li>Jika tidak terdapat informasi mengenai lokasi server, maka dianggap gagal.</li></ol></li><li><p>Menentukan informasi pengguna sebenarnya yang akan digunakan. Membentuk informasi
pengguna dengan aturan yang sama dengan pembentukan informasi klaster, namun hanya
diperbolehkan ada satu teknik autentikasi untuk setiap pengguna:</p><ol><li>Jika ada, gunakan tanda pada perintah: <code>--client-certificate</code>, <code>--client-key</code>, <code>--username</code>, <code>--password</code>, <code>--token</code>.</li><li>Menggunakan <em>field</em> <code>user</code> dari hasil gabungan berkas kubeconfig.</li><li>Jika terdapat dua teknik yang bertentangan, maka dianggap gagal.</li></ol></li><li><p>Untuk setiap informasi yang masih belum terisi, akan menggunakan nilai <code>default</code> dan
kemungkinan akan meminta informasi autentikasi.</p></li></ol><h2 id=referensi-berkas>Referensi berkas</h2><p>Referensi <em>file</em> dan <em>path</em> pada berkas kubeconfig adalah bernilai relatif terhadap
lokasi dari berkas kubeconfig.
Referensi <em>file</em> pada perintah adalah relatif terhadap direktori kerja saat ini.
Dalam <code>$HOME/.kube/config</code>, <em>relative path</em> akan disimpan secara relatif, dan
<em>absolute path</em> akan disimpan secara mutlak.</p><h2 id=selanjutnya>Selanjutnya</h2><ul><li><a href=/id/docs/tasks/access-application-cluster/configure-access-multiple-clusters/>Mengatur Akses Pada Beberapa Klaster</a></li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#config><code>kubectl config</code></a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-ed4ae5e4344d619bc6df6e1278efae74>3.7.5 - Prioritas dan Pemindahan Pod</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes 1.14 [stable]</code></div><p><a href=/docs/user-guide/pods>Pod</a> dapat memiliki <em>priority</em> (prioritas). Priority mengindikasikan lebih penting atau tidaknya sebuah Pod dibandingkan dengan Pod-pod lainnya. Jika sebuah Pod tidak dapat dijadwalkan (tertunda/<em>pending</em>), penjadwal akan mencoba untuk melakukan <em>preemption</em>/pemindahan (mengusir/<em>evict</em>) Pod-pod dengan prioritas lebih rendah agar penjadwalan Pod yang tertunda sebelumnya dapat dilakukan.</p><p>Pada Kubernetes 1.9 dan sesudahnya, Priority juga memengaruhi urutan penjadwalan Pod-pod dan urutan pengusiran Pod-pod dari Node pada kasus kehabisan sumber daya.</p><p>Priority dan Pemindahan Pod lulus menjadi <em>beta</em> pada Kubernetes 1.11 dan menjadi GA (<em>Generally Available</em>) pada Kubernetes 1.14. Mereka telah dihidupkan secara bawaan sejak versi 1.11.</p><p>Pada versi-versi Kubernetes di mana Priority dan pemindahan Pod masih berada pada tingkat fitur <em>alpha</em>, kamu harus menghidupkannya secara eksplisit. Untuk menggunakan fitur-fitur pada versi-versi lama Kubernetes, ikuti petunjuk di dokumentasi versi Kubernetes kamu, melalui arsip versi dokumentasi untuk versi Kubernetes kamu.</p><table><thead><tr><th>Versi Kubernetes</th><th style=text-align:center>Keadaan Priority and Pemindahan</th><th style=text-align:center>Dihidupkan secara Bawaan</th></tr></thead><tbody><tr><td>1.8</td><td style=text-align:center>alpha</td><td style=text-align:center>tidak</td></tr><tr><td>1.9</td><td style=text-align:center>alpha</td><td style=text-align:center>tidak</td></tr><tr><td>1.10</td><td style=text-align:center>alpha</td><td style=text-align:center>tidak</td></tr><tr><td>1.11</td><td style=text-align:center>beta</td><td style=text-align:center>ya</td></tr><tr><td>1.14</td><td style=text-align:center>stable</td><td style=text-align:center>ya</td></tr></tbody></table><div class="alert alert-danger warning callout" role=alert><strong>Peringatan:</strong> Pada sebuah klaster di mana tidak semua pengguna dipercaya, seorang pengguna yang berniat jahat dapat membuat Pod-pod dengan prioritas paling tinggi, membuat Pod-pod lainnya dipindahkan/tidak dapat dijadwalkan. Untuk mengatasi masalah ini, <a href=/id/docs/concepts/policy/resource-quotas/>ResourceQuota</a> ditambahkan untuk mendukung prioritas Pod. Seorang admin dapat membuat ResourceQuota untuk pengguna-pengguna pada tingkat prioritas tertentu, mencegah mereka untuk membuat Pod-pod pada prioritas tinggi. Fitur ini telah beta sejak Kubernetes 1.12.</div><h2 id=bagaimana-cara-menggunakan-priority-dan-pemindahan-pod>Bagaimana cara menggunakan Priority dan pemindahan Pod</h2><p>Untuk menggunakan Priority dan pemindahan Pod pada Kubernetes 1.11 dan sesudahnya, ikuti langkah-langkah berikut:</p><ol><li><p>Tambahkan satu atau lebih <a href=#priorityclass>PriorityClass</a>.</p></li><li><p>Buat Pod-pod dengan <a href=#prioritas-pod><code>priorityClassName</code></a>
disetel menjadi salah satu dari PriorityClass yang ditambahkan.
Tentu saja kamu tidak perlu membuat Pod-pod tersebut secara langsung;
Biasanya kamu akan menambahkan <code>priorityClassName</code> pada
<code>template</code> Pod dari sebuah objek kumpulan seperti sebuah Deployment.</p></li></ol><p>Teruslah membaca untuk lebih banyak informasi mengenai langkah-langkah tersebut.</p><p>Jika kamu mencoba fitur ini dan memutuskan untuk mematikannya, kamu harus menghapus <em>command-line flag</em> PodPriority atau menyetelnya menjadi <code>false</code>, kemudian melakukan pengulangan kembali terhadap API Server dan Scheduler. Setelah fitur ini dimatikan, Pod-pod yang sudah ada tetap akan memiliki kolom priority mereka, tetapi pemindahan Pod akan dimatikan, dan kolom-kolom priority tersebut diabaikan. Jika fitur tersebut telah dimatikan, kamu tidak dapat menyetel kolom <code>priorityClassName</code> pada Pod-pod baru.</p><h2 id=cara-mematikan-pemindahan-pod>Cara mematikan pemindahan Pod</h2><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Pada Kubernetes 1.12 ke atas, Pod-pod yang penting mengandalkan oleh Schneduler agar dapat dijadwalkan saat klaster berada pada kondisi kekurangan sumber daya. Untuk alasan ini, tidak direkomendasikan untuk mematikan fitur pemindahan Pod.</div><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Pada Kubernetes 1.15 ke atas, jika fitur <code>NonPreemptingPriority</code> diaktifkan, PriorityClass memiliki pilihan untuk menyetel <code>preemptionPolicy: Never</code>.
Hal ini akan mencegah Pod-pod dari PriorityClass tersebut untuk memicu pemindahan Pod-pod lainnya.</div><p>Pada Kubernetes 1.11 dan sesudahnya, pemindahan Pod dikontrol oleh sebuah <em>flag</em> kube-scheduler yaitu <code>disablePreemption</code>, yang disetel menjadi <code>false</code> secara bawaan. Jika kamu ingin mematikan pemindahan Pod meskipun ada catatan di atas, kamu dapat menyetel <code>disablePreemption</code> menjadi <code>true</code>.</p><p>Opsi ini hanya tersedia pada (berkas) konfigurasi komponen saja, dan tidak tersedia pada cara lama melalui <em>command line options</em>. Berikut contoh konfigurasi komponen untuk mematikan pemindahan (<em>preemption</em>) Pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubescheduler.config.k8s.io/v1alpha1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>KubeSchedulerConfiguration<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>algorithmSource</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>provider</span>:<span style=color:#bbb> </span>DefaultProvider<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>disablePreemption</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=priorityclass>PriorityClass</h2><p>Sebuah PriorityClass adalah sebuah objek tanpa Namespace yang mendefinisikan pemetaan dari sebuah nama kelas prioritas menjadi nilai <em>integer</em> dari prioritas tersebut. Nama tersebut dirinci pada kolom <code>name</code> dari <code>metadata</code> objek PriorityClass tersebut. Nilainya dirinci pada kolom <code>value</code> yang diperlukan. Semakin tinggi nilainya, maka semakin tinggi juga prioritasnya.</p><p>Sebuah objek PriorityClass dapat memiliki nilai <em>integer</em> 32-bit apa pun yang kurang dari atau sama dengan 1 miliar. Angka-angka yang lebih besar dicadangkan untuk Pod-pod pada sistem yang sangat penting yang secara normal sebaiknya tidak dipindahkan atau diusir. Seorang admin klaster sebaiknya membuat sebuah objek PriorityClass untuk setiap pemetaan seperti ini yang ia inginkan.</p><p>PriorityClass juga memiliki dua kolom opsional: <code>globalDefault</code> dan <code>description</code>. Kolom <code>globalDefault</code> mengindikasikan bahwa nilai PriorityClass ini sebaiknya digunakan tanpa sebuah <code>priorityClassName</code>. Hanya sebuah PriorityClass dengan <code>globalDefault</code> disetel menjadi <code>true</code> dapat berada pada sistem/klaster. Jika tidak ada PriorityClass dengan <code>globalDefault</code> yang telah disetel, prioritas Pod-pod tanpa <code>priorityClassName</code> adalah nol.</p><p>Kolom <code>description</code> adalah <em>string</em> yang sembarang. Kolom ini diperuntukkan untuk memberitahukan pengguna-pengguna klaster kapan mereka harus menggunakan PriorityClass ini.</p><h3 id=catatan-mengenai-podpriority-dan-klaster-klaster-yang-sudah-ada>Catatan mengenai PodPriority dan Klaster-klaster yang sudah ada</h3><ul><li><p>Jika kamu meningkatkan versi klaster kamu dan menghidupkan fitur ini, prioritas
Pod-pod kamu yang sudah ada akan secara efektif menjadi nol.</p></li><li><p>Penambahan dari sebuah PriorityClass dengan <code>globalDefault</code> yang disetel menjadi
<code>true</code> tidak mengubah prioritas-prioritas Pod-pod yang sudah ada. Nilai dari
PriorityClass semacam ini digunakan hanya untuk Pod-pod yang dibuat setelah
PriorityClass tersebut ditambahkan.</p></li><li><p>Jika kamu menghapus sebuah PriorityClass, Pod-pod yang sudah ada yang menggunakan
nama dari PriorityClass yang dihapus tersebut tidak akan berubah, tetapi kamu tidak
dapat membuat lebih banyak Pod yang menggunakan nama dari PriorityClass yang telah
dihapus tersebut.</p></li></ul><h3 id=contoh-priorityclass>Contoh PriorityClass</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>scheduling.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PriorityClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>high-priority<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#666>1000000</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>globalDefault</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>description</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Kelas prioritas ini sebaiknya hanya digunakan untuk Pod-pod layanan XYZ saja.&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=non-preempting-priority-class>PriorityClass yang <em>Non-preempting</em> (alpha)</h3><p>Kubernetes 1.15 menambahkan kolom <code>PreemptionPolicy</code> sebagai sebuah fitur <em>alpha</em>. Fitur ini dimatikan secara bawaan pada 1.15, dan membutuhkan diaktifkannya <a href=/docs/reference/command-line-tools-reference/feature-gates/><em>feature gate</em></a> <code>NonPreemptingPriority</code>.</p><p>Pod-pod dengan <code>PreemptionPolicy: Never</code> akan ditaruh pada antrean penjadwalkan mendahului Pod-pod dengan prioritas rendah, tetapi mereka tidak dapat memicu pemindahan Pod-pod lainnya (disebut juga Pod yang <em>non-preempting</em>).
Sebuah Pod yang <em>non-preempting</em> yang sedang menunggu untuk dijadwalkan akan tetap berada pada antrean penjadwalan, hingga sumber daya yang cukup tersedia, dan ia dapat dijadwalkan. Pod yang <em>non-preempting</em>, seperti Pod-pod lainnya, tunduk kepada <em>back-off</em> dari Scheduler. Hal ini berarti bahwa jika Scheduler mencoba untuk menjadwalkan Pod-pod ini dan mereka tidak dapat dijadwalkan, mereka akan dicoba kembali dengan frekuensi (percobaan) yang lebih rendah, memungkinkan Pod-pod lain dengan prioritas yang lebih rendah untuk dijadwalkan sebelum mereka dijadwalkan.</p><p>Pod yang <em>non-preempting</em> tetap dapat dipicu untuk dipindahkan oleh Pod lainnya yang memiliki prioritas yang lebih tinggi.</p><p><code>PreemptionPolicy</code> secara bawaan nilainya <code>PreemptionLowerPriority</code>, yang memungkinkan Pod-pod dengan PriorityClass tersebut untuk memicu pemindahan Pod-pod dengan prioritas lebih rendah (sama seperti sifat bawaan). Jika <code>PreemptionPolicy</code> disetel menjadi <code>Never</code>, Pod-pod pada PriorityClass tersebut akan menjadi Pod yang <em>non-preempting</em>.</p><p>Sebuah contoh kasus misalnya pada beban kerja <em>data science</em>.
Seorang pengguna dapat memasukkan sebuah beban kerja yang mereka ingin prioritaskan di atas beban kerja lainnya, tetapi tidak ingin menghapus beban kerja yang sudah ada melalui pemicuan pemindahan Pod-pod yang sedang berjalan.
Beban kerja prioritas tinggi dengan <code>PreemptionPolicy: Never</code> akan dijadwalkan mendahului Pod-pod lainnya yang berada dalam antrean, segera setelah sumber daya klaster "secara alami" menjadi cukup.</p><h4 id=contoh-priorityclass-yang-non-preempting>Contoh PriorityClass yang <em>Non-preempting</em></h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>scheduling.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PriorityClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>high-priority-nonpreempting<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#666>1000000</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>preemptionPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>globalDefault</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>description</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Kelas prioritas ini tidak akan memicu pemindahan Pod-pod lainnya.&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=prioritas-pod>Prioritas Pod</h2><p>Setelah kamu memiliki satu atau lebih PriorityClass, kamu dapat membuat Pod-pod yang merinci satu dari nama-nama PriorityClass tersebut pada spesifikasi mereka. Admission Controller prioritas menggunakan kolom <code>priorityClassName</code> dan mengumpulkan nilai <em>integer</em> dari prioritasnya. Jika PriorityClass-nya tidak ditemukan, maka Pod tersebut akan ditolak.</p><p>YAML berikut adalah contoh sebuah konfigurasi Pod yang menggunakan PriorityClass yang telah dibuat pada contoh sebelumnya. Admission Controller prioritas akan memeriksa spesifikasi tersebut dan memetakan prioritas Pod tersebut menjadi nilai 1000000.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb> </span>test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>IfNotPresent<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>priorityClassName</span>:<span style=color:#bbb> </span>high-priority<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=efek-prioritas-pod-terhadap-urutan-penjadwalan>Efek prioritas Pod terhadap urutan penjadwalan</h3><p>Pada Kubernetes 1.9 dan sesudahnya, saat prioritas Pod dihidupkan, Scheduler mengurutkan Pod-pod yang tertunda berdasarkan prioritas mereka dan sebuah Pod yang tertunda diletakkan mendahului Pod-pod tertunda lainnya yang memiliki prioritas yang lebih rendah pada antrean penjadwalan. Sebagai hasilnya, Pod dengan prioritas lebih tinggi dapat dijadwalkan lebih awal daripada Pod-pod dengan prioritas yang lebih rendah jika syarat penjadwalan terpenuhi. Jika Pod ini tidak dapat dijadwalkan, Scheduler akan melewatkannya dan mencoba untuk menjadwalkan Pod-pod lain dengan prioritas yang lebih rendah.</p><h2 id=pemindahan-pod>Pemindahan Pod</h2><p>Saat Pod-pod dibuat, mereka masuk ke sebuah antrean dan menunggu untuk dijadwalkan. Scheduler memilih sebuah Pod dari antrean dan mencoba untuk menjadwalkannya pada sebuah Node. Jika tidak ditemukan Node yang memenuhi semua kebutuhan Pod tersebut, logika program pemindahan Pod dipicu untuk Pod yang tertunda tersebut. Kita akan menyebut Pod tertunda tersebut dengan P. Logika program pemindahan Pod mencoba untuk menemukan sebuah Node di mana penghapusan dari satu atau lebih Pod dengan prioritas yang lebih rendah daripada P dapat memungkinkan P untuk dijadwalkan pada Node tersebut. Jika Node tersebut ditemukan, satu atau lebih Pod dengan prioritas lebih rendah akan dipindahkan dari Node tersebut. Setelah Pod-pod tersebut dihapus, P dapat dijadwalkan pada Node tersebut.</p><h3 id=informasi-yang-diekspos-pengguna>Informasi yang diekspos pengguna</h3><p>Saat Pod P memicu pemindahan satu atau lebih Pod pada Node N, kolom <code>nominatedNodeName</code> pada status Pod P disetel menjadi nama dari node N. Kolom ini membantu Scheduler untuk melacak sumber daya yang dicadangkan untuk Pod P dan juga memberikan informasi mengenai pemindahan Pod pada klaster untuk pengguna-pengguna.</p><p>Harap catat bahwa Pod P tidak harus dijadwalkan pada "<em>nominated</em> Node" (Node yang dicalonkan) tersebut. Setelah Pod-pod yang terpilih telah dipindahkan, mereka akan mendapatkan periode penghentian secara sopan (<em>graceful</em>) mereka. Jika Node lain menjadi tersedia saat Scheduler sedang menunggu penghentian Pod-pod yang terpilih untuk dipindahkan, Scheduler akan menggunakan Node lain tersebut untuk menjadwalkan Pod P. Sebagai hasilnya <code>nominatedNodeName</code> dan <code>nodeName</code> dari spesifikasi Pod belum tentu selalu sama. Juga, jika Scheduler memindahkan Pod-pod pada Node N, tapi kemudian sebuah Pod lain dengan prioritas lebih tinggi daripada Pod P tiba, Scheduler boleh memberikan Node N kepada Pod dengan prioritas lebih tinggi tersebut. Pada kasus demikian, Scheduler menghapus <code>nominatedPodName</code> dari Pod P. Dengan melakukan ini, Scheduler membuat Pod P berhak untuk memicu pemindahan Pod-pod lain pada Node lain.</p><h3 id=batasan-batasan-pemindahan-pod>Batasan-batasan pemindahan Pod</h3><h4 id=penghentian-secara-sopan-dari-korban-korban-pemindahan-pod>Penghentian secara sopan dari korban-korban pemindahan Pod</h4><p>Saat Pod-pod dipindahkan, korban-korbannya mendapatkan <a href=/id/docs/concepts/workloads/pods/pod/#penghentian-pod>periode penghentian secara sopan</a>. Mereka memiliki waktu sebanyak itu untuk menyelesaikan pekerjaan merekan dan berhenti. Jika mereka tidak menyelesaikannya sebelum waktu tersebut, mereka akan dihentikan secara paksa. Periode penghentian secara sopan ini membuat sebuah jarak waktu antara saat di mana Scheduler memindahkan Pod-pod dengan waktu saat Pod yang tertunda tersebut (P) dapat dijadwalkan pada Node tersebut (N). Sementara itu, Scheduler akan terus menjadwalkan Pod-pod lain yang tertunda. Oleh karena itu, biasanya ada jarak waktu antara titik di mana Scheduler memindahkan korban-korban dan titik saat Pod P dijadwalkan. Untuk meminimalkan jarak waktu ini, kamu dapat menyetel periode penghentian secara sopan dari Pod-pod dengan prioritas lebih rendah menjadi nol atau sebuah angka yang kecil.</p><h4 id=poddisruptionbudget-didukung-tapi-tidak-dijamin>PodDisruptionBudget didukung, tapi tidak dijamin!</h4><p>Sebuah <a href=/id/docs/concepts/workloads/pods/disruptions/>Pod Disruption Budget (PDB)</a> memungkinkan pemilik-pemilik aplikasi untuk membatasi jumlah Pod-pod dari sebuah aplikasi yang direplikasi yang mati secara bersamaan dikarenakan disrupsi yang disengaja. Kubernetes 1.9 mendukung PDB saat memindahkan Pod-pod, tetapi penghormatan terhadap PDB ini bersifat "usaha terbaik" (<em>best-effort</em>). Scheduler akan mencoba mencari korban-korban yang PDB-nya tidak dilanggar oleh pemindahan, tetapi jika tidak ada korban yang ditemukan, pemindahan akan tetap terjadi, dan Pod-pod dengan prioritas lebih rendah akan dihapus/dipindahkan meskipun PDB mereka dilanggar.</p><h4 id=afinitas-antar-pod-pada-pod-pod-dengan-prioritas-lebih-rendah>Afinitas antar-Pod pada Pod-pod dengan prioritas lebih rendah</h4><p>Sebuah Node akan dipertimbangkan untuk pemindahan Pod hanya jika jawaban pertanyaan berikut adalah "ya": "Jika semua Pod-pod dengan prioritas lebih rendah dari Pod yang tertunda dipindahkan dari Node, dapatkan Pod yang tertunda tersebut dijadwalkan (secara sukses) ke Node tersebut?"</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Pemindahan Pod tidak harus memindahkan semua Pod-pod dengan prioritas lebih rendah. Jika Pod yang tertunda dapat dijadwalkan dengan memindahkan lebih sedikit daripada semua Pod-pod dengan prioritas yang lebih rendah, maka hanya sebagian dari Pod-pod dengan prioritas lebih rendah tersebut akan dipindahkan. Meskipun demikian, jawaban untuk pertanyaan sebelumnya haruslah "ya". Jika jawabannya adalah "tidak", maka Node tersebut tidak akan dipertimbangkan untuk pemindahan Pod.</div><p>Jika sebuah Pod yang tertunda memiliki afinitas antar-Pod terhadap satu atau lebih dari Pod-pod dengan prioritas lebih rendah pada Node tersebut, maka aturan afinitas antar-Pod tersebut tidak dapat terpenuhi tanpa hadirnya Pod-pod dengan prioritas lebih rendah tersebut. Pada kasus ini, Scheduler tidak melakukan pemindahan terhadap Pod-pod manapun pada Node tersebut. Sebagai gantinya, ia mencari Node lainnya. Scheduler mungkin mendapatkan Node yang cocok atau tidak. Tidak ada jaminan bahwa Pod yang tertunda tersebut dapat dijadwalkan.</p><p>Solusi yang direkomendasikan untuk masalah ini adalah dengan cara membuat afinitas antar-Pod hanya terhadap Pod-pod dengan prioritas yang sama atau lebih tinggi.</p><h4 id=pemindahan-pod-antar-node>Pemindahan Pod antar Node</h4><p>Misalnya sebuah Node N sedang dipertimbangkan untuk pemindahan Pod sehingga sebuah Pod P yang tertunda dapat dijadwalkan pada N. P mungkin menjadi layak untuk N hanya jika sebuah Pod pada Node lain dipindahkan. Berikut sebuah contoh:</p><ul><li>Pod P dipertimbangkan untuk Node N.</li><li>Pod Q sedang berjalan pada Node lain pada Zona yang sama dengan Node N.</li><li>Pod P memiliki anti-afinitas yang berlaku pada seluruh Zona terhadap Pod Q (<code>topologyKey: topology.kubernetes.io/zone</code>).</li><li>Tidak ada kasus anti-afinitas lain antara Pod P dengan Pod-pod lainnya pada Zona tersebut.</li><li>Untuk dapat menjadwalkan Pod P pada Node N, Pod Q dapat dipindahkan, tetapi
Scheduler tidak melakukan pemindahan Pod antar Node. Jadi, Pod P akan
dianggap tidak dapat dijadwalkan pada Node N.</li></ul><p>Jika Pod Q dihapus dari Node-nya, pelanggaran terhadap anti-afinitas Pod tersebut akan hilang, dan Pod P dapat dijadwalkan pada Node N.</p><p>Kita mungkin mempertimbangkan untuk menambahkan pemindahan Pod antar Node pada versi-versi yang akan datang jika ada permintaan yang cukup dari pengguna, dan kami menemukan algoritma dengan kinerja yang layak.</p><h2 id=memecahkan-masalah-pada-prioritas-dan-pemindahan-pod>Memecahkan masalah pada Prioritas dan Pemindahan Pod</h2><p>Prioritas dan Pemindahan Pod adalah sebuah fitur besar yang berpotensi dapat mengganggu penjadwalan Pod jika fitur ini memiliki kesalahan (<em>bug</em>).</p><h3 id=masalah-yang-berpotensi-diakibatkan-oleh-prioritas-dan-pemindahan-pod>Masalah yang berpotensi diakibatkan oleh Prioritas dan Pemindahan Pod</h3><p>Berikut adalah beberapa masalah yang dapat diakibatkan oleh kesalahan-kesalahan pada implementasi fitur ini. Daftar ini tidak lengkap.</p><h4 id=pod-pod-dipindahkan-secara-tidak-perlu>Pod-pod dipindahkan secara tidak perlu</h4><p>Pemindahan Pod menghapus Pod-pod yang sudah ada dari sebuah klaster yang sedang mengalami kekurangan sumber daya untuk menyediakan ruangan untuk Pod-pod tertunda yang memiliki prioritas yang lebih tinggi. Jika seorang pengguna memberikan prioritas-prioritas tinggi untuk Pod-pod tertentu dengan tidak semestinya (karena kesalahan), Pod-pod prioritas tinggi yang tidak disengaja tersebut dapat mengakibatkan pemindahan Pod-pod pada klaster tersebut. Seperti disebutkan di atas, prioritas Pod dispesifikasikan dengan menyetel kolom <code>priorityClassName</code> dari <code>podSpec</code>. Nilai <em>integer</em> dari prioritas tersebut kemudian dipetakan dan diisi pada kolom <code>priority</code> dari <code>podSpec</code>.</p><p>Untuk menyelesaikan masalah tersebut, <code>priorityClassName</code> dari Pod-pod tersebut harus diubah untuk menggunakan kelas dengan prioritas yang lebih rendah, atau dibiarkan kosong saja. Kolom <code>priorityClassName</code> yang kosong dipetakan menjadi nol secara bawaan.</p><p>Saat sebuah Pod dipindahkan, akan ada <em>Event</em> yang direkam untuk Pod yang dipindahkan tersebut. Pemindahan seharusnya hanya terjadi saat sebuah klaster tidak memiliki sumber daya yang cukup untuk sebuah Pod. Pada kasus seperti ini, pemindahan terjadi hanya saat prioritas dari Pod yang tertunda tersebut lebih tinggi daripada Pod-pod korban. Pemindahan tidak boleh terjadi saat tidak ada Pod yang tertunda (<em>preemptor</em>), atau saat Pod-pod yang tertunda memiliki prioritas yang sama atau lebih rendah dari korban-korbannya. Jika pemindahan terjadi pada skenario demikian, mohon daftarkan sebuah Issue.</p><h4 id=pod-pod-dipindahkan-tetapi-preemptor-tidak-dijadwalkan>Pod-pod dipindahkan, tetapi <em>preemptor</em> tidak dijadwalkan</h4><p>Saat Pod-pod dijadwalkan, mereka menerima periode penghentian secara sopan mereka, yang secara bawaan bernilai 30 detik, tetapi dapat bernilai apa pun sesuai dengan yang disetel pada PodSpec. Jika Pod-pod korban tidak berhenti sebelum periode ini, mereka akan dihentikan secara paksa. Saat semua korban telah pergi, Pod <em>preemptor</em> dapat dijadwalkan.</p><p>Saat Pod <em>preemptor</em> sedang menunggu korban-korban dipindahkan, sebuah Pod dengan prioritas lebih tinggi boleh dibuat jika muat pada Node yang sama. Pada kasus ini, Scheduler akan menjadwalkan Pod dengan prioritas lebih tinggi tersebut alih-alih menjadwalkan Pod <em>preemptor</em>.</p><p>Dalam ketidakhadiran Pod dengan prioritas lebih tinggi tersebut, kita mengharapkan Pod <em>preemptor</em> dijadwalkan setelah periode penghentian secara sopan korban-korbannya telah berakhir.</p><h4 id=pod-pod-dengan-prioritas-lebih-tinggi-dipindahkan-karena-pod-pod-dengan-prioritas-lebih-rendah>Pod-pod dengan prioritas lebih tinggi dipindahkan karena Pod-pod dengan prioritas lebih rendah</h4><p>Saat Scheduler mencoba mencari Node-node yang dapat menjalankan sebuah Pod yang tertunda, dan tidak ada Node yang ditemukan, ia akan mencoba untuk memindahkan Pod-pod dengan prioritas lebih rendah dari salah satu Node untuk menyediakan ruangan untuk Pod yang tertunda tersebut. Jika sebuah Node dengan Pod-pod dengan prioritas lebih rendah tidak layak untuk menjalankan Pod yang tertunda tersebut, Scheduler mungkin memilih Node lain dengan Pod yang memiliki prioritas lebih tinggi (dibandingkan dengan Pod-pod pada Node lain tadi) untuk dipindahkan. Korban-korban tersebut harus tetap memiliki prioritas yang lebih rendah dari Pod <em>preemptor</em>.</p><p>Saat ada beberapa Node yang tersedia untuk pemindahan, Scheduler mencoba untuk memilih Node dengan kumpulan Pod yang memiliki prioritas paling rendah. Namun, jika Pod-pod tersebut memiliki PodDisruptionBudget yang akan dilanggar apabila mereka dipindahkan, maka Scheduler akan memilih Node lain dengan Pod-pod yang memiliki prioritas lebih tinggi.</p><p>Saat ada beberapa Node tersedia untuk pemindahan dan tidak ada satupun skenario di atas yang berlaku, kita mengharapkan Scheduler memilih Node dengan prioritas paling rendah. Apabila hal tersebut tidak terjadi, hal ini mungkin menunjukkan bahwa terdapat kesalahan pada Scheduler.</p><h2 id=interaksi-interaksi-prioritas-pod-dan-qos>Interaksi-interaksi prioritas Pod dan QoS</h2><p>Prioritas Pod dan <a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/node/resource-qos.md>QoS</a> adalah dua fitur terpisah dengan interaksi yang sedikit dan tidak ada batasan bawaan terhadap penyetelan prioritas Pod berdasarkan kelas QoS-nya. Logika program pemindahan Scheduler tidak mempertimbangkan QoS saat memilih sasaran-sasaran pemindahan. Pemindahan mempertimbangkan prioritas Pod dan mencoba memilih kumpulan sasaran dengan prioritas terendah. Pod-pod dengan prioritas lebih tinggi dipertimbangkan untuk pemindahan hanya jika penghapusan Pod-pod dengan prioritas terendah tidak cukup untuk memungkinkan Scheduler untuk menjadwalkan Pod <em>preemptor</em>, atau jika Pod-pod dengan prioritas terendah tersebut dilindungi oleh <code>PodDisruptionBudget</code>.</p><p>Komponen satu-satunya yang mempertimbangkan baik QoS dan prioritas Pod adalah <a href=/docs/tasks/administer-cluster/out-of-resource/>pengusiran oleh Kubelet karena kehabisan sumber daya</a>.
Kubelet menggolongkan Pod-pod untuk pengusiran pertama-tama berdasarkan apakah penggunaan sumber daya mereka melebihi <code>requests</code> mereka atau tidak, kemudian berdasarkan Priority, dan kemudian berdasarkan penggunaan sumber daya yang terbatas tersebut relatif terhadap <code>requests</code> dari Pod-pod tersebut.
Lihat <a href=/docs/tasks/administer-cluster/out-of-resource/#mengusir-pod-pod-pengguna>Mengusir Pod-pod pengguna</a> untuk lebih detail. Pengusiran oleh Kubelet karena kehabisan sumber daya tidak mengusir Pod-pod yang memiliki penggunaan sumber daya yang tidak melebihi <code>requests</code> mereka. Jika sebuah Pod dengan prioritas lebih rendah tidak melebihi <code>requests</code>-nya, ia tidak akan diusir. Pod lain dengan prioritas lebih tinggi yang melebihi <code>requests</code>-nya boleh diusir.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-712cb3c03ff14a39e5a83a6d9b71d203>3.8 - Keamanan</h1></div><div class=td-content><h1 id=pg-04eeb110d75afc8acb2cf7a3db743985>3.8.1 - Ikhtisar Keamanan Cloud Native</h1><nav id=TableOfContents><ul><li><a href=#4c-pada-keamanan-cloud-native>4C pada Keamanan <em>Cloud Native</em></a></li><li><a href=#cloud>Cloud</a><ul><li><a href=#tabel-keamanan-penyedia-layanan-cloud>Tabel Keamanan Penyedia Layanan Cloud</a></li><li><a href=#tabel-panduan-umum-infrastruktur>Tabel Panduan Umum Infrastruktur</a></li></ul></li><li><a href=#cluster>Cluster</a><ul><li><a href=#komponen-komponen-dari-cluster>Komponen-komponen <em>dari</em> Cluster</a></li><li><a href=#komponen-komponen-di-dalam-cluster-aplikasimu>Komponen-komponen <em>di dalam</em> Cluster (aplikasimu)</a></li></ul></li><li><a href=#container>Container</a></li><li><a href=#code>Code</a><ul><li><a href=#tabel-panduan-umum-keamanan-kode>Tabel Panduan Umum Keamanan Kode</a></li></ul></li><li><a href=#otomasi-yang-kokoh>Otomasi yang Kokoh</a></li><li><a href=#selanjutnya>Selanjutnya</a></li></ul></nav><p>Keamanan Kubernetes (dan keamanan secara umum) adalah sebuah topik sangat luas yang memiliki banyak bagian yang sangat berkaitan satu sama lain. Pada masa sekarang ini di mana perangkat lunak <em>open source</em> telah diintegrasi ke dalam banyak sistem yang membantu berjalannya aplikasi web, ada beberapa konsep menyeluruh yang dapat membantu intuisimu untuk berpikir tentang konsep keamanan secara menyeluruh. Panduan ini akan mendefinisikan sebuah cara/model berpikir untuk beberapa konsep umum mengenai Keamanan <em>Cloud Native</em>. Cara berpikir ini sepenuhnya subjektif dan kamu sebaiknya hanya menggunakannya apabila ini membantumu berpikir tentang di mana harus mengamankan <em>stack</em> perangkat lunakmu.</p><h2 id=4c-pada-keamanan-cloud-native>4C pada Keamanan <em>Cloud Native</em></h2><p>Mari memulainya dengan sebuah diagram yang dapat membantumu mengerti bagaimana berpikir tentang keamanan dalam bentuk beberapa lapisan.<div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Pendekatan berlapis ini memperkuat pendekatan <a href=https://en.wikipedia.org/wiki/Defense_in_depth_(computing)><em>defense in depth</em></a> terhadap keamanan, yang secara luas dianggap sebagai praktik terbaik untuk mengamankan sistem-sistem perangkat lunak. 4C tersebut adalah Cloud, Cluster, Container, dan Code.</div></p><figure><img src=/images/docs/4c.png><figcaption><h4>The 4C's of Cloud Native Security</h4></figcaption></figure><p>Seperti yang dapat kamu lihat dari gambar di atas, setiap dari 4C tersebut bergantung pada keamanan dari kotak yang lebih besar di mana mereka berada. Hampir tidak mungkin untuk mengamankan sistem terhadap standar-standar keamanan yang buruk pada Cloud, Container, dan Code hanya dengan menangani keamanan pada lapisan kode. Akan tetapi, apabila semua area tersebut ditangani dengan baik, maka menambahkan keamanan ke dalam kode kamu akan memperkuat landasan yang sudah kuat. Area-area yang menjadi perhatian ini akan dideskripsikan lebih mendalam di bawah.</p><h2 id=cloud>Cloud</h2><p>Dalam banyak hal, Cloud (atau server-server <em>co-located</em>, atau pusat data/<em>data center</em> korporat) adalah <a href=https://en.wikipedia.org/wiki/Trusted_computing_base><em>trusted computing base</em> (basis komputasi yang dipercaya)</a> dari sebuah klaster Kubernetes. Jika komponen-komponen tersebut rentan secara keamanan (atau dikonfigurasi dengan cara yang rentan), maka sesungguhnya tidak ada cara untuk menjamin keamanan dari komponen-komponen apa pun yang dibangun di atas basis komputasi ini. Memberikan rekomendasi untuk keamanan cloud berada di luar lingkup panduan ini, karena setiap penyedia layanan cloud dan beban kerja pada dasarnya berbeda-beda. Berikut beberapa tautan menuju beberapa dokumentasi penyedia layanan cloud yang populer untuk keamanan maupun untuk memberikan panduan umum untuk mengamankan infrastruktur yang menjadi basis sebuah klaster Kubernetes.</p><h3 id=tabel-keamanan-penyedia-layanan-cloud>Tabel Keamanan Penyedia Layanan Cloud</h3><table><thead><tr><th>IaaS Provider</th><th>Link</th></tr></thead><tbody><tr><td>Alibaba Cloud</td><td><a href=https://www.alibabacloud.com/trust-center>https://www.alibabacloud.com/trust-center</a></td></tr><tr><td>Amazon Web Services</td><td><a href=https://aws.amazon.com/security/>https://aws.amazon.com/security/</a></td></tr><tr><td>Google Cloud Platform</td><td><a href=https://cloud.google.com/security/>https://cloud.google.com/security/</a></td></tr><tr><td>IBM Cloud</td><td><a href=https://www.ibm.com/cloud/security>https://www.ibm.com/cloud/security</a></td></tr><tr><td>Microsoft Azure</td><td><a href=https://docs.microsoft.com/en-us/azure/security/azure-security>https://docs.microsoft.com/en-us/azure/security/azure-security</a></td></tr><tr><td>Oracle Cloud Infrastructure</td><td><a href=https://www.oracle.com/security/>https://www.oracle.com/security/</a></td></tr><tr><td>VMWare VSphere</td><td><a href=https://www.vmware.com/security/hardening-guides.html>https://www.vmware.com/security/hardening-guides.html</a></td></tr></tbody></table><p>Jika kamu mengoperasikan perangkat keras kamu sendiri, atau penyedia layanan cloud yang berbeda, kamu perlu merujuk pada dokumentasi penyedia layanan cloud yang kamu pakai untuk praktik keamanan terbaik.</p><h3 id=tabel-panduan-umum-infrastruktur>Tabel Panduan Umum Infrastruktur</h3><table><thead><tr><th>Area yang Menjadi Perhatian untuk Infrastruktur Kubernetes</th><th>Rekomendasi</th></tr></thead><tbody><tr><td>Akses Jaringan terhadap API Server (Master-master)</td><td>Secara Ideal, semua akses terhadap Master-master Kubernetes tidak diizinkan secara publik pada internet, dan dikontrol oleh daftar kendali akses (<em>network ACL</em>) yang dibatasi untuk kumpulan alamat IP yang dibutuhkan untuk mengelola klaster.</td></tr><tr><td>Akses Jaringan terhadap Node-node (Server-server Worker)</td><td>Node-node harus dikonfigurasikan untuk <em>hanya</em> menerima koneksi-koneksi (melalui daftar kendali akses) dari Master-master pada porta-porta (<em>port</em>) yang telah ditentukan, dan menerima koneksi-koneksi dari Service-service Kubernetes dengan tipe NodePort dan LoadBalancer. Apabila memungkinkan, Node-node tersebut sebaiknya tidak diekspos pada internet publik sama sekali.</td></tr><tr><td>Akses Kubernetes terhadap API Penyedia Layanan Cloud</td><td>Setiap penyedia layanan cloud perlu memberikan kumpulan izin yang berbeda-beda untuk Master-master dan Node-node Kubernetes, sehingga rekomendasi ini sifatnya lebih umum. Praktik terbaiknya adalah untuk memberikan klaster akses terhadap penyedia layanan cloud yang mengikuti <a href=https://en.wikipedia.org/wiki/Principle_of_least_privilege><em>principle of least privilege</em> (prinsip hak istimewa paling sedikit)</a> untuk sumber daya yang klaster tersebut perlukan untuk dikelola. Sebuah contoh untuk Kops di AWS dapat ditemukan di sini: <a href=https://github.com/kubernetes/kops/blob/master/docs/iam_roles.md#iam-roles>https://github.com/kubernetes/kops/blob/master/docs/iam_roles.md#iam-roles</a></td></tr><tr><td>Akses terhadap etcd</td><td>Akses terhadap etcd (tempat penyimpanan data Kubernetes) harus dibatasi hanya untuk Master-master saja. Bergantung pada konfigurasimu, kamu sebaiknya juga mengusahakan koneksi etcd menggunakan TLS. Informasi lebih lanjut dapat ditemukan di sini: <a href=https://github.com/etcd-io/etcd/tree/master/Documentation#security>https://github.com/etcd-io/etcd/tree/master/Documentation#security</a></td></tr><tr><td>Enkripsi etcd</td><td>Di mana pun kita dapat melakukannya, mengenkripsi semua data saat diam (<em>at rest</em>) pada semua <em>drive</em>, dan sejak etcd menyimpan keadaan seluruh klaster (termasuk Secret-secret), <em>disk</em>-nya sebaiknya kita enkripsi saat diam.</td></tr></tbody></table><h2 id=cluster>Cluster</h2><p>Bagian ini akan memberikan tautan-tautan untuk mengamankan beban-beban kerja di dalam Kubernetes. Ada dua area yang menjadi perhatian untuk mengamankan Kubernetes:</p><ul><li>Mengamankan komponen-komponen yang dapat dikonfigurasi yang membentuk klaster</li><li>Mengamankan komponen-komponen yang dijalankan di dalam klaster</li></ul><h3 id=komponen-komponen-dari-cluster>Komponen-komponen <em>dari</em> Cluster</h3><p>Jika kamu ingin menjaga klastermu dari akses yang tidak disengaja atau yang bersifat serangan, dan mengadopsi praktik yang baik, baca dan ikutilah nasihat untuk <a href=/docs/tasks/administer-cluster/securing-a-cluster/>mengamankan klastermu</a>.</p><h3 id=komponen-komponen-di-dalam-cluster-aplikasimu>Komponen-komponen <em>di dalam</em> Cluster (aplikasimu)</h3><p>Bergantung pada permukaan yang dapat diserang dari aplikasimu, kamu mungkin ingin berfokus pada aspek keamanan yang spesifik. Sebagai contoh, jika kamu menjalankan sebuah layanan (kita sebut Layanan A) yang kritikal di dalam rantai sumber daya lainnya dan sebuah beban kerja terpisah (kita sebut Layanan B) yang rentan terhadap serangan <em>resource exhaustion</em>, dengan tidak menyetel limit untuk sumber daya maka kamu juga menaruh risiko terhadap Layanan A. Berikut tabel tautan-tautan menuju hal-hal yang perlu diperhatikan untuk mengamankan beban-beban kerja yang berjalan di dalam Kubernetes.</p><table><thead><tr><th>Area yang Menjadi Perhatian untuk Keamanan Beban Kerja</th><th>Rekomendasi</th></tr></thead><tbody><tr><td>Otorisasi RBAC (Akses terhadap API Kubernetes)</td><td><a href=https://kubernetes.io/docs/reference/access-authn-authz/rbac/>https://kubernetes.io/docs/reference/access-authn-authz/rbac/</a></td></tr><tr><td>Autentikasi</td><td><a href=https://kubernetes.io/docs/reference/access-authn-authz/controlling-access/>https://kubernetes.io/docs/reference/access-authn-authz/controlling-access/</a></td></tr><tr><td>Manajemen Secret Aplikasi (dan mengenkripsi mereka di etcd)</td><td><a href=https://kubernetes.io/docs/concepts/configuration/secret/>https://kubernetes.io/docs/concepts/configuration/secret/</a><br><a href=https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/>https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/</a></td></tr><tr><td>Pod Security Policy</td><td><a href=https://kubernetes.io/docs/concepts/policy/pod-security-policy/>https://kubernetes.io/docs/concepts/policy/pod-security-policy/</a></td></tr><tr><td>Quality of Service (dan manajemen sumber daya klaster)</td><td><a href=https://kubernetes.io/docs/tasks/configure-pod-container/quality-service-pod/>https://kubernetes.io/docs/tasks/configure-pod-container/quality-service-pod/</a></td></tr><tr><td>Network Policy</td><td><a href=https://kubernetes.io/docs/concepts/services-networking/network-policies/>https://kubernetes.io/docs/concepts/services-networking/network-policies/</a></td></tr><tr><td>TLS untuk Ingress Kubernetes</td><td><a href=https://kubernetes.io/docs/concepts/services-networking/ingress/#tls>https://kubernetes.io/docs/concepts/services-networking/ingress/#tls</a></td></tr></tbody></table><h2 id=container>Container</h2><p>Untuk menjalankan perangkat lunak di dalam Kubernetes, perangkat lunak tersebut haruslah berada di dalam sebuah Container. Karenanya, ada beberapa pertimbangan keamanan yang harus diperhitungkan untuk mengambil manfaat dari fitur-fitur keamanan beban kerja Kubernetes. Keamanan Container berada di luar lingkup panduan ini, tetapi berikut disediakan sebuah tabel rekomendasi-rekomendasi umum dan tautan menuju eksplorasi lebih dalam pada topik ini.</p><table><thead><tr><th>Area yang Menjadi Perhatian untuk Container</th><th>Rekomendasi</th></tr></thead><tbody><tr><td>Pemindaian Kerentanan Container dan Dependensi Keamanan OS</td><td>Sebagai bagian dari tahap membangun sebuah <em>image</em> atau dilakukan secara teratur, kamu sebaiknya memindai Container-container terhadap kerentanan yang telah diketahui dengan peralatan seperti <a href=https://github.com/coreos/clair/>CoreOS's Clair</a></td></tr><tr><td>Penandatanganan <em>Image</em> dan Penegakan Aturan</td><td>Dua dari Proyek-proyek CNCF (TUF dan Notary) adalah alat-alat yang berguna untuk menandatangani <em>image</em> Container dan memelihara sistem kepercayaan untuk konten dari Container-container kamu. Jika kamu menggunakan Docker, ia dibangun di dalam Docker Engine sebagai <a href=https://docs.docker.com/engine/security/trust/content_trust/>Docker Content Trust</a>. Pada bagian penegakan aturan, proyek <a href=https://github.com/IBM/portieris>Portieris dari IBM</a> adalah sebuah alat yang berjalan sebagai sebuah Dynamic Admission Controller Kubernetes untuk memastikan bahwa <em>image-image</em> ditandatangani dengan tepat oleh Notary sebelum dimasukkan ke dalam Cluster.</td></tr><tr><td>Larang pengguna-pengguna dengan hak istimewa</td><td>Saat membangun Container-container, rujuklah dokumentasimu untuk cara membuat pengguna-pengguna di dalam Container-container yang memiliki hak istimewa sistem operasi yang paling sedikit yang dibutuhkan untuk mencapai tujuan Container tersebut.</td></tr></tbody></table><h2 id=code>Code</h2><p>Akhirnya pada lapisan kode aplikasi, hal ini adalah satu dari permukaan-permukaan serangan utama yang paling dapat kamu kontrol. Hal ini juga berada di luar lingkup Kubernetes, tetapi berikut beberapa rekomendasi:</p><h3 id=tabel-panduan-umum-keamanan-kode>Tabel Panduan Umum Keamanan Kode</h3><table><thead><tr><th>Area yang Menjadi Perhatian untuk Kode</th><th>Rekomendasi</th></tr></thead><tbody><tr><td>Akses hanya melalui TLS</td><td>Jika kode kamu perlu berkomunikasi via TCP, idealnya ia melakukan <em>TLS handshake</em> dengan klien sebelumnya. Dengan pengecualian pada sedikit kasus, kelakuan secara bawaan sebaiknya adalah mengenkripsi semuanya (data) pada saat transit (<em>encryption at transit</em>). Lebih jauh lagi, bahkan "di belakang dinding api" di dalam VPC kita sebaiknya kita melakukan enkripsi lalu lintas jaringan di antara layanan-layanan. Hal ini dapat dilakukan melalui sebuah proses yang dikenal dengan <em>mutual TLS</em> atau <a href=https://en.wikipedia.org/wiki/Mutual_authentication>mTLS</a> yang melakukan verifikasi dua sisi terhadap komunikasi antara layanan-layanan yang memiliki sertifikat digital. Ada banyak alat-alat yang dapat digunakan untuk mencapai hal ini, seperti <a href=https://linkerd.io/>Linkerd</a> dan <a href=https://istio.io/>Istio</a>.</td></tr><tr><td>Membatasi cakupan porta komunikasi</td><td>Rekomendasi ini sepertinya cukup jelas, tetapi di mana pun dapat dilakukan sebaiknya kamu hanya membuka porta-porta pada layananmu yang benar-benar diperlukan untuk komunikasi sistem atau pengambilan metrik.</td></tr><tr><td>Keamanan Dependensi Pihak ke-3</td><td>Karena aplikasi-aplikasi kita cenderung memiliki dependensi-dependensi di luar kode kita sendiri, merupakan praktik yang baik untuk memastikan hasil pemindaian rutin dependensi-dependensi kode kita masih aman tanpa CVE yang masih ada terhadap mereka. Setiap bahasa pemrograman memiliki alat untuk melakukan pemindaian ini secara otomatis.</td></tr><tr><td>Analisis Statis Kode</td><td>Kebanyakan bahasa pemrograman menyediakan cara agar potongan kode dapat dianalisis terhadap praktik-praktik penulisan kode yang berpotensi tidak aman. Kapan pun dapat dilakukan, kamu sebaiknya melakukan pemeriksaan menggunakan peralatan otomatis yang dapat memindai kode terhadap kesalahan keamanan yang umum terjadi. Beberapa dari peralatan tersebut dapat ditemukan di sini: <a href=https://www.owasp.org/index.php/Source_Code_Analysis_Tools>https://www.owasp.org/index.php/Source_Code_Analysis_Tools</a></td></tr><tr><td>Serangan Pengamatan (<em>probing</em>) Dinamis</td><td>Ada sedikit peralatan otomatis yang dapat dijalankan terhadap layanan/aplikasi kamu untuk mencoba beberapa serangan yang terkenal dan umumnya memengaruhi layanan-layanan. Serangan-serangan tersebut termasuk <em>SQL injection</em>, CSRF, dan XSS. Satu dari alat analisis dinamis yang terkenal adalah OWASP Zed Attack Proxy <a href=https://www.owasp.org/index.php/OWASP_Zed_Attack_Proxy_Project>https://www.owasp.org/index.php/OWASP_Zed_Attack_Proxy_Project</a></td></tr></tbody></table><h2 id=otomasi-yang-kokoh>Otomasi yang Kokoh</h2><p>Kebanyakan dari saran yang disebut di atas dapat diotomasi di dalam <em>delivery pipeline</em> kode kamu sebagai bagian dari rangkaian pemeriksaan keamanan. Untuk mempelajari lebih lanjut tentang pendekatan "<em>Continuous Hacking</em>" terhadap <em>delivery</em> perangkat lunak, <a href=https://thenewstack.io/beyond-ci-cd-how-continuous-hacking-of-docker-containers-and-pipeline-driven-security-keeps-ygrene-secure/>artikel ini</a> menyediakan lebih banyak detail.</p><h2 id=selanjutnya>Selanjutnya</h2><ul><li>Pelajari tentang <a href=/id/docs/concepts/services-networking/network-policies/>Network Policy untuk Pod</a></li><li>Pelajari tentang <a href=/docs/tasks/administer-cluster/securing-a-cluster/>mengamankan klaster kamu</a></li><li>Pelajari tentang <a href=/docs/reference/access-authn-authz/controlling-access/>kontrol akses API</a></li><li>Pelajari tentang <a href=/id/docs/tasks/tls/managing-tls-in-a-cluster/>enkripsi data saat transit</a> for the control plane</li><li>Pelajari tentang <a href=/docs/tasks/administer-cluster/encrypt-data/>enkripsi data saat diam</a></li><li>Pelajari tentang <a href=/id/docs/concepts/configuration/secret/>Secret (data sensitif) pada Kubernetes</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-c21d05f31057c5bcd2ebdd01f4e62a0e>3.9 - Penjadwalan dan Pengusiran</h1></div><div class=td-content><h1 id=pg-961126cd43559012893979e568396a49>3.9.1 - Bin Packing Sumber Daya untuk Sumber Daya Tambahan</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes 1.16 [alpha]</code></div><p><em>Kube-scheduler</em> dapat dikonfigurasikan untuk mengaktifkan pembungkusan rapat
(<em>bin packing</em>) sumber daya bersama dengan sumber daya tambahan melalui fungsi prioritas
<code>RequestedToCapacityRatioResourceAllocation</code>. Fungsi-fungsi prioritas dapat digunakan
untuk menyempurnakan <em>kube-scheduler</em> sesuai dengan kebutuhan.</p><h2 id=mengaktifkan-bin-packing-menggunakan-requestedtocapacityratioresourceallocation>Mengaktifkan <em>Bin Packing</em> menggunakan RequestedToCapacityRatioResourceAllocation</h2><p>Sebelum Kubernetes 1.15, <em>kube-scheduler</em> digunakan untuk memungkinkan mencetak
skor berdasarkan rasio permintaan terhadap kapasitas sumber daya utama seperti
CPU dan Memori. Kubernetes 1.16 menambahkan parameter baru ke fungsi prioritas
yang memungkinkan pengguna untuk menentukan sumber daya beserta dengan bobot
untuk setiap sumber daya untuk memberi nilai dari Node berdasarkan rasio
permintaan terhadap kapasitas. Hal ini memungkinkan pengguna untuk <em>bin pack</em>
sumber daya tambahan dengan menggunakan parameter yang sesuai untuk meningkatkan
pemanfaatan sumber daya yang langka dalam klaster yang besar. Perilaku
<code>RequestedToCapacityRatioResourceAllocation</code> dari fungsi prioritas dapat
dikontrol melalui pilihan konfigurasi yang disebut <code>RequestToCapacityRatioArguments</code>.
Argumen ini terdiri dari dua parameter yaitu <code>shape</code> dan <code>resources</code>. Shape
memungkinkan pengguna untuk menyempurnakan fungsi menjadi yang paling tidak
diminta atau paling banyak diminta berdasarkan nilai <code>utilization</code> dan <code>score</code>.
Sumber daya terdiri dari <code>name</code> yang menentukan sumber daya mana yang dipertimbangkan
selama penilaian dan <code>weight</code> yang menentukan bobot masing-masing sumber daya.</p><p>Di bawah ini adalah contoh konfigurasi yang menetapkan <code>requestedToCapacityRatioArguments</code>
pada perilaku <em>bin packing</em> untuk sumber daya tambahan <code>intel.com/foo</code> dan <code>intel.com/bar</code></p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;kind&#34;</span> : <span style=color:#b44>&#34;Policy&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span> : <span style=color:#b44>&#34;v1&#34;</span>,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span>...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;priorities&#34;</span> : [
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>       <span>...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      {
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;RequestedToCapacityRatioPriority&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;weight&#34;</span>: <span style=color:#666>2</span>,
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;argument&#34;</span>: {
</span></span><span style=display:flex><span>          <span style=color:green;font-weight:700>&#34;requestedToCapacityRatioArguments&#34;</span>: {
</span></span><span style=display:flex><span>            <span style=color:green;font-weight:700>&#34;shape&#34;</span>: [
</span></span><span style=display:flex><span>              {<span style=color:green;font-weight:700>&#34;utilization&#34;</span>: <span style=color:#666>0</span>, <span style=color:green;font-weight:700>&#34;score&#34;</span>: <span style=color:#666>0</span>},
</span></span><span style=display:flex><span>              {<span style=color:green;font-weight:700>&#34;utilization&#34;</span>: <span style=color:#666>100</span>, <span style=color:green;font-weight:700>&#34;score&#34;</span>: <span style=color:#666>10</span>}
</span></span><span style=display:flex><span>            ],
</span></span><span style=display:flex><span>            <span style=color:green;font-weight:700>&#34;resources&#34;</span>: [
</span></span><span style=display:flex><span>              {<span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;intel.com/foo&#34;</span>, <span style=color:green;font-weight:700>&#34;weight&#34;</span>: <span style=color:#666>3</span>},
</span></span><span style=display:flex><span>              {<span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;intel.com/bar&#34;</span>, <span style=color:green;font-weight:700>&#34;weight&#34;</span>: <span style=color:#666>5</span>}
</span></span><span style=display:flex><span>            ]
</span></span><span style=display:flex><span>          }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    ],
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div><p><strong>Fitur ini dinonaktifkan secara <em>default</em></strong></p><h3 id=tuning-requestedtocapacityratioresourceallocation-priority-function>Tuning RequestedToCapacityRatioResourceAllocation Priority Function</h3><p><code>shape</code> digunakan untuk menentukan perilaku dari fungsi <code>RequestedToCapacityRatioPriority</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb> </span>{<span style=color:green;font-weight:700>&#34;utilization&#34;: 0, &#34;score&#34;: </span><span style=color:#666>0</span>},<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span>{<span style=color:green;font-weight:700>&#34;utilization&#34;: 100, &#34;score&#34;: </span><span style=color:#666>10</span>}<span style=color:#bbb>
</span></span></span></code></pre></div><p>Argumen di atas memberikan Node nilai 0 jika utilisasi 0% dan 10 untuk utilisasi 100%,
yang kemudian mengaktfikan perilaku <em>bin packing</em>. Untuk mengaktifkan dari paling
yang tidak diminta, nilainya harus dibalik sebagai berikut.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb> </span>{<span style=color:green;font-weight:700>&#34;utilization&#34;: 0, &#34;score&#34;: </span><span style=color:#666>100</span>},<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span>{<span style=color:green;font-weight:700>&#34;utilization&#34;: 100, &#34;score&#34;: </span><span style=color:#666>0</span>}<span style=color:#bbb>
</span></span></span></code></pre></div><p><code>resources</code> adalah parameter opsional yang secara <em>default</em> diatur ke:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>&#34;resources&#34;: </span>[<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span>{<span style=color:green;font-weight:700>&#34;name&#34;: &#34;CPU&#34;, &#34;weight&#34;: </span><span style=color:#666>1</span>},<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span>{<span style=color:green;font-weight:700>&#34;name&#34;: &#34;Memory&#34;, &#34;weight&#34;: </span><span style=color:#666>1</span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>]<span style=color:#bbb>
</span></span></span></code></pre></div><p>Ini dapat digunakan untuk menambahkan sumber daya tambahan sebagai berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>&#34;resources&#34;: </span>[<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span>{<span style=color:green;font-weight:700>&#34;name&#34;: &#34;intel.com/foo&#34;, &#34;weight&#34;: </span><span style=color:#666>5</span>},<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span>{<span style=color:green;font-weight:700>&#34;name&#34;: &#34;CPU&#34;, &#34;weight&#34;: </span><span style=color:#666>3</span>},<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span>{<span style=color:green;font-weight:700>&#34;name&#34;: &#34;Memory&#34;, &#34;weight&#34;: </span><span style=color:#666>1</span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>]<span style=color:#bbb>
</span></span></span></code></pre></div><p>Parameter <code>weight</code> adalah opsional dan diatur ke 1 jika tidak ditentukan.
Selain itu, <code>weight</code> tidak dapat diatur ke nilai negatif.</p><h3 id=bagaimana-fungsi-prioritas-requestedtocapacityratioresourceallocation-menilai-node>Bagaimana Fungsi Prioritas RequestedToCapacityRatioResourceAllocation Menilai Node</h3><p>Bagian ini ditujukan bagi kamu yang ingin memahami secara detail internal
dari fitur ini.
Di bawah ini adalah contoh bagaimana nilai dari Node dihitung untuk satu kumpulan
nilai yang diberikan.</p><pre tabindex=0><code>Sumber daya yang diminta

intel.com/foo : 2
Memory: 256MB
CPU: 2

Bobot dari sumber daya

intel.com/foo : 5
Memory: 1
CPU: 3

FunctionShapePoint {{0, 0}, {100, 10}}

Spesifikasi dari Node 1

Tersedia:

intel.com/foo : 4
Memory : 1 GB
CPU: 8

Digunakan:

intel.com/foo: 1
Memory: 256MB
CPU: 1


Nilai Node:

intel.com/foo  = resourceScoringFunction((2+1),4)
               =  (100 - ((4-3)*100/4)
               =  (100 - 25)
               =  75
               =  rawScoringFunction(75)
               = 7

Memory         = resourceScoringFunction((256+256),1024)
               = (100 -((1024-512)*100/1024))
               = 50
               = rawScoringFunction(50)
               = 5

CPU            = resourceScoringFunction((2+1),8)
               = (100 -((8-3)*100/8))
               = 37.5
               = rawScoringFunction(37.5)
               = 3

NodeScore   =  (7 * 5) + (5 * 1) + (3 * 3) / (5 + 1 + 3)
            =  5


Spesifikasi dari Node 2

Tersedia:

intel.com/foo: 8
Memory: 1GB
CPU: 8

Digunakan:

intel.com/foo: 2
Memory: 512MB
CPU: 6


Nilai Node:

intel.com/foo  = resourceScoringFunction((2+2),8)
               =  (100 - ((8-4)*100/8)
               =  (100 - 25)
               =  50
               =  rawScoringFunction(50)
               = 5

Memory         = resourceScoringFunction((256+512),1024)
               = (100 -((1024-768)*100/1024))
               = 75
               = rawScoringFunction(75)
               = 7

CPU            = resourceScoringFunction((2+6),8)
               = (100 -((8-8)*100/8))
               = 100
               = rawScoringFunction(100)
               = 10

NodeScore   =  (5 * 5) + (7 * 1) + (10 * 3) / (5 + 1 + 3)
            =  7
</code></pre></div><div class=td-content style=page-break-before:always><h1 id=pg-da22fe2278df236f71efbe672f392677>3.9.2 - Overhead Pod</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.16 [alpha]</code></div><p>Ketika kamu menjalankan Pod pada Node, Pod itu akan mengambil sejumlah sumber daya sistem. Sumber daya ini adalah tambahan terhadap sumber daya yang diperlukan untuk menjalankan Container di dalam Pod (<em>overhead</em>).
<em>Pod Overhead</em> adalah fitur yang berfungsi untuk menghitung sumber daya digunakan oleh infrastruktur Pod selain permintaan dan limit Container.</p><h2 id=overhead-pod>Overhead Pod</h2><p>Pada Kubernetes, Overhead Pod ditentukan pada
<a href=/docs/reference/access-authn-authz/extensible-admission-controllers/#what-are-admission-webhooks>saat admisi</a> sesuai dengan Overhead yang ditentukan di dalam
<a href=/id/docs/concepts/containers/runtime-class/>RuntimeClass</a> milik Pod.</p><p>Ketika Overhead Pod diaktifkan, Overhead akan dipertimbangkan sebagai tambahan terhadap jumlah permintaan sumber daya Container
saat menjadwalkan Pod. Begitu pula Kubelet, yang akan memasukkan Overhead Pod saat menentukan ukuran
cgroup milik Pod, dan saat melakukan pemeringkatan pengusiran (<em>eviction</em>) Pod.</p><h3 id=yang-perlu-disiapkan>Yang perlu disiapkan</h3><p>Kamu harus memastikan bahwa
<a href=/docs/reference/command-line-tools-reference/feature-gates/><em>feature gate</em></a> <code>PodOverhead</code> telah diaktifkan (secara bawaan dinonaktifkan)
di seluruh klaster kamu, yang berarti:</p><ul><li>Pada <a class=glossary-tooltip title='Komponen control plane yang bertugas mengamati Pod baru yang belum ditempatkan di node manapun dan kemudian memilihkan node di mana Pod baru tersebut akan dijalankan.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-scheduler/ target=_blank aria-label=kube-scheduler>kube-scheduler</a></li><li>Pada <a class=glossary-tooltip title='Komponen control plane yang mengekspos API Kubernetes. Merupakan front-end dari control plane Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-apiserver/ target=_blank aria-label=kube-apiserver>kube-apiserver</a></li><li>Pada <a class=glossary-tooltip title='Agen yang dijalankan pada setiap node di klaster yang bertugas untuk memastikan kontainer dijalankan di dalam Pod.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a> di setiap Node</li><li>Pada peladen API khusus (<em>custom</em>) apa pun yang menggunakan <em>feature gate</em></li></ul><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Pengguna yang dapat mengubah sumber daya RuntimeClass dapat memengaruhi kinerja beban kerja klaster secara keseluruhan. Kamu dapat membatasi akses terhadap kemampuan ini dengan kontrol akses Kubernetes.
Lihat <a href=/docs/reference/access-authn-authz/authorization/>Ringkasan Otorisasi</a> untuk lebih lanjut.</div><h2 id=selanjutnya>Selanjutnya</h2><ul><li><a href=/id/docs/concepts/containers/runtime-class/>RuntimeClass</a></li><li><a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/20190226-pod-overhead.md>Desain PodOverhead</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-21169f516071aea5d16734a4c27789a5>3.9.3 - Menetapkan Pod ke Node</h1><p>Kamu dapat memaksa sebuah <a href=/id/docs/concepts/workloads/pods/pod/>pod</a> untuk hanya dapat berjalan pada <a href=/id/docs/concepts/architecture/nodes/>node</a> tertentu atau mengajukannya agar berjalan pada node tertentu. Ada beberapa cara untuk melakukan hal tersebut. Semua cara yang direkomendasikan adalah dengan menggunakan <a href=/id/docs/concepts/overview/working-with-objects/labels/><em>selector</em> label</a> untuk menetapkan pilihan yang kamu inginkan. Pada umumnya, pembatasan ini tidak dibutuhkan, sebagaimana <em>scheduler</em> akan melakukan penempatan yang proporsional dengan otomatis (seperti contohnya menyebar pod di node-node, tidak menempatkan pod pada node dengan sumber daya yang tidak memadai, dst.) tetapi ada keadaan-keadaan tertentu yang membuat kamu memiliki kendali lebih terhadap node yang menjadi tempat pod dijalankan, contohnya untuk memastikan pod dijalankan pada mesin yang telah terpasang SSD, atau untuk menempatkan pod-pod dari dua servis yang berbeda yang sering berkomunikasi bersamaan ke dalam zona ketersediaan yang sama.</p><p>Kamu dapat menemukan semua berkas untuk contoh-contoh berikut pada <a href=https://github.com/kubernetes/website/tree/main/content/en/docs/concepts/configuration/>dokumentasi yang kami sediakan di sini</a></p><h2 id=nodeselector>nodeSelector</h2><p>Penggunaan <code>nodeSelector</code> adalah cara pembatasan pemilihan node paling sederhana yang direkomendasikan. <code>nodeSelector</code> adalah sebuah <em>field</em> pada PodSpec. <code>nodeSelector</code> memerinci sebuah map berisi pasangan kunci-nilai. Agar pod dapat dijalankan pada sebuah node yang memenuhi syarat, node tersebut harus memiliki masing-masing dari pasangan kunci-nilai yang dinyatakan sebagai label (namun node juga dapat memiliki label tambahan diluar itu). Penggunaan paling umum adalah satu pasang kunci-nilai.</p><p>Mari kita telusuri contoh dari penggunaan <code>nodeSelector</code>.</p><h3 id=langkah-nol-prasyarat>Langkah Nol: Prasyarat</h3><p>Contoh ini mengasumsikan bahwa kamu memiliki pemahaman dasar tentang pod Kubernetes dan kamu telah <a href=https://github.com/kubernetes/kubernetes#documentation>membuat klaster Kubernetes</a>.</p><h3 id=langkah-satu-menyematkan-label-pada-node>Langkah Satu: Menyematkan label pada node</h3><p>Jalankan <code>kubectl get nodes</code> untuk mendapatkan nama dari node-node yang ada dalam klaster kamu. Temukan node yang akan kamu tambahkan label, kemudian jalankan perintah <code>kubectl label nodes &lt;node-name> &lt;label-key>=&lt;label-value></code> untuk menambahkan label pada node yang telah kamu pilih. Sebagai contoh, jika nama node yang saya pilih adalah 'kubernetes-foo-node-1.c.a-robinson.internal' dan label yang ingin saya tambahkan adalah 'disktype=ssd', maka saya dapat menjalankan <code>kubectl label nodes kubernetes-foo-node-1.c.a-robinson.internal disktype=ssd</code>.</p><p>Jika terjadi kegagalan dengan kesalahan perintah yang tidak <em>valid</em> ("<em>invalid command</em>"), kemungkinan besar kamu menggunakan kubectl dengan versi lebih lama yang tidak memiliki perintah <code>label</code>. Dalam hal ini, lihat [versi sebelumnya] (<a href=https://github.com/kubernetes/kubernetes/blob/a053dbc313572ed60d89dae9821ecab8bfd676dc/examples/node-selection/README.md>https://github.com/kubernetes/kubernetes/blob/a053dbc313572ed60d89dae9821ecab8bfd676dc/examples/node-selection/README.md</a>) dari petunjuk ini untuk instruksi tentang cara menetapkan label pada node.</p><p>Kamu dapat memastikan perintah telah berhasil dengan menjalankan ulang perintah <code>kubectl get nodes --show-labels</code> and memeriksa bahwa node yang dipilih sekarang sudah memiliki label yang ditambahkan. Kamu juga dapat menggunakan <code>kubectl describe node "nodename"</code> untuk melihat daftar lengkap label yang dimiliki sebuah node.</p><h3 id=langkah-dua-menambahkan-sebuah-nodeselector-ke-konfigurasi-pod-kamu>Langkah Dua: Menambahkan sebuah nodeSelector ke konfigurasi pod kamu</h3><p>Ambil berkas konfigurasi pod manapun yang akan kamu jalankan, dan tambahkan sebuah bagian <code>nodeSelector</code> pada berkas tersebut, seperti berikut. Sebagai contoh, jika berikut ini adalah konfigurasi pod saya:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb> </span>test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span></code></pre></div><p>Kemudian tambahkan sebuah <code>nodeSelector</code> seperti berikut:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/pods/pod-nginx.yaml download=pods/pod-nginx.yaml><code>pods/pod-nginx.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-pod-nginx-yaml")' title="Copy pods/pod-nginx.yaml to clipboard"></img></div><div class=includecode id=pods-pod-nginx-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb> </span>test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>IfNotPresent<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodeSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>disktype</span>:<span style=color:#bbb> </span>ssd<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Ketika kamu menjalankan perintah <code>kubectl apply -f https://k8s.io/examples/pods/pod-nginx.yaml</code>, pod tersebut akan dijadwalkan pada node yang memiliki label yang dirinci. Kamu dapat memastikan penambahan nodeSelector berhasil dengan menjalankan <code>kubectl get pods -o wide</code> dan melihat "NODE" tempat Pod ditugaskan.</p><h2 id=selingan-label-node-built-in>Selingan: label node <em>built-in</em></h2><p>Sebagai tambahan dari label yang kamu <a href=#step-one-attach-label-to-the-node>sematkan</a>, node sudah terisi dengan satu set label standar. Pada Kubernetes v1.4 label tersebut adalah</p><ul><li><code>kubernetes.io/hostname</code></li><li><code>failure-domain.beta.kubernetes.io/zone</code></li><li><code>failure-domain.beta.kubernetes.io/region</code></li><li><code>beta.kubernetes.io/instance-type</code></li><li><code>kubernetes.io/os</code></li><li><code>kubernetes.io/arch</code></li></ul><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Nilai dari label-label tersebut spesifik untuk setiap penyedia layanan <em>cloud</em> dan tidak dijamin reliabilitasnya.
Contohnya, nilai dari <code>kubernetes.io/hostname</code> bisa saja sama dengan nama node pada beberapa lingkungan dan berbeda pada lingkungan lain.</div><h2 id=isolasi-pembatasan-node>Isolasi/pembatasan Node</h2><p>Menambahkan label pada objek node memungkinkan penargetan pod pada node atau grup node yang spesifik. Penambahan label ini dapat digunakan untuk memastikan pod yang spesifik hanya berjalan pada node dengan isolasi, keamanan, atau pengaturan tertentu. Saat menggunakan label untuk tujuan tersebut, memilih kunci label yang tidak bisa dimodifikasi oleh proses kubelet pada node sangat direkomendasikan. Hal ini mencegah node yang telah diubah untuk menggunakan kredensial kubelet-nya untuk mengatur label-label pada objek nodenya sediri, dan mempengaruhi scheduler untuk menjadwalkan <em>workload</em> ke node yang telah diubah tersebut.</p><p><em>Plugin</em> penerimaan <code>NodeRestriction</code> mencegah kubeletes untuk megatur atau mengubah label dengan awalan <code>node-restriction.kubernetes.io/</code>.
Untuk memanfaatkan awalan label untuk isolasi node:</p><ol><li><p>Pastikan kamu menggunakan <a href=/docs/reference/access-authn-authz/node/><em>authorizer</em> node</a> dan mengaktifkan [<em>plugin admission NodeRestriction</em>(/docs/reference/access-authn-authz/admission-controllers/#noderestriction).</p></li><li><p>Tambah label dengan awalan <code>node-restriction.kubernetes.io/</code> ke objek node kamu, dan gunakan label tersebut pada node <em>selector</em> kamu. Contohnya, <code>example.com.node-restriction.kubernetes.io/fips=true</code> or <code>example.com.node-restriction.kubernetes.io/pci-dss=true</code>.</p></li></ol><h2 id=afinitas-dan-anti-afinitas>Afinitas dan anti-afinitas</h2><p><code>_Field_ nodeSelector</code> menyediakan cara yang sangat sederhana untuk membatasi pod ke node dengan label-label tertentu. Fitur afinitas/anti-afinitas saat ini bersifat beta dan memperluas tipe pembatasan yang dapat kamu nyatakan. Peningkatan kunci dari fitur ini adalah</p><ol><li>Bahasa yang lebih ekspresif (tidak hanya "AND of exact match")</li><li>Kamu dapat memberikan indikasi bahwa aturan yang dinyatakan bersifat rendah/preferensi dibanding dengan persyaratan mutlak sehingga jika scheduler tidak dapat memenuhinya, pod tetap akan dijadwalkan</li><li>Kamu dapat membatasi dengan label pada pod-pod lain yang berjalan pada node (atau domain <em>topological</em> lain), daripada dengan label pada node itu sendiri, yang memungkinkan pengaturan tentang pod yang dapat dan tidak dapat dilokasikan bersama.</li></ol><p>Fitur afinitas terdiri dari dua tipe afinitas yaitu "node afinitas" dan "inter-pod afinitas/anti-afinitas"
Node afinitas adalah seperti <code>nodeSelector</code> yang telah ada (tetapi dengam dua kelebihan pertama yang terdaftar di atas), sementara inter-pod afinitas/anti-afinitas membatasi pada label pod daripada label node, seperti yang dijelaskan pada item ketiga pada daftar di atas, sebagai tambahan dari item pertama dan kedua.</p><p><em>Field</em> <code>nodeSelector</code> tetap berjalan seperti biasa, namun pada akhirnya akan ditinggalkan karena afinitas node dapat menyatakan semua yang <code>nodeSelector</code> dapat nyatakan.</p><h3 id=afinitas-node-fitur-beta>Afinitas node (fitur beta)</h3><p>Afinitas node diperkenalkan sebagai fitur alfa pada Kubernetes 1.2.
Afinitas node secara konseptual mirip dengan <code>nodeSelector</code> yang memungkinkan kamu untuk membatasi node yang memenuhi syarat untuk penjadwalan pod, berdasarkan label pada node.</p><p>Saat ini ada dia tipe afinitas node, yaitu <code>requiredDuringSchedulingIgnoredDuringExecution</code> dan
<code>preferredDuringSchedulingIgnoredDuringExecution</code>. Kamu dapat menganggap dua tipe ini sebagai "kuat" dan "lemah" secara berurutan, dalam arti tipe pertama menyatakan peraturan yang <em>harus</em> dipenuhi agar pod dapat dijadwalkan pada node (sama seperti <code>nodeSelector</code> tetapi menggunakan sintaksis yang lebih ekpresif), sementara tipe kedua menyatakan <em>preferensi</em> yang akan dicoba dilaksanakan tetapi tidak akan dijamin oleh scheduler. Bagian "IgnoredDuringExecution" dari nama tipe ini berarti, mirip dengan cara kerja <code>nodeSelector</code>, jika label pada node berubah pada <em>runtime</em> yang menyebabkan aturan afinitas pada pod tidak lagi terpenuhi, pod akan tetap berjalan pada node. Pada masa yang akan datang kami berencana menawarkan <code>requiredDuringSchedulingRequiredDuringExecution</code> yang akan berjalan seperti <code>requiredDuringSchedulingIgnoredDuringExecution</code> hanya saja tipe ini akan mengeluarkan pod dari node yang gagal untuk memenuhi persyaratan afinitas node pod.</p><p>Dengan denikian, contoh dari <code>requiredDuringSchedulingIgnoredDuringExecution</code> adalah "hanya jalankan pod pada node dengan Intel CPU" dan contoh dari <code>preferredDuringSchedulingIgnoredDuringExecution</code> adalah "coba jalankan set pod ini dalam zona ketersediaan XYZ, tetapi jika tidak memungkinkan, maka biarkan beberapa pod berjalan di tempat lain".</p><p>Afinitas node dinyatakan sebagai <em>field</em> <code>nodeAffinity</code> dari <em>field</em> <code>affinity</code> pada PodSpec.</p><p>Berikut ini contoh dari pod yang menggunakan afinitas node:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/pods/pod-with-node-affinity.yaml download=pods/pod-with-node-affinity.yaml><code>pods/pod-with-node-affinity.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-pod-with-node-affinity-yaml")' title="Copy pods/pod-with-node-affinity.yaml to clipboard"></img></div><div class=includecode id=pods-pod-with-node-affinity-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>with-node-affinity<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>affinity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>nodeAffinity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requiredDuringSchedulingIgnoredDuringExecution</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>nodeSelectorTerms</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>kubernetes.io/e2e-az-name<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- e2e-az1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- e2e-az2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>preferredDuringSchedulingIgnoredDuringExecution</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>weight</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>preference</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>another-node-label-key<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- another-node-label-value<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>with-node-affinity<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/pause:2.0</span></span></code></pre></div></div></div><p>Aturan afinitas node tersebut menyatakan pod hanya bisa ditugaskan pada node dengan label yang memiliki kunci <code>kubernetes.io/e2e-az-name</code> dan bernilai <code>e2e-az1</code> atau <code>e2e-az2</code>. Selain itu, dari semua node yang memenuhi kriteria tersebut, mode dengan label dengan kunci <code>another-node-label-key</code> and bernilai <code>another-node-label-value</code> harus lebih diutamakan.</p><p>Kamu dapat meilhat operator <code>In</code> digunakan dalam contoh berikut. Sitaksis afinitas node yang baru mendukung operator-operator berikut: <code>In</code>, <code>NotIn</code>, <code>Exists</code>, <code>DoesNotExist</code>, <code>Gt</code>, <code>Lt</code>. Kamu dapat menggunakan <code>NotIn</code> dan <code>DoesNotExist</code> untuk mewujudkan perilaku node anti-afinitas, atau menggunakan <a href=/id/docs/concepts/scheduling-eviction/taint-and-toleration/>node taints</a> untuk menolak pod dari node tertentu.</p><p>Jika kamu menyatakan <code>nodeSelector</code> dan <code>nodeAffinity</code>. <em>keduanya</em> harus dipenuhi agar pod dapat dijadwalkan pada node kandidat.</p><p>Jika kamu menyatakan beberapa <code>nodeSelectorTerms</code> yang terkait dengan tipe <code>nodeAffinity</code>, maka pod akan dijadwalkan pada node <strong>jika salah satu</strong> dari <code>nodeSelectorTerms</code> dapat terpenuhi.</p><p>Jika kamu menyatakan beberapa <code>matchExpressions</code> yang terkait dengan <code>nodeSelectorTerms</code>, makan pod dapat dijadwalkan pada node <strong>hanya jika semua</strong> <code>matchExpressions</code> dapat terpenuhi.</p><p>Jika kamu menghapus atau mengubah label pada node tempat pod dijadwalkan, pod tidak akan dihapus. Dengan kata lain, pemilihan afinitas hanya bekerja pada saat waktu penjadwalan pod.</p><p><em>Field</em> <code>weight</code> pada <code>preferredDuringSchedulingIgnoredDuringExecution</code> berada pada rentang nilai 1-100. Untuk setiap node yang memenuhi semua persyaratan penjadwalan (permintaan sumber daya, pernyataan afinitas RequiredDuringScheduling, dll.), <em>scheduler</em> akan menghitung nilai jumlah dengan melakukan iterasi pada elemen-elemen dari <em>field</em> ini dan menambah "bobot" pada jumlah jika node cocok dengan MatchExpressions yang sesuai. Nilai ini kemudian digabungkan dengan nilai dari fungsi prioritas lain untuk node. Node dengan nilai tertinggi adalah node lebih diutamakan.</p><p>Untuk informasi lebih lanjut tentang afinitas node kamu dapat melihat <a href=https://git.k8s.io/community/contributors/design-proposals/scheduling/nodeaffinity.md>design doc</a>.</p><h3 id=afinitas-and-anti-afinitas-antar-pod-fitur-beta>Afinitas and anti-afinitas antar pod (fitur beta)</h3><p>Afinitas and anti-afinitas antar pod diperkenalkan pada Kubernetes 1.4. Afinitas and anti-afinitas antar pod memungkinkan kamu untuk membatasi node yang memenuhi syarat untuk penjadwalan pod <em>berdasarkan label-label pada pod yang sudah berjalan pada node</em> daripada berdasarkan label-label pada node. Aturan tersebut berbentuk "pod ini harus (atau, dalam kasus
anti-afinitas, tidak boleh) berjalan dalam X jika X itu sudah menjalankan satu atau lebih pod yang memenuhi aturan Y". Y dinyatakan sebagai sebuah LabelSelector dengan daftar namespace terkait; tidak seperti node, karena pod are namespaced (maka dari itu label-label pada pod diberi namespace secara implisit), sebuah label selector di atas label-label pod harus menentukan namespace yang akan diterapkan selector. Secara konsep X adalah domain topologi seperti node, rack, zona penyedia cloud, daerah penyedia cloud, dll. Kamu dapat menyatakannya menggunakan <code>topologyKey</code> yang merupakan kunci untuk label node yang digunakan sistem untuk menunjukkan domain topologi tersebut, contohnya lihat kunci label yang terdaftar di atas pada bagian <a href=#interlude-built-in-node-labels>Selingan: label node built-in</a>.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Afinitas and anti-afinitas antar pod membutuhkan jumlah pemrosesan yang substansial yang dapat memperlambat penjadwalan pada klaster berukuran besar secara signifikan. Kami tidak merekomendasikan penggunaan mereka pada klaster yang berukuran lebih besar dari beberapa ratus node.</div><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Anti-afinitas pod mengharuskan node untuk diberi label secara konsisten, misalnya setiap node dalam klaster harus memiliki label sesuai yang cocok dengan <code>topologyKey</code>. Jika sebagian atau semua node tidak memiliki label <code>topologyKey</code> yang dinyatakan, hal ini dapat menyebabkan perilaku yang tidak diinginkan.</div><p>Seperti afinitas node, ada dua tipe afinitas dan anti-afinitas pod, yaitu <code>requiredDuringSchedulingIgnoredDuringExecution</code> dan
<code>preferredDuringSchedulingIgnoredDuringExecution</code> yang menunjukan persyaratan "kuat" vs. "lemah". Lihat deskripsi pada bagian afinitas node sebelumnya.
Sebuah contoh dari afinitas <code>requiredDuringSchedulingIgnoredDuringExecution</code> adalah "Tempatkan bersamaan pod layanan A dan layanan B di zona yang sama, karena mereka banyak berkomunikasi satu sama lain"
dan contoh <code>preferDuringSchedulingIgnoredDuringExecution</code> anti-afinitas akan menjadi "sebarkan pod dari layanan ini di seluruh zona" (persyaratan kuat tidak masuk akal, karena kamu mungkin memiliki lebih banyak pod daripada zona).</p><p>Afinitas antar pod dinyatakan sebagai <em>field</em> <code>podAffinity</code> dari <em>field</em> <code>affinity</code> pada PodSpec dan anti-afinitas antar pod dinyatakan sebagai <em>field</em> <code>podAntiAffinity</code> dari <em>field</em> <code>affinity</code> pada PodSpec.</p><h4 id=contoh-pod-yang-menggunakan-pod-affinity>Contoh pod yang menggunakan pod affinity:</h4><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/pods/pod-with-pod-affinity.yaml download=pods/pod-with-pod-affinity.yaml><code>pods/pod-with-pod-affinity.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-pod-with-pod-affinity-yaml")' title="Copy pods/pod-with-pod-affinity.yaml to clipboard"></img></div><div class=includecode id=pods-pod-with-pod-affinity-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>with-pod-affinity<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>affinity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>podAffinity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requiredDuringSchedulingIgnoredDuringExecution</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>labelSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>security<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- S1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>topologyKey</span>:<span style=color:#bbb> </span>failure-domain.beta.kubernetes.io/zone<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>podAntiAffinity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>preferredDuringSchedulingIgnoredDuringExecution</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>weight</span>:<span style=color:#bbb> </span><span style=color:#666>100</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>podAffinityTerm</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>labelSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>security<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span>- S2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>topologyKey</span>:<span style=color:#bbb> </span>failure-domain.beta.kubernetes.io/zone<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>with-pod-affinity<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/pause:2.0<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Afinitas pada pod tersebut menetapkan sebuah aturan afinitas pod dan aturan anti-afinitas pod. Pada contoh ini, <code>podAffinity</code> adalah <code>requiredDuringSchedulingIgnoredDuringExecution</code>
sementara <code>podAntiAffinity</code> adalah <code>preferredDuringSchedulingIgnoredDuringExecution</code>. Aturan afinitas pod menyatakan bahwa pod dapat dijadwalkan pada node hanya jika node tersebut berada pada zona yang sama dengan minimal satu pod yang sudah berjalan yang memiliki label dengan kunci "security" dan bernilai "S1". (Lebih detail, pod dapat berjalan pada node N jika node N memiliki label dengan kunci <code>failure-domain.beta.kubernetes.io/zone</code>dan nilai V sehingga ada minimal satu node dalam klaster dengan kunci <code>failure-domain.beta.kubernetes.io/zone</code> dan bernilai V yang menjalankan pod yang memiliki label dengan kunci "security" dan bernilai "S1".) Aturan anti-afinitas pod menyatakan bahwa pod memilih untuk tidak dijadwalkan pada sebuah node jika node tersebut sudah menjalankan pod yang memiliki label dengan kunci "security" dan bernilai "S2". (Jika <code>topologyKey</code> adalah <code>failure-domain.beta.kubernetes.io/zone</code> maka dapat diartikan bahwa pod tidak dapat dijadwalkan pada node jika node berada pada zona yang sama dengan pod yang memiliki label dengan kunci "security" dan bernilai "S2".) Lihat <a href=https://git.k8s.io/community/contributors/design-proposals/scheduling/podaffinity.md>design doc</a> untuk lebih banyak contoh afinitas dan anti-afinitas pod, baik <code>requiredDuringSchedulingIgnoredDuringExecution</code>
maupun <code>preferredDuringSchedulingIgnoredDuringExecution</code>.</p><p>Operator yang sah untuk afinitas dan anti-afinitas pod adalah <code>In</code>, <code>NotIn</code>, <code>Exists</code>, <code>DoesNotExist</code>.</p><p>Pada dasarnya, <code>topologyKey</code> dapat berupa label-kunci apapun yang sah. Namun, untuk alasan performa dan keamanan, ada beberapa batasan untuk <code>topologyKey</code>:</p><ol><li>Untuk afinitas and anti-afinitas pod <code>requiredDuringSchedulingIgnoredDuringExecution</code>, <code>topologyKey</code> tidak boleh kosong.</li><li>Untuk anti-afinitas pod <code>requiredDuringSchedulingIgnoredDuringExecution</code>, pengontrol penerimaan <code>LimitPodHardAntiAffinityTopology</code> diperkenalkan untuk membatasi <code>topologyKey</code> pada <code>kubernetes.io/hostname</code>. Jika kamu menginginkan untuk membuatnya tersedia untuk topologi khusus, kamu dapat memodifikasi pengontrol penerimaan, atau cukup menonaktifkannya saja.</li><li>Untuk anti-afinitas pod <code>preferredDuringSchedulingIgnoredDuringExecution</code>, <code>topologyKey</code> yang kosong diinterpretasikan sebagai "semua topologi" ("semua topologi" sekarang dibatasi pada kombinasi dari <code>kubernetes.io/hostname</code>, <code>failure-domain.beta.kubernetes.io/zone</code> dan <code>failure-domain.beta.kubernetes.io/region</code>).</li><li>Kecuali untuk kasus-kasus di atas, <code>topologyKey</code> dapat berupa label-kunci apapun yang sah.</li></ol><p>Sebagai tambahan untuk <code>labelSelector</code> and <code>topologyKey</code>, kamu secara opsional dapat menyatakan daftar <code>namespaces</code> dari namespaces yang akan digunakan untuk mencocokan <code>labelSelector</code> (daftar ini berjalan pada level definisi yang sama dengan <code>labelSelector</code> dan <code>topologyKey</code>)</p><p>Jika dihilangkan atau kosong, daftar ini sesuai standar akan merujuk pada <em>namespace</em> dari pod tempat definisi afinitas/anti-afinitas dinyatakan.</p><p>Semua <code>matchExpressions</code> berkaitan dengan afinitas and anti-afinitas <code>requiredDuringSchedulingIgnoredDuringExecution</code> harus dipenuhi agar pod dapat dijadwalkan pada node.</p><h4 id=penggunaan-yang-lebih-praktikal>Penggunaan yang lebih praktikal</h4><p>Afinitas and anti-afinitas antar pod dapat menjadi lebih berguna saat digunakan bersamaan dengan koleksi dengan level yang lebih tinggi seperti ReplicaSets, StatefulSets, Deployments, dll. Pengguna dapat dengan mudah mengkonfigurasi bahwa satu set workload harus
ditempatkan bersama dalam topologi yang didefinisikan sama, misalnya, node yang sama.</p><h5 id=selalu-ditempatkan-bersamaan-pada-node-yang-sama>Selalu ditempatkan bersamaan pada node yang sama</h5><p>Dalam klaster berisi 3 node, sebuah aplikasi web memiliki in-memory cache seperti redis. Kita menginginkan agar <em>web-server</em> dari aplikasi ini sebisa mungkin ditempatkan bersamaan dengan cache.</p><p>Berikut ini kutipan yaml dari deployment redis sederhana dengan 3 replika dan label selector <code>app=store</code>, Deployment memiliki konfigurasi <code>PodAntiAffinity</code> untuk memastikan <em>scheduler</em> tidak menempatkan replika bersamaan pada satu node.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>redis-cache<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>store<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>store<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>affinity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>podAntiAffinity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>requiredDuringSchedulingIgnoredDuringExecution</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>labelSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>app<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                </span>- store<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>topologyKey</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;kubernetes.io/hostname&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>redis-server<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis:3.2-alpine<span style=color:#bbb>
</span></span></span></code></pre></div><p>Kutipan yaml dari deployment webserver berikut ini memiliki konfigurasi <code>podAntiAffinity</code> dan <code>podAffinity</code>. Konfigurasi ini menginformasikan scheduler bahwa semua replika harus ditempatkan bersamaan dengan pod yang memiliki label selector <code>app=store</code>. Konfigurasi ini juga memastikan bahwa setiap replika webserver tidak ditempatkan bersamaan pada satu node.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>web-server<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>web-store<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>web-store<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>affinity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>podAntiAffinity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>requiredDuringSchedulingIgnoredDuringExecution</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>labelSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>app<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                </span>- web-store<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>topologyKey</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;kubernetes.io/hostname&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>podAffinity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>requiredDuringSchedulingIgnoredDuringExecution</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>labelSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>app<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                </span>- store<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>topologyKey</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;kubernetes.io/hostname&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>web-app<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.12-alpine<span style=color:#bbb>
</span></span></span></code></pre></div><p>Jika kita membuat kedua dployment di atas, klaster berisi 3 node kita seharusnya menjadi seperti berikut.</p><table><thead><tr><th style=text-align:center>node-1</th><th style=text-align:center>node-2</th><th style=text-align:center>node-3</th></tr></thead><tbody><tr><td style=text-align:center><em>webserver-1</em></td><td style=text-align:center><em>webserver-2</em></td><td style=text-align:center><em>webserver-3</em></td></tr><tr><td style=text-align:center><em>cache-1</em></td><td style=text-align:center><em>cache-2</em></td><td style=text-align:center><em>cache-3</em></td></tr></tbody></table><p>st
Seperti yang kamu lihat, semua 3 replika dari <code>web-server</code> secara otomatis ditempatkan bersama dengan cache seperti yang diharapkan.</p><pre tabindex=0><code>$ kubectl get pods -o wide
NAME                           READY     STATUS    RESTARTS   AGE       IP           NODE
redis-cache-1450370735-6dzlj   1/1       Running   0          8m        10.192.4.2   kube-node-3
redis-cache-1450370735-j2j96   1/1       Running   0          8m        10.192.2.2   kube-node-1
redis-cache-1450370735-z73mh   1/1       Running   0          8m        10.192.3.1   kube-node-2
web-server-1287567482-5d4dz    1/1       Running   0          7m        10.192.2.3   kube-node-1
web-server-1287567482-6f7v5    1/1       Running   0          7m        10.192.4.3   kube-node-3
web-server-1287567482-s330j    1/1       Running   0          7m        10.192.3.2   kube-node-2
</code></pre><h5 id=tidak-akan-pernah-ditempatkan-bersamaan-dalam-node-yang-sama>Tidak akan pernah ditempatkan bersamaan dalam node yang sama</h5><p>Contoh di atas menggunakan aturan <code>PodAntiAffinity</code> dengan <code>topologyKey: "kubernetes.io/hostname"</code> untuk melakukan deploy klaster redis sehingga tidak ada dua instance terletak pada hos yang sama.
Lihat <a href=/docs/tutorials/stateful-application/zookeeper/#tolerating-node-failure>tutorial ZooKeeper</a> untuk contoh dari konfigurasi StatefulSet dengan anti-afinitas untuk ketersediaan tinggi, menggunakan teknik yang sama.</p><p>Untuk informasi lebih lanjut tentang afinitas/anti-afinitas antar pod, lihat <a href=https://git.k8s.io/community/contributors/design-proposals/scheduling/podaffinity.md>design doc</a>.</p><p>Kamu juga dapat mengecek <a href=/id/docs/concepts/scheduling-eviction/taint-and-toleration/>Taints</a>, yang memungkinkan sebuah <em>node</em> untuk <em>menolak</em> sekumpulan pod.</p><h2 id=nodename>nodeName</h2><p><code>nodeName</code> adalah bentuk paling sederhana dari pembatasan pemilihan node, tetapi karena
keterbatasannya biasanya tidak digunakan. <code>nodeName</code> adalah sebuah <em>field</em> dari
PodSpec. Jika tidak kosong, scheduler mengabaikan pod dan
kubelet yang berjalan pada node tersebut yang mencoba menjalankan pod. Maka, jika
<code>nodeName</code> disediakan dalam PodSpec, ia memiliki hak yang lebih tinggi dibanding metode-metode di atas untuk pemilihan node.</p><p>Beberapa keterbatasan dari penggunaan <code>nodeName</code> untuk memilih node adalah:</p><ul><li>Jika node yang disebut tidak ada, maka pod tidak akan dijalankan, dan dalam beberapa kasus akan
dihapus secara otomatis.</li><li>Jika node yang disebut tidak memiliki resource yang cukup untuk mengakomodasi pod, pod akan gagal
dan alasannya akan mengindikasikan sebab kegagalan, misalnya OutOfmemory atau OutOfcpu.</li><li>Nama node pada lingkungan cloud tidak selalu dapat diprediksi atau stabil.</li></ul><p>Berikut ini contoh konfigurasi pod menggunakan <em>field</em> <code>nodeName</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodeName</span>:<span style=color:#bbb> </span>kube-01<span style=color:#bbb>
</span></span></span></code></pre></div><p>Pod di atas akan berjalan pada node kube-01.</p><h2 id=selanjutnya>Selanjutnya</h2></div><div class=td-content style=page-break-before:always><h1 id=pg-ede4960b56a3529ee0bfe7c8fe2d09a5>3.9.4 - Taint dan Toleration</h1><p>Afinitas Node, seperti yang dideskripsikan <a href=/id/docs/concepts/configuration/assign-pod-node/#node-affinity-beta-feature>di sini</a>,
adalah salah satu properti dari Pod yang menyebabkan pod tersebut memiliki preferensi
untuk ditempatkan di sekelompok Node tertentu (preferensi ini dapat berupa <em>soft constraints</em> atau
<em>hard constraints</em> yang harus dipenuhi). <em>Taint</em> merupakan kebalikan dari afinitas --
properti ini akan menyebabkan Pod memiliki preferensi untuk tidak ditempatkan pada sekelompok Node tertentu.</p><p><em>Taint</em> dan <em>toleration</em> bekerja sama untuk memastikan Pod dijadwalkan pada Node
yang sesuai. Satu atau lebih <em>taint</em> akan diterapkan pada suatu node; hal ini akan menyebabkan
node tidak akan menerima pod yang tidak mengikuti <em>taint</em> yang sudah diterapkan.</p><h2 id=konsep>Konsep</h2><p>Kamu dapat menambahkan <em>taint</em> pada sebuah <em>node</em> dengan menggunakan perintah <a href=/docs/reference/generated/kubectl/kubectl-commands#taint>kubectl taint</a>.
Misalnya,</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl taint nodes node1 <span style=color:#b8860b>key</span><span style=color:#666>=</span>value:NoSchedule
</span></span></code></pre></div><p>akan menerapkan <em>taint</em> pada <em>node</em> <code>node1</code>. <em>Taint</em> tersebut memiliki <em>key</em> <code>key</code>, <em>value</em> <code>value</code>,
dan <em>effect</em> <em>taint</em> <code>NoSchedule</code>. Hal ini artinya pod yang ada tidak akan dapat dijadwalkan pada <code>node1</code>
kecuali memiliki <em>taint</em> yang sesuai.</p><p>Untuk menghilangkan <em>taint</em> yang ditambahkan dengan perintah di atas, kamu dapat menggunakan
perintah di bawah ini:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl taint nodes node1 key:NoSchedule-
</span></span></code></pre></div><p>Kamu dapat memberikan spesifikasi <em>toleration</em> untuk <em>pod</em> pada bagian PodSpec.
Kedua <em>toleration</em> yang diterapkan di bawa ini "sesuai" dengan <em>taint</em> yang
<em>taint</em> yang dibuat dengan perintah <code>kubectl taint</code> di atas, sehingga sebuah <em>pod</em>
dengan <em>toleration</em> yang sudah didefinisikan akan mampu di-<em>schedule</em> ke node <code>node</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>tolerations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;key&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Equal&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;value&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;NoSchedule&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>tolerations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;key&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Exists&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;NoSchedule&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Sebuah <em>toleration</em> "sesuai" dengan sebuah <em>taint</em> jika <em>key</em> dan efek yang
ditimbulkan sama:</p><ul><li><code>operator</code> dianggap <code>Exists</code> (pada kasus dimana tidak ada <code>value</code> yang diberikan), atau</li><li><code>operator</code> dianggap <code>Equal</code> dan <code>value</code> yang ada sama</li></ul><p><code>Operator</code> bernilai <code>Equal</code> secara <em>default</em> jika tidak diberikan spesifikasi khusus.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong><p>Terdapat dua kasus khusus:</p><ul><li>Sebuah <code>key</code> dengan operator <code>Exists</code> akan sesuai dengan semua <em>key</em>, <em>value</em>, dan <em>effect</em> yang ada.
Dengan kata lain, <em>tolaration</em> ini akan menerima semua hal yang diberikan.</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>tolerations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Exists&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><ul><li>Sebuah <code>effect</code> yang kosong akan dianggap sesuai dengan semua <em>effect</em> dengan <em>key</em> <code>key</code>.</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>tolerations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;key&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Exists&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div></div><p>Contoh yang diberikan di atas menggunakan <code>effect</code> untuk <code>NoSchedule</code>.
Alternatif lain yang dapat digunakan adalah <code>effect</code> untuk <code>PreferNoSchedule</code>.
<code>PreferNoSchedule</code> merupakan "preferensi" yang lebih fleksibel dari <code>NoSchedule</code> --
sistem akan mencoba untuk tidak menempatkan pod yang tidak menoleransi <em>taint</em>
pada <em>node</em>, tapi hal ini bukan merupakan sesuatu yang harus dipenuhi. Jenis ketiga
dari <code>effect</code> adalah <code>NoExecute</code>, akan dijelaskan selanjutnya.</p><p>Kamu dapat menerapkan beberapa <em>taint</em> sekaligus pada <em>node</em> atau
beberapa <em>toleration</em> sekaligus pada sebuah <em>pod</em>. Mekanisme Kubernetes dapat
memproses beberapa <em>taint</em> dan <em>toleration</em> sekaligus sama halnya seperti sebuah
<em>filter</em>: memulai dengan <em>taint</em> yang ada pada <em>node</em>, kemudian mengabaikan
<em>taint</em> yang sesuai pada pod yang memiliki <em>toleration</em> yang sesuai; kemudian
<em>taint</em> yang diterapkan pada pod yang sudah disaring tadi akan menghasilkan suatu
<em>effect</em> pada pod. Secara khusus:</p><ul><li>jika terdapat <em>taint</em> yang tidak tersaring dengan <em>effect</em> <code>NoSchedule</code> maka Kubernetes tidak akan menempatkan
<em>pod</em> pada <em>node</em> tersebut</li><li>jika tidak terdapat <em>taint</em> yang tidak tersaring dengan <em>effect</em> <code>NoSchedule</code>
tapi terdapat setidaknya satu <em>taint</em> yang tidak tersaring dengan
<em>effect</em> <code>PreferNoSchedule</code> maka Kubernetes akan mencoba untuk tidak akan menempatkan
<em>pod</em> pada <em>node</em> tersebut</li><li>jika terdapat <em>taint</em> yang tidak tersaring dengan <em>effect</em> <code>NoExecute</code> maka <em>pod</em> akan
berada dalam kondisi <em>evicted</em> dari <em>node</em> (jika <em>pod</em> tersebut sudah terlanjur ditempatkan pada <em>node</em>
tersebut), dan tidak akan di-<em>schedule</em> lagi pada <em>node</em> tersebut.</li></ul><p>Sebagai contoh, bayangkan kamu memberikan <em>taint</em> pada <em>node</em> sebagai berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl taint nodes node1 <span style=color:#b8860b>key1</span><span style=color:#666>=</span>value1:NoSchedule
</span></span><span style=display:flex><span>kubectl taint nodes node1 <span style=color:#b8860b>key1</span><span style=color:#666>=</span>value1:NoExecute
</span></span><span style=display:flex><span>kubectl taint nodes node1 <span style=color:#b8860b>key2</span><span style=color:#666>=</span>value2:NoSchedule
</span></span></code></pre></div><p>Dan <em>pod</em> memiliki dua <em>toleration</em>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>tolerations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;key1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Equal&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;value1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;NoSchedule&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;key1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Equal&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;value1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;NoExecute&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Pada kasus ini, <em>pod</em> tidak akan di-<em>schedule</em> pada <em>node</em>, karena tidak ada
<em>toleration</em> yang sesuai dengan <em>taint</em> ketiga. Akan tetapi, <em>pod</em> yang sebelumnya
sudah dijalankan di <em>node</em> dimana <em>taint</em> ditambahkan akan tetap jalan, karena <em>taint</em>
ketiga merupakan <em>taint</em> yang tidak ditoleransi oleh <em>pod</em>.</p><p>Pada umumnya, jika sebuah <em>taint</em> memiliki <em>effect</em> <code>NoExecute</code> ditambahkan pada <em>node</em>,
maka semua pod yang tidak menoleransi <em>taint</em> tersebut akan berada dalam <em>state</em>
<em>evicted</em> secara langsung, dan semua <em>pod</em> yang menoleransi <em>taint</em> tersebut
tidak akan berjalan seperti biasanya (tidak dalam <em>state</em> <em>evicted</em>). Meskipun demikian,
<em>toleration</em> dengan <em>effect</em> <code>NoExecute</code> dapat dispesfikasikan sebagai <em>field</em> opsional
<code>tolerationSeconds</code> yang memberikan perintah berapa lama suatu <em>pod</em> akan berada
pada <em>node</em> apabila sebuah <em>taint</em> ditambahkan. Contohnya:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>tolerations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;key1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Equal&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;value1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;NoExecute&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>tolerationSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>3600</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>ini berarti apabila sebuah <em>pod</em> sedang dalam berada dalam <em>state</em> <em>running</em>,
kemudian sebuah <em>taint</em> yang sesuai ditambahkan pada <em>node</em>, maka <em>pod</em> tersebut
akan tetap berada di dalam <em>node</em> untuk periode 3600 detik sebelum <em>state</em>-nya
berubah menjadi <em>evicted</em>. Jika <em>taint</em> dihapus sebelum periode tersebut, maka <em>pod</em>
tetap berjalan sebagaimana mestinya.</p><h2 id=contoh-penggunaan>Contoh Penggunaan</h2><p><em>Taint</em> dan <em>toleration</em> adalah mekanisme fleksibel yang digunakan untuk
memaksa <em>pod</em> agar tidak dijadwalkan pada <em>node-node</em> tertentu atau
mengubah <em>state</em> <em>pod</em> menjadi <em>evicted</em>. Berikut adalah beberapa contoh penggunaannya:</p><ul><li><p><strong>Node-Node yang Sifatnya <em>Dedicated</em></strong>: Jika kamu ingin menggunakan
sekumpulan <em>node</em> dengan penggunaan eksklusif dari sekumpulan pengguna,
kamu dapat menambahkan <em>taint</em> pada <em>node-node</em> tersebut (misalnya,
<code>kubectl taint nodes nodename dedicated=groupName:NoSchedule</code>) dan kemudian
menambahkan <em>toleration</em> yang sesuai pada <em>pod-pod</em> yang berada di dalamnya (hal ini
dapat dilakukan dengan mudah dengan cara menulis
<a href=/docs/reference/access-authn-authz/admission-controllers/><em>admission controller</em></a> yang
bersifat khusus). <em>Pod-pod</em> dengan <em>toleration</em> nantinya akan diperbolehkannya untuk menggunakan
<em>node</em> yang sudah di-<em>taint</em> (atau dengan kata lain didedikasikan penggunaannya) maupun
<em>node</em> lain yang ada di dalam klaster. Jika kamu ingin mendedikasikan <em>node</em> khusus
yang hanya digunakan oleh <em>pod-pod</em> tadi serta memastikan <em>pod-pod</em> tadi hanya menggunakan
<em>node</em> yang didedikasikan, maka kamu harus menambahkan sebuah <em>label</em> yang serupa dengan
<em>taint</em> yang diberikan pada sekelompok <em>node</em> (misalnya, <code>dedicated=groupName</code>), dan
<em>admission controller</em> sebaiknya menambahkan afininitas <em>node</em> untuk memastikan <em>pod-pod</em>
tadi hanya dijadwalkan pada <em>node</em> dengan <em>label</em> <code>dedicated=groupName</code>.</p></li><li><p><strong>Node-Node dengan Perangkat Keras Khusus</strong>: Pada suatu klaster dimana
sebagian kecuali <em>node</em> memiliki perangkat keras khusus (misalnya GPU), kita ingin
memastikan hanya <em>pod-pod</em> yang membutuhkan GPU saja yang dijadwalkan di <em>node</em> dengan GPU.
Hal ini dapat dilakukan dengan memberikan <em>taint</em> pada <em>node</em> yang memiliki perangkat keras
khusus (misalnya, <code>kubectl taint nodes nodename special=true:NoSchedule</code> atau
<code>kubectl taint nodes nodename special=true:PreferNoSchedule</code>) serta menambahkan <em>toleration</em>
yang sesuai pada <em>pod</em> yang menggunakan <em>node</em> dengan perangkat keras khusus. Seperti halnya pada
kebutuhan <em>dedicated</em> <em>node</em>, hal ini dapat dilakukan dengan mudah dengan cara menulis
<a href=/docs/reference/access-authn-authz/admission-controllers/><em>admission controller</em></a> yang
bersifat khusus. Misalnya, kita dapat menggunakan <a href=/id/docs/concepts/configuration/manage-compute-resources-container/#extended-resources><em>Extended Resource</em></a>
untuk merepresentasikan perangkat keras khusus, kemudian <em>taint</em> <em>node</em> dengan perangkat keras khusus
dengan nama <em>extended resource</em> dan jalankan <em>admission controller</em>
<a href=/docs/reference/access-authn-authz/admission-controllers/#extendedresourcetoleration>ExtendedResourceToleration</a>.
Setelah itu, karena <em>node</em> yang ada sudah di-<em>taint</em>, maka tidak akan ada <em>pod</em> yang
tidak memiliki <em>toleration</em> yang akan dijadwalkan pada <em>node</em> tersebut_.
Meskipun begitu, ketika kamu membuat suatu <em>pod</em> yang membutuhkan <em>extended resource</em>,
maka <em>admission controller</em> dari <code>ExtendedResourceToleration</code> akan mengoreksi
<em>toleration</em> sehingga <em>pod</em> tersebut dapat dijadwalkan pada <em>node</em> dengan perangkat keras khusus.
Dengan demikian, kamu tidak perlu menambahkan <em>toleration</em> secara manual pada pod yang ada.</p></li><li><p><strong><em>Eviction</em> berbasis <em>Taint</em> (fitur beta)</strong>: Konfigurasi <em>eviction</em> per <em>pod</em>
yang terjadi ketika <em>pod</em> mengalami gangguan, hal ini akan dibahas lebih lanjut di bagian
selanjutnya.</p></li></ul><h2 id=eviction-berbasis-taint><em>Eviction</em> berbasis <em>Taint</em></h2><p>Sebelumnya, kita sudah pernah membahas soal <em>effect</em> <em>taint</em> <code>NoExecute</code>,
yang memengaruhi <em>pod</em> yang sudah dijalankan dengan cara sebagai berikut:</p><ul><li><em>pod</em> yang tidak menoleransi <em>taint</em> akan segera diubah <em>state</em>-nya menjadi <em>evicted</em></li><li><em>pod</em> yang menoleransi <em>taint</em> yang tidak menspesifikasikan <code>tolerationSeconds</code> pada
spesifikasi <em>toleration</em> yang ada akan tetap berada di dalam <em>node</em> tanpa adanya batas waktu tertentu</li><li><em>pod</em> yang menoleransi <em>taint</em> yang menspesifikasikan <code>tolerationSeconds</code>
spesifikasi <em>toleration</em> yang ada akan tetap berada di dalam <em>node</em> hingga batas waktu tertentu</li></ul><p>Sebagai tambahan, Kubernetes 1.6 memperkenalkan dukungan alfa untuk merepresentasikan
<em>node</em> yang bermasalah. Dengan kata lain, <em>node controller</em> akan secara otomatis memberikan <em>taint</em>
pada sebuah <em>node</em> apabila <em>node</em> tersebut memenuhi kriteria tertentu. Berikut merupakan <em>taint</em>
yang secara <em>default</em> disediakan:</p><ul><li><code>node.kubernetes.io/not-ready</code>: <em>Node</em> berada dalam <em>state</em> <em>not ready</em>. Hal ini terjadi apabila
<em>value</em> dari <em>NodeCondition</em> <code>Ready</code> adalah "<code>False</code>".</li><li><code>node.kubernetes.io/unreachable</code>: <em>Node</em> berada dalam <em>state</em> <em>unreachable</em> dari <em>node controller</em>
Hal ini terjadi apabila <em>value</em> dari <em>NodeCondition</em> <code>Ready</code> adalah "<code>Unknown</code>".</li><li><code>node.kubernetes.io/out-of-disk</code>: <em>Node</em> kehabisan kapasitas <em>disk</em>.</li><li><code>node.kubernetes.io/memory-pressure</code>: <em>Node</em> berada diambang kapasitas memori.</li><li><code>node.kubernetes.io/disk-pressure</code>: <em>Node</em> berada diambang kapasitas <em>disk</em>.</li><li><code>node.kubernetes.io/network-unavailable</code>: Jaringan pada <em>Node</em> bersifat <em>unavailable</em>.</li><li><code>node.kubernetes.io/unschedulable</code>: <em>Node</em> tidak dapat dijadwalkan.</li><li><code>node.cloudprovider.kubernetes.io/uninitialized</code>: Ketika <em>kubelet</em> dijalankan dengan
penyedia layanan <em>cloud</em> "eksternal", <em>taint</em> ini akan diterapkan pada <em>node</em> untuk menandai
<em>node</em> tersebut tidak digunakan. Setelah kontroler dari <em>cloud-controller-manager</em> melakukan
inisiasi <em>node</em> tersebut, maka <em>kubelet</em> akan menghapus <em>taint</em> yang ada.</li></ul><p>Pada versi 1.13, fitur <code>TaintBasedEvictions</code> diubah menjadi beta dan diaktifkan secara <em>default</em>,
dengan demikian <em>taint-taint</em> tersebut secara otomatis ditambahkan oleh <em>NodeController</em> (atau <em>kubelet</em>)
dan logika normal untuk melakukan <em>eviction</em> pada <em>pod</em> dari suatu <em>node</em> tertentu berdasarkan <em>value</em>
dari <em>Ready</em> yang ada pada <em>NodeCondition</em> dinonaktifkan.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Untuk menjaga perilaku <a href=/id/docs/concepts/architecture/nodes/><em>rate limiting</em></a> yang
ada pada <em>eviction</em> <em>pod</em> apabila <em>node</em> mengalami masalah, sistem sebenarnya menambahkan
<em>taint</em> dalam bentuk <em>rate limiter</em>. Hal ini mencegah <em>eviction</em> besar-besaran pada <em>pod</em>
pada skenario dimana master menjadi terpisah dari <em>node</em> lainnya.</div><p>Fitur beta ini, bersamaan dengan <code>tolerationSeconds</code>, mengizinkan sebuah <em>pod</em>
untuk menspesifikasikan berapa lama <em>pod</em> harus tetap sesuai dengan sebuah <em>node</em>
apabila <em>node</em> tersebut bermasalah.</p><p>Misalnya, sebuah aplikasi dengan banyak <em>state</em> lokal akan lebih baik untuk tetap
berada di suatu <em>node</em> pada saat terjadi partisi jaringan, dengan harapan partisi jaringan
tersebut dapat diselesaikan dan mekanisme <em>eviction</em> <em>pod</em> tidak akan dilakukan.
<em>Toleration</em> yang ditambahkan akan berbentuk sebagai berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>tolerations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;node.kubernetes.io/unreachable&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Exists&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;NoExecute&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>tolerationSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>6000</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Perhatikan bahwa Kubernetes secara otomatis menambahkan <em>toleration</em> untuk
<code>node.kubernetes.io/not-ready</code> dengan <code>tolerationSeconds=300</code>
kecuali konfigurasi lain disediakan oleh pengguna.
Kubernetes juga secara otomatis menambahkan <em>toleration</em> untuk
<code>node.kubernetes.io/unreachable</code> dengan <code>tolerationSeconds=300</code>
kecuali konfigurasi lain disediakan oleh pengguna.</p><p><em>Toleration</em> yang ditambahkan secara otomatis ini menjamin bahwa
perilaku <em>default</em> dari suatu <em>pod</em> adalah tetap bertahan selama 5 menit pada
<em>node</em> apabila salah satu masalah terdeteksi.
Kedua <em>toleration</em> <em>default</em> tadi ditambahkan oleh <a href=https://git.k8s.io/kubernetes/plugin/pkg/admission/defaulttolerationseconds>DefaultTolerationSeconds
<em>admission controller</em></a>.</p><p><em>Pod-pod</em> pada <a href=/id/docs/concepts/workloads/controllers/daemonset/>DaemonSet</a> dibuat dengan <em>toleration</em>
<code>NoExecute</code> untuk <em>taint</em> tanpa <code>tolerationSeconds</code>:</p><ul><li><code>node.kubernetes.io/unreachable</code></li><li><code>node.kubernetes.io/not-ready</code></li></ul><p>Hal ini menjamin <em>pod-pod</em> yang merupakan bagian dari DaemonSet tidak pernah berada di dalam
<em>state</em> <em>evicted</em> apabila terjadi permasalahan pada <em>node</em>.</p><h2 id=taint-pada-node-berdasarkan-kondisi-tertentu><em>Taint</em> pada <em>Node</em> berdasarkan Kondisi Tertentu</h2><p>Pada versi 1.12, fitur <code>TaintNodesByCondition</code> menjadi fitur beta, dengan demikian <em>lifecycle</em>
dari kontroler <em>node</em> akan secara otomatis menambahkan <em>taint</em> sesuai dengan kondisi <em>node</em>.
Hal yang sama juga terjadi pada <em>scheduler</em>, <em>scheduler</em> tidak bertugas memeriksa kondisi <em>node</em>
tetapi kondisi <em>taint</em>. Hal ini memastikan bahwa kondisi <em>node</em> tidak memengaruhi apa
yang dijadwalkan di <em>node</em>. Pengguna dapat memilih untuk mengabaikan beberapa permasalahan yang
ada pada <em>node</em> (yang direpresentasikan oleh kondisi <em>Node</em>) dengan menambahkan <em>toleration</em> <em>Pod</em> <code>NoSchedule</code>.
Sedangkan <em>taint</em> dengan <em>effect</em> <code>NoExecute</code> dikendalikan oleh <code>TaintBasedEviction</code> yang merupakan
fitur beta yang diaktifkan secara <em>default</em> oleh Kubernetes sejak versi 1.13.</p><p>Sejak Kubernetes versi 1.8, kontroler DaemonSet akan secara otomatis
menambahkan <em>toleration</em> <code>NoSchedule</code> pada semua <em>daemon</em> untuk menjaga
fungsionalitas DaemonSet.</p><ul><li><code>node.kubernetes.io/memory-pressure</code></li><li><code>node.kubernetes.io/disk-pressure</code></li><li><code>node.kubernetes.io/out-of-disk</code> (hanya untuk pod yang bersifat <em>critical</em>)</li><li><code>node.kubernetes.io/unschedulable</code> (versi 1.10 atau yang lebih baru)</li><li><code>node.kubernetes.io/network-unavailable</code> (hanya untuk jaringan <em>host</em>)</li></ul><p>Menambahkan <em>toleration</em> ini menjamin <em>backward compatibility</em>.
Kamu juga dapat menambahkan <em>toleration</em> lain pada DaemonSet.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-598f36d691ab197f9d995784574b0a12>3.9.5 - Penjadwal Kubernetes</h1><p>Dalam Kubernetes, <em>scheduling</em> atau penjadwalan ditujukan untuk memastikan
<a class=glossary-tooltip title='Unit Kubernetes yang paling sederhana dan kecil. Sebuah Pod merepresentasikan sebuah set kontainer yang dijalankan pada kluster kamu.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a> mendapatkan
<a class=glossary-tooltip title='A node is a worker machine in Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/nodes/ target=_blank aria-label=Node>Node</a> sehingga
<a class=glossary-tooltip title='Agen yang dijalankan pada setiap node di klaster yang bertugas untuk memastikan kontainer dijalankan di dalam Pod.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=Kubelet>Kubelet</a> dapat menjalankannya.</p><h2 id=penjadwalan>Ikhtisar Penjadwalan</h2><p>Sebuah penjadwal mengawasi Pod yang baru saja dibuat dan belum ada Node yang
dialokasikan untuknya. Untuk setiap Pod yang ditemukan oleh penjadwal, maka
penjadwal tersebut bertanggung jawab untuk menemukan Node terbaik untuk
menjalankan Pod. Penjadwal dapat menetapkan keputusan penempatan ini dengan
mempertimbangkan prinsip-prinsip penjadwalan yang dijelaskan di bawah ini.</p><p>Jika kamu ingin memahami mengapa Pod ditempatkan pada Node tertentu, atau jika
kamu berencana untuk mengimplementasikan penjadwal kustom sendiri, halaman ini
akan membantu kamu belajar tentang penjadwalan.</p><h2 id=kube-scheduler>Kube-scheduler</h2><p><a href=https://kubernetes.io/docs/reference/command-line-tools-reference/kube-scheduler/><em>Kube-scheduler</em></a>
adalah penjadwal standar untuk Kubernetes dan dijalankan sebagai bagian dari
<a class=glossary-tooltip title='Merupakan lapisan orkestrasi Container yang mengekspos API dan antarmuka untuk mendefinisikan, menggelar, dan mengelola siklus hidup suatu Container.' data-toggle=tooltip data-placement=top href='/id/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='_control plane_'>_control plane_</a>.
<em>Kube-scheduler</em> dirancang agar jika kamu mau dan perlu, kamu bisa menulis
komponen penjadwalan kamu sendiri dan menggunakannya.</p><p>Untuk setiap Pod yang baru dibuat atau Pod yang tak terjadwal lainnya,
<em>kube-scheduler</em> memilih Node yang optimal untuk menjalankannya. Namun, setiap
kontainer masuk Pod memiliki persyaratan sumber daya yang berbeda dan setiap Pod
juga memiliki persyaratan yang berbeda juga. Oleh karena itu, Node yang ada
perlu dipilih sesuai dengan persyaratan khusus penjadwalan.</p><p>Dalam sebuah Klaster, Node yang memenuhi persyaratan penjadwalan untuk suatu Pod
disebut Node <em>feasible</em>. Jika tidak ada Node yang cocok, maka Pod tetap tidak
terjadwal sampai penjadwal yang mampu menempatkannya.</p><p>Penjadwal menemukan Node-Node yang layak untuk sebuah Pod dan kemudian
menjalankan sekumpulan fungsi untuk menilai Node-Node yang layak dan mengambil
satu Node dengan skor tertinggi di antara Node-Node yang layak untuk menjalankan
Pod. Penjadwal kemudian memberi tahu server API tentang keputusan ini dalam
proses yang disebut dengan <em>binding</em>.</p><p>Beberapa faktor yang perlu dipertimbangkan untuk keputusan penjadwalan termasuk
persyaratan sumber daya individu dan kolektif, aturan kebijakan / perangkat keras /
lunak, spesifikasi persamaan dan anti-persamaan, lokalitas data, interferensi
antar Workloads, dan sebagainya.</p><h3 id=kube-scheduler-implementation>Pemilihan node pada kube-scheduler</h3><p><em>Kube-scheduler</em> memilih node untuk pod dalam 2 langkah operasi:</p><ol><li>Filtering</li><li>Scoring</li></ol><p>Langkah <em>filtering</em> menemukan sekumpulan Nodes yang layak untuk menjadwalkan
Pod. Misalnya, penyarin PodFitsResources memeriksa apakah Node kandidat
memiliki sumber daya yang cukup untuk memenuhi permintaan spesifik sumber daya dari
Pod. Setelah langkah ini, daftar Node akan berisi Node-node yang sesuai;
seringkali, akan terisi lebih dari satu. Jika daftar itu kosong, maka Pod itu
tidak (belum) dapat dijadwalkan.</p><p>Pada langkah <em>scoring</em>, penjadwal memberi peringkat pada Node-node yang tersisa
untuk memilih penempatan paling cocok untuk Pod. Penjadwal memberikan skor
untuk setiap Node yang sudah tersaring, memasukkan skor ini pada aturan
penilaian yang aktif.</p><p>Akhirnya, <em>kube-scheduler</em> memberikan Pod ke Node dengan peringkat tertinggi.
Jika ada lebih dari satu node dengan skor yang sama, maka <em>kube-scheduler</em>
memilih salah satunya secara acak.</p><p>Ada dua cara yang didukung untuk mengkonfigurasi perilaku penyaringan dan
penilaian oleh penjadwal:</p><ol><li><a href=/docs/reference/scheduling/policies>Aturan Penjadwalan</a> yang memungkinkan
kamu untuk mengkonfigurasi <em>Predicates</em> untuk pemfilteran dan <em>Priorities</em>
untuk penilaian.</li><li><a href=/docs/reference/scheduling/profiles>Profil Penjadwalan</a> yang memungkinkan
kamu mengkonfigurasi <em>Plugin</em> yang menerapkan tahapan penjadwalan berbeda,
termasuk: <code>QueueSort</code>, <code>Filter</code>, <code>Score</code>, <code>Bind</code>, <code>Reserve</code>, <code>Permit</code>, dan
lainnya. Kamu juga bisa mengonfigurasi <em>kube-scheduler</em> untuk menjalankan
profil yang berbeda.</li></ol><h2 id=selanjutnya>Selanjutnya</h2><ul><li>Baca tentang <a href=/id/docs/concepts/scheduling-eviction/scheduler-perf-tuning/>penyetelan performa penjadwal</a></li><li>Baca tentang <a href=/id/docs/concepts/workloads/pods/pod-topology-spread-constraints/>pertimbangan penyebarang topologi pod</a></li><li>Baca <a href=/docs/reference/command-line-tools-reference/kube-scheduler/>referensi dokumentasi</a> untuk <em>kube-scheduler</em></li><li>Pelajari tentang <a href=/docs/tasks/administer-cluster/configure-multiple-schedulers/>mengkonfigurasi beberapa penjadwal</a></li><li>Pelajari tentang <a href=/docs/tasks/administer-cluster/topology-manager/>aturan manajemen topologi</a></li><li>Pelajari tentang <a href=/id/docs/concepts/configuration/pod-overhead/>pengeluaran tambahan Pod</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-602208c95fe7b1f1170310ce993f5814>3.9.6 - Kerangka Kerja Penjadwalan (Scheduling Framework)</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes 1.15 [alpha]</code></div><p>Kerangka kerja penjadwalan (<em>Scheduling Framework</em>) adalah arsitektur yang dapat
dipasang (<em>pluggable</em>) pada penjadwal Kubernetes untuk membuat kustomisasi
penjadwal lebih mudah. Hal itu dilakukan dengan menambahkan satu kumpulan "plugin"
API ke penjadwal yang telah ada. <em>Plugin</em> dikompilasi ke dalam penjadwal.
Beberapa API memungkinkan sebagian besar fitur penjadwalan diimplementasikan
sebagai <em>plugin</em>, sambil tetap mempertahankan penjadwalan "inti" sederhana dan
terpelihara. Silahkan merujuk pada [proposal desain dari kerangka penjadwalan]
<a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-scheduling/20180409-scheduling-framework.md>kep</a> untuk informasi teknis lebih lanjut tentang desain kerangka kerja
tersebut.</p><h1 id=alur-kerja-kerangka-kerja>Alur kerja kerangka kerja</h1><p>Kerangka kerja penjadwalan mendefinisikan beberapa titik ekstensi. <em>Plugin</em> penjadwal
mendaftar untuk dipanggil di satu atau lebih titik ekstensi. Beberapa <em>plugin</em> ini
dapat mengubah keputusan penjadwalan dan beberapa hanya bersifat informasi.</p><p>Setiap upaya untuk menjadwalkan satu Pod dibagi menjadi dua fase, <strong>Siklus Penjadwalan (<em>Scheduling Cycle</em>)</strong> dan <strong>Siklus Pengikatan (<em>Binding Cycle</em>)</strong>.</p><h2 id=siklus-penjadwalan-dan-siklus-pengikatan>Siklus Penjadwalan dan Siklus Pengikatan</h2><p>Siklus penjadwalan memilih sebuah Node untuk Pod, dan siklus pengikatan menerapkan
keputusan tersebut ke klaster. Secara bersama-sama, siklus penjadwalan dan siklus
pengikatan diartikan sebagai sebuah "konteks penjadwalan (<em>scheduling context</em>)".</p><p>Siklus penjadwalan dijalankan secara serial, sementara siklus pengikatan dapat
berjalan secara bersamaan.</p><p>Siklus penjadwalan atau pengikatan dapat dibatalkan jika Pod telah ditentukan
untuk tidak terjadwalkan atau jika terdapat kesalahan internal. Pod akan
dikembalikan ke antrian dan dicoba lagi.</p><h2 id=titik-titik-ekstensi>Titik-titik ekstensi</h2><p>Gambar berikut menunjukkan konteks penjadwalan Pod dan titik-titik ekstensi
yang diperlihatkan oleh kerangka penjadwalan. Dalam gambar ini "Filter"
setara dengan "Predicate" dan "Scoring" setara dengan "Priority Function".</p><p>Satu <em>plugin</em> dapat mendaftar di beberapa titik ekstensi untuk melakukan pekerjaan
yang lebih kompleks atau <em>stateful</em>.</p><figure><img src=/images/docs/scheduling-framework-extensions.png><figcaption><h4>Titik-titik ekstensi dari kerangka kerja Penjadwalan</h4></figcaption></figure><h3 id=queue-sort>QueueSort</h3><p><em>Plugin</em> ini digunakan untuk mengurutkan Pod-Pod dalam antrian penjadwalan. <em>Plugin</em>
QueueSort pada dasarnya menyediakan fungsi <code>Less (Pod1, Pod2)</code>. Hanya satu jenis
<em>plugin</em> QueueSort yang dapat diaktifkan dalam waktu yang bersamaan.</p><h3 id=pre-filter>PreFilter</h3><p><em>Plugin</em> ini digunakan untuk melakukan pra-proses informasi tentang Pod, atau untuk
memeriksa tertentu kondisi yang harus dipenuhi oleh klaster atau Pod. Jika
<em>plugin</em> PreFilter menghasilkan hasil yang salah, siklus penjadwalan dibatalkan.</p><h3 id=filter>Filter</h3><p><em>Plugin</em> ini digunakan untuk menyaring Node yang tidak dapat menjalankan Pod.
Untuk setiap Node, penjadwal akan memanggil <em>plugin</em> Filter sesuai dengan urutan
mereka dikonfigurasi. Jika ada <em>plugin</em> Filter menandai Node menjadi <em>infeasible</em>,
maka <em>plugin</em> yang lainnya tidak akan dipanggil untuk Node itu. Node-Node dapat dievaluasi
secara bersamaan.</p><h3 id=post-filter>PostFilter</h3><p>Plugin ini disebut setelah fase Filter, tetapi hanya ketika tidak ada node yang layak
ditemukan untuk pod. Plugin dipanggil dalam urutan yang dikonfigurasi. Jika
plugin postFilter menandai node sebagai 'Schedulable', plugin yang tersisa
tidak akan dipanggil. Implementasi PostFilter yang khas adalah preemption, yang
mencoba membuat pod dapat di menjadwalkan dengan mendahului Pod lain.</p><h3 id=pre-score>PreScore</h3><p><em>Plugin</em> ini digunakan untuk melakukan pekerjaan "pra-penilaian", yang
menghasilkan keadaan yang dapat dibagi untuk digunakan oleh <em>plugin-plugin</em> Score.
Jika <em>plugin</em> PreScore mengeluarkan hasil salah, maka siklus penjadwalan dibatalkan.</p><h3 id=score>Score</h3><p><em>Plugin</em> ini digunakan untuk menentukan peringkat Node yang telah melewati fase
penyaringan. Penjadwal akan memanggil setiap <em>plugin</em> Score untuk setiap Node.
Akan ada kisaran bilangan bulat yang telah ditetapkan untuk mewakili skor
minimum dan maksimum. Setelah fase <a href=#normalize-scoring>NormalizeScore</a>,
penjadwal akan menggabungkan skor Node dari semua <em>plugin</em> sesuai dengan bobot
<em>plugin</em> yang telah dikonfigurasi.</p><h3 id=normalize-score>NormalizeScore</h3><p><em>Plugin</em> ini digunakan untuk memodifikasi skor sebelum penjadwal menghitung
peringkat akhir Node-Node. <em>Plugin</em> yang mendaftar untuk titik ekstensi ini akan
dipanggil dengan hasil <a href=#score>Score</a> dari <em>plugin</em> yang sama. Hal ini dilakukan
sekali untuk setiap <em>plugin</em> dan setiap siklus penjadwalan.</p><p>Sebagai contoh, anggaplah sebuah <em>plugin</em> <code>BlinkingLightScorer</code> memberi peringkat
pada Node-Node berdasarkan berapa banyak kedipan lampu yang mereka miliki.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>ScoreNode</span>(_ <span style=color:#666>*</span>v1.pod, n <span style=color:#666>*</span>v1.Node) (<span style=color:#0b0;font-weight:700>int</span>, <span style=color:#0b0;font-weight:700>error</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>return</span> <span style=color:#00a000>getBlinkingLightCount</span>(n)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Namun, jumlah maksimum kedipan lampu mungkin kecil jika dibandingkan dengan
<code>NodeScoreMax</code>. Untuk memperbaikinya, <code>BlinkingLightScorer</code> juga harus mendaftar
untuk titik ekstensi ini.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>NormalizeScores</span>(scores <span style=color:#a2f;font-weight:700>map</span>[<span style=color:#0b0;font-weight:700>string</span>]<span style=color:#0b0;font-weight:700>int</span>) {
</span></span><span style=display:flex><span>    highest <span style=color:#666>:=</span> <span style=color:#666>0</span>
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>for</span> _, score <span style=color:#666>:=</span> <span style=color:#a2f;font-weight:700>range</span> scores {
</span></span><span style=display:flex><span>        highest = <span style=color:#00a000>max</span>(highest, score)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>for</span> node, score <span style=color:#666>:=</span> <span style=color:#a2f;font-weight:700>range</span> scores {
</span></span><span style=display:flex><span>        scores[node] = score<span style=color:#666>*</span>NodeScoreMax<span style=color:#666>/</span>highest
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Jika ada <em>plugin</em> NormalizeScore yang menghasilkan hasil yang salah, maka siklus
penjadwalan dibatalkan.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> <em>Plugin</em> yang ingin melakukan pekerjaan "pra-pemesanan" harus menggunakan
titik ekstensi NormalizeScore.</div><h3 id=reserve>Reserve</h3><p>Ini adalah titik ekstensi yang bersifat informasi. <em>Plugin</em> yang mempertahankan
keadaan <em>runtime</em> (alias "<em>stateful plugins</em>") harus menggunakan titik ekstensi ini
untuk diberitahukan oleh penjadwal ketika sumber daya pada suatu Node dicadangkan
untuk Pod yang telah disiapkan. Proses ini terjadi sebelum penjadwal benar-benar
mengikat Pod ke Node, dan itu ada untuk mencegah kondisi balapan (<em>race conditions</em>)
ketika penjadwal menunggu agar pengikatan berhasil.</p><p>Ini adalah langkah terakhir dalam siklus penjadwalan. Setelah Pod berada dalam
status dicadangkan, maka itu akan memicu <em>plugin</em> <a href=#unreserve>Unreserve</a>
(apabila gagal) atau <em>plugin</em> <a href=#post-bind>PostBind</a> (apabila sukses)
di akhir siklus pengikatan.</p><h3 id=permit>Permit</h3><p><em>Plugin</em> Permit dipanggil pada akhir siklus penjadwalan untuk setiap Pod
untuk mencegah atau menunda pengikatan ke Node kandidat. <em>Plugin</em> Permit dapat
melakukan salah satu dari ketiga hal ini:</p><ol><li><p><strong>approve</strong><br>     Setelah semua <em>plugin</em> Permit menyetujui sebuah Pod, Pod tersebut akan dikirimkan untuk diikat.</p></li><li><p><strong>deny</strong><br>     Jika ada <em>plugin</em> Permit yang menolak sebuah Pod, Pod tersebut akan dikembalikan ke
antrian penjadwalan. Hal ini akan memicu <em>plugin</em> <a href=#unreserve>Unreserve</a>.</p></li><li><p><strong>wait</strong> (dengan batas waktu)<br>     Jika <em>plugin</em> Permit menghasilkan "wait", maka Pod disimpan dalam
     daftar Pod "yang menunggu" internal, dan siklus pengikatan Pod ini dimulai tetapi akan langsung diblokir
     sampai mendapatkan <a href=#frameworkhandle><em>approved</em></a>. Jika waktu tunggu habis, ** wait ** menjadi ** deny **
     dan Pod dikembalikan ke antrian penjadwalan, yang memicu <em>plugin</em> <a href=#unreserve>Unreserve</a>.</p></li></ol><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Ketika setiap <em>plugin</em> dapat mengakses daftar Pod-Pod "yang menunggu" dan menyetujuinya
(silahkan lihat <a href=#frameworkhandle><code>FrameworkHandle</code></a>), kami hanya mengharapkan
<em>plugin</em> Permit untuk menyetujui pengikatan Pod dalam kondisi "menunggu" yang
telah dipesan. Setelah Pod disetujui, akan dikirim ke fase <a href=#pre-bind>PreBind</a>.</div><h3 id=pre-bind>PreBind</h3><p><em>Plugin</em> ini digunakan untuk melakukan pekerjaan apa pun yang diperlukan sebelum
Pod terikat. Sebagai contoh, <em>plugin</em> PreBind dapat menyediakan <em>network volume</em>
dan melakukan <em>mounting</em> pada Node target sebelum mengizinkan Pod berjalan di
sana.</p><p>Jika ada <em>plugin</em> PreBind yang menghasilkan kesalahan, maka Pod <a href=#unreserve>ditolak</a>
dan kembali ke antrian penjadwalan.</p><h3 id=bind>Bind</h3><p><em>Plugin</em> ini digunakan untuk mengikat Pod ke Node. <em>Plugin-plugin</em> Bind tidak akan
dipanggil sampai semua <em>plugin</em> PreBind selesai. Setiap <em>plugin</em> Bind dipanggil
sesuai urutan saat dikonfigurasi. <em>Plugin</em> Bind dapat memilih untuk menangani
atau tidak Pod yang diberikan. Jika <em>plugin</em> Bind memilih untuk menangani Pod,
** <em>plugin</em> Bind yang tersisa dilewati **.</p><h3 id=post-bind>PostBind</h3><p>Ini adalah titik ekstensi bersifat informasi. <em>Plugin-plugin</em> PostBind dipanggil
setelah sebuah Pod berhasil diikat. Ini adalah akhir dari siklus pengikatan, dan
dapat digunakan untuk membersihkan sumber daya terkait.</p><h3 id=unreserve>Unreserve</h3><p>Ini adalah titik ekstensi bersifat informasi. Jika sebuah Pod telah dipesan dan
kemudian ditolak di tahap selanjutnya, maka <em>plugin-plugin</em> Unreserve akan
diberitahu. <em>Plugin</em> Unreserve harus membersihkan status yang terkait dengan Pod
yang dipesan.</p><p><em>Plugin</em> yang menggunakan titik ekstensi ini sebaiknya juga harus digunakan
<a href=#unreserve>Reserve</a>.</p><h2 id=plugin-api><em>Plugin</em> API</h2><p>Ada dua langkah untuk <em>plugin</em> API. Pertama, <em>plugin</em> harus mendaftar dan mendapatkan
konfigurasi, kemudian mereka menggunakan antarmuka titik ekstensi. Antarmuka (<em>interface</em>)
titik ekstensi memiliki bentuk sebagai berikut.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a2f;font-weight:700>type</span> Plugin <span style=color:#a2f;font-weight:700>interface</span> {
</span></span><span style=display:flex><span>    <span style=color:#00a000>Name</span>() <span style=color:#0b0;font-weight:700>string</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>type</span> QueueSortPlugin <span style=color:#a2f;font-weight:700>interface</span> {
</span></span><span style=display:flex><span>    Plugin
</span></span><span style=display:flex><span>    <span style=color:#00a000>Less</span>(<span style=color:#666>*</span>v1.pod, <span style=color:#666>*</span>v1.pod) <span style=color:#0b0;font-weight:700>bool</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>type</span> PreFilterPlugin <span style=color:#a2f;font-weight:700>interface</span> {
</span></span><span style=display:flex><span>    Plugin
</span></span><span style=display:flex><span>    <span style=color:#00a000>PreFilter</span>(context.Context, <span style=color:#666>*</span>framework.CycleState, <span style=color:#666>*</span>v1.pod) <span style=color:#0b0;font-weight:700>error</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic>// ...
</span></span></span></code></pre></div><h2 id=konfigurasi-plugin>Konfigurasi <em>plugin</em></h2><p>Kamu dapat mengaktifkan atau menonaktifkan <em>plugin</em> dalam konfigurasi penjadwal.
Jika kamu menggunakan Kubernetes v1.18 atau yang lebih baru, kebanyakan
<a href=/docs/reference/scheduling/profiles/#scheduling-plugins>plugin-plugin penjadwalan</a>
sudah digunakan dan diaktifkan secara bawaan.</p><p>Selain <em>plugin-plugin</em> bawaan, kamu juga dapat mengimplementasikan <em>plugin-plugin</em> penjadwalan
kamu sendiri dan mengonfigurasinya bersama-sama dengan <em>plugin-plugin</em> bawaan.
Kamu bisa mengunjungi <a href=https://github.com/kubernetes-sigs/scheduler-plugins>plugin-plugin penjadwalan</a>
untuk informasi lebih lanjut.</p><p>Jika kamu menggunakan Kubernetes v1.18 atau yang lebih baru, kamu dapat
mengonfigurasi sekumpulan <em>plugin</em> sebagai profil penjadwal dan kemudian menetapkan
beberapa profil agar sesuai dengan berbagai jenis beban kerja. Pelajari lebih
lanjut di <a href=/docs/reference/scheduling/profiles/#multiple-profiles>multi profil</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-d9574a30fcbc631b0d2a57850e161e89>3.9.7 - Penyetelan Kinerja Penjadwal</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.14 [beta]</code></div><p><a href=/id/docs/concepts/scheduling-eviction/kube-scheduler/#kube-scheduler>kube-scheduler</a>
merupakan penjadwal (<em>scheduler</em>) Kubernetes bawaan yang bertanggung jawab
terhadap penempatan Pod-Pod pada seluruh Node di dalam sebuah klaster.</p><p>Node-Node di dalam klaster yang sesuai dengan syarat-syarat penjadwalan dari
sebuah Pod disebut sebagai Node-Node layak (<em>feasible</em>). Penjadwal mencari Node-Node
layak untuk sebuah Pod dan kemudian menjalankan fungsi-fungsi untuk menskor Node-Node tersebut, memilih sebuah Node dengan skor tertinggi di antara
Node-Node layak lainnya, di mana Pod akan dijalankan. Penjadwal kemudian memberitahu
API server soal keputusan ini melalui sebuah proses yang disebut <em>Binding</em>.</p><p>Laman ini menjelaskan optimasi penyetelan (<em>tuning</em>) kinerja yang relevan
untuk klaster Kubernetes berskala besar.</p><p>Pada klaster berskala besar, kamu bisa menyetel perilaku penjadwal
untuk menyeimbangkan hasil akhir penjadwalan antara latensi (seberapa cepat Pod-Pod baru ditempatkan)
dan akurasi (seberapa akurat penjadwal membuat keputusan penjadwalan yang tepat).</p><p>Kamu bisa mengonfigurasi setelan ini melalui pengaturan <code>percentageOfNodesToScore</code> pada kube-scheduler.
Pengaturan KubeSchedulerConfiguration ini menentukan sebuah ambang batas untuk
penjadwalan Node-Node di dalam klaster kamu.</p><h3 id=pengaturan-ambang-batas>Pengaturan Ambang Batas</h3><p>Opsi <code>percentageOfNodesToScore</code> menerima semua angka numerik antara 0 dan 100.
Angka 0 adalah angka khusus yang menandakan bahwa kube-scheduler harus menggunakan
nilai bawaan.
Jika kamu mengatur <code>percentageOfNodesToScore</code> dengan angka di atas 100, kube-scheduler
akan membulatkan ke bawah menjadi 100.</p><p>Untuk mengubah angkanya, sunting berkas konfigurasi kube-scheduler (biasanya <code>/etc/kubernetes/config/kube-scheduler.yaml</code>),
lalu <em>ulang kembali</em> kube-scheduler.</p><p>Setelah kamu selesai menyunting, jalankan perintah</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl get componentstatuses
</span></span></code></pre></div><p>untuk memverifikasi komponen kube-scheduler berjalan dengan baik (<em>healthy</em>). Keluarannya kira-kira seperti ini:</p><pre tabindex=0><code>NAME                 STATUS    MESSAGE             ERROR
controller-manager   Healthy   ok
scheduler            Healthy   ok
...
</code></pre><h2 id=persentase-penskoran-node>Ambang Batas Penskoran Node</h2><p>Untuk meningkatan kinerja penjadwalan, kube-scheduler dapat berhenti mencari
Node-Node yang layak saat sudah berhasil menemukannya. Pada klaster berskala besar,
hal ini menghemat waktu dibandingkan dengan pendekatan awam yang mengecek setiap Node.</p><p>Kamu bisa mengatur ambang batas untuk menentukan berapa banyak jumlah Node minimal yang dibutuhkan, sebagai
persentase bagian dari seluruh Node di dalam klaster kamu. kube-scheduler akan mengubahnya menjadi
bilangan bulat berisi jumlah Node. Saat penjadwalan, jika kube-scheduler mengidentifikasi
cukup banyak Node-Node layak untuk melewati jumlah persentase yang diatur, maka kube-scheduler
akan berhenti mencari Node-Node layak dan lanjut ke [fase penskoran] (/id/docs/concepts/scheduling-eviction/kube-scheduler/#kube-scheduler-implementation).</p><p><a href=#bagaimana-penjadwal-mengecek-node>Bagaimana penjadwal mengecek Node</a> menjelaskan proses ini secara detail.</p><h3 id=ambang-batas-bawaan>Ambang Batas Bawaan</h3><p>Jika kamu tidak mengatur sebuah ambang batas, maka Kubernetes akan
menghitung sebuah nilai menggunakan pendekatan linier, yaitu 50% untuk klaster dengan 100 Node,
serta 10% untuk klaster dengan 5000 Node.</p><p>Artinya, kube-scheduler selalu menskor paling tidak 5% dari klaster kamu, terlepas dari
seberapa besar klasternya, kecuali kamu secara eksplisit mengatur <code>percentageOfNodesToScore</code>
menjadi lebih kecil dari 5.</p><p>Jika kamu ingin penjadwal untuk memasukkan seluruh Node di dalam klaster ke dalam penskoran,
maka aturlah <code>percentageOfNodesToScore</code> menjadi 100.</p><h2 id=contoh>Contoh</h2><p>Contoh konfigurasi di bawah ini mengatur <code>percentageOfNodesToScore</code> menjadi 50%.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubescheduler.config.k8s.io/v1alpha1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>KubeSchedulerConfiguration<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>algorithmSource</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>provider</span>:<span style=color:#bbb> </span>DefaultProvider<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>percentageOfNodesToScore</span>:<span style=color:#bbb> </span><span style=color:#666>50</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=menyetel-percentageofnodestoscore>Menyetel percentageOfNodesToScore</h2><p><code>percentageOfNodesToScore</code> merupakan angka 1 sampai 100 dengan
nilai bawaan yang dihitung berdasarkan ukuran klaster. Di sini juga terdapat
batas bawah yang telah ditetapkan, yaitu 50 Node.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong><p>Pada klaster dengan kurang dari 50 Node layak, penjadwal masih
terus memeriksa seluruh Node karena Node-Node layak belum mencukupi supaya
penjadwal dapat menghentikan proses pencarian lebih awal.</p><p>Pada klaster kecil, jika kamu mengatur <code>percentageOfNodesToScore</code> dengan angka kecil,
pengaturan ini hampir atau sama sekali tidak berpengaruh, karena alasan yang sama.</p><p>Jika klaster kamu punya ratusan Node, gunakan angka bawaan untuk opsi konfigurasi ini.
Mengubah angkanya kemungkinan besar tidak akan mengubah kinerja penjadwal secara berarti.</p></div><p>Sebuah catatan penting yang perlu dipertimbangkan saat mengatur angka ini adalah
ketika klaster dengan jumlah Node sedikit diperiksa untuk kelayakan, beberapa Node
tidak dikirim untuk diskor bagi sebuah Pod. Hasilnya, sebuah Node yang mungkin memiliki
nilai lebih tinggi untuk menjalankan Pod tersebut bisa saja tidak diteruskan ke fase penskoran.
Hal ini berdampak pada penempatan Pod yang kurang ideal.</p><p>Kamu sebaiknya menghindari pengaturan <code>percentageOfNodesToScore</code> menjadi sangat rendah,
agar kube-scheduler tidak seringkali membuat keputusan penempatan Pod yang buruk.
Hindari pengaturan persentase di bawah 10%, kecuali <em>throughput</em> penjadwal sangat penting
untuk aplikasi kamu dan skor dari Node tidak begitu penting. Dalam kata lain, kamu
memilih untuk menjalankan Pod pada Node manapun selama Node tersebut layak.</p><h2 id=bagaimana-penjadwal-mengecek-node>Bagaimana Penjadwal Mengecek Node</h2><p>Bagian ini ditujukan untuk kamu yang ingin mengerti bagaimana fitur ini bekerja secara internal.</p><p>Untuk memberikan semua Node di dalam klaster sebuah kesempatan yang adil untuk
dipertimbangkan dalam menjalankan Pod, penjadwal mengecek Node satu persatu
secara <em>round robin</em>. Kamu dapat membayangkan Node-Node ada di dalam sebuah array.
Penjadwal mulai dari indeks array pertama dan mengecek kelayakan dari Node sampai
jumlahnya telah mencukupi sesuai dengan <code>percentageOfNodesToScore</code>. Untuk Pod berikutnya,
penjadwal melanjutkan dari indeks array Node yang terhenti ketika memeriksa
kelayakan Node-Node untuk Pod sebelumnya.</p><p>Jika Node-Node berada di beberapa zona, maka penjadwal akan mengecek Node satu persatu
pada seluruh zona untuk memastikan bahwa Node-Node dari zona berbeda masuk dalam pertimbangan
kelayakan. Sebagai contoh, ada 6 Node di dalam 2 zona:</p><pre tabindex=0><code>Zona 1: Node 1, Node 2, Node 3, Node 4
Zona 2: Node 5, Node 6
</code></pre><p>Penjadwal mempertimbangkan kelayakan dari Node-Node tersebut dengan urutan berikut:</p><pre tabindex=0><code>Node 1, Node 5, Node 2, Node 6, Node 3, Node 4
</code></pre><p>Setelah semua Node telah dicek, penjadwal akan kembali pada Node 1.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-ac9161c6d952925b083ad9602b4e8e7f>3.10 - Policies</h1></div><div class=td-content><h1 id=pg-a935ff8c59eb116b43494255cc67f69a>3.10.1 - LimitRange</h1><p>Secara bawaan, Container berjalan dengan <a href=/id/docs/user-guide/compute-resources>sumber daya komputasi</a> tanpa batas pada klaster Kubernetes.
Dengan ResourceQuota (kuota sumber daya), administrator klaster dapat membatasi konsumsi dan pembuatan sumber daya berbasis <a class=glossary-tooltip title='Sebuah abstraksi yang digunakan oleh Kubernetes untuk mendukung multipel klaster virtual pada klaster fisik yang sama.' data-toggle=tooltip data-placement=top href=/id/docs/concepts/overview/working-with-objects/namespaces target=_blank aria-label=Namespace>Namespace</a>.
Di dalam Namespace, Pod atau Container dapat mengkonsumsi CPU dan memori sesuai dengan yang ditentukan oleh ResourceQuota pada Namespace tersebut.
Ada kekhawatiran bahwa satu Pod atau Container dapat memonopoli semua sumber daya yang tersedia.
LimitRange (Batas Rentang) adalah kebijakan untuk membatasi alokasi sumber daya (bagi Pod atau Container) pada Namespace.</p><p>LimitRange memberikan batasan (<em>limit</em>) yang dapat:</p><ul><li>Menerapkan penggunaan sumber daya komputasi minimum dan maksimum untuk setiap Pod atau Container dalam Namespace.</li><li>Menerapkan permintaan (<em>request</em>) tempat penyimpanan minimum dan maksimum untuk setiap PersistentVolumeClaim dalam Namespace.</li><li>Menerapkan rasio antara permintaan dan batas untuk sumber daya dalam Namespace.</li><li>Menetapkan permintaan/batas bawaan untuk menghitung sumber daya dalam Namespace dan memasukkannya secara otomatis ke Container pada <em>runtime</em>.</li></ul><h2 id=mengaktifkan-limitrange>Mengaktifkan LimitRange</h2><p>Dukungan LimitRange diaktifkan secara bawaan untuk banyak distribusi Kubernetes. Hal ini
diaktifkan ketika tanda <code>--enable-admission-plugins=</code> pada apiserver memiliki <em>admission controller</em> <code>LimitRanger</code> sebagai
salah satu argumennya.</p><p>LimitRange diberlakukan pada Namespace tertentu ketika ada sebuah objek LimitRange pada Namespace tersebut.</p><p>Nama dari objek LimitRange harus merupakan sebuah <a href=/id/docs/concepts/overview/working-with-objects/names#nama>nama subdomain DNS</a>.</p><h3 id=gambaran-umum-limitrange>Gambaran Umum LimitRange</h3><ul><li>Administrator membuat sebuah LimitRange dalam sebuah Namespace.</li><li>Pengguna membuat sumber daya seperti Pod, Container, dan PersistentVolumeClaim pada namespace.</li><li><em>Admission controller</em> <code>LimitRanger</code> memberlakukan bawaan dan batas untuk semua Pod dan Container yang tidak menetapkan persyaratan sumber daya komputasi dan melacak penggunaannya untuk memastikan agar tidak melebihi minimum, maksimum dan rasio sumber daya yang ditentukan dalam LimitRange yang ada pada Namespace.</li><li>Apabila permintaan membuat atau memperbarui sumber daya (Pod, Container, PersistentVolumeClaim) yang melanggar batasan LimitRange, maka permintaan ke server API akan gagal dengan kode status HTTP <code>403 FORBIDDEN</code> dan sebuah pesan yang menjelaskan batasan yang telah dilanggar.</li><li>Apabila LimitRange diaktifkan pada Namespace untuk menghitung sumber daya seperti <code>cpu</code> dan <code>memory</code>, pengguna harus menentukan permintaan atau batasan untuk nilai-nilai itu. Jika tidak, sistem dapat menolak pembuatan Pod.</li><li>Pelanggaran terhadap LimitRange hanya terjadi pada tahap penerimaan Pod, bukan pada saat Pod sedang berjalan.</li></ul><p>Contoh dari kebijakan yang dapat dibuat dengan menggunakan LimitRange yaitu:</p><ul><li>Dalam klaster dua Node dengan kapasitas 8 GiB RAM dan 16 <em>core</em>, batasan Pod dalam Namespace meminta 100m untuk CPU dengan batas maksimum 500m untuk CPU dan minta 200Mi untuk Memori dengan batas maksimum 600Mi untuk Memori.</li><li>Tetapkan batas bawaan dan permintaan pada 150m untuk CPU dan permintaan standar memori pada 300Mi untuk Container yang dimulai tanpa cpu dan permintaan memori dalam spesifikasi mereka.</li></ul><p>Dalam kasus di mana batas total Namespace kurang dari jumlah batas Pod/Container,
mungkin akan ada perebutan untuk sumber daya. Dalam hal ini, maka Container atau Pod tidak akan dibuat.</p><p>Baik perebutan maupun perubahan pada LimitRange tidak akan mempengaruhi sumber daya yang sudah dibuat.</p><h2 id=selanjutnya>Selanjutnya</h2><p>Silahkan merujuk pada <a href=https://git.k8s.io/community/contributors/design-proposals/resource-management/admission_control_limit_range.md>Dokumen perancangan LimitRanger</a> untuk informasi lebih lanjut.</p><p>Untuk contoh tentang penggunaan batas, lihatlah:</p><ul><li><a href=/docs/tasks/administer-cluster/manage-resources/cpu-constraint-namespace/>Bagaimana cara mengonfigurasi batasan CPU minimum dan maksimum untuk setiap Namespace</a>.</li><li><a href=/docs/tasks/administer-cluster/manage-resources/memory-constraint-namespace/>Bagaimana cara mengonfigurasi batasan memori minimum dan maksimum untuk setiap Namespace</a>.</li><li><a href=/docs/tasks/administer-cluster/manage-resources/cpu-default-namespace/>Bagaimana cara mengonfigurasi permintaan dan batas bawaan CPU untuk setiap Namespace</a>.</li><li><a href=/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/>Bagaimana cara mengonfigurasi permintaan dan batas bawaan memori untuk setiap Namespace</a>.</li><li><a href=/docs/tasks/administer-cluster/limit-storage-consumption/#limitrange-to-limit-requests-for-storage>Bagaimana cara mengonfigurasi konsumsi tempat penyimpanan minimum dan maksimum untuk setiap Namespace</a>.</li><li><a href=/docs/tasks/administer-cluster/quota-memory-cpu-namespace/>Contoh terperinci tentang mengonfigurasi kuota untuk setiap Namespace</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-94ddc6e901c30f256138db11d09f05a3>3.10.2 - Resource Quota</h1><p>Saat beberapa pengguna atau tim berbagi sebuah klaster dengan jumlah Node yang tetap,
ada satu hal yang perlu diperhatikan yaitu suatu tim dapat menggunakan sumber daya
lebih dari jatah yang mereka perlukan.</p><p><em>Resource Quota</em> (kuota sumber daya) adalah sebuah alat yang dapat digunakan oleh
administrator untuk mengatasi hal ini.</p><p>Sebuah Resource Quota, didefinisikan oleh objek API <code>ResourceQuota</code>, menyediakan batasan-batasan
yang membatasi konsumsi gabungan sumber daya komputasi untuk tiap Namespace. Resource Quota dapat
membatasi jumlah objek yang dapat dibuat dalam sebuah Namespace berdasarkan tipenya, maupun jumlah
seluruh sumber daya komputasi yang dapat dipakai oleh sumber daya API (misalnya Pod) di Namespace
tersebut.</p><p>Resource Quota bekerja sebagai berikut:</p><ul><li>Tim-tim berbeda bekerja pada Namespace yang berbeda pula. Sekarang hal ini belum diwajibkan,
tetapi dukungan untuk mewajibkannya melalui ACL sedang direncanakan.</li><li>Administrator membuat sebuah <code>ResourceQuota</code> untuk setiap Namespace.</li><li>Para pengguna membuat sumber daya (Pod, Service, dll.) di dalam Namespace tersebut, kemudian
sistem kuota memantau penggunaan untuk memastikan bahwa penggunaannya tidak melebihi batas
sumber daya yang ditentukan di <code>ResourceQuota</code>.</li><li>Jika pembuatan atau pembaruan sebuah sumber daya melanggar sebuah batasan kuota, maka permintaan
tersebut akan gagal dengan kode status <code>403 FORBIDDEN</code> dengan sebuah pesan yang menjelaskan batasan
yang akan dilanggar.</li><li>Jika kuota diaktifkan di sebuah Namespace untuk sumber daya komputasi seperti <code>cpu</code> dan <code>memory</code>,
pengguna-pengguna harus menentukan <code>requests</code> atau <code>limits</code> untuk sumber daya tersebut; atau sistem
kuota akan menolak pembuatan Pod tersebut. Petunjuk: Gunakan Admission Controller <code>LimitRanger</code> untuk
memaksa nilai-nilai bawaan untuk Pod-Pod yang tidak menentukan kebutuhan sumber daya komputasi.
Lihat <a href=/docs/tasks/administer-cluster/quota-memory-cpu-namespace/>petunjuknya</a> untuk contoh bagaimana
cara menghindari masalah ini.</li></ul><p>Contoh-contoh kebijakan yang dapat dibuat menggunakan Namespace dan kuota adalah:</p><ul><li>Dalam sebuah klaster dengan kapasitas RAM 32 GiB, dan CPU 16 <em>core</em>, misalkan tim A menggunakan 20GiB
dan 10 <em>core</em>, dan tim B menggunakan 10GiB dan 4 <em>core</em>, dan menyimpan 2GiB dan 2 <em>core</em> untuk cadangan
penggunaan di masa depan.</li><li>Batasi Namespace "testing" dengan batas 1 <em>core</em> dan RAM 1GiB. Biarkan Namespace "production" menggunakan
berapapun jumlah yang diinginkan.</li></ul><p>Pada kasus di mana total kapasitas klaster lebih sedikit dari jumlah seluruh kuota di seluruh Namespace,
dapat terjadi perebutan sumber daya komputasi. Masalah ini akan ditangani dengan cara siapa-cepat-dia-dapat.</p><p>Perebutan sumber daya komputasi maupun perubahan kuota tidak akan memengaruhi sumber daya yang sudah dibuat
sebelumnya.</p><h2 id=mengaktifkan-resource-quota>Mengaktifkan Resource Quota</h2><p>Dukungan untuk Resource Quota diaktifkan secara bawaan pada banyak distribusi Kubernetes. Resource Quota
diaktifkan saat <em>flag</em> <code>--enable-admission-plugins=</code> pada apiserver memiliki <code>ResourceQuota</code> sebagai
salah satu nilainya.</p><p>Sebuah Resource Quota akan dipaksakan pada sebuah Namespace tertentu saat ada sebuah objek <code>ResourceQuota</code>
di dalam Namespace tersebut.</p><h2 id=resource-quota-komputasi>Resource Quota Komputasi</h2><p>Kamu dapat membatasi jumlah total <a href=/docs/user-guide/compute-resources>sumber daya komputasi</a> yang dapat
diminta di dalam sebuah Namespace.</p><p>Berikut jenis-jenis sumber daya yang didukung:</p><table><thead><tr><th>Nama Sumber Daya</th><th>Deskripsi</th></tr></thead><tbody><tr><td><code>limits.cpu</code></td><td>Pada seluruh Pod yang berada pada kondisi non-terminal, jumlah <code>limits</code> CPU tidak dapat melebihi nilai ini.</td></tr><tr><td><code>limits.memory</code></td><td>Pada seluruh Pod yang berada pada kondisi non-terminal, jumlah <code>limits</code> memori tidak dapat melebihi nilai ini.</td></tr><tr><td><code>limits.cpu</code></td><td>Pada seluruh Pod yang berada pada kondisi non-terminal, jumlah <code>requests</code> CPU tidak dapat melebihi nilai ini.</td></tr><tr><td><code>limits.memory</code></td><td>Pada seluruh Pod yang berada pada kondisi non-terminal, jumlah <code>requests</code> memori tidak dapat melebihi nilai ini.</td></tr></tbody></table><h3 id=resource-quota-untuk-sumber-daya-yang-diperluas>Resource Quota untuk sumber daya yang diperluas</h3><p>Sebagai tambahan untuk sumber daya yang disebutkan di atas, pada rilis 1.10, dukungan kuota untuk
<a href=/id/docs/concepts/configuration/manage-compute-resources-container/#extended-resources>sumber daya yang diperluas</a> ditambahkan.</p><p>Karena <em>overcommit</em> tidak diperbolehkan untuk sumber daya yang diperluas, tidak masuk akal untuk menentukan
keduanya; <code>requests</code> dan <code>limits</code> untuk sumber daya yang diperluas yang sama pada sebuah kuota. Jadi, untuk
sumber daya yang diperluas, hanya kuota dengan prefiks <code>requests.</code> saja yang diperbolehkan untuk sekarang.</p><p>Mari kita ambil contoh sumber daya GPU. Jika nama sumber dayanya adalah <code>nvidia.com/gpu</code>, dan kamu ingin
membatasi jumlah total GPU yang diminta pada sebuah Namespace menjadi 4, kamu dapat menentukan sebuah kuota
sebagai berikut:</p><ul><li><code>requests.nvidia.com/gpu: 4</code></li></ul><p>Lihat <a href=#melihat-dan-menyetel-kuota>Melihat dan Menyetel Kuota</a> untuk informasi lebih lanjut.</p><h2 id=resource-quota-untuk-penyimpanan>Resource Quota untuk penyimpanan</h2><p>Kamu dapat membatasi jumlah total <a href=/id/docs/concepts/storage/persistent-volumes/>sumber daya penyimpanan</a> yang dapat
diminta pada sebuah Namespace.</p><p>Sebagai tambahan, kamu dapat membatasi penggunaan sumber daya penyimpanan berdasarkan <em>storage class</em>
sumber daya penyimpanan tersebut.</p><table><thead><tr><th>Nama Sumber Daya</th><th>Deskripsi</th></tr></thead><tbody><tr><td><code>requests.storage</code></td><td>Pada seluruh Persistent Volume Claim, jumlah <code>requests</code> penyimpanan tidak dapat melebihi nilai ini.</td></tr><tr><td><code>persistentvolumeclaims</code></td><td>Jumlah kuantitas <a href=/id/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims>Persistent Volume Claim</a> yang dapat ada di dalam sebuah Namespace.</td></tr><tr><td><code>&lt;storage-class-name>.storageclass.storage.k8s.io/requests.storage</code></td><td>Pada seluruh Persistent Volume Claim yang dikaitkan dengan sebuah nama <em>storage-class</em> (melalui kolom <code>storageClassName</code>), jumlah permintaan penyimpanan tidak dapat melebihi nilai ini.</td></tr><tr><td><code>&lt;storage-class-name>.storageclass.storage.k8s.io/persistentvolumeclaims</code></td><td>Pada seluruh Persistent Volume Claim yang dikaitkan dengan sebuah nama <em>storage-class</em> (melalui kolom <code>storageClassName</code>), jumlah kuantitas <a href=/id/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims>Persistent Volume Claim</a> yang dapat ada di dalam sebuah Namespace.</td></tr></tbody></table><p>Sebagai contoh, jika sebuah operator ingin membatasi penyimpanan dengan Storage Class <code>gold</code> yang berbeda dengan Storage Class <code>bronze</code>, maka operator tersebut dapat menentukan kuota sebagai berikut:</p><ul><li><code>gold.storageclass.storage.k8s.io/requests.storage: 500Gi</code></li><li><code>bronze.storageclass.storage.k8s.io/requests.storage: 100Gi</code></li></ul><p>Pada rilis 1.8, dukungan kuota untuk penyimpanan lokal sementara (<em>local ephemeral storage</em>) ditambahkan sebagai
sebuah fitur <em>alpha</em>:</p><table><thead><tr><th>Nama Sumber Daya</th><th>Deskripsi</th></tr></thead><tbody><tr><td><code>requests.ephemeral-storage</code></td><td>Pada seluruh Pod di sebuah Namespace, jumlah <code>requests</code> penyimpanan lokal sementara tidak dapat melebihi nilai ini.</td></tr><tr><td><code>limits.ephemeral-storage</code></td><td>Pada seluruh Pod di sebuah Namespace, jumlah <code>limits</code> penyimpanan lokal sementara tidak dapat melebihi nilai ini.</td></tr></tbody></table><h2 id=kuota-kuantitas-objek>Kuota Kuantitas Objek</h2><p>Rilis 1.9 menambahkan dukungan untuk membatasi semua jenis sumber daya standar yang berada pada sebuah Namespace dengan sintaksis sebagai berikut:</p><ul><li><code>count/&lt;sumber-daya>.&lt;grup></code></li></ul><p>Berikut contoh-contoh sumber daya yang dapat ditentukan pengguna pada kuota kuantitas objek:</p><ul><li><code>count/persistentvolumeclaims</code></li><li><code>count/services</code></li><li><code>count/secrets</code></li><li><code>count/configmaps</code></li><li><code>count/replicationcontrollers</code></li><li><code>count/deployments.apps</code></li><li><code>count/replicasets.apps</code></li><li><code>count/statefulsets.apps</code></li><li><code>count/jobs.batch</code></li><li><code>count/cronjobs.batch</code></li><li><code>count/deployments.extensions</code></li></ul><p>Rilis 1.15 menambahkan dukungan untuk sumber daya <em>custom</em> menggunakan sintaksis yang sama.
Contohnya, untuk membuat kuota pada sumber daya <em>custom</em> <code>widgets</code> pada grup API <code>example.com</code>, gunakan
<code>count/widgets.example.com</code>.</p><p>Saat menggunakan Resource Quota <code>count/*</code>, sebuah objek akan menggunakan kuotanya jika ia berada pada penyimpanan Apiserver.
Tipe-tipe kuota ini berguna untuk menjaga dari kehabisan sumber daya penyimpanan. Misalnya, kamu mungkin
ingin membatasi kuantitas objek Secret pada sebuah Apiserver karena ukuran mereka yang besar. Terlalu banyak
Secret pada sebuah klaster bahkan dapat membuat Server dan Controller tidak dapat dijalankan! Kamu dapat membatasi
jumlah Job untuk menjaga dari CronJob yang salah dikonfigurasi sehingga membuat terlalu banyak Job pada sebuah
Namespace yang mengakibatkan <em>denial of service</em>.</p><p>Sebelum rilis 1.9, kita tidak dapat melakukan pembatasan kuantitas objek generik pada kumpulan sumber daya yang terbatas.
Sebagai tambahan, kita dapat membatasi lebih lanjut sumber daya tertentu dengan kuota berdasarkan jenis mereka.</p><p>Berikut jenis-jenis yang telah didukung:</p><table><thead><tr><th>Nama Sumber Daya</th><th>Deskripsi</th></tr></thead><tbody><tr><td><code>configmaps</code></td><td>Jumlah total ConfigMap yang dapat berada pada suatu Namespace.</td></tr><tr><td><code>persistentvolumeclaims</code></td><td>Jumlah total PersistentVolumeClaim<a href=/id/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims>persistent volume claims</a> yang dapat berada pada suatu Namespace.</td></tr><tr><td><code>pods</code></td><td>Jumlah total Pod yang berada pada kondisi non-terminal yang dapat berada pada suatu Namespace. Sebuah Pod berada kondisi terminal yaitu jika <code>.status.phase in (Failed, Succeded)</code> adalah <code>true</code>.</td></tr><tr><td><code>replicationcontrollers</code></td><td>Jumlah total ReplicationController yang dapat berada pada suatu Namespace.</td></tr><tr><td><code>resourcequotas</code></td><td>Jumlah total <a href=/docs/reference/access-authn-authz/admission-controllers/#resourcequota>ResourceQuota</a> yang dapat berada pada suatu Namespace.</td></tr><tr><td><code>services</code></td><td>Jumlah total Service yang dapat berada pada suatu Namespace.</td></tr><tr><td><code>services.loadbalancers</code></td><td>Jumlah total Service dengan tipe LoadBalancer yang dapat berada pada suatu Namespace.</td></tr><tr><td><code>services.nodeports</code></td><td>Jumlah total Service dengan tipe NodePort yang dapat berada pada suatu Namespace.</td></tr><tr><td><code>secrets</code></td><td>Jumlah total Secret yang dapat berada pada suatu Namespace.</td></tr></tbody></table><p>Sebagai contoh, <code>pods</code> membatasi kuantitas dan memaksa kuantitas maksimum <code>pods</code> yang
berada pada kondisi non-terminal yang dibuat pada sebuah Namespace. Kamu mungkin ingin
menyetel kuota <code>pods</code> pada sebuah Namespace untuk menghindari kasus di mana pengguna membuat
banyak Pod kecil dan menghabiskan persediaan alamat IP Pod pada klaster.</p><h2 id=lingkup-kuota>Lingkup Kuota</h2><p>Setiap kuota dapat memiliki kumpulan lingkup yang dikaitkan. Sebuah kuota hanya akan mengukur penggunaan sebuah
sumber daya jika sumber daya tersebut cocok dengan irisan dari lingkup-lingkup yang ditentukan.</p><p>Saat sebuah lingkup ditambahkan kepada kuota, lingkup itu akan membatasi kuantitas sumber daya yang didukung menjadi yang berkaitan dengan lingkup tersebut.
Sumber daya yang ditentukan pada kuota di luar kumpulan yang diizinkan akan menghasilkan kesalahan validasi.</p><table><thead><tr><th>Lingkup</th><th>Deskripsi</th></tr></thead><tbody><tr><td><code>Terminating</code></td><td>Mencocokkan dengan Pod-Pod yang memiliki <code>.spec.activeDeadlineSeconds >= 0</code></td></tr><tr><td><code>NotTerminating</code></td><td>Mencocokkan dengan Pod-Pod yang memiliki <code>.spec.activeDeadlineSeconds is nil</code></td></tr><tr><td><code>BestEffort</code></td><td>Mencocokkan dengan Pod-Pod yang memiliki <em>quality of service</em> bertipe <em>best effort</em>.</td></tr><tr><td><code>NotBestEffort</code></td><td>Mencocokkan dengan Pod-Pod yang tidak memiliki <em>quality of service</em> bertipe <em>best effort</em>.</td></tr></tbody></table><p>Lingkup <code>BestEffort</code> membatasi sebuah kuota untuk memantau sumber daya berikut: <code>pods</code></p><p>Lingkup <code>Terminating</code>, <code>NotTerminating</code>, dan <code>NotBestEffort</code> membatasi sebuah kuota untuk memantau sumber daya berikut:</p><ul><li><code>cpu</code></li><li><code>limits.cpu</code></li><li><code>limits.memory</code></li><li><code>memory</code></li><li><code>pods</code></li><li><code>requests.cpu</code></li><li><code>requests.memory</code></li></ul><h3 id=resource-quota-per-priorityclass>Resource Quota Per PriorityClass</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes 1.12 [beta]</code></div><p>Pod-Pod dapat dibuat dengan sebuah <a href=/id/docs/concepts/configuration/pod-priority-preemption/#pod-priority>Priority (prioritas)</a> tertentu.
Kamu dapat mengontrol konsumsi sumber daya sistem sebuah Pod berdasarkan Priority Pod tersebut, menggunakan
kolom <code>scopeSelector</code> pada spesifikasi kuota tersebut.</p><p>Sebuah kuota dicocokkan dan digunakan hanya jika <code>scopeSelector</code> pada spesifikasi kuota tersebut memilih Pod tersebut.</p><p>Contoh ini membuat sebuah objek kuota dan mencocokkannya dengan Pod-Pod pada Priority tertentu. Contoh tersebut
bekerja sebagai berikut:</p><ul><li>Pod-Pod di dalam klaster memiliki satu dari tiga Priority Class, "low", "medium", "high".</li><li>Satu objek kuota dibuat untuk setiap Priority.</li></ul><p>Simpan YAML berikut ke sebuah berkas bernama <code>quota.yml</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>List<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ResourceQuota<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pods-high<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hard</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1000&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>200Gi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>pods</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;10&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>scopeSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>operator </span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>scopeName</span>:<span style=color:#bbb> </span>PriorityClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;high&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ResourceQuota<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pods-medium<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hard</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;10&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>20Gi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>pods</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;10&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>scopeSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>operator </span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>scopeName</span>:<span style=color:#bbb> </span>PriorityClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;medium&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ResourceQuota<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pods-low<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hard</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;5&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>10Gi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>pods</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;10&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>scopeSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>operator </span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>scopeName</span>:<span style=color:#bbb> </span>PriorityClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;low&#34;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div><p>Terapkan YAML tersebut dengan <code>kubectl create</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f ./quota.yml
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>resourcequota/pods-high created
</span></span><span style=display:flex><span>resourcequota/pods-medium created
</span></span><span style=display:flex><span>resourcequota/pods-low created
</span></span></code></pre></div><p>Pastikan bahwa kuota <code>Used</code> adalah <code>0</code> dengan <code>kubectl describe quota</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe quota
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>Name:       pods-high
</span></span><span style=display:flex><span>Namespace:  default
</span></span><span style=display:flex><span>Resource    Used  Hard
</span></span><span style=display:flex><span>--------    ----  ----
</span></span><span style=display:flex><span>cpu         <span style=color:#666>0</span>     1k
</span></span><span style=display:flex><span>memory      <span style=color:#666>0</span>     200Gi
</span></span><span style=display:flex><span>pods        <span style=color:#666>0</span>     <span style=color:#666>10</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Name:       pods-low
</span></span><span style=display:flex><span>Namespace:  default
</span></span><span style=display:flex><span>Resource    Used  Hard
</span></span><span style=display:flex><span>--------    ----  ----
</span></span><span style=display:flex><span>cpu         <span style=color:#666>0</span>     <span style=color:#666>5</span>
</span></span><span style=display:flex><span>memory      <span style=color:#666>0</span>     10Gi
</span></span><span style=display:flex><span>pods        <span style=color:#666>0</span>     <span style=color:#666>10</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Name:       pods-medium
</span></span><span style=display:flex><span>Namespace:  default
</span></span><span style=display:flex><span>Resource    Used  Hard
</span></span><span style=display:flex><span>--------    ----  ----
</span></span><span style=display:flex><span>cpu         <span style=color:#666>0</span>     <span style=color:#666>10</span>
</span></span><span style=display:flex><span>memory      <span style=color:#666>0</span>     20Gi
</span></span><span style=display:flex><span>pods        <span style=color:#666>0</span>     <span style=color:#666>10</span>
</span></span></code></pre></div><p>Buat sebuah Pod dengan Priority "high". Simpan YAML berikut ke sebuah
berkas bernama <code>high-priority-pod.yml</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>high-priority<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>high-priority<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>ubuntu<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;/bin/sh&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;while true; do echo hello; sleep 10;done&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;10Gi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;500m&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;10Gi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;500m&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>priorityClassName</span>:<span style=color:#bbb> </span>high<span style=color:#bbb>
</span></span></span></code></pre></div><p>Terapkan dengan <code>kubectl create</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f ./high-priority-pod.yml
</span></span></code></pre></div><p>Pastikan bahwa status "Used" untuk kuota dengan Priority "high", <code>pods-high</code>, telah berubah
dan dua kuota lainnya tidak berubah.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe quota
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>Name:       pods-high
</span></span><span style=display:flex><span>Namespace:  default
</span></span><span style=display:flex><span>Resource    Used  Hard
</span></span><span style=display:flex><span>--------    ----  ----
</span></span><span style=display:flex><span>cpu         500m  1k
</span></span><span style=display:flex><span>memory      10Gi  200Gi
</span></span><span style=display:flex><span>pods        <span style=color:#666>1</span>     <span style=color:#666>10</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Name:       pods-low
</span></span><span style=display:flex><span>Namespace:  default
</span></span><span style=display:flex><span>Resource    Used  Hard
</span></span><span style=display:flex><span>--------    ----  ----
</span></span><span style=display:flex><span>cpu         <span style=color:#666>0</span>     <span style=color:#666>5</span>
</span></span><span style=display:flex><span>memory      <span style=color:#666>0</span>     10Gi
</span></span><span style=display:flex><span>pods        <span style=color:#666>0</span>     <span style=color:#666>10</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Name:       pods-medium
</span></span><span style=display:flex><span>Namespace:  default
</span></span><span style=display:flex><span>Resource    Used  Hard
</span></span><span style=display:flex><span>--------    ----  ----
</span></span><span style=display:flex><span>cpu         <span style=color:#666>0</span>     <span style=color:#666>10</span>
</span></span><span style=display:flex><span>memory      <span style=color:#666>0</span>     20Gi
</span></span><span style=display:flex><span>pods        <span style=color:#666>0</span>     <span style=color:#666>10</span>
</span></span></code></pre></div><p><code>scopeSelector</code> mendukung nilai-nilai berikut pada kolom <code>operator</code>:</p><ul><li><code>In</code></li><li><code>NotIn</code></li><li><code>Exist</code></li><li><code>DoesNotExist</code></li></ul><h2 id=request-vs-limit><em>Request</em> vs Limit</h2><p>Saat mengalokasikan sumber daya komputasi, setiap Container dapat menentukan sebuah nilai <em>request</em> (permintaan) dan limit untuk CPU atau memori.
Kuota tersebut dapat dikonfigurasi untuk membatasi nilai salah satunya.</p><p>Jika kuota tersebut memiliki sebuah nilai yang ditentukan untuk <code>requests.cpu</code> atau <code>requests.memory</code>, maka kuota
tersebut mengharuskan setiap Container yang akan dibuat untuk menentukan request eksplisit untuk sumber daya tersebut.
Jika kuota tersebut memiliki sebuah nilai yang ditentukan untuk <code>limits.cpu</code> atau <code>limits.memory</code>, maka kuota tersebut
mengharuskan setiap Container yang akan dibuat untuk menentukan limit eksplisit untuk sumber daya tersebut.</p><h2 id=melihat-dan-menyetel-kuota>Melihat dan Menyetel kuota</h2><p>Kubectl mendukung membuat, membarui, dan melihat kuota:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create namespace myspace
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt; compute-resources.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: ResourceQuota
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: compute-resources
</span></span></span><span style=display:flex><span><span style=color:#b44>spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>  hard:
</span></span></span><span style=display:flex><span><span style=color:#b44>    requests.cpu: &#34;1&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44>    requests.memory: 1Gi
</span></span></span><span style=display:flex><span><span style=color:#b44>    limits.cpu: &#34;2&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44>    limits.memory: 2Gi
</span></span></span><span style=display:flex><span><span style=color:#b44>    requests.nvidia.com/gpu: 4
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f ./compute-resources.yaml --namespace<span style=color:#666>=</span>myspace
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt; object-counts.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: ResourceQuota
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: object-counts
</span></span></span><span style=display:flex><span><span style=color:#b44>spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>  hard:
</span></span></span><span style=display:flex><span><span style=color:#b44>    configmaps: &#34;10&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44>    persistentvolumeclaims: &#34;4&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44>    pods: &#34;4&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44>    replicationcontrollers: &#34;20&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44>    secrets: &#34;10&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44>    services: &#34;10&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44>    services.loadbalancers: &#34;2&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f ./object-counts.yaml --namespace<span style=color:#666>=</span>myspace
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get quota --namespace<span style=color:#666>=</span>myspace
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME                    AGE
</span></span><span style=display:flex><span>compute-resources       30s
</span></span><span style=display:flex><span>object-counts           32s
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe quota compute-resources --namespace<span style=color:#666>=</span>myspace
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>Name:                    compute-resources
</span></span><span style=display:flex><span>Namespace:               myspace
</span></span><span style=display:flex><span>Resource                 Used  Hard
</span></span><span style=display:flex><span>--------                 ----  ----
</span></span><span style=display:flex><span>limits.cpu               <span style=color:#666>0</span>     <span style=color:#666>2</span>
</span></span><span style=display:flex><span>limits.memory            <span style=color:#666>0</span>     2Gi
</span></span><span style=display:flex><span>requests.cpu             <span style=color:#666>0</span>     <span style=color:#666>1</span>
</span></span><span style=display:flex><span>requests.memory          <span style=color:#666>0</span>     1Gi
</span></span><span style=display:flex><span>requests.nvidia.com/gpu  <span style=color:#666>0</span>     <span style=color:#666>4</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe quota object-counts --namespace<span style=color:#666>=</span>myspace
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>Name:                   object-counts
</span></span><span style=display:flex><span>Namespace:              myspace
</span></span><span style=display:flex><span>Resource                Used    Hard
</span></span><span style=display:flex><span>--------                ----    ----
</span></span><span style=display:flex><span>configmaps              <span style=color:#666>0</span>       <span style=color:#666>10</span>
</span></span><span style=display:flex><span>persistentvolumeclaims  <span style=color:#666>0</span>       <span style=color:#666>4</span>
</span></span><span style=display:flex><span>pods                    <span style=color:#666>0</span>       <span style=color:#666>4</span>
</span></span><span style=display:flex><span>replicationcontrollers  <span style=color:#666>0</span>       <span style=color:#666>20</span>
</span></span><span style=display:flex><span>secrets                 <span style=color:#666>1</span>       <span style=color:#666>10</span>
</span></span><span style=display:flex><span>services                <span style=color:#666>0</span>       <span style=color:#666>10</span>
</span></span><span style=display:flex><span>services.loadbalancers  <span style=color:#666>0</span>       <span style=color:#666>2</span>
</span></span></code></pre></div><p>Kubectl juga mendukung kuota kuantitas objek untuk semua sumber daya standar yang berada pada Namespace
menggunakan sintaksis <code>count/&lt;resource>.&lt;group></code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create namespace myspace
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create quota <span style=color:#a2f>test</span> --hard<span style=color:#666>=</span>count/deployments.extensions<span style=color:#666>=</span>2,count/replicasets.extensions<span style=color:#666>=</span>4,count/pods<span style=color:#666>=</span>3,count/secrets<span style=color:#666>=</span><span style=color:#666>4</span> --namespace<span style=color:#666>=</span>myspace
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl run nginx --image<span style=color:#666>=</span>nginx --replicas<span style=color:#666>=</span><span style=color:#666>2</span> --namespace<span style=color:#666>=</span>myspace
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe quota --namespace<span style=color:#666>=</span>myspace
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>Name:                         <span style=color:#a2f>test</span>
</span></span><span style=display:flex><span>Namespace:                    myspace
</span></span><span style=display:flex><span>Resource                      Used  Hard
</span></span><span style=display:flex><span>--------                      ----  ----
</span></span><span style=display:flex><span>count/deployments.extensions  <span style=color:#666>1</span>     <span style=color:#666>2</span>
</span></span><span style=display:flex><span>count/pods                    <span style=color:#666>2</span>     <span style=color:#666>3</span>
</span></span><span style=display:flex><span>count/replicasets.extensions  <span style=color:#666>1</span>     <span style=color:#666>4</span>
</span></span><span style=display:flex><span>count/secrets                 <span style=color:#666>1</span>     <span style=color:#666>4</span>
</span></span></code></pre></div><h2 id=kuota-dan-kapasitas-klaster>Kuota dan Kapasitas Klaster</h2><p><code>ResourceQuota</code> tidak tergantung pada kapasitas klaster. <code>ResourceQuota</code> ditentukan dalam
satuan-satuan absolut. Jadi, jika kamu menambahkan Node ke klaster kamu, penambahan ini
<strong>bukan</strong> berarti secara otomatis memberikan setiap Namespace kemampuan untuk menggunakan
lebih banyak sumber daya.</p><p>Terkadang kebijakan yang lebih kompleks mungkin lebih diinginkan, seperti:</p><ul><li>Secara proporsional membagi sumber daya total klaster untuk beberapa tim.</li><li>Mengizinkan setiap tim untuk meningkatkan penggunaan sumber daya sesuai kebutuhan,
tetapi tetap memiliki batas yang cukup besar untuk menghindari kehabisan sumber daya.</li><li>Mendeteksi permintaan dari sebuah Namespace, menambah Node, kemudian menambah kuota.</li></ul><p>Kebijakan-kebijakan seperti itu dapat diterapkan dengan <code>ResourceQuota</code> sebagai dasarnya,
dengan membuat sebuah "pengontrol" yang memantau penggunaan kuota dan menyesuaikan batas
keras kuota untuk setiap Namespace berdasarkan sinyal-sinyal lainnya.</p><p>Perlu dicatat bahwa Resource Quota membagi agregat sumber daya klaster, tapi Resource Quota
tidak membuat batasan-batasan terhadap Node: Pod-Pod dari beberapa Namespace boleh berjalan
di Node yang sama.</p><h2 id=membatasi-konsumsi-priority-class-secara-bawaan>Membatasi konsumsi Priority Class secara bawaan</h2><p>Mungkin saja diinginkan untuk Pod-Pod pada kelas prioritas tertentu, misalnya "cluster-services", sebaiknya diizinkan pada sebuah Namespace, jika dan hanya jika terdapat sebuah objek kuota yang cocok.</p><p>Dengan mekanisme ini, operator-operator dapat membatasi penggunaan Priority Class dengan prioritas tinggi pada Namespace-Namespace tertentu saja dan tidak semua Namespace dapat menggunakan Priority Class tersebut secara bawaan.</p><p>Untuk memaksa aturan ini, <em>flag</em> kube-apiserver <code>--admission-control-config-file</code> sebaiknya digunakan untuk memberikan <em>path</em> menuju berkas konfigurasi berikut:</p><ul class="nav nav-tabs" id=example1 role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#example1-0 role=tab aria-controls=example1-0 aria-selected=true>apiserver.config.k8s.io/v1</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#example1-1 role=tab aria-controls=example1-1>apiserver.k8s.io/v1alpha1</a></li></ul><div class=tab-content id=example1><div id=example1-0 class="tab-pane show active" role=tabpanel aria-labelledby=example1-0><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiserver.config.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>AdmissionConfiguration<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>plugins</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;ResourceQuota&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>configuration</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiserver.config.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ResourceQuotaConfiguration<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>limitedResources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>resource</span>:<span style=color:#bbb> </span>pods<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>matchScopes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>scopeName</span>:<span style=color:#bbb> </span>PriorityClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;cluster-services&#34;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div></div><div id=example1-1 class=tab-pane role=tabpanel aria-labelledby=example1-1><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#080;font-style:italic># Kedaluwarsa pada v1.17 digantikan oleh apiserver.config.k8s.io/v1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiserver.k8s.io/v1alpha1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>AdmissionConfiguration<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>plugins</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;ResourceQuota&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>configuration</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># Kedaluwarsa pada v1.17 digantikan oleh apiserver.config.k8s.io/v1, ResourceQuotaConfiguration</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>resourcequota.admission.k8s.io/v1beta1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Configuration<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>limitedResources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>resource</span>:<span style=color:#bbb> </span>pods<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>matchScopes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>scopeName</span>:<span style=color:#bbb> </span>PriorityClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;cluster-services&#34;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Sekarang, Pod-Pod "cluster-services" akan diizinkan hanya pada Namespace di mana ada sebuah objek kuota dengan sebuah <code>scopeSelector</code> yang cocok.</p><p>Contohnya:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>scopeSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>scopeName</span>:<span style=color:#bbb> </span>PriorityClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;cluster-services&#34;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div><p>Lihat <a href=https://github.com/kubernetes/kubernetes/pull/36765>LimitedResources</a> dan <a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/scheduling/pod-priority-resourcequota.md>dokumen desain dukungan Quota untuk Priority Class</a> untuk informasi lebih lanjut.</p><h2 id=contoh>Contoh</h2><p>Lihat <a href=/docs/tasks/administer-cluster/quota-api-object/>contoh detail cara menggunakan sebuah Resource Quota</a>.</p><h2 id=selanjutnya>Selanjutnya</h2><p>Lihat <a href=https://git.k8s.io/community/contributors/design-proposals/resource-management/admission_control_resource_quota.md>dokumen desain ResourceQuota</a> untuk informasi lebih lanjut.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-59977cbac423e20437db079757cb03df>3.10.3 - Pod Security Policy</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.25 [beta]</code></div><p>Pod Security Policies (kebijakan keamanan Pod) memungkinkan otorisasi secara detil dari pembuatan dan pembaruan Pod.</p><h2 id=apa-itu-pod-security-policy>Apa itu Pod Security Policy?</h2><p><em>Pod Security Policy</em> adalah sebuah sumber daya pada tingkat klaster yang mengatur aspek-aspek spesifikasi Pod yang sensitif terhadap keamanan. Objek-objek <code>PodSecurityPolicy</code> mendefinisikan sebuah kumpulan kondisi yang harus dijalankan oleh Pod untuk dapat diterima oleh sistem, dan juga sebagai nilai-nilai bawaan untuk kolom-kolom yang bersangkutan. Mereka memungkinkan administrator untuk mengatur hal-hal berikut:</p><table><thead><tr><th>Aspek yang diatur</th><th>Nama Kolom</th></tr></thead><tbody><tr><td>Menjalankan Container-container yang <em>privileged</em></td><td><a href=#privileged><code>privileged</code></a></td></tr><tr><td>Penggunaan <em>namespace-namespace</em> milik <em>host</em></td><td><a href=#host-namespaces><code>hostPID</code>, <code>hostIPC</code></a></td></tr><tr><td>Penggunaan jaringan dan <em>port</em> milik <em>host</em></td><td><a href=#host-namespaces><code>hostNetwork</code>, <code>hostPorts</code></a></td></tr><tr><td>Penggunaan jenis-jenis Volume</td><td><a href=#volumes-and-file-systems><code>volumes</code></a></td></tr><tr><td>Penggunaan <em>filesystem</em> milik <em>host</em></td><td><a href=#volumes-and-file-systems><code>allowedHostPaths</code></a></td></tr><tr><td>Daftar putih untuk <em>driver-driver</em> Flexvolume</td><td><a href=#flexvolume-drivers><code>allowedFlexVolumes</code></a></td></tr><tr><td>Mengalokasi FSGroup yang memiliki Volume milik Pod</td><td><a href=#volumes-and-file-systems><code>fsGroup</code></a></td></tr><tr><td>Mengharuskan penggunaan <em>read-only root filesystem</em></td><td><a href=#volumes-and-file-systems><code>readOnlyRootFilesystem</code></a></td></tr><tr><td>User dan Grop ID dari Container</td><td><a href=#users-and-groups><code>runAsUser</code>, <code>runAsGroup</code>, <code>supplementalGroups</code></a></td></tr><tr><td>Membatasi eskalasi ke kemampuan <em>root</em></td><td><a href=#privilege-escalation><code>allowPrivilegeEscalation</code>, <code>defaultAllowPrivilegeEscalation</code></a></td></tr><tr><td>Kemampuan-kemampuan Linux</td><td><a href=#capabilities><code>defaultAddCapabilities</code>, <code>requiredDropCapabilities</code>, <code>allowedCapabilities</code></a></td></tr><tr><td>Konteks SELinux dari Container ainer</td><td><a href=#selinux><code>seLinux</code></a></td></tr><tr><td>Jenis tambatan Proc yang diizinkan untuk Container</td><td><a href=#allowedprocmounttypes><code>allowedProcMountTypes</code></a></td></tr><tr><td>Profil AppArmor yang digunakan oleh Container</td><td><a href=#apparmor>annotations</a></td></tr><tr><td>Profil seccomp yang digubakan oleh Container</td><td><a href=#seccomp>annotations</a></td></tr><tr><td>Profil sysctl yang digunakan oleh Container</td><td><a href=#sysctl><code>forbiddenSysctls</code>,<code>allowedUnsafeSysctls</code></a></td></tr></tbody></table><h2 id=mengaktifkan-pod-security-policy>Mengaktifkan Pod Security Policy</h2><p>Pengaturan Pod Security Policy diimplementasi sebagai sebuah opsi (tapi direkomendasikan untuk digunakan) dari <a href=/docs/reference/access-authn-authz/admission-controllers/#podsecuritypolicy><em>admission controller</em></a>. PodSecurityPolicy dilaksanakan dengan <a href=/docs/reference/access-authn-authz/admission-controllers/#how-do-i-turn-on-an-admission-control-plug-in>mengaktifkan <em>admission controller</em>-nya</a>, tetapi melakukan hal ini tanpa mengizinkan kebijakan apapun <strong>akan menghalangi Pod apapun untuk dibuat</strong> di dalam klaster.</p><p>Sejak API dari Pod Security Policy (<code>policy/v1beta1/podsecuritypolicy</code>) diaktifkan secara independen dari <em>admission controller</em>, untuk klaster-klaster yang sudah ada direkomendasikan untuk menambahkan dan mengizinkan kebijakan yang bersangkutan sebelum mengaktifkan <em>admission controller</em> tersebut.</p><h2 id=mengizinkan-kebijakan>Mengizinkan Kebijakan</h2><p>Saat sebuah sumber daya PodSecurityPolicy dibuat, ia tidak melakukan apa-apa. Untuk menggunakannya, <a href=/id/docs/tasks/configure-pod-container/configure-service-account/>Service Account</a> dari pengguna yang memintanya atau target Pod-nya harus diizinkan terlebih dahulu untuk menggunakan kebijakan tersebut, dengan membolehkan kata kerja <code>use</code> terhadap kebijakan tersebut.</p><p>Kebanyakan Pod Kubernetes tidak dibuat secara langsung oleh pengguna. Sebagai gantinya, mereka biasanya dibuat secara tidak langsung sebagai bagian dari sebuah <a href=/id/docs/concepts/workloads/controllers/deployment/>Deployment</a>, <a href=/id/docs/concepts/workloads/controllers/replicaset/>ReplicaSet</a>, atau pengontrol yang sudah ditemplat lainnya melalui Controller Manager. Memberikan akses untuk pengontrol terhadap kebijakan tersebut akan mengizinkan akses untuk <em>semua</em> Pod yang dibuat oleh pengontrol tersebut, sehingga metode yang lebih baik untuk mengizinkan kebijakan adalah dengan memberikan akses pada Service Account milik Pod (lihat <a href=#run-another-pod>contohnya</a>).</p><h3 id=melalui-rbac>Melalui RBAC</h3><p><a href=/id/docs/reference/access-authn-authz/rbac/>RBAC</a> adalah mode otorisasi standar Kubernetes, dan dapat digunakan dengan mudah untuk mengotorisasi penggunaan kebijakan-kebijakan.</p><p>Pertama-tama, sebuah <code>Role</code> atau <code>ClusterRole</code> perlu memberikan akses pada kata kerja <code>use</code> terhadap kebijakan-kebijakan yang diinginkan. <code>rules</code> yang digunakan untuk memberikan akses tersebut terlihat seperti berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>&lt;role name&gt;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#39;policy&#39;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#39;podsecuritypolicies&#39;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>     </span>[<span style=color:#b44>&#39;use&#39;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceNames</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- &lt;list of policies to authorize&gt;<span style=color:#bbb>
</span></span></span></code></pre></div><p>Kemudian, <code>Role</code> atau <code>ClusterRole</code> tersebut diikat ke pengguna-pengguna yang diberikan otoritas.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRoleBinding<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>&lt;binding name&gt;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>roleRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>&lt;role name&gt;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># Mengotorisasi ServiceAccount spesifik</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ServiceAccount<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>&lt;authorized service account name&gt;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>&lt;authorized pod namespace&gt;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># Mengotorisasi User spesifik (tidak direkomendasikan)</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>User<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>&lt;authorized user name&gt;<span style=color:#bbb>
</span></span></span></code></pre></div><p>Jika sebuah <code>RoleBinding</code> (bukan <code>ClusterRoleBinding</code>) digunakan, maka ia hanya akan memberi akses penggunaan untuk Pod-Pod yang dijalankan pada Namespace yang sama dengan <code>RoleBinding</code> tersebut. Hal ini dapat dipasangkan dengan grup sistem untuk memberi akses pada semua Pod yang berjalan di Namespace tersebut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#080;font-style:italic># Mengotorisasi semua ServiceAccount di dalam sebuah Namespace</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Group<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:serviceaccounts<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># Atau secara ekuivalen, semua pengguna yang telah terotentikasi pada sebuah Namespace</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Group<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:authenticated<span style=color:#bbb>
</span></span></span></code></pre></div><p>Untuk lebih banyak contoh pengikatan RBAC, lihat <a href=/id/docs/reference/access-authn-authz/rbac#role-binding-examples>Contoh Role Binding</a>.
Untuk contoh lengkap untuk mengotorisasi sebuah PodSecurityPolicy, lihat <a href=#contoh>di bawah</a>.</p><h3 id=mengatasi-masalah>Mengatasi Masalah</h3><ul><li><a href=/docs/admin/kube-controller-manager/>Controller Manager</a> harus dijalankan terhadap <a href=/docs/reference/access-authn-authz/controlling-access/>port API yang telah diamankan</a>, dan tidak boleh memiliki izin <em>superuser</em>, atau semua permintaan akan melewati modul-modul otentikasi dan otorisasi, semua objek PodSecurityPolicy tidak akan diizinkan, dan semua pengguna dapat membuat Container-container yang <em>privileged</em>. Untuk lebih detil tentang mengkonfigurasi otorisasi Controller Manager, lihat <a href=/id/docs/reference/access-authn-authz/rbac/#controller-roles>Controller Roles</a>.</li></ul><h2 id=urutan-kebijakan>Urutan Kebijakan</h2><p>Sebagai tambahan terhadap membatasi pembuatan dan pembaruan Pod, Pod Security Policy dapat digunakan juga untuk menyediakan nilai-nilai bawaan untuk banyak kolom yang dikontrol olehnya. Saat banyak kebijakan tersedia, pengatur Pod Security Policy memilih kebijakan-kebijakan berdasarkan kriteria berikut:</p><ol><li>PodSecurityPolicy yang mengizinkan Pod apa adanya, tanpa mengganti nilai-nilai bawaan atau memutasi Pod tersebut, akan lebih dipilih. Urutan PodSecurityPolicy yang tidak mengubah Pod ini tidak dipermasalahkan.</li><li>Jika Pod-nya harus diberi nilai bawaan atau dimutasi, maka PodSecurityPolicy pertama (diurutkan berdasarkan namanya) untuk mengizinkan Pod tersebut akan dipilih.</li></ol><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Saat operasi pembaruan (saat ini mutasi terhadap spesifikasi Pod tidak diizinkan) hanya PodSecurityPolicy yang tidak mengubah Pod yang akan digunakan untuk melakukan validasi terhadap Pod tersebut.</div><h2 id=contoh>Contoh</h2><p><em>Contoh ini mengasumsikan kamu telah memiliki klaster yang berjalan dengan <em>admission controller</em> PodSecurityPolicy diaktifkan, dan kamu mempunyai akses admin.</em></p><h3 id=persiapan>Persiapan</h3><p>Mempersiapkan sebuah Namespace dan ServiceAccount untuk digunakan pada contoh ini. Kita akan menggunakan ServiceAccount ini untuk meniru sebuah pengguna bukan admin.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create namespace psp-example
</span></span><span style=display:flex><span>kubectl create serviceaccount -n psp-example fake-user
</span></span><span style=display:flex><span>kubectl create rolebinding -n psp-example fake-editor --clusterrole<span style=color:#666>=</span>edit --serviceaccount<span style=color:#666>=</span>psp-example:fake-user
</span></span></code></pre></div><p>Untuk memperjelas kita bertindak sebagai pengguna yang mana dan mempersingkat ketikan, kita akan membuat 2 alias:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>alias</span> kubectl-admin<span style=color:#666>=</span><span style=color:#b44>&#39;kubectl -n psp-example&#39;</span>
</span></span><span style=display:flex><span><span style=color:#a2f>alias</span> kubectl-user<span style=color:#666>=</span><span style=color:#b44>&#39;kubectl --as=system:serviceaccount:psp-example:fake-user -n psp-example&#39;</span>
</span></span></code></pre></div><h3 id=membuat-sebuah-kebijakan-dan-sebuah-pod>Membuat sebuah kebijakan dan sebuah Pod</h3><p>Beri definisi objek contoh PodSecurityPolicy dalam sebuah berkas. Ini adalah kebijakan yang mencegah pembuatan Pod-Pod yang <em>privileged</em>.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/policy/example-psp.yaml download=policy/example-psp.yaml><code>policy/example-psp.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("policy-example-psp-yaml")' title="Copy policy/example-psp.yaml to clipboard"></img></div><div class=includecode id=policy-example-psp-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>policy/v1beta1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PodSecurityPolicy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>privileged</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># Jangan izinkan Pod-Pod yang _privileged_!</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># Sisanya isi kolom-kolom yang dibutuhkan</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>seLinux</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rule</span>:<span style=color:#bbb> </span>RunAsAny<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>supplementalGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rule</span>:<span style=color:#bbb> </span>RunAsAny<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>runAsUser</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rule</span>:<span style=color:#bbb> </span>RunAsAny<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>fsGroup</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rule</span>:<span style=color:#bbb> </span>RunAsAny<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#39;*&#39;</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Dan buatlah PodSecurityPolicy tersebut dengan <code>kubectl</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl-admin create -f example-psp.yaml
</span></span></code></pre></div><p>Sekarang, sebagai pengguna bukan admin, cobalah membuat Pod sederhana:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl-user create -f- <span style=color:#b44>&lt;&lt;EOF
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: Pod
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name:      pause
</span></span></span><span style=display:flex><span><span style=color:#b44>spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>  containers:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - name:  pause
</span></span></span><span style=display:flex><span><span style=color:#b44>      image: k8s.gcr.io/pause
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span><span style=display:flex><span>Error from server <span style=color:#666>(</span>Forbidden<span style=color:#666>)</span>: error when creating <span style=color:#b44>&#34;STDIN&#34;</span>: pods <span style=color:#b44>&#34;pause&#34;</span> is forbidden: unable to validate against any pod security policy: <span style=color:#666>[]</span>
</span></span></code></pre></div><p><strong>Apa yang terjadi?</strong> Walaupun PodSecurityPolicy tersebut telah dibuat, ServiceAccount dari Pod tersebut maupun <code>fake-user</code> tidak memikiki izin untuk menggunakan kebijakan tersebut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl-user auth can-i use podsecuritypolicy/example
</span></span><span style=display:flex><span>no
</span></span></code></pre></div><p>Membuat RoleBinding untuk memberikan <code>fake-user</code> akses terhadap kata kerja <code>use</code> pada kebijakan contoh kita:</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Ini bukan cara yang direkomendasikan! Lihat <a href=#menjalankan-pod-lainnya>bagian selanjutnya</a> untuk cara yang lebih baik.</div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl-admin create role psp:unprivileged <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    --verb<span style=color:#666>=</span>use <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    --resource<span style=color:#666>=</span>podsecuritypolicy <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    --resource-name<span style=color:#666>=</span>example
</span></span><span style=display:flex><span>role <span style=color:#b44>&#34;psp:unprivileged&#34;</span> created
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl-admin create rolebinding fake-user:psp:unprivileged <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    --role<span style=color:#666>=</span>psp:unprivileged <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    --serviceaccount<span style=color:#666>=</span>psp-example:fake-user
</span></span><span style=display:flex><span>rolebinding <span style=color:#b44>&#34;fake-user:psp:unprivileged&#34;</span> created
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl-user auth can-i use podsecuritypolicy/example
</span></span><span style=display:flex><span>yes
</span></span></code></pre></div><p>Sekarang, ulangi membuat Pod tersebut</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl-user create -f- <span style=color:#b44>&lt;&lt;EOF
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: Pod
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name:      pause
</span></span></span><span style=display:flex><span><span style=color:#b44>spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>  containers:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - name:  pause
</span></span></span><span style=display:flex><span><span style=color:#b44>      image: k8s.gcr.io/pause
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span><span style=display:flex><span>pod <span style=color:#b44>&#34;pause&#34;</span> created
</span></span></code></pre></div><p>Bekerja seperti yang diharapkan! Tapi percobaan apapun untuk membuat Pod yang <em>privileged</em> seharusnya masih ditolak:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl-user create -f- <span style=color:#b44>&lt;&lt;EOF
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: Pod
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name:      privileged
</span></span></span><span style=display:flex><span><span style=color:#b44>spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>  containers:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - name:  pause
</span></span></span><span style=display:flex><span><span style=color:#b44>      image: k8s.gcr.io/pause
</span></span></span><span style=display:flex><span><span style=color:#b44>      securityContext:
</span></span></span><span style=display:flex><span><span style=color:#b44>        privileged: true
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span><span style=display:flex><span>Error from server <span style=color:#666>(</span>Forbidden<span style=color:#666>)</span>: error when creating <span style=color:#b44>&#34;STDIN&#34;</span>: pods <span style=color:#b44>&#34;privileged&#34;</span> is forbidden: unable to validate against any pod security policy: <span style=color:#666>[</span>spec.containers<span style=color:#666>[</span>0<span style=color:#666>]</span>.securityContext.privileged: Invalid value: true: Privileged containers are not allowed<span style=color:#666>]</span>
</span></span></code></pre></div><p>Hapus Pod tersebut sebelum melanjutkan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl-user delete pod pause
</span></span></code></pre></div><h3 id=menjalankan-pod-lainnya>Menjalankan Pod lainnya</h3><p>Mari coba lagi, dengan cara yang sedikit berbeda:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl-user run pause --image<span style=color:#666>=</span>k8s.gcr.io/pause
</span></span><span style=display:flex><span>deployment <span style=color:#b44>&#34;pause&#34;</span> created
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl-user get pods
</span></span><span style=display:flex><span>No resources found.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl-user get events | head -n <span style=color:#666>2</span>
</span></span><span style=display:flex><span>LASTSEEN   FIRSTSEEN   COUNT     NAME              KIND         SUBOBJECT                TYPE      REASON                  SOURCE                                  MESSAGE
</span></span><span style=display:flex><span>1m         2m          <span style=color:#666>15</span>        pause-7774d79b5   ReplicaSet                            Warning   FailedCreate            replicaset-controller                   Error creating: pods <span style=color:#b44>&#34;pause-7774d79b5-&#34;</span> is forbidden: no providers available to validate pod request
</span></span></code></pre></div><p><strong>Apa yang terjadi?</strong> Kita telah mengikat Role <code>psp:unprivileged</code> untuk <code>fake-user</code> kita, kenapa kita mendapatkan kesalahan <code>Error creating: pods "pause-7774d79b5-" is forbidden: no providers available to validate pod request</code>? Jawabannya berada pada sumbernya - <code>replicaset-controller</code>. Fake-user berhasil membuat Deployment tersebut (yang berhasil membuat sebuah ReplicaSet), tetapi saat ReplicaSet tersebut akan membuat Pod, ia tidak terotorisasi untuk menggunakan PodSecurityPolicy contoh tersebut.</p><p>Untuk memperbaikinya, ikatlah Role <code>psp:unprivileged</code> pada ServiceAccount Pod tersebut. Pada kasus ini (karena kita tidak menspesifikasikannya) ServiceAccount-nya adalah <code>default</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl-admin create rolebinding default:psp:unprivileged <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    --role<span style=color:#666>=</span>psp:unprivileged <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    --serviceaccount<span style=color:#666>=</span>psp-example:default
</span></span><span style=display:flex><span>rolebinding <span style=color:#b44>&#34;default:psp:unprivileged&#34;</span> created
</span></span></code></pre></div><p>Sekarang, jika kamu memberi waktu ReplicaSet-nya untuk mencoba kembali, pengatur ReplicaSet tersebut seharusnya akan berhasil membuat Pod tersebut.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl-user get pods --watch
</span></span><span style=display:flex><span>NAME                    READY     STATUS    RESTARTS   AGE
</span></span><span style=display:flex><span>pause-7774d79b5-qrgcb   0/1       Pending   <span style=color:#666>0</span>         1s
</span></span><span style=display:flex><span>pause-7774d79b5-qrgcb   0/1       Pending   <span style=color:#666>0</span>         1s
</span></span><span style=display:flex><span>pause-7774d79b5-qrgcb   0/1       ContainerCreating   <span style=color:#666>0</span>         1s
</span></span><span style=display:flex><span>pause-7774d79b5-qrgcb   1/1       Running   <span style=color:#666>0</span>         2s
</span></span></code></pre></div><h3 id=membersihkan>Membersihkan</h3><p>Hapus Namespace tersebut untuk membersihkan sebagian besar sumber daya yang digunakan dalam contoh ini:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl-admin delete ns psp-example
</span></span><span style=display:flex><span>namespace <span style=color:#b44>&#34;psp-example&#34;</span> deleted
</span></span></code></pre></div><p>Perlu diperhatikan bahwa sumber daya <code>PodSecurityPolicy</code> tidak diberi Namespace, dan harus dibersihkan secara terpisah:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl-admin delete psp example
</span></span><span style=display:flex><span>podsecuritypolicy <span style=color:#b44>&#34;example&#34;</span> deleted
</span></span></code></pre></div><h3 id=contoh-contoh-kebijakan>Contoh-contoh Kebijakan</h3><p>Berikut adalah kebijakan dengan batasan paling sedikit yang dapat kamu buat, ekuivalen dengan tidak menggunakan <em>admission controller</em> Pod Security Policy:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/policy/privileged-psp.yaml download=policy/privileged-psp.yaml><code>policy/privileged-psp.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("policy-privileged-psp-yaml")' title="Copy policy/privileged-psp.yaml to clipboard"></img></div><div class=includecode id=policy-privileged-psp-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>policy/v1beta1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PodSecurityPolicy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>privileged<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>seccomp.security.alpha.kubernetes.io/allowedProfileNames</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;*&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>privileged</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>allowPrivilegeEscalation</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>allowedCapabilities</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#39;*&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#39;*&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostNetwork</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostPorts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>min</span>:<span style=color:#bbb> </span><span style=color:#666>0</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>max</span>:<span style=color:#bbb> </span><span style=color:#666>65535</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostIPC</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostPID</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>runAsUser</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rule</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;RunAsAny&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>seLinux</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rule</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;RunAsAny&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>supplementalGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rule</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;RunAsAny&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>fsGroup</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rule</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;RunAsAny&#39;</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Berikut adalah sebuah contoh kebijakan yang restriktif yang mengharuskan pengguna-pengguna untuk berjalan sebagai pengguna yang <em>unprivileged</em>, memblokir kemungkinan eskalasi menjadi <em>root</em>, dan mengharuskan penggunaan beberapa mekanisme keamanan.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/policy/restricted-psp.yaml download=policy/restricted-psp.yaml><code>policy/restricted-psp.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("policy-restricted-psp-yaml")' title="Copy policy/restricted-psp.yaml to clipboard"></img></div><div class=includecode id=policy-restricted-psp-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>policy/v1beta1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PodSecurityPolicy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>restricted<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>seccomp.security.alpha.kubernetes.io/allowedProfileNames</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;docker/default,runtime/default&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apparmor.security.beta.kubernetes.io/allowedProfileNames</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;runtime/default&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>seccomp.security.alpha.kubernetes.io/defaultProfileName</span>:<span style=color:#bbb>  </span><span style=color:#b44>&#39;runtime/default&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apparmor.security.beta.kubernetes.io/defaultProfileName</span>:<span style=color:#bbb>  </span><span style=color:#b44>&#39;runtime/default&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>privileged</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># Dibutuhkan untuk menghindari eskalasi ke _root_.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>allowPrivilegeEscalation</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># Hal ini berlebihan dengan _non-root_ + melarang eskalasi _privilege_,</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># tetapi kita dapat menyediakannya untuk _defense in depth_</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>requiredDropCapabilities</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- ALL<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># Izinkan tipe-tipe volume inti.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#b44>&#39;configMap&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#b44>&#39;emptyDir&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#b44>&#39;projected&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#b44>&#39;secret&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#b44>&#39;downwardAPI&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># Berasumsi bahwa persistentVolumes yang disetel oleh admin klaster aman untuk digunakan.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#b44>&#39;persistentVolumeClaim&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostNetwork</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostIPC</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostPID</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>runAsUser</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># Mengharuskan container untuk berjalan tanpa hak sebagai _root_.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rule</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;MustRunAsNonRoot&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>seLinux</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># Kebijakan ini mengasumsikan bahwa node-node menggunakan AppArmor daripada SELinux.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rule</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;RunAsAny&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>supplementalGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rule</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;MustRunAs&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ranges</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># Larang menambahkan grup _root_.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>min</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>max</span>:<span style=color:#bbb> </span><span style=color:#666>65535</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>fsGroup</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rule</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;MustRunAs&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ranges</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># Larang menambahkan grup _root_.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>min</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>max</span>:<span style=color:#bbb> </span><span style=color:#666>65535</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>readOnlyRootFilesystem</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><h2 id=referensi-kebijakan>Referensi Kebijakan</h2><h3 id=privileged>Privileged</h3><p><strong>Privileged</strong> - menentukan bila Container manapun di dalam sebuah Pod dapat mengaktifkan mode <em>privileged</em>. Secara bawaan, sebuah Container tidak diizinkan untuk mengakses perangkat apapun pada <em>host</em>-nya, tapi sebuah Container yang "<em>privileged</em>" akan diberikan akses untuk semua perangkat pada <em>host</em>-nya. Hal ini mengizinkan hampir semua akses yang sama dengan proses yang berjalan pada <em>host</em> kepada Container tersebut. Hal ini berfungsi untuk Container-container yang ingin menggunakan kemampuan Linux seperti memanipulasi <em>network stack</em> atau mengakses perangkat-perangkat.
determines if any container in a pod can enable privileged mode.</p><h3 id=namespace-host>Namespace Host</h3><p><strong>HostPID</strong> - Mengatur jika Container-container pada Pod dapat berbagi <em>namespace process ID</em> pada <em>host</em>. Catatlah bahwa saat dipasangkan dengan ptrace, hal ini dapat digunakan untuk eskalasi <em>privilege</em> di luar kontainer (ptrace secara bawaan tidak diizinkan).</p><p><strong>HostIPC</strong> - Mengatur jika container-container pada Pod dapat berbagi <em>namespace IPC</em> pada <em>host</em>.</p><p><strong>HostNetwork</strong> - Mengatur jika Pod dapat menggunakan <em>namespace</em> jaringan pada <em>host</em>. Melakukan hal ini akan memberikan Pod akses pada perangkat <em>loopback</em>, <em>service</em> yang sedang <em>listening</em> pada <em>localhost</em>, dan dapat digunakan untuk mengintai aktivitas jaringan pada Pod-Pod lain pada Node yang sama.</p><p><strong>HostPorts</strong> - Memberikan daftar putih dari berbagai <em>port</em> yang diizinkan pada <em>namespace</em> jaringan pada <em>host</em>. Hal ini didefinisikan sebagai sebuah daftar <code>HostPortRange</code>, dengan <code>min</code>(inklusif) dan <code>max</code>(inklusif). Nilai bawaannya adalah tidak ada <em>host port</em> yang diizinkan.</p><p><strong>AllowedHostPaths</strong> - Lihat <a href=#volumes-dan-file-systems>Volume dan <em>file systems</em></a>.</p><h3 id=volume-dan-file-system>Volume dan <em>file system</em></h3><p><strong>Volume</strong> - Menyediakan sebuah daftar putih dari tipe-tipe Volume yang diizinkan. Nilai-nilai yang diizinkan sesuai dengan sumber Volume yang didefinisikan saat membuat sebuah Volume. Untuk daftar lengkap tipe-tipe Volume, lihat <a href=/id/docs/concepts/storage/volumes/#tipe-tipe-volume>tipe-tipe Volume</a>. Sebagai tambahan, <code>*</code> dapat digunakan untuk mengizinkan semua tipe Volume.</p><p><strong>Kumpulan Volume-volume minimal yang direkomendasikan</strong> untuk PodSecurityPolicy baru adalah sebagai berikut:</p><ul><li>configMap</li><li>downwardAPI</li><li>emptyDir</li><li>persistentVolumeClaim</li><li>secret</li><li>projected</li></ul><div class="alert alert-danger warning callout" role=alert><strong>Peringatan:</strong> PodSecurityPolicy tidak membatasi tipe-tipe objek <code>PersistentVolume</code> yang dapat direferensikan oleh <code>PersistentVolumeClaim</code>. Hanya pengguna-pengguna yang dipercaya yang boleh diberikan izin untuk membuat objek-objek <code>PersistentVolume</code>.</div><p><strong>FSGroup</strong> - Mengatur grup tambahan yang dipasang ke beberapa volume.</p><ul><li><em>MustRunAs</em> - Membutuhkan setidaknya satu <code>range</code> untuk dapat ditentukan. Menggunakan semua nilai minimum dari <code>range</code> yang pertama sebagai nilai bawaannya. Memvalidasikan terhadap semua <code>range</code>.</li><li><em>MayRunAs</em> - Membutuhkan setidaknya satu <code>range</code> untuk dapat ditentukan. Mengizinkan <code>FSGroups</code> dibiarkan kosong tanpa memberikan nilai bawaan. Memvalidasikan terhadap semua <code>range</code> jika nilai <code>FSGroups</code> disetel.</li><li><em>RunAsAny</em> - Tidak ada nilai bawaan yang diberikan. Mengizinkan ID <code>fsGroup</code> apapun untuk digunakan.</li></ul><p><strong>AllowedHostPaths</strong> - Memperinci sebuah daftar putih dari <em>host path</em> yang diizinkan untuk digunakan oleh volume-volume <code>hostPath</code>. Sebuah daftar kosong berarti tidak ada pembatasan pada <em>host path</em> yang digunakan. Hal ini didefinisikan sebagai sebuah daftar objek-objek dengan sebuah kolom <code>pathPrefix</code>, yang mengizinkan volume-volume <code>hostPath</code> untuk menambatkan sebuah <em>path</em> yang dimulai dengan sebuah prefiks yang diizinkan, dan sebuah kolom <code>readOnly</code> yang menunjukkan bahwa ia harus ditambatkan sebagai <em>read-only</em>.
Misalnya:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>allowedHostPaths</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># Hal ini mengizinkan &#34;/foo&#34;, &#34;/foo/&#34;, &#34;/foo/bar&#34; dll., tetapi</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># melarang &#34;/fool&#34;, &#34;/etc/foo&#34; dll.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># &#34;/foo/../&#34; tidak sah.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>pathPrefix</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/foo&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># Izinkan hanya tambatan _read-only_</span><span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-danger warning callout" role=alert><strong>Peringatan:</strong><p>Ada banyak cara bagi sebuah Container dengan akses yang tidak dibatasi terhadap <em>host filesystem</em>-nya untuk dapat melakukan eskalasi <em>privilege</em>, termasuk membaca data dari Container-container lain, dan menyalahgunakan kredensial dari <em>service-service</em> sistem, misalnya Kubelet.</p><p>Direktori volume <code>hostPath</code> yang dapat ditulis mengizinkan container-container untuk menulis ke <em>filesystem</em> melalui cara-cara yang membiarkan mereka melintasi <em>host filesystem</em> di luar <code>pathPrefix</code> yang bersangkutan.
<code>readOnly: true</code>, tersedia pada Kubernetes 1.11 ke atas, harus digunakan pada <strong>semua</strong> <code>allowedHostPaths</code> untuk secara efektif membatasi akses terhadap <code>pathPrefix</code> yang diperinci.</p></div><p><strong>ReadOnlyRootFilesystem</strong> - Mengharuskan container-container berjalan dengan sebuah <em>root filesystem</em> yang bersifat <em>read-only</em> (yaitu, tanpa lapisan yang dapat ditulis)</p><h3 id=driver-driver-flexvolume><em>Driver-driver</em> Flexvolume</h3><p>Hal ini memperinci sebuah daftar putih dari <em>driver-driver</em> Flexvolume yang diizinkan untuk digunakan oleh Flexvolume. Sebuah daftar kosong atau <code>nil</code> berarti tidak ada batasan terhadap <em>driver-driver</em> tersebut.
Pastikan kolom <a href=#volume-dan-file-system><code>volumes</code></a> berisi tipe volumenya; Jika tidak, tidak ada <em>driver</em> Flexvolume yang diizinkan.</p><p>Misalnya:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>policy/v1beta1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PodSecurityPolicy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>allow-flex-volumes<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># ... kolom kolom lainnya</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- flexVolume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>allowedFlexVolumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>driver</span>:<span style=color:#bbb> </span>example/lvm<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>driver</span>:<span style=color:#bbb> </span>example/cifs<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=pengguna-dan-grup>Pengguna dan Grup</h3><p><strong>RunAsUser</strong> - Mengatur ID pengguna mana yang digunakan untuk menjalankan container-container.</p><ul><li><em>MustRunAs</em> - Membutuhkan setidaknya satu <code>range</code> untuk dapat ditentukan. Menggunakan semua nilai minimum dari <code>range</code> yang pertama sebagai nilai bawaannya. Memvalidasikan terhadap semua <code>range</code>.</li><li><em>MustRunAsNonRoot</em> - Mengharuskan Pod diajukan dengan nilai <code>runAsUser</code> yang bukan nol, atau memiliki petunjuk <code>USER</code> didefinisikan (dengan UID numerik) di dalam <em>image</em>. Pod-Pod yang belum memperinci <code>runAsNonRoot</code> atau <code>runAsUser</code> akan dimutasikan untuk menyetel <code>runAsNonRoot=true</code> sehingga membutuhkan petunjuk <code>USER</code> dengan nilai numerik bukan nol di dalam Container. Tidak ada nilai bawaan yang diberikan. Menyetel <code>allowPrivilegeEscalation=false</code> sangat disarankan dengan strategi ini.</li><li><em>RunAsAny</em> - Tidak ada nilai bawaan yang diberikan. Mengizinkan <code>runAsUser</code> apapun untuk digunakan.</li></ul><p><strong>RunAsGroup</strong> - Mengatur ID grup primer mana yang digunakan untuk menjalankan Container-container.</p><ul><li><em>MustRunAs</em> - Membutuhkan setidaknya satu <code>range</code> untuk dapat ditentukan. Menggunakan semua nilai minimum dari <code>range</code> yang pertama sebagai nilai bawaannya. Memvalidasikan terhadap semua <code>range</code>.</li><li><em>MayRunAs</em> - Tidak memerlukan <code>RunAsGroup</code> untuk diperinci. Tetapi, saat <code>RunAsGroup</code> diperinci, mereka harus berada pada <code>range</code> yang didefinisikan.</li><li><em>RunAsAny</em> - Tidak ada nilai bawaan yang diberikan. Mengizinkan <code>runAsGroup</code> apapun untuk digunakan.</li></ul><p><strong>SupplementalGroups</strong> - Mengatur ID grup mana saja yang ditambah ke Container-container.</p><ul><li><em>MustRunAs</em> - Membutuhkan setidaknya satu <code>range</code> untuk dapat ditentukan. Menggunakan semua nilai minimum dari <code>range</code> yang pertama sebagai nilai bawaannya. Memvalidasikan terhadap semua <code>range</code>.</li><li><em>MayRunAs</em> - Membutuhkan setidaknya satu <code>range</code> untuk dapat ditentukan. Mengizinkan <code>supplementalGroups</code> dibiarkan kosong tanpa memberikan nilai bawaan. Memvalidasikan terhadap semua <code>range</code> jika nilai <code>supplementalGroup</code> disetel.</li><li><em>RunAsAny</em> - Tidak ada nilai bawaan yang diberikan. Mengizinkan ID <code>supplementalGroups</code> apapun untuk digunakan.</li></ul><h3 id=eskalasi-privilege>Eskalasi <em>Privilege</em></h3><p>Opsi ini mengatur opsi Container <code>allowPrivilegeEscalation</code>. Nilai <code>bool</code> ini secara langsung mengatur apakah <em>flag</em> <a href=https://www.kernel.org/doc/Documentation/prctl/no_new_privs.txt><code>no_new_privs</code></a> disetel pada proses Container tersebut. <em>Flag</em> ini akan mencegah program <code>setuid</code> mengganti ID pengguna efektif, dan mencegah berkas-berkas untuk memungkinkan kemampuan tambahan (misalnya, ini akan mencagah penggunaan peralatan <code>ping</code>). Perilaku ini dibutuhkan untuk memaksakan <code>MustRunAsNonRoot</code>.</p><p><strong>AllowPrivilegeEscalation</strong> - Membatasi apakah seorang pengguna diizinkan untuk menyetel konteks keamanan dari sebuah Container menjadi <code>allowPrivilegeEscalation=true</code>. Hal ini memiliki nilai bawaan untuk diizinkan, agar tidak merusak program <code>setuid</code>. Menyetel ini menjadi <code>false</code> memastikan bahwa tidak ada proses <em>child</em> dari sebuah Container dapat memperoleh lebih banyak <em>privilege</em> dari <em>parent</em>-nya.</p><p><strong>DefaultAllowPrivilegeEscalation</strong> - Menyetel nilai bawaan untuk opsi <code>allowPrivilegeEscalation</code>. Perilaku bawaan tanpa hal ini adalah untuk mengizinkan eskalasi <em>privilege</em> agar tidak merusak program <code>setuid</code>. Jika perilaku ini tidak diinginkan, kolom ini dapat digunakan untuk menyetel nilai bawaan <code>allowPrivilegeEscalation</code> agar melarang eskalasi, sementara masih mengizinkan Pod-Pod untuk meminta <code>allowPrivilegeEscalation</code> secara eksplisit.</p><h3 id=kemampuan-kemampuan>Kemampuan-kemampuan</h3><p>Kemampuan-kemampuan Linux menyediakan perincian yang detail dari <em>privilege-privilege</em> yang biasa dikaitkan dengan <code>superuser</code>. Beberapa dari kemampuan-kemampuan ini dapat digunakan untuk mengeskalasi <em>privilege-privilege</em> atau untuk <em>container breakout</em>, dan dapat dibatasi oleh PodSecurityPolicy. Untuk lebih lanjut tentang kemampuan-kemampuan Linux, lihat <a href=http://man7.org/linux/man-pages/man7/capabilities.7.html>capabilities(7)</a>.</p><p>Kolom-kolom berikut mengambil daftar kemampuan-kemampuan, diperincikan sebagai nama kemampuannya dalam ALL_CAPS tanpa awalan <code>CAP_</code>.</p><p><strong>AllowedCapabilities</strong> - Menyediakan sebuah daftar putih dari kemampuan-kemampuan yang dapat ditambahkan pada sebuah Container. Kumpulan kemampuan bawaan secara implisit diizinkan. Kumpulan kosong berarti tidak ada kemampuan tambahan yang dapat ditambahkan selain bawaannya. <code>*</code> dapat digunakan untuk mengizinkan semua kemampuan.</p><p><strong>RequiredDropCapabilities</strong> - Kemampuan-kemampuan yang harus dihapus dari Container-container. Kemampuan-kemampuan ini dihapus dari kumpulan bawaan, dan tidak boleh ditambahkan. Kemampuan-kemampuan yang terdaftar di <code>RequiredDropCapabilities</code> tidak boleh termasuk di dalam <code>AllowedCapabilities</code> atau <code>DefaultAddCapabilities</code>.</p><p><strong>DefaultAddCapabilities</strong> - Kemampuan-kemampuan yang ditambahkan pada Container-container secara bawaan, sebagai tambahan untuk bawaan <em>runtime</em>. Lihat <a href=https://docs.docker.com/engine/reference/run/#runtime-privilege-and-linux-capabilities>dokumentasi Docker</a> untuk daftar kemampuan bawaan saat menggunakan <em>runtime</em> Docker.</p><h3 id=selinux>SELinux</h3><ul><li><em>MustRunAs</em> - Mengharuskan penyetelan <code>seLinuxOptions</code>. Menggunakan <code>seLinuxOptions</code> sebagai nilai bawaannya. Memvalidasi terhadap <code>seLinuxOptions</code>.</li><li><em>RunAsAny</em> - Tidak ada nilai bawaan yang disediakan. Mengizinkan nilai <code>seLinuxOptions</code> apapun untuk diberikan.</li></ul><h3 id=allowedprocmounttypes>AllowedProcMountTypes</h3><p><code>allowedProcMountTypes</code> adalah sebuah daftar putih dari ProcMountType yang diizinkan. Nilai kosong atau <code>nil</code> menunjukkan bahwa hanya <code>DefaultProcMountType</code> yang boleh digunakan.</p><p><code>DefaultProcMount</code> menggunakan nilai bawaan <em>container runtime</em> untuk <em>readonly</em> dan <em>masked paths</em> untuk <code>/proc</code>. Kebanyakan <em>runtime</em> Container melakukan <em>mask</em> terhadap beberapa <em>path</em> di dalam <code>/proc</code> untuk menghindari <em>security exposure</em> dari perangkat-perangkat atau informasi khusus yang tidak disengaja. Hal ini ditandai dengan nilai <em>string</em> <code>Default</code>.</p><p>Satu-satunya ProcMountType lainnya adalah <code>UnmaskedProcMount</code>, yang melangkahi perilaku <em>masking</em> bawaan dari <em>runtime</em> Container dan memastikan bahwa <code>/proc</code> yang baru dibuat tetap utuh tanpa perubahan. Hal ini ditandai dengan nilai <em>string</em> <code>Unmasked</code>.</p><h3 id=apparmor>AppArmor</h3><p>Diatur melalui anotasi pada PodSecurityPolicy. Lihat <a href=/docs/tutorials/clusters/apparmor/#podsecuritypolicy-annotations>dokumentasi AppArmor</a>.</p><h3 id=seccomp>Seccomp</h3><p>Penggunaan profil-profil <em>seccomp</em> di dalam Pod-Pod dapat diatur melalui anotasi pada PodSecurityPolicy.
<em>Seccomp</em> adalah fitur <em>Alpha</em> di Kubernetes.</p><p><strong>seccomp.security.alpha.kubernetes.io/defaultProfileName</strong> - Anotasi yang menunjukkan profil <em>seccomp</em> bawaan untuk diterapkan kepada container-container. Nilai-nilai yang mungkin adalah:</p><ul><li><code>unconfined</code> - <em>Seccomp</em> tidak diterapkan pada proses-proses di container (ini adalah bawaan di Kubernetes), jika tidak ada alternatif yang diberikan.</li><li><code>runtime/default</code> - Profil <em>runtime</em> container bawaan digunakan.</li><li><code>docker/default</code> - Profil bawaan <em>seccomp</em> Docker digunakan. Sudah kedaluwarsa sejak Kubernetes 1.11. Gunakan <code>runtime/default</code> sebagai gantinya.</li><li><code>localhost/&lt;path></code> - Menentukan sebuah profil sebagai sebuah berkas pada Node yang berlokasi pada <code>&lt;seccomp_root>/&lt;path></code>, di mana <code>&lt;seccomp_root></code> didefinisikan melalui <em>flag</em> <code>--seccomp-profile-root</code> pada Kubelet.</li></ul><p><strong>seccomp.security.alpha.kubernetes.io/allowedProfileNames</strong> - Anotasi yang menunjukkan nilai-nilai mana yang diizinkan untuk anotasi <em>seccomp</em> pada Pod. Ditentukan sebagai sebuah daftar nilai yang diizinkan yang dibatasi dengan tanda koma. Nilai-nilai yang dimungkinkan adalah yang terdaftar di atas, ditambah dengan <code>*</code> untuk mengizinkan semua profil. Ketiadaan anotasi ini berarti nilai bawaannya tidak dapat diubah.</p><h3 id=sysctl>Sysctl</h3><p>Secara bawaan, semua <em>sysctl</em> yang aman diizinkan.</p><ul><li><code>forbiddenSysctls</code> - mengecualikan <em>sysctl-sysctl</em> tertentu. Kamu dapat melarang kombinasi dari <em>sysctl-sysctl</em> yang aman maupun tidak aman pada daftar ini. Untuk melarang menyetel <em>sysctl</em> apapun, gunakan nilai <code>*</code>.</li><li><code>allowedUnsafeSysctls</code> - mengizinkan <em>sysctl-sysctl</em> tertentu yang telah dilarang oleh daftar bawaan, selama nilainya tidak terdaftar di dalam <code>forbiddenSysctls</code>.</li></ul><p>Lihat <a href=/docs/concepts/cluster-administration/sysctl-cluster/#podsecuritypolicy>dokumentasi Sysctl</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-285a3785fd3d20f437c28d87ca4dadca>3.11 - Administrasi Klaster</h1></div><div class=td-content><h1 id=pg-fb494ea3b1874bd753dcd11c3f35c2dc>3.11.1 - Ikhtisar Administrasi Klaster</h1><p>Ikhtisar administrasi klaster ini ditujukan untuk siapapun yang akan membuat atau mengelola klaster Kubernetes.
Diharapkan untuk memahami beberapa <a href=/docs/concepts/>konsep</a> dasar Kubernetes sebelumnya.</p><h2 id=perencanaan-klaster>Perencanaan Klaster</h2><p>Lihat panduan di <a href=/docs/setup>Persiapan</a> untuk mempelajari beberapa contoh tentang bagaimana merencanakan, mengatur dan mengonfigurasi klaster Kubernetes. Solusi yang akan dipaparkan di bawah ini disebut <em>distro</em>.</p><p>Sebelum memilih panduan, berikut adalah beberapa hal yang perlu dipertimbangkan:</p><ul><li>Apakah kamu hanya ingin mencoba Kubernetes pada komputermu, atau kamu ingin membuat sebuah klaster dengan <em>high-availability</em>, <em>multi-node</em>? Pilihlah distro yang paling sesuai dengan kebutuhanmu.</li><li><strong>Jika kamu merencanakan klaster dengan <em>high-availability</em></strong>, pelajari bagaimana cara mengonfigurasi <a href=/id/docs/concepts/cluster-administration/federation/>klaster pada <em>multiple zone</em></a>.</li><li>Apakah kamu akan menggunakan <strong>Kubernetes klaster di <em>hosting</em></strong>, seperti <a href=https://cloud.google.com/kubernetes-engine/>Google Kubernetes Engine</a>, atau <strong><em>hosting</em> sendiri klastermu</strong>?</li><li>Apakah klastermu berada pada <strong><em>on-premises</em></strong>, atau <strong>di cloud (IaaS)</strong>? Kubernetes belum mendukung secara langsung klaster hibrid. Sebagai gantinya, kamu dapat membuat beberapa klaster.</li><li><strong>Jika kamu ingin mengonfigurasi Kubernetes <em>on-premises</em></strong>, pertimbangkan <a href=/id/docs/concepts/cluster-administration/networking/>model jaringan</a> yang paling sesuai.</li><li>Apakah kamu ingin menjalankan Kubernetes pada <strong>"bare metal" <em>hardware</em></strong> atau pada <strong><em>virtual machines</em> (VM)</strong>?</li><li>Apakah kamu <strong>hanya ingin mencoba klaster Kubernetes</strong>, atau kamu ingin ikut aktif melakukan <strong>pengembangan kode dari proyek Kubernetes</strong>? Jika jawabannya yang terakhir, pilihlah distro yang aktif dikembangkan. Beberapa distro hanya menggunakan rilis <em>binary</em>, namun menawarkan lebih banyak variasi pilihan.</li><li>Pastikan kamu paham dan terbiasa dengan beberapa <a href=/docs/admin/cluster-components/>komponen</a> yang dibutuhkan untuk menjalankan sebuah klaster.</li></ul><p>Catatan: Tidak semua distro aktif dikelola. Pilihlah distro yang telah diuji dengan versi terkini dari Kubernetes.</p><h2 id=mengelola-klaster>Mengelola Klaster</h2><ul><li><p><a href=/docs/tasks/administer-cluster/cluster-management/>Mengelola klaster</a> akan menjabarkan beberapa topik terkait <em>lifecycle</em> dari klaster: membuat klaster baru, melakukan <em>upgrade</em> pada <em>node master</em> dan <em>worker</em>, melakukan pemeliharaan <em>node</em> (contoh: <em>upgrade</em> kernel), dan melakukan <em>upgrade</em> versi Kubernetes API pada klaster yang sedang berjalan.</p></li><li><p>Pelajari bagaimana cara <a href=/docs/concepts/nodes/node/>mengatur <em>node</em></a>.</p></li><li><p>Pelajari bagaimana cara membuat dan mengatur kuota resource <a href=/id/docs/concepts/policy/resource-quotas/>(<em>resource quota</em>)</a> untuk <em>shared</em> klaster.</p></li></ul><h2 id=mengamankan-klaster>Mengamankan Klaster</h2><ul><li><p><a href=/id/docs/concepts/cluster-administration/certificates/>Sertifikat (<em>certificate</em>)</a> akan menjabarkan langkah-langkah untuk membuat sertifikat menggunakan beberapa <em>tool chains</em>.</p></li><li><p><a href=/id/docs/concepts/containers/container-environment-variables/>Kubernetes <em>Container Environment</em></a> akan menjelaskan <em>environment</em> untuk kontainer yang dikelola oleh Kubelet pada Kubernetes <em>node</em>.</p></li><li><p><a href=/docs/reference/access-authn-authz/controlling-access/>Mengontrol Akses ke Kubernetes API</a> akan menjabarkan bagaimana cara mengatur izin (<em>permission</em>) untuk akun pengguna dan <em>service account</em>.</p></li><li><p><a href=/docs/reference/access-authn-authz/authentication/>Autentikasi</a> akan menjelaskan autentikasi di Kubernetes, termasuk ragam pilihan autentikasi.</p></li><li><p><a href=/docs/reference/access-authn-authz/authorization/>Otorisasi</a> dibedakan dari autentikasi, digunakan untuk mengontrol bagaimana <em>HTTP call</em> ditangani.</p></li><li><p><a href=/docs/reference/access-authn-authz/admission-controllers/>Menggunakan <em>Admission Controllers</em></a> akan menjelaskan <em>plug-in</em> yang akan melakukan intersep permintaan sebelum menuju ke server Kubernetes API, setelah autentikasi dan otorisasi dilakukan.</p></li><li><p><a href=/docs/concepts/cluster-administration/sysctl-cluster/>Menggunakan Sysctls pada Klaster Kubernetes</a> akan menjabarkan tentang cara menggunakan perintah <code>sysctl</code> pada <em>command-line</em> untuk mengatur parameter kernel.</p></li><li><p><a href=/docs/tasks/debug-application-cluster/audit/>Audit</a> akan menjelaskan bagaimana cara berinteraksi dengan log audit Kubernetes.</p></li></ul><h3 id=mengamankan-kubelet>Mengamankan Kubelet</h3><ul><li><a href=/docs/concepts/architecture/master-node-communication/>Komunikasi Master-Node</a></li><li><a href=/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/>TLS <em>bootstrapping</em></a></li><li><a href=/docs/admin/kubelet-authentication-authorization/>Autentikasi/Otorisasi Kubelet</a></li></ul><h2 id=layanan-tambahan-klaster>Layanan Tambahan Klaster</h2><ul><li><p><a href=/id/docs/concepts/services-networking/dns-pod-service/>Integrasi DNS</a> akan menjelaskan bagaimana cara <em>resolve</em> suatu nama DNS langsung pada <em>service</em> Kubernetes.</p></li><li><p><a href=/id/docs/concepts/cluster-administration/logging/><em>Logging</em> dan <em>Monitoring</em> Aktivitas Klaster</a> akan menjelaskan bagaimana cara <em>logging</em> bekerja di Kubernetes serta bagaimana cara mengimplementasikannya.</p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-2bf9a93ab5ba014fb6ff70b22c29d432>3.11.2 - Sertifikat</h1><p>Saat menggunakan autentikasi sertifikat klien, kamu dapat membuat sertifikat
secara manual melalui <code>easyrsa</code>, <code>openssl</code> atau <code>cfssl</code>.</p><h3 id=easyrsa>easyrsa</h3><p><strong>easyrsa</strong> dapat digunakan untuk menghasilkan sertifikat klaster kamu secara manual.</p><ol><li><p>Unduh, buka paket, dan inisialisasi versi tambal easyrsa3.</p><pre><code> curl -LO https://storage.googleapis.com/kubernetes-release/easy-rsa/easy-rsa.tar.gz
 tar xzf easy-rsa.tar.gz
 cd easy-rsa-master/easyrsa3
 ./easyrsa init-pki
</code></pre></li><li><p>Hasilkan CA. (<code>--batch</code> untuk atur mode otomatis. <code>--req-cn</code> untuk menggunakan <em>default</em> CN.)</p><pre><code> ./easyrsa --batch &quot;--req-cn=${MASTER_IP}@`date +%s`&quot; build-ca nopass
</code></pre></li><li><p>Hasilkan sertifikat dan kunci <em>server</em>.
Argumen <code>--subject-alt-name</code> digunakan untuk mengatur alamat IP dan nama DNS yang dapat diakses
oleh <em>server</em> API. <code>MASTER_CLUSTER_IP</code> biasanya merupakan IP pertama dari CIDR <em>service cluster</em>
yang diset dengan argumen <code>--service-cluster-ip-range</code> untuk <em>server</em> API dan
komponen manajer pengontrol. Argumen <code>--days</code> digunakan untuk mengatur jumlah hari
masa berlaku sertifikat.
Sampel di bawah ini juga mengasumsikan bahwa kamu menggunakan <code>cluster.local</code> sebagai nama
<em>domain</em> DNS <em>default</em>.</p><pre><code> ./easyrsa --subject-alt-name=&quot;IP:${MASTER_IP},&quot;\
 &quot;IP:${MASTER_CLUSTER_IP},&quot;\
 &quot;DNS:kubernetes,&quot;\
 &quot;DNS:kubernetes.default,&quot;\
 &quot;DNS:kubernetes.default.svc,&quot;\
 &quot;DNS:kubernetes.default.svc.cluster,&quot;\
 &quot;DNS:kubernetes.default.svc.cluster.local&quot; \
 --days=10000 \
 build-server-full server nopass
</code></pre></li><li><p>Salin <code>pki/ca.crt</code>, <code>pki/issued/server.crt</code>, dan <code>pki/private/server.key</code> ke direktori kamu.</p></li><li><p>Isi dan tambahkan parameter berikut ke dalam parameter mulai <em>server</em> API:</p><pre><code>--client-ca-file=/yourdirectory/ca.crt
--tls-cert-file=/yourdirectory/server.crt
--tls-private-key-file=/yourdirectory/server.key
</code></pre></li></ol><h3 id=openssl>openssl</h3><p><strong>openssl</strong> secara manual dapat menghasilkan sertifikat untuk klaster kamu.</p><ol><li><p>Hasilkan ca.key dengan 2048bit:</p><pre><code>openssl genrsa -out ca.key 2048
</code></pre></li><li><p>Hasilkan ca.crt berdasarkan ca.key (gunakan -days untuk mengatur waktu efektif sertifikat):</p><pre><code>openssl req -x509 -new -nodes -key ca.key -subj &quot;/CN=${MASTER_IP}&quot; -days 10000 -out ca.crt
</code></pre></li><li><p>Hasilkan server.key dengan 2048bit:</p><pre><code> openssl genrsa -out server.key 2048
</code></pre></li><li><p>Buat <em>file</em> konfigurasi untuk menghasilkan <em>Certificate Signing Request</em> (CSR).
Pastikan untuk mengganti nilai yang ditandai dengan kurung sudut (mis. <code>&lt;MASTER_IP></code>)
dengan nilai sebenarnya sebelum menyimpan ke <em>file</em> (mis. <code>csr.conf</code>).
Perhatikan bahwa nilai <code>MASTER_CLUSTER_IP</code> adalah layanan IP klaster untuk
<em>server</em> API seperti yang dijelaskan dalam subbagian sebelumnya.
Sampel di bawah ini juga mengasumsikan bahwa kamu menggunakan <code>cluster.local</code>
sebagai nama <em>domain</em> DNS <em>default</em>.</p><pre><code> [ req ]
 default_bits = 2048
 prompt = no
 default_md = sha256
 req_extensions = req_ext
 distinguished_name = dn

 [ dn ]
 C = &lt;country&gt;
 ST = &lt;state&gt;
 L = &lt;city&gt;
 O = &lt;organization&gt;
 OU = &lt;organization unit&gt;
 CN = &lt;MASTER_IP&gt;

 [ req_ext ]
 subjectAltName = @alt_names

 [ alt_names ]
 DNS.1 = kubernetes
 DNS.2 = kubernetes.default
 DNS.3 = kubernetes.default.svc
 DNS.4 = kubernetes.default.svc.cluster
 DNS.5 = kubernetes.default.svc.cluster.local
 IP.1 = &lt;MASTER_IP&gt;
 IP.2 = &lt;MASTER_CLUSTER_IP&gt;

 [ v3_ext ]
 authorityKeyIdentifier=keyid,issuer:always
 basicConstraints=CA:FALSE
 keyUsage=keyEncipherment,dataEncipherment
 extendedKeyUsage=serverAuth,clientAuth
 subjectAltName=@alt_names
</code></pre></li><li><p>Hasilkan permintaan penandatanganan sertifikat berdasarkan <em>file</em> konfigurasi:</p><pre><code> openssl req -new -key server.key -out server.csr -config csr.conf
</code></pre></li><li><p>Hasilkan sertifikat <em>server</em> menggunakan ca.key, ca.crt dan server.csr:</p><pre><code> openssl x509 -req -in server.csr -CA ca.crt -CAkey ca.key \
 -CAcreateserial -out server.crt -days 10000 \
 -extensions v3_ext -extfile csr.conf
</code></pre></li><li><p>Lihat sertifikat:</p><pre><code> openssl x509  -noout -text -in ./server.crt
</code></pre></li></ol><p>Terakhir, tambahkan parameter yang sama ke dalam parameter mulai <em>server</em> API.</p><h3 id=cfssl>cfssl</h3><p><strong>cfssl</strong> adalah alat lain untuk pembuatan sertifikat.</p><ol><li><p>Unduh, buka paket dan siapkan <em>command line tools</em> seperti yang ditunjukkan di bawah ini.
Perhatikan bahwa kamu mungkin perlu menyesuaikan contoh perintah berdasarkan arsitektur
perangkat keras dan versi cfssl yang kamu gunakan.</p><pre><code>curl -L https://pkg.cfssl.org/R1.2/cfssl_linux-amd64 -o cfssl
chmod +x cfssl
curl -L https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64 -o cfssljson
chmod +x cfssljson
curl -L https://pkg.cfssl.org/R1.2/cfssl-certinfo_linux-amd64 -o cfssl-certinfo
chmod +x cfssl-certinfo
</code></pre></li><li><p>Buat direktori untuk menyimpan <em>artifacts</em> dan inisialisasi cfssl:</p><pre><code>mkdir cert
cd cert
../cfssl print-defaults config &gt; config.json
../cfssl print-defaults csr &gt; csr.json
</code></pre></li><li><p>Buat <em>file</em> konfigurasi JSON untuk menghasilkan <em>file</em> CA, misalnya, <code>ca-config.json</code>:</p><pre><code>{
  &quot;signing&quot;: {
    &quot;default&quot;: {
      &quot;expiry&quot;: &quot;8760h&quot;
    },
    &quot;profiles&quot;: {
      &quot;kubernetes&quot;: {
        &quot;usages&quot;: [
          &quot;signing&quot;,
          &quot;key encipherment&quot;,
          &quot;server auth&quot;,
          &quot;client auth&quot;
        ],
        &quot;expiry&quot;: &quot;8760h&quot;
      }
    }
  }
}
</code></pre></li><li><p>Buat <em>file</em> konfigurasi JSON untuk CA <em>certificate signing request</em> (CSR), misalnya,
<code>ca-csr.json</code>. Pastikan untuk mengganti nilai yang ditandai dengan kurung sudut
dengan nilai sebenarnya yang ingin kamu gunakan.</p><pre><code>{
  &quot;CN&quot;: &quot;kubernetes&quot;,
  &quot;key&quot;: {
    &quot;algo&quot;: &quot;rsa&quot;,
    &quot;size&quot;: 2048
  },
  &quot;names&quot;:[{
    &quot;C&quot;: &quot;&lt;country&gt;&quot;,
    &quot;ST&quot;: &quot;&lt;state&gt;&quot;,
    &quot;L&quot;: &quot;&lt;city&gt;&quot;,
    &quot;O&quot;: &quot;&lt;organization&gt;&quot;,
    &quot;OU&quot;: &quot;&lt;organization unit&gt;&quot;
  }]
}
</code></pre></li><li><p>Hasilkan kunci CA (<code>ca-key.pem</code>) dan sertifikat (<code>ca.pem</code>):</p><pre><code>../cfssl gencert -initca ca-csr.json | ../cfssljson -bare ca
</code></pre></li><li><p>Buat <em>file</em> konfigurasi JSON untuk menghasilkan kunci dan sertifikat untuk API
<em>server</em>, misalnya, <code>server-csr.json</code>. Pastikan untuk mengganti nilai dalam kurung sudut
dengan nilai sebenarnya yang ingin kamu gunakan. <code>MASTER_CLUSTER_IP</code> adalah layanan
klaster IP untuk <em>server</em> API seperti yang dijelaskan dalam subbagian sebelumnya.
Sampel di bawah ini juga mengasumsikan bahwa kamu menggunakan <code>cluster.local</code> sebagai
nama <em>domain</em> DNS <em>default</em>.</p><pre><code>{
  &quot;CN&quot;: &quot;kubernetes&quot;,
  &quot;hosts&quot;: [
    &quot;127.0.0.1&quot;,
    &quot;&lt;MASTER_IP&gt;&quot;,
    &quot;&lt;MASTER_CLUSTER_IP&gt;&quot;,
    &quot;kubernetes&quot;,
    &quot;kubernetes.default&quot;,
    &quot;kubernetes.default.svc&quot;,
    &quot;kubernetes.default.svc.cluster&quot;,
    &quot;kubernetes.default.svc.cluster.local&quot;
  ],
  &quot;key&quot;: {
    &quot;algo&quot;: &quot;rsa&quot;,
    &quot;size&quot;: 2048
  },
  &quot;names&quot;: [{
    &quot;C&quot;: &quot;&lt;country&gt;&quot;,
    &quot;ST&quot;: &quot;&lt;state&gt;&quot;,
    &quot;L&quot;: &quot;&lt;city&gt;&quot;,
    &quot;O&quot;: &quot;&lt;organization&gt;&quot;,
    &quot;OU&quot;: &quot;&lt;organization unit&gt;&quot;
  }]
}
</code></pre></li><li><p>Buat kunci dan sertifikat untuk server API, yang mana awalnya di
simpan masing-masing ke dalam <em>file</em> <code>server-key.pem</code> dan <code>server.pem</code>:</p><pre><code>../cfssl gencert -ca=ca.pem -ca-key=ca-key.pem \
--config=ca-config.json -profile=kubernetes \
server-csr.json | ../cfssljson -bare server
</code></pre></li></ol><h2 id=distribusi-sertifikat-self-signed-ca>Distribusi Sertifikat <em>Self-Signed</em> CA</h2><p><em>Node</em> klien dapat menolak untuk mengakui sertifikat CA yang ditandatangani sendiri sebagai valid.
Untuk <em>deployment</em> non-produksi, atau untuk <em>deployment</em> yang berjalan di belakang <em>firewall</em> perusahaan,
kamu dapat mendistribusikan sertifikat CA yang ditandatangani sendiri untuk semua klien dan <em>refresh</em>
daftar lokal untuk sertifikat yang valid.</p><p>Pada setiap klien, lakukan operasi berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo cp ca.crt /usr/local/share/ca-certificates/kubernetes.crt
</span></span><span style=display:flex><span>sudo update-ca-certificates
</span></span></code></pre></div><pre tabindex=0><code>Updating certificates in /etc/ssl/certs...
1 added, 0 removed; done.
Running hooks in /etc/ca-certificates/update.d....
done.
</code></pre><h2 id=sertifikat-api>Sertifikat API</h2><p>Kamu dapat menggunakan API <code>Certificate.k8s.io</code> untuk menyediakan
sertifikat x509 yang digunakan untuk autentikasi seperti yang didokumentasikan
<a href=/id/docs/tasks/tls/managing-tls-in-a-cluster>di sini</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-d0e81230313a2684e7b7e40b21834e30>3.11.3 - Penyedia Layanan Cloud</h1><p>Laman ini akan menjelaskan bagaimana cara mengelola Kubernetes yang berjalan pada penyedia layanan cloud tertentu.</p><h3 id=kubeadm>Kubeadm</h3><p><a href=/docs/reference/setup-tools/kubeadm/>Kubeadm</a> merupakan salah satu cara yang banyak digunakan untuk membuat klaster Kubernetes.
Kubeadm memiliki beragam opsi untuk mengatur konfigurasi spesifik untuk penyedia layanan cloud. Salah satu contoh yang biasa digunakan pada penyedia cloud <em>in-tree</em> yang dapat diatur dengan kubeadm adalah sebagai berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubeadm.k8s.io/v1beta1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>InitConfiguration<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>nodeRegistration</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kubeletExtraArgs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cloud-provider</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;openstack&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cloud-config</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/kubernetes/cloud.conf&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>kubeadm.k8s.io/v1beta1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterConfiguration<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kubernetesVersion</span>:<span style=color:#bbb> </span>v1.13.0<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiServer</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>extraArgs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cloud-provider</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;openstack&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cloud-config</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/kubernetes/cloud.conf&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>extraVolumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cloud<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/kubernetes/cloud.conf&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/kubernetes/cloud.conf&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>controllerManager</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>extraArgs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cloud-provider</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;openstack&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cloud-config</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/kubernetes/cloud.conf&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>extraVolumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cloud<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/kubernetes/cloud.conf&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/kubernetes/cloud.conf&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Penyedia layanan cloud <em>in-tree</em> biasanya membutuhkan <code>--cloud-provider</code> dan <code>--cloud-config</code> yang ditentukan sebelumnya pada <em>command lines</em> untuk <a href=/docs/admin/kube-apiserver/>kube-apiserver</a>, <a href=/docs/admin/kube-controller-manager/>kube-controller-manager</a> dan
<a href=/docs/admin/kubelet/>kubelet</a>. Konten dari <em>file</em> yang ditentukan pada <code>--cloud-config</code> untuk setiap provider akan dijabarkan di bawah ini.</p><p>Untuk semua penyedia layanan cloud eksternal, silakan ikuti instruksi pada repositori masing-masing penyedia layanan.</p><h2 id=aws>AWS</h2><p>Bagian ini akan menjelaskan semua konfigurasi yang dapat diatur saat menjalankan Kubernetes pada Amazon Web Services.</p><h3 id=nama-node>Nama Node</h3><p>Penyedia layanan cloud AWS menggunakan nama DNS privat dari <em>instance</em> AWS sebagai nama dari objek Kubernetes Node.</p><h3 id=load-balancer><em>Load Balancer</em></h3><p>Kamu dapat mengatur <a href=/id/docs/tasks/access-application-cluster/create-external-load-balancer/>load balancers eksternal</a> sehingga dapat menggunakan fitur khusus AWS dengan mengatur anotasi seperti di bawah ini.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-ssl-cert</span>:<span style=color:#bbb> </span>arn:aws:acm:xx-xxxx-x:xxxxxxxxx:xxxxxxx/xxxxx-xxxx-xxxx-xxxx-xxxxxxxxx<span style=color:#bbb> </span><span style=color:#080;font-style:italic>#ganti nilai ini</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>service.beta.kubernetes.io/aws-load-balancer-backend-protocol</span>:<span style=color:#bbb> </span>http<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>LoadBalancer<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>443</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>5556</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>example<span style=color:#bbb>
</span></span></span></code></pre></div><p>Pengaturan lainnya juga dapat diaplikasikan pada layanan <em>load balancer</em> di AWS dengan menggunakan anotasi-anotasi. Berikut ini akan dijelaskan anotasi yang didukung oleh AWS ELB:</p><ul><li><code>service.beta.kubernetes.io/aws-load-balancer-access-log-emit-interval</code>: Digunakan untuk menentukan interval pengeluaran log akses.</li><li><code>service.beta.kubernetes.io/aws-load-balancer-access-log-enabled</code>: Digunakan untuk mengaktifkan atau menonaktifkan log akses.</li><li><code>service.beta.kubernetes.io/aws-load-balancer-access-log-s3-bucket-name</code>: Digunakan untuk menentukan nama <em>bucket</em> S3 log akses.</li><li><code>service.beta.kubernetes.io/aws-load-balancer-access-log-s3-bucket-prefix</code>: Digunakan untuk menentukan prefix <em>bucket</em> S3 log akses.</li><li><code>service.beta.kubernetes.io/aws-load-balancer-additional-resource-tags</code>: Digunakan untuk menentukan daftar tag tambahan pada ELB dengan menggunakan parameter <em>key-value</em>. Contoh: <code>"Key1=Val1,Key2=Val2,KeyNoVal1=,KeyNoVal2"</code>.</li><li><code>service.beta.kubernetes.io/aws-load-balancer-backend-protocol</code>: Digunakan untuk menentukan protokol yang digunakan oleh <em>backend</em> (pod) di belakang <em>listener</em>. Jika diset ke <code>http</code> (default) atau <code>https</code>, maka akan dibuat HTTPS <em>listener</em> yang akan mengakhiri koneksi dan meneruskan <em>header</em>. Jika diset ke <code>ssl</code> atau <code>tcp</code>, maka akan digunakan "raw" SSL <em>listener</em>. Jika diset ke <code>http</code> dan <code>aws-load-balancer-ssl-cert</code> tidak digunakan, maka akan digunakan HTTP <em>listener</em>.</li><li><code>service.beta.kubernetes.io/aws-load-balancer-ssl-cert</code>: Digunakan untuk meminta <em>secure</em> <em>listener</em>. Nilai yang dimasukkan adalah sertifikat ARN yang valid. Info lebih lanjut lihat <a href=http://docs.aws.amazon.com/ElasticLoadBalancing/latest/DeveloperGuide/elb-listener-config.html>ELB Listener Config</a> CertARN merupakan IAM atau CM certificate ARN, contoh: <code>arn:aws:acm:us-east-1:123456789012:certificate/12345678-1234-1234-1234-123456789012</code>.</li><li><code>service.beta.kubernetes.io/aws-load-balancer-connection-draining-enabled</code>: Digunakan untuk mengaktifkan atau menonaktfkan <em>connection draining</em>.</li><li><code>service.beta.kubernetes.io/aws-load-balancer-connection-draining-timeout</code>: Digunakan untuk menentukan <em>connection draining timeout</em>.</li><li><code>service.beta.kubernetes.io/aws-load-balancer-connection-idle-timeout</code>: Digunakan untuk menentukan <em>idle connection timeout</em>.</li><li><code>service.beta.kubernetes.io/aws-load-balancer-cross-zone-load-balancing-enabled</code>: Digunakan untuk mengaktifkan atau menonaktifkan <em>cross-zone load balancing</em>.</li><li><code>service.beta.kubernetes.io/aws-load-balancer-extra-security-groups</code>: Digunakan untuk menentukan grup keamanan yang akan ditambahkan pada ELB yang dibuat.</li><li><code>service.beta.kubernetes.io/aws-load-balancer-internal</code>: Digunakan sebagai indikasi untuk menggunakan internal ELB.</li><li><code>service.beta.kubernetes.io/aws-load-balancer-proxy-protocol</code>: Digunakan untuk mengaktifkan <em>proxy protocol</em> pada ELB. Saat ini hanya dapat menerima nilai <code>*</code> yang berarti mengaktifkan <em>proxy protocol</em> pada semua ELB <em>backends</em>. Di masa mendatang kamu juga dapat mengatur agar <em>proxy protocol</em> hanya aktif pada <em>backends</em> tertentu..</li><li><code>service.beta.kubernetes.io/aws-load-balancer-ssl-ports</code>: Digunakan untuk menentukan daftar port--yang dipisahkan koma-- yang akan menggunakan SSL/HTTPS <em>listeners</em>. Nilai <em>default</em> yaitu <code>*</code> (semua).</li></ul><p>Informasi anotasi untuk AWS di atas diperoleh dari komentar pada <a href=https://github.com/kubernetes/kubernetes/blob/master/pkg/cloudprovider/providers/aws/aws.go>aws.go</a></p><h2 id=azure>Azure</h2><h3 id=nama-node-1>Nama Node</h3><p>Penyedia layanan cloud Azure menggunakan <em>hostname</em> dari <em>node</em> (yang ditentukan oleh kubelet atau menggunakan <code>--hostname-override</code>) sebagai nama dari objek Kubernetes Node.
Perlu diperhatikan bahwa nama Kubernetes Node harus sesuai dengan nama Azure VM.</p><h2 id=cloudstack>CloudStack</h2><h3 id=nama-node-2>Nama Node</h3><p>Penyedia layanan cloud CloudStack menggunakan <em>hostname</em> dari <em>node</em> (yang ditentukan kubelet atau menggunakan <code>--hostname-override</code>) sebagai nama dari objek Kubernetes Node.
Perlu diperhatikan bahwa nama Kubernetes Node harus sesuai dengan nama Cloudstack VM.</p><h2 id=gce>GCE</h2><h3 id=nama-node-3>Nama Node</h3><p>Penyedia layanan cloud GCE menggunakan <em>hostname</em> dari <em>node</em> (yang ditentukan kubelet atau menggunakan <code>--hostname-override</code>) sebagai nama dari objek Kubernetes Node.
Perlu diperhatikan bahwa segmen pertama dari nama Kubernetes Node harus sesuai dengan nama <em>instance</em> GCE (contoh: sebuah <em>node</em> dengan nama <code>kubernetes-node-2.c.my-proj.internal</code> harus sesuai dengan <em>instance</em> yang memiliki nama <code>kubernetes-node-2</code>).</p><h2 id=openstack>OpenStack</h2><p>Bagian ini akan menjelaskan semua konfigurasi yang dapat diatur saat menggunakan OpenStack dengan Kubernetes.</p><h3 id=nama-node-4>Nama Node</h3><p>Penyedia layanan cloud OpenStack menggunakan nama <em>instance</em> (yang diperoleh dari metadata OpenStack) sebagai nama objek Kubernetes Node.
Perlu diperhatikan bahwa nama <em>instance</em> harus berupa nama Kubernetes Node yang valid agar kubelet dapat mendaftarkan objek Node-nya.</p><h3 id=layanan>Layanan</h3><p>Penyedia layanan cloud OpenStack menggunakan beragam layanan OpenStack yang tersedia sebagai <em>underlying cloud</em> agar dapat mendukung Kubernetes:</p><table><thead><tr><th>Layanan</th><th>Versi API</th><th>Wajib</th></tr></thead><tbody><tr><td>Block Storage (Cinder)</td><td>V1†, V2, V3</td><td>Tidak</td></tr><tr><td>Compute (Nova)</td><td>V2</td><td>Tidak</td></tr><tr><td>Identity (Keystone)</td><td>V2‡, V3</td><td>Ya</td></tr><tr><td>Load Balancing (Neutron)</td><td>V1§, V2</td><td>Tidak</td></tr><tr><td>Load Balancing (Octavia)</td><td>V2</td><td>Tidak</td></tr></tbody></table><p>† Block Storage V1 API tidak lagi didukung, dukungan Block Storage V3 API telah
ditambahkan pada Kubernetes 1.9.</p><p>‡ Identity V2 API tidak lagi didukung dan akan dihapus oleh penyedia layanan
pada rilis mendatang. Pada rilis "Queens", OpenStack tidak lagi mengekspos
Identity V2 API.</p><p>§ Dukungan Load Balancing V1 API telah dihapus pada Kubernetes 1.9.</p><p><em>Service discovery</em> dilakukan dengan menggunakan katalog layanan/servis (<em>service catalog</em>) yang diatur oleh
OpenStack Identity (Keystone) menggunakan <code>auth-url</code> yang ditentukan pada konfigurasi
penyedia layanan. Penyedia layanan akan menurunkan fungsionalitas secara perlahan saat layanan OpenStack selain Keystone tidak tersedia dan akan menolak dukungan fitur yang terdampak. Beberapa fitur tertentu dapat diaktifkan atau dinonaktfikan tergantung dari ekstensi yang diekspos oleh Neutron pada <em>underlying cloud</em>.</p><h3 id=cloud-conf>cloud.conf</h3><p>Kubernetes berinteraksi dengan OpenStack melalui <em>file</em> cloud.conf. <em>File</em> ini akan menyuplai Kubernetes dengan kredensial dan lokasi dari Openstack <em>auth endpoint</em>.
Kamu dapat membuat <em>file</em> cloud.conf dengan menambahkan rincian berikut ini di dalam <em>file</em>:</p><h4 id=konfigurasi-pada-umumnya>Konfigurasi pada umumnya</h4><p>Berikut ini merupakan contoh dan konfigurasi yang biasa digunakan dan akan mencakup semua pilihan yang paling sering dibutuhkan. <em>File</em> ini akan merujuk pada <em>endpoint</em> dari Keystone OpenStack, serta menyediakan rincian bagaimana cara mengautentikasi dengannya, termasuk cara mengatur <em>load balancer</em>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>[Global]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>username=user<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>password=pass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>auth-url=https://&lt;keystone_ip&gt;/identity/v3<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>tenant-id=c869168a828847f39f7f06edd7305637<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>domain-id=2a73b8f597c04551a0fdc8e95544be8a<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>[LoadBalancer]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>subnet-id=6937f8fa-858d-4bc9-a3a5-18d2c957166a<span style=color:#bbb>
</span></span></span></code></pre></div><h5 id=global>Global</h5><p>Konfigurasi untuk penyedia layanan OpenStack berikut ini akan membahas bagian konfigurasi global sehingga harus berada pada bagian <code>[Global]</code> dari <em>file</em> <code>cloud.conf</code>:</p><ul><li><code>auth-url</code> (Wajib): URL dari API keystone digunakan untuk autentikasi. ULR ini dapat ditemukan pada bagian Access dan Security > API Access > Credentials di laman panel kontrol OpenStack.</li><li><code>username</code> (Wajib): Merujuk pada username yang dikelola keystone.</li><li><code>password</code> (Wajib): Merujuk pada kata sandi yang dikelola keystone.</li><li><code>tenant-id</code> (Wajib): Digunakan untuk menentukan id dari <em>project</em> tempat kamu membuat <em>resources</em>.</li><li><code>tenant-name</code> (Opsional): Digunakan untuk menentukan nama dari <em>project</em> tempat kamu ingin membuat <em>resources</em>.</li><li><code>trust-id</code> (Opsional): Digunakan untuk menentukan <em>identifier of the trust</em> untuk digunakan
sebagai otorisasi. Suatu <em>trust</em> merepresentasikan otorisasi dari suatu pengguna (<em>the trustor</em>) untuk didelegasikan
pada pengguna lain (<em>the trustee</em>), dan dapat digunakan oleh <em>trustee</em>
berperan sebagai <em>the trustor</em>. <em>Trust</em> yang tersedia dapat ditemukan pada <em>endpoint</em>
<code>/v3/OS-TRUST/trusts</code> dari Keystone API.</li><li><code>domain-id</code> (Opsional): Digunakan untuk menentukan id dari domain tempat <em>user</em> kamu berada.</li><li><code>domain-name</code> (Opsional): Digunakan untuk menentukan nama dari domain tempat <em>user</em> kamu berada.</li><li><code>region</code> (Opsional): Digunakan untuk menentukan <em>identifier</em> dari region saat digunakan pada
multi-region OpenStack cloud. Sebuah region merupakan pembagian secara umum dari <em>deployment</em> OpenStack. Meskipun region tidak wajib berkorelasi secara geografis, suatu <em>deployment</em> dapat menggunakan nama geografis sebagai region <em>identifier</em> seperti
<code>us-east</code>. Daftar region yang tersedia dapat ditemukan pada <em>endpoint</em> <code>/v3/regions</code>
dari Keystone API.</li><li><code>ca-file</code> (Optional): Digunakan untuk menentukan path dari <em>file</em> <em>custom</em> CA.</li></ul><p>Saat menggunakan Keystone V3 - yang mengganti istilah <em>tenant</em> menjadi <em>project</em> - nilai <code>tenant-id</code>
akan secara otomatis dipetakan pada <em>project</em> yang sesuai di API.</p><h5 id=load-balancer-1><em>Load Balancer</em></h5><p>Konfigurasi berikut ini digunakan untuk mengatur <em>load
balancer</em> dan harus berada pada bagian <code>[LoadBalancer]</code> dari <em>file</em> <code>cloud.conf</code>:</p><ul><li><code>lb-version</code> (Opsional): Digunakan untuk menonaktifkan pendeteksian versi otomatis. Nilai
yang valid yaitu <code>v1</code> atau <code>v2</code>. Jika tidak ditentukan, maka pendeteksian otomatis akan
memilih versi tertinggi yang didukung dari <em>underlying</em> OpenStack
cloud.</li><li><code>use-octavia</code> (Opsional): Digunakan untuk menentukan apakah akan menggunakan <em>endpoint</em> dari layanan Octavia LBaaS. Nilai yang valid yaitu <code>true</code> atau <code>false</code>. Jika diset nilai <code>true</code> namun Octavia LBaaS V2 tidak dapat ditemukan, maka <em>load balancer</em> akan kembali menggunakan <em>endpoint</em> dari Neutron LBaaS V2. Nilai <em>default</em> adalah <code>false</code>.</li><li><code>subnet-id</code> (Opsional): Digunakan untuk menentukan id dari subnet yang ingin kamu
buat <em>load balancer</em> di dalamnya. Nilai id ini dapat dilihat pada Network > Networks. Klik pada
jaringan yang sesuai untuk melihat subnet di dalamnya.</li><li><code>floating-network-id</code> (Opsional): Jika diset, maka akan membuat <em>floating</em> IP
untuk <em>load balancer</em>.</li><li><code>lb-method</code> (Opsional): Digunakan untuk menentukan algoritma pendistribusian
yang akan digunakan. Nilai yang valid yaitu
<code>ROUND_ROBIN</code>, <code>LEAST_CONNECTIONS</code>, atau <code>SOURCE_IP</code>. Jika tidak diset, maka akan
menggunakan algoritma <em>default</em> yaitu <code>ROUND_ROBIN</code>.</li><li><code>lb-provider</code> (Opsional): Digunakan untuk menentukan penyedia dari <em>load balancer</em>.
Jika tidak ditentukan, maka akan menggunakan penyedia <em>default</em> yang ditentukan pada Neutron.</li><li><code>create-monitor</code> (Opsional): Digunakan untuk menentukan apakah akan membuat atau tidak monitor kesehatan
untuk Neutron <em>load balancer</em>. Nilai yang valid yaitu <code>true</code> dan <code>false</code>.
Nilai <em>default</em> adalah <code>false</code>. Jika diset nilai <code>true</code> maka <code>monitor-delay</code>,
<code>monitor-timeout</code>, dan <code>monitor-max-retries</code> juga harus diset.</li><li><code>monitor-delay</code> (Opsional): Waktu antara pengiriman <em>probes</em> ke
anggota dari <em>load balancer</em>. Mohon pastikan kamu memasukkan waktu yang valid. Nilai waktu yang valid yaitu "ns", "us" (atau "µs"), "ms", "s", "m", "h"</li><li><code>monitor-timeout</code> (Opsional): Waktu maksimum dari monitor untuk menunggu
balasan ping sebelum <em>timeout</em>. Nilai ini harus lebih kecil dari nilai <em>delay</em>.
Mohon pastikan kamu memasukkan waktu yang valid. Nilai waktu yang valid yaitu "ns", "us" (atau "µs"), "ms", "s", "m", "h"</li><li><code>monitor-max-retries</code> (Opsional): Jumlah gagal ping yang diizinkan sebelum
mengubah status anggota <em>load balancer</em> menjadi INACTIVE. Harus berupa angka
antara 1 dan 10.</li><li><code>manage-security-groups</code> (Opsional): Digunakan untuk menentukan apakah <em>load balancer</em>
akan mengelola aturan grup keamanan sendiri atau tidak. Nilai yang valid
adalah <code>true</code> dan <code>false</code>. Nilai <em>default</em> adalah <code>false</code>. Saat diset ke <code>true</code> maka
nilai <code>node-security-group</code> juga harus ditentukan.</li><li><code>node-security-group</code> (Opsional): ID dari grup keamanan yang akan dikelola.</li></ul><h5 id=block-storage><em>Block Storage</em></h5><p>Konfigurasi untuk penyedia layanan OpenStack berikut ini digunakan untuk mengatur penyimpanan blok atau <em>block storage</em>
dan harus berada pada bagian <code>[BlockStorage]</code> dari <em>file</em> <code>cloud.conf</code>:</p><ul><li><code>bs-version</code> (Opsional): Digunakan untuk menonaktifkan fitur deteksi versi otomatis. Nilai
yang valid yaitu <code>v1</code>, <code>v2</code>, <code>v3</code> dan <code>auto</code>. Jika diset ke <code>auto</code> maka pendeteksian versi
otomatis akan memilih versi tertinggi yang didukung oleh <em>underlying</em>
OpenStack cloud. Nilai <em>default</em> jika tidak diset adalah <code>auto</code>.</li><li><code>trust-device-path</code> (Opsional): Pada umumnya nama <em>block device</em> yang ditentukan
oleh Cinder (contoh: <code>/dev/vda</code>) tidak dapat diandalkan. Opsi ini dapat mengatur hal
tersebut. Jika diset ke <code>true</code> maka akan menggunakan nama <em>block device</em> yang ditentukan
oleh Cinder. Nilai <em>default</em> adalah <code>false</code> yang berarti <em>path</em> dari <em>device</em> akan ditentukan
oleh nomor serialnya serta pemetaan dari <code>/dev/disk/by-id</code>, dan ini merupakan
cara yang direkomendasikan.</li><li><code>ignore-volume-az</code> (Opsional): Digunakan untuk mengatur penggunaan <em>availability zone</em> saat
menautkan volumes Cinder. Jika Nova dan Cinder memiliki <em>availability
zones</em> yang berbeda, opsi ini harus diset <code>true</code>. Skenario seperti ini yang umumnya terjadi, yaitu
saat terdapat banyak Nova <em>availability zones</em> namun hanya ada satu Cinder <em>availability zone</em>.
Nilai <em>default</em> yaitu <code>false</code> digunakan untuk mendukung penggunaan pada rilis terdahulu,
tetapi nilai ini dapat berubah pada rilis mendatang.</li></ul><p>Jika menjalankan Kubernetes dengan versi &lt;= 1.8 pada OpenStack yang menggunakan <em>paths</em> alih-alih
menggunakan port untuk membedakan antara <em>endpoints</em>, maka mungkin dibutuhkan untuk
secara eksplisit mengatur parameter <code>bs-version</code>. Contoh <em>endpoint</em> yang berdasarkan <em>path</em> yaitu
<code>http://foo.bar/volume</code> sedangkan endpoint yang berdasarkan port memiliki bentuk seperti ini
<code>http://foo.bar:xxx</code>.</p><p>Pada lingkungan yang menggunakan <em>endpoint</em> berdasarkan <em>path</em> dan Kubernetes menggunakan logika deteksi-otomatis yang lama, maka <em>error</em> <code>BS API version autodetection failed.</code> akan muncul saat mencoba
melepaskan volume. Untuk mengatasi isu ini, dimungkinkan
untuk memaksa penggunaan Cinder API versi 2 dengan menambahkan baris berikut ini pada konfigurasi penyedia cloud:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>[BlockStorage]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>bs-version=v2<span style=color:#bbb>
</span></span></span></code></pre></div><h5 id=metadata>Metadata</h5><p>Konfigurasi untuk OpenStack berikut ini digunakan untuk mengatur metadata dan
harus berada pada bagian <code>[Metadata]</code> dari <em>file</em> <code>cloud.conf</code>:</p><ul><li><p><code>search-order</code> (Opsional): Konfigurasi berikut ini digunakan untuk mengatur bagaimana
cara provider mengambil metadata terkait dengan <em>instance</em> yang dijalankannya. Nilai
<em>default</em> yaitu <code>configDrive,metadataService</code> yang berarti provider akan mengambil
metadata terkait <em>instance</em> dari <em>config drive</em> terlebih dahulu jika tersedia, namun
jika tidak maka akan menggunakan layanan metadata. Nilai alternatif lainnya yaitu:</p><ul><li><code>configDrive</code> - Hanya mengambil metadata <em>instance</em> dari <em>config
drive</em>.</li><li><code>metadataService</code> - Hanya mengambil data <em>instance</em> dari layanan
metadata.</li><li><code>metadataService,configDrive</code> - Mengambil metadata <em>instance</em> dari layanan metadata terlebih
dahulu jika tersedia, jika tidak maka akan mengambil dari <em>config drive</em>.</li></ul><p>Pengaturan ini memang sebaiknya dilakukan sebab metadata pada <em>config drive</em> bisa saja lambat laun akan kedaluwarsa, sedangkan layanan metadata akan selalu menyediakan metadata yang paling mutakhir. Tidak semua penyedia layanan cloud OpenStack menyediakan kedua layanan <em>config drive</em> dan layanan metadata dan mungkin hanya salah satu saja
yang tersedia. Oleh sebab itu nilai <em>default</em> diatur agar dapat memeriksa keduanya.</p></li></ul><h5 id=router>Router</h5><p>Konfigurasi untuk Openstack berikut ini digunakan untuk mengatur <em>plugin</em> jaringan Kubernetes <a href=/docs/concepts/cluster-administration/network-plugins/#kubenet>kubenet</a>
dan harus berada pada bagian <code>[Router]</code> dari <em>file</em> <code>cloud.conf</code>:</p><ul><li><code>router-id</code> (Opsional): Jika Neutron pada <em>underlying cloud</em> mendukung ekstensi
<code>extraroutes</code> maka gunakan <code>router-id</code> untuk menentukan router mana yang akan ditambahkan rute di dalamnya.
Router yang dipilih harus menjangkau jaringan privat tempat <em>node</em> klaster berada
(biasanya hanya ada satu jaringan <em>node</em>, dan nilai ini harus nilai dari <em>default</em> router
pada jaringan <em>node</em>). Nilai ini dibutuhkan untuk dapat menggunakan <a href=/docs/concepts/cluster-administration/network-plugins/#kubenet>kubenet</a> pada OpenStack.</li></ul><h2 id=ovirt>OVirt</h2><h3 id=nama-node-5>Nama Node</h3><p>Penyedia layanan cloud OVirt menggunakan <em>hostname</em> dari <em>node</em> (yang ditentukan kubelet atau menggunakan <code>--hostname-override</code>) sebagai nama dari objek Kubernetes Node.
Perlu diperhatikan bahwa nama Kubernetes Node harus sesuai dengan VM FQDN (yang ditampilkan oleh OVirt di bawah <code>&lt;vm>&lt;guest_info>&lt;fqdn>...&lt;/fqdn>&lt;/guest_info>&lt;/vm></code>)</p><h2 id=photon>Photon</h2><h3 id=nama-node-6>Nama Node</h3><p>Penyedia layanan cloud Photon menggunakan <em>hostname</em> dari <em>node</em> (yang ditentukan kubelet atau menggunakan <code>--hostname-override</code>) sebagai nama dari objek Kubernetes Node.
Perlu diperhatikan bahwa nama Kubernetes Node name harus sesuai dengan nama Photon VM (atau jika <code>overrideIP</code> diset ke true pada <code>--cloud-config</code>, nama Kubernetes Node harus sesuai dengan alamat IP Photon VM).</p><h2 id=vsphere>VSphere</h2><h3 id=nama-node-7>Nama Node</h3><p>Penyedia layanan cloud VSphere menggunakan <em>hostname</em> yang terdeteksi dari <em>node</em> (yang ditentukan oleh kubelet) sebagai nama dari objek Kubernetes Node.</p><p>Parameter <code>--hostname-override</code> diabaikan oleh penyedia layanan cloud VSphere.</p><h2 id=ibm-cloud-kubernetes-service>IBM Cloud Kubernetes Service</h2><h3 id=node-komputasi>Node Komputasi</h3><p>Saat menggunakan layanan IBM Cloud Kubernetes Service, kamu dapat membuat klaster yang terdiri dari campuran antara mesin virtual dan fisik (<em>bare metal</em>) sebagai <em>node</em> di <em>single zone</em> atau <em>multiple zones</em> pada satu region. Untuk informasi lebih lanjut, lihat <a href="https://cloud.ibm.com/docs/containers?topic=containers-plan_clusters#plan_clusters">Perencanaan klaster dan pengaturan worker node</a>.</p><p>Nama dari objek Kubernetes Node yaitu alamat IP privat dari IBM Cloud Kubernetes Service <em>worker node instance</em>.</p><h3 id=jaringan>Jaringan</h3><p>Penyedia layanan IBM Cloud Kubernetes Service menyediakan VLAN untuk membuat jaringan node yang terisolasi dengan kinerja tinggi. Kamu juga dapat membuat <em>custom firewall</em> dan <em>policy</em> jaringan Calico untuk menambah lapisan perlindungan ekstra bagi klaster kamu, atau hubungkan klaster kamu dengan <em>on-prem</em> data center via VPN. Untuk informasi lebih lanjut, lihat <a href="https://cloud.ibm.com/docs/containers?topic=containers-cs_network_cluster#cs_network_cluster">Perencanaan jaringan privat dan in-cluster</a>.</p><p>Untuk membuka aplikasi ke publik atau di dalam klaster, kamu dapat menggunakan NodePort, LoadBalancer, atau Ingress. Kamu juga dapat menyesuaikan aplikasi <em>load balancer</em> Ingress dengan anotasi. Untuk informasi lebih lanjut, lihat <a href="https://cloud.ibm.com/docs/containers?topic=containers-cs_network_planning#cs_network_planning">Perencanaan untuk membuka aplikasi dengan jaringan eksternal</a>.</p><h3 id=penyimpanan>Penyimpanan</h3><p>Penyedia layanan IBM Cloud Kubernetes Service memanfaatkan Kubernetes-native <em>persistent volumes</em> agar pengguna dapat melakukan <em>mount</em> <em>file</em>, block, dan penyimpanan objek cloud ke aplikasi mereka. Kamu juga dapat menggunakan <em>database-as-a-service</em> dan <em>add-ons</em> pihak ketiga sebagai penyimpanan <em>persistent</em> untuk data kamu. Untuk informasi lebih lanjut, lihat <a href="https://cloud.ibm.com/docs/containers?topic=containers-storage_planning#storage_planning">Perencanaan penyimpanan persistent yang selalu tersedia (<em>highly available</em>)</a>.</p><h2 id=baidu-cloud-container-engine>Baidu Cloud Container Engine</h2><h3 id=nama-node-8>Nama Node</h3><p>Penyedia layanan cloud Baidu menggunakan alamat IP privat dari <em>node</em> (yang ditentukan oleh kubelet atau menggunakan <code>--hostname-override</code>) sebagai nama dari objek Kubernetes Node.
Perlu diperhatikan bahwa nama Kubernetes Node harus sesuai dengan alamat IP privat dari Baidu VM.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-3aeeecf7cdb2a21eb4b31db7a71c81e2>3.11.4 - Mengelola Resource</h1><p>Kamu telah melakukan <em>deploy</em> pada aplikasimu dan mengeksposnya melalui sebuah <em>service</em>. Lalu? Kubernetes menyediakan berbagai peralatan untuk membantu mengatur mekanisme <em>deploy</em> aplikasi, termasuk pengaturan kapasitas dan pembaruan. Diantara fitur yang akan didiskusikan lebih mendalam yaitu <a href=/id/docs/concepts/configuration/overview/>berkas konfigurasi</a> dan <a href=/id/docs/concepts/overview/working-with-objects/labels/>label</a>.</p><h2 id=mengelola-konfigurasi-resource>Mengelola konfigurasi <em>resource</em></h2><p>Banyak aplikasi memerlukan beberapa <em>resource</em>, seperti Deployment dan Service. Pengelolaan beberapa <em>resource</em> dapat disederhanakan dengan mengelompokkannya dalam berkas yang sama (dengan pemisah <code>---</code> pada YAML). Contohnya:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/application/nginx-app.yaml download=application/nginx-app.yaml><code>application/nginx-app.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("application-nginx-app-yaml")' title="Copy application/nginx-app.yaml to clipboard"></img></div><div class=includecode id=application-nginx-app-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-nginx-svc<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>LoadBalancer<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.7.9<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Beberapa <em>resource</em> dapat dibuat seolah-olah satu <em>resource</em>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/application/nginx-app.yaml
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>service/my-nginx-svc created
</span></span><span style=display:flex><span>deployment.apps/my-nginx created
</span></span></code></pre></div><p><em>Resource</em> akan dibuat dalam urutan seperti pada berkas. Oleh karena itu, lebih baik menyalakan <em>service</em> lebih dahulu agar menjamin <em>scheduler</em> dapat menyebar <em>pod</em> yang terkait <em>service</em> selagi <em>pod</em> dibangkitkan oleh <em>controller</em>, seperti Deployment.</p><p><code>kubectl apply</code> juga dapat menerima beberapa argumen <code>-f</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/application/nginx/nginx-svc.yaml -f https://k8s.io/examples/application/nginx/nginx-deployment.yaml
</span></span></code></pre></div><p>Selain berkas, kita dapat juga memasukkan direktori sebagai argumen:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/application/nginx/
</span></span></code></pre></div><p><code>kubectl</code> akan membaca berkas apapun yang berakhiran <code>.yaml</code>, <code>.yml</code>, or <code>.json</code>.</p><p>Sangat disarankan untuk meletakkan sumber daya yang ada dalam <em>microservice</em> atau <em>tier</em> aplikasi yang sama dalam satu berkas, dan mengelompokkan semua berkas terkait aplikasimu dalam satu direktori. Jika <em>tier</em> masing-masing aplikasi terikat dengan DNS, maka kamu dapat melakukan <em>deploy</em> semua komponen teknologi yang dibutuhkan bersama-sama.</p><p>Lokasi konfigurasi dapat juga diberikan dalam bentuk URL. Ini berguna ketika ingin menjalankan berkas konfigurasi dari Github:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://raw.githubusercontent.com/kubernetes/website/master/content/en/examples/application/nginx/nginx-deployment.yaml
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>deployment.apps/my-nginx created
</span></span></code></pre></div><h2 id=operasi-majemuk-dalam-kubectl>Operasi majemuk dalam kubectl</h2><p>Pembuatan <em>resource</em> bukanlah satu-satunya operasi yang bisa dijalankan <code>kubectl</code> secara majemuk. Contoh lainnya adalah mengekstrak nama <em>resource</em> dari berkas konfigurasi untuk menjalankan operasi lainnya, seperti untuk menghapus <em>resource</em> yang telah dibuat:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete -f https://k8s.io/examples/application/nginx-app.yaml
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>deployment.apps <span style=color:#b44>&#34;my-nginx&#34;</span> deleted
</span></span><span style=display:flex><span>service <span style=color:#b44>&#34;my-nginx-svc&#34;</span> deleted
</span></span></code></pre></div><p>Pada kasus dua <em>resource</em>, mudah untuk memasukkan keduanya pada <em>command line</em> menggunakan sintaks <em>resource</em>/nama:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete deployments/my-nginx services/my-nginx-svc
</span></span></code></pre></div><p>Namun, untuk <em>resource</em> yang lebih banyak, memasukkan selektor (<em>label query</em>) menggunakan <code>-l</code> atau <code>--selector</code> untuk memfilter <em>resource</em> berdasarkan label akan lebih mudah:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete deployment,services -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>deployment.apps <span style=color:#b44>&#34;my-nginx&#34;</span> deleted
</span></span><span style=display:flex><span>service <span style=color:#b44>&#34;my-nginx-svc&#34;</span> deleted
</span></span></code></pre></div><p>Karena <code>kubectl</code> mengembalikan nama resource yang sama dengan sintaks yang diterima, mudah untuk melanjutkan operasi menggunakan <code>$()</code> atau <code>xargs</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get <span style=color:#a2f;font-weight:700>$(</span>kubectl create -f docs/concepts/cluster-administration/nginx/ -o name | grep service<span style=color:#a2f;font-weight:700>)</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME           TYPE           CLUSTER-IP   EXTERNAL-IP   PORT<span style=color:#666>(</span>S<span style=color:#666>)</span>      AGE
</span></span><span style=display:flex><span>my-nginx-svc   LoadBalancer   10.0.0.208   &lt;pending&gt;     80/TCP       0s
</span></span></code></pre></div><p>Dengan perintah di atas, pertama kita buat resource di dalam <code>examples/application/nginx/</code>. Lalu tampilkan resources yang terbentuk dengan format keluaran <code>-o name</code> (menampilkan tiap resource dalam format resource/nama). Kemudian lakukan <code>grep</code> hanya pada "service", dan tampilkan dengan <code>kubectl get</code>.</p><p>Untuk dapat menggunakan perintah di atas pada direktori yang bertingkat, kamu dapat memberi argumen <code>--recursive</code> atau <code>-R</code> bersama dengan argumen <code>--filename,-f</code>.</p><p>Misalnya ada sebuah direktori <code>project/k8s/development</code> memuat semua manifests yang berkaitan dengan <em>development environment</em>. Manifest akan tersusun berdasarkan tipe resource:</p><pre tabindex=0><code>project/k8s/development
├── configmap
│   └── my-configmap.yaml
├── deployment
│   └── my-deployment.yaml
└── pvc
    └── my-pvc.yaml
</code></pre><p>Secara <em>default</em>, menjalankan operasi majemuk pada <code>project/k8s/development</code> hanya akan terbatas pada direktori terluar saja. Sehingga ketika kita menjalankan operasi pembuatan dengan perintah berikut, kita akan mendapatkan pesan kesalahan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f project/k8s/development
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>error: you must provide one or more resources by argument or filename <span style=color:#666>(</span>.json|.yaml|.yml|stdin<span style=color:#666>)</span>
</span></span></code></pre></div><p>Solusinya, tambahkan argumen <code>--recursive</code> atau <code>-R</code> bersama dengan <code>--filename,-f</code>, seperti:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f project/k8s/development --recursive
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>configmap/my-config created
</span></span><span style=display:flex><span>deployment.apps/my-deployment created
</span></span><span style=display:flex><span>persistentvolumeclaim/my-pvc created
</span></span></code></pre></div><p>Argumen <code>--recursive</code> berjalan pada operasi apapun yang menerima argumen <code>--filename,-f</code> seperti: <code>kubectl {create,get,delete,describe,rollout} etc.</code></p><p>Argumen <code>--recursive</code> juga berjalan saat beberapa argumen <code>-f</code> diberikan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f project/k8s/namespaces -f project/k8s/development --recursive
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>namespace/development created
</span></span><span style=display:flex><span>namespace/staging created
</span></span><span style=display:flex><span>configmap/my-config created
</span></span><span style=display:flex><span>deployment.apps/my-deployment created
</span></span><span style=display:flex><span>persistentvolumeclaim/my-pvc created
</span></span></code></pre></div><p>Jika kamu tertarik mempelajari lebih lanjut tentang <code>kubectl</code>, silahkan baca <a href=/id/docs/reference/kubectl/overview/>Ikhtisar kubectl</a>.</p><h2 id=memakai-label-secara-efektif>Memakai label secara efektif</h2><p>Contoh yang kita lihat sejauh ini hanya menggunakan paling banyak satu label pada <em>resource</em>. Ada banyak skenario ketika membutuhkan beberapa label untuk membedakan sebuah kelompok dari yang lainnya.</p><p>Sebagai contoh, aplikasi yang berbeda akan menggunakan label <code>app</code> yang berbeda, tapi pada aplikasi <em>multitier</em>, seperti pada <a href=https://github.com/kubernetes/examples/tree/main/guestbook/>contoh buku tamu</a>, tiap <em>tier</em> perlu dibedakan. Misal untuk menandai <em>tier frontend</em> bisa menggunakan label:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>guestbook<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span></code></pre></div><p>sementara itu Redis <em>master</em> dan <em>slave</em> memiliki label <code>tier</code> yang berbeda. Bisa juga menggunakan label tambahan <code>role</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>guestbook<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>backend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>role</span>:<span style=color:#bbb> </span>master<span style=color:#bbb>
</span></span></span></code></pre></div><p>dan</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>guestbook<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>backend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>role</span>:<span style=color:#bbb> </span>slave<span style=color:#bbb>
</span></span></span></code></pre></div><p>Label memungkinkan kita untuk memilah <em>resource</em> dengan pembeda berupa label:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f examples/guestbook/all-in-one/guestbook-all-in-one.yaml
</span></span><span style=display:flex><span>kubectl get pods -Lapp -Ltier -Lrole
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME                           READY     STATUS    RESTARTS   AGE       APP         TIER       ROLE
</span></span><span style=display:flex><span>guestbook-fe-4nlpb             1/1       Running   <span style=color:#666>0</span>          1m        guestbook   frontend   &lt;none&gt;
</span></span><span style=display:flex><span>guestbook-fe-ght6d             1/1       Running   <span style=color:#666>0</span>          1m        guestbook   frontend   &lt;none&gt;
</span></span><span style=display:flex><span>guestbook-fe-jpy62             1/1       Running   <span style=color:#666>0</span>          1m        guestbook   frontend   &lt;none&gt;
</span></span><span style=display:flex><span>guestbook-redis-master-5pg3b   1/1       Running   <span style=color:#666>0</span>          1m        guestbook   backend    master
</span></span><span style=display:flex><span>guestbook-redis-slave-2q2yf    1/1       Running   <span style=color:#666>0</span>          1m        guestbook   backend    slave
</span></span><span style=display:flex><span>guestbook-redis-slave-qgazl    1/1       Running   <span style=color:#666>0</span>          1m        guestbook   backend    slave
</span></span><span style=display:flex><span>my-nginx-divi2                 1/1       Running   <span style=color:#666>0</span>          29m       nginx       &lt;none&gt;     &lt;none&gt;
</span></span><span style=display:flex><span>my-nginx-o0ef1                 1/1       Running   <span style=color:#666>0</span>          29m       nginx       &lt;none&gt;     &lt;none&gt;
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -lapp<span style=color:#666>=</span>guestbook,role<span style=color:#666>=</span>slave
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME                          READY     STATUS    RESTARTS   AGE
</span></span><span style=display:flex><span>guestbook-redis-slave-2q2yf   1/1       Running   <span style=color:#666>0</span>          3m
</span></span><span style=display:flex><span>guestbook-redis-slave-qgazl   1/1       Running   <span style=color:#666>0</span>          3m
</span></span></code></pre></div><h2 id=deploy-dengan-canary>Deploy dengan Canary</h2><p>Skenario lain yang menggunakan beberapa label yaitu saat membedakan deployment komponen yang sama namun dengan rilis atau konfigurasi yang berbeda. Adalah praktik yang umum untuk mendeploy sebuah <em>canary</em> dari rilis aplikasi yang baru (berdasarkan <em>tag image</em> dalam templat <em>pod</em>) bersamaan dengan rilis sebelumnya. Ini memungkinkan rilis yang baru dapat menerima <em>live traffic</em> sebelum benar-benar menggantikan rilis yang lama.</p><p>Salah satu alternatif yaitu kamu dapat memakai label <code>track</code> untuk membedakan antar rilis.</p><p>Rilis primer dan stabil akan memiliki label <code>track</code> yang berisi <code>stable</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>guestbook<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>track</span>:<span style=color:#bbb> </span>stable<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gb-frontend:v3<span style=color:#bbb>
</span></span></span></code></pre></div><p>kemudian kamu buat lagi rilis <em>frontend</em> buku tamu yang membawa label <code>track</code> yang berbeda (misal <code>canary</code>), sehingga <em>pod</em> dalam kedua rilis tidak beririsan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>frontend-canary<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>guestbook<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>track</span>:<span style=color:#bbb> </span>canary<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gb-frontend:v4<span style=color:#bbb>
</span></span></span></code></pre></div><p>Servis <em>frontend</em> akan meliputi kedua set replika dengan menentukan subset bersama dari para labelnya (tanpa <code>track</code>). Sehingga <em>traffic</em> akan diarahkan ke kedua aplikasi:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>guestbook<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>tier</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span></code></pre></div><p>Kamu dapat mengatur jumlah replika rilis <em>stable</em> dan <em>canary</em> untuk menentukan rasio dari tiap rilis yang akan menerima <em>traffic production live</em> (dalam kasus ini 3:1).
Ketika telah yakin, kamu dapat memindahkan <em>track stable</em> ke rilis baru dan menghapus <em>canary</em>.</p><p>Untuk contoh yang lebih jelas, silahkan cek <a href=https://github.com/kelseyhightower/talks/tree/master/kubecon-eu-2016/demo#deploy-a-canary>tutorial melakukan deploy Ghost</a>.</p><h2 id=memperbarui-label>Memperbarui label</h2><p>Kadang, <em>pod</em> dan <em>resource</em> lain yang sudah ada harus dilabeli ulang sebelum membuat <em>resource</em> baru. Hal ini dapat dilakukan dengan perintah <code>kubectl label</code>.
Contohnya jika kamu ingin melabeli ulang semua <em>pod</em> nginx sebagai <em>frontend tier</em>, tinggal jalankan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl label pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx <span style=color:#b8860b>tier</span><span style=color:#666>=</span>fe
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>pod/my-nginx-2035384211-j5fhi labeled
</span></span><span style=display:flex><span>pod/my-nginx-2035384211-u2c7e labeled
</span></span><span style=display:flex><span>pod/my-nginx-2035384211-u3t6x labeled
</span></span></code></pre></div><p>Perintah ini melakukan filter pada semua <em>pod</em> dengan label "app=nginx", lalu melabelinya dengan "tier=fe".
Untuk melihat <em>pod</em> yang telah dilabeli, jalankan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx -L tier
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME                        READY     STATUS    RESTARTS   AGE       TIER
</span></span><span style=display:flex><span>my-nginx-2035384211-j5fhi   1/1       Running   <span style=color:#666>0</span>          23m       fe
</span></span><span style=display:flex><span>my-nginx-2035384211-u2c7e   1/1       Running   <span style=color:#666>0</span>          23m       fe
</span></span><span style=display:flex><span>my-nginx-2035384211-u3t6x   1/1       Running   <span style=color:#666>0</span>          23m       fe
</span></span></code></pre></div><p>Akan muncul semua <em>pod</em> dengan "app=nginx" dan sebuah kolom label tambahan yaitu tier (ditentukan dengan <code>-L</code> atau <code>--label-columns</code>).</p><p>Untuk informasi lebih lanjut, silahkan baca <a href=/id/docs/concepts/overview/working-with-objects/labels/>label</a> dan <a href=/docs/reference/generated/kubectl/kubectl-commands/#label>kubectl label</a>.</p><h2 id=memperbarui-anotasi>Memperbarui anotasi</h2><p>Kadang resource perlu ditambahkan anotasi. Anotasi adalah metadata sembarang yang tidak unik, seperti <em>tools, libraries</em>, dsb yang digunakan oleh klien API . Ini dapat dilakukan dengan <code>kubectl annotate</code>. Sebagai contoh:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl annotate pods my-nginx-v4-9gw19 <span style=color:#b8860b>description</span><span style=color:#666>=</span><span style=color:#b44>&#39;my frontend running nginx&#39;</span>
</span></span><span style=display:flex><span>kubectl get pods my-nginx-v4-9gw19 -o yaml
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>apiVersion: v1
</span></span><span style=display:flex><span>kind: pod
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  annotations:
</span></span><span style=display:flex><span>    description: my frontend running nginx
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>Untuk informasi lebih lanjut, silahkan lihat laman <a href=/id/docs/concepts/overview/working-with-objects/annotations/>annotations</a> dan <a href=/docs/reference/generated/kubectl/kubectl-commands/#annotate>kubectl annotate</a>.</p><h2 id=memperbesar-dan-memperkecil-aplikasi-kamu>Memperbesar dan memperkecil aplikasi kamu</h2><p>Saat beban aplikasi naik maupun turun, mudah untuk mengubah kapasitas dengan <code>kubectl</code>. Contohnya, untuk menurunkan jumlah replika nginx dari 3 ke 1, lakukan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl scale deployment/my-nginx --replicas<span style=color:#666>=</span><span style=color:#666>1</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>deployment.extensions/my-nginx scaled
</span></span></code></pre></div><p>Sekarang kamu hanya memiliki satu <em>pod</em> yang dikelola oleh deployment.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME                        READY     STATUS    RESTARTS   AGE
</span></span><span style=display:flex><span>my-nginx-2035384211-j5fhi   1/1       Running   <span style=color:#666>0</span>          30m
</span></span></code></pre></div><p>Agar sistem dapat menyesuaikan jumlah replika nginx yang dibutuhkan secara otomatis dari 1 hingga 3, lakukan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl autoscale deployment/my-nginx --min<span style=color:#666>=</span><span style=color:#666>1</span> --max<span style=color:#666>=</span><span style=color:#666>3</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>horizontalpodautoscaler.autoscaling/my-nginx autoscaled
</span></span></code></pre></div><p>Sekarang jumlah replika nginx akan secara otomatis naik dan turun sesuai kebutuhan.</p><p>Informasi tambahan dapat dilihat pada dokumen <a href=/docs/reference/generated/kubectl/kubectl-commands/#scale>kubectl scale</a>, <a href=/docs/reference/generated/kubectl/kubectl-commands/#autoscale>kubectl autoscale</a> dan <a href=/docs/tasks/run-application/horizontal-pod-autoscale/>horizontal <em>pod</em> autoscaler</a>.</p><h2 id=pembaruan-resource-di-tempat>Pembaruan resource di tempat</h2><p>Kadang kita perlu membuat pembaruan kecil, yang tidak mengganggu pada <em>resource</em> yang telah dibuat.</p><h3 id=kubectl-apply>kubectl apply</h3><p>Disarankan untuk menyimpan berkas-berkas konfigurasi dalam <em>source control</em> (lihat <a href=http://martinfowler.com/bliki/InfrastructureAsCode.html>konfigurasi sebagai kode</a>). Sehingga berkas dapat dipelihara dan diatur dalam versi bersama dengan kode milik <em>resource</em> yang diatur oleh konfigurasi tersebut. Berikutnya, kamu dapat menggunakan <a href=/docs/reference/generated/kubectl/kubectl-commands/#apply><code>kubectl apply</code></a> untuk membarui perubahan konfigurasi ke klaster.</p><p>Perintah ini akan membandingkan versi konfigurasi yang disuplai dengan versi sebelumnya yang telah berjalan dan memasang perubahan yang kamu buat tanpa mengganti properti yang tidak berubah sama sekali.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/application/nginx/nginx-deployment.yaml
</span></span><span style=display:flex><span>deployment.apps/my-nginx configured
</span></span></code></pre></div><p>Perhatikan bahwa <code>kubectl apply</code> memasang anotasi pada <em>resource</em> untuk menentukan perubahan pada konfigurasi sejak terakhir dipanggil. Ketika dijalankan, <code>kubectl apply</code> melakukan pembandingan <em>three-way</em> antara konfigurasi sebelumnya, masukan yang disuplai, dan konfigurasi <em>resource</em> sekarang, untuk dapat menentukan cara memodifikasi <em>resource</em>.</p><p>Saat ini, <em>resource</em> dibuat tanpa ada anotasi. Jadi pemanggilan pertama pada <code>kubectl apply</code> akan dikembalikan pada perbandingan <em>two-way</em> antara masukan pengguna dan konfigurasi <em>resource</em> sekarang. Saat pemanggilan pertama ini, tidak ada penghapusan set properti yang terdeteksi saat <em>resource</em> dibuat. Sehingga, tidak ada yang dihapus.</p><p>Tiap <code>kubectl apply</code>, atau perintah lain yang memodifikasi konfigurasi seperti <code>kubectl replace</code> dan <code>kubectl edit</code> dijalankan, anotasi akan diperbarui. Sehingga memungkinkan operasi <code>kubectl apply</code> untuk mendeteksi dan melakukan penghapusan secara perbandingan <em>three-way</em>.</p><h3 id=kubectl-edit>kubectl edit</h3><p>Sebagai alternatif, kamu juga dapat membarui resource dengan <code>kubectl edit</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl edit deployment/my-nginx
</span></span></code></pre></div><p>Ini sama dengan melakukan <code>get</code> pada <em>resource</em>, mengubahnya di text editor, kemudian menjalankan<code>apply</code> pada <em>resource</em> dengan versi terkini:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get deployment my-nginx -o yaml &gt; /tmp/nginx.yaml
</span></span><span style=display:flex><span>vi /tmp/nginx.yaml
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># lakukan pengubahan, lalu simpan berkas</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl apply -f /tmp/nginx.yaml
</span></span><span style=display:flex><span>deployment.apps/my-nginx configured
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>rm /tmp/nginx.yaml
</span></span></code></pre></div><p>Cara demikian memungkinkan kamu membuat perubahan signifikan dengan mudah. Lihat bahwa kamu juga dapat menentukan editor dengan variabel environment <code>EDITOR</code> atau <code>KUBE_EDITOR</code>.</p><p>Untuk informasi tambahan, silahkan lihat laman <a href=/docs/reference/generated/kubectl/kubectl-commands/#edit>kubectl edit</a>.</p><h3 id=kubectl-patch>kubectl patch</h3><p>Kamu dapat menggunakan <code>kubectl patch</code> untuk membarui obyek API di tempat. Perintah ini mendukung patch JSON, <em>patch</em> gabungan JSON, dan <em>strategic merge patch</em>. Lihat
<a href=/docs/tasks/run-application/update-api-object-kubectl-patch/>Update API Objects in Place Using kubectl patch</a>
dan
<a href=/docs/reference/generated/kubectl/kubectl-commands/#patch>kubectl patch</a>.</p><h2 id=pembaruan-disruptif>Pembaruan disruptif</h2><p>Pada kasus tertentu, kamu mungkin perlu memperbarui field resource yang tidak dapat diperbarui setelah diinisiasi atau kamu ingin membuat perubahan rekursif segera, seperti memperbaiki <em>pod</em> yang rusak saat menjalankan Deployment. Untuk mengubah field seperti itu, gunakan <code>replace --force</code> yang akan menghapus dan membuat ulang resource. Dalam kasus ini kamu dapat mengubah berkas konfigurasi awalnya:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl replace -f https://k8s.io/examples/application/nginx/nginx-deployment.yaml --force
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>deployment.apps/my-nginx deleted
</span></span><span style=display:flex><span>deployment.apps/my-nginx replaced
</span></span></code></pre></div><h2 id=membarui-aplikasi-tanpa-memadamkan-servis>Membarui aplikasi tanpa memadamkan servis</h2><p>Suatu saat, kamu akan perlu untuk membarui aplikasi yang telah terdeploy, biasanya dengan mengganti <em>image</em> atau <em>tag</em> sebagaimana dalam skenario <em>canary deployment</em> di atas. <code>kubectl</code> mendukung beberapa operasi pembaruan, masing-masing dapat digunakan pada skenario berbeda.</p><p>Kami akan memandumu untuk membuat dan membarui aplikasi melalui Deployment.</p><p>Misal kamu telah menjalankan nginx versi 1.7.9:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl run my-nginx --image<span style=color:#666>=</span>nginx:1.7.9 --replicas<span style=color:#666>=</span><span style=color:#666>3</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>deployment.apps/my-nginx created
</span></span></code></pre></div><p>Untuk memperbarui versi ke 1.9.1, ganti <code>.spec.template.spec.containers[0].image</code> dari <code>nginx:1.7.9</code> ke <code>nginx:1.9.1</code>, dengan perintah kubectl yang telah dipelajari di atas.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl edit deployment/my-nginx
</span></span></code></pre></div><p>Selesai! Deployment akan memperbarui aplikasi nginx yang terdeploy secara berangsur di belakang. Dia akan menjamin hanya ada sekian replika lama yang akan down selagi pembaruan berjalan dan hanya ada sekian replika baru akan dibuat melebihi jumlah pod. Untuk mempelajari lebih lanjut, kunjungi <a href=/id/docs/concepts/workloads/controllers/deployment/>laman Deployment</a>.</p><h2 id=selanjutnya>Selanjutnya</h2><ul><li><a href=/docs/tasks/debug-application-cluster/debug-application-introspection/>Pelajari tentang bagaimana memakai <code>kubectl</code> untuk memeriksa dan <em>debug</em> aplikasi.</a></li><li><a href=/id/docs/concepts/configuration/overview/>Praktik Terbaik dan Tips Konfigurasi</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-d649067a69d8d5c7e71564b42b96909e>3.11.5 - Jaringan Kluster</h1><p>Jaringan adalah bagian utama dari Kubernetes, tetapi bisa menjadi sulit
untuk memahami persis bagaimana mengharapkannya bisa bekerja.
Ada 4 masalah yang berbeda untuk diatasi:</p><ol><li>Komunikasi antar kontainer yang sangat erat: hal ini diselesaikan oleh
<a href=/id/docs/concepts/workloads/pods/pod/>Pod</a> dan komunikasi <code>localhost</code>.</li><li>Komunikasi antar Pod: ini adalah fokus utama dari dokumen ini.</li><li>Komunikasi Pod dengan Service: ini terdapat di <a href=/id/docs/concepts/services-networking/service/>Service</a>.</li><li>Komunikasi eksternal dengan Service: ini terdapat di <a href=/id/docs/concepts/services-networking/service/>Service</a>.</li></ol><p>Kubernetes adalah tentang berbagi mesin antar aplikasi. Pada dasarnya,
saat berbagi mesin harus memastikan bahwa dua aplikasi tidak mencoba menggunakan
<em>port</em> yang sama. Mengkoordinasikan <em>port</em> di banyak pengembang sangat sulit
dilakukan pada skala yang berbeda dan memaparkan pengguna ke masalah
tingkat kluster yang di luar kendali mereka.</p><p>Alokasi <em>port</em> yang dinamis membawa banyak komplikasi ke sistem - setiap aplikasi
harus menganggap <em>port</em> sebagai <em>flag</em>, <em>server</em> API harus tahu cara memasukkan
nomor <em>port</em> dinamis ke dalam blok konfigurasi, Service-Service harus tahu cara
menemukan satu sama lain, dll. Sebaliknya daripada berurusan dengan ini,
Kubernetes mengambil pendekatan yang berbeda.</p><h2 id=model-jaringan-kubernetes>Model jaringan Kubernetes</h2><p>Setiap Pod mendapatkan alamat IP sendiri. Ini berarti kamu tidak perlu secara langsung membuat tautan antara Pod dan kamu hampir tidak perlu berurusan dengan memetakan <em>port</em> kontainer ke <em>port</em> pada <em>host</em>. Ini menciptakan model yang bersih, kompatibel dengan yang sebelumnya dimana Pod dapat diperlakukan seperti halnya VM atau <em>host</em> fisik dari perspektif alokasi <em>port</em>, penamaan, <em>service discovery</em>, <em>load balancing</em>, konfigurasi aplikasi, dan migrasi.</p><p>Kubernetes memberlakukan persyaratan mendasar berikut pada setiap implementasi jaringan (kecuali kebijakan segmentasi jaringan yang disengaja):</p><ul><li>Pod pada suatu Node dapat berkomunikasi dengan semua Pod pada semua Node tanpa NAT</li><li>agen pada suatu simpul (mis. <em>daemon</em> sistem, kubelet) dapat berkomunikasi dengan semua Pod pada Node itu</li></ul><p>Catatan: Untuk platform yang mendukung Pod yang berjalan di jaringan <em>host</em> (mis. Linux):</p><ul><li>Pod di jaringan <em>host</em> dari sebuah Node dapat berkomunikasi dengan semua Pod pada semua Node tanpa NAT</li></ul><p>Model ini tidak hanya sedikit kompleks secara keseluruhan, tetapi pada prinsipnya kompatibel dengan keinginan Kubernetes untuk memungkinkan <em>low-friction porting</em> dari aplikasi dari VM ke kontainer. Jika pekerjaan kamu sebelumnya dijalankan dalam VM, VM kamu memiliki IP dan dapat berbicara dengan VM lain di proyek yang sama. Ini adalah model dasar yang sama.</p><p>Alamat IP Kubernetes ada di lingkup Pod - kontainer dalam Pod berbagi jaringan <em>namespace</em> mereka - termasuk alamat IP mereka. Ini berarti bahwa kontainer dalam Pod semua dapat mencapai <em>port</em> satu sama lain di <code>_localhost_</code>. Ini juga berarti bahwa kontainer dalam Pod harus mengoordinasikan penggunaan <em>port</em>, tetapi ini tidak berbeda dari proses di VM. Ini disebut model "IP-per-pod".</p><h2 id=bagaimana-menerapkan-model-jaringan-kubernetes>Bagaimana menerapkan model jaringan Kubernetes</h2><p>Ada beberapa cara agar model jaringan ini dapat diimplementasikan. Dokumen ini bukan studi lengkap tentang berbagai metode, tetapi semoga berfungsi sebagai pengantar ke berbagai teknologi dan berfungsi sebagai titik awal.</p><p>Opsi jaringan berikut ini disortir berdasarkan abjad - urutan tidak menyiratkan status istimewa apa pun.</p><h3 id=aci>ACI</h3><p><a href=https://www.cisco.com/c/en/us/solutions/data-center-virtualization/application-centric-infrastructure/index.html>Infrastruktur Sentral Aplikasi Cisco</a> menawarkan solusi SDN overlay dan underlay terintegrasi yang mendukung kontainer, mesin virtual, dan <em>bare metal server</em>. <a href=https://www.github.com/noironetworks/aci-containers>ACI</a> menyediakan integrasi jaringan kontainer untuk ACI. Tinjauan umum integrasi disediakan <a href=https://www.cisco.com/c/dam/en/us/solutions/collateral/data-center-virtualization/application-centric-infrastructure/solution-overview-c22-739493.pdf>di sini</a>.</p><h3 id=aos-dari-apstra>AOS dari Apstra</h3><p><a href=http://www.apstra.com/products/aos/>AOS</a> adalah sistem Jaringan Berbasis Intent yang menciptakan dan mengelola lingkungan pusat data yang kompleks dari platform terintegrasi yang sederhana. AOS memanfaatkan desain terdistribusi sangat <em>scalable</em> untuk menghilangkan pemadaman jaringan sambil meminimalkan biaya.</p><p>Desain Referensi AOS saat ini mendukung <em>host</em> yang terhubung dengan Lapis-3 yang menghilangkan masalah peralihan Lapis-2 yang lama. Host Lapis-3 ini bisa berupa <em>server</em> Linux (Debian, Ubuntu, CentOS) yang membuat hubungan tetangga BGP secara langsung dengan <em>top of rack switches</em> (TORs). AOS mengotomatisasi kedekatan perutean dan kemudian memberikan kontrol yang halus atas <em>route health injections</em> (RHI) yang umum dalam <em>deployment</em> Kubernetes.</p><p>AOS memiliki banyak kumpulan endpoint REST API yang memungkinkan Kubernetes dengan cepat mengubah kebijakan jaringan berdasarkan persyaratan aplikasi. Peningkatan lebih lanjut akan mengintegrasikan model Grafik AOS yang digunakan untuk desain jaringan dengan penyediaan beban kerja, memungkinkan sistem manajemen ujung ke ujung untuk layanan cloud pribadi dan publik.</p><p>AOS mendukung penggunaan peralatan vendor umum dari produsen termasuk Cisco, Arista, Dell, Mellanox, HPE, dan sejumlah besar sistem white-box dan sistem operasi jaringan terbuka seperti Microsoft SONiC, Dell OPX, dan Cumulus Linux.</p><p>Detail tentang cara kerja sistem AOS dapat diakses di sini: <a href=http://www.apstra.com/products/how-it-works/>http://www.apstra.com/products/how-it-works/</a></p><h3 id=aws-vpc-cni-untuk-kubernetes>AWS VPC CNI untuk Kubernetes</h3><p><a href=https://github.com/aws/amazon-vpc-cni-k8s>AWS VPC CNI</a> menawarkan jaringan AWS <em>Virtual Private Cloud</em> (VPC) terintegrasi untuk kluster Kubernetes. Plugin CNI ini menawarkan <em>throughput</em> dan ketersediaan tinggi, latensi rendah, dan <em>jitter</em> jaringan minimal. Selain itu, pengguna dapat menerapkan jaringan AWS VPC dan praktik keamanan terbaik untuk membangun kluster Kubernetes. Ini termasuk kemampuan untuk menggunakan catatan aliran VPC, kebijakan perutean VPC, dan grup keamanan untuk isolasi lalu lintas jaringan.</p><p>Menggunakan <em>plugin</em> CNI ini memungkinkan Pod Kubernetes memiliki alamat IP yang sama di dalam Pod seperti yang mereka lakukan di jaringan VPC. CNI mengalokasikan AWS <em>Elastic Networking Interfaces</em> (ENIs) ke setiap node Kubernetes dan menggunakan rentang IP sekunder dari setiap ENI untuk Pod pada Node. CNI mencakup kontrol untuk pra-alokasi ENI dan alamat IP untuk waktu mulai Pod yang cepat dan memungkinkan kluster besar hingga 2.000 Node.</p><p>Selain itu, CNI dapat dijalankan bersama <a href=https://docs.aws.amazon.com/eks/latest/userguide/calico.html>Calico untuk penegakan kebijakan jaringan</a>. Proyek AWS VPC CNI adalah <em>open source</em> dengan <a href=https://github.com/aws/amazon-vpc-cni-k8s>dokumentasi di GitHub</a>.</p><h3 id=big-cloud-fabric-dari-big-switch-networks>Big Cloud Fabric dari Big Switch Networks</h3><p><a href=https://www.bigswitch.com/container-network-automation>Big Cloud Fabric</a> adalah arsitektur jaringan asli layanan cloud, yang dirancang untuk menjalankan Kubernetes di lingkungan cloud pribadi / lokal. Dengan menggunakan SDN fisik & <em>virtual</em> terpadu, Big Cloud Fabric menangani masalah yang sering melekat pada jaringan kontainer seperti penyeimbangan muatan, visibilitas, pemecahan masalah, kebijakan keamanan & pemantauan lalu lintas kontainer.</p><p>Dengan bantuan arsitektur multi-penyewa Pod virtual pada Big Cloud Fabric, sistem orkestrasi kontainer seperti Kubernetes, RedHat OpenShift, Mesosphere DC/OS & Docker Swarm akan terintegrasi secara alami bersama dengan sistem orkestrasi VM seperti VMware, OpenStack & Nutanix. Pelanggan akan dapat terhubung dengan aman berapa pun jumlah klusternya dan memungkinkan komunikasi antar penyewa di antara mereka jika diperlukan.</p><p>Terbaru ini BCF diakui oleh Gartner sebagai visioner dalam <a href=http://go.bigswitch.com/17GatedDocuments-MagicQuadrantforDataCenterNetworking_Reg.html><em>Magic Quadrant</em></a>. Salah satu penyebaran BCF Kubernetes di tempat (yang mencakup Kubernetes, DC/OS & VMware yang berjalan di beberapa DC di berbagai wilayah geografis) juga dirujuk <a href=https://portworx.com/architects-corner-kubernetes-satya-komala-nio/>di sini</a>.</p><h3 id=cilium>Cilium</h3><p><a href=https://github.com/cilium/cilium>Cilium</a> adalah perangkat lunak <em>open source</em> untuk menyediakan dan secara transparan mengamankan konektivitas jaringan antar kontainer aplikasi. Cilium mengetahui L7/HTTP dan dapat memberlakukan kebijakan jaringan pada L3-L7 menggunakan model keamanan berbasis identitas yang dipisahkan dari pengalamatan jaringan.</p><h3 id=cni-genie-dari-huawei>CNI-Genie dari Huawei</h3><p><a href=https://github.com/Huawei-PaaS/CNI-Genie>CNI-Genie</a> adalah <em>plugin</em> CNI yang memungkinkan Kubernetes [secara bersamaan memiliki akses ke berbagai implementasi](<a href=https://github.com/Huawei-PaaS>https://github.com/Huawei-PaaS</a> /CNI-Genie/blob/master/docs/multiple-cni-plugins/README.md#what-cni-genie-feature-1-multiple-cni-plugins-enables) dari [model jaringan Kubernetes] (<a href=https://git.k8s.io/website/docs/concepts/cluster-administration/networking.md#kubernetes-model>https://git.k8s.io/website/docs/concepts/cluster-administration/networking.md#kubernetes-model</a>) dalam <em>runtime</em>. Ini termasuk setiap implementasi yang berjalan sebagai <a href=https://github.com/containernetworking/cni#3rd-party-plugins><em>plugin</em> CNI</a>, seperti <a href=https://github.com/coreos/flannel#flannel>Flannel</a>, <a href=http://docs.projectcalico.org/>Calico</a>, <a href=http://romana.io>Romana</a>, <a href=https://www.weave.works/products/weave-net/>Weave-net</a>.</p><p>CNI-Genie juga mendukung <a href=https://github.com/Huawei-PaaS/CNI-Genie/blob/master/docs/multiple-ips/README.md#feature-2-extension-cni-genie-multiple-ip-address-per-pod>menetapkan beberapa alamat IP ke sebuah Pod</a>, masing-masing dari <em>plugin</em> CNI yang berbeda.</p><h3 id=cni-ipvlan-vpc-k8s>cni-ipvlan-vpc-k8s</h3><p><a href=https://github.com/lyft/cni-ipvlan-vpc-k8s>cni-ipvlan-vpc-k8s</a> berisi satu set <em>plugin</em> CNI dan IPAM untuk menyediakan kemudahan, host-lokal, latensi rendah, <em>throughput</em> tinggi , dan tumpukan jaringan yang sesuai untuk Kubernetes dalam lingkungan Amazon Virtual Private Cloud (VPC) dengan memanfaatkan Amazon Elastic Network Interfaces (ENI) dan mengikat IP yang dikelola AWS ke Pod-Pod menggunakan <em>driver</em> IPvlan <em>kernel</em> Linux dalam mode L2.</p><p>Plugin ini dirancang untuk secara langsung mengkonfigurasi dan <em>deploy</em> dalam VPC. Kubelet melakukan <em>booting</em> dan kemudian mengkonfigurasi sendiri dan memperbanyak penggunaan IP mereka sesuai kebutuhan tanpa memerlukan kompleksitas yang sering direkomendasikan untuk mengelola jaringan <em>overlay</em>, BGP, menonaktifkan pemeriksaan sumber/tujuan, atau menyesuaikan tabel rute VPC untuk memberikan <em>subnet</em> per <em>instance</em> ke setiap <em>host</em> (yang terbatas hingga 50-100 masukan per VPC). Singkatnya, cni-ipvlan-vpc-k8s secara signifikan mengurangi kompleksitas jaringan yang diperlukan untuk menggunakan Kubernetes yang berskala di dalam AWS.</p><h3 id=contiv>Contiv</h3><p><a href=https://github.com/contiv/netplugin>Contiv</a> menyediakan jaringan yang dapat dikonfigurasi (<em>native</em> l3 menggunakan BGP, <em>overlay</em> menggunakan vxlan, classic l2, atau Cisco-SDN / ACI) untuk berbagai kasus penggunaan. <a href=http://contiv.io>Contiv</a> semuanya open sourced.</p><h3 id=contrail-tungsten-fabric>Contrail / Tungsten Fabric</h3><p><a href=http://www.juniper.net/us/en/products-services/sdn/contrail/contrail-networking/>Contrail</a>, berdasarkan <a href=https://tungsten.io>Tungsten Fabric</a>, adalah platform virtualisasi jaringan dan manajemen kebijakan <em>multi-cloud</em> yang benar-benar terbuka. Contrail dan Tungsten Fabric terintegrasi dengan berbagai sistem orkestrasi seperti Kubernetes, OpenShift, OpenStack dan Mesos, dan menyediakan mode isolasi yang berbeda untuk mesin <em>virtual</em>, banyak kontainer / banyak Pod dan beban kerja <em>bare metal</em>.</p><h3 id=danm>DANM</h3><p>[DANM] (<a href=https://github.com/nokia/danm>https://github.com/nokia/danm</a>) adalah solusi jaringan untuk beban kerja telco yang berjalan di kluster Kubernetes. Dibangun dari komponen-komponen berikut:</p><ul><li>Plugin CNI yang mampu menyediakan antarmuka IPVLAN dengan fitur-fitur canggih</li><li>Modul IPAM built-in dengan kemampuan mengelola dengan jumlah banyak, <em>cluster-wide</em>, <em>discontinous</em> jaringan L3 dan menyediakan skema dinamis, statis, atau tidak ada permintaan skema IP</li><li>Metaplugin CNI yang mampu melampirkan beberapa antarmuka jaringan ke kontainer, baik melalui CNI sendiri, atau mendelegasikan pekerjaan ke salah satu solusi CNI populer seperti SRI-OV, atau Flannel secara paralel</li><li>Pengontrol Kubernetes yang mampu mengatur secara terpusat antarmuka VxLAN dan VLAN dari semua <em>host</em> Kubernetes</li><li>Pengontrol Kubernetes lain yang memperluas konsep <em>service discovery</em> berbasis servis untuk bekerja di semua antarmuka jaringan Pod</li></ul><p>Dengan <em>toolset</em> ini, DANM dapat memberikan beberapa antarmuka jaringan yang terpisah, kemungkinan untuk menggunakan ujung belakang jaringan yang berbeda dan fitur IPAM canggih untuk Pod.</p><h3 id=flannel>Flannel</h3><p>[Flannel] (<a href=https://github.com/coreos/flannel#flannel>https://github.com/coreos/flannel#flannel</a>) adalah jaringan overlay yang sangat sederhana yang memenuhi persyaratan Kubernetes. Banyak orang telah melaporkan kesuksesan dengan Flannel dan Kubernetes.</p><h3 id=google-compute-engine-gce>Google Compute Engine (GCE)</h3><p>Untuk skrip konfigurasi kluster Google Compute Engine, <a href=https://cloud.google.com/vpc/docs/routes>perutean lanjutan</a> digunakan untuk menetapkan setiap VM <em>subnet</em> (standarnya adalah <code>/24</code> - 254 IP). Setiap lalu lintas yang terikat untuk <em>subnet</em> itu akan dialihkan langsung ke VM oleh <em>fabric</em> jaringan GCE. Ini adalah tambahan untuk alamat IP "utama" yang ditugaskan untuk VM, yang NAT'ed untuk akses internet keluar. Sebuah linux <em>bridge</em> (disebut <code>cbr0</code>) dikonfigurasikan untuk ada pada subnet itu, dan diteruskan ke <em>flag</em> <code>-bridge</code> milik docker.</p><p>Docker dimulai dengan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#b8860b>DOCKER_OPTS</span><span style=color:#666>=</span><span style=color:#b44>&#34;--bridge=cbr0 --iptables=false --ip-masq=false&#34;</span>
</span></span></code></pre></div><p>Jembatan ini dibuat oleh Kubelet (dikontrol oleh <em>flag</em> <code>--network-plugin=kubenet</code>) sesuai dengan <code>.spec.podCIDR</code> yang dimiliki oleh Node.</p><p>Docker sekarang akan mengalokasikan IP dari blok <code>cbr-cidr</code>. Kontainer dapat menjangkau satu sama lain dan Node di atas jembatan <code>cbr0</code>. IP-IP tersebut semuanya dapat dirutekan dalam jaringan proyek GCE.</p><p>GCE sendiri tidak tahu apa-apa tentang IP ini, jadi tidak akan NAT untuk lalu lintas internet keluar. Untuk mencapai itu aturan iptables digunakan untuk menyamar (alias SNAT - untuk membuatnya seolah-olah paket berasal dari lalu lintas <code>Node</code> itu sendiri) yang terikat untuk IP di luar jaringan proyek GCE (10.0.0.0/8).</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>iptables -t nat -A POSTROUTING ! -d 10.0.0.0/8 -o eth0 -j MASQUERADE
</span></span></code></pre></div><p>Terakhir IP forwarding diaktifkan di kernel (sehingga kernel akan memproses paket untuk kontainer yang dijembatani):</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sysctl net.ipv4.ip_forward<span style=color:#666>=</span><span style=color:#666>1</span>
</span></span></code></pre></div><p>Hasil dari semua ini adalah bahwa semua Pod dapat saling menjangkau dan dapat keluar lalu lintas ke internet.</p><h3 id=jaguar>Jaguar</h3><p><a href=https://gitlab.com/sdnlab/jaguar>Jaguar</a> adalah solusi open source untuk jaringan Kubernetes berdasarkan OpenDaylight. Jaguar menyediakan jaringan overlay menggunakan vxlan dan Jaguar CNIPlugin menyediakan satu alamat IP per Pod.</p><h3 id=knitter>Knitter</h3><p><a href=https://github.com/ZTE/Knitter/>Knitter</a> adalah solusi jaringan yang mendukung banyak jaringan di Kubernetes. Solusi ini menyediakan kemampuan manajemen penyewa dan manajemen jaringan. Knitter mencakup satu set solusi jaringan kontainer NFV ujung ke ujung selain beberapa pesawat jaringan, seperti menjaga alamat IP untuk aplikasi, migrasi alamat IP, dll.</p><h3 id=kube-ovn>Kube-OVN</h3><p><a href=https://github.com/alauda/kube-ovn>Kube-OVN</a> adalah <em>fabric</em> jaringan kubernetes berbasis OVN untuk <em>enterprises</em>. Dengan bantuan OVN/OVS, solusi ini menyediakan beberapa fitur jaringan <em>overlay</em> canggih seperti <em>subnet</em>, QoS, alokasi IP statis, <em>mirroring traffic</em>, <em>gateway</em>, kebijakan jaringan berbasis <em>openflow</em>, dan proksi layanan.</p><h3 id=kube-router>Kube-router</h3><p><a href=https://github.com/cloudnativelabs/kube-router>Kube-router</a> adalah solusi jaringan yang dibuat khusus untuk Kubernetes yang bertujuan untuk memberikan kinerja tinggi dan kesederhanaan operasional. Kube-router menyediakan Linux <a href=http://www.linuxvirtualserver.org/software/ipvs.html>LVS/IPVS</a> berbasis proksi layanan, solusi jaringan berbasis penerusan <em>pod-to-pod</em> Linux <em>kernel</em> tanpa <em>overlay</em>, dan penegak kebijakan jaringan berbasis <em>iptables/ipset</em>.</p><h3 id=l2-networks-and-linux-bridging>L2 networks and linux bridging</h3><p>Jika Anda memiliki jaringan L2 yang "bodoh", seperti saklar sederhana di <em>environment</em> "bare-metal", kamu harus dapat melakukan sesuatu yang mirip dengan pengaturan GCE di atas. Perhatikan bahwa petunjuk ini hanya dicoba dengan sangat sederhana - sepertinya berhasil, tetapi belum diuji secara menyeluruh. Jika kamu menggunakan teknik ini dan telah menyempurnakan prosesnya, tolong beri tahu kami.</p><p>Ikuti bagian "With Linux Bridge devices" dari <a href=http://blog.oddbit.com/2014/08/11/four-ways-to-connect-a-docker/>tutorial yang sangat bagus ini</a> dari Lars Kellogg-Stedman.</p><h3 id=multus-plugin-multi-jaringan>Multus (plugin Multi-Jaringan)</h3><p><a href=https://github.com/Intel-Corp/multus-cni>Multus</a> adalah plugin Multi CNI untuk mendukung fitur Banyak Jaringan di Kubernetes menggunakan objek jaringan berbasis CRD di Kubernetes.</p><p>Multus mendukung semua <a href=https://github.com/containernetworking/plugins>plugin referensi</a> (mis. <a href=https://github.com/containernetworking/plugins/tree/master/plugins/meta/flannel>Flannel</a>, <a href=https://github.com/containernetworking/plugins/tree/master/plugins/ipam/dhcp>DHCP</a>, [Macvlan](<a href=https://github.com/containernetworking/plugins/tree/master/plugins/main>https://github.com/containernetworking/plugins/tree/master/plugins/main</a> / macvlan)) yang mengimplementasikan spesifikasi CNI dan plugin pihak ke-3 (mis. <a href=https://github.com/projectcalico/cni-plugin>Calico</a>, <a href=https://github.com/weaveworks/weave>Weave</a>, <a href=https://github.com/cilium/cilium>Cilium</a>, <a href=https://github.com/contiv/netplugin>Contiv</a>). Selain itu, Multus mendukung <a href=https://github.com/hustcat/sriov-cni>SRIOV</a>, <a href=https://github.com/Intel-Corp/sriov-cni>DPDK</a>, <a href=https://github.com/intel/vhost-user-net-plugin>OVS- DPDK & VPP</a> beban kerja di Kubernetes dengan aplikasi cloud asli dan aplikasi berbasis NFV di Kubernetes.</p><h3 id=nsx-t>NSX-T</h3><p><a href=https://docs.vmware.com/en/VMware-NSX-T/index.html>VMware NSX-T</a> adalah virtualisasi jaringan dan platform keamanan. NSX-T dapat menyediakan virtualisasi jaringan untuk lingkungan multi-cloud dan multi-hypervisor dan berfokus pada kerangka kerja dan arsitektur aplikasi yang muncul yang memiliki titik akhir dan tumpukan teknologi yang heterogen. Selain hypervisor vSphere, lingkungan ini termasuk hypervisor lainnya seperti KVM, wadah, dan bare metal.</p><p><a href=https://docs.vmware.com/en/VMware-NSX-T/2.0/nsxt_20_ncp_kubernetes.pdf>NSX-T Container Plug-in (NCP)</a> menyediakan integrasi antara NSX-T dan pembuat wadah seperti Kubernetes, serta integrasi antara NSX-T dan platform CaaS / PaaS berbasis-kontainer seperti Pivotal Container Service (PKS) dan OpenShift.</p><h3 id=nuage-networks-vcs-layanan-cloud-virtual>Nuage Networks VCS (Layanan Cloud Virtual)</h3><p><a href=http://www.nuagenetworks.net>Nuage</a> menyediakan platform SDN (Software-Defined Networking) berbasis kebijakan yang sangat skalabel. Nuage menggunakan Open vSwitch <em>open source</em> untuk data <em>plane</em> bersama dengan SDN Controller yang kaya fitur yang dibangun pada standar terbuka.</p><p>Platform Nuage menggunakan <em>overlay</em> untuk menyediakan jaringan berbasis kebijakan yang mulus antara Kubernetes Pod-Pod dan lingkungan non-Kubernetes (VM dan server <em>bare metal</em>). Model abstraksi kebijakan Nuage dirancang dengan mempertimbangkan aplikasi dan membuatnya mudah untuk mendeklarasikan kebijakan berbutir halus untuk aplikasi. Mesin analisis <em>real-time</em> platform memungkinkan pemantauan visibilitas dan keamanan untuk aplikasi Kubernetes.</p><h3 id=ovn-open-virtual-networking>OVN (Open Virtual Networking)</h3><p>OVN adalah solusi virtualisasi jaringan opensource yang dikembangkan oleh komunitas Open vSwitch. Ini memungkinkan seseorang membuat switch logis, router logis, ACL stateful, load-balancers dll untuk membangun berbagai topologi jaringan virtual. Proyek ini memiliki plugin dan dokumentasi Kubernetes spesifik di <a href=https://github.com/openvswitch/ovn-kubernetes>ovn-kubernetes</a>.</p><h3 id=project-calico>Project Calico</h3><p><a href=http://docs.projectcalico.org/>Project Calico</a> adalah penyedia jaringan wadah sumber terbuka dan mesin kebijakan jaringan.</p><p>Calico menyediakan solusi jaringan dan kebijakan kebijakan jaringan yang sangat berskala untuk menghubungkan Pod Kubernetes berdasarkan prinsip jaringan IP yang sama dengan internet, untuk Linux (open source) dan Windows (milik - tersedia dari <a href=https://www.tigera.io/essentials/>Tigera</a>). Calico dapat digunakan tanpa enkapsulasi atau <em>overlay</em> untuk menyediakan jaringan pusat data skala tinggi yang berkinerja tinggi. Calico juga menyediakan kebijakan keamanan jaringan berbutir halus, berdasarkan niat untuk Pod Kubernetes melalui <em>firewall</em> terdistribusi.</p><p>Calico juga dapat dijalankan dalam mode penegakan kebijakan bersama dengan solusi jaringan lain seperti Flannel, alias <a href=https://github.com/tigera/canal>kanal</a>, atau jaringan GCE, AWS atau Azure asli.</p><h3 id=romana>Romana</h3><p><a href=http://romana.io>Romana</a> adalah jaringan sumber terbuka dan solusi otomasi keamanan yang memungkinkan kamu menggunakan Kubernetes tanpa jaringan hamparan. Romana mendukung Kubernetes <a href=/id/docs/concepts/services-networking/network-policies/>Kebijakan Jaringan</a> untuk memberikan isolasi di seluruh ruang nama jaringan.</p><h3 id=weave-net-dari-weaveworks>Weave Net dari Weaveworks</h3><p><a href=https://www.weave.works/products/weave-net/>Weave Net</a> adalah jaringan yang tangguh dan mudah digunakan untuk Kubernetes dan aplikasi yang dihostingnya. Weave Net berjalan sebagai <a href=https://www.weave.works/docs/net/latest/cni-plugin/>plug-in CNI</a> atau berdiri sendiri. Di kedua versi, itu tidak memerlukan konfigurasi atau kode tambahan untuk dijalankan, dan dalam kedua kasus, jaringan menyediakan satu alamat IP per Pod - seperti standar untuk Kubernetes.</p><h2 id=selanjutnya>Selanjutnya</h2><p>Desain awal model jaringan dan alasannya, dan beberapa rencana masa depan dijelaskan secara lebih rinci dalam <a href=https://git.k8s.io/community/contributors/design-proposals/network/networking.md>dokumen desain jaringan</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-c4b1e87a84441f8a90699a345ce48d68>3.11.6 - Arsitektur Logging</h1><p>Log aplikasi dan sistem dapat membantu kamu untuk memahami apa yang terjadi di dalam klaster kamu. Log berguna untuk mengidentifikasi dan menyelesaikan masalah serta memonitor aktivitas klaster. Hampir semua aplikasi modern mempunyai sejenis mekanisme log sehingga hampir semua mesin kontainer didesain untuk mendukung suatu mekanisme <em>logging</em>. Metode <em>logging</em> yang paling mudah untuk aplikasi dalam bentuk kontainer adalah menggunakan <em>standard output</em> dan <em>standard error</em>.</p><p>Namun, fungsionalitas bawaan dari mesin kontainer atau <em>runtime</em> biasanya tidak cukup memadai sebagai solusi log. Contohnya, jika sebuah kontainer gagal, sebuah pod dihapus, atau suatu <em>node</em> mati, kamu biasanya tetap menginginkan untuk mengakses log dari aplikasimu. Oleh sebab itu, log sebaiknya berada pada penyimpanan dan <em>lifecyle</em> yang terpisah dari node, pod, atau kontainer. Konsep ini dinamakan sebagai <em>logging</em> pada level klaster. <em>Logging</em> pada level klaster ini membutuhkan <em>backend</em> yang terpisah untuk menyimpan, menganalisis, dan mengkueri log. Kubernetes tidak menyediakan solusi bawaan untuk penyimpanan data log, namun kamu dapat mengintegrasikan beragam solusi <em>logging</em> yang telah ada ke dalam klaster Kubernetes kamu.</p><p>Arsitektur <em>logging</em> pada level klaster yang akan dijelaskan berikut mengasumsikan bahwa sebuah <em>logging backend</em> telah tersedia baik di dalam maupun di luar klastermu. Meskipun kamu tidak tertarik menggunakan <em>logging</em> pada level klaster, penjelasan tentang bagaimana log disimpan dan ditangani pada node di bawah ini mungkin dapat berguna untukmu.</p><h2 id=hal-dasar-logging-pada-kubernetes>Hal dasar <em>logging</em> pada Kubernetes</h2><p>Pada bagian ini, kamu dapat melihat contoh tentang dasar <em>logging</em> pada Kubernetes yang mengeluarkan data pada <em>standard output</em>. Demonstrasi berikut ini menggunakan sebuah <a href=/examples/debug/counter-pod.yaml>spesifikasi pod</a> dengan kontainer yang akan menuliskan beberapa teks ke <em>standard output</em> tiap detik.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/debug/counter-pod.yaml download=debug/counter-pod.yaml><code>debug/counter-pod.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("debug-counter-pod-yaml")' title="Copy debug/counter-pod.yaml to clipboard"></img></div><div class=includecode id=debug-counter-pod-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>counter<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>count<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[/bin/sh, -c,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:#b44>&#39;i=0; while true; do echo &#34;$i: $(date)&#34;; i=$((i+1)); sleep 1; done&#39;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Untuk menjalankan pod ini, gunakan perintah berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/debug/counter-pod.yaml
</span></span></code></pre></div><p>Keluarannya adalah:</p><pre tabindex=0><code>pod/counter created
</code></pre><p>Untuk mengambil log, gunakan perintah <code>kubectl logs</code> sebagai berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl logs counter
</span></span></code></pre></div><p>Keluarannya adalah:</p><pre tabindex=0><code>0: Mon Jan  1 00:00:00 UTC 2001
1: Mon Jan  1 00:00:01 UTC 2001
2: Mon Jan  1 00:00:02 UTC 2001
...
</code></pre><p>Kamu dapat menambahkan parameter <code>--previous</code> pada perintah <code>kubectl logs</code> untuk mengambil log dari kontainer sebelumnya yang gagal atau <em>crash</em>. Jika pod kamu memiliki banyak kontainer, kamu harus menspesifikasikan kontainer mana yang kamu ingin akses lognya dengan menambahkan nama kontainer pada perintah tersebut. Lihat <a href=/docs/reference/generated/kubectl/kubectl-commands#logs>dokumentasi <code>kubectl logs</code></a> untuk informasi lebih lanjut.</p><h2 id=node-level-logging>Node-level <em>logging</em></h2><p><img src=/images/docs/user-guide/logging/logging-node-level.png alt="Node-level logging"></p><p>Semua hal yang ditulis oleh aplikasi dalam kontainer ke <code>stdout</code> dan <code>stderr</code> akan ditangani dan diarahkan ke suatu tempat oleh mesin atau <em>engine</em> kontainer. Contohnya,mesin kontainer Docker akan mengarahkan kedua aliran tersebut ke <a href=https://docs.docker.com/engine/admin/logging/overview>suatu <em>logging driver</em></a>, yang akan dikonfigurasi pada Kubernetes untuk menuliskan ke dalam berkas dalam format json.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> <em>Logging driver</em> json dari Docker memperlakukan tiap baris sebagai pesan yang terpisah. Saat menggunakan <em>logging driver</em> Docker, tidak ada dukungan untuk menangani pesan <em>multi-line</em>. Kamu harus menangani pesan <em>multi-line</em> pada level agen log atau yang lebih tinggi.</div><p>Secara <em>default</em>, jika suatu kontainer <em>restart</em>, kubelet akan menjaga kontainer yang mati tersebut beserta lognya. Namun jika suatu pod dibuang dari <em>node</em>, maka semua hal dari kontainernya juga akan dibuang, termasuk lognya.</p><p>Hal lain yang perlu diperhatikan dalam <em>logging</em> pada level <em>node</em> adalah implementasi rotasi log, sehingga log tidak menghabiskan semua penyimpanan yang tersedia pada <em>node.</em> Kubernetes saat ini tidak bertanggung jawab dalam melakukan rotasi log, namun <em>deployment tool</em> seharusnya memberikan solusi terhadap masalah tersebut.
Contohnya, pada klaster Kubernetes, yang di <em>deployed</em> menggunakan <code>kube-up.sh</code>, terdapat alat bernama <a href=https://linux.die.net/man/8/logrotate><code>logrotate</code></a> yang dikonfigurasi untuk berjalan tiap jamnya. Kamu juga dapat menggunakan <em>runtime</em> kontainer untuk melakukan rotasi log otomatis, misalnya menggunakan <code>log-opt</code> Docker.
Pada <code>kube-up.sh</code>, metode terakhir digunakan untuk COS <em>image</em> pada GCP, sedangkan metode pertama digunakan untuk lingkungan lainnya. Pada kedua metode, secara <em>default</em> akan dilakukan rotasi pada saat berkas log melewati 10MB.</p><p>Sebagai contoh, kamu dapat melihat informasi lebih rinci tentang bagaimana <code>kube-up.sh</code> mengatur <em>logging</em> untuk COS <em>image</em> pada GCP yang terkait dengan <a href=https://github.com/kubernetes/kubernetes/blob/main/cluster/gce/gci/configure-helper.sh><em>script</em></a>.</p><p>Saat kamu menjalankan perintah <a href=/docs/reference/generated/kubectl/kubectl-commands#logs><code>kubectl logs</code></a> seperti pada contoh tadi, kubelet di <em>node</em> tersebut akan menangani permintaan untuk membaca langsung isi berkas log sebagai respon.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Saat ini, jika suatu sistem eksternal telah melakukan rotasi, hanya konten dari berkas log terbaru yang akan tersedia melalui perintah <code>kubectl logs</code>. Contoh, jika terdapat sebuah berkas 10MB, <code>logrotate</code> akan melakukan rotasi sehingga akan ada dua buah berkas, satu dengan ukuran 10MB, dan satu berkas lainnya yang kosong. Maka <code>kubectl logs</code> akan mengembalikan respon kosong.</div><h3 id=komponen-sistem-log>Komponen sistem log</h3><p>Terdapat dua jenis komponen sistem: yaitu yang berjalan di dalam kontainer dan komponen lain yang tidak berjalan di dalam kontainer. Sebagai contoh:</p><ul><li>Kubernetes <em>scheduler</em> dan kube-proxy berjalan di dalam kontainer.</li><li>Kubelet dan <em>runtime</em> kontainer, contohnya Docker, tidak berjalan di dalam kontainer.</li></ul><p>Pada mesin yang menggunakan systemd, kubelet dan runtime <em>runtime</em> menulis ke journald. Jika systemd tidak tersedia, keduanya akan menulis ke berkas <code>.log</code> pada folder <code>/var/log</code>.
Komponen sistem di dalam kontainer akan selalu menuliskan ke folder <code>/var/log</code>, melewati mekanisme <em>default logging</em>. Mereka akan menggunakan <em>logging library</em> <a href=https://github.com/kubernetes/klog>klog</a>.
Kamu dapat menemukan konvensi tentang tingkat kegawatan <em>logging</em> untuk komponen-komponen tersebut pada <a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-instrumentation/logging.md>dokumentasi <em>development logging</em></a>.</p><p>Seperti halnya pada log kontainer, komponen sistem yang menuliskan log pada folder <code>/var/log</code> juga harus melakukan rotasi log. Pada klaster Kubernetes yang menggunakan <code>kube-up.sh</code>, log tersebut telah dikonfigurasi dan akan dirotasi oleh <code>logrotate</code> secara harian atau saat ukuran log melebihi 100MB.</p><h2 id=arsitektur-klaster-level-logging>Arsitektur klaster-level <em>logging</em></h2><p>Meskipun Kubernetes tidak menyediakan solusi bawaan untuk <em>logging</em> level klaster, ada beberapa pendekatan yang dapat kamu pertimbangkan. Berikut beberapa diantaranya:</p><ul><li>Menggunakan agen <em>logging</em> pada level <em>node</em> yang berjalan pada setiap <em>node</em>.</li><li>Menggunakan kontainer <em>sidecar</em> khusus untuk <em>logging</em> aplikasi di dalam pod.</li><li>Mengeluarkan log langsung ke <em>backend</em> dari dalam aplikasi</li></ul><h3 id=menggunakan-agen-node-level-logging>Menggunakan agen node-level <em>logging</em></h3><p><img src=/images/docs/user-guide/logging/logging-with-node-agent.png alt="Menggunakan agen node-level logging"></p><p>Kamu dapat mengimplementasikan klaster-level <em>logging</em> dengan menggunakan agen yang berjalan pada setiap <em>node</em>. Agen <em>logging</em> merupakan perangkat khusus yang akan mengekspos log atau mengeluarkan log ke <em>backend</em>. Umumnya agen <em>logging</em> merupakan kontainer yang memiliki akses langsung ke direktori tempat berkas log berada dari semua kontainer aplikasi yang berjalan pada <em>node</em> tersebut.</p><p>Karena agen <em>logging</em> harus berjalan pada setiap <em>node</em>, umumnya dilakukan dengan menggunakan replika DaemonSet, <em>manifest</em> pod, atau menjalankan proses khusus pada <em>node</em>. Namun dua cara terakhir sudah dideprekasi dan sangat tidak disarankan.</p><p>Menggunakan agen <em>logging</em> pada level <em>node</em> merupakan cara yang paling umum dan disarankan untuk klaster Kubernetes. Hal ini karena hanya dibutuhkan satu agen tiap node dan tidak membutuhkan perubahan apapun dari sisi aplikasi yang berjalan pada <em>node</em>. Namun, node-level <em>logging</em> hanya dapat dilakukan untuk aplikasi yang menggunakan <em>standard output</em> dan <em>standard error</em>.</p><p>Kubernetes tidak menspesifikasikan khusus suatu agen <em>logging</em>, namun ada dua agen <em>logging</em> yang dimasukkan dalam rilis Kubernetes: <a href=/docs/user-guide/logging/stackdriver>Stackdriver Logging</a> untuk digunakan pada Google Cloud Platform, dan <a href=/docs/user-guide/logging/elasticsearch>Elasticsearch</a>. Kamu dapat melihat informasi dan instruksi pada masing-masing dokumentasi. Keduanya menggunakan <a href=http://www.fluentd.org/>fluentd</a> dengan konfigurasi kustom sebagai agen pada <em>node</em>.</p><h3 id=menggunakan-kontainer-sidecar-dengan-agen-logging>Menggunakan kontainer <em>sidecar</em> dengan agen <em>logging</em></h3><p>Kamu dapat menggunakan kontainer <em>sidecar</em> dengan salah satu cara berikut:</p><ul><li>Kontainer <em>sidecar</em> mengeluarkan log aplikasi ke <code>stdout</code> miliknya sendiri.</li><li>Kontainer <em>sidecar</em> menjalankan agen <em>logging</em> yang dikonfigurasi untuk mengambil log dari aplikasi kontainer.</li></ul><h4 id=kontainer-streaming-sidecar>Kontainer <em>streaming</em> <em>sidecar</em></h4><p><img src=/images/docs/user-guide/logging/logging-with-streaming-sidecar.png alt="Kontainer sidecar dengan kontainer streaming"></p><p>Kamu dapat memanfaatkan kubelet dan agen <em>logging</em> yang telah berjalan pada tiap <em>node</em> dengan menggunakan kontainer <em>sidecar</em>. Kontainer <em>sidecar</em> dapat membaca log dari sebuah berkas, <em>socket</em> atau journald. Tiap kontainer <em>sidecar</em> menuliskan log ke <code>stdout</code> atau <code>stderr</code> mereka sendiri.</p><p>Dengan menggunakan cara ini kamu dapat memisahkan aliran log dari bagian-bagian yang berbeda dari aplikasimu, yang beberapa mungkin tidak mendukung log ke <code>stdout</code> dan <code>stderr</code>. Perubahan logika aplikasimu dengan menggunakan cara ini cukup kecil, sehingga hampir tidak ada <em>overhead</em>. Selain itu, karena <code>stdout</code> dan <code>stderr</code> ditangani oleh kubelet, kamu juga dapat menggunakan alat bawaan seperti <code>kubectl logs</code>.</p><p>Sebagai contoh, sebuah pod berjalan pada satu kontainer tunggal, dan kontainer menuliskan ke dua berkas log yang berbeda, dengan dua format yang berbeda pula. Berikut ini <em>file</em> konfigurasi untuk Pod:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/admin/logging/two-files-counter-pod.yaml download=admin/logging/two-files-counter-pod.yaml><code>admin/logging/two-files-counter-pod.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-logging-two-files-counter-pod-yaml")' title="Copy admin/logging/two-files-counter-pod.yaml to clipboard"></img></div><div class=includecode id=admin-logging-two-files-counter-pod-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>counter<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>count<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- /bin/sh<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- -c<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- &gt;<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      i=0;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      while true;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      do
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        echo &#34;$i: $(date)&#34; &gt;&gt; /var/log/1.log;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        echo &#34;$(date) INFO $i&#34; &gt;&gt; /var/log/2.log;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        i=$((i+1));
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        sleep 1;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      done</span><span style=color:#bbb>      
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/log<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Hal ini akan menyulitkan untuk mengeluarkan log dalam format yang berbeda pada aliran log yang sama, meskipun kamu dapat me-<em>redirect</em> keduanya ke <code>stdout</code> dari kontainer. Sebagai gantinya, kamu dapat menggunakan dua buah kontainer <em>sidecar</em>. Tiap kontainer <em>sidecar</em> dapat membaca suatu berkas log tertentu dari <em>shared volume</em> kemudian mengarahkan log ke <code>stdout</code>-nya sendiri.</p><p>Berikut <em>file</em> konfigurasi untuk pod yang memiliki dua buah kontainer <em>sidecard</em>:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/admin/logging/two-files-counter-pod-streaming-sidecar.yaml download=admin/logging/two-files-counter-pod-streaming-sidecar.yaml><code>admin/logging/two-files-counter-pod-streaming-sidecar.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-logging-two-files-counter-pod-streaming-sidecar-yaml")' title="Copy admin/logging/two-files-counter-pod-streaming-sidecar.yaml to clipboard"></img></div><div class=includecode id=admin-logging-two-files-counter-pod-streaming-sidecar-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>counter<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>count<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- /bin/sh<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- -c<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- &gt;<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      i=0;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      while true;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      do
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        echo &#34;$i: $(date)&#34; &gt;&gt; /var/log/1.log;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        echo &#34;$(date) INFO $i&#34; &gt;&gt; /var/log/2.log;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        i=$((i+1));
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        sleep 1;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      done</span><span style=color:#bbb>      
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/log<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>count-log-1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[/bin/sh, -c, &#39;tail -n+1 -F /var/log/1.log&#39;]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/log<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>count-log-2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[/bin/sh, -c, &#39;tail -n+1 -F /var/log/2.log&#39;]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/log<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Saat kamu menjalankan pod ini, kamu dapat mengakses tiap aliran log secara terpisah dengan menjalankan perintah berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl logs counter count-log-1
</span></span></code></pre></div><pre tabindex=0><code>0: Mon Jan  1 00:00:00 UTC 2001
1: Mon Jan  1 00:00:01 UTC 2001
2: Mon Jan  1 00:00:02 UTC 2001
...
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl logs counter count-log-2
</span></span></code></pre></div><pre tabindex=0><code>Mon Jan  1 00:00:00 UTC 2001 INFO 0
Mon Jan  1 00:00:01 UTC 2001 INFO 1
Mon Jan  1 00:00:02 UTC 2001 INFO 2
...
</code></pre><p>Agen node-level yang terpasang di klastermu akan mengambil aliran log tersebut secara otomatis tanpa perlu melakukan konfigurasi tambahan. Bahkan jika kamu mau, kamu dapat mengonfigurasi agen untuk melakukan <em>parse</em> baris log tergantung dari kontainer sumber awalnya.</p><p>Sedikit catatan, meskipun menggunakan memori dan CPU yang cukup rendah (sekitar beberapa milicore untuk CPU dan beberapa megabytes untuk memori), penulisan log ke <em>file</em> kemudian mengalirkannya ke <code>stdout</code> dapat berakibat penggunaan disk yang lebih besar. Jika kamu memiliki aplikasi yang menuliskan ke <em>file</em> tunggal, umumnya lebih baik menggunakan <code>/dev/stdout</code> sebagai tujuan daripada menggunakan pendekatan dengan kontainer <em>sidecar</em>.</p><p>Kontainer <em>sidecar</em> juga dapat digunakan untuk melakukan rotasi berkas log yang tidak dapat dirotasi oleh aplikasi itu sendiri. Contoh dari pendekatan ini adalah sebuah kontainer kecil yang menjalankan rotasi log secara periodik. Namun, direkomendasikan untuk menggunakan <code>stdout</code> dan <code>stderr</code> secara langsung dan menyerahkan kebijakan rotasi dan retensi pada kubelet.</p><h4 id=kontainer-sidecar-dengan-agen-logging>Kontainer <em>sidecar</em> dengan agen <em>logging</em></h4><p><img src=/images/docs/user-guide/logging/logging-with-sidecar-agent.png alt="Kontainer sidecar dengan agen logging"></p><p>Jika agen node-level <em>logging</em> tidak cukup fleksible untuk kebutuhanmu, kamu dapat membuat kontainer <em>sidecar</em> dengan agen <em>logging</em> yang terpisah, yang kamu konfigurasi spesifik untuk berjalan dengan aplikasimu.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Menggunakan agen <em>logging</em> di dalam kontainer <em>sidecar</em> dapat berakibat penggunaan <em>resource</em> yang signifikan. Selain itu, kamu tidak dapat mengakses log itu dengan menggunakan perintah <code>kubectl logs</code>, karena mereka tidak dikontrol oleh kubelet.</div><p>Sebagai contoh, kamu dapat menggunakan <a href=/docs/tasks/debug-application-cluster/logging-stackdriver/>Stackdriver</a>,
yang menggunakan fluentd sebagai agen <em>logging</em>. Berikut ini dua <em>file</em> konfigurasi yang dapat kamu pakai untuk mengimplementasikan cara ini. <em>File</em> yang pertama berisi sebuah <a href=/id/docs/tasks/configure-pod-container/configure-pod-configmap/>ConfigMap</a> untuk mengonfigurasi fluentd.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/admin/logging/fluentd-sidecar-config.yaml download=admin/logging/fluentd-sidecar-config.yaml><code>admin/logging/fluentd-sidecar-config.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-logging-fluentd-sidecar-config-yaml")' title="Copy admin/logging/fluentd-sidecar-config.yaml to clipboard"></img></div><div class=includecode id=admin-logging-fluentd-sidecar-config-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fluentd-config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>fluentd.conf</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    &lt;source&gt;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      type tail
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      format none
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      path /var/log/1.log
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      pos_file /var/log/1.log.pos
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      tag count.format1
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    &lt;/source&gt;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    &lt;source&gt;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      type tail
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      format none
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      path /var/log/2.log
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      pos_file /var/log/2.log.pos
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      tag count.format2
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    &lt;/source&gt;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    &lt;match **&gt;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      type google_cloud
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    &lt;/match&gt;</span><span style=color:#bbb>    
</span></span></span></code></pre></div></div></div><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Konfigurasi fluentd berada diluar cakupan artikel ini. Untuk informasi lebih lanjut tentang cara mengonfigurasi fluentd, silakan lihat <a href=http://docs.fluentd.org/>dokumentasi resmi fluentd </a>.</div><p><em>File</em> yang kedua mendeskripsikan sebuah pod yang memiliki kontainer <em>sidecar</em> yang menjalankan fluentd. Pod ini melakukan <em>mount</em> sebuah volume yang akan digunakan fluentd untuk mengambil data konfigurasinya.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/admin/logging/two-files-counter-pod-agent-sidecar.yaml download=admin/logging/two-files-counter-pod-agent-sidecar.yaml><code>admin/logging/two-files-counter-pod-agent-sidecar.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-logging-two-files-counter-pod-agent-sidecar-yaml")' title="Copy admin/logging/two-files-counter-pod-agent-sidecar.yaml to clipboard"></img></div><div class=includecode id=admin-logging-two-files-counter-pod-agent-sidecar-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>counter<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>count<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- /bin/sh<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- -c<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- &gt;<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      i=0;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      while true;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      do
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        echo &#34;$i: $(date)&#34; &gt;&gt; /var/log/1.log;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        echo &#34;$(date) INFO $i&#34; &gt;&gt; /var/log/2.log;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        i=$((i+1));
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        sleep 1;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      done</span><span style=color:#bbb>      
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/log<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>count-agent<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/fluentd-gcp:1.30<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>FLUENTD_ARGS<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span>-c /etc/fluentd-config/fluentd.conf<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/log<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/fluentd-config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>configMap</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fluentd-config<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Setelah beberapa saat, kamu akan mendapati pesan log pada <em>interface</em> Stackdriver.</p><p>Ingat, ini hanya contoh saja dan kamu dapat mengganti fluentd dengan agen <em>logging</em> lainnya, yang dapat membaca sumber apa saja dari dalam kontainer aplikasi.</p><h3 id=mengekspos-log-langsung-dari-aplikasi>Mengekspos log langsung dari aplikasi</h3><p><img src=/images/docs/user-guide/logging/logging-from-application.png alt="Mengekspos log langsung dari aplikasi"></p><p>Kamu dapat mengimplementasikan klaster-level <em>logging</em> dengan mengekspos atau mengeluarkan log langsung dari tiap aplikasi; namun cara implementasi mekanisme <em>logging</em> tersebut diluar cakupan dari Kubernetes.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-cbfd3654996eae9fcdef009f70fa83f0>3.11.7 - Metrik untuk Komponen Sistem Kubernetes</h1><p>Metrik dari komponen sistem dapat memberikan gambaran yang lebih baik tentang apa
yang sedang terjadi di dalam sistem. Metrik sangat berguna untuk membuat dasbor (<em>dashboard</em>)
dan peringatan (<em>alert</em>).</p><p>Komponen Kubernetes mengekspos metrik dalam <a href=https://prometheus.io/docs/instrumenting/exposition_formats/>format Prometheus</a>.
Format ini berupa teks biasa yang terstruktur, dirancang agar orang dan mesin dapat membacanya.</p><h2 id=metrik-metrik-dalam-kubernetes>Metrik-metrik dalam Kubernetes</h2><p>Dalam kebanyakan kasus, metrik tersedia pada <em>endpoint</em> <code>/metrics</code> dari server HTTP.
Untuk komponen yang tidak mengekspos <em>endpoint</em> secara bawaan, <em>endpoint</em> tersebut dapat diaktifkan
dengan menggunakan opsi <code>--bind-address</code>.</p><p>Contoh-contoh untuk komponen tersebut adalah:</p><ul><li><a class=glossary-tooltip title='Komponen control plane yang menjalankan pengontrol.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-controller-manager/ target=_blank aria-label=kube-controller-manager>kube-controller-manager</a></li><li><a class=glossary-tooltip title='kube-proxy merupakan proksi jaringan yang berjalan pada setiap node di dalam klaster.' data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-proxy/ target=_blank aria-label=kube-proxy>kube-proxy</a></li><li><a class=glossary-tooltip title='Komponen control plane yang mengekspos API Kubernetes. Merupakan front-end dari control plane Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-apiserver/ target=_blank aria-label=kube-apiserver>kube-apiserver</a></li><li><a class=glossary-tooltip title='Komponen control plane yang bertugas mengamati Pod baru yang belum ditempatkan di node manapun dan kemudian memilihkan node di mana Pod baru tersebut akan dijalankan.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-scheduler/ target=_blank aria-label=kube-scheduler>kube-scheduler</a></li><li><a class=glossary-tooltip title='Agen yang dijalankan pada setiap node di klaster yang bertugas untuk memastikan kontainer dijalankan di dalam Pod.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a></li></ul><p>Di dalam lingkungan produksi, kamu mungkin ingin mengonfigurasi <a href=https://prometheus.io/>Server Prometheus</a>
atau pengambil metrik (<em>metrics scraper</em>) lainnya untuk mengumpulkan metrik-metrik ini secara berkala
dan membuatnya tersedia dalam semacam pangkalan data deret waktu (<em>time series database</em>).</p><p>Perlu dicatat bahwa <a class=glossary-tooltip title='Agen yang dijalankan pada setiap node di klaster yang bertugas untuk memastikan kontainer dijalankan di dalam Pod.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a>
juga mengekspos metrik pada <em>endpoint-endpoint</em> seperti <code>/metrics/cadvisor</code>,
<code>/metrics/resource</code> dan <code>/metrics/probes</code>. Metrik-metrik tersebut tidak memiliki
siklus hidup yang sama.</p><p>Jika klastermu menggunakan <a class=glossary-tooltip title='Mengelola keputusan otorisasi, memungkinkan admin untuk mengonfigurasi kebijakan akses secara dinamis melalui API Kubernetes.' data-toggle=tooltip data-placement=top href=/id/docs/reference/access-authn-authz/rbac/ target=_blank aria-label=RBAC>RBAC</a>,
maka membaca metrik memerlukan otorisasi melalui <em>user</em>, <em>group</em>, atau
ServiceAccount dengan ClusterRole yang memperbolehkan untuk mengakses <code>/metrics</code>.</p><p>Sebagai contoh:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>prometheus<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>nonResourceURLs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;/metrics&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- get<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=siklus-hidup-metrik>Siklus hidup metrik</h2><p>Metrik alfa (<em>alpha</em>) → Metrik stabil → Metrik usang (<em>deprecated</em>) → Metrik tersembunyi → Metrik terhapus</p><p>Metrik alfa tidak memiliki jaminan stabilitas. Metrik ini
dapat dimodifikasi atau dihapus kapan saja.</p><p>Metrik stabil dijamin tidak akan mengalami perubahan. Hal ini berarti:</p><ul><li>Metrik stabil tanpa penanda usang (<em>deprecated signature</em>) tidak akan dihapus ataupun diganti namanya</li><li>Jenis metrik stabil tidak akan dimodifikasi</li></ul><p>Metrik usang dijadwalkan untuk dihapus, tetapi masih tersedia untuk digunakan.
Metrik ini mencakup anotasi versi di mana metrik ini dianggap menjadi usang.</p><p>Sebagai contoh:</p><ul><li><p>Sebelum menjadi usang</p><pre tabindex=0><code># HELP some_counter this counts things
# TYPE some_counter counter
some_counter 0
</code></pre></li><li><p>Setelah menjadi usang</p><pre tabindex=0><code># HELP some_counter (Deprecated since 1.15.0) this counts things
# TYPE some_counter counter
some_counter 0
</code></pre></li></ul><p>Metrik tersembunyi tidak lagi dipublikasikan untuk pengambilan metrik (<em>scraping</em>), tetapi masih tersedia untuk digunakan. Untuk menggunakan metrik tersembunyi, lihat bagian <a href=#menampilkan-metrik-tersembunyi>Menampilkan metrik tersembunyi</a>.</p><p>Metrik yang terhapus tidak lagi dipublikasikan dan tidak dapat digunakan lagi.</p><h2 id=menampilkan-metrik-tersembunyi>Menampilkan metrik tersembunyi</h2><p>Seperti yang dijelaskan di atas, admin dapat mengaktifkan metrik tersembunyi melalui opsi baris perintah pada biner (program) tertentu. Ini dimaksudkan untuk digunakan sebagai jalan keluar bagi admin jika mereka melewatkan migrasi metrik usang dalam rilis terakhir.</p><p>Opsi <code>show-hidden-metrics-for-version</code> menerima input versi yang kamu inginkan untuk menampilkan metrik usang dalam rilis tersebut. Versi tersebut dinyatakan sebagai x.y, di mana x adalah versi mayor, y adalah versi minor. Versi <em>patch</em> tidak diperlukan meskipun metrik dapat menjadi usang dalam rilis <em>patch</em>, alasannya adalah kebijakan penandaan metrik usang dijalankan terhadap rilis minor.</p><p>Opsi tersebut hanya dapat menerima input versi minor sebelumnya sebagai nilai. Semua metrik yang disembunyikan di versi sebelumnya akan dikeluarkan jika admin mengatur versi sebelumnya ke <code>show-hidden-metrics-for-version</code>. Versi yang terlalu lama tidak diperbolehkan karena melanggar kebijakan untuk metrik usang.</p><p>Ambil metrik <code>A</code> sebagai contoh, di sini diasumsikan bahwa <code>A</code> sudah menjadi usang di versi 1.n. Berdasarkan kebijakan metrik usang, kita dapat mencapai kesimpulan berikut:</p><ul><li>Pada rilis <code>1.n</code>, metrik menjadi usang, dan dapat dikeluarkan secara bawaan.</li><li>Pada rilis <code>1.n+1</code>, metrik disembunyikan secara bawaan dan dapat dikeluarkan dengan baris perintah <code>show-hidden-metrics-for-version=1.n</code>.</li><li>Pada rilis <code>1.n+2</code>, metrik harus dihapus dari <em>codebase</em>. Tidak ada jalan keluar lagi.</li></ul><p>Jika kamu meningkatkan versi dari rilis <code>1.12</code> ke <code>1.13</code>, tetapi masih bergantung pada metrik <code>A</code> yang usang di <code>1.12</code>, kamu harus mengatur metrik tersembunyi melalui baris perintah: <code>--show-hidden-metrics = 1.12</code> dan ingatlah untuk menghapus ketergantungan terhadap metrik ini sebelum meningkatkan versi rilis ke <code>1.14</code>.</p><h2 id=menonaktifkan-metrik-akselerator>Menonaktifkan metrik akselerator</h2><p>kubelet mengumpulkan metrik akselerator melalui cAdvisor. Untuk mengumpulkan metrik ini, untuk akselerator seperti GPU NVIDIA, kubelet membuka koneksi dengan <em>driver</em> GPU. Ini berarti untuk melakukan perubahan infrastruktur (misalnya, pemutakhiran <em>driver</em>), administrator klaster perlu menghentikan agen kubelet.</p><p>Pengumpulkan metrik akselerator sekarang menjadi tanggung jawab vendor dibandingkan kubelet. Vendor harus menyediakan sebuah kontainer untuk mengumpulkan metrik dan mengeksposnya ke layanan metrik (misalnya, Prometheus).</p><p><a href=/docs/reference/command-line-tools-reference/feature-gates/>Gerbang fitur <code>DisableAcceleratorUsageMetrics</code></a> menonaktifkan metrik yang dikumpulkan oleh kubelet, dengan <a href=https://github.com/kubernetes/enhancements/tree/411e51027db842355bd489691af897afc1a41a5e/keps/sig-node/1867-disable-accelerator-usage-metrics#graduation-criteria>lini masa (<em>timeline</em>) untuk mengaktifkan fitur ini secara bawaan</a>.</p><h2 id=metrik-komponen>Metrik komponen</h2><h3 id=metrik-kube-controller-manager>Metrik kube-controller-manager</h3><p>Metrik <em>controller manager</em> memberikan gambaran penting
tentang kinerja dan kesehatan <em>controller manager</em>. Metrik ini mencakup metrik
<em>runtime</em> bahasa Go yang umum seperti jumlah go_routine dan metrik khusus
pengontrol seperti latensi permintaan etcd atau latensi API Cloudprovider
(AWS, GCE, OpenStack) yang dapat digunakan untuk mengukur kesehatan klaster.</p><p>Mulai dari Kubernetes 1.7, metrik Cloudprovider yang detail tersedia untuk
operasi penyimpanan untuk GCE, AWS, Vsphere, dan OpenStack.
Metrik ini dapat digunakan untuk memantau kesehatan operasi <em>persistent volume</em>.</p><p>Misalnya, untuk GCE metrik-metrik berikut ini dipanggil:</p><pre tabindex=0><code>cloudprovider_gce_api_request_duration_seconds { request = &#34;instance_list&#34;}
cloudprovider_gce_api_request_duration_seconds { request = &#34;disk_insert&#34;}
cloudprovider_gce_api_request_duration_seconds { request = &#34;disk_delete&#34;}
cloudprovider_gce_api_request_duration_seconds { request = &#34;attach_disk&#34;}
cloudprovider_gce_api_request_duration_seconds { request = &#34;detach_disk&#34;}
cloudprovider_gce_api_request_duration_seconds { request = &#34;list_disk&#34;}
</code></pre><h3 id=metrik-kube-scheduler>Metrik kube-scheduler</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.20 [alpha]</code></div><p>Penjadwal mengekspos metrik opsional yang melaporkan sumber daya yang diminta dan limit yang diinginkan dari semua pod yang berjalan. Metrik ini dapat digunakan untuk membangun dasbor perencanaan kapasitas, mengevaluasi limit penjadwalan yang digunakan saat ini atau secara historis, dengan cepat mengidentifikasi beban kerja yang tidak dapat dijadwalkan karena kurangnya sumber daya, dan membandingkan permintaan sumber daya oleh pod dengan penggunaannya yang aktual.</p><p>kube-scheduler mengidentifikasi <a href=/docs/concepts/configuration/manage-resources-containers/>permintaan dan limit</a> sumber daya yang dikonfigurasi untuk setiap Pod; jika permintaan atau limit bukan nol, kube-scheduler akan melaporkan deret waktu (<em>timeseries</em>) metrik. Deret waktu diberi label dengan:</p><ul><li>namespace</li><li>nama pod</li><li>node di mana pod dijadwalkan atau <em>string</em> kosong jika belum dijadwalkan</li><li>prioritas</li><li>penjadwal yang ditugaskan untuk pod itu</li><li>nama dari sumber daya (misalnya, <code>cpu</code>)</li><li>satuan dari sumber daya jika diketahui (misalnya, <code>cores</code>)</li></ul><p>Setelah pod selesai (memiliki <code>restartPolicy</code> <code>Never</code> atau <code>OnFailure</code> dan berada dalam fase pod <code>Succeeded</code> atau <code>Failed</code>, atau telah dihapus dan semua kontainer dalam keadaan Terminated) deret metrik tidak lagi dilaporkan karena penjadwal sekarang sudah dibebaskan untuk menjadwalkan pod lain untuk dijalankan. Metrik yang dibahas pada bagian ini dikenal sebagai <code>kube_pod_resource_request</code> dan <code>kube_pod_resource_limit</code>.</p><p>Metrik diekspos melalui <em>endpoint</em> HTTP <code>/metrics/resources</code> dan memerlukan otorisasi yang sama seperti endpoint <code>/metrics</code>
pada penjadwal. Kamu harus menggunakan opsi <code>--show-hidden-metrics-for-version=1.20</code> untuk mengekspos metrik-metrik stabilitas alfa ini.</p><h2 id=selanjutnya>Selanjutnya</h2><ul><li>Baca tentang <a href=https://github.com/prometheus/docs/blob/master/content/docs/instrumenting/exposition_formats.md#text-based-format>format teks Prometheus</a> untuk berbagai metrik</li><li>Baca tentang <a href=/docs/reference/using-api/deprecation-policy/#deprecating-a-feature-or-behavior>kebijakan <em>deprecation</em> Kubernetes</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-2e05a56491965ae320c2662590b2ca18>3.11.8 - Konfigurasi Garbage Collection pada kubelet</h1><p><em>Garbage collection</em> merupakan fitur kubelet yang sangat bermanfaat, yang akan membersihkan <em>image-image</em> dan juga kontainer-kontainer
yang tidak lagi digunakan. Kubelet akan melakukan <em>garbage collection</em> untuk kontainer setiap satu menit dan <em>garbage collection</em> untuk
<em>image</em> setiap lima menit.</p><p>Perangkat <em>garbage collection</em> eksternal tidak direkomendasikan karena perangkat tersebut berpotensi merusak perilaku kubelet dengan
menghilangkan kontainer-kontainer yang sebenarnya masih diperlukan.</p><h2 id=garbage-collection-untuk-image><em>Garbage Collection</em> untuk <em>Image</em></h2><p>Kubernetes mengelola <em>lifecycle</em> untuk seluruh <em>image</em> melalui <em>imageManager</em>, dengan bantuan cadvisor.</p><p><em>Policy</em> untuk melakukan <em>garbage collection</em> memperhatikan dua hal: <code>HighThresholdPercent</code> dan <code>LowThresholdPercent</code>.
Penggunaan disk yang melewati batas atas (<em>high threshold</em>) akan men-<em>trigger</em> <em>garbage collection</em>.
<em>Garbage collection</em> akan mulai menghapus dari <em>image-image</em> yang paling jarang digunakan (<em>least recently used</em>)
sampai menemui batas bawah (<em>low threshold</em>) kembali.</p><h2 id=garbage-collection-untuk-kontainer><em>Garbage Collection</em> untuk Kontainer</h2><p><em>Policy</em> untuk melakukan <em>garbage collection</em> pada kontainer memperhatikan tiga variabel yang ditentukan oleh pengguna (<em>user-defined</em>).
<code>MinAge</code> merupakan umur minimal dimana suatu kontainer dapat terkena <em>garbage collection</em>.
<code>MaxPerPodContainer</code> merupakan jumlah maksimum yang diperbolehkan untuk setiap pod (UID, container name) <em>pair</em> memiliki
kontainer-kontainer yang sudah mati (<em>dead containers</em>). <code>MaxContainers</code> merupakan jumlah maksimal total dari seluruh kontainer yang sudah mati.
Semua variabel ini dapat dinonaktifkan secara individual, dengan mengatur <code>MinAge</code> ke angka nol serta mengatur <code>MaxPerPodContainer</code> dan <code>MaxContainers</code>
ke angka di bawah nol.</p><p>Kubelet akan mengambil tindakan untuk kontainer-kontainer yang tidak dikenal, sudah dihapus, atau diluar batasan-batasan yang diatur
sebelumnya melalui <em>flag</em>. Kontainer-kontainer yang paling lama (tertua) biasanya akan dihapus terlebih dahulu. <code>MaxPerPodContainer</code> dan <code>MaxContainer</code>
berpotensi mengalami konflik satu sama lain pada situasi saat menjaga jumlah maksimal kontainer per pod (<code>MaxPerPodContainer</code>) akan melebihi
jumlah kontainer mati (<em>dead containers</em>) yang diperbolehkan (<code>MaxContainers</code>).
<code>MaxPerPodContainer</code> dapat diatur sedemikian rupa dalam situasi ini: Seburuk-buruhknya dengan melakukan <em>downgrade</em> <code>MaxPerPodContainer</code> ke angka 1
dan melakukan <em>evict</em> kontainer-kontainer yang paling lama. Selain itu, kontainer-kontainer milik Pod yang telah dihapus akan dihilangkan
saat umur mereka telah melebihi <code>MinAge</code>.</p><p>Kontainer-kontainer yang tidak dikelola oleh kubelet akan terbebas dari <em>garbage collection</em>.</p><h2 id=konfigurasi-pengguna>Konfigurasi Pengguna</h2><p>Para pengguna dapat mengatur <em>threshold-threshold</em> untuk melakukan <em>tuning</em> pada <em>garbage collection image</em>
melalui <em>flag-flag</em> kubelet sebagai berikut:</p><ol><li><code>image-gc-high-threshold</code>, persentase dari penggunaan disk yang men-<em>trigger</em> proses <em>garbage collection</em> untuk <em>image</em>.
<em>Default</em>-nya adalah 85%.</li><li><code>image-gc-low-threshold</code>, persentase dari penggunaan disk dimana <em>garbage collection</em> berusaha menghapus <em>image</em>.
<em>Default</em>-nya adalah 80%.</li></ol><p>Kami juga memperbolehkan para pengguna untuk menyesuaikan <em>policy garbage collection</em> melalui
<em>flag-flag</em> kubelet sebagai berikut:</p><ol><li><code>minimum-container-ttl-duration</code>, umur minimal untuk setiap kontainer yang sudah selesai (<em>finished</em>) sebelum
terkena <em>garbage collection</em>. <em>Default</em>-nya adalah 0 menit, yang berarti setiap kontainer yang telah selesai akan
terkena <em>garbage collection</em>.</li><li><code>maximum-dead-containers-per-container</code>, jumlah maksimal dari kontainer-kontainer lama yang diperbolehkan ada
secara global. <em>Default</em>-nya adalah -1, yang berarti tidak ada batasannya untuk global.</li></ol><p>Kontainer-kontainer dapat berpotensi terkena <em>garbage collection</em> sebelum kegunaannya telah usang. Kontainer-kontainer
ini memliki log dan data lainnya yang bisa saja berguna saat <em>troubleshoot</em>. Sangat direkomendasikan untuk menetapkan
angka yang cukup besar pada <code>maximum-dead-containers-per-container</code>, untuk memperbolehkan paling tidak 1 kontainer mati
untuk dijaga (<em>retained</em>) per jumlah kontainer yang diharapkan. Angka yang lebih besar untuk <code>maximum-dead-containers</code>
juga direkomendasikan untuk alasan serupa.
Lihat <a href=https://github.com/kubernetes/kubernetes/issues/13287>isu ini</a> untuk penjelasan lebih lanjut.</p><h2 id=deprecation><em>Deprecation</em></h2><p>Beberapa fitur <em>Garbage Collection</em> pada kubelet di laman ini akan digantikan oleh fitur <em>eviction</em> nantinya, termasuk:</p><table><thead><tr><th><em>Flag Existing</em></th><th><em>Flag</em> Baru</th><th>Alasan</th></tr></thead><tbody><tr><td><code>--image-gc-high-threshold</code></td><td><code>--eviction-hard</code> atau <code>--eviction-soft</code></td><td>sinyal <em>eviction</em> yang ada (<em>existing</em>) dapat men-<em>trigger</em> <em>garbage collection</em></td></tr><tr><td><code>--image-gc-low-threshold</code></td><td><code>--eviction-minimum-reclaim</code></td><td>hal serupa dapat diperoleh dengan <em>eviction reclaim</em></td></tr><tr><td><code>--maximum-dead-containers</code></td><td></td><td><em>deprecated</em> saat log yang telah usang tersimpan di luar konteks kontainer</td></tr><tr><td><code>--maximum-dead-containers-per-container</code></td><td></td><td><em>deprecated</em> saat log yang telah usang tersimpan di luar konteks kontainer</td></tr><tr><td><code>--minimum-container-ttl-duration</code></td><td></td><td><em>deprecated</em> saat log yang telah usang tersimpan di luar konteks kontainer</td></tr><tr><td><code>--low-diskspace-threshold-mb</code></td><td><code>--eviction-hard</code> atau <code>eviction-soft</code></td><td><em>eviction</em> memberi generalisasi <em>threshold</em> disk untuk <em>resource-resource</em> lainnya</td></tr><tr><td><code>--outofdisk-transition-frequency</code></td><td><code>--eviction-pressure-transition-period</code></td><td><em>eviction</em> memberi generalisasi transisi tekanan <em>disk</em> (<em>disk pressure</em>)untuk <em>resource-resource</em> lainnya</td></tr></tbody></table><h2 id=selanjutnya>Selanjutnya</h2><p>Lihat <a href=/docs/tasks/administer-cluster/out-of-resource/>Konfigurasi untuk Menangani Kehabisan <em>Resource</em></a> untuk penjelasan lebih lanjut.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-3003324f360fdacc06ca144e57ff0e97>3.11.9 - Federation</h1><blockquote class="deprecation_file_warning callout"><div><h4>Sudah usang</h4><p>Penggunaan <code>Federation V1</code> sangat tidak disarankan. <code>Federation V1</code> tidak pernah masuk dalam GA dan tidak lagi dikembangkan secara aktif. Dokumentasi hanya disediakan sebatas data artefak saja.</p><p>Untuk informasi lebih lanjut mengenai hal ini dan penggantinya kamu dapat membaca <a href=https://github.com/kubernetes-sigs/federation-v2>Kubernetes Federation v2</a>.</p></div></blockquote><p>Laman ini menjelaskan alasan dan cara penggunaan <em>federation</em> untuk melakukan manajemen
klaster Kubernetes.</p><h2 id=kenapa-federation>Kenapa <em>Federation</em> ?</h2><p><em>Federation</em> membuat proses manajemen klaster multipel menjadi lebih mudah.
<em>Federation</em> mencapai hal ini dengan cara menyediakan 2 buah fondasi:</p><ul><li>Melakukan sinkronisasi <em>resource</em> di seluruh klaster: <em>Federation</em>
menyediakan kemampuan untuk melakukan sinkronisasi <em>resources</em> pada <em>multiple</em>
klaster. Sebagai contoh, kamu dapat memastikan <em>Deployment</em> yang sama
tersedia pada klaster multipel.</li><li><em>Cross</em> <em>cluster</em> <em>Discovery</em>: <em>Federation</em> menyediakan kemampuan untuk melakukan
konfigurasi otomatis server DNS dan <em>load balancer</em> dari semua klaster.
Misalnya, kamu dapat memastikan bahwa sebuah VIP atau DNS global dapat digunakan
untuk mengakses <em>backend</em> dari klaster multipel.</li></ul><p>Beberapa penggunaan <em>federation</em> adalah sebagai berikut:</p><ul><li><em>High Availability</em>: Melakukan <em>load balance</em> di seluruh klaster serta
melakukan konfigurasi otomatis server DNS dan <em>load balancer</em>, <em>federation</em>
meminimalisasi dampak yang terjadi apabila terjadi kegagalan klaster.</li><li>Mencegah <em>lock-in</em> yang terjadi akibat penyedia layanan: Dengan cara mempermudah
proses migrasi antar klaster.</li></ul><p>Manfaat <em>federation</em> tidak akan terlalu kelihatan kecuali kamu memiliki beberapa klaster.
Beberapa alasan kenapa kamu butuh beberapa klaster adalah:</p><ul><li><em>Latency</em> yang rendah: Memiliki klaster yang berada di <em>region</em> yang berbeda
meminimalisasi <em>latency</em> dengan cara menyajikan konten ke pengguna
berdasarkan <em>region</em> yang paling dekat dengan pengguna tersebut.</li><li>Isolasi <em>fault</em>: Akan lebih baik apabila kita memiliki beberapa klaster kecil
dibandingkan sebuah klaster besar untuk melakukan isolasi <em>fault</em> (misalnya saja
klaster ini bisa saja berada di <em>availability</em> zona dan penyedia layanan <em>cloud</em>
yang berbeda).</li><li>Skalabilitas: Terdapat batasan skalabilitas untuk sebuah klaster Kubernetes,
hal ini sebenarnya tidak menjadi masalah bagi sebagian besar pengguna. Untuk informasi
lebih lanjut kamu bisa membaca
<a href=https://git.k8s.io/community/sig-scalability/goals.md><em>Kubernetes Scaling</em> dan Perencanaan Performa</a>).</li><li><a href=#hybrid-cloud-capabilities><em>Hybrid cloud</em></a>: Kamu dapat memiliki <em>multiple</em> klsuter
pada penyedia layanan <em>cloud</em> yang berbeda ataupun menggunakan <em>on-premsie</em>.</li></ul><h3 id=kekurangan>Kekurangan</h3><p>Meskipun terdapat banyak kelebihan dari penggunaan <em>federation</em>,
terdapat beberapa kekurangan <em>federation</em> yang dijabarkan sebagai berikut:</p><ul><li>Peningkatan <em>bandwidth</em> dan biaya untuk jaringan: <em>control plane</em> <em>federation</em> bertugas mengawasi semua
kulster yang ada untuk menjamin <em>state</em> yang ada saat ini sesuai dengan <em>state</em> yang diinginkan. Hal ini dapat menyebabkan
peningkatan biaya jaringan apabila klaster yang ada dijalankan pada <em>region</em> yang berbeda baik pada penyedia
layanan <em>cloud</em> yang sama maupun berbeda.</li><li>Berkurangnya isolasi antar klaster: Sebuah <em>bug</em> yang ada pada <em>control plane</em> <em>federation</em> dapat
berdampak pada semua klaster. Hal ini dapat dihindari dengan cara mejaga logika yang ada pada <em>control plane</em> <em>federation</em>
seminimum mungkin.</li><li>Kematangan: Proyek <em>federation</em> ini tergolong baru dan belum cukup matang.
Tidak semua <em>resource</em> yang ada tersedia dan masih banyak feature <em>alpha</em>. <a href=https://github.com/kubernetes/federation/issues/88><em>Issue</em>
88</a> memberikan detail
isu-isu terkait sistem yang masih berusaha dicari solusinya.</li></ul><h3 id=kemampuan-hybrid-penggunaan-layanan-penyedian-cloud>Kemampuan <em>Hybrid</em> Penggunaan Layanan Penyedian <em>Cloud</em></h3><p><em>Federation</em> pada Kubernetes memungkinkan klaster untuk dijalankan
pada penyedia layanan <em>cloud</em> yang berbeda (misalnya Google Cloud, AWS), dan <em>on-premise</em>
(misalnya OpenStack). <a href=/docs/tasks/federation/set-up-cluster-federation-kubefed/>Kubefed</a>
adalah salah satu cara yang direkomendasikan untuk melakukan proses <em>deploy</em>
klaster <em>federation</em>.</p><p>Dengan demikian, <a href=#resources-api><em>resources</em> API</a> yang kamu miliki
dapat berada di klaster atau bahkan penyedia layanan <em>cloud</em> yang berbeda.</p><h2 id=mengaktifkan-federation>Mengaktifkan <em>Federation</em></h2><p>Untuk bisa melakukan <em>federation</em> pada klaster yang berbeda,
pertama kamu harus mengaktifkan <em>control plane</em> <em>federation</em>.
Ikuti <a href=/docs/tutorials/federation/set-up-cluster-federation-kubefed/>petunjuk mengaktifkan <em>control plane</em> <em>federation</em></a>
untuk informasi lebih lanjut.</p><h2 id=resources-api><code>Resources</code> API</h2><p>Setelah kamu mengaktifkan <em>control plane</em>, kamu dapat menggunakan <em>resource</em> API <em>federation</em>.
Berikut merupakan panduan yang akan menjelaskan masing-masing <em>resource</em> secara mendetail:</p><ul><li><a href=/docs/tasks/administer-federation/cluster/>Cluster</a></li><li><a href=/docs/tasks/administer-federation/configmap/>ConfigMap</a></li><li><a href=/docs/tasks/administer-federation/daemonset/>DaemonSets</a></li><li><a href=/docs/tasks/administer-federation/deployment/>Deployment</a></li><li><a href=/docs/tasks/administer-federation/events/>Events</a></li><li><a href=/docs/tasks/administer-federation/hpa/>Hpa</a></li><li><a href=/docs/tasks/administer-federation/ingress/>Ingress</a></li><li><a href=/docs/tasks/administer-federation/job/>Jobs</a></li><li><a href=/docs/tasks/administer-federation/namespaces/>Namespaces</a></li><li><a href=/docs/tasks/administer-federation/replicaset/>ReplicaSets</a></li><li><a href=/docs/tasks/administer-federation/secret/>Secrets</a></li><li><a href=/id/docs/concepts/cluster-administration/federation-service-discovery/>Services</a></li></ul><p><a href=/docs/reference/federation/>Referensi Dokumentasi API</a> memberikan semua daftar
<em>resources</em> yang disediakan <em>apiserver</em> <em>federation</em>.</p><h2 id=penghapusan-berantai>Penghapusan Berantai</h2><p>Kubernetes versi 1.6 menyediakan mekanisme penghapusan berantai
untuk <em>resource</em> yang ada pada <em>federation</em>. Dengan penghapusan berantai,
ketika kamu menghapus sebuah <em>resource</em> dari <em>control plane</em> <em>federation</em>,
kamu juga akan menghapus segala <em>resource</em> tersebut pada semua klaster yang ada.</p><p>Mekanisme penghapusan berantai ini tidak diaktifkan secara <em>default</em>
ketika menggunakan REST API. Untuk mengaktifkannya, ubah nilai dari opsi
<code>DeleteOptions.orphanDependents=false</code> ketika kamu menghapus sebuah <em>resource</em>
dari <em>control plane</em> <em>federation</em> dengan menggunakan REST API.
Penggunaan <code>kubectl delete</code>mengaktifkan penhapusan berantai secara <em>default</em>.
Kamu dapat menonaktifkannya dengan menggunakan <code>kubectl delete --cascade=false</code></p><p>Catatan: Kubernetes versi 1.5 menyediakan penghapusan berantai
untuk sebagian <em>resource</em> <em>federation</em>.</p><h2 id=cakupan-dari-sebuah-klaster>Cakupan dari Sebuah Klaster</h2><p>Pada penyedia IaaS seperti Google Compute Engine atau Amazon Web Services, sebuah VM ada di dalam
<a href=https://cloud.google.com/compute/docs/zones>zona</a> atau <a href=http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html><em>availability
zone</em></a>.
Kami menyarankan agar semua VM pada klaster Kubernetes berada pada <em>availability</em> zona yang sama, karena:</p><ul><li>dibandingkan dengan sebuah klaster global Kubernetes, terdapat lebih sedikit <em>single-points of failure</em>.</li><li>dibandingkan dengan sebuah klaster yang tersebar pada <em>availability zone</em> yang mungkin berbeda, akan lebih mudah untuk merencanakan properti <em>availability</em> dari sebuah
klaster yang berada pada satu zona.</li><li>ketika pengembang Kubernetes mendesain sistem (misalnya, memperkirakan <em>latency</em>, <em>bandwidth</em>, atau
<em>failure</em> yang mungkin terjadi) pengembang tersebut memperkirakan semua mesin akan berada pada sebuah <em>data center</em> yang sama, atau setidaknya masih terdapat pada satu wilayah.</li></ul><p>Sangat direkomendasikan untuk menjalankan sedikit klaster dengan lebih banyak VM pada setiap <em>availability</em> zona;
meskipun begitu hal ini tidak menutup kemungkinan untuk menjalankan klaster multipel
pada setiap <em>availability</em> zona.</p><p>Alasan kenapa menjalankan lebih sedikit klaster pada setiap <em>availability</em> zona lebih dianjurkan:</p><ul><li>meningkatkan <em>bin packing</em> <em>Pod</em> pada beberapa kasus dimana terdapat lebih banyak <em>node</em> dalam sebuah klaster (mengurangi terjadinya <em>fragmentation</em> <em>resource</em>).</li><li>mengurangi <em>overhead</em> operasional (meskipun keuntungan ini akan berkurang seiring bertambah matangnya proses dan <em>tooling</em> operasional).</li><li>mengurangi biaya <em>resource</em> tetap per klaster, misalnya VM <em>apiserver</em>.</li></ul><p>Alasan untuk memiliki klaster multipel:</p><ul><li><em>policy</em> kemananan yang ketat membutuhkan isolasi antar <em>work</em> <em>class</em> (baca Partisi Klaster di bawah).</li><li>melakukan penerapan Kubernetes dan/atau perangkat lunak lain yang versi baru ke salah satu klaster.</li></ul><h2 id=memilih-jumlah-klaster-yang-tepat>Memilih jumlah klaster yang tepat</h2><p>Pemilihan jumlah klaster yang tepat merupakan pilihan yang relatif statis, dan hanya akan ditinjau kembali sewaktu-waktu.
Sebaliknya, jumlah <em>node</em> dan <em>pod</em> dalam suatu <em>service</em> dapat berubah secara cepat seiring bertambahnya <em>workload</em>.</p><p>Untuk memilih jumlah klaster, pertama, pilih <em>region</em> yang memiliki <em>latency</em> yang masih dapat dimaklumi untuk semua pengguna aplikasi kamu
(jika kamu menggunakan <em>Content Distribution Network</em>, kebutuhan informasi nilai <em>latency</em> CDN tidak perlu diperhatikan).
Masalah legal juga perlu diperhitungkan. Misalnya sebuah perusahaan dengan pelanggan global bisa jadi memilih klaster di <em>region</em>
US, EU, AP, dan SA. Jumlah <em>region</em> ini dimisalkan dengan <code>R</code>.</p><p>Kedua, pilih berapa banyak klaster yang bisa jadi <em>unavailable</em> secara bersamaan tanpa membuat <em>service</em> menjadi <em>unavailable</em>.
Misalkan jumlah klaster <em>unavailable</em> ini sebagai <code>U</code>. Jika kamu tidak yakin, maka 1 merupakan pilihan yang tergolong
dapat diterima.</p><p>Jika aplikasimu memungkinkan trafik untuk di-<em>load balance</em> ke <em>region</em> mana saja ketika terjadi <em>failure</em> pada klaster,
maka kamu setidaknya membutuhkan nilai yang lebih banyak dari jumlah <code>R</code> atau <code>U + 1</code> klaster. Jika tidak (misalnya, kamu
ingin menjamin stabilnya <em>latency</em> ketika terjadi <em>failure</em> pada klaster) maka kamu membutuhkan <code>R * (U + 1)</code> klaster
(<code>U + 1</code> di setiap <em>region</em> yang ada pada <code>R</code>). Pada kasus lain, cobalah untuk menerapkan satu klaster
pada zona yang berbeda.</p><p>Terakhir, jika klaster yang kamu miliki membutuhkan jumlah <em>node</em> yang melebihi nilai yang direkomendasikan untuk sebuah klaster Kubernetes,
maka kamu membutuhkan lebih banyak klaster. Kubernetes v1.3 mampu menangani hingga 1000 node untuk setiap klaster. Kubernetes v1.8
mampu menangani hingga 5000 node untuk tiap klaster. Baca <a href=/docs/setup/cluster-large/>Membangun Klaster Besar</a> untuk petunjuk lebih lanjut.</p><h2 id=selanjutnya>Selanjutnya</h2><ul><li>Pelajari lebih lanjut tentang <a href=https://github.com/kubernetes/community/blob/main/contributors/design-proposals/multicluster/federation.md>proposal
<em>Federation</em></a>.</li><li>Baca <a href=/docs/tutorials/federation/set-up-cluster-federation-kubefed/>petunjuk pengaktifan</a> klaster <em>federation</em>.</li><li>Lihat <a href="https://www.youtube.com/watch?v=pq9lbkmxpS8">seminar tentang <em>federation</em> pada Kubecon2016</a></li><li>Lihat <a href="https://www.youtube.com/watch?v=kwOvOLnFYck"><em>update</em> <em>federation</em> pada Kubecon2017 Eropa</a></li><li>Lihat <a href="https://www.youtube.com/watch?v=vGZo5DaThQU"><em>update</em> <em>sig-multicluster</em> pada Kubecon2018 Eropa</a></li><li>Lihat <a href="https://youtu.be/q27rbaX5Jis?t=7m20s">presentasi prototipe <em>Federation-v2</em> pada Kubecon2018 Eropa</a></li><li>Lihat <a href=https://github.com/kubernetes-sigs/federation-v2/blob/master/docs/userguide.md>petunjuk penggunaan <em>Federation-v2</em></a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-08e94e6a480e0d6b2de72d84a1b97617>3.11.10 - Berbagai Proxy di Kubernetes</h1><p>Laman ini menjelaskan berbagai <i>proxy</i> yang ada di dalam Kubernetes.</p><h2 id=berbagai-jenis-i-proxy-i>Berbagai Jenis <i>Proxy</i></h2><p>Ada beberapa jenis <i>proxy</i> yang akan kamu temui saat menggunakan Kubernetes:</p><ol><li><p><a href=/id/docs/tasks/access-application-cluster/access-cluster/#directly-accessing-the-rest-api>kubectl proxy</a>:</p><ul><li>dijalankan pada <i>desktop</i> pengguna atau di dalam sebuah Pod</li><li>melakukan <i>proxy</i> dari alamat localhost ke apiserver Kubernetes</li><li>dari klien menuju <i>proxy</i> menggunakan HTTP</li><li>dari <i>proxy</i> menuju apiserver menggunakan HTTPS</li><li>mencari lokasi apiserver</li><li>menambahkan <i>header</i> autentikasi</li></ul></li><li><p><a href=/id/docs/tasks/access-application-cluster/access-cluster/#discovering-builtin-services>apiserver proxy</a>:</p><ul><li>merupakan sebuah <i>bastion</i> yang ada di dalam apiserver</li><li>menghubungkan pengguna di luar klaster ke alamat-alamat IP di dalam klaster yang tidak bisa terjangkau</li><li>dijalankan bersama <i>process-process</i> apiserver</li><li>dari klien menuju <i>proxy</i> menggunakan HTTPS (atau http jika dikonfigurasi pada apiserver)</li><li>dari <i>proxy</i> menuju target menggunakan HTTP atau HTTPS, tergantung pilihan yang diambil oleh <i>proxy</i> melalui informasi yang ada</li><li>dapat digunakan untuk menghubungi Node, Pod, atau Service</li><li>melakukan <i>load balancing</i> saat digunakan untuk menjangkau sebuah Service</li></ul></li><li><p><a href=/id/docs/concepts/services-networking/service/#ips-and-vips>kube proxy</a>:</p><ul><li>dijalankan pada setiap Node</li><li>melakukan <i>proxy</i> untuk UDP, TCP dan SCTP</li><li>tidak mengerti HTTP</li><li>menyediakan <i>load balancing</i></li><li>hanya digunakan untuk menjangkau berbagai Service</li></ul></li><li><p>Sebuah <i>Proxy/Load-balancer</i> di depan satu atau banyak apiserver:</p><ul><li>keberadaan dan implementasinya bervariasi tergantung pada klaster (contohnya nginx)</li><li>ada di antara seluruh klien dan satu/banyak apiserver</li><li>jika ada beberapa apiserver, berfungsi sebagai <i>load balancer</i></li></ul></li><li><p><i>Cloud Load Balancer</i> pada servis eksternal:</p><ul><li>disediakan oleh beberapa penyedia layanan cloud, seperti AWS ELB, Google Cloud Load Balancer</li><li>dibuat secara otomatis ketika Service dari Kubernetes dengan tipe <code>LoadBalancer</code></li><li>biasanya hanya tersedia untuk UDP/TCP</li><li><i>support</i> untuk SCTP tergantung pada <i>load balancer</i> yang diimplementasikan oleh penyedia cloud</li><li>implementasi bervariasi tergantung pada penyedia cloud</li></ul></li></ol><p>Pengguna Kubernetes biasanya hanya cukup perlu tahu tentang kubectl <i>proxy</i> dan apiserver <i>proxy</i>.
Untuk <i>proxy-proxy</i> lain di luar ini, admin klaster biasanya akan memastikan konfigurasinya dengan benar.</p><h2 id=melakukan-i-request-redirect-i>Melakukan <i>request redirect</i></h2><p><i>Proxy</i> telah menggantikan fungsi <i>redirect</i>. <i>Redirect</i> telah terdeprekasi.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-d5cc46b61677b53f61a407d20bdd0830>3.11.11 - Metrik controller manager</h1><p>Metrik <em>controller manager</em> memberikan informasi penting tentang kinerja dan kesehatan dari <em>controller manager</em>.</p><h2 id=tentang-metrik-controller-manager>Tentang metrik <em>controller manager</em></h2><p>Metrik <em>controller manager</em> ini berfungsi untuk memberikan informasi penting tentang kinerja dan kesehatan dari <em>controller manager</em>.
Metrik ini juga berisi tentang metrik umum dari <em>runtime</em> bahasa pemrograman Go seperti jumlah <em>go_routine</em> dan metrik spesifik dari <em>controller</em> seperti
latensi dari etcd <em>request</em> atau latensi API dari penyedia layanan <em>cloud</em> (AWS, GCE, OpenStack) yang dapat digunakan untuk mengukur kesehatan dari klaster.</p><p>Mulai dari Kubernetes 1.7, metrik yang lebih mendetil tentang operasi penyimpanan dari penyedia layanan <em>cloud</em> juga telah tersedia.
Metrik-metrik ini dapat digunakan untuk memonitor kesehatan dari operasi <em>persistent volume</em>.</p><p>Berikut merupakan contoh nama metrik yang disediakan GCE:</p><pre tabindex=0><code>cloudprovider_gce_api_request_duration_seconds { request = &#34;instance_list&#34;}
cloudprovider_gce_api_request_duration_seconds { request = &#34;disk_insert&#34;}
cloudprovider_gce_api_request_duration_seconds { request = &#34;disk_delete&#34;}
cloudprovider_gce_api_request_duration_seconds { request = &#34;attach_disk&#34;}
cloudprovider_gce_api_request_duration_seconds { request = &#34;detach_disk&#34;}
cloudprovider_gce_api_request_duration_seconds { request = &#34;list_disk&#34;}
</code></pre><h2 id=konfigurasi>Konfigurasi</h2><p>Pada sebuah klaster, informasi metrik <em>controller manager</em> dapat diakses melalui <code>http://localhost:10252/metrics</code>
dari <em>host</em> tempat <em>controller manager</em> dijalankan.</p><p>Metrik ini dikeluarkan dalam bentuk <a href=https://prometheus.io/docs/instrumenting/exposition_formats/>format prometheus</a> serta mudah untuk dibaca manusia.</p><p>Pada <em>environment</em> produksi, kamu mungkin juga ingin mengonfigurasi prometheus atau pengumpul metrik lainnya untuk mengumpulkan metrik-metrik ini secara berkala dalam bentuk basis data <em>time series</em>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-85d633ae590aa20ec024f1b7af1d74fc>3.11.12 - Instalasi Add-ons</h1><p><em>Add-ons</em> berfungsi untuk menambah serta memperluas fungsionalitas dari Kubernetes.</p><p>Laman ini akan menjabarkan beberapa <em>add-ons</em> yang tersedia serta tautan instruksi bagaimana cara instalasi masing-masing <em>add-ons</em>.</p><p><em>Add-ons</em> pada setiap bagian akan diurutkan secara alfabet - pengurutan ini tidak dilakukan berdasarkan status preferensi atau keunggulan.</p><h2 id=jaringan-dan-policy-jaringan>Jaringan dan <em>Policy</em> Jaringan</h2><ul><li><a href=https://www.github.com/noironetworks/aci-containers>ACI</a> menyediakan integrasi jaringan kontainer dan keamanan jaringan dengan Cisco ACI.</li><li><a href=https://docs.projectcalico.org/latest/getting-started/kubernetes/>Calico</a> merupakan penyedia jaringan L3 yang aman dan <em>policy</em> jaringan.</li><li><a href=https://projectcalico.docs.tigera.io/getting-started/kubernetes/flannel/flannel>Canal</a> menggabungkan Flannel dan Calico, menyediakan jaringan serta <em>policy</em> jaringan.</li><li><a href=https://github.com/cilium/cilium>Cilium</a> merupakan <em>plugin</em> jaringan L3 dan <em>policy</em> jaringan yang dapat menjalankan <em>policy</em> HTTP/API/L7 secara transparan. Mendukung mode <em>routing</em> maupun <em>overlay/encapsulation</em>.</li><li><a href=https://github.com/cni-genie/CNI-Genie>CNI-Genie</a> memungkinkan Kubernetes agar dapat terkoneksi dengan beragam <em>plugin</em> CNI, seperti Calico, Canal, Flannel, Romana, atau Weave dengan mulus.</li><li><a href=http://contiv.github.io>Contiv</a> menyediakan jaringan yang dapat dikonfigurasi (<em>native</em> L3 menggunakan BGP, <em>overlay</em> menggunakan vxlan, klasik L2, dan Cisco-SDN/ACI) untuk berbagai penggunaan serta <em>policy framework</em> yang kaya dan beragam. Proyek Contiv merupakan proyek <a href=http://github.com/contiv>open source</a>. Laman <a href=http://github.com/contiv/install>instalasi</a> ini akan menjabarkan cara instalasi, baik untuk klaster dengan kubeadm maupun non-kubeadm.</li><li><a href=http://www.juniper.net/us/en/products-services/sdn/contrail/contrail-networking/>Contrail</a>, yang berbasis dari <a href=https://tungsten.io>Tungsten Fabric</a>, merupakan sebuah proyek <em>open source</em> yang menyediakan virtualisasi jaringan <em>multi-cloud</em> serta platform manajemen <em>policy</em>. Contrail dan Tungsten Fabric terintegrasi dengan sistem orkestrasi lainnya seperti Kubernetes, OpenShift, OpenStack dan Mesos, serta menyediakan mode isolasi untuk mesin virtual (VM), kontainer/pod dan <em>bare metal</em>.</li><li><a href=https://github.com/flannel-io/flannel#deploying-flannel-manually>Flannel</a> merupakan penyedia jaringan <em>overlay</em> yang dapat digunakan pada Kubernetes.</li><li><a href=https://github.com/ZTE/Knitter/>Knitter</a> merupakan solusi jaringan yang mendukung multipel jaringan pada Kubernetes.</li><li><a href=https://github.com/k8snetworkplumbingwg/multus-cni>Multus</a> merupakan sebuah multi <em>plugin</em> agar Kubernetes mendukung multipel jaringan secara bersamaan sehingga dapat menggunakan semua <em>plugin</em> CNI (contoh: Calico, Cilium, Contiv, Flannel), ditambah pula dengan SRIOV, DPDK, OVS-DPDK dan VPP pada <em>workload</em> Kubernetes.</li><li><a href=https://docs.vmware.com/en/VMware-NSX-T-Data-Center/index.html>NSX-T</a> Container Plug-in (NCP) menyediakan integrasi antara VMware NSX-T dan orkestrator kontainer seperti Kubernetes, termasuk juga integrasi antara NSX-T dan platform CaaS/PaaS berbasis kontainer seperti <em>Pivotal Container Service</em> (PKS) dan OpenShift.</li><li><a href=https://github.com/nuagenetworks/nuage-kubernetes/blob/v5.1.1-1/docs/kubernetes-1-installation.rst>Nuage</a> merupakan platform SDN yang menyediakan <em>policy-based</em> jaringan antara Kubernetes Pods dan non-Kubernetes <em>environment</em> dengan <em>monitoring</em> visibilitas dan keamanan.</li><li><a href=http://romana.io>Romana</a> merupakan solusi jaringan <em>Layer</em> 3 untuk jaringan pod yang juga mendukung <a href=/id/docs/concepts/services-networking/network-policies/><em>NetworkPolicy</em> API</a>. Instalasi Kubeadm <em>add-on</em> ini tersedia <a href=https://github.com/romana/romana/tree/master/containerize>di sini</a>.</li><li><a href=https://www.weave.works/docs/net/latest/kube-addon/>Weave Net</a> menyediakan jaringan serta <em>policy</em> jaringan, yang akan membawa kedua sisi dari partisi jaringan, serta tidak membutuhkan basis data eksternal.</li></ul><h2 id=service-discovery><em>Service Discovery</em></h2><ul><li><a href=https://coredns.io>CoreDNS</a> merupakan server DNS yang fleksibel, mudah diperluas yang dapat <a href=https://github.com/coredns/deployment/tree/master/kubernetes>diinstal</a> sebagai <em>in-cluster</em> DNS untuk pod.</li></ul><h2 id=visualisasi-amp-kontrol>Visualisasi & Kontrol</h2><ul><li><a href=https://github.com/kubernetes/dashboard#kubernetes-dashboard>Dashboard</a> merupakan antarmuka web dasbor untuk Kubernetes.</li><li><a href=https://www.weave.works/documentation/scope-latest-installing/#k8s>Weave Scope</a> merupakan perangkat untuk visualisasi grafis dari kontainer, pod, <em>service</em> dll milikmu. Gunakan bersama dengan <a href=https://cloud.weave.works/>akun Weave Cloud</a> atau <em>host</em> UI-mu sendiri.</li></ul><h2 id=add-ons-terdeprekasi><em>Add-ons</em> Terdeprekasi</h2><p>Ada beberapa <em>add-on</em> lain yang didokumentasikan pada direktori deprekasi <a href=https://git.k8s.io/kubernetes/cluster/addons><em>cluster/addons</em></a>.</p><p><em>Add-on</em> lain yang dipelihara dan dikelola dengan baik dapat ditulis di sini. Ditunggu PR-nya!</p></div><div class=td-content style=page-break-before:always><h1 id=pg-31c9327d2332c585341b64ddafa19cdd>3.11.13 - Prioritas dan Kesetaraan API (API Priority and Fairness)</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.18 [alpha]</code></div><p>Mengontrol perilaku server API dari Kubernetes pada situasi beban berlebih
merupakan tugas utama dari administrator klaster. <a class=glossary-tooltip title='Komponen control plane yang mengekspos API Kubernetes. Merupakan front-end dari control plane Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-apiserver/ target=_blank aria-label=kube-apiserver>kube-apiserver</a> memiliki beberapa kontrol yang tersedia
(seperti opsi <code>--max-request-inflight</code> dan <code>--max-mutating-request-inflight</code>
pada baris perintah atau <em>command-line</em>) untuk membatasi jumlah pekerjaan luar biasa yang akan
diterima, untuk mencegah banjirnya permintaan masuk dari beban berlebih
yang berpotensi untuk menghancurkan server API. Namun opsi ini tidak cukup untuk memastikan
bahwa permintaan yang paling penting dapat diteruskan pada saat kondisi lalu lintas (<em>traffic</em>) yang cukup tinggi.</p><p>Fitur Prioritas dan Kesetaraan API atau <em>API Priority and Fairness</em> (APF) adalah alternatif untuk meningkatkan
batasan <em>max-inflight</em> seperti yang disebutkan di atas. APF mengklasifikasi
dan mengisolasi permintaan dengan cara yang lebih halus. Fitur ini juga memperkenalkan
jumlah antrian yang terbatas, sehingga tidak ada permintaan yang ditolak
pada saat terjadi lonjakan permintaan dalam waktu yang sangat singkat. Permintaan dibebaskan dari antrian dengan menggunakan
teknik antrian yang adil (<em>fair queuing</em>) sehingga, sebagai contoh, perilaku buruk dari satu
<a class=glossary-tooltip title='Kontrol tertutup yang mengawasi kondisi bersama dari klaster melalui apiserver dan membuat perubahan yang mencoba untuk membawa kondisi saat ini ke kondisi yang diinginkan.' data-toggle=tooltip data-placement=top href=/id/docs/concepts/architecture/controller/ target=_blank aria-label=controller>controller</a> tidak seharusnya
mengakibatkan <em>controller</em> yang lain menderita (meskipun pada tingkat prioritas yang sama).</p><div class="alert alert-warning caution callout" role=alert><strong>Perhatian:</strong> Permintaan yang diklasifikasikan sebagai "long running" - terutama <em>watch</em> - tidak
mengikuti filter prioritas dan kesetaraan API. Dimana ini juga berlaku pada
opsi <code>--max-request-inflight</code> tanpa mengaktifkan APF.</div><h2 id=mengaktifkan-prioritas-dan-kesetaraan-api>Mengaktifkan prioritas dan kesetaraan API</h2><p>Fitur APF dikontrol oleh sebuah gerbang fitur (<em>feature gate</em>)
dan fitur ini tidak diaktifkan secara bawaan. Silahkan lihat
<a href=/docs/reference/command-line-tools-reference/feature-gates/>gerbang fitur</a>
untuk penjelasan umum tentang gerbang fitur dan bagaimana cara mengaktifkan dan menonaktifkannya.
Nama gerbang fitur untuk APF adalah "APIPriorityAndFairness".
Fitur ini melibatkan sebuah <a class=glossary-tooltip title='Sekumpulan path terkait pada API Kubernetes.' data-toggle=tooltip data-placement=top href=/id/docs/concepts/overview/kubernetes-api/#api-groups target=_blank aria-label='Grup API'>Grup API</a> yang harus juga diaktifkan. Kamu bisa melakukan ini dengan
menambahkan opsi pada baris perintah berikut pada permintaan ke <code>kube-apiserver</code> kamu:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kube-apiserver <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>--feature-gates<span style=color:#666>=</span><span style=color:#b8860b>APIPriorityAndFairness</span><span style=color:#666>=</span><span style=color:#a2f>true</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>--runtime-config<span style=color:#666>=</span>flowcontrol.apiserver.k8s.io/v1alpha1<span style=color:#666>=</span><span style=color:#a2f>true</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span> <span style=color:#080;font-style:italic># …dan opsi-opsi lainnya seperti biasa</span>
</span></span></code></pre></div><p>Opsi pada baris perintah <code>--enable-priority-and-fairness=false</code> akan menonaktifkan fitur
APF, bahkan ketika opsi yang lain telah mengaktifkannya.</p><h2 id=konsep>Konsep</h2><p>Ada beberapa fitur lainnya yang terlibat dalam fitur APF. Permintaan yang masuk diklasifikasikan berdasarkan atribut permintaan dengan menggunakan
FlowSchema, dan diserahkan ke tingkat prioritas. Tingkat prioritas menambahkan tingkat
isolasi dengan mempertahankan batas konkurensi yang terpisah, sehingga permintaan yang diserahkan
ke tingkat prioritas yang berbeda tidak dapat membuat satu sama lain menderita. Dalam sebuah tingkat prioritas,
algoritma <em>fair-queuing</em> mencegah permintaan dari <em>flows</em> yang berbeda akan memberikan penderitaan
kepada yang lainnya, dan memperbolehkan permintaan untuk dimasukkan ke dalam antrian untuk mencegah pelonjakan lalu lintas
yang akan menyebabkan gagalnya permintaan, walaupun pada saat beban rata-ratanya cukup rendah.</p><h3 id=tingkat-prioritas-priority-level>Tingkat prioritas (<em>Priority Level</em>)</h3><p>Tanpa pengaktifan APF, keseluruhan konkurensi dalam
server API dibatasi oleh opsi pada <code>kube-apiserver</code>
<code>--max-request-inflight</code> dan <code>--max-mutating-request-inflight</code>. Dengan pengaktifan APF,
batas konkurensi yang ditentukan oleh opsi ini akan dijumlahkan dan kemudian jumlah tersebut dibagikan
untuk sekumpulan tingkat prioritas (<em>priority level</em>) yang dapat dikonfigurasi. Setiap permintaan masuk diserahkan
ke sebuah tingkat prioritas, dan setiap tingkat prioritas hanya akan meneruskan sebanyak mungkin
permintaan secara bersamaan sesuai dengan yang diijinkan dalam konfigurasi.</p><p>Konfigurasi bawaan, misalnya, sudah mencakup tingkat prioritas terpisah untuk
permintaan dalam rangka pemilihan pemimpin (<em>leader-election</em>), permintaan dari <em>controller</em> bawaan, dan permintaan dari
Pod. Hal ini berarti bahwa Pod yang berperilaku buruk, yang bisa membanjiri server API
dengan permintaan, tidak akan mampu mencegah kesuksesan pemilihan pemimpin atau tindakan yang dilakukan oleh <em>controller</em> bawaan.</p><h3 id=antrian-queuing>Antrian (<em>Queuing</em>)</h3><p>Bahkan dalam sebuah tingkat prioritas mungkin akan ada sumber lalu lintas yang berbeda dalam jumlah besar.
Dalam situasi beban berlebih, sangat penting untuk mencegah satu aliran
permintaan dari penderitaan karena aliran yang lainnya (khususnya, dalam kasus yang relatif umum dari sebuah
klien tunggal bermasalah (<em>buggy</em>) yang dapat membanjiri <em>kube-apiserver</em> dengan permintaan, klien bermasalah itu
idealnya tidak memiliki banyak dampak yang bisa diukur terhadap klien yang lainnya). Hal ini
ditangani dengan menggunakan algoritma <em>fair-queuing</em> untuk memproses permintaan yang diserahkan
oleh tingkat prioritas yang sama. Setiap permintaan diserahkan ke sebuah <em>flow</em>, yang diidentifikasi berdasarkan
nama FlowSchema yang sesuai, ditambah dengan <em>flow distinguisher</em> - yang
bisa saja didasarkan pada pengguna yang meminta, sumber daya Namespace dari target, atau tidak sama sekali - dan
sistem mencoba untuk memberikan bobot yang hampir sama untuk permintaan dalam <em>flow</em> yang berbeda dengan tingkat prioritas yang sama.</p><p>Setelah mengklasifikasikan permintaan ke dalam sebuah <em>flow</em>, fitur APF kemudian
dapat menyerahkan permintaan ke dalam sebuah antrian. Penyerahan ini menggunakan
teknik yang dikenal sebagai <a class=glossary-tooltip title='A technique for assigning requests to queues that provides better isolation than hashing modulo the number of queues.' data-toggle=tooltip data-placement=top href='/id/docs/reference/glossary/?all=true#term-shuffle-sharding' target=_blank aria-label='_shuffle sharding_'>_shuffle sharding_</a>, yang membuat penggunaan antrian yang relatif efisien
untuk mengisolasi <em>flow</em> dengan intensitas rendah dari <em>flow</em> dengan intensitas tinggi.</p><p>Detail dari algoritma antrian dapat disesuaikan untuk setiap tingkat prioritas, dan
memperbolehkan administrator untuk menukar (<em>trade off</em>) dengan penggunaan memori, kesetaraan (properti dimana
<em>flow</em> yang independen akan membuat semua kemajuan ketika total dari lalu lintas sudah melebihi kapasitas),
toleransi untuk lonjakan lalu lintas, dan penambahan latensi yang dihasilkan oleh antrian.</p><h3 id=permintaan-yang-dikecualikan-exempt-request>Permintaan yang dikecualikan (<em>Exempt Request</em>)</h3><p>Beberapa permintaan dianggap cukup penting sehingga mereka tidak akan mengikuti
salah satu batasan yang diberlakukan oleh fitur ini. Pengecualian ini untuk mencegah
konfigurasi <em>flow control</em> yang tidak terkonfigurasi dengan baik sehingga tidak benar-benar menonaktifkan server API.</p><h2 id=bawaan-default>Bawaan (<em>Default</em>)</h2><p>Fitur APF dikirimkan dengan konfigurasi yang disarankan
dimana konfigurasi itu seharusnya cukup untuk bereksperimen; jika klaster kamu cenderung
mengalami beban berat maka kamu harus mempertimbangkan konfigurasi apa yang akan bekerja paling baik.
Kelompok konfigurasi yang disarankan untuk semua permintaan terbagi dalam lima prioritas
kelas:</p><ul><li><p>Tingkat prioritas <code>system</code> diperuntukkan bagi permintaan dari grup <code>system:nodes</code>,
mis. Kubelet, yang harus bisa menghubungi server API agar
mendapatkan <em>workload</em> untuk dijadwalkan.</p></li><li><p>Tingkat prioritas <code>leader-election</code> diperuntukkan bagi permintaan dalam pemilihan pemimpin (<em>leader election</em>)
dari <em>controller</em> bawaan (khususnya, permintaan untuk <code>endpoint</code>, <code>configmaps</code>,
atau <code>leases</code> yang berasal dari <code>system:kube-controller-manager</code> atau pengguna
<code>system:kube-scheduler</code> dan akun Service di Namespace <code>kube-system</code>). Hal ini
penting untuk mengisolasi permintaan ini dari lalu lintas yang lain karena
kegagalan dalam pemilihan pemimpin menyebabkan <em>controller</em> akan gagal dan memulai kembali (<em>restart</em>),
yang pada akhirnya menyebabkan lalu lintas yang lebih mahal karena <em>controller</em>
yang baru perlu menyinkronkan para informannya.</p></li><li><p>Tingkat prioritas <code>workload-high</code> diperuntukkan bagi permintaan yang lain dari <em>controller</em> bawaan.
  </p></li><li><p>Tingkat prioritas <code>workload-low</code> diperuntukkan bagi permintaan dari akun Service yang lain,
yang biasanya mencakup semua permintaan dari <em>controller</em> yang bekerja didalam Pod.
  </p></li><li><p>Tingkat prioritas <code>global-default</code> menangani semua lalu lintas lainnya, mis.
perintah interaktif <code>kubectl</code> yang dijalankan oleh pengguna yang tidak memiliki hak khusus.</p></li></ul><p>Kemudian, ada dua PriorityLevelConfiguration dan dua FlowSchema yang telah
dibangun dan tidak mungkin ditimpa ulang:</p><ul><li><p>Tingkat prioritas khusus <code>exempt</code> diperuntukkan bagi permintaan yang tidak akan dikenakan
<em>flow control</em> sama sekali: permintaan itu akan selalu diteruskan sesegera mungkin.
FlowSchema <code>exempt</code> khusus mengklasifikasikan semua permintaan dari kelompok <code>system:masters</code>
ke dalam tingkat prioritas khusus ini. Kamu juga dapat menentukan FlowSchema lain yang mengarahkan
permintaan lain ke tingkat prioritas ini juga, apabila permintaan tersebut sesuai.</p></li><li><p>Tingkat prioritas khusus <code>catch-all</code> digunakan secara kombinasi dengan spesial
FlowSchema <code>catch-all</code> untuk memastikan bahwa setiap permintaan mendapatkan proses
klasifikasi. Biasanya kamu tidak harus bergantung pada konfigurasi <em>catch-all</em> ini,
dan kamu seharusnya membuat FlowSchema <em>catch-all</em> dan PriorityLevelConfiguration kamu sendiri
(atau gunakan konfigurasi <code>global-default</code> yang sudah diinstal secara bawaan) secara benar.
Untuk membantu menemukan kesalahan konfigurasi yang akan melewatkan beberapa klasifikasi
permintaan, maka tingkat prioritas <code>catch-all</code> hanya wajib mengijinkan satu konkurensi
bersama dan tidak melakukan memasukkan permintaan dalam antrian, sehingga membuat lalu lintas
yang secara relatif hanya sesuai dengan FlowSchema <code>catch-all</code> akan ditolak dengan kode kesalahan HTTP 429.</p></li></ul><h2 id=sumber-daya-resource>Sumber daya (<em>Resource</em>)</h2><p><em>Flow control</em> API melibatkan dua jenis sumber daya.
<a href=/docs/reference/generated/kubernetes-api/v1.25/#prioritylevelconfiguration-v1alpha1-flowcontrol-apiserver-k8s-io>PriorityLevelConfiguration</a>
yang menentukan kelas isolasi yang tersedia, bagian dari konkurensi anggaran yang tersedia
yang masing-masing dapat menangani bagian tersebut, dan memperbolehkan untuk melakukan <em>fine-tuning</em> terhadap perilaku antrian.
<a href=/docs/reference/generated/kubernetes-api/v1.25/#flowschema-v1alpha1-flowcontrol-apiserver-k8s-io>FlowSchema</a>
yang digunakan untuk mengklasifikasikan permintaan individu yang masuk, mencocokkan masing-masing dengan setiap
PriorityLevelConfiguration.</p><h3 id=prioritylevelconfiguration>PriorityLevelConfiguration</h3><p>Sebuah PriorityLevelConfiguration merepresentasikan sebuah kelas isolasi tunggal. Setiap
PriorityLevelConfiguration memiliki batas independensi dalam hal jumlah
permintaan yang belum diselesaikan, dan batasan dalam hal jumlah permintaan yang mengantri.</p><p>Batas konkurensi untuk PriorityLevelConfiguration tidak disebutkan dalam
jumlah permintaan secara mutlak, melainkan dalam "concurrency shares." Total batas konkurensi
untuk server API didistribusikan di antara PriorityLevelConfiguration yang ada
secara proporsional dengan "concurrency shares" tersebut. Ini mengizinkan seorang
administrator klaster untuk meningkatkan atau menurunkan jumlah total lalu lintas ke sebuah
server dengan memulai kembali <code>kube-apiserver</code> dengan nilai opsi
<code>--max-request-inflight</code> (atau <code>--max-mutating-request-inflight</code>) yang berbeda, dan semua
PriorityLevelConfiguration akan melihat konkurensi maksimum yang diizinkan kepadanya untuk menaikkan (atau
menurunkan) dalam fraksi yang sama.</p><div class="alert alert-warning caution callout" role=alert><strong>Perhatian:</strong> Dengan fitur Prioritas dan Kesetaraan yang diaktifkan, batas total konkurensi untuk
server diatur pada nilai penjumlahan dari <code>--max-request-inflight</code> dan
<code>--max-mutating-request-inflight</code>. Tidak akan ada lagi perbedaan
antara permintaan yang bermutasi dan permintaan yang tidak bermutasi; jika kamu ingin melayaninya
secara terpisah untuk suatu sumber daya yang ada, maka perlu membuat FlowSchema terpisah yang sesuai dengan
masing-masing kata kerja dari permintaan yang bermutasi dan yang tidak bermutasi tersebut.</div><p>Ketika jumlah permintaan masuk yang diserahkan kepada sebuah
PriorityLevelConfiguration melebihi dari tingkat konkurensi yang diizinkan,
bagian <code>type</code> dari spesifikasinya menentukan apa yang akan terjadi pada permintaan selanjutnya.
Tipe <code>Reject</code> berarti bahwa kelebihan lalu lintas akan segera ditolak
dengan kode kesalahan HTTP 429 (yang artinya terlalu banyak permintaan). Tipe <code>Queue</code> berarti permintaan
di atas batas tersebut akan mengantri, dengan teknik <em>sharding shuffle</em> dan <em>fair queuing</em> yang digunakan
untuk menyelaraskan kemajuan antara <em>flow</em> permintaan.</p><p>Konfigurasi antrian memungkinkan mengatur algoritma <em>fair queuing</em> untuk sebuah
tingkat prioritas. Detail algoritma dapat dibaca di <a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-api-machinery/1040-priority-and-fairness>proposal pembaharuan</a>, namun secara singkat:</p><ul><li><p>Meningkatkan <code>queue</code> (antrian) berarti mengurangi tingkat tabrakan antara <em>flow</em> yang berbeda,
sehingga berakibat pada biaya untuk meningkatkan penggunaan memori. Nilai 1 di sini secara
efektif menonaktifkan logika <em>fair-queuing</em>, tetapi masih mengizinkan permintaan untuk
dimasukkan kedalam antrian.</p></li><li><p>Meningkatkan <code>queueLengthLimit</code> berarti memperbolehkan lonjakan yang lebih besar dari lalu lintas
untuk berkelanjutan tanpa menggagalkan permintaan apa pun, dengan konsekuensi akan meningkatkan
latensi dan penggunaan memori.</p></li><li><p>Mengubah <code>handSize</code> berarti memperbolehkan kamu untuk menyesuaikan probabilitas tabrakan antara
   <em>flow</em> yang berbeda dan keseluruhan konkurensi yang tersedia untuk satu <em>flow</em> tunggal
dalam situasi beban berlebih.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> <code>HandSize</code> yang lebih besar membuat dua <em>flow</em> individual berpeluang kecil untuk bertabrakan
(dan dimana <em>flow</em> yang satu bisa membuat <em>flow</em> yang lain menderita), tetapi akan lebih memungkinkan
bahwa <em>flow</em> dalam jumlah kecil akan dapat mendominasi apiserver. <code>HandSize</code> yang lebih besar juga
berpotensi meningkatkan jumlah latensi yang diakibatkan oleh satu <em>flow</em> lalu lintas tunggal
yang tinggi. Jumlah maksimum permintaan dalam antrian yang diijinkan dari sebuah <em>flow</em> tunggal
adalah <code>handSize * queueLengthLimit</code>.</div></li></ul><p>Berikut ini adalah tabel yang menunjukkan koleksi konfigurasi <em>shuffle sharding</em>
yang menarik, dimana setiap probabilitas <em>mouse</em> (<em>flow</em> dengan intensitas rendah)
yang diberikan akan dimampatkan oleh <em>elephant</em> (<em>flow</em> dengan intensitas tinggi) dalam sebuah koleksi ilustratif
dari jumlah <em>elephant</em> yang berbeda. Silahkan lihat pada
<a href=https://play.golang.org/p/Gi0PLgVHiUg>https://play.golang.org/p/Gi0PLgVHiUg</a>, yang digunakan untuk menghitung nilai-nilai dalam tabel ini.</p><table><caption style=display:none>Contoh Konfigurasi Shuffle Sharding</caption><thead><tr><th>HandSize</th><th>Queues</th><th>1 elephant</th><th>4 elephants</th><th>16 elephants</th></tr></thead><tbody><tr><td>12</td><td>32</td><td>4.428838398950118e-09</td><td>0.11431348830099144</td><td>0.9935089607656024</td></tr><tr><td>10</td><td>32</td><td>1.550093439632541e-08</td><td>0.0626479840223545</td><td>0.9753101519027554</td></tr><tr><td>10</td><td>64</td><td>6.601827268370426e-12</td><td>0.00045571320990370776</td><td>0.49999929150089345</td></tr><tr><td>9</td><td>64</td><td>3.6310049976037345e-11</td><td>0.00045501212304112273</td><td>0.4282314876454858</td></tr><tr><td>8</td><td>64</td><td>2.25929199850899e-10</td><td>0.0004886697053040446</td><td>0.35935114681123076</td></tr><tr><td>8</td><td>128</td><td>6.994461389026097e-13</td><td>3.4055790161620863e-06</td><td>0.02746173137155063</td></tr><tr><td>7</td><td>128</td><td>1.0579122850901972e-11</td><td>6.960839379258192e-06</td><td>0.02406157386340147</td></tr><tr><td>7</td><td>256</td><td>7.597695465552631e-14</td><td>6.728547142019406e-08</td><td>0.0006709661542533682</td></tr><tr><td>6</td><td>256</td><td>2.7134626662687968e-12</td><td>2.9516464018476436e-07</td><td>0.0008895654642000348</td></tr><tr><td>6</td><td>512</td><td>4.116062922897309e-14</td><td>4.982983350480894e-09</td><td>2.26025764343413e-05</td></tr><tr><td>6</td><td>1024</td><td>6.337324016514285e-16</td><td>8.09060164312957e-11</td><td>4.517408062903668e-07</td></tr></tbody></table><h3 id=flowschema>FlowSchema</h3><p>FlowSchema mencocokkan beberapa permintaan yang masuk dan menetapkan permintaan ke dalam sebuah
tingkat prioritas. Setiap permintaan masuk diuji dengan setiap
FlowSchema secara bergiliran, dimulai dari yang terendah secara numerik ---
yang kita anggap sebagai yang tertinggi secara logis --- <code>matchingPrecedence</code> dan
begitu seterusnya. FlowSchema yang cocok pertama kali akan menang.</p><div class="alert alert-warning caution callout" role=alert><strong>Perhatian:</strong> Hanya FlowSchema yang pertama kali cocok untuk permintaan yang diberikan yang akan dianggap penting. Jika ada banyak
FlowSchema yang cocok dengan sebuah permintaan masuk, maka akan ditetapkan berdasarkan salah satu
yang mempunyai <code>matchingPrecedence</code> tertinggi. Jika ada beberapa FlowSchema dengan nilai
<code>matchingPrecedence</code> yang sama dan cocok dengan permintaan yang sama juga, permintaan dengan leksikografis
<code>name</code> yang lebih kecil akan menang, tetapi akan lebih baik untuk tidak mengandalkan metode ini, dan sebaiknya
perlu memastikan bahwa tidak ada dua FlowSchema yang memiliki <code>matchingPrecedence</code> yang sama.</div><p>Sebuah FlowSchema dianggap cocok dengan sebuah permintaan yang diberikan jika setidaknya salah satu dari <code>rules</code> nya
ada yang cocok. Sebuah aturan (<em>rule</em>) cocok jika setidaknya satu dari <code>subject</code> <em>dan</em>
ada salah satu dari <code>resourceRules</code> atau <code>nonResourceRules</code> (tergantung dari apakah permintaan
yang masuk adalah untuk URL sumber daya atau non-sumber daya) yang cocok dengan permintaan tersebut.</p><p>Untuk bagian <code>name</code> dalam subjek, dan bagian <code>verbs</code>, <code>apiGroups</code>, <code>resources</code>,
<code>namespaces</code>, dan <code>nonResourceURLs</code> dalam aturan sumber daya dan non-sumber daya,
<em>wildcard</em> <code>*</code> mungkin bisa ditetapkan untuk mencocokkan semua nilai pada bagian yang diberikan,
sehingga secara efektif menghapusnya dari pertimbangan.</p><p>Sebuah <code>DistinguisherMethod.type</code> dari FlowSchema menentukan bagaimana permintaan
yang cocok dengan Skema itu akan dipisahkan menjadi <em>flow</em>. Nilai tipe itu bisa jadi <code>ByUser</code>, dalam
hal ini satu pengguna yang meminta tidak akan bisa menghabiskan kapasitas dari pengguna lain,
atau bisa juga <code>ByNamespace</code>, dalam hal ini permintaan sumber daya
di salah satu Namespace tidak akan bisa menyebabkan penderitaan bagi permintaan akan sumber daya
dalam kapasitas Namespace yang lain, atau bisa juga kosong (atau <code>distinguisherMethod</code>
dihilangkan seluruhnya), dalam hal ini semua permintaan yang cocok dengan FlowSchema ini akan
dianggap sebagai bagian dari sebuah <em>flow</em> tunggal. Pilihan yang tepat untuk FlowSchema yang diberikan
akan bergantung pada sumber daya dan lingkungan khusus kamu.</p><h2 id=diagnosis>Diagnosis</h2><p>Setiap respons HTTP dari server API dengan fitur prioritas dan kesetaraan
yang diaktifkan memiliki dua <em>header</em> tambahan: <code>X-Kubernetes-PF-FlowSchema-UID</code> dan
<code>X-Kubernetes-PF-PriorityLevel-UID</code>, yang mencatat skema <em>flow</em> yang cocok dengan permintaan
dan tingkat prioritas masing-masing. Name Objek API tidak termasuk dalam <em>header</em> ini jika pengguna peminta tidak
memiliki izin untuk melihatnya, jadi ketika melakukan <em>debugging</em> kamu dapat menggunakan perintah seperti ini</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get flowschema -o custom-columns<span style=color:#666>=</span><span style=color:#b44>&#34;uid:{metadata.uid},name:{metadata.name}&#34;</span>
</span></span><span style=display:flex><span>kubectl get prioritylevelconfiguration -o custom-columns<span style=color:#666>=</span><span style=color:#b44>&#34;uid:{metadata.uid},name:{metadata.name}&#34;</span>
</span></span></code></pre></div><p>untuk mendapatkan pemetaan UID ke names baik untuk FlowSchema maupun PriorityLevelConfiguration.</p><h2 id=observabilitas>Observabilitas</h2><p>Saat kamu mengaktifkan fitur Prioritas dan Kesetaraan API atau APF, kube-apiserver
akan mengeluarkan metrik tambahan. Dengan memantau metrik ini dapat membantu kamu untuk menentukan apakah
konfigurasi kamu tidak tepat dalam membatasi lalu lintas yang penting, atau menemukan
beban kerja yang berperilaku buruk yang dapat membahayakan kesehatan dari sistem.</p><ul><li><p><code>apiserver_flowcontrol_rejected_requests_total</code> menghitung permintaan yang
ditolak, mengelompokkannya berdasarkan nama dari tingkat prioritas yang ditetapkan,
nama FlowSchema yang ditetapkan, dan alasan penolakan tersebut.
Alasan penolakan akan mengambil dari salah satu alasan-alasan berikut:</p><ul><li><code>queue-full</code>, yang mengindikasikan bahwa sudah terlalu banyak permintaan
yang menunggu dalam antrian,</li><li><code>concurrency-limit</code>, yang mengindikasikan bahwa PriorityLevelConfiguration
telah dikonfigurasi untuk menolak, bukan untuk memasukan permintaan berlebih ke
dalam antrian, atau</li><li><code>time-out</code>, yang mengindikasikan bahwa permintaan masih dalam antrian
ketika batas waktu antriannya telah berakhir.</li></ul></li><li><p><code>apiserver_flowcontrol_dispatched_requests_total</code> menghitung permintaan
yang sudah mulai dieksekusi, mengelompokkannya berdasarkan nama dari tingkat
prioritas yang ditetapkan, dan nama dari FlowSchema yang ditetapkan.</p></li><li><p><code>apiserver_flowcontrol_current_inqueue_requests</code> memberikan
jumlah total sesaat secara instan dari permintaan dalam antrian (bukan yang dieksekusi),
dan mengelompokkannya berdasarkan tingkat prioritas dan FlowSchema.</p></li><li><p><code>apiserver_flowcontrol_current_executing_requests</code> memberikan
jumlah total yang instan dari permintaan yang dieksekusi, dan mengelompokkannya
berdasarkan tingkat prioritas dan FlowSchema.</p></li><li><p><code>apiserver_flowcontrol_request_queue_length_after_enqueue</code> memberikan
histogram dari panjang antrian untuk semua antrian yang ada, mengelompokkannya berdasarkan
tingkat prioritas dan FlowSchema, berdasarkan pengambilan sampel oleh permintaan
<em>enqueued</em>. Setiap permintaan yang mendapatkan antrian berkontribusi ke satu sampel
dalam histogramnya, pelaporan panjang antrian dilakukan setelah permintaan yang
mengantri tersebut ditambahkan. Perlu dicatat bahwa ini akan menghasilkan statistik
yang berbeda dengan survei yang tidak bias.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Nilai asing atau tidak biasa dalam histogram akan berarti ada kemungkinan sebuah <em>flow</em></li></ul><p>(misalnya, permintaan oleh satu pengguna atau untuk satu <em>namespace</em>, tergantung pada
konfigurasinya) telah membanjiri server API, dan sedang dicekik. Sebaliknya, jika
histogram dari satu tingkat prioritas menunjukkan bahwa semua antrian dalam prioritas
level itu lebih panjang daripada level prioritas yang lainnya, mungkin akan sesuai
untuk meningkatkan <em>concurrency shares</em> dari PriorityLevelConfiguration itu.</p></div><ul><li><p><code>apiserver_flowcontrol_request_concurrency_limit</code> memberikan hasil perhitungan
batas konkurensi (berdasarkan pada batas konkurensi total dari server API dan
<em>concurrency share</em> dari PriorityLevelConfiguration) untuk setiap
PriorityLevelConfiguration.</p></li><li><p><code>apiserver_flowcontrol_request_wait_duration_seconds</code> memberikan histogram tentang bagaimana
permintaan yang panjang dihabiskan dalam antrian, mengelompokkannya berdasarkan FlowSchema
yang cocok dengan permintaan, tingkat prioritas yang ditetapkan, dan apakah permintaan
tersebut berhasil dieksekusi atau tidak.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Karena setiap FlowSchema selalu memberikan permintaan untuk satu</li></ul><p>PriorityLevelConfiguration, kamu dapat menambahkan histogram untuk semua
FlowSchema dalam satu tingkat prioritas untuk mendapatkan histogram yang efektif
dari permintaan yang ditetapkan ke tingkat prioritas tersebut.</p></div><ul><li><code>apiserver_flowcontrol_request_execution_seconds</code> memberikan histogram tentang bagaimana
caranya permintaan yang panjang diambil untuk benar-benar dieksekusi, mengelompokkannya
berdasarkan FlowSchema yang cocok dengan permintaan dan tingkat prioritas yang ditetapkan pada
permintaan tersebut.</li></ul><h2 id=selanjutnya>Selanjutnya</h2><p>Untuk latar belakang informasi mengenai detail desain dari prioritas dan kesetaraan API, silahkan lihat
<a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-api-machinery/1040-priority-and-fairness>proposal pembaharuan</a>.
Kamu juga dapat membuat saran dan permintaan akan fitur melalui <a href=https://github.com/kubernetes/community/tree/master/sig-api-machinery>SIG API
Machinery</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-7e0d97616b15e2c383c6a0a96ec442cb>3.12 - Memperluas Kubernetes</h1></div><div class=td-content><h1 id=pg-5c2b36cd0ddbe006b575d4e54c63d508>3.12.1 - Memperluas Klaster Kubernetes Kamu</h1><p>Kubernetes sangat mudah dikonfigurasi dan diperluas. Sehingga,
jarang membutuhkan <em>fork</em> atau menambahkan <em>patch</em> ke kode proyek Kubernetes.</p><p>Panduan ini menjelaskan pilihan untuk menyesuaikan klaster Kubernetes.
Dokumen ini ditujukan kepada <a class=glossary-tooltip title='Seseorang yang mengonfigurasi, mengontrol, dan memonitor klaster.' data-toggle=tooltip data-placement=top href='/id/docs/reference/glossary/?all=true#term-cluster-operator' target=_blank aria-label='operator klaster'>operator klaster</a> yang ingin
memahami bagaimana menyesuaikan klaster Kubernetes dengan kebutuhan lingkungan kerja mereka.</p><p>Developer yang prospektif <a class=glossary-tooltip title='Seseorang yang menyesuaikan platform Kubernetes agar sesuai dengan kebutuhan proyek mereka.' data-toggle=tooltip data-placement=top href='/id/docs/reference/glossary/?all=true#term-platform-developer' target=_blank aria-label='Developer Platform'>Developer Platform</a> atau <a class=glossary-tooltip title='Seseorang yang menyumbangkan kode, dokumentasi, atau waktu mereka untuk membantu proyek atau komunitas Kubernetes.' data-toggle=tooltip data-placement=top href='/id/docs/reference/glossary/?all=true#term-contributor' target=_blank aria-label=Kontributor>Kontributor</a> Proyek Kubernetes juga mendapatkan manfaat dari
dokumen ini sebagai pengantar apa saja poin-poin dan pola-pola perluasan yang ada, untung-rugi, dan batasan-batasannya.</p><h2 id=ikhtisar>Ikhtisar</h2><p>Pendekatan-pendekatan kostumisasi secara umum dapat dibagi atas <em>konfigurasi</em>, yang hanya melibatkan perubahan <em>flag</em>, konfigurasi berkas lokal, atau objek-objek sumber daya API; dan <em>perluasan</em>, yang melibatkan berjalannya program atau layanan tambahan. Dokumen ini sebagian besar membahas tentang perluasan.</p><h2 id=konfigurasi>Konfigurasi</h2><p><em>Flag-flag</em> dan <em>berkas-berkas konfigurasi</em> didokumentasikan di bagian Referensi dari dokumentasi daring, didalam setiap <em>binary</em>:</p><ul><li><a href=/docs/admin/kubelet/>kubelet</a></li><li><a href=/docs/admin/kube-apiserver/>kube-apiserver</a></li><li><a href=/docs/admin/kube-controller-manager/>kube-controller-manager</a></li><li><a href=/docs/admin/kube-scheduler/>kube-scheduler</a>.</li></ul><p><em>Flag-flag</em> dan berkas-berkas konfigurasi mungkin tidak selalu dapat diubah pada layanan Kubernetes yang <em>hosted</em> atau pada distribusi dengan instalasi yang dikelola. Ketika mereka dapat diubah, mereka biasanya hanya dapat diubah oleh Administrator Klaster. Dan juga, mereka dapat sewaktu-waktu diubah dalam versi Kubernetes di masa depan, dan menyetel mereka mungkin memerlukan proses pengulangan kembali. Oleh karena itu, mereka harus digunakan hanya ketika tidak ada pilihan lain.</p><p><em>API kebijakan bawaan</em>, seperti <a href=/id/docs/concepts/policy/resource-quotas/>ResourceQuota</a>, <a href=/id/docs/concepts/policy/pod-security-policy/>PodSecurityPolicy</a>, <a href=/id/docs/concepts/services-networking/network-policies/>NetworkPolicy</a> dan Role-based Access Control (<a href=/id/docs/reference/access-authn-authz/rbac/>RBAC</a>), adalah API bawaan Kubernetes. API biasanya digunakan oleh layanan Kubernetes yang <em>hosted</em> dan diatur oleh instalasi Kubernetes. Mereka bersifat deklaratif dan menggunakan konvensi yang sama dengan sumber daya Kubernetes lainnya seperti pod-pod, jadi konfigurasi klaster baru dapat diulang-ulang dan dapat diatur dengan cara yang sama dengan aplikasi. Dan, ketika mereka stabil, mereka mendapatkan keuntungan dari <a href=/docs/reference/deprecation-policy/>kebijakan pendukung yang jelas</a> seperti API Kubernetes lainnya. Oleh karena itu, mereka lebih disukai daripada <em>berkas konfigurasi</em> dan <em>flag-flag</em> saat mereka cocok dengan situasi yang dibutuhkan.</p><h2 id=perluasan>Perluasan</h2><p>Perluasan adalah komponen perangkat lunak yang memperluas dan berintegrasi secara mendalam dengan Kubernetes.
Mereka mengadaptasi Kubernetes untuk mendukung perangkat keras tipe baru dan jenis baru.</p><p>Kebanyakan administrator klaster akan menggunakan instansi Kubernetes yang didistribusikan atau yang <em>hosted</em>.
Sebagai hasilnya, kebanyakan pengguna Kubernetes perlu menginstal perluasan dan lebih sedikit yang perlu untuk membuat perluasan-perluasan yang baru.</p><h2 id=pola-pola-perluasan>Pola-pola Perluasan</h2><p>Kubernetes didesain untuk dapat diotomasi dengan menulis program-program klien. Program apapun yang membaca dan/atau menulis ke API Kubernetes dapat menyediakan otomasi yang berguna.</p><p><em>Otomasi</em> dapat berjalan di dalam klaster atau di luar klaster. Dengan mengikuti panduan
di dalam dokumen ini, kamu dapat menulis otomasi yang sangat tersedia dan kuat.
Otomasi pada umumnya dapat bekerja dengan berbagai macam klaster Kubernetes, termasuk
klaster yang <em>hosted</em> dan instalasi yang dikelola.</p><p>Ada pola spesifik untuk menulis program klien yang bekerja dengan baik bersama Kubernetes yang disebut pola <em>Controller</em>. <em>Controller-controller</em> biasanya membaca kolom <code>.spec</code> milik sebuah objek, kemungkinan melakukan sesuatu, dan kemudian memperbarui objek milik <code>.status</code>.</p><p><em>Controller</em> adalah klien dari Kubernetes. Ketika Kubernetes adalah klien dan memanggil layanan
terpisah, hal tersebut disebut <em>Webhook</em>. Layanan terpisah tersebut disebut sebuah <em>Webhook Backend</em>. Seperti <em>Controller-controller</em>, <em>Webhook-webhook</em> memang menambah sebuah titik untuk terjadinya kegagalan.</p><p>Di dalam model <em>Webhook</em>, Kubernetes membuat sebuah <em>network request</em> kepada sebuah layanan terpisah.</p><p>Di dalam model <em>Binary Plugin</em>, Kubernetes mengeksekusi sebuah program.
<em>Binary Plugin</em> digunakan oleh kubelet (misalnya <a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-storage/flexvolume.md><em>Plugin Flex Volume</em></a>
dan oleh <a href=/docs/concepts/cluster-administration/network-plugins/><em>Plugin</em> Jaringan</a>) dan oleh kubectl.</p><p>Berikut ini adalah diagram yang menunjukkan bagaimana titik-titik perluasan berinteraksi dengan <em>control plane</em> Kubernetes.</p><img src="https://docs.google.com/drawings/d/e/2PACX-1vQBRWyXLVUlQPlp7BvxvV9S1mxyXSM6rAc_cbLANvKlu6kCCf-kGTporTMIeG5GZtUdxXz1xowN7RmL/pub?w=960&h=720"><h2 id=titik-titik-perluasan>Titik-titik Perluasan</h2><p>Diagram berikut menunjukkan titik-titik perluasan di sebuah Kubernetes.</p><img src="https://docs.google.com/drawings/d/e/2PACX-1vSH5ZWUO2jH9f34YHenhnCd14baEb4vT-pzfxeFC7NzdNqRDgdz4DDAVqArtH4onOGqh0bhwMX0zGBb/pub?w=425&h=809"><ol><li>Pengguna biasanya berinteraksi dengan API Kubernetes menggunakan <code>kubectl</code>. <a href=/docs/tasks/extend-kubectl/kubectl-plugins/><em>Plugin-plugin</em> Kubectl</a> memperluas <em>binari</em> kubectl. Mereka hanya memengaruhi lingkungan lokal pengguna, dan tidak dapat memaksakan kebijakan yang menyeluruh di seluruh situs.</li><li>apiserver menangani semua permintaan. Beberapa tipe titik perluasan di apiserver memperbolehkan otentikasi permintaan, atau memblokir mereka berdasarkan konten mereka, menyunting konten, dan menangani penghapusan. Hal ini dideskripsikan di bagian <a href=/docs/concepts/overview/extending#perluasan-perluasan-akses-api>Perluasan Akses API</a></li><li>apiserver melayani berbagai macam sumber daya, <em>tipe-tipe sumber daya bawaan</em>, seperti <code>pod</code>, didefinisikan oleh proyek kubernetes dan tidak dapat diubah. kamu juga dapat menambahkan sumber daya yang kamu definisikan sendiri, atau yang proyek lain definisikan, disebut <em>Custom Resources</em>, seperti dijelaskan di bagian <a href=/docs/concepts/overview/extending#tipe-tipe-yang-ditentukan-pengguna>Sumber Daya <em>Custom</em></a>. Sumber daya <em>Custom</em> sering digunakan dengan Perluasan Akses API.</li><li>Penjadwal Kubernetes memutuskan ke Node mana Pod akan ditempatkan. Ada beberapa cara untuk memperluas penjadwalan. Hal ini dibahas pada bagian <a href=/docs/concepts/overview/extending#perluasan-perluasan-penjadwal>Perluasan-perluasan Penjadwal</a>.</li><li>Sebagian besar perilaku Kubernetes diimplementasi oleh program yang disebut <em>Controller-controller</em> yang merupakan klien dari API-Server. <em>Controller-controller</em> sering digunakan bersama dengan Sumber Daya <em>Custom</em>.</li><li>Kubelet berjalan di server, dan membantu Pod-pod terlihat seperti server virtual dengan IP mereka sendiri di jaringan klaster. <a href=/docs/concepts/overview/extending#plugin-plugin-jaringan><em>Plugin</em> Jaringan</a> memungkinkan adanya perbedaan implementasi pada jaringan Pod.</li><li>Kubelet juga melakukan penambatan dan pelepasan tambatan volume untuk kontainer. Tipe-tipe penyimpanan baru dapat didukung via <a href=/docs/concepts/overview/extending#plugin-plugin-penyimpanan><em>Plugin</em> Penyimpanan</a>.</li></ol><p>Jika kamu tidak yakin untuk memulai dari mana, diagram alir di bawah ini dapat membantu kamu. Ingat lah bahwa beberapa solusi mungkin melibatkan beberapa tipe perluasan.</p><img src="https://docs.google.com/drawings/d/e/2PACX-1vRWXNNIVWFDqzDY0CsKZJY3AR8sDeFDXItdc5awYxVH8s0OLherMlEPVUpxPIB1CSUu7GPk7B2fEnzM/pub?w=1440&h=1080"><h2 id=perluasan-api>Perluasan API</h2><h3 id=tipe-tipe-yang-ditentukan-pengguna>Tipe-tipe yang Ditentukan Pengguna</h3><p>Pertimbangkan untuk menambahkan Sumber Daya <em>Custom</em> ke Kubernetes jika kamu ingin mendefinisikan pengontrol baru, objek konfigurasi aplikasi atau API deklaratif lainnya, dan untuk mengelolanya menggunakan alat Kubernetes, seperti <code>kubectl</code>.</p><p>Jangan menggunakan Sumber Daya <em>Custom</em> sebagai penyimpanan data untuk aplikasi, pengguna, atau untuk memonitor data.</p><p>Untuk lebih jelasnya tentang Sumber Daya <em>Custom</em>, lihat <a href=/docs/concepts/api-extension/custom-resources/>Panduan Konsep Sumber Daya <em>Custom</em></a>.</p><h3 id=menggabungkan-api-baru-dengan-otomasi>Menggabungkan API Baru dengan Otomasi</h3><p>Kombinasi antara sebuah API sumber daya <em>custom</em> dan <em>loop</em> kontrol disebut <a href=/id/docs/concepts/extend-kubernetes/operator/>Pola Operator</a>. Pola Operator digunakan untuk mengelola aplikasi yang spesifik dan biasanya <em>stateful</em>. API-API <em>custom</em> dan <em>loop</em> kontrol ini dapat digunakan untuk mengatur sumber daya lainnya, seperti penyimpanan dan kebijakan-kebijakan.</p><h3 id=mengubah-sumber-daya-bawaan>Mengubah Sumber Daya Bawaan</h3><p>Ketika kamu memperluas API Kubernetes dengan menambahkan sumber daya <em>custom</em>, sumber daya yang ditambahkan akan selalu masuk ke Grup API baru. Kamu tidak dapat mengganti atau mengubah Grup API yang sudah ada. Menambah sebuah API tidak secara langsung membuat kamu memengaruhi perilaku API yang sudah ada (seperti Pod), tetapi Perluasan Akses API dapat memengaruhinya secara langsung.</p><h3 id=perluasan-perluasan-akses-api>Perluasan-Perluasan Akses API</h3><p>Ketika sebuah permintaan sampai ke Server API Kubernetes, permintaan tersebut diotentikasi terlebih dahulu, kemudian diotorisasi, kemudian diarahkan ke berbagai jenis <em>Admission Control</em>. Lihat dokumentasi <a href=/docs/reference/access-authn-authz/controlling-access/>Mengatur Akses ke API Kubernetes</a> untuk lebih jelasnya tentang alur ini.</p><p>Setiap langkah berikut menawarkan titik-titik perluasan.</p><p>Kubernetes memiliki beberapa metode otentikasi bawaan yang didukungnya. Metode ini bisa berada di belakang proksi yang mengotentikasi, dan metode ini dapat mengirim sebuah token dari <em>header</em> Otorisasi ke layanan terpisah untuk verifikasi (sebuah <em>webhook</em>). Semua metode ini tercakup dalam <a href=/docs/reference/access-authn-authz/authentication/>Dokumentasi Otentikasi</a>.</p><h3 id=otentikasi>Otentikasi</h3><p><a href=/docs/reference/access-authn-authz/authentication/>Otentikasi</a> memetakan <em>header</em> atau sertifikat dalam semua permintaan ke <em>username</em> untuk klien yang mebuat permintaan.</p><p>Kubernetes menyediakan beberapa metode otentikasi bawaan, dan sebuah metode <a href=/docs/reference/access-authn-authz/authentication/#webhook-token-authentication><em>Webhook</em> Otentikasi</a> jika metode bawaan tersebut tidak mencukupi kebutuhan kamu.</p><h3 id=otorisasi>Otorisasi</h3><p><a href=/docs/reference/access-authn-authz/webhook/>Otorisasi</a> menentukan apakah pengguna tertentu dapat membaca, menulis, dan melakukan operasi lainnya terhadap sumber daya API. Hal ini hanya bekerja pada tingkat sumber daya secara keseluruhan -- tidak membeda-bedakan berdasarkan field objek sembarang. Jika pilihan otorisasi bawaan tidak mencukupi kebutuhan kamu, <a href=/docs/reference/access-authn-authz/webhook/><em>Webhook</em> Otorisasi</a> memungkinkan pemanggilan kode yang disediakan pengguna untuk membuat keputusan otorisasi.</p><h3 id=kontrol-admisi-dinamis>Kontrol Admisi Dinamis</h3><p>Setalah permintaan diotorisasi, jika ini adalah operasi penulisan, permintaan ini akan melalui langkah <a href=/docs/reference/access-authn-authz/admission-controllers/>Kontrol Admisi</a>. Sebagai tambahan untuk step bawaan, ada beberapa perluasan:</p><ul><li><a href=/docs/reference/access-authn-authz/admission-controllers/#imagepolicywebhook><em>Webhook</em> Kebijakan <em>Image</em></a> membatasi <em>image</em> mana saja yang dapat berjalan di kontainer.</li><li>Untuk membuat keputusan kontrol admisi sembarang, <a href=/docs/reference/access-authn-authz/extensible-admission-controllers/#admission-webhooks><em>Webhook</em> Admisi</a> umum dapat digunakan. <em>Webhook</em> Admisi dapat menolak pembuatan atau pembaruan.</li></ul><h2 id=perluasan-infrastruktur>Perluasan Infrastruktur</h2><h3 id=plugin-plugin-penyimpanan><em>Plugin-plugin</em> Penyimpanan</h3><p><a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/flexvolume-deployment.md>Flex Volume</a> memungkinkan pengguna untuk memasang tipe-tipe volume tanpa dukungan bawaan dengan cara membiarkan Kubelet memanggil sebuah <em>Plugin Binary</em> untuk menambatkan volume.</p><h3 id=plugin-perangkat><em>Plugin</em> Perangkat</h3><p><em>Plugin</em> perangkat memungkinkan sebuah node untuk menemukan sumber daya Node baru (sebagai tambahan dari bawaannya seperti CPU dan memori) melalui sebuah <a href=/docs/concepts/cluster-administration/device-plugins/><em>Plugin</em> Perangkat</a>.</p><h3 id=plugin-plugin-jaringan><em>Plugin-plugin</em> Jaringan</h3><p>Struktur-struktur jaringan yang berbeda dapat didukung melalui <a href=/docs/admin/network-plugins/><em>Plugin</em> Jaringan</a> pada tingkat Node.</p><h3 id=perluasan-perluasan-penjadwal>Perluasan-perluasan Penjadwal</h3><p>Penjadwal adalah jenis pengatur spesial yang mengawasi Pod, dan menempatkan Pod ke Node. Penjadwal bawaan dapat digantikan seluruhnya, sementara terus menggunakan komponen Kubernetes lainnya, atau <a href=/docs/tasks/administer-cluster/configure-multiple-schedulers/>penjadwal ganda</a> dapat berjalan dalam waktu yang bersamaan.</p><p>Ini adalah usaha yang signifikan, dan hampir semua pengguna Kubernetes merasa mereka tidak perlu memodifikasi penjadwal tersebut.</p><p>Penjadwal juga mendukung <a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/scheduling/scheduler_extender.md><em>webhook</em></a> yang memperbolehkan sebuah <em>webhook backend</em> (perluasan penjadwal) untuk menyaring dan memprioritaskan Node yang terpilih untuk sebuah Pod.</p><h2 id=selanjutnya>Selanjutnya</h2><ul><li>Pelajari lebih lanjut tentang <a href=/docs/concepts/api-extension/custom-resources/>Sumber Daya <em>Custom</em></a></li><li>Pelajari tentang <a href=/docs/reference/access-authn-authz/extensible-admission-controllers/>Kontrol Admisi Dinamis</a></li><li>Pelajari lebih lanjut tentang perluasan Infrastruktur<ul><li><a href=/docs/concepts/cluster-administration/network-plugins/><em>Plugin</em> Jaringan</a></li><li><a href=/docs/concepts/cluster-administration/device-plugins/><em>Plugin</em> Perangkat</a></li></ul></li><li>Pelajari tentang <a href=/docs/tasks/extend-kubectl/kubectl-plugins/><em>Plugin</em> kubectl</a></li><li>Pelajari tentang <a href=/id/docs/concepts/extend-kubernetes/operator/>Pola Operator</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-0af41d3bd7c785621b58b7564793396a>3.12.2 - Memperluas API Kubernetes</h1></div><div class=td-content><h1 id=pg-1ea4977c0ebf97569bf54a477faa7fa5>3.12.2.1 - Memperluas Kubernetes API dengan Lapisan Agregasi</h1><p>Lapisan agregasi memungkinkan Kubernetes untuk diperluas dengan API tambahan, selain dari yang ditawarkan oleh API inti Kubernetes.</p><h2 id=ikhtisar>Ikhtisar</h2><p>Lapisan agregasi memungkinkan instalasi tambahan beragam API <em>Kubernetes-style</em> di kluster kamu. Tambahan-tambahan ini dapat berupa solusi-solusi yang sudah dibangun (<em>prebuilt</em>) oleh pihak ke-3 yang sudah ada, seperti <a href=https://github.com/kubernetes-incubator/service-catalog/blob/master/README.md><em>service-catalog</em></a>, atau API yang dibuat oleh pengguna seperti <a href=https://github.com/kubernetes-incubator/apiserver-builder/blob/master/README.md>apiserver-builder</a>, yang dapat membantu kamu memulainya.</p><p>Lapisan agregasi berjalan di dalam proses bersama dengan kube-apiserver. Hingga sebuah sumber daya ekstensi terdaftar, lapisan agregasi tidak akan melakukan apapun. Untuk mendaftarkan sebuah API, pengguna harus menambahkan sebuah objek <em>APIService</em>, yang "mengklaim" jalur URL di API Kubernetes. Pada titik tersebut, lapisan agregasi akan mem-<em>proxy</em> apapun yang dikirim ke jalur API tersebut (misalnya /apis/myextension.mycompany.io/v1/…) ke <em>APIService</em> yang terdaftar.</p><p>Biasanya, <em>APIService</em> akan diimplementasikan oleh sebuah ekstensi-apiserver di dalam sebuah Pod yang berjalan di kluster. Ekstensi-apiserver ini biasanya perlu di pasangkan dengan satu atau lebih <em>controller</em> apabila manajemen aktif dari sumber daya tambahan diperlukan. Sebagai hasilnya, apiserver-builder sebenarnya akan memberikan kerangka untuk keduanya. Sebagai contoh lain, ketika service-catalog diinstal, ia menyediakan ekstensi-apiserver dan <em>controller</em> untuk layanan-layanan yang disediakannya.</p><p>Ekstensi-apiserver harus memiliki latensi koneksi yang rendah dari dan ke kube-apiserver.
Secara Khusus, permintaan pencarian diperlukan untuk bolak-balik dari kube-apiserver dalam 5 detik atau kurang.
Jika implementasi kamu tidak dapat menyanggupinya, kamu harus mempertimbangkan cara mengubahnya. Untuk sekarang, menyetel
<em>feature-gate</em> <code>EnableAggregatedDiscoveryTimeout=false</code> di kube-apiserver
akan menonaktifkan batasan waktu tersebut. Fitur ini akan dihapus dalam rilis mendatang.</p><h2 id=selanjutnya>Selanjutnya</h2><ul><li>Untuk mengaktifkan agregator di lingkungan kamu, aktifkan<a href=/docs/tasks/access-kubernetes-api/configure-aggregation-layer/>konfigurasi lapisan agregasi</a>.</li><li>Kemudian, <a href=/docs/tasks/access-kubernetes-api/setup-extension-api-server/>siapkan ekstensi api-server</a> untuk bekerja dengan lapisan agregasi.</li><li>Selain itu, pelajari caranya <a href=/docs/tasks/access-kubernetes-api/extend-api-custom-resource-definitions/>mengembangkan API Kubernetes menggunakan <em>Custom Resource Definition</em></a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-342388440304e19ce30c0f8ada1c77ce>3.12.2.2 - Custom Resource</h1><p><em>Custom Resource</em> adalah ekstensi dari Kubernetes API. Laman ini mendiskusikan kapan kamu melakukan penambahan sebuah <em>Custom Resource</em> ke klaster Kubernetes dan kapan kamu menggunakan sebuah layanan mandiri. Laman ini mendeskripsikan dua metode untuk menambahkan <em>Custom Resource</em> dan bagaimana cara memilihnya.</p><h2 id=custom-resource><em>Custom Resource</em></h2><p>Sebuah sumber daya adalah sebuah <em>endpoint</em> pada <a href=/docs/reference/using-api/api-overview/>Kubernetes API</a> yang menyimpan sebuah koleksi <a href=/id/docs/concepts/overview/working-with-objects/kubernetes-objects/>objek API</a> dari sebuah jenis tertentu. Sebagai contoh, sumber daya bawaan Pod mengandung sebuah koleksi objek-objek Pod.</p><p>Sebuah <em>Custom Resource</em> adalah sebuah ekstensi dari Kubernetes API yang tidak seharusnya tersedia pada pemasangan default Kubernetes. Namun, banyak fungsi-fungsi inti Kubernetes yang sekarang dibangun menggunakan <em>Custom Resource</em>, membuat Kubernetes lebih modular.</p><p><em>Custom Resource</em> bisa muncul dan menghilang dalam sebuah klaster yang berjalan melalui registrasi dinamis (<em>dynamic registration</em>), dan admin-admin klaster bisa memperbaharui <em>Custom Resource</em> secara independen dari klaster itu sendiri. Ketika sebuah <em>Custom Resource</em>
dipasang, pengguna dapat membuat dan mengakses objek-objek <em>Custom Resource</em> menggunakan <a href=/docs/user-guide/kubectl-overview/>kubectl</a>, seperti yang mereka lakukan untuk sumber daya bawaan seperti Pod.</p><h2 id=controller-khusus><em>Controller</em> Khusus</h2><p>Dengan sendirinya, <em>Custom Resource</em> memungkinkan kamu untuk menyimpan dan mengambil data terstruktur. Ketika kamu menggabungkan sebuah <em>Custom Resource</em> dengan <em>controller</em> khusus, <em>Custom Resource</em> akan memberikan sebuah API deklaratif yang sebenarnya.</p><p>Sebuah <a href=/id/docs/concepts/overview/working-with-objects/kubernetes-objects/#memahami-konsep-objek-objek-yang-ada-pada-kubernetes>API deklaratif</a>
memungkinkan kamu untuk mendeklarasikan atau menspesifikasikan keadaan dari sumber daya kamu dan mencoba untuk menjaga agar keadaan saat itu tersinkronisasi dengan keadaan yang diinginkan. <em>Controller</em> menginterpretasikan data terstruktur sebagai sebuah rekaman dari keadaan yang diinginkan pengguna, dan secara kontinu menjaga keadaan ini.</p><p>Kamu bisa men-<em>deploy</em> dan memperbaharui sebuah <em>controller</em> khusus pada sebuah klaster yang berjalan, secara independen dari siklus hidup klaster itu sendiri. <em>Controller</em> khusus dapat berfungsi dengan sumber daya jenis apapun, tetapi mereka sangat efektif ketika dikombinasikan dengan <em>Custom Resource</em>. <a href=https://coreos.com/blog/introducing-operators.html><em>Operator pattern</em></a> mengkombinasikan <em>Custom Resource</em> dan <em>controller</em> khusus. Kamu bisa menggunakan <em>controller</em> khusus untuk menyandi pengetahuan domain untuk aplikasi spesifik menjadi sebuah ekstensi dari Kubernetes API.</p><h2 id=haruskah-custom-resource-ditambahkan-ke-dalam-klaster-kubernetes-saya>Haruskah <em>Custom Resource</em> ditambahkan ke dalam klaster Kubernetes saya?</h2><p>Ketika membuat sebuah API baru, pikirkan apakah kamu ingin <a href=/docs/concepts/api-extension/apiserver-aggregation/>mengagregasikan API kamu dengan API klaster Kubernetes</a> atau membiarkan API kamu berdiri sendiri.</p><table><thead><tr><th>Pilih agregasi API jika:</th><th>Pilih sebuah API yang berdiri sendiri jika:</th></tr></thead><tbody><tr><td>API kamu bersifat <a href=#api-deklaratif>Deklaratif</a>.</td><td>API kamu tidak cocok dengan model <a href=#api-deklaratif>Deklaratif</a>.</td></tr><tr><td>Kamu mau tipe baru yang dapat dibaca dan ditulis dengan <code>kubectl</code>.</td><td>Dukungan <code>kubectl</code> tidak diperlukan</td></tr><tr><td>Kamu mau melihat tipe baru pada sebuah Kubernetes UI, seperti dasbor, bersama dengan tipe-tipe bawaan.</td><td>Dukungan Kubernetes UI tidak diperlukan.</td></tr><tr><td>Kamu mengembangkan sebuah API baru.</td><td>Kamu memiliki sebuah program yang melayani API kamu dan dapat berkerja dengan baik.</td></tr><tr><td>Kamu bersedia menerima pembatasan format yang Kubernetes terapkan pada jalur sumber daya API (Lihat <a href=/id/docs/concepts/overview/kubernetes-api/>Ikhtisar API</a>.)</td><td>Kamu perlu memiliki jalur REST spesifik agar menjadi cocok dengan REST API yang telah didefinisikan.</td></tr><tr><td>Sumber daya kamu secara alami mencakup hingga sebuah klaster atau sebuah <em>namespace</em> dari sebuah klaster.</td><td>Sumber daya yang mencakup klaster atau <em>namespace</em> adalah sebuah ketidakcocokan; kamu perlu mengendalikan jalur sumber daya spesifik.</td></tr><tr><td>Kamu ingin menggunakan kembali <a href=#fitur-umum>dukungan fitur Kubernetes API</a>.</td><td>Kamu tidak membutuhkan fitur tersebut.</td></tr></tbody></table><h3 id=api-deklaratif>API Deklaratif</h3><p>Dalam sebuah API Deklaratif, biasanya:</p><ul><li>API kamu terdiri dari sejumlah kecil dari objek yang berukuran relatif kecil (sumber daya).</li><li>Objek-objek mendefinisikan pengaturan dari aplikasi atau infrastruktur.</li><li>Objek-objek relatif tidak sering diperbaharui.</li><li>Manusia sering diperlukan untuk membaca dan menulis objek-objek tersebut.</li><li>Operasi utama terhadap objek bersifat CRUD (<em>creating, reading, updating,</em> dan <em>deleting</em>).</li><li>Transaksi antar objek tidak dibutuhkan; API merepresentasikan sebuah keadaan yang diinginkan, bukan keadaan yang eksak.</li></ul><p>API imperatif bersifat tidak deklaratif.
Tanda-tanda apabila API kamu tidak deklaratif termasuk:</p><ul><li>klien berkata "lakukan ini", dan kemudian mendapat sebuah respon serempak ketika selesai.</li><li>klien berkata "lakukan ini", dan kemudian mendapat sebuah ID operasi kembali, dan harus melakukan sebuah cek terhadap objek <em>Operation</em> terpisah untuk menentukan selesainya sebuah permintaan.</li><li>Kamu berbicara tentang <em>Remote Procedure Call</em> (RPC).</li><li>Menyimpan secara langsung sejumlah data (mis. > beberapa kB per objek, atau >1000-an objek).</li><li>Membutuhkan akses dengan <em>bandwidth</em> tinggi (10-an permintaan per detik dapat ditopang).</li><li>Menyimpan data pengguna (seperti gambar, PII, dll) atau data berskala besar yang diproses oleh aplikasi.</li><li>Operasi-operasi natural terhadap objek yang tidak bersifat CRUD.</li><li>API yang tidak mudah dimodelkan dengan objek.</li><li>Kamu memilih untuk merepresentasikan operasi tertunda dengan sebuah ID operasi atau sebuah objek operasi.</li></ul><h2 id=apakah-saya-harus-menggunakan-sebuah-configmap-atau-sebuah-custom-resource>Apakah saya harus menggunakan sebuah ConfigMap atau sebuah <em>Custom Resource</em>?</h2><p>Gunakan ConfigMap jika salah satu hal berikut berlaku:</p><ul><li>Terdapat sebuah format berkas pengaturan yang sudah ada, yang terdokumentasi dengan baik seperti sebuah <code>mysql.cnf</code> atau <code>pom.xml</code>.</li><li>Kamu ingin menaruh seluruh berkas pengaturan kedalam sebuah <em>key</em> dari sebuah ConfigMap.</li><li>Kegunaan utama dari berkas pengaturan adalah untuk dikonsumsi sebuah program yang berjalan di dalam sebuah Pod di dalam klaster kamu untuk mengatur dirinya sendiri.</li><li>Konsumen dari berkas lebih suka untuk mengkonsumsi lewat berkas dalam sebuah Pod atau variabel lingkungan dalam sebuah Pod, dibandingkan melalui Kubernetes API.</li><li>Kamu ingin melakukan pembaharuan bergulir lewat Deployment, dll, ketika berkas diperbaharui.</li></ul><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Gunakan sebuah <a href=/id/docs/concepts/configuration/secret/>Secret</a> untuk data sensitif, yang serupa dengan ConfigMap tetapi lebih aman.</div><p>Gunakan sebuah <em>Custom Resource</em> (CRD atau <em>Aggregated API</em>) jika kebanyakan dari hal berikut berlaku:</p><ul><li>Kamu ingin menggunakan pustaka klien Kubernetes dan CLI untuk membuat dan memperbaharui sumber daya baru.</li><li>Kamu ingin dukungan tingkat tinggi dari kubectl (sebagai contoh: <code>kubectl get my-object object-name</code>).</li><li>Kamu ingin membangun sebuah otomasi baru yang mengawasi pembaharuan terhadap objek baru, dan kemudian melakukan CRUD terhadap objek lainnya, atau sebaliknya.</li><li>Kamu ingin menulis otomasi yang menangani pembaharuan untuk objek.</li><li>Kamu ingin menggunakan kesepakatan API Kubernetes seperti <code>.spec</code>, <code>.status</code>, dan <code>.metadata</code>.</li><li>Kamu ingin objek tersebut untuk menjadi sebuah abstraksi terhadap sebuah kumpulan dari sumber daya terkontrol, atau peringkasan dari sumber daya lainnya.</li></ul><h2 id=menambahkan-custom-resource>Menambahkan <em>Custom Resource</em></h2><p>Kubernetes menyediakan dua cara untuk menambahkan sumber daya ke klaster kamu:</p><ul><li>CRD cukup sederhana dan bisa diciptakan tanpa pemrograman apapun.</li><li><a href=/id/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>Agregasi API</a> membutuhkan pemrograman, tetapi memungkinkan kendali lebih terhadap perilaku API seperti bagaimana data disimpan dan perubahan antar versi API.</li></ul><p>Kubernetes menyediakan kedua opsi tersebut untuk memenuhi kebutuhan pengguna berbeda, jadi tidak ada kemudahan penggunaan atau fleksibilitas yang dikompromikan.</p><p><em>Aggregated API</em> adalah bawahan dari APIServer yang duduk dibelakang API server utama, yang bertindak sebagai sebuah <em>proxy</em>. Pengaturan ini disebut <a href=/id/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>Agregasi API</a> (AA). Untuk pengguna, yang terlihat adalah Kubernetes API yang diperluas.</p><p>CRD memungkinkan pengguna untuk membuat tipe baru sumber daya tanpa menambahkan APIserver lain. Kamu tidak perlu mengerti Agregasi API untuk menggunakan CRD.</p><p>Terlepas dari bagaimana cara mereka dipasang, sumber daya baru disebut sebagai <em>Custom Resource</em> untuk memisahkan mereka dari sumber daya bawaan Kubernetes (seperti Pod).</p><h2 id=customresourcedefinition>CustomResourceDefinition</h2><p>Sumber daya API <a href=/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions/>CustomResourceDefinition</a> memungkinkan kamu untuk medefinisikan <em>Custom Resource</em>. Mendefinisikan sebuah objek CRD akan membuat sebuah <em>Custom Resource</em> dengan sebuah nama dan skema yang kamu spesifikasikan. Kubernetes API melayani dan menangani penyimpanan dari <em>Custom Resource</em> kamu.</p><p>Ini membebaskan kamu dari menulis server API kamu sendiri untuk menangani <em>Custom Resource</em>, tetapi sifat dasar dari implementasi menyebabkan kamu memiliki fleksibilitas yang berkurang dibanding <a href=#agregasi-server-api>agregasi server API</a>).</p><p>Lihat <a href=https://github.com/kubernetes/sample-controller>contoh <em>controller</em> khusus</a> sebagai sebuah contoh dari bagaimana cara untuk mendaftarkan sebuah <em>Custom Resource</em>, bekerja dengan instans dari tipe baru sumber daya kamu, dan menggunakan sebuah <em>controller</em> untuk menangani <em>event</em>.</p><h2 id=agregasi-server-api>Agregasi server API</h2><p>Biasanya, tiap sumber daya di API Kubernetes membutuhkan kode yang menangani permintaan REST dan mengatur peyimpanan tetap dari objek-objek. Server Kubernetes API utama menangani sumber daya bawaan seperti Pod dan Service, dan juga menangani <em>Custom Resource</em> dalam sebuah cara yang umum melalui <a href=#customresourcedefinition>CRD</a>.</p><p><a href=/id/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>Lapisan agregasi</a> memungkinkan kamu untuk menyediakan implementasi khusus untuk <em>Custom Resource</em> dengan menulis dan men-<em>deploy</em> API server kamu yang berdiri sendiri. API server utama menlimpahkan permintaan kepada kamu untuk <em>Custom Resource</em> yang kamu tangani, membuat mereka tersedia untuk semua kliennya.</p><h2 id=memilih-sebuah-metode-untuk-menambahkan-custom-resource>Memilih sebuah metode untuk menambahkan <em>Custom Resource</em></h2><p>CRD lebih mudah digunakan. <em>Aggregated API</em> lebih fleksibel. Pilih metode yang paling baik untuk kebutuhan kamu.</p><p>Biasanya, CRD cocok jika:</p><ul><li>Kamu memiliki <em>field</em> yang banyak</li><li>Kamu menggunakan sumber daya dalam perusahaan kamu, atau sebagai bagian dari proyek <em>open-source</em> kecil (berlawanan dengan sebuah produk komersil)</li></ul><h3 id=membandingkan-kemudahan-penggunaan>Membandingkan kemudahan penggunaan</h3><p>CRD lebih mudah dibuat dibandingkan dengan <em>Aggregated API</em>.</p><table><thead><tr><th>CRD</th><th>Aggregated API</th></tr></thead><tbody><tr><td>Tidak membutuhkan pemrograman. Pengguna dapat memilih bahasa apapun untuk sebuah <em>controller</em> CRD.</td><td>Membutuhkan pemrograman dalam Go dan membangun <em>binary</em> dan <em>image</em>. Pengguna dapat memilih bahasa apapun untuk sebuah CRD <em>controller</em>.</td></tr><tr><td>Tidak ada servis tambahan yang dijalankan; CR ditangani oleh server API.</td><td>Sebuah servis tambahan untuk menciptakan dan dapat gagal.</td></tr><tr><td>Todal ada dukungan berjalan ketika CRD dibuat. Perbaikan <em>bug</em> apapun akan dianggap sebagai bagian dari peningkatan Kubernetes Master normal.</td><td>Mungkin dibutuhkan untuk secara berkala mengambil perbaikan <em>bug</em> dari sumber dan membangun ulang dan memeperbaharui APIserver teragregasi.</td></tr><tr><td>Tidak butuh untuk menangani banyak versi dari API kamu. Sebagai contoh: ketika kamu mengendalikan klien untuk sumber daya ini, kamu bisa meningkatkannya selaras dengan API.</td><td>Kamu perlu menangani banyak versi dari API kamu, sebagai contoh: ketika mengembangkan sebuah ekstensi untuk dibagikan kepada dunia.</td></tr></tbody></table><h3 id=fitur-lanjutan-dan-fleksibilitas>Fitur lanjutan dan fleksibilitas</h3><p><em>Aggregated API</em> menawarkan fitur API lebih lanjut dan kustomisasi dari fitur lain, sebagai contoh: lapisan penyimpanan.</p><table><thead><tr><th>Fitur</th><th>Deskripsi</th><th>CRD</th><th>Aggregated API</th></tr></thead><tbody><tr><td>Validation</td><td>Membantu pengguna-pengguna mencegah error dan memungkinkan kamu untuk mengembangkan API kamu secara independen dari klien-klien kamu. Fitur ini sangan berguna ketika ada banyak klien yang tidak semua bisa memperbaharui secara bersamaan pada waktu yang sama.</td><td>Ya. Sebagian besar validasi dapat dipesifikasikan di dalam CRD <a href=/docs/tasks/access-kubernetes-api/extend-api-custom-resource-definitions/#validation>OpenAPI v3.0 <em>validation</em></a>. Validasi bentuk lainnya didukung dengan penambahan sebuah <a href=/docs/reference/access-authn-authz/admission-controllers/#validatingadmissionwebhook-alpha-in-1-8-beta-in-1-9><em>Validating Webhook</em></a>.</td><td>Ya, cek validasi secara arbitrer</td></tr><tr><td>Defaulting</td><td>Lihat diatas</td><td>Ya, baik melalui <a href=/docs/tasks/access-kubernetes-api/extend-api-custom-resource-definitions/#defaulting>OpenAPI v3.0 <em>validation</em></a> <code>default</code> keyword (GA in 1.17), maupun melalui sebuah <a href=/docs/reference/access-authn-authz/admission-controllers/#mutatingadmissionwebhook><em>Mutating Webhook</em></a> (meskipun tidak akan dijalankan ketika membaca dari etcd untuk objek-objek lama)</td><td>Ya</td></tr><tr><td>Multi-versioning</td><td>Memungkinkan menyajikan objek yang sama lwat dua versi API. Bisa membantu memudahkan perubahan API seperti menamai ulang <em>field-field</em>. Tidak terlalu penting jika kamu mengendalikan versi-versi klien kamu.</td><td><a href=/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definition-versioning>Ya</a></td><td>Ya</td></tr><tr><td>Custom Storage</td><td>Jika kamu membutuhkan penyimpanan dengan sebuah mode performa (sebagai contoh, basis data <em>time-series</em> dibanding penyimpanan <em>key-value</em>) atau isolasi untuk keamanan (sebagau contoh, rahasia penyandian atau berkas berbeda)</td><td>Tidak</td><td>Ya</td></tr><tr><td>Custom Business Logic</td><td>Melakukan cek arbitrer atau tindakan-tindakan ketika membuat, membaca, atau memperbaharui sebuah objek</td><td>Ya, menggunakan <a href=/docs/reference/access-authn-authz/extensible-admission-controllers/#admission-webhooks><em>Webhooks</em></a>.</td><td>Ya</td></tr><tr><td>Scale Subresource</td><td>Memungkinkan sistem-sistem seperti HorizontalPodAutoscaler dan PodDisruptionBudget untuk berinteraksi dengan sumber daya baru</td><td><a href=/docs/tasks/access-kubernetes-api/extend-api-custom-resource-definitions/#scale-subresource>Ya</a></td><td>Ya</td></tr><tr><td>Status Subresource</td><td><ul><li>kontrol akses yang lebih baik: pengguna menulis bagian <em>spec</em>, <em>controller</em> menulis bagian status.</li><li>Memungkinkan pembuatan objek bertambah pada mutasi data <em>Custom Resource</em> (membutuhkan <em>spec</em> terpisah dan bagian status pada sumber daya)</li></ul></td><td><a href=/docs/tasks/access-kubernetes-api/extend-api-custom-resource-definitions/#status-subresource>Ya</a></td><td>Ya</td></tr><tr><td>Other Subresources</td><td>Menambahkan operasi selain CRUD, seperti "logs" atau "exec".</td><td>Tidak</td><td>Ya</td></tr><tr><td>strategic-merge-patch</td><td><em>Endpoint-endpoint</em> baru yang mendukung PATCH dengan <code>Content-Type: application/strategic-merge-patch+json</code>. Berguna untuk memperbaharui objek-objek yang mungkin dapat dimodifikasi baik secara lokal, dan maupun lewat server. Untuk informasi lebih lanjut, lihat <a href=/docs/tasks/run-application/update-api-object-kubectl-patch/>"Update API Objects in Place Using kubectl patch"</a></td><td>Tidak</td><td>Ya</td></tr><tr><td>Protocol Buffers</td><td>sumber daya baru mendukung klien-klien yang ingin menggunakan <em>Protocol Buffer</em></td><td>Tidak</td><td>Ya</td></tr><tr><td>OpenAPI Schema</td><td>Apakah ada sebuah skema OpenAPI (swagger) untuk tipe yang bisa secara dinamis diambil dari server? Apakah pengguna terlindungi dari kesalahan pengejaan nama-nama <em>field</em> dengan memastikan bahwa hanya <em>field</em> yang diperbolehkan yang boleh diisi? Apakah tipe-tipe diberlakukan (dengan kata lain, jangan menaruh sebuah <code>int</code> di dalam <em>field</em> <code>string</code>?)</td><td>Ya, berdasarkan pada skema <a href=/docs/tasks/access-kubernetes-api/extend-api-custom-resource-definitions/#validation>OpenAPI v3.0 validation</a> (GA pada 1.16)</td><td>Ya</td></tr></tbody></table><h3 id=fitur-umum>Fitur Umum</h3><p>Ketika kamu membuat sebuah <em>Custom Resource</em>, baik melalui sebuah CRD atau sebuah AA, kamu mendapat banyak fitur untuk API kamu, dibandingkan dengan mengimplementasikannya diluar platform Kubernetes.</p><table><thead><tr><th>Fitur</th><th>Apa yang dilakukannya</th></tr></thead><tbody><tr><td>CRUD</td><td><em>Endpoint-endpoint</em> baru yang mendukung operasi dasar melalui HTTP dan <code>kubectl</code></td></tr><tr><td>Watch</td><td><em>Endpoint-endpoint</em> baru yang mendukung operasi Kubernetes Watch melalui HTTP</td></tr><tr><td>Discovery</td><td>Klien seperti kubectl dan dasbor yang secara otomatis menawarkan operasi <em>list</em>, <em>display</em>, dan pembaharuan <em>field</em> pada sumber daya kamu.</td></tr><tr><td>json-patch</td><td><em>Endpoint-endpoint</em> baru yang mendukung PATCH dengan <code>Content-Type: application/json-patch+json</code></td></tr><tr><td>merge-patch</td><td><em>Endpoint-endpoint</em> baru yang mendukung PATCH dengan <code>Content-Type: application/merge-patch+json</code></td></tr><tr><td>HTTPS</td><td><em>Endpoint-endpoint</em> menggunakan HTTPS</td></tr><tr><td>Built-in Authentication</td><td>Akses ke ekstensi yang menggunakan <em>apiserver</em> inti (lapisan agregasi) untuk otentikasi</td></tr><tr><td>Built-in Authorization</td><td>Akses ke ekstensi dapat menggunakan ulang otorisasi yang digunakan oleh <em>apiserver</em> inti (mis. RBAC)</td></tr><tr><td>Finalizers</td><td>Penghapusan blok dari ekstensi sumber daya hingga pembersihan eksternal terjadi.</td></tr><tr><td>Admission Webhooks</td><td>Menentukan nilai default dan memvalidasi ekstensi sumber daya saat terjadi operasi <em>create/update/delete</em> apapun.</td></tr><tr><td>UI/CLI Display</td><td>Kubectl, dasbor dapat menampilkan ekstensi sumber daya</td></tr><tr><td>Unset vs Empty</td><td>Klien-klien dapat membedakan <em>field-field</em> yang tidak diisi dari <em>field-field</em> yang memiliki nilai nol.</td></tr><tr><td>Client Libraries Generation</td><td>Kubernetes menyediakan pustaka klien dasar, juga alat-alat untuk membuat pustaka klien dengan tipe spesifik.</td></tr><tr><td>Labels and annotations</td><td>Metadata umum lintas objek yang cara untuk memperbaharui sumber daya inti dan <em>Custom Resource</em>-nya diketahui oleh alat-alat.</td></tr></tbody></table><h2 id=persiapan-pemasangan-sebuah-custom-resource>Persiapan pemasangan sebuah <em>Custom Resource</em></h2><p>Ada beberapa poin yang harus diperhatikan sebelum menambahkan sebuah <em>Custom Resource</em> ke klaster kamu.</p><h3 id=kode-pihak-ketiga-dan-poin-kegagalan-baru>Kode pihak ketiga dan poin kegagalan baru</h3><p>Saat membuat sebuah CRD tidak secara otomatis menambahkan titik-titik kegagalan baru (sebagai contoh, dengan menyebabkan kode pihak ketiga untuk berjalan di API server kamu), paket-paket (sebagai contoh, <em>Chart</em>) atau bundel pemasangan lain seringkali sudah termasuk CRD dan juga sebagai Deployment dari kode pihak ketiga yang mengimplementasi logika bisnis untuk sebuah <em>Custom Resource</em>.</p><p>Memasang sebuah APIserver teragregasi selalu melibatkan tindakan menjalankan Deployment baru.</p><h3 id=penyimpanan>Penyimpanan</h3><p><em>Custom Resource</em> mengkonsumsi ruang penyimpanan dengan cara yang sama dengan ConfigMap. Membuat terlalu banyak sumber daya mungkin akan memenuhi ruang penyimpanan server API kamu.</p><p>Server <em>Aggregated API</em> dapat menggunakan penyimpanan yang sama dengan server API utama, dimana peringatan yang sama berlaku.</p><h3 id=authentication-authorization-and-auditing>Authentication, authorization, and auditing</h3><p>CRD selalu menggunakan otentikasi, otorisasi, dan audit pencatatan yang sama sebagai sumber daya bawaan dari server API kamu.</p><p>Jika kamu menggunakan RBAC untuk otorisasi, sebagian besar <em>role</em> RBAC tidak akan mengizinkan akses ke sumber daya baru (kecuali <em>role cluster-admin</em> atau <em>role</em> apapun yang dibuat menggunakan aturan <em>wildcard</em>). Kamu akan dibutuhkan untuk secara eksplisit mengizinkan akses ke sumber daya baru. CRD dan <em>Aggregated API</em> seringkali dibundel dengan definisi <em>role</em> baru untuk tipe yang mereka tambahkan.</p><p>API server teragregasi dapat atau tidak dapat menggunakan otentikasi, otorisasi, dan pengauditan yang sama dengan server API utama.</p><h2 id=mengakses-sebuah-custom-resource>Mengakses sebuah <em>Custom Resource</em></h2><p><a href=/docs/reference/using-api/client-libraries/>Pustaka klien</a> Kubernetes dapat digunakan untuk mengakses <em>Custom Resource</em>. Tidak semua pustaka klien mendukung <em>Custom Resource</em>. Pustaka klien go dan python melakukannya.</p><p>Ketika kamu menambahkan sebuah <em>Custom Resource</em>, kamu dapat mengaksesnya dengan menggunakan:</p><ul><li>kubectl</li><li>Klien dinamis kubernetes.</li><li>Sebuah klien REST yang kamu tulis</li><li>Sebuah klien yang dibuat menggunakan <a href=https://github.com/kubernetes/code-generator>Kubernetes client generation tools</a> (membuat satu adalah usaha lanjutan, tetapi beberapa proyek mungkin menyajikan sebuah klien bersama dengan CRD atau AA).</li></ul><h2 id=selanjutnya>Selanjutnya</h2><ul><li><p>Belajar bagaimana untuk <a href=/id/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>Memperluas Kubernetes API dengan lapisan agregasi</a>.</p></li><li><p>Belajar bagaimana untuk <a href=/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions/>Memperluas Kubernetes API dengan CustomResourceDefinition</a>.</p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-c8937cdc9df96f3328becf04f8211292>3.12.3 - Ekstensi Komputasi, Penyimpanan, dan Jaringan</h1></div><div class=td-content><h1 id=pg-1ac2260db9ecccbf0303a899bc27ce6d>3.12.3.1 - Plugin Jaringan</h1><p><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.25 [alpha]</code></div><div class="alert alert-danger warning callout" role=alert><strong>Peringatan:</strong> Fitur-fitur Alpha berubah dengan cepat.</div></p><p><em>Plugin</em> jaringan di Kubernetes hadir dalam beberapa varian:</p><ul><li><em>Plugin</em> CNI : mengikuti spesifikasi appc / CNI, yang dirancang untuk interoperabilitas.</li><li><em>Plugin</em> Kubenet : mengimplementasi <code>cbr0</code> sederhana menggunakan <em>plugin</em> <code>bridge</code> dan <code>host-local</code> CNI</li></ul><h2 id=instalasi>Instalasi</h2><p>Kubelet memiliki <em>plugin</em> jaringan bawaan tunggal, dan jaringan bawaan umum untuk seluruh kluster. <em>Plugin</em> ini memeriksa <em>plugin-plugin</em> ketika dijalankan, mengingat apa yang ditemukannya, dan mengeksekusi <em>plugin</em> yang dipilih pada waktu yang tepat dalam siklus pod (ini hanya berlaku untuk Docker, karena rkt mengelola <em>plugin</em> CNI sendiri). Ada dua parameter perintah Kubelet yang perlu diingat saat menggunakan <em>plugin</em>:</p><ul><li><code>cni-bin-dir</code>: Kubelet memeriksa direktori ini untuk <em>plugin-plugin</em> saat <em>startup</em></li><li><code>network-plugin</code>: <em>Plugin</em> jaringan untuk digunakan dari <code>cni-bin-dir</code>. Ini harus cocok dengan nama yang dilaporkan oleh <em>plugin</em> yang diperiksa dari direktori <em>plugin</em>. Untuk <em>plugin</em> CNI, ini (nilainya) hanyalah "cni".</li></ul><h2 id=persyaratan-plugin-jaringan>Persyaratan <em>Plugin</em> Jaringan</h2><p>Selain menyediakan <a href=https://github.com/kubernetes/kubernetes/tree/v1.25.0/pkg/kubelet/dockershim/network/plugins.go>antarmuka <code>NetworkPlugin</code></a> untuk mengonfigurasi dan membersihkan jaringan Pod, <em>plugin</em> ini mungkin juga memerlukan dukungan khusus untuk kube-proxy. Proksi <em>iptables</em> jelas tergantung pada <em>iptables</em>, dan <em>plugin</em> ini mungkin perlu memastikan bahwa lalu lintas kontainer tersedia untuk <em>iptables</em>. Misalnya, jika plugin menghubungkan kontainer ke <em>bridge</em> Linux, <em>plugin</em> harus mengatur nilai sysctl <code>net/bridge/bridge-nf-call-iptables</code> menjadi <code>1</code> untuk memastikan bahwa proksi <em>iptables</em> berfungsi dengan benar. Jika <em>plugin</em> ini tidak menggunakan <em>bridge</em> Linux (melainkan sesuatu seperti Open vSwitch atau mekanisme lainnya), <em>plugin</em> ini harus memastikan lalu lintas kontainer dialihkan secara tepat untuk proksi.</p><p>Secara bawaan jika tidak ada <em>plugin</em> jaringan Kubelet yang ditentukan, <em>plugin</em> <code>noop</code> digunakan, yang menetapkan <code>net/bridge/bridge-nf-call-iptables=1</code> untuk memastikan konfigurasi sederhana (seperti Docker dengan sebuah <em>bridge</em>) bekerja dengan benar dengan proksi <em>iptables</em>.</p><h3 id=cni>CNI</h3><p><em>Plugin</em> CNI dipilih dengan memberikan opsi <em>command-line</em> <code>--network-plugin=cni</code> pada Kubelet. Kubelet membaca berkas dari <code>--cni-conf-dir</code> (bawaan <code>/etc/cni/net.d</code>) dan menggunakan konfigurasi CNI dari berkas tersebut untuk mengatur setiap jaringan Pod. Berkas konfigurasi CNI harus sesuai dengan <a href=https://github.com/containernetworking/cni/blob/master/SPEC.md#network-configuration>spesifikasi CNI</a>, dan setiap <em>plugin</em> CNI yang diperlukan oleh konfigurasi harus ada di <code>--cni-bin-dir</code> (nilai bawaannya adalah <code>/opt/cni/bin</code>).</p><p>Jika ada beberapa berkas konfigurasi CNI dalam direktori, Kubelet menggunakan berkas yang pertama dalam urutan abjad.</p><p>Selain plugin CNI yang ditentukan oleh berkas konfigurasi, Kubernetes memerlukan <em>plugin</em> CNI standar <a href=https://github.com/containernetworking/plugins/blob/master/plugins/main/loopback/loopback.go><code>lo</code></a> <em>plugin</em> , minimal pada versi 0.2.0.</p><h4 id=dukungan-hostport>Dukungan hostPort</h4><p><em>Plugin</em> jaringan CNI mendukung <code>hostPort</code>. Kamu dapat menggunakan <em>plugin</em> <a href=https://github.com/containernetworking/plugins/tree/master/plugins/meta/portmap>portmap</a> resmi yang ditawarkan oleh tim <em>plugin</em> CNI atau menggunakan <em>plugin</em> kamu sendiri dengan fungsionalitas <em>portMapping</em>.</p><p>Jika kamu ingin mengaktifkan dukungan <code>hostPort</code>, kamu harus menentukan <code>portMappings capability</code> di <code>cni-conf-dir</code> kamu.
Contoh:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;k8s-pod-network&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;cniVersion&#34;</span>: <span style=color:#b44>&#34;0.4.0&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;plugins&#34;</span>: [
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;calico&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;log_level&#34;</span>: <span style=color:#b44>&#34;info&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;datastore_type&#34;</span>: <span style=color:#b44>&#34;kubernetes&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;nodename&#34;</span>: <span style=color:#b44>&#34;127.0.0.1&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;ipam&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;host-local&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;subnet&#34;</span>: <span style=color:#b44>&#34;usePodCidr&#34;</span>
</span></span><span style=display:flex><span>      },
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;policy&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;k8s&#34;</span>
</span></span><span style=display:flex><span>      },
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;kubernetes&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;kubeconfig&#34;</span>: <span style=color:#b44>&#34;/etc/cni/net.d/calico-kubeconfig&#34;</span>
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;portmap&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;capabilities&#34;</span>: {<span style=color:green;font-weight:700>&#34;portMappings&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>}
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  ]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=dukungan-pembentukan-lalu-lintas>Dukungan pembentukan lalu-lintas</h4><p><em>Plugin</em> jaringan CNI juga mendukung pembentukan lalu-lintas yang masuk dan keluar dari Pod. Kamu dapat menggunakan <em>plugin</em> resmi <a href=https://github.com/containernetworking/plugins/tree/master/plugins/meta/bandwidth><em>bandwidth</em></a> yang ditawarkan oleh tim <em>plugin</em> CNI atau menggunakan <em>plugin</em> kamu sendiri dengan fungsionalitas kontrol <em>bandwidth</em>.</p><p>Jika kamu ingin mengaktifkan pembentukan lalu-lintas, kamu harus menambahkan <em>plugin</em> <code>bandwidth</code> ke berkas konfigurasi CNI kamu (nilai bawaannya adalah <code>/etc/cni/ net.d</code>).</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;k8s-pod-network&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;cniVersion&#34;</span>: <span style=color:#b44>&#34;0.4.0&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;plugins&#34;</span>: [
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;calico&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;log_level&#34;</span>: <span style=color:#b44>&#34;info&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;datastore_type&#34;</span>: <span style=color:#b44>&#34;kubernetes&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;nodename&#34;</span>: <span style=color:#b44>&#34;127.0.0.1&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;ipam&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;host-local&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;subnet&#34;</span>: <span style=color:#b44>&#34;usePodCidr&#34;</span>
</span></span><span style=display:flex><span>      },
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;policy&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;k8s&#34;</span>
</span></span><span style=display:flex><span>      },
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;kubernetes&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;kubeconfig&#34;</span>: <span style=color:#b44>&#34;/etc/cni/net.d/calico-kubeconfig&#34;</span>
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;bandwidth&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;capabilities&#34;</span>: {<span style=color:green;font-weight:700>&#34;bandwidth&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>}
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  ]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Sekarang kamu dapat menambahkan anotasi <code>kubernetes.io/ingress-bandwidth</code> dan <code>kubernetes.io/egress-bandwidth</code> ke Pod kamu.
Contoh:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/ingress-bandwidth</span>:<span style=color:#bbb> </span>1M<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/egress-bandwidth</span>:<span style=color:#bbb> </span>1M<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=kubenet>Kubenet</h3><p>Kubenet adalah <em>plugin</em> jaringan yang sangat mendasar dan sederhana, hanya untuk Linux. Ia, tidak dengan sendirinya, mengimplementasi fitur-fitur yang lebih canggih seperti jaringan <em>cross-node</em> atau kebijakan jaringan. Ia biasanya digunakan bersamaan dengan penyedia layanan cloud yang menetapkan aturan <em>routing</em> untuk komunikasi antar Node, atau dalam lingkungan Node tunggal.</p><p>Kubenet membuat <em>bridge</em> Linux bernama <code>cbr0</code> dan membuat pasangan <em>veth</em> untuk setiap Pod dengan ujung <em>host</em> dari setiap pasangan yang terhubung ke <code>cbr0</code>. Ujung Pod dari pasangan diberi alamat IP yang dialokasikan dari rentang yang ditetapkan untuk Node baik melalui konfigurasi atau oleh controller-manager. <code>cbr0</code> memiliki MTU yang cocok dengan MTU terkecil dari antarmuka normal yang diaktifkan pada <em>host</em>.</p><p><em>Plugin</em> ini memerlukan beberapa hal:</p><ul><li><em>Plugin</em> CNI <code>bridge</code>, <code>lo</code> dan <code>host-local</code> standar diperlukan, minimal pada versi 0.2.0. Kubenet pertama-tama akan mencari mereka di <code>/opt/cni/bin</code>. Tentukan <code>cni-bin-dir</code> untuk menyediakan lokasi pencarian tambahan. Hasil pencarian pertama akan digunakan.</li><li>Kubelet harus dijalankan dengan argumen <code>--network-plugin=kubenet</code> untuk mengaktifkan <em>plugin</em></li><li>Kubelet juga harus dijalankan dengan argumen <code>--non-masquerade-cidr=&lt;clusterCidr></code> untuk memastikan lalu-lintas ke IP-IP di luar rentang ini akan menggunakan <em>masquerade</em> IP.</li><li>Node harus diberi subnet IP melalui perintah kubelet <code>--pod-cidr</code> atau perintah controller-manager <code>--allocate-node-cidrs=true --cluster-cidr=&lt;cidr></code>.</li></ul><h3 id=menyesuaikan-mtu-dengan-kubenet>Menyesuaikan MTU (dengan kubenet)</h3><p>MTU harus selalu dikonfigurasi dengan benar untuk mendapatkan kinerja jaringan terbaik. <em>Plugin</em> jaringan biasanya akan mencoba membuatkan MTU yang masuk akal, tetapi terkadang logika tidak akan menghasilkan MTU yang optimal. Misalnya, jika <em>bridge</em> Docker atau antarmuka lain memiliki MTU kecil, kubenet saat ini akan memilih MTU tersebut. Atau jika kamu menggunakan enkapsulasi IPSEC, MTU harus dikurangi, dan perhitungan ini di luar cakupan untuk sebagian besar <em>plugin</em> jaringan.</p><p>Jika diperlukan, kamu dapat menentukan MTU secara eksplisit dengan opsi <code>network-plugin-mtu</code> kubelet. Sebagai contoh, pada AWS <code>eth0</code> MTU biasanya adalah 9001, jadi kamu dapat menentukan <code>--network-plugin-mtu=9001</code>. Jika kamu menggunakan IPSEC, kamu dapat menguranginya untuk memungkinkan/mendukung <em>overhead</em> enkapsulasi pada IPSEC, contoh: <code>--network-plugin-mtu=8873</code>.</p><p>Opsi ini disediakan untuk <em>plugin</em> jaringan; Saat ini <strong>hanya kubenet yang mendukung <code>network-plugin-mtu</code></strong>.</p><h2 id=ringkasan-penggunaan>Ringkasan Penggunaan</h2><ul><li><code>--network-plugin=cni</code> menetapkan bahwa kita menggunakan <em>plugin</em> jaringan <code>cni</code> dengan <em>binary-binary plugin</em> CNI aktual yang terletak di <code>--cni-bin-dir</code> (nilai bawaannya <code>/opt/cni/bin</code>) dan konfigurasi <em>plugin</em> CNI yang terletak di <code>--cni-conf-dir</code> (nilai bawaannya <code>/etc/cni/net.d</code>).</li><li><code>--network-plugin=kubenet</code> menentukan bahwa kita menggunakan <em>plugin</em> jaringan <code>kubenet</code> dengan <code>bridge</code> CNI dan <em>plugin-plugin</em> <code>host-local</code> yang terletak di <code>/opt/cni/bin</code> atau <code>cni-bin-dir</code>.</li><li><code>--network-plugin-mtu=9001</code> menentukan MTU yang akan digunakan, saat ini hanya digunakan oleh <em>plugin</em> jaringan <code>kubenet</code>.</li></ul><h2 id=selanjutnya>Selanjutnya</h2></div><div class=td-content style=page-break-before:always><h1 id=pg-53e1ea8892ceca307ba19e8d6a7b8d32>3.12.3.2 - Plugin Perangkat</h1><div class=lead>Gunakan kerangka kerja <em>plugin</em> perangkat Kubernetes untuk mengimplementasikan plugin untuk GPU, NIC, FPGA, InfiniBand, dan sumber daya sejenis yang membutuhkan setelan spesifik vendor.</div><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.10 [beta]</code></div><p>Kubernetes menyediakan <a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/resource-management/device-plugin.md>kerangka kerja <em>plugin</em> perangkat</a>
sehingga kamu dapat memakainya untuk memperlihatkan sumber daya perangkat keras sistem ke dalam <a class=glossary-tooltip title='Agen yang dijalankan pada setiap node di klaster yang bertugas untuk memastikan kontainer dijalankan di dalam Pod.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=Kubelet>Kubelet</a>.</p><p>Daripada menkustomisasi kode Kubernetes itu sendiri, vendor dapat mengimplementasikan
<em>plugin</em> perangkat yang di-<em>deploy</em> secara manual atau sebagai <a class=glossary-tooltip title='Memastikan salinan Pod dijalankan pada sekumpulan Node dalam satu klaster.' data-toggle=tooltip data-placement=top href=/id/docs/concepts/workloads/controllers/daemonset target=_blank aria-label=DaemonSet>DaemonSet</a>.
Perangkat yang dituju termasuk GPU, NIC berkinerja tinggi, FPGA, adaptor InfiniBand,
dan sumber daya komputasi sejenis lainnya yang perlu inisialisasi dan setelan spesifik vendor.</p><h2 id=pendaftaran-plugin-perangkat>Pendaftaran <em>plugin</em> perangkat</h2><p>Kubelet mengekspor servis gRPC <code>Registration</code>:</p><pre tabindex=0><code class=language-gRPC data-lang=gRPC>service Registration {
	rpc Register(RegisterRequest) returns (Empty) {}
}
</code></pre><p>Plugin perangkat bisa mendaftarkan dirinya sendiri dengan kubelet melalui servis gRPC.
Dalam pendaftaran, <em>plugin</em> perangkat perlu mengirim:</p><ul><li>Nama Unix socket-nya.</li><li>Versi API Plugin Perangkat yang dipakai.</li><li><code>ResourceName</code> yang ingin ditunjukkan. <code>ResourceName</code> ini harus mengikuti
<a href=/id/docs/concepts/configuration/manage-compute-resources-container/#extended-resources>skema penamaan sumber daya ekstensi</a>
sebagai <code>vendor-domain/tipe-sumber-daya</code>.
(Contohnya, NVIDIA GPU akan dinamai <code>nvidia.com/gpu</code>.)</li></ul><p>Setelah registrasi sukses, <em>plugin</em> perangkat mengirim daftar perangkat yang diatur
ke kubelet, lalu kubelet kemudian bertanggung jawab untuk mengumumkan sumber daya tersebut
ke peladen API sebagai bagian pembaruan status node kubelet.
Contohnya, setelah <em>plugin</em> perangkat mendaftarkan <code>hardware-vendor.example/foo</code> dengan kubelet
dan melaporkan kedua perangkat dalam node dalam kondisi sehat, status node diperbarui
untuk menunjukkan bahwa node punya 2 perangkat “Foo” terpasang dan tersedia.</p><p>Kemudian, pengguna dapat meminta perangkat dalam spesifikasi
<a href=/docs/reference/generated/kubernetes-api/v1.25/#container-v1-core>Kontainer</a>
seperti meminta tipe sumber daya lain, dengan batasan berikut:</p><ul><li>Sumber daya ekstensi hanya didukung sebagai sumber daya integer dan tidak bisa <em>overcommitted</em>.</li><li>Perangkat tidak bisa dibagikan antar Kontainer.</li></ul><p>Semisal klaster Kubernetes menjalankan <em>plugin</em> perangkat yang menunjukkan sumber daya <code>hardware-vendor.example/foo</code>
pada node tertentu. Berikut contoh Pod yang meminta sumber daya itu untuk menjalankan demo beban kerja:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>demo-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>demo-container-1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/pause:2.0<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>hardware-vendor.example/foo</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># Pod ini perlu 2 perangkat perangkat-vendor.example/foo</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># dan hanya dapat menjadwalkan ke Node yang bisa memenuhi</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># kebutuhannya.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># Jika Node punya lebih dari 2 perangkat tersedia,</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># maka kelebihan akan dapat digunakan Pod lainnya.</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=implementasi-plugin-perangkat>Implementasi <em>plugin</em> perangkat</h2><p>Alur kerja umum dari <em>plugin</em> perangkat adalah sebagai berikut:</p><ul><li><p>Inisiasi. Selama fase ini, <em>plugin</em> perangkat melakukan inisiasi spesifik vendor
dan pengaturan untuk memastikan perangkat pada status siap.</p></li><li><p>Plugin memulai servis gRPC, dengan Unix socket pada lokasi
<code>/var/lib/kubelet/device-plugins/</code>, yang mengimplementasi antarmuka berikut:</p><pre tabindex=0><code class=language-gRPC data-lang=gRPC>service DevicePlugin {
      // ListAndWatch mengembalikan aliran dari List of Devices
      // Kapanpun Device menyatakan perubahan atau kehilangan Device, ListAndWatch
      // mengembalikan daftar baru
      rpc ListAndWatch(Empty) returns (stream ListAndWatchResponse) {}

      // Allocate dipanggil saat pembuatan kontainer sehingga Device
      // Plugin dapat menjalankan operasi spesifik perangkat dan menyuruh Kubelet
      // dari operasi untuk membuat Device tersedia di kontainer
      rpc Allocate(AllocateRequest) returns (AllocateResponse) {}
}
</code></pre></li><li><p>Plugin mendaftarkan dirinya sendiri dengan kubelet melalui Unix socket pada lokasi host
<code>/var/lib/kubelet/device-plugins/kubelet.sock</code>.</p></li><li><p>Seteleh sukses mendaftarkan dirinya sendiri, <em>plugin</em> perangkat berjalan dalam mode peladen, dan selama itu
dia tetap mengawasi kesehatan perangkat dan melaporkan balik ke kubelet terhadap perubahan status perangkat.
Dia juga bertanggung jawab untuk melayani <em>request</em> gRPC <code>Allocate</code>. Selama <code>Allocate</code>, <em>plugin</em> perangkat dapat
membuat persiapan spesifik-perangkat; contohnya, pembersihan GPU atau inisiasi QRNG.
Jika operasi berhasil, <em>plugin</em> perangkat mengembalikan <code>AllocateResponse</code> yang memuat konfigurasi
runtime kontainer untuk mengakses perangkat teralokasi. Kubelet memberikan informasi ini ke runtime kontainer.</p></li></ul><h3 id=menangani-kubelet-yang-restart>Menangani kubelet yang <em>restart</em></h3><p>Plugin perangkat diharapkan dapat mendeteksi kubelet yang <em>restart</em> dan mendaftarkan dirinya sendiri kembali dengan
<em>instance</em> kubelet baru. Pada implementasi sekarang, sebuah <em>instance</em> kubelet baru akan menghapus semua socket Unix yang ada
di dalam <code>/var/lib/kubelet/device-plugins</code> ketika dijalankan. Plugin perangkat dapat mengawasi penghapusan
socket Unix miliknya dan mendaftarkan dirinya sendiri kembali ketika hal tersebut terjadi.</p><h2 id=deployment-plugin-perangkat>Deployment <em>plugin</em> perangkat</h2><p>Kamu dapat melakukan <em>deploy</em> sebuah <em>plugin</em> perangkat sebagai DaemonSet, sebagai sebuah paket untuk sistem operasi node-mu,
atau secara manual.</p><p>Direktori <em>canonical</em> <code>/var/lib/kubelet/device-plugins</code> membutuhkan akses berprivilese,
sehingga <em>plugin</em> perangkat harus berjalan dalam konteks keamanan dengan privilese.
Jika kamu melakukan <em>deploy</em> <em>plugin</em> perangkat sebagai DaemonSet, <code>/var/lib/kubelet/device-plugins</code>
harus dimuat sebagai <a class=glossary-tooltip title='Sebuah direktori yang mengandung data, dapat diakses o;eh kontainer-kontainer di dalam pod.' data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/ target=_blank aria-label=Volume>Volume</a> pada
<a href=/docs/reference/generated/kubernetes-api/v1.25/#podspec-v1-core>PodSpec</a>
plugin.</p><p>Jika kamu memilih pendekatan DaemonSet, kamu dapat bergantung pada Kubernetes untuk meletakkan Pod
<em>plugin</em> perangkat ke Node, memulai-ulang Pod daemon setelah kegagalan, dan membantu otomasi pembaruan.</p><h2 id=kecocokan-api>Kecocokan API</h2><p>Dukungan pada <em>plugin</em> perangkat Kubernetes sedang dalam beta. API dapat berubah hingga stabil,
dalam cara yang tidak kompatibel. Sebagai proyek, Kubernetes merekomendasikan para developer <em>plugin</em> perangkat:</p><ul><li>Mengamati perubahan pada rilis mendatang.</li><li>Mendukung versi API <em>plugin</em> perangkat berbeda untuk kompatibilitas-maju/mundur.</li></ul><p>Jika kamu menyalakan fitur DevicePlugins dan menjalankan <em>plugin</em> perangkat pada node yang perlu diperbarui
ke rilis Kubernetes dengan versi API plugin yang lebih baru, perbarui <em>plugin</em> perangkatmu
agar mendukung kedua versi sebelum membarui para node ini. Memilih pendekatan demikian akan
menjamin fungsi berkelanjutan dari alokasi perangkat selama pembaruan.</p><h2 id=mengawasi-sumber-daya-plugin-perangkat>Mengawasi Sumber Daya Plugin Perangkat</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.15 [beta]</code></div><p>Dalam rangka mengawasi sumber daya yang disediakan <em>plugin</em> perangkat, agen monitoring perlu bisa
menemukan kumpulan perangkat yang terpakai dalam node dan mengambil metadata untuk mendeskripsikan
pada kontainer mana metrik harus diasosiasikan. Metrik <a href=https://prometheus.io/>prometheus</a>
diekspos oleh agen pengawas perangkat harus mengikuti
<a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-instrumentation/instrumentation.md>Petunjuk Instrumentasi Kubernetes</a>,
mengidentifikasi kontainer dengan label prometheus <code>pod</code>, <code>namespace</code>, dan <code>container</code>.</p><p>Kubelet menyediakan servis gRPC untuk menyalakan pencarian perangkat yang terpakai, dan untuk menyediakan metadata
untuk perangkat berikut:</p><pre tabindex=0><code class=language-gRPC data-lang=gRPC>// PodResourcesLister adalah layanan yang disediakan kubelet untuk menyediakan informasi tentang
// sumber daya node yang dikonsumsi Pod dan kontainer pada node
service PodResourcesLister {
    rpc List(ListPodResourcesRequest) returns (ListPodResourcesResponse) {}
}
</code></pre><p>Servis gRPC dilayani lewat socket unix pada <code>/var/lib/kubelet/pod-resources/kubelet.sock</code>.
Agen pengawas untuk sumber daya <em>plugin</em> perangkat dapat di-<em>deploy</em> sebagai daemon, atau sebagai DaemonSet.
Direktori <em>canonical</em> <code>/var/lib/kubelet/pod-resources</code> perlu akses berprivilese,
sehingga agen pengawas harus berjalan dalam konteks keamanan dengan privilese. Jika agen pengawas perangkat berjalan
sebagai DaemonSet, <code>/var/lib/kubelet/pod-resources</code> harus dimuat sebagai
<a class=glossary-tooltip title='Sebuah direktori yang mengandung data, dapat diakses o;eh kontainer-kontainer di dalam pod.' data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/ target=_blank aria-label=Volume>Volume</a> pada plugin
<a href=/docs/reference/generated/kubernetes-api/v1.25/#podspec-v1-core>PodSpec</a>.</p><p>Dukungan untuk "servis PodResources" butuh <a href=/docs/reference/command-line-tools-reference/feature-gates/>gerbang fitur</a>
<code>KubeletPodResources</code> untuk dinyalakan. Mulai dari Kubernetes 1.15 nilai bawaannya telah dinyalakan.</p><h2 id=integrasi-plugin-perangkat-dengan-topology-manager>Integrasi Plugin Perangkat dengan Topology Manager</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.17 [alpha]</code></div><p>Topology Manager adalah komponen Kubelet yang membolehkan sumber daya untuk dikoordinasi secara selaras dengan Topology. Untuk melakukannya, API Plugin Perangkat telah dikembangkan untuk memasukkan struct <code>TopologyInfo</code>.</p><pre tabindex=0><code class=language-gRPC data-lang=gRPC>message TopologyInfo {
	repeated NUMANode nodes = 1;
}

message NUMANode {
    int64 ID = 1;
}
</code></pre><p>Plugin Perangkat yang ingin memanfaatkan Topology Manager dapat mengembalikan beberapa <em>struct</em> TopologyInfo sebagai bagian dari pendaftaran perangkat, bersama dengan ID perangkat dan status kesehatan perangkat. Manajer perangkat akan memakai informasi ini untuk konsultasi dengan Topology Manager dan membuat keputusan alokasi sumber daya.</p><p><code>TopologyInfo</code> mendukung kolom <code>nodes</code> yang bisa <code>nil</code> (sebagai bawaan) atau daftar node NUMA. Ini membuat Plugin Perangkat mengumumkan apa saja yang bisa meliputi node NUMA.</p><p>Contoh <em>struct</em> <code>TopologyInfo</code> untuk perangkat yang dipopulate oleh Plugin Perangkat:</p><pre tabindex=0><code>pluginapi.Device{ID: &#34;25102017&#34;, Health: pluginapi.Healthy, Topology:&amp;pluginapi.TopologyInfo{Nodes: []*pluginapi.NUMANode{&amp;pluginapi.NUMANode{ID: 0,},}}}
</code></pre><h2 id=contoh>Contoh <em>plugin</em> perangkat</h2><p>Berikut beberapa contoh implementasi <em>plugin</em> perangkat:</p><ul><li><a href=https://github.com/RadeonOpenCompute/k8s-device-plugin>Plugin perangkat AMD GPU</a></li><li><a href=https://github.com/intel/intel-device-plugins-for-kubernetes>Plugin perangkat Intel</a> untuk perangkat GPU, FPGA, dan QuickAssist Intel</li><li><a href=https://github.com/kubevirt/kubernetes-device-plugins>Plugin perangkat KubeVirt</a> untuk virtualisasi hardware-assisted</li><li><a href=https://github.com/NVIDIA/k8s-device-plugin>Plugin perangkat NVIDIA GPU</a><ul><li>Perlu <a href=https://github.com/NVIDIA/nvidia-docker>nvidia-docker</a> versi 2.0 yang memungkinkan untuk menjalakan kontainer Docker yang memuat GPU.</li></ul></li><li><a href=https://github.com/GoogleCloudPlatform/container-engine-accelerators/tree/master/cmd/nvidia_gpu>Plugin perangkat NVIDIA GPU untuk Container-Optimized OS</a></li><li><a href=https://github.com/hustcat/k8s-rdma-device-plugin>Plugin perangkat RDMA</a></li><li><a href=https://github.com/vikaschoudhary16/sfc-device-plugin>Plugin perangkat Solarflare</a></li><li><a href=https://github.com/intel/sriov-network-device-plugin>Plugin perangkat SR-IOV Network</a></li><li><a href=https://github.com/Xilinx/FPGA_as_a_Service/tree/master/k8s-fpga-device-plugin>Plugin perangkat Xilinx FPGA</a> untuk perangkat Xilinx FPGA</li></ul><h2 id=selanjutnya>Selanjutnya</h2><ul><li>Pelajari bagaimana <a href=/docs/tasks/manage-gpus/scheduling-gpus/>menjadwalkan sumber daya GPU</a> dengan <em>plugin</em> perangkat</li><li>Pelajari bagaimana <a href=/docs/tasks/administer-cluster/extended-resource-node/>mengumumkan sumber daya ekstensi</a> pada node</li><li>Baca tentang penggunaan <a href=https://kubernetes.io/blog/2019/04/24/hardware-accelerated-ssl/tls-termination-in-ingress-controllers-using-kubernetes-device-plugins-and-runtimeclass/>akselerasi perangkat keras untuk ingress TLS</a> dengan Kubernetes</li><li>Pelajari tentang [Topology Manager] (/docs/tasks/adminster-cluster/topology-manager/)</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-3131452556176159fb269593c1a52012>3.12.4 - Pola Operator</h1><p>Operator adalah ekstensi perangkat lunak untuk Kubernetes yang memanfaatkan
<a href=/id/docs/concepts/extend-kubernetes/api-extension/custom-resources/><em>custom resource</em></a>
untuk mengelola aplikasi dan komponen-komponennya. Operator mengikuti prinsip
Kubernetes, khususnya dalam hal <a href=/docs/concepts/#kubernetes-control-plane><em>control loop</em></a>.</p><h2 id=motivasi>Motivasi</h2><p>Pola dari Operator bertujuan untuk menangkap tujuan utama dari Operator manusia
yang mengelola layanan atau suatu kumpulan layanan. Operator manusia yang
menjaga spesifik aplikasi dan layanan memiliki pengetahuan yang mendalam tentang
bagaimana sistem harus berperilaku, bagaimana cara menyebarkannya, dan
bagaimana bereaksi jika ada masalah.</p><p>Orang-orang yang menjalankan <em>workload-workload</em> di Kubernetes pada umumnya suka
menggunakan otomatisasi untuk menangani tugas-tugas yang berulang. Pola
Operator menangkap bagaimana kamu dapat menulis kode untuk mengotomatiskan
sebuah tugas di luar batas apa yang dapat disediakan oleh Kubernetes itu
sendiri.</p><h2 id=operator-di-kubernetes>Operator di Kubernetes</h2><p>Kubernetes didesain untuk otomasi. Secara di luar nalar, kamu mendapatkan banyak
otomatisasi bawaan dari komponen inti Kubernetes. Kamu dapat menggunakan
Kubernetes untuk mengotomasikan penyebaran dan menjalankan <em>workload-workload</em>, <em>dan</em>
kamu juga dapat mengotomasikan cara Kubernetes melakukan pekerjaan itu.</p><p>Konsep dari <a class=glossary-tooltip title='Kontrol tertutup yang mengawasi kondisi bersama dari klaster melalui apiserver dan membuat perubahan yang mencoba untuk membawa kondisi saat ini ke kondisi yang diinginkan.' data-toggle=tooltip data-placement=top href=/id/docs/concepts/architecture/controller/ target=_blank aria-label=controller>controller</a>
Kubernetes memungkinkan kamu memperluas perilaku klaster tanpa harus mengubah
kode dari Kubernetes itu sendiri.</p><p>Operator adalah klien API dari Kubernetes yang bertindak sebagai <em>controller</em>
untuk <a href=/docs/concepts/api-extension/custom-resources/><em>custome resource</em></a>.</p><h2 id=contoh>Contoh Operator</h2><p>Beberapa hal yang dapat kamu gunakan untuk mengotomasi Operator meliputi:</p><ul><li>menyebarkan aplikasi sesuai dengan permintaan</li><li>mengambil dan memulihkan backup status dari sebuah aplikasi</li><li>menangani pembaruan kode aplikasi termasuk dengan perubahan terkait seperti
skema basis data atau pengaturan konfigurasi tambahan</li><li>mempublikasikan layanan ke sebuah aplikasi yang tidak mendukung API Kubernetes
untuk menemukan mereka</li><li>mensimulasikan kegagalan pada seluruh atau sebagian klaster kamu untuk
menguji resiliensinya</li><li>memilih suatu pemimpin untuk aplikasi yang terdistribusi tanpa adanya proses
pemilihan anggota secara internal</li></ul><p>Seperti apa sebuah Operator dalam kasus yang lebih terperinci? Berikut ini
adalah contoh yang lebih detail:</p><ol><li>Sebuah <em>custom resource</em> bernama SampleDB, bisa kamu konfigurasi ke
dalam klaster.</li><li>Sebuah Deployment memastikan sebuah Pod berjalan dimana didalamnya
berisi bagian <em>controller</em> dari Operator.</li><li>Kontainer Image dari kode Operator.</li><li>Kode <em>controller</em> yang menanyakan pada <em>control-plane</em> untuk mencari tahu
apakah itu sumber daya SampleDB telah dikonfigurasi.</li><li>Inti dari Operator adalah kode untuk memberi tahu server API bagaimana
membuatnya kondisi sebenarnya sesuai dengan sumber daya yang dikonfigurasi.
   * Jika kamu menambahkan SampleDB baru, Operator menyiapkan
PersistentVolumeClaims untuk menyediakan penyimpanan basis data yang
tahan lama, sebuah StatefulSet untuk menjalankan SampleDB dan pekerjaan
untuk menangani konfigurasi awal.
   * Jika kamu menghapusnya, Operator mengambil <em>snapshot</em>, lalu memastikannya
     StatefulSet dan Volume juga dihapus.</li><li>Operator juga mengelola backup basis data yang reguler. Untuk setiap resource
SampleDB, Operator menentukan kapan membuat Pod yang dapat terhubung
   ke database dan mengambil backup. Pod-Pod ini akan bergantung pada ConfigMap
   dan / atau sebuah Secret yang memiliki basis data koneksi dan kredensial.</li><li>Karena Operator bertujuan untuk menyediakan otomatisasi yang kuat untuk
resource yang dikelola, maka akan ada kode pendukung tambahan. Sebagai contoh
, kode memeriksa untuk melihat apakah basis data menjalankan versi yang
lama dan, jika demikian, kode membuat objek Job yang melakukan pembaruan untuk
kamu.</li></ol><h2 id=menyebarkan-operator>Menyebarkan Operator</h2><p>Cara paling umum untuk menyebarkan Operator adalah dengan menambahkan
CustomResourceDefinition dan <em>controller</em> yang berkaitan ke dalam klaster kamu.
<em>Controller</em> biasanya akan berjalan di luar
<a class=glossary-tooltip title='Merupakan lapisan orkestrasi Container yang mengekspos API dan antarmuka untuk mendefinisikan, menggelar, dan mengelola siklus hidup suatu Container.' data-toggle=tooltip data-placement=top href='/id/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='control plane'>control plane</a>,
seperti kamu akan menjalankan aplikasi apa pun yang dikontainerisasi.
Misalnya, kamu bisa menjalankan <em>controller</em> di klaster kamu sebagai sebuah
Deployment.</p><h2 id=menggunakan-operator-menggunakan-operator>Menggunakan Operator {#menggunakan operator}</h2><p>Setelah Operator disebarkan, kamu akan menggunakannya dengan menambahkan,
memodifikasi, atau menghapus jenis sumber daya yang digunakan Operator tersebut.
Melanjutkan contoh diatas, kamu akan menyiapkan Deployment untuk Operator itu
sendiri, dan kemudian:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get SampleDB                   <span style=color:#080;font-style:italic># find configured databases</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl edit SampleDB/example-database <span style=color:#080;font-style:italic># manually change some settings</span>
</span></span></code></pre></div><p>…dan itu saja! Operator akan berhati-hati dalam menerapkan perubahan
serta menjaga layanan yang ada dalam kondisi yang baik.</p><h2 id=menulis-operator>Menulis Operator Kamu Sendiri</h2><p>Jika tidak ada Operator dalam ekosistem yang mengimplementasikan perilaku kamu
inginkan, kamu dapat kode kamu sendiri. Dalam <a href=#selanjutnya>Selanjutnya</a> kamu
akan menemukan beberapa tautan ke <em>library</em> dan perangkat yang dapat kamu gunakan
untuk menulis Operator <em>Cloud Native</em> kamu sendiri.</p><p>Kamu juga dapat mengimplementasikan Operator (yaitu, <em>Controller</em>) dengan
menggunakan bahasa / <em>runtime</em> yang dapat bertindak sebagai
<a href=/docs/reference/using-api/client-libraries/>klien dari API Kubernetes</a>.</p><h2 id=selanjutnya>Selanjutnya</h2><ul><li>Memahami lebih lanjut tentang <a href=/id/docs/concepts/extend-kubernetes/api-extension/custom-resources/><em>custome resources</em></a></li><li>Temukan "ready-made" <em>operators</em> dalam <a href=https://operatorhub.io/>OperatorHub.io</a>
untuk memenuhi use case kamu</li><li>Menggunakan perangkat yang ada untuk menulis Operator kamu sendiri, misalnya:<ul><li>menggunakan <a href=https://kudo.dev/>KUDO</a> (Kubernetes Universal Declarative Operator)</li><li>menggunakan <a href=https://book.kubebuilder.io/>kubebuilder</a></li><li>menggunakan <a href=https://metacontroller.github.io/metacontroller/intro.html>Metacontroller</a> bersama dengan
<code>WebHooks</code> yang kamu implementasikan sendiri</li><li>menggunakan the <a href=https://github.com/operator-framework/getting-started>Operator <em>Framework</em></a></li></ul></li><li><a href=https://operatorhub.io/>Terbitkan</a> Operator kamu agar dapat digunakan oleh
orang lain</li><li>Baca <a href=https://coreos.com/blog/introducing-operators.html>artikel asli dari CoreOS</a>
yang memperkenalkan pola Operator</li><li>Baca sebuah <a href=https://cloud.google.com/blog/products/containers-kubernetes/best-practices-for-building-kubernetes-operators-and-stateful-apps>artikel</a>
dari Google Cloud soal panduan terbaik membangun Operator</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-b26fcf43d01abc16c8110766026dafed>3.12.5 - Service Catalog</h1><p><p>Service Catalog adalah sebuah ekstensi API yang memungkinkan aplikasi berjalan pada klaster Kubernetes untuk
mempermudah penggunaan perangkat lunak yang dikelola eksternal, seperti servis penyimpanan
data yang ditawarkan oleh penyedia layanan komputasi awan.</p></p><p>Ini menyediakan cara untuk membuat daftar, melakukan pembuatan, dan mengikat dengan
<a class=glossary-tooltip title='Sebuah perangkat lunak yang dikelola oleh penyedia layanan pihak ketiga.' data-toggle=tooltip data-placement=top href='/id/docs/reference/glossary/?all=true#term-managed-service' target=_blank aria-label='servis terkelola'>servis terkelola</a> eksternal
dari <a class=glossary-tooltip title='Sebuah endpoint untuk kumpulan servis terlola yang ditawarkan dan dikelola oleh penyedia layanan pihak ketiga.' data-toggle=tooltip data-placement=top href='/id/docs/reference/glossary/?all=true#term-service-broker' target=_blank aria-label='makelar servis'>makelar servis</a> tanpa membutuhkan
pengetahuan mendalam mengenai cara servis tersebut dibuat dan diatur.</p><p>Sebuah makelar servis (<em>service broker</em>), seperti yang didefinisikan oleh [spesifikasi API makelar servis terbuka]
(<a href=https://github.com/openservicebrokerapi/servicebroker/blob/v2.13/spec.md)>https://github.com/openservicebrokerapi/servicebroker/blob/v2.13/spec.md)</a>, adalah sebuah
<em>endpoint</em> untuk beberapa layanan terkelola yang ditawarkan dan dikelola oleh pihak ketiga,
yang bisa jadi sebuah penyedia layanan <em>cloud</em> seperti AWS, GCP atau Azure.</p><p>Beberapa contoh dari servis terkelola adalah Microsoft Azure Cloud Queue, Amazon Simple Queue Service, dan
Google Cloud Pub/Sub, selain itu, bisa juga penawaran perangkat lunak apa pun yang dapat digunakan oleh suatu aplikasi.</p><p>Dengan menggunakan Service Catalog,
seorang <a class=glossary-tooltip title='Seseorang yang mengonfigurasi, mengontrol, dan memonitor klaster.' data-toggle=tooltip data-placement=top href='/id/docs/reference/glossary/?all=true#term-cluster-operator' target=_blank aria-label='pengelola klaster'>pengelola klaster</a> dapat melihat
daftar servis terkelola yang ditawarkan oleh makelar servis, melakukan pembuatan terhadap
sebuah servis terkelola, dan menghubungkan (<em>bind</em>) untuk membuat tersedia terhadap aplikasi pada suatu klaster Kubernetes.</p><h2 id=contoh-kasus-penggunaan>Contoh kasus penggunaan</h2><p>Seorang <a class=glossary-tooltip title='A person who writes an application that runs in a Kubernetes cluster.' data-toggle=tooltip data-placement=top href='/id/docs/reference/glossary/?all=true#term-application-developer' target=_blank aria-label='pengembang aplikasi'>pengembang aplikasi</a> ingin menggunakan
sistem antrian pesan sebagai bagian dari aplikasinya yang berjalan dalam klaster Kubernetes.
Namun, mereka tidak ingin berurusan dengan kesulitan dalam pengaturan, misalnya menjaga servis tetap
berjalan dan mengatur itu oleh mereka sendiri. Beruntungnya, sudah tersedia penyedia layanan <em>cloud</em>
yang menawarkan sistem antrian pesan sebagai servis terkelola melalui makelar servisnya.</p><p>Seorang pengelola klaster dapat membuat Service Catalog dan menggunakannya untuk berkomunikasi dengan
makelar servis milik penyedia layanan <em>cloud</em> untuk menyediakan sebuah servis antrian pesan dan membuat
servis ini tersedia kepada aplikasi dalam klaster Kubernetes.
Seorang pengembang aplikasi tidak perlu memikirkan detail implementasi atau mengatur sistem antrian pesan tersebut.
Aplikasi dapat langsung menggunakan servis tersebut.</p><h2 id=arsitektur>Arsitektur</h2><p>Service Catalog menggunakan <a href=https://github.com/openservicebrokerapi/servicebroker>API dari Open Service Broker</a>
untuk berkomunikasi dengan makelar servis, bertindak sebagai perantara untuk API Server Kubernetes untuk
merundingkan penyediaan awal dan mengambil kredensial untuk aplikasi bisa menggunakan servis terkelola tersebut.</p><p>Ini terimplementasi sebagai ekstensi API Server dan pengontrol, menggunakan etcd sebagai media penyimpanan.
Ini juga menggunakan <a href=/id/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>lapisan agregasi</a>
yang tersedia pada Kubernetes versi 1.7+ untuk menampilkan API-nya.</p><br><p><img src=/images/docs/service-catalog-architecture.svg alt="Arsitektur Service Catalog"></p><h3 id=sumber-daya-api>Sumber Daya API</h3><p>Service Catalog memasang API <code>servicecatalog.k8s.io</code> dan menyediakan beberapa sumber daya Kubernetes berikut:</p><ul><li><code>ClusterServiceBroker</code>: Sebuah representasi dalam klaster untuk makelar servis, membungkus detail koneksi peladen.
Ini dibuat dan dikelola oleh pengelola klaster yang berharap untuk menggunakan makelar peladen untuk membuat
tipe baru dari sebuah servis terkelola yang tersedia dalam klaster mereka.</li><li><code>ClusterServiceClass</code>: Sebuah servis terkelola ditawarkan oleh beberapa makelar servis.
Ketika sumber daya <code>ClusterServiceBroker</code> ditambahkan ke dalam klaster, kontroler Service Catalog terhubung
ke makelar servis untuk mendapatkan daftar servis terkelola yang tersedia. Kemudian membuat sumber daya
<code>ClusterServiceClass</code> sesuai dengan masing-masing servis terkelola.</li><li><code>ClusterServicePlan</code>: Sebuah penawaran khusus dari servis terkelola. Sebagai contoh, sebuah servis terkelola
bisa memiliki model harga, yaitu gratis atau berbayar, atau ini mungkin juga memiliki konfigurasi pilihan berbeda,
misal menggunakan penyimpanan SSD atau memiliki sumber daya lebih. Mirip dengan <code>ClusterServiceClass</code>, ketika
<code>ClusterServiceBroker</code> baru ditambahkan ke dalam klaster, Service Catalog akan membuat sumber daya
<code>ClusterServicePlan</code> sesuai dengan <em>Service Plan</em> yang tersedia untuk masing-masing servis terkelola.</li><li><code>ServiceInstance</code>: Sebuah objek dari <code>ClusterServiceClass</code>.
Ini dibuat oleh operator klaster untuk membuat bentuk spesifik dari servis terkelola yang tersedia untuk
digunakan oleh salah satu atau lebih aplikasi dalam klaster.
Ketika sumber daya <code>ServiceInstance</code> baru terbuat, pengontrol Service Catalog terhubung ke makelar servis yang
sesuai dan menginstruksikan untuk menyediakan sebuah objek servis.</li><li><code>ServiceBinding</code>: Kredensial untuk mengakses suatu <code>ServiceInstance</code>.
Ini dibuat oleh operator klaster yang ingin aplikasinya untuk menggunakan sebuah <code>ServiceInstance</code>.
Saat dibuat, kontroler Service Catalog membuat sebuah <code>Secret</code> Kubernetes yang berisikan detail koneksi
dan kredensial untuk objek servis, yang bisa dimuat ke dalam Pod.</li></ul><h3 id=autentikasi>Autentikasi</h3><p>Service Catalog mendukung beberapa metode autentikasi, yaitu:</p><ul><li>Basic (nama pengguna/kata sandi)</li><li><a href=https://tools.ietf.org/html/rfc6750>OAuth 2.0 Bearer Token</a></li></ul><h2 id=penggunaan>Penggunaan</h2><p>Seorang operator klaster dapat menggunakan API sumber daya Service Catalog untuk membuat servis terkelola
dan membuatnya tersedia dalam klaster Kubernetes. Langkah yang dilalui adalah sebagai berikut:</p><ol><li>Membuat daftar servis terkelola dan model pembayaran yang tersedia dari makelar servis.</li><li>Membuat sebuah objek dari suatu servis terkelola.</li><li>Menghubungkan ke servis terkelola, yang mengembalikan kredensial koneksi.</li><li>Memetakan kredensial koneksi ke dalam aplikasi.</li></ol><h3 id=membuat-daftar-servis-terkelola-dan-model-pembayaran>Membuat daftar servis terkelola dan model pembayaran</h3><p>Pertama, seorang operator klaster harus membuat sumber daya <code>ClusterServiceBroker</code> dalam kelompok
<code>servicecatalog.k8s.io</code>. Sumber daya ini memiliki URL dan detail koneksi untuk mengakses makelar servis.</p><p>Ini ada contoh dari suatu sumber daya <code>ClusterServiceBroker</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>servicecatalog.k8s.io/v1beta1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterServiceBroker<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cloud-broker<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># Merujuk pada titik akhir dari makelar servis. (Ini adalah contoh URL yang tidak nyata)</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>url</span>:<span style=color:#bbb>  </span>https://servicebroker.somecloudprovider.com/v1alpha1/projects/service-catalog/brokers/default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic>#####</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># Nilai tambahan dapat ditambahkan disini, yang mungkin bisa digunakan untuk berkomunikasi</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># dengan makelar servis, misalnya saja informasi bearer token atau sebuah caBundle untuk TLS.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic>#####</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Berikut adalah sebuah diagram urutan yang mengilustrasikan langkah-langkah dalam mendaftarkan
servis terkelola dan model pembayaran yang tersedia dari makelar servis:</p><p><img src=/images/docs/service-catalog-list.svg alt="Daftar Servis"></p><ol><li><p>Setelah sumber daya <code>ClusterServiceBroker</code> ditambahkan ke dalam Service Catalog, ini membuat panggilan
makelar servis luar untuk membuat daftar servis yang tersedia.</p></li><li><p>Makelar servis akan mengembalikan daftar servis terkelola yang tersedia dan daftar model pembayaran,
yang akan disimpan sementara sebagai <code>ClusterServiceClass</code> dan <code>ClusterServicePlan</code>.</p></li><li><p>Seorang operator klaster bisa mendapatkan daftar servis terkelola dengan menggunakan perintah berikut ini:</p><pre><code> kubectl get clusterserviceclasses -o=custom-columns=SERVICE\ NAME:.metadata.name,EXTERNAL\ NAME:.spec.externalName
</code></pre><p>Itu seharusnya memberikan daftar nama servis dengan format yang mirip dengan berikut:</p><pre><code> SERVICE NAME                           EXTERNAL NAME
 4f6e6cf6-ffdd-425f-a2c7-3c9258ad2468   cloud-provider-service
 ...                                    ...
</code></pre><p>Mereka juga dapat melihat model pembayaran yang tersedia menggunakan perintah berikut:</p><pre><code> kubectl get clusterserviceplans -o=custom-columns=PLAN\ NAME:.metadata.name,EXTERNAL\ NAME:.spec.externalName
</code></pre><p>Itu seharusnya memberikan daftar nama model pembayaran dengan format mirip dengan berikut:</p><pre><code> PLAN NAME                              EXTERNAL NAME
 86064792-7ea2-467b-af93-ac9694d96d52   service-plan-name
 ...                                    ...
</code></pre></li></ol><h3 id=pembuatan-sebuah-objek>Pembuatan sebuah objek</h3><p>Seorang operator klaster dapat memulai pembuatan sebuah objek dengan membuat sumber daya <code>ServiceInstance</code>.</p><p>Ini adalah contoh dari sumber daya <code>ServiceInstance</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>servicecatalog.k8s.io/v1beta1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ServiceInstance<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cloud-queue-instance<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>cloud-apps<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># Referensi untuk salah satu servis yang pernah dikembalikan</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clusterServiceClassExternalName</span>:<span style=color:#bbb> </span>cloud-provider-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clusterServicePlanExternalName</span>:<span style=color:#bbb> </span>service-plan-name<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic>#####</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># Parameter tambahan dapat ditambahkan disini,</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># yang mungkin akan digunakan oleh makelar servis.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic>#####</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Berikut adalah diagram urutan yang mengilustrasikan langkah-langkah dalam pembuatan sebuah objek dari
servis terkelola:</p><p><img src=/images/docs/service-catalog-provision.svg alt="Pembuatan sebuah servis"></p><ol><li>Ketika sumber daya <code>ServiceInstance</code> sudah terbuat, Service Catalog memulai pemanggilan ke makelar servis
luar untuk membuat sebuah objek dari suatu servis.</li><li>Makelar servis membuat sebuah objek baru dari suatu servis terkelola dan mengembalikan sebuah respons HTTP.</li><li>Seorang operator klaster dapat mengecek status dari objek untuk melihat apakah sudah siap atau belum.</li></ol><h3 id=menghubungkan-ke-servis-terkelola>Menghubungkan ke servis terkelola</h3><p>Setelah sebuah objek terbuat, klaster operator harus menghubungkan ke servis terkelola untuk mendapatkan
kredensial koneksi dan detail pengguna servis untuk aplikasi bisa mengguakan servis tersebut. Ini dilakukan
dengan membuat sebuah sumber daya <code>ServiceBinding</code>.</p><p>Berikut adalah contoh dari sumber daya <code>ServiceBinding</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>servicecatalog.k8s.io/v1beta1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ServiceBinding<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cloud-queue-binding<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>cloud-apps<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>instanceRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cloud-queue-instance<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic>#####</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># Informasi tambahan dapat ditambahkan disini, seperti misalnya secretName atau</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># parameter pengguna servis, yang mungkin akan digunakan oleh makelar servis.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic>#####</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Berikut ada diagram urutan yang mengilustrasikan langkah-langkah dalam menghubungkan objek servis terkelola.</p><p><img src=/images/docs/service-catalog-bind.svg alt="Menghubungkan ke servis terkelola"></p><ol><li>Setelah <code>ServiceBinding</code> terbuat, Service Catalog memanggil makelar servis luar untuk meminta
informasi yang dibutuhkan untuk terhubung dengan objek servis.</li><li>Makelar servis memberikan izin atau peran kepada aplikasi sesuai dengan pengguna servis.</li><li>Makelar servis mengembalikan informasi untuk bisa terhubung dan mengakses servis terkelola.
Ini tergantung pada penyedia layanan dan servis, sehingga informasi yang dikembalikan mungkin berbeda
antara suatu penyedia layanan dan servis terkelolanya.</li></ol><h3 id=memetakan-kredensial-koneksi>Memetakan kredensial koneksi</h3><p>Setelah menghubungkan, langkah terakhir melibatkan pemetaan kredensial koneksi dan informasi spesifik mengenai
servis kedalam aplikasi. Informasi ini disimpan dalam Secrets yang mana aplikasi dalam klaster dapat mengakses
dan menggunakan untuk bisa terkoneksi secara langsung dengan servis terkelola.</p><br><p><img src=/images/docs/service-catalog-map.svg alt="Pemetaan kredensial koneksi"></p><h4 id=berkas-konfigurasi-pod>Berkas konfigurasi Pod</h4><p>Salah satu metode untuk melakukan pemetaan ini adalah dengan menggunakan deklarasi konfigurasi Pod.</p><p>Berikut adalah contoh yang mendekripsikan bagaimana pemetaan kredensial pengguna servis ke dalam aplikasi.
Sebuah kunci yang disebut <code>sa-key</code> disimpan dalam media bernama <code>provider-cloud-key</code>, dan aplikasi memasang
media ini pada <code>/var/secrets/provider/key.json</code>. <em>Environment variable</em> <code>PROVIDER_APPLICATION_CREDENTIALS</code>
dipetakan dari nilai pada berkas yang dipasang.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>provider-cloud-key<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>sa-key<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>provider-cloud-key<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/secrets/provider<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>PROVIDER_APPLICATION_CREDENTIALS<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/var/secrets/provider/key.json&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Berikut adalah contoh yang mendeskripsikan cara memetakan nilai rahasia ke dalam <em>environment variable</em> aplikasi.
Dalam contoh ini, nama topik dari sistem antrian pesan dipetakan dari <em>secret</em> bernama <code>provider-queue-credentials</code>
dengan nama <code>topic</code> ke dalam <em>environment variable</em> <code>TOPIC</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;TOPIC&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>secretKeyRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                   </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>provider-queue-credentials<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                   </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>topic<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=selanjutnya>Selanjutnya</h2><ul><li>Jika kamu terbiasa dengan <a class=glossary-tooltip title='A package of pre-configured Kubernetes resources that can be managed with the Helm tool.' data-toggle=tooltip data-placement=top href=https://helm.sh/docs/topics/charts/ target=_blank aria-label='Helm Charts'>Helm Charts</a>,
<a href=/docs/tasks/service-catalog/install-service-catalog-using-helm/>pasang Service Catalog menggunakan Helm</a>
ke dalam klaster Kubernetes. Alternatif lain, kamu dapat <a href=/docs/tasks/service-catalog/install-service-catalog-using-sc/>memasang Service Catalog dengan SC tool</a>.</li><li>Lihat <a href=https://github.com/openservicebrokerapi/servicebroker/blob/master/gettingStarted.md#sample-service-brokers>contoh makelar servis</a>.</li><li>Pelajari mengenai <a href=https://github.com/kubernetes-incubator/service-catalog>kubernetes-incubator/service-catalog</a> proyek.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-bad3c3629d0ab48ed84b6caf66d02f89>3.12.6 - Poseidon-Firmament - Sebuah Penjadwal Alternatif</h1><p><strong>Rilis saat ini dari Penjadwal Poseidon-Firmament adalah rilis <code>alpha </code>.</strong></p><p>Penjadwal Poseidon-Firmament adalah penjadwal alternatif yang dapat digunakan bersama penjadwal Kubernetes bawaan.</p><h2 id=pengenalan>Pengenalan</h2><p>Poseidon adalah sebuah layanan yang berperan sebagai pemersatu antara <a href=https://github.com/Huawei-PaaS/firmament>Penjadwal Firmament</a> dengan Kubernetes. Penjadwal Poseidon-Firmament menambah kapabilitas penjadwal Kubernetes saat ini. Penjadwal ini menggabungkan kemampuan penjadwalan berbasis grafik jaringan grafis (<em>flow network graph</em>) baru bersama penjadwal Kubernetes bawaan. Penjadwal Firmament memodelkan beban-beban kerja dan klaster-klaster sebagai jaringan aliran dan menjalankan optimisasi aliran biaya-minimum kepada jaringan ini untuk membuat keputusan penjadwalan.</p><p>Penjadwal ini memodelkan masalah penjadwalan sebagai optimasi berbasis batasan atas grafik jaringan aliran. Hal ini dicapai dengan mengurangi penjadwalan ke masalah optimisasi biaya-minimum aliran-maksimum. Penjadwal Poseidon-Firmament secara dinamis memperbaiki penempatan beban kerja.</p><p>Penjadwal Poseidon-Firmament berjalan bersamaan dengan penjadwal Kubernetes bawaan sebagai penjadwal alternatif, sehingga beberapa penjadwal dapat berjalan secara bersamaan.</p><h2 id=keuntungan-utama>Keuntungan Utama</h2><h3 id=penjadwalan-grafik-jaringan-network-graph-berbasis-penjadwalan-poseidon-firmament-memberikan-beberapa-keuntungan-utama-sebagai-berikut>Penjadwalan grafik jaringan (<em>network graph</em>) berbasis penjadwalan Poseidon-Firmament memberikan beberapa keuntungan utama sebagai berikut:</h3><ul><li>Beban kerja (Pod) dijadwalkan secara kolektif untuk memungkinkan penjadwalan dalam skala besar.</li><li>Berdasarkan hasil tes kinerja yang ekstensif, skala Poseidon-Firmament jauh lebih baik daripada penjadwal bawaan Kubernetes dilihat dari jumlah node meningkat dalam sebuah klaster. Hal ini disebabkan oleh fakta bahwa Poseidon-Firmament mampu mengamortisasi lebih banyak pekerjaan di seluruh beban kerja.</li><li>Penjadwal Poseidon-Firmament mengungguli penjadwal bawaan Kubernetes dengan margin lebar ketika menyangkut jumlah kinerja <em>throughput</em> untuk skenario di mana kebutuhan sumber daya komputasi agak seragam di seluruh pekerjaan (Replicaset / Deployment / Job). Angka kinerja <em>throughput</em> <em>end-to-end</em> penjadwal Poseidon-Firmament , termasuk waktu <em>bind</em>, secara konsisten menjadi lebih baik seiring jumlah Node dalam sebuah klaster meningkat. Misalnya, untuk klaster 2.700 Node (ditampilkan dalam grafik <a href=https://github.com/kubernetes-sigs/poseidon/blob/master/docs/benchmark/README.md>di sini</a>), penjadwal Poseidon-Firmament berhasil mencapai 7X atau lebih <em>throughput</em> <em>end-to-end</em> yang lebih besar dibandingkan dengan penjadwal bawaan Kubernetes, yang mencakup waktu <em>bind</em>.</li><li>Tersedianya pembatasan aturan yang kompleks.</li><li>Penjadwalan dalam Poseidon-Firmament bersifat dinamis; ini membuat sumber daya klaster dalam keadaan optimal secara global selama setiap berjalannya penjadwalan.</li><li>Pemanfaatan sumber daya yang sangat efisien.</li></ul><h2 id=penjadwal-poseidon-firmament-bagaimana-cara-kerjanya>Penjadwal Poseidon-Firmament - Bagaimana cara kerjanya</h2><p>Sebagai bagian dari pendukung penjadwal-penjadwal Kubernetes, setiap Pod baru biasanya dijadwalkan oleh penjadwal bawaan. Kubernetes dapat diinstruksikan untuk menggunakan penjadwal lain dengan menentukan nama penjadwal <em>custom</em> lain ("poseidon" dalam kasus ini) di <em>field</em> <strong>schedulerName</strong> dari PodSpec pada saat pembuatan pod. Dalam kasus ini, penjadwal bawaan akan mengabaikan Pod itu dan memungkinkan penjadwal Poseidon untuk menjadwalkan Pod pada Node yang relevan.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>schedulerName</span>:<span style=color:#bbb> </span>poseidon<span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Untuk detail tentang desain proyek ini, lihat <a href=https://github.com/kubernetes-sigs/poseidon/blob/master/docs/design/README.md>dokumen desain</a>.</div><h2 id=kemungkinan-skenario-kasus-penggunaan-kapan-menggunakannya>Kemungkinan Skenario Kasus Penggunaan - Kapan menggunakannya</h2><p>Seperti yang disebutkan sebelumnya, penjadwal Poseidon-Firmament memungkinkan lingkungan penjadwalan dengan <em>throughput</em> yang sangat tinggi bahkan pada ukuran klaster dengan beban kerja besar, dikarenakan pendekatan penjadwalannya yang sekaligus dalam jumlah besar, dibandingkan dengan pendekatan bawaan <em>pod-at-a-time</em> Kubernetes. Dalam pengujian ekstensif kami, kami telah mengamati manfaat <em>throughput</em> substansial selama kebutuhan sumber daya (CPU / Memori) untuk Pod yang masuk seragam di seluruh tugas (Replicaset / Deployment / Job), terutama karena amortisasi pekerjaan yang efisien di seluruh tugas.</p><p>Meskipun penjadwal Poseidon-Firmament mampu menjadwalkan berbagai jenis beban kerja, seperti layanan-layanan, <em>batch</em>, dll., berikut ini adalah beberapa kasus penggunaan yang paling unggul:</p><ol><li>Untuk pekerjaan "Big Data / AI" yang terdiri dari sejumlah besar tugas, manfaat dari <em>throughput</em> luar biasa.</li><li>Pekerjaan layanan atau <em>batch job</em> di mana kebutuhan sumber dayanya seragam di seluruh pekerjaan (Replicaset / Deployment / Job).</li></ol><h2 id=tahap-proyek-saat-ini>Tahap Proyek Saat Ini</h2><ul><li><strong>Rilis Alpha - Repo Inkubasi.</strong> di <a href=https://github.com/kubernetes-sigs/poseidon>https://github.com/kubernetes-sigs/poseidon</a>.</li><li>Saat ini, penjadwal Poseidon-Firmament <strong>tidak memberikan dukungan untuk ketersediaan tinggi</strong>, implementasi kami mengasumsikan bahwa penjadwal tidak mungkin gagal. <a href=https://github.com/kubernetes-sigs/poseidon/blob/master/docs/design/README.md>Dokumen desain</a> menjelaskan cara-cara yang memungkinkan untuk mengaktifkan ketersediaan tinggi, tetapi kami membiarkannya untuk pekerjaan mendatang.</li><li>Kami <strong>tidak mengetahui adanya <em>production deployment</em></strong> dari penjadwal Poseidon-Firmament saat ini.</li><li>Poseidon-Firmament didukung dari rilis Kubernetes 1.6 dan bekerja dengan semua rilis berikutnya.</li><li>Proses rilis untuk <em>repo</em> Poseidon dan Firmament berjalan secara serentak. Rilis Poseidon saat ini dapat ditemukan <a href=https://github.com/kubernetes-sigs/poseidon/releases>di sini</a> dan rilis Firmament yang sesuai dapat ditemukan <a href=https://github.com/Huawei-PaaS/firmament/releases>di sini</a>.</li></ul><h2 id=matriks-perbandingan-fitur>Matriks Perbandingan Fitur</h2><table><thead><tr><th>Fitur</th><th>Penjadwal Bawaan Kubernetes</th><th>Penjadwal Poseidon-Firmament</th><th>Catatan</th></tr></thead><tbody><tr><td><em>Node Affinity</em>/<em>Anti-Affinity</em></td><td>Y</td><td>Y</td><td></td></tr><tr><td><em>Pod Affinity</em> / <em>Anti-Affinity</em> - termasuk dukungan untuk simetri <em>anti-affinity</em> Pod</td><td>Y</td><td>Y</td><td>Saat ini penjadwal bawaan mengungguli penjadwal Poseidon-Firmament Pod dalam segi fungsionalitas <em>affinity</em>/<em>anti-affinity</em>. Kami sedang berupaya menyelesaikan ini.</td></tr><tr><td><em>Taints</em> & <em>Toleration</em></td><td>Y</td><td>Y</td><td></td></tr><tr><td>Kemampuan Penjadwalan Dasar sesuai dengan sumber daya komputasi yang tersedia (CPU & Memori) pada sebuah Node</td><td>Y</td><td>Y**</td><td>Tidak semua Predikat & Prioritas sudah didukung saat ini.</td></tr><tr><td><em>Throughput</em> ekstrim pada skala besar</td><td>Y**</td><td>Y</td><td>Pendekatan penjadwalan massal mengukur atau meningkatkan penempatan beban kerja. Manfaat <em>throughput</em> substansial menggunakan penjadwal Firmament selama persyaratan sumber daya (CPU / Memori) untuk Pod yang masuk seragam di seluruh Replicaset / Deployment / Job. Hal ini terutama disebabkan oleh amortisasi pekerjaan yang efisien di seluruh Replicaset / Deployment / Job. 1) Untuk pekerjaan "Big Data / AI" yang terdiri dari jumlah tugas yang besar, manfaat <em>throughput</em> yang luar biasa. 2) Manfaat <em>throughput</em> substansial juga untuk skenario layanan atau sekumpulan pekerjaan di mana persyaratan sumber daya beban kerja seragam di seluruh Replicaset / Deployment / Job.</td></tr><tr><td>Penjadwalan Optimal</td><td>Penjadwalan <em>Pod-by-Pod</em>, memproses satu Pod pada satu waktu (dapat mengakibatkan penjadwalan sub-optimal)</td><td>Penjadwalan Massal (Penjadwalan optimal)</td><td>Penjadwal bawaan <em>Pod-by-Pod</em> Kubernetes dapat menetapkan tugas ke mesin sub-optimal. Sebaliknya, Firmament mempertimbangkan semua tugas yang tidak terjadwal pada saat yang bersamaan bersama dengan batasan lunak dan kerasnya.</td></tr><tr><td>Penghindaran Gangguan Kolokasi</td><td>N</td><td>N**</td><td>Direncanakan di Poseidon-Firmament.</td></tr><tr><td><em>Pre-emption</em> Prioritas</td><td>Y</td><td>N**</td><td>Tersedia secara parsial pada Poseidon-Firmament, dibandingkan dengan dukungan ekstensif di penjadwal bawaan Kubernetes.</td></tr><tr><td>Penjadwalan Ulang yang Inheren</td><td>N</td><td>Y**</td><td>Penjadwal Poseidon-Firmament mendukung penjadwalan ulang beban kerja. Dalam setiap penjadwalan, penjadwal Poseidon-Firmament mempertimbangkan semua Pod, termasuk Pod yang sedang berjalan, dan sebagai hasilnya dapat melakukan migrasi atau mengeluarkan Pod - sebuah lingkungan penjadwalan yang optimal secara global.</td></tr><tr><td>Penjadwalan Berkelompok</td><td>N</td><td>Y</td><td></td></tr><tr><td>Dukungan untuk Penjadwalan Volume Persisten Pra-terikat</td><td>Y</td><td>Y</td><td></td></tr><tr><td>Dukungan untuk Volume Lokal & Penjadwalan <em>Binding</em> Volume Persisten Dinamis</td><td>Y</td><td>N**</td><td>Direncanakan.</td></tr><tr><td>Ketersediaan Tinggi</td><td>Y</td><td>N**</td><td>Direncanakan.</td></tr><tr><td>Penjadwalan berbasis metrik <em>real-time</em></td><td>N</td><td>Y**</td><td>Awalnya didukung menggunakan Heapster (sekarang tidak digunakan lagi) untuk menempatkan Pod menggunakan statistik penggunaan klaster aktual ketimbang reservasi. Rencananya akan dialihkan ke "server metrik".</td></tr><tr><td>Dukungan untuk <em>Max-Pod</em> per Node</td><td>Y</td><td>Y</td><td>Penjadwal Poseidon-Firmament secara mulus berdampingan dengan penjadwal bawaan Kubernetes.</td></tr><tr><td>Dukungan untuk Penyimpanan <em>Ephemeral</em>, selain CPU / Memori</td><td>Y</td><td>Y</td><td></td></tr></tbody></table><h2 id=instalasi>Instalasi</h2><p>Untuk instalasi Poseidon dalam-klaster, silakan mulai dari <a href=https://github.com/kubernetes-sigs/poseidon/blob/master/docs/install/README.md>Petunjuk Instalasi</a>.</p><h2 id=pengembangan>Pengembangan</h2><p>Untuk developer, silakan merujuk ke <a href=https://github.com/kubernetes-sigs/poseidon/blob/master/docs/devel/README.md>Instruksi <em>Setup</em> Developer</a>.</p><h2 id=hasil-pengujian-kinerja-throughput-terbaru>Hasil Pengujian Kinerja <em>Throughput</em> Terbaru</h2><p>Penjadwal <em>pod-by-pod</em>, seperti penjadwal bawaan Kubernetes, biasanya memproses satu Pod pada satu waktu. Penjadwal ini memiliki kelemahan penting berikut:</p><ol><li>Penjadwal berkomitmen untuk penempatan Pod lebih awal dan membatasi pilihan untuk Pod lain yang menunggu untuk ditempatkan.</li><li>Ada peluang terbatas untuk amortisasi pekerjaan lintas Pod karena mereka dipertimbangkan untuk ditempatkan secara individual.</li></ol><p>Kelemahan dari penjadwal <em>pod-by-pod</em> ini diatasi dengan penjadwalan secara terkumpul atau dalam jumlah banyak secara bersamaan di penjadwal Poseidon-Firmament. Memproses beberapa Pod dalam satu kumpulan memungkinkan penjadwal untuk bersama-sama mempertimbangkan penempatan mereka, dan dengan demikian untuk menemukan untung-rugi terbaik untuk seluruh kumpulan ketimbang satu Pod saja. Pada saat yang sama, amortisasi berfungsi lintas Pod yang menghasilkan <em>throughput</em> yang jauh lebih tinggi.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Silakan merujuk ke <a href=https://github.com/kubernetes-sigs/poseidon/blob/master/docs/benchmark/README.md>hasil <em>benchmark</em> terbaru</a> untuk hasil uji perbandingan kinerja <em>throughput</em> terperinci antara penjadwal Poseidon-Firmament dan Penjadwal bawaan Kubernetes.</div></div><div class=td-content style=page-break-before:always><h1 id=pg-f8918f697450c2009b75913f9e9317a5>4 - Tugas</h1><nav id=TableOfContents><ul><li><a href=#antarmuka-pengguna-berbasis-web-dashboard>Antarmuka Pengguna Berbasis Web (Dashboard)</a></li><li><a href=#menggunakan-baris-perintah-kubectl>Menggunakan Baris Perintah kubectl</a></li><li><a href=#mengkonfigurasi-pod-dan-container>Mengkonfigurasi Pod dan Container</a></li><li><a href=#menjalankan-aplikasi>Menjalankan Aplikasi</a></li><li><a href=#menjalankan-job>Menjalankan Job</a></li><li><a href=#mengakses-aplikasi-dalam-klaster>Mengakses Aplikasi dalam Klaster</a></li><li><a href=#monitoring-logging-dan-debugging><em>Monitoring, Logging</em>, dan <em>Debugging</em></a></li><li><a href=#mengakses-api-kubernetes>Mengakses API Kubernetes</a></li><li><a href=#menggunakan-tls>Menggunakan TLS</a></li><li><a href=#mengelola-klaster>Mengelola Klaster</a></li><li><a href=#mengelola-aplikasi-yang-stateful>Mengelola Aplikasi yang <em>Stateful</em></a></li><li><a href=#daemon-klaster><em>Daemon</em> Klaster</a></li><li><a href=#mengelola-gpu>Mengelola GPU</a></li><li><a href=#mengelola-hugepages>Mengelola <em>HugePages</em></a></li><li><a href=#selanjutnya>Selanjutnya</a></li></ul></nav><p>Bagian dokumentasi Kubernetes ini berisi halaman-halaman yang perlihatkan
bagaimana melakukan setiap tugas (<em>task</em>). Halaman tugas menunjukkan cara melakukan
satu hal saja, biasanya dengan memberikan urutan langkah pendek.</p><h2 id=antarmuka-pengguna-berbasis-web-dashboard>Antarmuka Pengguna Berbasis Web (Dashboard)</h2><p>Melakukan <em>deploy</em> dan mengakses <em>dashboard</em> berbasis web untuk
membantu kamu mengelola dan memantau aplikasi yang dimasukkan ke dalam container
di Kubernetes.</p><h2 id=menggunakan-baris-perintah-kubectl>Menggunakan Baris Perintah kubectl</h2><p>Instalasi dan konfigurasi utilitas baris perintah <code>kubectl</code> yang digunakan untuk
mengelola secara langsung klaster Kubernetes.</p><h2 id=mengkonfigurasi-pod-dan-container>Mengkonfigurasi Pod dan Container</h2><p>Melakukan tugas konfigurasi yang umum untuk Pod dan Container.</p><h2 id=menjalankan-aplikasi>Menjalankan Aplikasi</h2><p>Melakukan tugas manajemen aplikasi secara umum, seperti <em>rolling updates</em>, memasukkan
informasi ke dalam Pod, dan penskalaan Pod secara horisontal.</p><h2 id=menjalankan-job>Menjalankan Job</h2><p>Menjalankan Job dengan menggunakan pemrosesan paralel.</p><h2 id=mengakses-aplikasi-dalam-klaster>Mengakses Aplikasi dalam Klaster</h2><p>Mengkonfigurasi <em>load balancing</em>, <em>port forwarding</em>, atau membangun <em>firewall</em>
atau konfigurasi DNS untuk mengakses aplikasi dalam sebuah klaster.</p><h2 id=monitoring-logging-dan-debugging><em>Monitoring, Logging</em>, dan <em>Debugging</em></h2><p>Mengatur <em>monitoring</em> (pemantauan) dan <em>logging</em> (pencatatan) untuk memecahkan
masalah klaster atau melakukan <em>debug</em> (pelacakan) aplikasi yang dikontainerisasi.</p><h2 id=mengakses-api-kubernetes>Mengakses API Kubernetes</h2><p>Mempelajari berbagai metode untuk mengakses API Kubernetes secara langsung.</p><h2 id=menggunakan-tls>Menggunakan TLS</h2><p>Mengkonfigurasi aplikasi kamu untuk percaya dan menggunakan klaster <em>Certificate
Authority</em> (CA).</p><h2 id=mengelola-klaster>Mengelola Klaster</h2><p>Mempelajari tugas umum untuk mengelola klaster.</p><h2 id=mengelola-aplikasi-yang-stateful>Mengelola Aplikasi yang <em>Stateful</em></h2><p>Melakukan tugas umum untuk mengelola aplikasi yang <em>Stateful</em>, termasuk
penskalaan, penghapusan, dan <em>debugging</em> StatefulSets.</p><h2 id=daemon-klaster><em>Daemon</em> Klaster</h2><p>Melakukan tugas-tugas umum untuk mengelola DaemonSet, seperti melakukan <em>rolling
updates</em>.</p><h2 id=mengelola-gpu>Mengelola GPU</h2><p>Mengkonfigurasi dan menjadwalkan GPU NVIDIA untuk digunakan sebagai sumber daya
oleh Node dalam sebuah klaster.</p><h2 id=mengelola-hugepages>Mengelola <em>HugePages</em></h2><p>Mengkonfigurasi dan menjadwalkan <em>HugePages</em> sebagai sumber daya yang dapat
dijadwalkan dalam sebuah klaster.</p><h2 id=selanjutnya>Selanjutnya</h2><p>Jika kamu ingin menulis halaman tugas (<em>task</em>), silahkan lihat
<a href=/docs/home/contribute/create-pull-request/>Membuat Dokumentasi <em>Pull Request</em></a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-57bf66f59d9a642b82eebeabbc66470b>4.1 - Menginstal Peralatan</h1><div class=lead>Peralatan untuk melakukan instalasi Kubernetes dalam komputer kamu.</div><h2 id=kubectl>kubectl</h2><p>Perangkat baris perintah Kubernetes, <a href=/id/docs/reference/kubectl/kubectl/>kubectl</a>,
memungkinkan kamu untuk menjalankan perintah pada klaster Kubernetes.
Kamu dapat menggunakan kubectl untuk menerapkan aplikasi, memeriksa dan mengelola sumber daya klaster,
dan melihat <em>log</em> (catatan). Untuk informasi lebih lanjut termasuk daftar lengkap operasi kubectl, lihat
<a href=/id/docs/reference/kubectl/>referensi dokumentasi <code>kubectl</code></a>.</p><p>kubectl dapat diinstal pada berbagai platform Linux, macOS dan Windows.
Pilihlah sistem operasi pilihan kamu di bawah ini.</p><ul><li><a href=/en/docs/tasks/tools/install-kubectl-linux>Instalasi kubectl pada Linux</a></li><li><a href=/en/docs/tasks/tools/install-kubectl-macos>Instalasi kubectl pada macOS</a></li><li><a href=/en/docs/tasks/tools/install-kubectl-windows>Instalasi kubectl pada Windows</a></li></ul><h2 id=kind>kind</h2><p><a href=https://kind.sigs.k8s.io/docs/><code>kind</code></a> memberikan kamu kemampuan untuk
menjalankan Kubernetes pada komputer lokal kamu. Perangkat ini membutuhkan
<a href=https://docs.docker.com/get-docker/>Docker</a> yang sudah diinstal dan
terkonfigurasi.</p><p>Halaman <a href=https://kind.sigs.k8s.io/docs/user/quick-start/>Memulai Cepat</a> <code>kind</code>
memperlihatkan kepada kamu tentang apa yang perlu kamu lakukan untuk <code>kind</code>
berjalan dan bekerja.</p><p><a class="btn btn-primary" href=https://kind.sigs.k8s.io/docs/user/quick-start/ role=button aria-label="Melihat Memulai Cepat Kind">Melihat Memulai Cepat Kind</a></p><h2 id=minikube>minikube</h2><p>Seperti halnya dengan <code>kind</code>, <a href=https://minikube.sigs.k8s.io/><code>minikube</code></a>
merupakan perangkat yang memungkinkan kamu untuk menjalankan Kubernetes
secara lokal. <code>minikube</code> menjalankan sebuah klaster Kubernetes dengan
satu node saja dalam komputer pribadi (termasuk Windows, macOS dan Linux)
sehingga kamu dapat mencoba Kubernetes atau untuk pekerjaan pengembangan
sehari-hari.</p><p>Kamu bisa mengikuti petunjuk resmi
<a href=https://minikube.sigs.k8s.io/docs/start/>Memulai!</a>
<code>minikube</code> jika kamu ingin fokus agar perangkat ini terinstal.</p><p><a class="btn btn-primary" href=https://minikube.sigs.k8s.io/docs/start/ role=button aria-label="Lihat Panduan Memulai! Minikube">Lihat Panduan Memulai! Minikube</a></p><p>Setelah kamu memiliki <code>minikube</code> yang bekerja, kamu bisa menggunakannya
untuk <a href=/id/docs/tutorials/hello-minikube/>menjalankan aplikasi contoh</a>.</p><h2 id=kubeadm>kubeadm</h2><p>Kamu dapat menggunakan <a class=glossary-tooltip title='A tool for quickly installing Kubernetes and setting up a secure cluster.' data-toggle=tooltip data-placement=top href=/docs/admin/kubeadm/ target=_blank aria-label=kubeadm>kubeadm</a>
untuk membuat dan mengatur klaster Kubernetes.
<code>kubeadm</code> menjalankan langkah-langkah yang diperlukan untuk mendapatkan klaster
dengan kelaikan dan keamanan minimum, aktif dan berjalan dengan cara yang mudah
bagi pengguna.</p><p><a href=/id/docs/setup/production-environment/tools/kubeadm/install-kubeadm/>Instalasi kubeadm</a> memperlihatkan tentang bagaimana melakukan instalasi kubeadm.
Setelah terinstal, kamu dapat menggunakannya untuk <a href=/id/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/>membuat klaster</a>.</p><p><a class="btn btn-primary" href=/docs/setup/production-environment/tools/kubeadm/install-kubeadm/ role=button aria-label="Lihat panduan instalasi kubeadm">Lihat panduan instalasi kubeadm</a></p></div><div class=td-content style=page-break-before:always><h1 id=pg-bbdc530b292ab4074d1dfe69feafb3e7>4.1.1 - Menginstal dan Menyiapkan kubectl</h1><p><a href=/docs/user-guide/kubectl/>Kubectl</a> adalah alat baris perintah (<em>command line tool</em>) Kubernetes yang digunakan untuk menjalankan berbagai perintah untuk klaster Kubernetes. Kamu dapat menggunakan <code>kubectl</code> untuk men-<em>deploy</em> aplikasi, mengatur sumber daya klaster, dan melihat log. Daftar operasi <code>kubectl</code> dapat dilihat di <a href=/docs/reference/kubectl/overview/>Ikhtisar kubectl</a>.</p><h2 id=sebelum-kamu-memulai>Sebelum kamu memulai</h2><p>Kamu harus menggunakan kubectl dengan perbedaan maksimal satu versi minor dengan klaster kamu. Misalnya, klien v1.2 masih dapat digunakan dengan master v1.1, v1.2, dan 1.3. Menggunakan versi terbaru <code>kubectl</code> dapat menghindari permasalahan yang tidak terduga.</p><h2 id=menginstal-kubectl-pada-linux>Menginstal kubectl pada Linux</h2><h3 id=menginstal-program-kubectl-menggunakan-curl-pada-linux>Menginstal program kubectl menggunakan curl pada Linux</h3><ol><li><p>Unduh versi terbarunya dengan perintah:</p><pre tabindex=0><code>curl -LO https://storage.googleapis.com/kubernetes-release/release/`curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt`/bin/linux/amd64/kubectl
</code></pre><p>Untuk mengunduh versi spesifik, ganti bagian <code>curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt</code> dengan versi yang diinginkan.</p><p>Misalnya, untuk mengunduh versi v1.25.0 di Linux, ketik:</p><pre tabindex=0><code>curl -LO https://storage.googleapis.com/kubernetes-release/release/v1.25.0/bin/linux/amd64/kubectl
</code></pre></li><li><p>Jadikan program <code>kubectl</code> dapat dieksekusi.</p><pre tabindex=0><code>chmod +x ./kubectl
</code></pre></li><li><p>Pindahkan ke PATH kamu.</p><pre tabindex=0><code>sudo mv ./kubectl /usr/local/bin/kubectl
</code></pre></li><li><p>Pastikan instalasinya sudah berhasil dengan melakukan pengecekan versi:</p><pre tabindex=0><code>kubectl version --client
</code></pre></li></ol><h3 id=menginstal-dengan-manajer-paket-package-manager-bawaan>Menginstal dengan manajer paket (<em>package manager</em>) bawaan</h3><ul class="nav nav-tabs" id=kubectl-install role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#kubectl-install-0 role=tab aria-controls=kubectl-install-0 aria-selected=true>Ubuntu, Debian or HypriotOS</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#kubectl-install-1 role=tab aria-controls=kubectl-install-1>CentOS, RHEL or Fedora</a></li></ul><div class=tab-content id=kubectl-install><div id=kubectl-install-0 class="tab-pane show active" role=tabpanel aria-labelledby=kubectl-install-0><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>
</span></span><span style=display:flex><span>sudo apt-get update <span style=color:#666>&amp;&amp;</span> sudo apt-get install -y apt-transport-https gnupg2
</span></span><span style=display:flex><span>curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key add -
</span></span><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b44>&#34;deb https://apt.kubernetes.io/ kubernetes-xenial main&#34;</span> | sudo tee -a /etc/apt/sources.list.d/kubernetes.list
</span></span><span style=display:flex><span>sudo apt-get update
</span></span><span style=display:flex><span>sudo apt-get install -y kubectl
</span></span></code></pre></div></div><div id=kubectl-install-1 class=tab-pane role=tabpanel aria-labelledby=kubectl-install-1><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo
</span></span></span><span style=display:flex><span><span style=color:#b44>[kubernetes]
</span></span></span><span style=display:flex><span><span style=color:#b44>name=Kubernetes
</span></span></span><span style=display:flex><span><span style=color:#b44>baseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64
</span></span></span><span style=display:flex><span><span style=color:#b44>enabled=1
</span></span></span><span style=display:flex><span><span style=color:#b44>gpgcheck=1
</span></span></span><span style=display:flex><span><span style=color:#b44>repo_gpgcheck=1
</span></span></span><span style=display:flex><span><span style=color:#b44>gpgkey=https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span><span style=display:flex><span>yum install -y kubectl
</span></span></code></pre></div></div></div><h3 id=menginstal-dengan-manajer-paket-lain>Menginstal dengan manajer paket lain</h3><ul class="nav nav-tabs" id=other-kubectl-install role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#other-kubectl-install-0 role=tab aria-controls=other-kubectl-install-0 aria-selected=true>Snap</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#other-kubectl-install-1 role=tab aria-controls=other-kubectl-install-1>Homebrew</a></li></ul><div class=tab-content id=other-kubectl-install><div id=other-kubectl-install-0 class="tab-pane show active" role=tabpanel aria-labelledby=other-kubectl-install-0><p><p>Jika kamu menggunakan Ubuntu atau versi Linux lain yang mendukung manajer paket <a href=https://snapcraft.io/docs/core/install>snap</a>, <code>kubectl</code> tersedia dalam bentuk aplikasi di <a href=https://snapcraft.io/>snap</a>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>snap install kubectl --classic
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl version --client
</span></span></code></pre></div></div><div id=other-kubectl-install-1 class=tab-pane role=tabpanel aria-labelledby=other-kubectl-install-1><p><p>Jika kamu menggunakan Linux dengan manajer paket <a href=https://docs.brew.sh/Homebrew-on-Linux>Homebrew</a>, <code>kubectl</code> sudah tersedia untuk diinstal di <a href=https://docs.brew.sh/Homebrew-on-Linux#install>Homebrew</a>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>brew install kubectl
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl version --client
</span></span></code></pre></div></div></div><h2 id=menginstal-kubectl-pada-macos>Menginstal kubectl pada macOS</h2><h3 id=menginstal-program-kubectl-dengan-curl-pada-macos>Menginstal program kubectl dengan curl pada macOS</h3><ol><li><p>Unduh versi terbarunya dengan perintah:</p><pre tabindex=0><code>curl -LO &#34;https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/darwin/amd64/kubectl&#34;
</code></pre><p>Untuk mengunduh versi spesifik, ganti bagian <code>curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt</code> dengan versi yang diinginkan.</p><p>Misalnya, untuk mengunduh versi v1.25.0 pada macOS, ketik:</p><pre tabindex=0><code>curl -LO https://storage.googleapis.com/kubernetes-release/release/v1.25.0/bin/darwin/amd64/kubectl
</code></pre></li><li><p>Buat agar program <code>kubectl</code> dapat dijalankan.</p><pre tabindex=0><code>chmod +x ./kubectl
</code></pre></li><li><p>Pindahkan ke PATH kamu.</p><pre tabindex=0><code>sudo mv ./kubectl /usr/local/bin/kubectl
</code></pre></li><li><p>Pastikan instalasinya sudah berhasil dengan melakukan pengecekan versi:</p><pre tabindex=0><code>kubectl version --client
</code></pre></li></ol><h3 id=menginstal-dengan-homebrew-pada-macos>Menginstal dengan Homebrew pada macOS</h3><p>Jika kamu menggunakan macOS dan manajer paket <a href=https://brew.sh/>Homebrew</a>, kamu dapat menginstal <code>kubectl</code> langsung dengan Homebrew.</p><ol><li><p>Jalankan perintah:</p><pre tabindex=0><code>brew install kubectl 
</code></pre><p>atau</p><pre tabindex=0><code>brew install kubernetes-cli
</code></pre></li><li><p>Pastikan instalasinya sudah berhasil dengan melakukan pengecekan versi:</p><pre tabindex=0><code>kubectl version --client
</code></pre></li></ol><h3 id=menginstal-dengan-macports-pada-macos>Menginstal dengan Macports pada macOS</h3><p>Jika kamu menggunakan macOS dan manajer paket <a href=https://macports.org/>Macports</a>, kamu dapat menginstal <code>kubectl</code> langsung dengan Macports.</p><ol><li><p>Jalankan perintah:</p><pre tabindex=0><code>sudo port selfupdate
sudo port install kubectl
</code></pre></li><li><p>Pastikan instalasinya sudah berhasil dengan melakukan pengecekan versi:</p><pre tabindex=0><code>kubectl version --client
</code></pre></li></ol><h2 id=menginstal-kubectl-pada-windows>Menginstal kubectl pada Windows</h2><h3 id=menginstal-program-kubectl-dengan-curl-pada-windows>Menginstal program kubectl dengan curl pada Windows</h3><ol><li><p>Unduh versi terbarunya v1.25.0 dari <a href=https://storage.googleapis.com/kubernetes-release/release/v1.25.0/bin/windows/amd64/kubectl.exe>tautan ini</a>.</p><p>Atau jika sudah ada <code>curl</code> pada mesin kamu, jalankan perintah ini:</p><pre tabindex=0><code>curl -LO https://storage.googleapis.com/kubernetes-release/release/v1.25.0/bin/windows/amd64/kubectl.exe
</code></pre><p>Untuk mendapatkan versi stabil terakhir (misalnya untuk <em>scripting</em>), lihat di <a href=https://storage.googleapis.com/kubernetes-release/release/stable.txt>https://storage.googleapis.com/kubernetes-release/release/stable.txt</a>.</p></li><li><p>Tambahkan program yang sudah diunduh tersebut ke PATH kamu.</p></li><li><p>Pastikan instalasinya sudah berhasil dengan melakukan pengecekan versi:</p><pre tabindex=0><code>kubectl version --client
</code></pre></li></ol><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> <a href=https://docs.docker.com/docker-for-windows/#kubernetes>Docker Desktop untuk Windows</a> sudah menambahkan versi <code>kubectl</code>-nya sendiri ke PATH. Jika kamu sudah menginstal Docker Desktop, kamu harus menambahkan entrinya ke PATH sebelum yang ditambahkan oleh penginstal (<em>installer</em>) Docker Desktop atau kamu dapat menghapus <code>kubectl</code> bawaan dari Docker Desktop.</div><h3 id=menginstal-dengan-powershell-dari-psgallery>Menginstal dengan Powershell dari PSGallery</h3><p>Jika kamu menggunakan Windows dan manajer paket <a href=https://www.powershellgallery.com/>Powershell Gallery</a>, kamu dapat menginstal dan melakukan pembaruan <code>kubectl</code> dengan Powershell.</p><ol><li><p>Jalankan perintah berikut (jangan lupa untuk memasukkan <code>DownloadLocation</code>):</p><pre tabindex=0><code>Install-Script -Name install-kubectl -Scope CurrentUser -Force
install-kubectl.ps1 [-DownloadLocation &lt;path&gt;]
</code></pre><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Jika kamu tidak menambahkan <code>DownloadLocation</code>, <code>kubectl</code> akan diinstal di dalam direktori <em>temp</em> pengguna.</div><p>Penginstal akan membuat <code>$HOME/.kube</code> dan membuat berkas konfigurasi</p></li><li><p>Pastikan instalasinya sudah berhasil dengan melakukan pengecekan versi:</p><pre tabindex=0><code>kubectl version --client
</code></pre><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Proses pembaruan dapat dilakukan dengan menjalankan ulang dua perintah yang terdapat pada langkah 1.</div></li></ol><h3 id=menginstal-pada-windows-menggunakan-chocolatey-atau-scoop>Menginstal pada Windows menggunakan Chocolatey atau Scoop</h3><p>Untuk menginstal <code>kubectl</code> pada Windows, kamu dapat menggunakan manajer paket <a href=https://chocolatey.org>Chocolatey</a> atau penginstal baris perintah <a href=https://scoop.sh>Scoop</a>.<ul class="nav nav-tabs" id=kubectl-win-install role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#kubectl-win-install-0 role=tab aria-controls=kubectl-win-install-0 aria-selected=true>choco</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#kubectl-win-install-1 role=tab aria-controls=kubectl-win-install-1>scoop</a></li></ul><div class=tab-content id=kubectl-win-install><div id=kubectl-win-install-0 class="tab-pane show active" role=tabpanel aria-labelledby=kubectl-win-install-0><p><pre><code>choco install kubernetes-cli
</code></pre></div><div id=kubectl-win-install-1 class=tab-pane role=tabpanel aria-labelledby=kubectl-win-install-1><p><pre><code>scoop install kubectl
</code></pre></div></div></p><ol><li><p>Pastikan instalasinya sudah berhasil dengan melakukan pengecekan versi:</p><pre tabindex=0><code>kubectl version --client
</code></pre></li><li><p>Pindah ke direktori utama:</p><pre tabindex=0><code>cd %USERPROFILE%
</code></pre></li><li><p>Buat direktori <code>.kube</code>:</p><pre tabindex=0><code>mkdir .kube
</code></pre></li><li><p>Pindah ke direktori <code>.kube</code> yang baru saja dibuat:</p><pre tabindex=0><code>cd .kube
</code></pre></li><li><p>Lakukan konfigurasi <code>kubectl</code> untuk menggunakan klaster Kubernetes <em>remote</em>:</p><pre tabindex=0><code>New-Item config -type file
</code></pre><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Ubah berkas konfigurasi dengan penyunting (<em>editor</em>) teks pilihanmu, misalnya Notepad.</div></li></ol><h2 id=mengunduh-sebagai-bagian-dari-google-cloud-sdk>Mengunduh sebagai bagian dari Google Cloud SDK</h2><p>Kamu dapat menginstal <code>kubectl</code> sebagai bagian dari Google Cloud SDK.</p><ol><li><p>Instal <a href=https://cloud.google.com/sdk/>Google Cloud SDK</a>.</p></li><li><p>Jalankan perintah instalasi <code>kubectl</code>:</p><pre tabindex=0><code>gcloud components install kubectl
</code></pre></li><li><p>Pastikan instalasinya sudah berhasil dengan melakukan pengecekan versi:</p><pre tabindex=0><code>kubectl version --client
</code></pre></li></ol><h2 id=memeriksa-konfigurasi-kubectl>Memeriksa konfigurasi kubectl</h2><p>Agar <code>kubectl</code> dapat mengakses klaster Kubernetes, dibutuhkan sebuah <a href=/id/docs/tasks/access-application-cluster/configure-access-multiple-clusters/>berkas kubeconfig</a>, yang akan otomatis dibuat ketika kamu membuat klaster baru menggunakan <a href=https://github.com/kubernetes/kubernetes/blob/master/cluster/kube-up.sh>kube-up.sh</a> atau setelah berhasil men-<em>deploy</em> klaster Minikube. Secara bawaan, konfigurasi <code>kubectl</code> disimpan di <code>~/.kube/config</code>.</p><p>Kamu dapat memeriksa apakah konfigurasi <code>kubectl</code> sudah benar dengan mengambil keadaan klaster:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl cluster-info
</span></span></code></pre></div><p>Jika kamu melihat respons berupa URL, maka konfigurasi klaster <code>kubectl</code> sudah benar.</p><p>Tetapi, jika kamu melihat pesan seperti di bawah, maka <code>kubectl</code> belum dikonfigurasi dengan benar atau tidak dapat terhubung ke klaster Kubernetes.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>The connection to the server &lt;server-name:port&gt; was refused - did you specify the right host or port?
</span></span></code></pre></div><p>Selanjutnya, jika kamu ingin menjalankan klaster Kubernetes di laptop (lokal) kamu, kamu memerlukan sebuah perangkat seperti Minikube sebelum menjalankan ulang perintah yang ada di atas.</p><p>Jika <code>kubectl cluster-info</code> mengembalikan respons URL tetapi kamu masih belum dapat mengakses klaster, kamu bisa menggunakan perintah di bawah untuk memeriksa apakah klaster sudah dikonfigurasi dengan benar.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl cluster-info dump
</span></span></code></pre></div><h2 id=konfigurasi-kubectl-opsional>Konfigurasi kubectl opsional</h2><h3 id=menyalakan-penyelesaian-otomatis-untuk-terminal>Menyalakan penyelesaian otomatis untuk terminal</h3><p><code>kubectl</code> menyediakan fitur penyelesaian otomatis (<em>auto complete</em>) untuk Bash dan Zsh yang dapat memudahkanmu ketika mengetik di terminal.</p><p>Ikuti petunjuk di bawah untuk menyalakan penyelesaian otomatis untuk Bash dan Zsh.</p><ul class="nav nav-tabs" id=kubectl-autocompletion role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#kubectl-autocompletion-0 role=tab aria-controls=kubectl-autocompletion-0 aria-selected=true>Bash pada Linux</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#kubectl-autocompletion-1 role=tab aria-controls=kubectl-autocompletion-1>Bash pada macOS</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#kubectl-autocompletion-2 role=tab aria-controls=kubectl-autocompletion-2>Zsh</a></li></ul><div class=tab-content id=kubectl-autocompletion><div id=kubectl-autocompletion-0 class="tab-pane show active" role=tabpanel aria-labelledby=kubectl-autocompletion-0><p><h3 id=pendahuluan>Pendahuluan</h3><p>Skrip penyelesaian (<em>completion script</em>) <code>kubectl</code> untuk Bash dapat dibuat dengan perintah <code>kubectl completion bash</code>. Masukkan skrip tersebut ke dalam terminal sebagai sumber untuk menyalakan penyelesaian otomatis dari <code>kubectl</code>.</p><p>Namun, skrip penyelesaian tersebut bergantung pada <a href=https://github.com/scop/bash-completion><strong>bash-completion</strong></a>, yang artinya kamu harus menginstal program tersebut terlebih dahulu (kamu dapat memeriksa apakah kamu sudah memiliki bash-completion dengan menjalankan perintah <code>type _init_completion</code>).</p><h3 id=menginstal-bash-completion>Menginstal bash-completion</h3><p>bash-completion disediakan oleh banyak manajer paket (lihat <a href=https://github.com/scop/bash-completion#installation>di sini</a>). Kamu dapat menginstalnya dengan menggunakan perintah <code>apt-get install bash-completion</code> atau <code>yum install bash-completion</code>, dsb.</p><p>Perintah di atas akan membuat skrip utama bash-completion di <code>/usr/share/bash-completion/bash_completion</code>. Terkadang kamu juga harus menambahkan skrip tersebut ke dalam berkas <code>~/.bashrc</code>, tergantung manajer paket yang kamu pakai.</p><p>Untuk memastikannya, muat ulang terminalmu dan jalankan <code>type _init_completion</code>. Jika perintah tersebut berhasil, maka instalasi selesai. Jika tidak, tambahkan teks berikut ke dalam berkas <code>~/.bashrc</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>source</span> /usr/share/bash-completion/bash_completion
</span></span></code></pre></div><p>Muat ulang terminalmu dan pastikan bash-completion sudah berhasil diinstal dengan menjalankan <code>type _init_completion</code>.</p><h3 id=menyalakan-penyelesaian-otomatis-kubectl>Menyalakan penyelesaian otomatis kubectl</h3><p>Sekarang kamu harus memastikan bahwa skrip penyelesaian untuk <code>kubectl</code> sudah dimasukkan sebagai sumber penyelesaian otomatis pada semua sesi terminal. Kamu dapat melakukannya dengan dua cara:</p><ul><li><p>Masukkan skrip penyelesaian sebagai sumber di berkas <code>~/.bashrc</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b44>&#39;source &lt;(kubectl completion bash)&#39;</span> &gt;&gt;~/.bashrc
</span></span></code></pre></div></li><li><p>Tambahkan skrip penyelesaian ke direktori <code>/etc/bash_completion.d</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl completion bash &gt;/etc/bash_completion.d/kubectl
</span></span></code></pre></div></li></ul><p>Jika kamu menggunakan alias untuk <code>kubectl</code>, kamu masih dapat menggunakan fitur penyelesaian otomatis dengan menjalankan perintah:</p><pre><code>```shell
echo 'alias k=kubectl' &gt;&gt;~/.bashrc
echo 'complete -F __start_kubectl k' &gt;&gt;~/.bashrc
```
</code></pre><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Semua sumber skrip penyelesaian bash-completion terdapat di <code>/etc/bash_completion.d</code>.</div><p>Kedua cara tersebut sama, kamu bisa memilih salah satunya. Setelah memuat ulang terminal, penyelesaian otomatis dari <code>kubectl</code> seharusnya sudah dapat bekerja.</p></div><div id=kubectl-autocompletion-1 class=tab-pane role=tabpanel aria-labelledby=kubectl-autocompletion-1><p><h3 id=pendahuluan>Pendahuluan</h3><p>Skrip penyelesaian (<em>completion script</em>) <code>kubectl</code> untuk Bash dapat dibuat dengan perintah <code>kubectl completion bash</code>. Masukkan skrip tersebut ke dalam terminal sebagai sumber untuk menyalakan penyelesaian otomatis dari <code>kubectl</code>.</p><p>Namun, skrip penyelesaian tersebut bergantung pada <a href=https://github.com/scop/bash-completion><strong>bash-completion</strong></a>, yang artinya kamu harus menginstal program tersebut terlebih dahulu.</p><div class="alert alert-danger warning callout" role=alert><strong>Peringatan:</strong> Terdapat dua versi bash-completion, v1 dan v2. V1 untuk Bash 3.2 (bawaan dari macOs), dan v2 untuk Bash 4.1+. Skrip penyelesaian <code>kubectl</code> <strong>tidak kompatibel</strong> dengan bash-completion v1 dan Bash 3.2. Dibutuhkan <strong>bash-completion v2</strong> dan <strong>Bash 4.1+</strong> agar skrip penyelesaian <code>kubectl</code> dapat bekerja dengan baik. Maka dari itu, kamu harus menginstal dan menggunakan Bash 4.1+ (<a href=https://itnext.io/upgrading-bash-on-macos-7138bd1066ba><em>panduan</em></a>) untuk dapat menggunakan fitur penyelesaian otomatis dari <code>kubectl</code>. Ikuti panduan di bawah setelah kamu menginstal Bash 4.1+ (yaitu, Bash versi 4.1 atau lebih baru).</div><h3 id=pemutakhiran-bash>Pemutakhiran Bash</h3><p>Panduan di bawah berasumsi kamu menggunakan Bash 4.1+. Kamu dapat memeriksa versi Bash dengan menjalankan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b8860b>$BASH_VERSION</span>
</span></span></code></pre></div><p>Jika versinya sudah terlalu usang, kamu dapat menginstal/memutakhirkannya dengan menggunakan Homebrew:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>brew install bash
</span></span></code></pre></div><p>Muat ulang terminalmu dan pastikan versi yang diharapkan sudah dipakai:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b8860b>$BASH_VERSION</span> <span style=color:#b8860b>$SHELL</span>
</span></span></code></pre></div><p>Homebrew biasanya akan menginstalnya di <code>/usr/local/bin/bash</code>.</p><h3 id=menginstal-bash-completion>Menginstal bash-completion</h3><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Seperti yang sudah disebutkan, panduan di bawah berasumsi kamu menggunakan Bash 4.1+, yang berarti kamu akan menginstal bash-completion v2 (penyelesaian otomatis dari <code>kubectl</code> tidak kompatibel dengan Bash 3.2 dan bash-completion v1).</div><p>Kamu dapat memeriksa apakah kamu sudah memiliki bash-completion v2 dengan perintah <code>type _init_completion</code>. Jika belum, kamu dapat menginstalnya dengan menggunakan Homebrew:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>brew install bash-completion@2
</span></span></code></pre></div><p>Seperti yang disarankan pada keluaran perintah di atas, tambahkan teks berikut ke berkas <code>~/.bashrc</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>export</span> <span style=color:#b8860b>BASH_COMPLETION_COMPAT_DIR</span><span style=color:#666>=</span><span style=color:#b44>&#34;/usr/local/etc/bash_completion.d&#34;</span>
</span></span><span style=display:flex><span><span style=color:#666>[[</span> -r <span style=color:#b44>&#34;/usr/local/etc/profile.d/bash_completion.sh&#34;</span> <span style=color:#666>]]</span> <span style=color:#666>&amp;&amp;</span> . <span style=color:#b44>&#34;/usr/local/etc/profile.d/bash_completion.sh&#34;</span>
</span></span></code></pre></div><p>Muat ulang terminalmu dan pastikan bash-completion v2 sudah terinstal dengan perintah <code>type _init_completion</code>.</p><h3 id=menyalakan-penyelesaian-otomatis-kubectl>Menyalakan penyelesaian otomatis kubectl</h3><p>Sekarang kamu harus memastikan bahwa skrip penyelesaian untuk <code>kubectl</code> sudah dimasukkan sebagai sumber penyelesaian otomatis di semua sesi terminal. Kamu dapat melakukannya dengan beberapa cara:</p><ul><li><p>Masukkan skrip penyelesaian sebagai sumber di berkas <code>~/.bashrc</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b44>&#39;source &lt;(kubectl completion bash)&#39;</span> &gt;&gt;~/.bashrc
</span></span></code></pre></div></li><li><p>Menambahkan skrip penyelesaian ke direktori <code>/etc/bash_completion.d</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl completion bash &gt;/etc/bash_completion.d/kubectl
</span></span></code></pre></div></li><li><p>Jika kamu menggunakan alias untuk <code>kubectl</code>, kamu masih dapat menggunakan fitur penyelesaian otomatis dengan menjalankan perintah:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b44>&#39;alias k=kubectl&#39;</span> &gt;&gt;~/.bashrc
</span></span><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b44>&#39;complete -F __start_kubectl k&#39;</span> &gt;&gt;~/.bashrc
</span></span></code></pre></div></li><li><p>Jika kamu menginstal <code>kubectl</code> dengan Homebrew (seperti yang sudah dijelaskan <a href=#install-with-homebrew-on-macos>di atas</a>), maka skrip penyelesaian untuk <code>kubectl</code> sudah berada di <code>/usr/local/etc/bash_completion.d/kubectl</code>. Kamu tidak perlu melakukan apa-apa lagi.</p></li></ul><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> bash-completion v2 yang diinstal dengan Homebrew meletakkan semua berkas nya di direktori <code>BASH_COMPLETION_COMPAT_DIR</code>, itulah alasannya dua cara terakhir dapat bekerja.</div><p>Setelah memuat ulang terminal, penyelesaian otomatis dari <code>kubectl</code> seharusnya sudah dapat bekerja.</p></div><div id=kubectl-autocompletion-2 class=tab-pane role=tabpanel aria-labelledby=kubectl-autocompletion-2><p><p>Skrip penyelesaian (<em>completion script</em>) <code>kubectl</code> untuk Zsh dapat dibuat dengan perintah <code>kubectl completion zsh</code>. Masukkan skrip tersebut ke dalam terminal sebagai sumber untuk menyalakan penyelesaian otomatis dari <code>kubectl</code>.</p><p>Tambahkan baris berikut di berkas <code>~/.zshrc</code> untuk menyalakan penyelesaian otomatis dari <code>kubectl</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>source</span> &lt;<span style=color:#666>(</span>kubectl completion zsh<span style=color:#666>)</span>
</span></span></code></pre></div><p>Jika kamu menggunakan alias untuk <code>kubectl</code>, kamu masih dapat menggunakan fitur penyelesaian otomatis dengan menjalankan perintah:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b44>&#39;alias k=kubectl&#39;</span> &gt;&gt;~/.zshrc
</span></span><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b44>&#39;compdef __start_kubectl k&#39;</span> &gt;&gt;~/.zshrc
</span></span></code></pre></div><p>Setelah memuat ulang terminal, penyelesaian otomatis dari <code>kubectl</code> seharusnya sudah dapat bekerja.</p><p>Jika kamu mendapatkan pesan gagal seperti <code>complete:13: command not found: compdef</code>, maka tambahkan teks berikut ke awal berkas <code>~/.zshrc</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>autoload -Uz compinit
</span></span><span style=display:flex><span>compinit
</span></span></code></pre></div></div></div><h2 id=selanjutnya>Selanjutnya</h2><ul><li><a href=/id/docs/tasks/tools/install-minikube/>Menginstal Minikube.</a></li><li>Lihat <a href=/docs/setup/>panduan persiapan</a> untuk mencari tahu tentang pembuatan klaster.</li><li><a href=/docs/tasks/access-application-cluster/service-access-application-cluster/>Pelajari cara untuk menjalankan dan mengekspos aplikasimu.</a></li><li>Jika kamu membutuhkan akses ke klaster yang tidak kamu buat, lihat <a href=/id/docs/tasks/access-application-cluster/configure-access-multiple-clusters/>dokumen Berbagi Akses Klaster</a>.</li><li>Baca <a href=/docs/reference/kubectl/kubectl/>dokumen referensi kubectl</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-964bdff888520740e5e221695245678d>4.2 - Menjalankan Tugas-Tugas Otomatis dengan CronJob</h1><p>Kamu dapat menggunakan <a class=glossary-tooltip title='A repeating task (a Job) that runs on a regular schedule.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/cron-jobs/ target=_blank aria-label=CronJob>CronJob</a> untuk menjalankan <a class=glossary-tooltip title='Tugas terbatas atau bertumpuk (batch) yang berjalan sampai selesai.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/job/ target=_blank aria-label=Job>Job</a> yang dijadwalkan berbasis waktu. Job akan berjalan seperti pekerjaan-pekerjaan <a href=https://en.wikipedia.org/wiki/Cron>Cron</a> di Linux atau sistem UNIX.</p><p>CronJob sangat berguna untuk membuat pekerjaan yang berjalan secara periodik dan berulang, misalnya menjalankan (<em>backup</em>) atau mengirim email.
CronJob juga dapat menjalankan pekerjaan individu pada waktu tertentu, misalnya jika kamu ingin menjadwalkan sebuah pekerjaan dengan periode aktivitas yang rendah.</p><p>CronJob memiliki keterbatasan dan kekhasan.
Misalnya, dalam keadaan tertentu, sebuah CronJob dapat membuat banyak Job.
Karena itu, Job haruslah <em>idempotent.</em></p><p>Untuk informasi lanjut mengenai keterbatasan, lihat <a href=/id/docs/concepts/workloads/controllers/cron-jobs>CronJob</a>.</p><h2 id=sebelum-kamu-memulai>Sebelum kamu memulai</h2><ul><li><p>Kamu harus memiliki klaster Kubernetes, dan perangkat baris perintah kubectl
juga harus dikonfigurasikan untuk berkomunikasi dengan klastermu. Jika kamu
belum memiliki klaster, kamu dapat membuatnya dengan menggunakan
<a href=/id/docs/tasks/tools/#minikube>minikube</a>,
atau kamu juga dapat menggunakan salah satu dari tempat mencoba Kubernetes berikut ini:</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>Bermain dengan Kubernetes</a></li></ul></li></ul><h2 id=membuat-sebuah-cronjob>Membuat Sebuah CronJob</h2><p>CronJob membutuhkan sebuah berkas konfigurasi.
Ini adalah contoh dari berkas konfigurasi CronJob <code>.spec</code> yang akan mencetak waktu sekarang dan pesan "hello" setiap menit:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/application/job/cronjob.yaml download=application/job/cronjob.yaml><code>application/job/cronjob.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("application-job-cronjob-yaml")' title="Copy application/job/cronjob.yaml to clipboard"></img></div><div class=includecode id=application-job-cronjob-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>batch/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>CronJob<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>schedule</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;* * * * *&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>jobTemplate</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- /bin/sh<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- -c<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- date; echo Hello from the Kubernetes cluster<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>OnFailure<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Jalankan contoh CronJob menggunakan perintah berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f https://k8s.io/examples/application/job/cronjob.yaml
</span></span></code></pre></div><p>Keluaran akan mirip dengan ini:</p><pre tabindex=0><code>cronjob.batch/hello created
</code></pre><p>Kamu juga dapat menggunakan <code>kubectl run</code> untuk membuat sebuah CronJob tanpa menulis sebuah konfigurasi yang lengkap:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl run hello --schedule<span style=color:#666>=</span><span style=color:#b44>&#34;*/1 * * * *&#34;</span> --restart<span style=color:#666>=</span>OnFailure --image<span style=color:#666>=</span>busybox -- /bin/sh -c <span style=color:#b44>&#34;date; echo Hello from the Kubernetes cluster&#34;</span>
</span></span></code></pre></div><p>Setelah membuat sebuah CronJob, untuk mengecek statusnya kamu dapat menggunakan perintah berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get cronjob hello
</span></span></code></pre></div><p>Keluaran akan mirip dengan ini:</p><pre tabindex=0><code>NAME    SCHEDULE      SUSPEND   ACTIVE   LAST SCHEDULE   AGE
hello   */1 * * * *   False     0        &lt;none&gt;          10s
</code></pre><p>Seperti yang kamu lihat dari hasil perintah di atas, CronJob belum menjadwalkan atau menjalankan pekerjaan apa pun.
Waktu yang biasanya dibutuhkan untuk mengamati Job hingga Job tersebut dibuat akan membutuhkan sekitar satu menit:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get <span style=color:#a2f>jobs</span> --watch
</span></span></code></pre></div><p>Keluaran akan mirip dengan ini:</p><pre tabindex=0><code>NAME               COMPLETIONS   DURATION   AGE
hello-4111706356   0/1                      0s
hello-4111706356   0/1           0s         0s
hello-4111706356   1/1           5s         5s
</code></pre><p>Sekarang kamu telah melihat satu Job berjalan yang dijadwalkan oleh "hello" CronJob.
Kamu dapat berhenti mengamati Job dan melihat CronJob lagi untuk melihat CronJob menjadwalkan sebuah Job:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get cronjob hello
</span></span></code></pre></div><p>Keluaran akan mirip dengan ini:</p><pre tabindex=0><code>NAME    SCHEDULE      SUSPEND   ACTIVE   LAST SCHEDULE   AGE
hello   */1 * * * *   False     0        50s             75s
</code></pre><p>Kamu dapat melihat bahwa CronJob <code>hello</code> berhasil menjadwalkan sebuah Job pada waktu yang ditentukan dalam <code>LAST SCHEDULE</code>. Saat ini ada 0 Job yang aktif, berarti sebuah Job telah selesai atau gagal.</p><p>Sekarang, temukan Pod yang dibuat oleh jadwal Job terakhir dan melihat keluaran bawaan dari salah satu Pod.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Nama Job dan nama Pod itu berbeda.</div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Ganti &#34;hello-4111706356&#34; dengan nama Job di sistem kamu</span>
</span></span><span style=display:flex><span><span style=color:#b8860b>pods</span><span style=color:#666>=</span><span style=color:#a2f;font-weight:700>$(</span>kubectl get pods --selector<span style=color:#666>=</span>job-name<span style=color:#666>=</span>hello-4111706356 --output<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>={</span>.items<span style=color:#666>[</span>*<span style=color:#666>]</span>.metadata.name<span style=color:#666>}</span><span style=color:#a2f;font-weight:700>)</span>
</span></span></code></pre></div><p>Menampilkan log sebuah Pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl logs <span style=color:#b8860b>$pods</span>
</span></span></code></pre></div><p>Keluaran akan mirip dengan ini:</p><pre tabindex=0><code>Fri Feb 22 11:02:09 UTC 2019
Hello from the Kubernetes cluster
</code></pre><h2 id=menghapus-sebuah-cronjob>Menghapus sebuah CronJob</h2><p>Ketika kamu tidak membutuhkan sebuah CronJob lagi, kamu dapat megnhapusnya dengan perintah <code>kubectl delete cronjob &lt;cronjob name></code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete cronjob hello
</span></span></code></pre></div><p>Menghapus CronJob akan menghapus semua Job dan Pod yang telah terbuat dan menghentikanya dari pembuatan Job tambahan.
Kamu dapat membaca lebih lanjut tentang menghapus Job di <a href=/id/docs/concepts/workloads/controllers/garbage-collection/><em>garbage collection</em></a>.</p><h2 id=menulis-speifikasi-sebuah-cron>Menulis Speifikasi Sebuah Cron</h2><p>Seperti semua konfigurasi Kubernetes, sebuah CronJob membutuhkan <em>field</em> <code>apiVersion</code>, <code>kind</code>, dan <code>metadata</code>. Untuk informasi
umum tentang bekerja dengan berkas konfigurasi, lihat dokumentasi <a href=/docs/user-guide/deploying-applications>men-<em>deploy</em> aplikasi</a>,
dan <a href=/docs/user-guide/working-with-resources>mengunakan kubectl untuk manajemen sumber daya</a>.</p><p>Sebuah konfigurasi CronJob juga membutuhkan sebuah <a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status>bagian <code>.spec</code></a>.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Semua modifikasi pada sebuah CronJob, terutama <code>.spec</code>, akan diterapkan pada proses berikut.</div><h3 id=penjadwalan>Penjadwalan</h3><p><code>.spec.schedule</code> adalah <em>field</em> yang wajib diisi dari sebuah <code>.spec</code>
Dibutuhkan sebuah format string <a href=https://en.wikipedia.org/wiki/Cron>Cron</a>, misalnya <code>0 * * * *</code> atau <code>@hourly</code>, sebagai jadwal Job untuk dibuat dan dieksekusi.</p><p>Format ini juga mencakup nilai langkah "Vixie cron". Seperti penjelasan di <a href=https://www.freebsd.org/cgi/man.cgi?crontab%285%29>FreeBSD manual</a>:</p><blockquote><p>Nilai langkah dapat digunakan bersama dengan rentang. Sebuah rentang diikuti dengan
<code>/&lt;number></code> menentukan lompatan angka melalui rentang.
Misalnya, <code>0-23/2</code> dapat digunakan dalam jam untuk menentukan
perintah akan dieksekusi setiap jam (alternatif dalam bawaan v7 adalah
<code>0,2,4,6,8,10,12,14,16,18,20,22</code>). Langkah-langkah juga diizinkan setelah
tanda bintang, jadi jika kamu menginginkan "setiap dua jam", gunakan saja <code>*/2</code>.</p></blockquote><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Sebuah tanda tanya (<code>?</code>) dalam penjadwalan memiliki makna yang sama dengan tanda bintang <code>*</code>, yaitu, singkatan dari nilai apa pun yang tersedia untuk <em>field</em> tertentu.</div><h3 id=templat-job>Templat Job</h3><p><code>.spec.JobTemplate</code> adalah templat untuk sebuah Job, dan itu wajib.
Templat Job memiliki skema yang sama dengan <a href=/id/docs/concepts/workloads/controllers/job/>Job</a>, kecuali jika bersarang dan tidak memiliki sebuah <code>apiVersion</code> atau <code>kind</code>.
Untuk informasi lebih lanjut tentang menulis sebuah Job <code>.spec</code> lihat <a href=/id/docs/concepts/workloads/controllers/job/#writing-a-job-spec>Menulis spesifikasi Job</a>.</p><h3 id=starting-deadline><em>Starting Deadline</em></h3><p><em>Field</em> <code>.spec.startingDeadlineSeconds</code> adalah <em>field</em> opsional.
<em>Field</em> tersebut berarti batas waktu dalam satuan detik untuk memulai sebuah Job jika Job melewatkan waktu yang telah dijadwalkan karena alasan apapun.
Setelah mencapai batas waktu, CronJob tidak akan memulai sebuah Job.
Job yang tidak memenuhi batas waktu, dengan cara ini dianggap sebagai Job yang gagal.
Jika <em>field</em> ini tidak ditentukan, maka Job tidak memiliki batas waktu.</p><p><em>Controller</em> CronJob menghitung berapa banyak jadwal yang terlewat untuk sebuah CronJob. jika lebih dari 100 jadwal yang terlewat, maka tidak ada lagi CronJob yang akan dijadwalkan. Ketika <code>.spec.startingDeadlineSeconds</code> tidak disetel, CronJob Controller menghitung jadwal yang terlewat dari <code>status.lastScheduleTime</code> hingga sekarang.</p><p>Misalnya, sebuah CronJob seharusnya berjalan setiap menit, <code>status.lastScheduleTime</code> CronJob adalah pukul 5:00am, tetapi sekarang pukul 07:00am. Itu berarti ada 120 jadwal yang terlewat, maka tidak ada lagi CronJob yang akan dijadwalkan.</p><p>Jika <em>field</em> <code>.spec.startingDeadlineSeconds</code> disetel (tidak kosong), CronJob Controller akah menghitung berapa banyak Job yang terlewat dari nilai <code>.spec.startingDeadlineSeconds</code> hingga sekarang.</p><p>Misalnya, jika disetel ke <code>200</code>, CronJob Controller akan menghitung jadwal yang terlewat dalam 200 detik terakhir. Pada kasus ini, jika terdapat lebih dari 100 jadwal yang terlewat dalam 200 detik terakhir, maka tidak ada lagi CronJob yang akan dijadwalkan.</p><h3 id=kebijakan-concurrency>Kebijakan <em>Concurrency</em></h3><p><em>Field</em> <code>.spec.concurrencyPolicy</code> juga opsional.
<em>Field</em> tersebut menentukan bagaimana memperlakukan eksekusi <em>concurrent</em> dari sebuah Job yang dibuat oleh CronJob.
Kamu dapat menetapkan hanya satu dari kebijakan <em>concurrency</em>:</p><ul><li><code>Allow</code> (bawaan): CronJob mengizinkan Job berjalan secara <em>concurrent</em></li><li><code>Forbid</code> : Job tidak mengizinkan Job berjalan secara <em>concurrent</em>; jika sudah saatnya untuk menjalankan Job baru dan Job sebelumnya belum selesai, maka CronJob akan melewatkan Job baru yang akan berjalan</li><li><code>Replace</code>: Jika sudah saatnya untuk menjalankan Job baru dan Job sebelumnya belum selesai, maka CronJob akan mengganti Job yang sedang berjalan dengan Job baru.</li></ul><p>Perhatikan bahwa kebijakan <em>concurrency</em> hanya berlaku untuk Job yang dibuat dengan CronJob yang sama.
Jika terdapat banyak CronJob, Job akan selalu diizinkan untuk berjalan secara <em>concurrent</em>.</p><h3 id=penangguhan>Penangguhan</h3><p><em>Field</em> <code>.spec.suspend</code> juga opsional.
Jika <em>field</em> tersebut disetel <code>true</code>, semua eksekusi selanjutnya akan ditangguhkan.
Konfigurasi ini tidak dapat berlaku untuk eksekusi yang sudah dimulai.
Secara bawaan <em>false</em>.</p><div class="alert alert-warning caution callout" role=alert><strong>Perhatian:</strong> Eksekusi yang ditangguhkan selama waktu yang dijadwalkan dihitung sebagai Job yang terlewat.
Ketika <code>.spec.suspend</code> diubah dari <code>true</code> ke <code>false</code> pada CronJob yang memiliki konfigurasi tanpa <a href=#starting-deadline>batas waktu</a>, Job yang terlewat akan dijadwalkan segera.</div><h3 id=batas-riwayat-pekerjaan>Batas Riwayat Pekerjaan</h3><p><em>Field</em> <code>.spec.successfulJobHistoryLimit</code> dan <code>.spec.failedJobHistoryLimit</code> juga opsional.
<em>Field</em> tersebut menentukan berapa banyak Job yang sudah selesai dan gagal yang harus disimpan.
Secara bawaan, masing-masing <em>field</em> tersebut disetel 3 dan 1. Mensetel batas ke <code>0</code> untuk menjaga tidak ada Job yang sesuai setelah Job tersebut selesai.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-f5da33b976758a9183018c421eb83f58>4.3 - Mengatur Pod dan Kontainer</h1></div><div class=td-content><h1 id=pg-e6dd9300cf3a955f7cdfe77fb5d15292>4.3.1 - Menetapkan Sumber Daya Memori untuk Container dan Pod</h1><p>Laman ini menunjukkan bagaimana menetapkan permintaan dan batasan memori untuk Container.
Container dijamin memiliki memori sebanyak yang diminta,
tetapi tidak diperbolehkan untuk menggunakan memori melebihi batas.</p><h2 id=sebelum-kamu-memulai>Sebelum kamu memulai</h2><p><p>Kamu harus memiliki klaster Kubernetes, dan perangkat baris perintah kubectl
juga harus dikonfigurasikan untuk berkomunikasi dengan klastermu. Jika kamu
belum memiliki klaster, kamu dapat membuatnya dengan menggunakan
<a href=/id/docs/tasks/tools/#minikube>minikube</a>,
atau kamu juga dapat menggunakan salah satu dari tempat mencoba Kubernetes berikut ini:</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>Bermain dengan Kubernetes</a></li></ul>Untuk melihat versi, tekan <code>kubectl version</code>.</p><p>Setiap Node pada klaster kamu harus memiliki memori setidaknya 300 MiB.</p><p>Beberapa langkah pada laman ini mengharuskan kamu menjalankan Service
<a href=https://github.com/kubernetes-incubator/metrics-server><em>metrics-server</em></a>
pada klaster kamu. Jika kamu memiliki <em>metrics-server</em>
yang sudah berjalan, kamu dapat melewati langkah-langkah berikut ini.</p><p>Jika kamu menjalankan Minikube, jalankan perintah berikut untuk mengaktifkan
<em>metrics-server</em>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>minikube addons <span style=color:#a2f>enable</span> metrics-server
</span></span></code></pre></div><p>Untuk melihat apakah <em>metrics-server</em> sudah berjalan, atau penyedia lain dari API metrik sumber daya
(<code>metrics.k8s.io</code>), jalankan perintah berikut ini:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get apiservices
</span></span></code></pre></div><p>Jika API metrik sumber daya telah tersedia, keluarannya meliputi seperti
acuan pada <code>metrics.k8s.io</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME
</span></span><span style=display:flex><span>v1beta1.metrics.k8s.io
</span></span></code></pre></div><h2 id=membuat-namespace>Membuat Namespace</h2><p>Buat Namespace sehingga sumber daya yang kamu buat dalam latihan ini
terisolasi dari klaster kamu yang lain.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create namespace mem-example
</span></span></code></pre></div><h2 id=menentukan-permintaan-memori-dan-batasan-memori>Menentukan permintaan memori dan batasan memori</h2><p>Untuk menentukan permintaan memori untuk Container, sertakan <em>field</em> <code>resources:requests</code>
pada manifes sumber daya dari Container. Untuk menentukan batasan memori, sertakan <code>resources:limits</code>.</p><p>Dalam latihan ini, kamu akan membuat Pod yang memiliki satu Container. Container memiliki permintaan memori
sebesar 100 MiB dan batasan memori sebesar 200 MiB. Berikut berkas konfigurasi
untuk Pod:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/pods/resource/memory-request-limit.yaml download=pods/resource/memory-request-limit.yaml><code>pods/resource/memory-request-limit.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-resource-memory-request-limit-yaml")' title="Copy pods/resource/memory-request-limit.yaml to clipboard"></img></div><div class=includecode id=pods-resource-memory-request-limit-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>memory-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>mem-example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>memory-demo-ctr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>polinux/stress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;200Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;100Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;stress&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;--vm&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;--vm-bytes&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;150M&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;--vm-hang&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Bagian <code>args</code> dalam berkas konfigurasi memberikan argumen untuk Container pada saat dimulai.
Argumen<code>"--vm-bytes", "150M"</code> memberi tahu Container agar mencoba mengalokasikan memori sebesar 150 MiB.</p><p>Buatlah Pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/resource/memory-request-limit.yaml --namespace<span style=color:#666>=</span>mem-example
</span></span></code></pre></div><p>Verifikasi apakah Container dalam Pod sudah berjalan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod memory-demo --namespace<span style=color:#666>=</span>mem-example
</span></span></code></pre></div><p>Lihat informasi mendetil tentang Pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod memory-demo --output<span style=color:#666>=</span>yaml --namespace<span style=color:#666>=</span>mem-example
</span></span></code></pre></div><p>Keluarannya menunjukkan bahwa satu Container dalam Pod memiliki permintaan memori sebesar 100 MiB
dan batasan memori sebesar 200 MiB.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>200Mi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>100Mi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Jalankan <code>kubectl top</code> untuk mengambil metrik dari Pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl top pod memory-demo --namespace<span style=color:#666>=</span>mem-example
</span></span></code></pre></div><p>Keluarannya menunjukkan bahwa Pod menggunakan memori sekitar 162.900.000 byte, dimana
sekitar 150 MiB. Ini lebih besar dari permintaannya sebesar 100 MiB Pod, tetapi masih di dalam
batasan Pod sebesar 200 MiB.</p><pre tabindex=0><code>NAME                        CPU(cores)   MEMORY(bytes)
memory-demo                 &lt;something&gt;  162856960
</code></pre><p>Hapuslah Pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pod memory-demo --namespace<span style=color:#666>=</span>mem-example
</span></span></code></pre></div><h2 id=melebihi-batasan-memori-dari-container>Melebihi batasan memori dari Container</h2><p>Container dapat melebihi permintaan memorinya jika Node memiliki memori yang tersedia. Tapi sebuah Container
tidak diperbolehkan untuk menggunakan lebih dari batasan memorinya. Jika Container mengalokasikan lebih banyak memori daripada
batasannya, Container menjadi kandidat untuk dihentikan. Jika Container terus berlanjut
mengkonsumsi memori melebihi batasnya, maka Container akan diakhiri. Jika Container dihentikan dan bisa
di mulai ulang, kubelet akan memulai ulang, sama seperti jenis kegagalan <em>runtime</em> yang lainnya.</p><p>Dalam latihan ini, kamu membuat Pod yang mencoba mengalokasikan lebih banyak memori dari batasannya.
Berikut adalah berkas konfigurasi untuk Pod yang memiliki satu Container dengan berkas
permintaan memori sebesar 50 MiB dan batasan memori sebesar 100 MiB:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/pods/resource/memory-request-limit-2.yaml download=pods/resource/memory-request-limit-2.yaml><code>pods/resource/memory-request-limit-2.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-resource-memory-request-limit-2-yaml")' title="Copy pods/resource/memory-request-limit-2.yaml to clipboard"></img></div><div class=includecode id=pods-resource-memory-request-limit-2-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>memory-demo-2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>mem-example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>memory-demo-2-ctr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>polinux/stress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;50Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;100Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;stress&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;--vm&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;--vm-bytes&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;250M&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;--vm-hang&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Dalam bagian <code>args</code> dari berkas konfigurasi, kamu dapat melihat bahwa Container tersebut
akan mencoba mengalokasikan memori sebesar 250 MiB, yang jauh di atas batas yaitu 100 MiB.</p><p>Buatlah Pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/resource/memory-request-limit-2.yaml --namespace<span style=color:#666>=</span>mem-example
</span></span></code></pre></div><p>Lihat informasi mendetail tentang Pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod memory-demo-2 --namespace<span style=color:#666>=</span>mem-example
</span></span></code></pre></div><p>Sampai sini, Container mungkin sedang berjalan atau dimatikan. Ulangi perintah sebelumnya hingga Container dimatikan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME            READY     STATUS      RESTARTS   AGE
</span></span><span style=display:flex><span>memory-demo-2   0/1       OOMKilled   <span style=color:#666>1</span>          24s
</span></span></code></pre></div><p>Dapatkan tampilan yang lebih mendetail tentang status Container:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod memory-demo-2 --output<span style=color:#666>=</span>yaml --namespace<span style=color:#666>=</span>mem-example
</span></span></code></pre></div><p>Keluarannya menunjukkan bahwa Container dimatikan karena kehabisan memori (OOM):</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>lastState:
</span></span><span style=display:flex><span>   terminated:
</span></span><span style=display:flex><span>     containerID: docker://65183c1877aaec2e8427bc95609cc52677a454b56fcb24340dbd22917c23b10f
</span></span><span style=display:flex><span>     exitCode: <span style=color:#666>137</span>
</span></span><span style=display:flex><span>     finishedAt: 2017-06-20T20:52:19Z
</span></span><span style=display:flex><span>     reason: OOMKilled
</span></span><span style=display:flex><span>     startedAt: null
</span></span></code></pre></div><p>Container dalam latihan ini dapat dimulai ulang, sehingga kubelet akan memulai ulangnya. Ulangi
perintah ini beberapa kali untuk melihat bahwa Container berulang kali dimatikan dan dimulai ulang:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod memory-demo-2 --namespace<span style=color:#666>=</span>mem-example
</span></span></code></pre></div><p>Keluarannya menunjukkan bahwa Container dimatikan, dimulai ulang, dimatikan lagi, dimulai ulang lagi, dan seterusnya:</p><pre tabindex=0><code>kubectl get pod memory-demo-2 --namespace=mem-example
NAME            READY     STATUS      RESTARTS   AGE
memory-demo-2   0/1       OOMKilled   1          37s
</code></pre><pre tabindex=0><code>
kubectl get pod memory-demo-2 --namespace=mem-example
NAME            READY     STATUS    RESTARTS   AGE
memory-demo-2   1/1       Running   2          40s
</code></pre><p>Lihat informasi mendetail tentang riwayat Pod:</p><pre tabindex=0><code>kubectl describe pod memory-demo-2 --namespace=mem-example
</code></pre><p>Keluarannya menunjukkan bahwa Container dimulai dan gagal berulang kali:</p><pre tabindex=0><code>... Normal  Created   Created container with id 66a3a20aa7980e61be4922780bf9d24d1a1d8b7395c09861225b0eba1b1f8511
... Warning BackOff   Back-off restarting failed container
</code></pre><p>Lihat informasi mendetail tentang Node klaster Anda:</p><pre tabindex=0><code>kubectl describe nodes
</code></pre><p>Keluarannya mencakup rekaman Container yang dimatikan karena kondisi kehabisan memori:</p><pre tabindex=0><code>Warning OOMKilling Memory cgroup out of memory: Kill process 4481 (stress) score 1994 or sacrifice child
</code></pre><p>Hapus Pod kamu:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pod memory-demo-2 --namespace<span style=color:#666>=</span>mem-example
</span></span></code></pre></div><h2 id=menentukan-permintaan-memori-yang-terlalu-besar-untuk-node-kamu>Menentukan permintaan memori yang terlalu besar untuk Node kamu</h2><p>Permintaan dan batasan memori yang dikaitkan dengan Container, berguna untuk berpikir
apakah sebuah Pod yang memiliki permintaan dan batasan memori. Permintaan memori untuk Pod tersebut adalah
jumlah permintaan memori untuk semua Container dalam Pod. Begitu juga dengan batasan memori
untuk Pod adalah jumlah batasan memori dari semua Container di dalam Pod.</p><p>Penjadwalan Pod didasarkan pada permintaan. Sebuah Pod dijadwalkan untuk berjalan di sebuah Node hanya jika sebuah Node
memiliki cukup memori yang tersedia untuk memenuhi permintaan memori dari Pod tersebut.</p><p>Dalam latihan ini, kamu membuat Pod yang memiliki permintaan memori yang sangat besar sehingga melebihi
kapasitas dari Node mana pun dalam klaster kamu. Berikut adalah berkas konfigurasi untuk Pod yang memiliki
Container dengan permintaan memori 1000 GiB, yang kemungkinan besar melebihi kapasitas
dari setiap Node dalam klaster kamu.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/pods/resource/memory-request-limit-3.yaml download=pods/resource/memory-request-limit-3.yaml><code>pods/resource/memory-request-limit-3.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-resource-memory-request-limit-3-yaml")' title="Copy pods/resource/memory-request-limit-3.yaml to clipboard"></img></div><div class=includecode id=pods-resource-memory-request-limit-3-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>memory-demo-3<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>mem-example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>memory-demo-3-ctr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>polinux/stress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1000Gi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1000Gi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;stress&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;--vm&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;--vm-bytes&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;150M&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;--vm-hang&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Buatlah Pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/resource/memory-request-limit-3.yaml --namespace<span style=color:#666>=</span>mem-example
</span></span></code></pre></div><p>Lihat status Pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod memory-demo-3 --namespace<span style=color:#666>=</span>mem-example
</span></span></code></pre></div><p>Keluarannya menunjukkan bahwa status Pod adalah PENDING. Artinya, Pod tidak dijadwalkan untuk berjalan di Node mana pun, dan Pod akan tetap dalam status PENDING tanpa batas waktu:</p><pre tabindex=0><code>kubectl get pod memory-demo-3 --namespace=mem-example
NAME            READY     STATUS    RESTARTS   AGE
memory-demo-3   0/1       Pending   0          25s
</code></pre><p>Lihat informasi mendetail tentang Pod, termasuk <em>event</em>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe pod memory-demo-3 --namespace<span style=color:#666>=</span>mem-example
</span></span></code></pre></div><p>Keluarannya menunjukkan bahwa Container tidak dapat dijadwalkan karena memori yang tidak cukup pada Node:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>Events:
</span></span><span style=display:flex><span>  ...  Reason            Message
</span></span><span style=display:flex><span>       ------            -------
</span></span><span style=display:flex><span>  ...  FailedScheduling  No nodes are available that match all of the following predicates:: Insufficient memory <span style=color:#666>(</span>3<span style=color:#666>)</span>.
</span></span></code></pre></div><h2 id=satuan-memori>Satuan Memori</h2><p>Sumber daya memori diukur dalam satuan <em>byte</em>. Kamu dapat mengekspresikan memori sebagai bilangan bulat biasa atau
bilangan bulan <em>fixed-point</em> dengan salah satu akhiran ini: E, P, T, G, M, K, Ei, Pi, Ti, Gi, Mi, Ki.
Contoh berikut ini mewakili nilai yang kira-kira sama:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>128974848, 129e6, 129M , 123Mi
</span></span></code></pre></div><p>Hapuslah Pod kamu:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pod memory-demo-3 --namespace<span style=color:#666>=</span>mem-example
</span></span></code></pre></div><h2 id=jika-kamu-tidak-menentukan-batasan-memori>Jika kamu tidak menentukan batasan memori</h2><p>Jika kamu tidak menentukan batasan memori untuk sebuah Container, salah satu dari situasi berikut ini berlaku:</p><ul><li><p>Container tidak memiliki batasan maksimum jumlah memori yang digunakannya. Container
dapat menggunakan semua memori yang tersedia dalam Node dimana Container itu berjalan yang pada gilirannya dapat memanggil penyetop OOM (<em>out-of-memory</em>).
Lebih lanjut, dalam kasus menghentikan OOM, Container tanpa batas sumber daya akan memiliki peluang lebih besar untuk dihentikan.</p></li><li><p>Container berjalan pada Namespace yang memiliki batasan bawaan memori, dan
Container secara otomatis menetapkan batasan bawaan. Administrator klaster dapat menggunakan
<a href=/docs/reference/generated/kubernetes-api/v1.25/#limitrange-v1-core>LimitRange</a>
untuk menentukan batasan memori secara bawaan.</p></li></ul><h2 id=motivasi-untuk-permintaan-dan-batasan-memori>Motivasi untuk permintaan dan batasan memori</h2><p>Dengan mengonfigurasi permintaan dan batasan memori untuk Container yang berjalan pada berkas
klaster, kamu dapat menggunakan sumber daya memori yang tersedia pada Node klaster kamu secara efisien.
Dengan menjaga permintaan memori pada Pod tetap rendah, kamu memberikan kesempatan yang baik untuk Pod tersebut
dijadwalkan. Dengan memiliki batas memori yang lebih besar dari permintaan memori, Anda mencapai dua hal:</p><ul><li>Pod dapat memiliki aktivitas yang bersifat <em>burst</em> dengan memanfaatkan memori yang kebetulan tersedia.</li><li>Jumlah memori yang dapat digunakan Pod selama keadaan <em>burst</em> dibatasi pada jumlah yang wajar.</li></ul><h2 id=membersihkan>Membersihkan</h2><p>Hapus Namespace kamu. Ini akan menghapus semua Pod yang kamu buat untuk tugas ini:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete namespace mem-example
</span></span></code></pre></div><h2 id=selanjutnya>Selanjutnya</h2><h3 id=untuk-pengembang-aplikasi>Untuk pengembang aplikasi</h3><ul><li><p><a href=/docs/tasks/configure-pod-container/assign-cpu-resource/>Menetapkan sumber daya CPU ke Container dan Pod</a></p></li><li><p><a href=/docs/tasks/configure-pod-container/quality-service-pod/>Mengonfigurasi <em>Quality of Service</em> untuk Pod</a></p></li></ul><h3 id=untuk-administrator-klaster>Untuk administrator klaster</h3><ul><li><p><a href=/id/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/>Mengonfigurasi permintaan dan batasan bawaan memori untuk Namespace</a></p></li><li><p><a href=/id/docs/tasks/administer-cluster/manage-resources/cpu-default-namespace/>Mengonfigurasi permintaan dan batasan bawaan CPU untuk Namespace</a></p></li><li><p><a href=/id/docs/tasks/administer-cluster/manage-resources/memory-constraint-namespace/>Mengonfigurasi batasan memori minimum dan maksimum untuk Namespace</a></p></li><li><p><a href=/id/docs/tasks/administer-cluster/manage-resources/cpu-constraint-namespace/>Mengonfigurasi batasan CPU minimum dan maksimum untuk Namespace</a></p></li><li><p><a href=/id/docs/tasks/administer-cluster/manage-resources/quota-memory-cpu-namespace/>Mengonfigurasi kuota CPU dan memori untuk Namespace</a></p></li><li><p><a href=/id/docs/tasks/administer-cluster/manage-resources/quota-pod-namespace/>Mengonfigurasi kuota Pod untuk Namespace</a></p></li><li><p><a href=/id/docs/tasks/administer-cluster/quota-api-object/>Mengonfigurasi kuota untuk objek API</a></p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-904cea8c8efd5c0d33adbfe579ec2dd2>4.3.2 - Konfigurasi Quality of Service untuk Pod</h1><p>Laman ini menunjukkan bagaimana mengonfigurasi Pod agar ditempatkan pada kelas <em>Quality of Service</em> (QoS) tertentu.
Kubernetes menggunakan kelas QoS untuk membuat keputusan tentang
penjadwalan dan pengeluaran Pod.</p><h2 id=sebelum-kamu-memulai>Sebelum kamu memulai</h2><p><p>Kamu harus memiliki klaster Kubernetes, dan perangkat baris perintah kubectl
juga harus dikonfigurasikan untuk berkomunikasi dengan klastermu. Jika kamu
belum memiliki klaster, kamu dapat membuatnya dengan menggunakan
<a href=/id/docs/tasks/tools/#minikube>minikube</a>,
atau kamu juga dapat menggunakan salah satu dari tempat mencoba Kubernetes berikut ini:</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>Bermain dengan Kubernetes</a></li></ul>Untuk melihat versi, tekan <code>kubectl version</code>.</p><h2 id=qos-classes>Kelas QoS</h2><p>Saat membuat Pod, Kubernetes menempatkan salah satu kelas QoS berikut untuknya:</p><ul><li>Guaranteed</li><li>Burstable</li><li>BestEffort</li></ul><h2 id=membuat-sebuah-namespace>Membuat sebuah Namespace</h2><p>Buat sebuah Namespace sehingga sumber daya yang kamu buat dalam latihan ini
terisolasi dari klaster kamu yang lain.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create namespace qos-example
</span></span></code></pre></div><h2 id=membuat-sebuah-pod-yang-mendapatkan-penempatan-kelas-qos-guaranteed>Membuat sebuah Pod yang mendapatkan penempatan kelas QoS Guaranteed</h2><p>Agar sebuah Pod memiliki kelas QoS Guaranteed:</p><ul><li>Setiap Container, termasuk Container pemulai, di dalam Pod harus memiliki batasan memori dan permintaan memori dengan nilai yang sama.</li><li>Setiap Container, termasuk Container pemulai, di dalam Pod harus memiliki batasan CPU dan permintaan CPU dengan nilai yang sama.</li></ul><p>Berikut adalah berkas konfigurasi untuk sebuah Pod dengan satu Container. Container tersebut memiliki sebuah batasan memori dan sebuah
permintaan memori, keduanya sama dengan 200MiB. Container itu juga mempunyai batasan CPU dan permintaan CPU yang sama sebesar 700 milliCPU:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/pods/qos/qos-pod.yaml download=pods/qos/qos-pod.yaml><code>pods/qos/qos-pod.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-qos-qos-pod-yaml")' title="Copy pods/qos/qos-pod.yaml to clipboard"></img></div><div class=includecode id=pods-qos-qos-pod-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>qos-example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-ctr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;200Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;700m&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;200Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;700m&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Buatlah Pod：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f https://k8s.io/examples/pods/qos/qos-pod.yaml --namespace<span style=color:#666>=</span>qos-example
</span></span></code></pre></div><p>Tampilkan informasi detail Pod yang telah dibuat:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod qos-demo --namespace<span style=color:#666>=</span>qos-example --output<span style=color:#666>=</span>yaml
</span></span></code></pre></div><p>Keluaran dari perintah di atas menunjukkan Kubernetes memberikan kelas QoS Guaranteed pada Pod. Keluaran tersebut juga
membuktikan bahwa Container pada Pod memiliki permintaan memori yang sesuai dengan batasan memori dan permintaan CPU yang juga sesuai dengan batasan CPU yang dispesifikasikan.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>700m<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>200Mi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>700m<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>200Mi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>qosClass</span>:<span style=color:#bbb> </span>Guaranteed<span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Jika sebuah Container hanya menspesifikasikan batasan memori tanpa menentukan permintaan memori, maka Kubernetes akan
secara otomatis menetapkan permintaan memori yang sesuai dengan batasan memori yang dicantumkan. Sama halnya jika sebuah Container menspesifikasikan batasan
CPU tanpa menentukan permintaan CPU, maka Kubernetes akan secara otomatis menetapkan permintaan CPU yang sesuai
dengan batasan CPU yang dicantumkan.</div><p>Hapuslah Pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pod qos-demo --namespace<span style=color:#666>=</span>qos-example
</span></span></code></pre></div><h2 id=membuat-sebuah-pod-yang-mendapatkan-penempatan-kelas-qos-burstable>Membuat sebuah Pod yang mendapatkan penempatan kelas Qos Burstable</h2><p>Sebuah Pod akan mendapatkan kelas QoS Burstable apabila:</p><ul><li>Pod tidak memenuhi kriteria untuk kelas QoS Guaranteed.</li><li>Setidaknya ada satu Container di dalam Pod dengan permintaan memori atau CPU.</li></ul><p>Berikut adalah berkas konfigurasi untuk Pod dengan satu Container. Container yang dimaksud memiliki batasan memori sebesar 200MiB
dan permintaan memori sebesar 100MiB.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/pods/qos/qos-pod-2.yaml download=pods/qos/qos-pod-2.yaml><code>pods/qos/qos-pod-2.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-qos-qos-pod-2-yaml")' title="Copy pods/qos/qos-pod-2.yaml to clipboard"></img></div><div class=includecode id=pods-qos-qos-pod-2-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>qos-example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-2-ctr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;200Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;100Mi&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Buatlah Pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f https://k8s.io/examples/pods/qos/qos-pod-2.yaml --namespace<span style=color:#666>=</span>qos-example
</span></span></code></pre></div><p>Tampilkan informasi detail Pod yang telah dibuat:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod qos-demo-2 --namespace<span style=color:#666>=</span>qos-example --output<span style=color:#666>=</span>yaml
</span></span></code></pre></div><p>Keluaran dari perintah di atas menunjukkan Kubernetes memberikan kelas QoS Burstable pada Pod.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>Always<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-2-ctr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>200Mi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>100Mi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>qosClass</span>:<span style=color:#bbb> </span>Burstable<span style=color:#bbb>
</span></span></span></code></pre></div><p>Hapuslah Pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pod qos-demo-2 --namespace<span style=color:#666>=</span>qos-example
</span></span></code></pre></div><h2 id=membuat-sebuah-pod-yang-mendapatkan-penempatan-kelas-qos-besteffort>Membuat sebuah Pod yang mendapatkan penempatan kelas QoS BestEffort</h2><p>Agar Pod mendapatkan kelas QoS BestEffort, Container dalam pod tidak boleh
memiliki batasan atau permintaan memori atau CPU.</p><p>Berikut adalah berkas konfigurasi untuk Pod dengan satu Container. Container yang dimaksud tidak memiliki batasan atau permintaan memori atau CPU apapun.<div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/pods/qos/qos-pod-3.yaml download=pods/qos/qos-pod-3.yaml><code>pods/qos/qos-pod-3.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-qos-qos-pod-3-yaml")' title="Copy pods/qos/qos-pod-3.yaml to clipboard"></img></div><div class=includecode id=pods-qos-qos-pod-3-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-3<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>qos-example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-3-ctr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span></code></pre></div></div></div></p><p>Buatlah Pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f https://k8s.io/examples/pods/qos/qos-pod-3.yaml --namespace<span style=color:#666>=</span>qos-example
</span></span></code></pre></div><p>Tampilkan informasi detail Pod yang telah dibuat:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod qos-demo-3 --namespace<span style=color:#666>=</span>qos-example --output<span style=color:#666>=</span>yaml
</span></span></code></pre></div><p>Keluaran dari perintah di atas menunjukkan Kubernetes memberikan kelas QoS BestEffort pada Pod.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>qosClass</span>:<span style=color:#bbb> </span>BestEffort<span style=color:#bbb>
</span></span></span></code></pre></div><p>Hapuslah Pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pod qos-demo-3 --namespace<span style=color:#666>=</span>qos-example
</span></span></code></pre></div><h2 id=membuat-sebuah-pod-yang-memiliki-dua-container>Membuat sebuah Pod yang memiliki dua Container</h2><p>Berikut adalah konfigurasi berkas untuk Pod yang memiliki dua Container. Satu Container menentukan permintaan memori sebesar 200MiB. Container yang lain tidak menentukan permintaan atau batasan apapun.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/pods/qos/qos-pod-4.yaml download=pods/qos/qos-pod-4.yaml><code>pods/qos/qos-pod-4.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-qos-qos-pod-4-yaml")' title="Copy pods/qos/qos-pod-4.yaml to clipboard"></img></div><div class=includecode id=pods-qos-qos-pod-4-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-4<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>qos-example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-4-ctr-1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;200Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-4-ctr-2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Perhatikan bahwa Pod ini memenuhi kriteria untuk kelas QoS Burstable. Maksudnya, Container tersebut tidak memenuhi
kriteria untuk kelas QoS Guaranteed, dan satu dari Container tersebut memiliki permintaan memori.</p><p>Buatlah Pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f https://k8s.io/examples/pods/qos/qos-pod-4.yaml --namespace<span style=color:#666>=</span>qos-example
</span></span></code></pre></div><p>Tampilkan informasi detail Pod yang telah dibuat:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod qos-demo-4 --namespace<span style=color:#666>=</span>qos-example --output<span style=color:#666>=</span>yaml
</span></span></code></pre></div><p>Keluaran dari perintah di atas menunjukkan Kubernetes memberikan kelas QoS Burstable pada Pod.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-4-ctr-1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>200Mi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-4-ctr-2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>qosClass</span>:<span style=color:#bbb> </span>Burstable<span style=color:#bbb>
</span></span></span></code></pre></div><p>Hapuslah Pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pod qos-demo-4 --namespace<span style=color:#666>=</span>qos-example
</span></span></code></pre></div><h2 id=membersihkan>Membersihkan</h2><p>Hapuslah Namespace:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete namespace qos-example
</span></span></code></pre></div><h2 id=selanjutnya>Selanjutnya</h2><h3 id=untuk-pengembang-aplikasi>Untuk pengembang aplikasi</h3><ul><li><p><a href=/id/docs/tasks/configure-pod-container/assign-memory-resource/>Menetapkan sumber daya memori ke Container dan Pod</a></p></li><li><p><a href=/docs/tasks/configure-pod-container/assign-cpu-resource/>Menetapkan permintaan CPU pada Container dan Pod</a></p></li></ul><h3 id=untuk-administrator-klaster>Untuk administrator klaster</h3><ul><li><p><a href=/id/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/>Mengonfigurasi permintaan dan batasan bawaan memori untuk Namespace</a></p></li><li><p><a href=/id/docs/tasks/administer-cluster/manage-resources/cpu-default-namespace/>Mengonfigurasi permintaan dan batasan bawaan CPU untuk Namespace</a></p></li><li><p><a href=/id/docs/tasks/administer-cluster/manage-resources/memory-constraint-namespace/>Mengonfigurasi batasan memori minimum dan maksimum untuk Namespace</a></p></li><li><p><a href=/id/docs/tasks/administer-cluster/manage-resources/cpu-constraint-namespace/>Mengonfigurasi batasan CPU minimum dan maksimum untuk Namespace</a></p></li><li><p><a href=/id/docs/tasks/administer-cluster/manage-resources/quota-memory-cpu-namespace/>Mengonfigurasi kuota CPU dan memori untuk Namespace</a></p></li><li><p><a href=/id/docs/tasks/administer-cluster/manage-resources/quota-pod-namespace/>Mengonfigurasi kuota Pod untuk Namespace</a></p></li><li><p><a href=/id/docs/tasks/administer-cluster/quota-api-object/>Mengonfigurasi kuota untuk objek API</a></p></li><li><p><a href=/id/docs/tasks/administer-cluster/topology-manager/>Kebijakan Pengaturan Manajemen Topologi pada sebuah Node</a></p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-484833fb880d1e179cc2965d15f84da5>4.3.3 - Mengatur Pod untuk Menggunakan Volume sebagai Tempat Penyimpanan</h1><p>Laman ini menjelaskan bagaimana cara mengatur sebuah Pod untuk menggunakan Volume sebagai tempat penyimpanan.</p><p><em>Filesystem</em> dari sebuah Container hanya hidup selama Container itu juga hidup. Saat Container berakhir dan dimulai ulang, perubahan pada <em>filesystem</em> akan hilang. Untuk penyimpanan konsisten yang independen dari Container, kamu dapat menggunakan <a href=/id/docs/concepts/storage/volumes/>Volume</a>. Hal ini penting terutama untuk aplikasi <em>stateful</em>, seperti <em>key-value stores</em> (contohnya Redis) dan database.</p><h2 id=sebelum-kamu-memulai>Sebelum kamu memulai</h2><p><p>Kamu harus memiliki klaster Kubernetes, dan perangkat baris perintah kubectl
juga harus dikonfigurasikan untuk berkomunikasi dengan klastermu. Jika kamu
belum memiliki klaster, kamu dapat membuatnya dengan menggunakan
<a href=/id/docs/tasks/tools/#minikube>minikube</a>,
atau kamu juga dapat menggunakan salah satu dari tempat mencoba Kubernetes berikut ini:</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>Bermain dengan Kubernetes</a></li></ul>Untuk melihat versi, tekan <code>kubectl version</code>.</p><h2 id=mengatur-volume-untuk-pod>Mengatur volume untuk Pod</h2><p>Pada latihan ini, kamu membuat sebuah Pod yang menjalankan sebuah Container. Pod ini memiliki sebuah Volume dengan tipe <a href=/id/docs/concepts/storage/volumes/#emptydir>emptyDir</a>
yang tetap bertahan, meski Container berakhir dan dimulai ulang. Berikut berkas konfigurasi untuk Pod:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/pods/storage/redis.yaml download=pods/storage/redis.yaml><code>pods/storage/redis.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-storage-redis-yaml")' title="Copy pods/storage/redis.yaml to clipboard"></img></div><div class=includecode id=pods-storage-redis-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>redis-storage<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/data/redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>redis-storage<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><ol><li><p>Membuat Pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/storage/redis.yaml
</span></span></code></pre></div></li><li><p>Verifikasi apakah Container dari Pod berjalan sukses, lalu mengamati perubahan terhadap Pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod redis --watch
</span></span></code></pre></div><p>Hasil keluaran seperti ini:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME      READY     STATUS    RESTARTS   AGE
</span></span><span style=display:flex><span>redis     1/1       Running   <span style=color:#666>0</span>          13s
</span></span></code></pre></div></li><li><p>Pada terminal lain, buka <em>shell</em> untuk masuk ke Container yang sedang berjalan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> -it redis -- /bin/bash
</span></span></code></pre></div></li><li><p>Di dalam <em>shell</em>, pergi ke <code>/data/redis</code>, kemudian buat sebuah berkas:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>root@redis:/data# <span style=color:#a2f>cd</span> /data/redis/
</span></span><span style=display:flex><span>root@redis:/data/redis# <span style=color:#a2f>echo</span> Hello &gt; test-file
</span></span></code></pre></div></li><li><p>Di dalam <em>shell</em>, munculkan daftar proses-proses yang sedang berjalan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>root@redis:/data/redis# apt-get update
</span></span><span style=display:flex><span>root@redis:/data/redis# apt-get install procps
</span></span><span style=display:flex><span>root@redis:/data/redis# ps aux
</span></span></code></pre></div><p>Keluarannya mirip seperti ini:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
</span></span><span style=display:flex><span>redis        <span style=color:#666>1</span>  0.1  0.1  <span style=color:#666>33308</span>  <span style=color:#666>3828</span> ?        Ssl  00:46   0:00 redis-server *:6379
</span></span><span style=display:flex><span>root        <span style=color:#666>12</span>  0.0  0.0  <span style=color:#666>20228</span>  <span style=color:#666>3020</span> ?        Ss   00:47   0:00 /bin/bash
</span></span><span style=display:flex><span>root        <span style=color:#666>15</span>  0.0  0.0  <span style=color:#666>17500</span>  <span style=color:#666>2072</span> ?        R+   00:48   0:00 ps aux
</span></span></code></pre></div></li><li><p>Di dalam <em>shell</em>, matikan proses Redis:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>root@redis:/data/redis# <span style=color:#a2f>kill</span> &lt;pid&gt;
</span></span></code></pre></div><p>dengan <code>&lt;pid></code> adalah ID proses Redis (PID).</p></li><li><p>Di dalam terminal awal, amati perubahan terhadap Pod Redis. Sampai akhirnya kamu akan melihat hal seperti ini:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME      READY     STATUS     RESTARTS   AGE
</span></span><span style=display:flex><span>redis     1/1       Running    <span style=color:#666>0</span>          13s
</span></span><span style=display:flex><span>redis     0/1       Completed  <span style=color:#666>0</span>         6m
</span></span><span style=display:flex><span>redis     1/1       Running    <span style=color:#666>1</span>         6m
</span></span></code></pre></div></li></ol><p>Sampai di sini, Container telah berakhir dan dimuat ulang. Hal ini karena Pod Redis memiliki
<a href=/docs/reference/generated/kubernetes-api/v1.25/#podspec-v1-core>restartPolicy</a>
dengan nilai <code>Always</code>.</p><ol><li><p>Gunakan <em>shell</em> untuk masuk ke dalam Container yang telah dimuat ulang:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> -it redis -- /bin/bash
</span></span></code></pre></div></li><li><p>Di dalam <em>shell</em>, pergi ke <code>/data/redis</code>, dan verifikasi apakah <code>test-file</code> masih ada.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>root@redis:/data/redis# <span style=color:#a2f>cd</span> /data/redis/
</span></span><span style=display:flex><span>root@redis:/data/redis# ls
</span></span><span style=display:flex><span>test-file
</span></span></code></pre></div></li><li><p>Hapus Pod yang kamu buat untuk latihan ini:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pod redis
</span></span></code></pre></div></li></ol><h2 id=selanjutnya>Selanjutnya</h2><ul><li><p>Lihat <a href=/docs/reference/generated/kubernetes-api/v1.25/#volume-v1-core>Volume</a>.</p></li><li><p>Lihat <a href=/docs/reference/generated/kubernetes-api/v1.25/#pod-v1-core>Pod</a>.</p></li><li><p>Selain penyimpanan pada disk lokal yang di sediakan oleh <code>emptyDir</code>, Kubernetes
juga mendukung solusi penyimpanan <em>network-attached</em>, termasuk PD pada
GCE dan EBS dari EC2, yang cenderung lebih disukai untuk data sangat penting dan akan menangani urusan detil seperti <em>mounting</em> dan <em>unmounting</em> perangkat pada Node. Lihat
<a href=/id/docs/concepts/storage/volumes/>Volume</a> untuk informasi detil.</p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-528d2422215cb9632b7b45e886b023b5>4.3.4 - Mengatur Pod untuk Penyimpanan dengan PersistentVolume</h1><p>Laman ini akan menjelaskan bagaimana kamu dapat mengatur sebuah Pod dengan menggunakan
<a class=glossary-tooltip title='Mengklaim sumber daya penyimpanan yang didefinisikan di dalam suatu PersistentVolume, sehingga PersistentVolume tersebut dapat dipasang (mounted) sebagai sebuah volume pada suatu Container.' data-toggle=tooltip data-placement=top href=/id/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims target=_blank aria-label=PersistentVolumeClaim>PersistentVolumeClaim</a>
untuk penyimpanan.
Berikut ringkasan prosesnya:</p><ol><li><p>Kamu, sebagai seorang administrator klaster, membuat sebuah PersistentVolume yang didukung oleh penyimpanan
fisik. Kamu tidak mengaitkan volume dengan Pod apapun.</p></li><li><p>Kamu, sekarang mengambil peran sebagai seorang <em>developer</em> / pengguna klaster, membuat sebuah
PersistentVolumeClaim yang secara otomatis terikat dengan PersistentVolume yang sesuai.</p></li><li><p>Kamu membuat sebuah Pod yang menggunakan PersistentVolumeClaim di atas untuk penyimpanan.</p></li></ol><h2 id=sebelum-kamu-memulai>Sebelum kamu memulai</h2><ul><li><p>Kamu membutuhkan sebuah klaster Kubernetes yang hanya memiliki satu Node, dan
<a class=glossary-tooltip title='Sebuah utilitas baris perintah untuk berkomunikasi dengan suatu server API Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/user-guide/kubectl-overview/ target=_blank aria-label=kubectl>kubectl</a>
alat baris perintah yang sudah diatur untuk berkomunikasi dengan klaster kamu. Jika kamu
tidak memiliki sebuah klaster dengan Node tunggal, kamu dapat membuatnya dengan
<a href=/docs/getting-started-guides/minikube>Minikube</a>.</p></li><li><p>Familiar dengan materi di
<a href=/id/docs/concepts/storage/persistent-volumes/>Persistent Volumes</a>.</p></li></ul><h2 id=membuat-sebuah-berkas-index-html-di-dalam-node-kamu>Membuat sebuah berkas index.html di dalam Node kamu</h2><p>Buka sebuah <em>shell</em> ke Node tunggal di klaster kamu. Bagaimana kamu membuka sebuah <em>shell</em> tergantung
dengan bagaimana kamu mengatur klaster kamu. Contoh, jika kamu menggunakan Minikube, kamu
dapat membuka sebuah <em>shell</em> ke Node kamu dengan memasukkan <code>minikube ssh</code>.</p><p>Di dalam <em>shell</em> kamu pada Node itu, buat sebuah direktori dengan nama <code>/mnt/data</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Asumsikan Node kamu menggunakan &#34;sudo&#34; untuk menjalankan perintah</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># sebagai superuser</span>
</span></span><span style=display:flex><span>sudo mkdir /mnt/data
</span></span></code></pre></div><p>Di dalam direktori <code>/mnt/data</code>, buat sebuah berkas dengan nama <code>index.html</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Disini kembali asumsikan bahwa Node kamu menggunakan &#34;sudo&#34; untuk menjalankan perintah</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># sebagai superuser</span>
</span></span><span style=display:flex><span>sudo sh -c <span style=color:#b44>&#34;echo &#39;Hello from Kubernetes storage&#39; &gt; /mnt/data/index.html&#34;</span>
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Jika Node kamu menggunakan alat untuk mengakses <em>superuser</em> selain dengan <code>sudo</code>, kamu dapat
membuat ini bekerja jika mengganti <code>sudo</code> dengan nama dari alat lainnya.</div><p>Menguji bahwa berkas <code>index.html</code> ada:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat /mnt/data/index.html
</span></span></code></pre></div><p>Keluaran akan seperti ini:</p><pre tabindex=0><code>Hello from Kubernetes storage
</code></pre><p>Sekarang kamu dapat menutup <em>shell</em> di Node kamu.</p><h2 id=membuat-sebuah-persistentvolume>Membuat sebuah PersistentVolume</h2><p>Pada latihan ini, kamu akan membuat sebuah <em>hostPath</em> PersistentVolume. Kubernetes mendukung
hostPath untuk pengembangan dan pengujian di dalam klaster Node tunggal. Sebuah hostPath
PersistentVolume menggunakan berkas atau direktori di dalam Node untuk meniru penyimpanan terhubung jaringan (NAS, <em>network-attached storage</em>).</p><p>Di dalam klaster <em>production</em>, kamu tidak dapat menggunakan hostPath. Sebagai gantinya sebuah administrator klaster
akan menyediakan sumberdaya jaringan seperti Google Compute Engine <em>persistent disk</em>,
<em>NFS share</em>, atau sebuah Amazon Elastic Block Store volume. Administrator klaster juga dapat
menggunakan <a href=/docs/reference/generated/kubernetes-api/v1.25/#storageclass-v1-storage-k8s-io>StorageClass</a>
untuk mengatur
<a href=https://kubernetes.io/blog/2016/10/dynamic-provisioning-and-storage-in-kubernetes><em>provisioning</em> secara dinamis</a>.</p><p>Berikut berkas konfigurasi untuk hostPath PersistentVolume:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/pods/storage/pv-volume.yaml download=pods/storage/pv-volume.yaml><code>pods/storage/pv-volume.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-storage-pv-volume-yaml")' title="Copy pods/storage/pv-volume.yaml to clipboard"></img></div><div class=includecode id=pods-storage-pv-volume-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>task-pv-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>local<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>manual<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>capacity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>10Gi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/mnt/data&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Berkas konfigurasi tersebut menentukan bahwa volume berada di <code>/mnt/data</code> pada
klaster Node. Konfigurasi tersebut juga menentukan ukuran dari 10 gibibytes dan
mode akses <code>ReadWriteOnce</code>, yang berarti volume dapat di pasang sebagai
<em>read-write</em> oleh Node tunggal. Konfigurasi ini menggunakan <a href=/id/docs/concepts/storage/persistent-volumes/#kelas>nama dari StorageClass</a>
<code>manual</code> untuk PersistentVolume, yang akan digunakan untuk mengikat
permintaan PeristentVolumeClaim ke PersistentVolume ini.</p><p>Membuat sebuah PersistentVolume:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/storage/pv-volume.yaml
</span></span></code></pre></div><p>Melihat informasi tentang PersistentVolume:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pv task-pv-volume
</span></span></code></pre></div><p>Keluaran menunjuk PersistentVolume memliki sebuah <code>STATUS</code> dari <code>Available</code>. Ini
berarti PersistentVolume belum terikat ke PersistentVolumeClaim.</p><pre><code>NAME             CAPACITY   ACCESSMODES   RECLAIMPOLICY   STATUS      CLAIM     STORAGECLASS   REASON    AGE
task-pv-volume   10Gi       RWO           Retain          Available             manual                   4s
</code></pre><h2 id=membuat-sebuah-persistentvolumeclaim>Membuat sebuah PersistentVolumeClaim</h2><p>Langkah selanjutnya adalah membuat sebuah PersistentVolumeClaim. Pod menggunakan PersistentVolumeClaim
untuk meminta penyimpanan fisik. Pada latihan ini, kamu akan membuat sebuah PersistentVolumeClaim
yang meminta sebuah volume minimal tiga gibibytes dengan mode akses <em>read-write</em>
setidaknya untuk satu Node.</p><p>Berikut berkas konfigurasi untuk PersistentVolumeClaim:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/pods/storage/pv-claim.yaml download=pods/storage/pv-claim.yaml><code>pods/storage/pv-claim.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-storage-pv-claim-yaml")' title="Copy pods/storage/pv-claim.yaml to clipboard"></img></div><div class=includecode id=pods-storage-pv-claim-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>task-pv-claim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>manual<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>3Gi<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Membuat sebuah PersistentVolumeClaim:</p><pre><code>kubectl apply -f https://k8s.io/examples/pods/storage/pv-claim.yaml
</code></pre><p>Setelah membuat sebuah PersistentVolumeClaim, Kubernetes <em>control plane</em> terlihat
untuk sebuah PersistentVolumeClaim yang memenuhi persyaratan <em>claim's</em>. Jika
<em>control plane</em> menemukan PersistentVolume yang cocok dengan StorageClass, maka
akan mengikat <em>claim</em> ke dalam volume tersebut.</p><p>Lihat kembali PersistentVolume:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pv task-pv-volume
</span></span></code></pre></div><p>Sekarang keluaran menunjukan sebuah <code>STATUS</code> dari <code>Bound</code>.</p><pre><code>NAME             CAPACITY   ACCESSMODES   RECLAIMPOLICY   STATUS    CLAIM                   STORAGECLASS   REASON    AGE
task-pv-volume   10Gi       RWO           Retain          Bound     default/task-pv-claim   manual                   2m
</code></pre><p>Lihat PersistentVolumeClaim:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pvc task-pv-claim
</span></span></code></pre></div><p>Keluaran menunjukan PersistentVolumeClaim terlah terikat dengan PersistentVolume,
<code>task-pv-volume</code>.</p><pre><code>NAME            STATUS    VOLUME           CAPACITY   ACCESSMODES   STORAGECLASS   AGE
task-pv-claim   Bound     task-pv-volume   10Gi       RWO           manual         30s
</code></pre><h2 id=membuat-sebuah-pod>Membuat sebuah Pod</h2><p>Langkah selanjutnya adalah membuat sebuah Pod yang akan menggunakan PersistentVolumeClaim sebagai volume.</p><p>Berikut berkas konfigurasi untuk Pod:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/pods/storage/pv-pod.yaml download=pods/storage/pv-pod.yaml><code>pods/storage/pv-pod.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-storage-pv-pod-yaml")' title="Copy pods/storage/pv-pod.yaml to clipboard"></img></div><div class=includecode id=pods-storage-pv-pod-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>task-pv-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>task-pv-storage<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>persistentVolumeClaim</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>claimName</span>:<span style=color:#bbb> </span>task-pv-claim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>task-pv-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;http-server&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/usr/share/nginx/html&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>task-pv-storage<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Perhatikan bahwa berkas konfigurasi Pod menentukan sebuah PersistentVolumeClaim, tetapi
tidak menentukan PeristentVolume. Dari sudut pandang Pod, <em>claim</em> adalah volume.</p><p>Membuat Pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/storage/pv-pod.yaml
</span></span></code></pre></div><p>Pastikan bahwa Container di dalam Pod berjalan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod task-pv-pod
</span></span></code></pre></div><p>Mendapatkan sebuah <em>shell</em> ke Container yang sedang berjalan di Pod kamu:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> -it task-pv-pod -- /bin/bash
</span></span></code></pre></div><p>Di dalam <em>shell</em>, pastikan bahwa nginx menyajikan berkas <code>index.html</code> dari dalam
hostPath volume:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Pastikan kamu menjalankan 3 perintah ini di dalam shell root yang berasal dari</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># &#34;kubectl exec&#34; dari langkah sebelumnya</span>
</span></span><span style=display:flex><span>apt update
</span></span><span style=display:flex><span>apt install curl
</span></span><span style=display:flex><span>curl http://localhost/
</span></span></code></pre></div><p>Keluaran akan menunjukan sebuah teks yang telah kamu tulis di berkas <code>index.html</code>
di dalam hostPath volume:</p><pre><code>Hello from Kubernetes storage
</code></pre><p>Jika kamu melihat pesan tersebut, kamu telah berhasil mengatur sebuah Pod
untuk menggunakan penyimpanan dari PersistentVolumeClaim.</p><h2 id=membersihkan>Membersihkan</h2><p>Hapus Pod, PersistentVolumeClaim dan PersistentVolume:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pod task-pv-pod
</span></span><span style=display:flex><span>kubectl delete pvc task-pv-claim
</span></span><span style=display:flex><span>kubectl delete pv task-pv-volume
</span></span></code></pre></div><p>Jika kamu belum memiliki <em>shell</em> yang telah dibuka ke Node di klaster kamu,
buka <em>shell</em> baru dengan cara yang sama yang telah kamu lakukan sebelumnya.</p><p>Di dalam <em>shell</em> Node kamu, hapus berkas dan direktori yang telah kamu buat:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Asumsikan Node kamu menggunakan &#34;sudo&#34; untuk menjalankan perintah</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># sebagai superuser</span>
</span></span><span style=display:flex><span>sudo rm /mnt/data/index.html
</span></span><span style=display:flex><span>sudo rmdir /mnt/data
</span></span></code></pre></div><p>Sekarang kamu dapat menutup <em>shell</em> Node kamu.</p><h2 id=kontrol-akses>Kontrol akses</h2><p>Penyimpanan yang telah terkonfigurasi dengan group ID (GID) memungkinkan akses menulis hanya dari Pod yang menggunakan
GID yang sama. GID yang tidak cocok atau hilang akan menyebabkan kesalahan izin ditolak. Untuk mengurangi
kebutuhan koordinasi dengan pengguna, administrator dapat membuat anotasi sebuah PersistentVolume
dengan GID. Kemudian GID akan otomatis ditambahkan ke Pod yang menggunakan PersistentVolume.</p><p>Gunakan anotasi <code>pv.beta.kubernetes.io/gid</code> sebagai berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pv1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>pv.beta.kubernetes.io/gid</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1234&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Ketika sebuah Pod mengkonsumsi PersistentVolume yang memiliki anotasi GID, anotasi GID tersebut
akan diterapkan ke semua container di dalam Pod dengan cara yang sama yang ditentukan di dalam GID Pod security context.
Settiap GID, baik berasal dari anotasi PersistentVolume atau Pod, diterapkan pada proses pertama yang dijalankan
di setiap container.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Ketika sebuah Pod mengkonsumsi PersistentVolume, GID yang terkait dengan PersistentVolume
tidak ada di dalam sumberdaya Pod itu sendiri.</div><h2 id=selanjutnya>Selanjutnya</h2><ul><li>Belajar lebih lanjut tentang <a href=/id/docs/concepts/storage/persistent-volumes/>PersistentVolume</a>.</li><li>Baca <a href=https://git.k8s.io/community/contributors/design-proposals/storage/persistent-storage.md>dokumen perancangan Penyimpanan <em>Persistent</em></a>.</li></ul><h3 id=referensi>Referensi</h3><ul><li><a href=/docs/reference/generated/kubernetes-api/v1.25/#persistentvolume-v1-core>PersistentVolume</a></li><li><a href=/docs/reference/generated/kubernetes-api/v1.25/#persistentvolumespec-v1-core>PersistentVolumeSpec</a></li><li><a href=/docs/reference/generated/kubernetes-api/v1.25/#persistentvolumeclaim-v1-core>PersistentVolumeClaim</a></li><li><a href=/docs/reference/generated/kubernetes-api/v1.25/#persistentvolumeclaimspec-v1-core>PersistentVolumeClaimSpec</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-abd895c0803315e9717e6ff9ec4e3d30>4.3.5 - Mengonfigurasi Konteks Keamanan untuk Pod atau Container</h1><p>Konteks keamanan (<em>security context</em>) menentukan wewenang (<em>privilege</em>) dan aturan kontrol akses untuk sebuah Pod
atau Container. Aturan konteks keamanan meliputi hal-hal berikut ini namun tidak terbatas pada hal-hal tersebut:</p><ul><li><p>Kontrol akses bersifat diskresi: Izin untuk mengakses objek, seperti sebuah berkas, yang didasarkan pada
<a href=https://wiki.archlinux.org/index.php/users_and_groups>ID pengguna atau <em>user ID</em> (UID) dan ID grup atau <em>group ID</em> (GID)</a>.</p></li><li><p><a href=https://en.wikipedia.org/wiki/Security-Enhanced_Linux><em>Security Enhanced Linux</em> (SELinux)</a>: Di mana objek diberi label keamanan.</p></li><li><p>Menjalankan dengan wewenang (<em>privileged</em>) atau tanpa wewenang (<em>unprivileged</em>).</p></li><li><p><a href=https://linux-audit.com/linux-capabilities-hardening-linux-binaries-by-removing-setuid/>Kapabilitas Linux (Linux Capabilities)</a>: Memberi sebuah proses beberapa wewenang, namun tidak semua wewenang dari pengguna <em>root</em>.</p></li><li><p><a href=/docs/tutorials/clusters/apparmor/>AppArmor</a>: Menggunakan profil program untuk membatasi kemampuan dari masing-masing program.</p></li><li><p><a href=https://en.wikipedia.org/wiki/Seccomp>Seccomp</a>: Menyaring panggilan sistem (<em>system calls</em>) dari suatu proses.</p></li><li><p>AllowPrivilegeEscalation: Mengontrol apakah suatu proses dapat memperoleh lebih banyak wewenang daripada proses induknya. Pilihan ini mengontrol secara langsung apakah opsi <a href=https://www.kernel.org/doc/Documentation/prctl/no_new_privs.txt><code>no_new_privs</code></a> diaktifkan pada proses dalam Container. AllowPrivilegeEscalation selalu aktif (<em>true</em>) ketika Container: 1) berjalan dengan wewenang ATAU 2) memiliki <code>CAP_SYS_ADMIN</code>.</p></li><li><p>readOnlyRootFilesystem: Menambatkan (<em>mount</em>) sistem berkas (<em>file system</em>) <em>root</em> dari sebuah Container hanya sebatas untuk dibaca saja (<em>read-only</em>).</p></li></ul><p>Poin-poin di atas bukanlah sekumpulan lengkap dari aturan konteks keamanan - silakan lihat <a href=https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.18/#securitycontext-v1-core>SecurityContext</a> untuk daftar lengkapnya.</p><p>Untuk informasi lebih lanjut tentang mekanisme keamanan pada Linux, silahkan lihat
<a href=https://www.linux.com/learn/overview-linux-kernel-security-features>ikhtisar fitur keamanan pada Kernel Linux</a></p><h2 id=sebelum-kamu-memulai>Sebelum kamu memulai</h2><p><p>Kamu harus memiliki klaster Kubernetes, dan perangkat baris perintah kubectl
juga harus dikonfigurasikan untuk berkomunikasi dengan klastermu. Jika kamu
belum memiliki klaster, kamu dapat membuatnya dengan menggunakan
<a href=/id/docs/tasks/tools/#minikube>minikube</a>,
atau kamu juga dapat menggunakan salah satu dari tempat mencoba Kubernetes berikut ini:</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>Bermain dengan Kubernetes</a></li></ul>Untuk melihat versi, tekan <code>kubectl version</code>.</p><h2 id=mengatur-konteks-keamanan-untuk-pod>Mengatur konteks keamanan untuk Pod</h2><p>Untuk menentukan aturan keamanan pada Pod, masukkan bagian <code>securityContext</code>
dalam spesifikasi Pod. Bagian <code>securityContext</code> adalah sebuah objek
<a href=/docs/reference/generate/kubernetes-api/v1.25/#podsecuritycontext-v1-core>PodSecurityContext</a>.
Aturan keamanan yang kamu tetapkan untuk Pod akan berlaku untuk semua Container dalam Pod tersebut.
Berikut sebuah berkas konfigurasi untuk Pod yang memiliki volume <code>securityContext</code> dan <code>emptyDir</code>:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/pods/security/security-context.yaml download=pods/security/security-context.yaml><code>pods/security/security-context.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-security-security-context-yaml")' title="Copy pods/security/security-context.yaml to clipboard"></img></div><div class=includecode id=pods-security-security-context-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>security-context-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>runAsUser</span>:<span style=color:#bbb> </span><span style=color:#666>1000</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>runAsGroup</span>:<span style=color:#bbb> </span><span style=color:#666>3000</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>fsGroup</span>:<span style=color:#bbb> </span><span style=color:#666>2000</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>sec-ctx-vol<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>sec-ctx-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;sleep 1h&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>sec-ctx-vol<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/data/demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>allowPrivilegeEscalation</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Dalam berkas konfigurasi ini, bagian <code>runAsUser</code> menentukan bahwa dalam setiap Container pada
Pod, semua proses dijalankan oleh ID pengguna 1000. Bagian <code>runAsGroup</code> menentukan grup utama dengan ID 3000 untuk
semua proses dalam setiap Container pada Pod. Jika bagian ini diabaikan, maka ID grup utama dari Container
akan berubah menjadi <em>root</em>(0). Berkas apa pun yang dibuat juga akan dimiliki oleh pengguna dengan ID 1000 dan grup dengan ID 3000 ketika <code>runAsGroup</code> ditentukan.
Karena <code>fsGroup</code> ditentukan, semua proses milik Container juga merupakan bagian dari grup tambahan dengan ID 2000.
Pemilik volume <code>/data/demo</code> dan berkas apa pun yang dibuat dalam volume tersebut adalah grup dengan ID 2000.</p><p>Buatlah Pod tersebut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/security/security-context.yaml
</span></span></code></pre></div><p>Periksa apakah Container dari Pod sedang berjalan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod security-context-demo
</span></span></code></pre></div><p>Masuk ke <em>shell</em> dari Container yang sedang berjalan tersebut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> -it security-context-demo -- sh
</span></span></code></pre></div><p>Pada <em>shell</em> kamu, lihat daftar proses yang berjalan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>ps
</span></span></code></pre></div><p>Keluarannya menunjukkan bahwa proses dijalankan oleh pengguna dengan ID 1000, yang merupakan nilai dari bagian <code>runAsUser</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>PID   USER     TIME  COMMAND
</span></span><span style=display:flex><span>    <span style=color:#666>1</span> <span style=color:#666>1000</span>      0:00 sleep 1h
</span></span><span style=display:flex><span>    <span style=color:#666>6</span> <span style=color:#666>1000</span>      0:00 sh
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>Pada <em>shell</em> kamu, pindah ke direktori <code>/data</code>, dan lihat isinya:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>cd</span> /data
</span></span><span style=display:flex><span>ls -l
</span></span></code></pre></div><p>Keluarannya menunjukkan bahwa direktori <code>/data/demo</code> memiliki grup dengan ID 2000, yang merupakan
nilai dari bagian <code>fsGroup</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>drwxrwsrwx <span style=color:#666>2</span> root <span style=color:#666>2000</span> <span style=color:#666>4096</span> Jun  <span style=color:#666>6</span> 20:08 demo
</span></span></code></pre></div><p>Pada <em>shell</em> kamu, pindah ke direktori <code>/data/demo</code>, dan buatlah sebuah berkas didalamnya:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>cd</span> demo
</span></span><span style=display:flex><span><span style=color:#a2f>echo</span> hello &gt; testfile
</span></span></code></pre></div><p>Lihatlah daftar berkas dalam direktori <code>/data/demo</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>ls -l
</span></span></code></pre></div><p>Keluarannya menunjukkan bahwa <code>testfile</code> memiliki grup dengan ID 2000, dimana merupakan nilai dari bagian <code>fsGroup</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>-rw-r--r-- <span style=color:#666>1</span> <span style=color:#666>1000</span> <span style=color:#666>2000</span> <span style=color:#666>6</span> Jun  <span style=color:#666>6</span> 20:08 testfile
</span></span></code></pre></div><p>Jalankan perintah berikut ini:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ id
</span></span><span style=display:flex><span><span style=color:#b8860b>uid</span><span style=color:#666>=</span><span style=color:#666>1000</span> <span style=color:#b8860b>gid</span><span style=color:#666>=</span><span style=color:#666>3000</span> <span style=color:#b8860b>groups</span><span style=color:#666>=</span><span style=color:#666>2000</span>
</span></span></code></pre></div><p>Kamu akan melihat bahwa nilai <em>gid</em> adalah 3000, sama dengan bagian <code>runAsGroup</code>. Jika <code>runAsGroup</code> diabaikan maka nilai <em>gid</em> akan
tetap bernilai 0(<em>root</em>) dan proses akan dapat berinteraksi dengan berkas-berkas yang dimiliki oleh grup root(0) dan yang memiliki
izin grup untuk grup root(0).</p><p>Keluarlah dari <em>shell</em> kamu:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>exit</span>
</span></span></code></pre></div><h2 id=melakukan-konfigurasi-izin-volume-dan-kebijakan-perubahan-kepemilikan-untuk-pod>Melakukan konfigurasi izin volume dan kebijakan perubahan kepemilikan untuk Pod</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.18 [alpha]</code></div><p>Secara bawaan, Kubernetes mengubah kepemilikan dan izin secara rekursif untuk konten masing-masing
volume untuk mencocokkan <code>fsGroup</code> yang ditentukan dalam <code>securityContext</code> dari Pod pada saat volume itu
ditambatkan (<em>mounted</em>). Untuk volume yang besar, memeriksa dan mengubah kepemilikan dan izin dapat memerlukan waktu yang sangat lama,
sehingga memperlambat proses menjalankan Pod. Kamu dapat menggunakan bagian <code>fsGroupChangePolicy</code> dalam sebuah <code>securityContext</code>
untuk mengontrol cara Kubernetes memeriksa dan mengelola kepemilikan dan izin
untuk sebuah volume.</p><p><strong>fsGroupChangePolicy</strong> - <code>fsGroupChangePolicy</code> mendefinisikan perilaku untuk mengubah kepemilikan dan izin volume
sebelum diekspos di dalam sebuah Pod. Bagian ini hanya berlaku untuk tipe volume yang mendukung
<code>fsGroup</code> untuk mengontrol kepemilikan dan izin. Bagian ini memiliki dua nilai yang dapat dimasukkan:</p><ul><li><em>OnRootMismatch</em>: Hanya mengubah izin dan kepemilikan jika izin dan kepemilikan dari direktori <em>root</em> tidak sesuai dengan izin volume yang diharapkan. Hal ini dapat membantu mempersingkat waktu yang diperlukan untuk mengubah kepemilikan dan izin sebuah volume.</li><li><em>Always</em>: Selalu mengubah izin dan kepemilikan volume ketika volume sudah ditambatkan.</li></ul><p>Sebagai contoh:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>runAsUser</span>:<span style=color:#bbb> </span><span style=color:#666>1000</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>runAsGroup</span>:<span style=color:#bbb> </span><span style=color:#666>3000</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>fsGroup</span>:<span style=color:#bbb> </span><span style=color:#666>2000</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>fsGroupChangePolicy</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;OnRootMismatch&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Ini adalah fitur alpha. Untuk menggunakannya, silahkan aktifkan <a href=/docs/reference/command-line-tools-reference/feature-gates/>gerbang fitur</a> <code>ConfigurableFSGroupPolicy</code> untuk kube-api-server, kube-controller-manager, dan kubelet.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Bagian ini tidak berpengaruh pada tipe volume yang bersifat sementara (<em>ephemeral</em>) seperti
<a href=https://kubernetes.io/docs/concepts/storage/volumes/#secret><code>secret</code></a>,
<a href=https://kubernetes.io/docs/concepts/storage/volumes/#configmap><code>configMap</code></a>,
dan <a href=https://kubernetes.io/docs/concepts/storage/volumes/#emptydir><code>emptydir</code></a>.</div><h2 id=mengatur-konteks-keamanan-untuk-container>Mengatur konteks keamanan untuk Container</h2><p>Untuk menentukan aturan keamanan untuk suatu Container, sertakan bagian <code>securityContext</code>
dalam manifes Container. Bagian <code>securityContext</code> adalah sebuah objek
<a href=/docs/reference/generate/kubernetes-api/v1.25/#securitycontext-v1-core>SecurityContext</a>.
Aturan keamanan yang kamu tentukan untuk Container hanya berlaku untuk
Container secara individu, dan aturan tersebut menimpa aturan yang dibuat pada tingkat Pod apabila
ada aturan yang tumpang tindih. Aturan pada Container mempengaruhi volume pada Pod.</p><p>Berikut berkas konfigurasi untuk Pod yang hanya memiliki satu Container. Keduanya, baik Pod
dan Container memiliki bagian <code>securityContext</code> sebagai berikut:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/pods/security/security-context-2.yaml download=pods/security/security-context-2.yaml><code>pods/security/security-context-2.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-security-security-context-2-yaml")' title="Copy pods/security/security-context-2.yaml to clipboard"></img></div><div class=includecode id=pods-security-security-context-2-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>security-context-demo-2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>runAsUser</span>:<span style=color:#bbb> </span><span style=color:#666>1000</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>sec-ctx-demo-2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/google-samples/node-hello:1.0<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>runAsUser</span>:<span style=color:#bbb> </span><span style=color:#666>2000</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>allowPrivilegeEscalation</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Buatlah Pod tersebut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/security/security-context-2.yaml
</span></span></code></pre></div><p>Periksa jika Container dalam Pod sedang berjalan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod security-context-demo-2
</span></span></code></pre></div><p>Masuk ke dalam <em>shell</em> Container yang sedang berjalan tersebut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> -it security-context-demo-2 -- sh
</span></span></code></pre></div><p>Pada <em>shell</em> kamu, lihat daftar proses yang sedang berjalan:</p><pre tabindex=0><code>ps aux
</code></pre><p>Keluarannya menunjukkan bahwa proses dijalankan oleh user dengan ID 2000, yang merupakan
nilai dari <code>runAsUser</code> seperti yang telah ditentukan untuk Container tersebut. Nilai tersebut menimpa nilai ID 1000 yang
ditentukan untuk Pod-nya.</p><pre tabindex=0><code>USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
2000         1  0.0  0.0   4336   764 ?        Ss   20:36   0:00 /bin/sh -c node server.js
2000         8  0.1  0.5 772124 22604 ?        Sl   20:36   0:00 node server.js
...
</code></pre><p>Keluar dari <em>shell</em> anda:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>exit</span>
</span></span></code></pre></div><h2 id=mengatur-kapabilitas-untuk-container>Mengatur Kapabilitas untuk Container</h2><p>Dengan menggunakan <a href=http://man7.org/linux/man-pages/man7/capabilities.7.html>Kapabilitas Linux (Linux Capabilities)</a>,
kamu dapat memberikan wewenang tertentu kepada suatu proses tanpa memberikan semua wewenang
dari pengguna <em>root</em>. Untuk menambah atau menghapus Kapabilitas Linux pada suatu Container, masukkan
bagian <code>capabilities</code> pada <code>securityContext</code> di manifes Container-nya.</p><p>Pertama-tama, mari melihat apa yang terjadi ketika kamu tidak menyertakan bagian <code>capabilities</code>.
Berikut ini adalah berkas konfigurasi yang tidak menambah atau mengurangi kemampuan apa pun dari Container:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/pods/security/security-context-3.yaml download=pods/security/security-context-3.yaml><code>pods/security/security-context-3.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-security-security-context-3-yaml")' title="Copy pods/security/security-context-3.yaml to clipboard"></img></div><div class=includecode id=pods-security-security-context-3-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>security-context-demo-3<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>sec-ctx-3<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/google-samples/node-hello:1.0<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Buatlah Pod tersebut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/security/security-context-3.yaml
</span></span></code></pre></div><p>Periksa apakah Container dari Pod tersebut sedang berjalan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod security-context-demo-3
</span></span></code></pre></div><p>Masuk ke dalam <em>shell</em> dari Container yang berjalan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> -it security-context-demo-3 -- sh
</span></span></code></pre></div><p>Dalam <em>shell</em> tersebut, lihatlah daftar proses yang berjalan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>ps aux
</span></span></code></pre></div><p>Keluarannya menunjukkan ID dari proses atau <em>process IDs</em> (PIDs) untuk Container tersebut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>USER  PID %CPU %MEM    VSZ   RSS TTY   STAT START   TIME COMMAND
</span></span><span style=display:flex><span>root    <span style=color:#666>1</span>  0.0  0.0   <span style=color:#666>4336</span>   <span style=color:#666>796</span> ?     Ss   18:17   0:00 /bin/sh -c node server.js
</span></span><span style=display:flex><span>root    <span style=color:#666>5</span>  0.1  0.5 <span style=color:#666>772124</span> <span style=color:#666>22700</span> ?     Sl   18:17   0:00 node server.js
</span></span></code></pre></div><p>Dalam <em>shell</em> kamu, lihat status dari proses dengan ID 1:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>cd</span> /proc/1
</span></span><span style=display:flex><span>cat status
</span></span></code></pre></div><p>Keluarannya menunjukkan <em>bitmap</em> dari kapabilitas untuk proses tersebut:</p><pre tabindex=0><code>...
CapPrm:	00000000a80425fb
CapEff:	00000000a80425fb
...
</code></pre><p>Buatlah catatan untuk <em>bitmap</em> dari kapabilitas tersebut, dan keluarlah dari <em>shell</em> kamu:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>exit</span>
</span></span></code></pre></div><p>Berikutnya, jalankan Container yang sama seperti dengan Container sebelumnya, namun
Container ini memiliki kapabilitas tambahan yang sudah ditentukan.</p><p>Berikut ini adalah berkas konfigurasi untuk Pod yang hanya menjalankan satu Container. Konfigurasi
ini menambahkan kapabilitas <code>CAP_NET_ADMIN</code> dan <code>CAP_SYS_TIME</code>:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/pods/security/security-context-4.yaml download=pods/security/security-context-4.yaml><code>pods/security/security-context-4.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-security-security-context-4-yaml")' title="Copy pods/security/security-context-4.yaml to clipboard"></img></div><div class=includecode id=pods-security-security-context-4-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>security-context-demo-4<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>sec-ctx-4<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/google-samples/node-hello:1.0<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>capabilities</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>add</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;NET_ADMIN&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;SYS_TIME&#34;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Buatlah Pod tersebut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/security/security-context-4.yaml
</span></span></code></pre></div><p>Masuk ke dalam <em>shell</em> dari Container yang berjalan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> -it security-context-demo-4 -- sh
</span></span></code></pre></div><p>Di dalam <em>shell</em> kamu, lihatlah kapabilitas dari proses dengan ID 1:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>cd</span> /proc/1
</span></span><span style=display:flex><span>cat status
</span></span></code></pre></div><p>Keluarannya menunjukkan <em>bitmap</em> kapabilitas untuk proses tersebut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>...
</span></span><span style=display:flex><span>CapPrm:	00000000aa0435fb
</span></span><span style=display:flex><span>CapEff:	00000000aa0435fb
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>Bandingkan kemampuan dari kedua Containers tersebut:</p><pre tabindex=0><code>00000000a80425fb
00000000aa0435fb
</code></pre><p>Dalam <em>bitmap</em> kapabilitas pada Container pertama, bit-12 dan ke-25 tidak diatur. Sedangkan dalam Container kedua,
bit ke-12 dan ke-25 diatur. Bit ke-12 adalah kapabilitas <code>CAP_NET_ADMIN</code>, dan bit-25 adalah kapabilitas <code>CAP_SYS_TIME</code>.
Lihatlah <a href=https://github.com/torvalds/linux/blob/master/include/uapi/linux/capability.h>capability.h</a>
untuk nilai dari konstanta kapabilitas-kapabilitas yang lainnya.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Konstanta kapabilitas Linux memiliki format <code>CAP_XXX</code>. Tetapi ketika kamu memasukkan daftar kemampuan dalam manifes Container kamu, kamu harus menghilangkan bagian <code>CAP_</code> dari konstantanya. Misalnya, untuk menambahkan <code>CAP_SYS_TIME</code>, masukkan <code>SYS_TIME</code> ke dalam daftar kapabilitas Container kamu.</div><h2 id=memberikan-label-selinux-pada-sebuah-container>Memberikan label SELinux pada sebuah Container</h2><p>Untuk memberikan label SELinux pada sebuah Container, masukkan bagian <code>seLinuxOptions</code> pada
bagian <code>securityContext</code> dari manifes Pod atau Container kamu.
Bagian <code>seLinuxOptions</code> adalah sebuah objek <a href=/docs/reference/generated/kubernetes-api/v1.25/#selinuxoptions-v1-core>SELinuxOptions</a>.
Berikut ini adalah contoh yang menerapkan sebuah level dari SELinux:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>seLinuxOptions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>level</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;s0:c123,c456&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Untuk menetapkan label SELinux, modul keamanan SELinux harus dimuat terlebih dahulu pada sistem operasi dari hosnya.</div><h2 id=diskusi>Diskusi</h2><p>Konteks keamanan untuk sebuah Pod berlaku juga untuk Container yang berada dalam Pod tersebut dan juga untuk
volume dari Pod tersebut jika ada. Terkhusus untuk <code>fsGroup</code> dan <code>seLinuxOptions</code>
akan diterapkan pada volume seperti berikut:</p><ul><li><p><code>fsGroup</code>: Volume yang mendukung manajemen kepemilikan (<em>ownership</em>) akan dimodifikasi agar dapat dimiliki
dan ditulis oleh ID group (GID) yang disebutkan dalam <code>fsGroup</code>. Lihatlah
<a href=https://git.k8s.io/community/contributors/design-proposals/storage/volume-ownership-management.md>Dokumen Desain untuk Manajemen Kepemilikan</a>
untuk lebih lanjut.</p></li><li><p><code>seLinuxOptions</code>: Volume yang mendukung pelabelan SELinux akan dilabel ulang agar dapat diakses
oleh label yang ditentukan pada <code>seLinuxOptions</code>. Biasanya kamu hanya
perlu mengatur bagian <code>level</code>. Dimana ini akan menetapkan label
<a href=https://selinuxproject.org/page/NB_MLS>Keamanan multi-kategori (<em>Multi-Category Security</em>) (MCS)</a>
yang diberikan kepada semua Container dalam Pod serta Volume yang ada didalamnya.</p></li></ul><div class="alert alert-danger warning callout" role=alert><strong>Peringatan:</strong> Setelah kamu menentukan label MCS untuk Pod, maka semua Pod dengan label yang sama dapat mengakses Volume tersebut. Jika kamu membutuhkan perlindungan antar Pod, kamu harus menetapkan label MCS yang unik untuk setiap Pod.</div><h2 id=bersih-bersih-clean-up>Bersih-bersih (<em>Clean Up</em>)</h2><p>Hapus Pod-Pod tersebut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pod security-context-demo
</span></span><span style=display:flex><span>kubectl delete pod security-context-demo-2
</span></span><span style=display:flex><span>kubectl delete pod security-context-demo-3
</span></span><span style=display:flex><span>kubectl delete pod security-context-demo-4
</span></span></code></pre></div><h2 id=selanjutnya>Selanjutnya</h2><ul><li><a href=/docs/reference/generated/kubernetes-api/v1.25/#podsecuritycontext-v1-core>PodSecurityContext</a></li><li><a href=/docs/reference/generated/kubernetes-api/v1.25/#securitycontext-v1-core>SecurityContext</a></li><li><a href=https://opensource.com/business/15/3/docker-security-tuning>Menyetel Docker dengan peningkatan keamanan terbaru</a></li><li><a href=https://git.k8s.io/community/contributors/design-proposals/auth/security_context.md>Dokumen desain konteks keamanan</a></li><li><a href=https://git.k8s.io/community/contributors/design-proposals/storage/volume-ownership-management.md>Dokumen desain manajemen kepemilikan</a></li><li><a href=/id/docs/concepts/policy/pod-security-policy/>Kebijakan keamanan Pod</a></li><li><a href=https://git.k8s.io/community/contributors/design-proposals/auth/no-new-privs.md>Dokumen desain AllowPrivilegeEscalation</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-2c0d882359718c4c69c67099bed2156c>4.3.6 - Mengatur ServiceAccount untuk Pod</h1><p>ServiceAccount menyediakan identitas untuk proses yang sedang berjalan dalam sebuah Pod.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Dokumen ini digunakan sebagai pengenalan untuk pengguna terhadap ServiceAccount dan menjelaskan bagaimana perilaku ServiceAccount dalam konfigurasi klaster seperti yang direkomendasikan Kubernetes. Pengubahan perilaku yang bisa saja dilakukan administrator klaster terhadap klaster tidak menjadi bagian pembahasan dokumentasi ini.</div><p>Ketika kamu mengakses klaster (contohnya menggunakan <code>kubectl</code>), kamu terautentikasi oleh apiserver sebagai sebuah akun pengguna (untuk sekarang umumnya sebagai <code>admin</code>, kecuali jika administrator klustermu telah melakukan pengubahan). Berbagai proses yang ada di dalam kontainer dalam Pod juga dapat mengontak apiserver. Ketika itu terjadi, mereka akan diautentikasi sebagai sebuah ServiceAccount (contohnya sebagai <code>default</code>).</p><h2 id=sebelum-kamu-memulai>Sebelum kamu memulai</h2><p><p>Kamu harus memiliki klaster Kubernetes, dan perangkat baris perintah kubectl
juga harus dikonfigurasikan untuk berkomunikasi dengan klastermu. Jika kamu
belum memiliki klaster, kamu dapat membuatnya dengan menggunakan
<a href=/id/docs/tasks/tools/#minikube>minikube</a>,
atau kamu juga dapat menggunakan salah satu dari tempat mencoba Kubernetes berikut ini:</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>Bermain dengan Kubernetes</a></li></ul>Untuk melihat versi, tekan <code>kubectl version</code>.</p><h2 id=menggunakan-default-serviceaccount-untuk-mengakses-api-server>Menggunakan Default ServiceAccount untuk Mengakses API server.</h2><p>Ketika kamu membuat sebuah Pod, jika kamu tidak menentukan sebuah ServiceAccount, maka ia akan otomatis ditetapkan sebagai ServiceAccount<code>default</code> di Namespace yang sama. Jika kamu mendapatkan json atau yaml mentah untuk sebuah Pod yang telah kamu buat (contohnya menggunakan <code>kubectl get pods/&lt;podname> -o yaml</code>), kamu akan melihat <em>field</em> <code>spec.serviceAccountName</code> yang telah secara <a href=/docs/user-guide/working-with-resources/#resources-are-automatically-modified>otomatis ditentukan</a>.</p><p>Kamu dapat mengakses API dari dalam Pod menggunakan kredensial ServiceAccount yang ditambahkan secara otomatis seperti yang dijelaskan dalam <a href=/docs/user-guide/accessing-the-cluster/#accessing-the-api-from-a-pod>Mengakses Klaster</a>.
Hak akses API dari ServiceAccount menyesuaikan dengan <a href=/docs/reference/access-authn-authz/authorization/#authorization-modules>kebijakan dan plugin otorisasi</a> yang sedang digunakan.</p><p>Di versi 1.6+, kamu dapat tidak memilih <em>automounting</em> kredensial API dari sebuah ServiceAccount dengan mengatur <code>automountServiceAccountToken: false</code> pada ServiceAccount:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ServiceAccount<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>build-robot<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>automountServiceAccountToken</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Di versi 1.6+, kamu juga dapat tidak memilih <em>automounting</em> kredensial API dari suatu Pod tertentu:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>serviceAccountName</span>:<span style=color:#bbb> </span>build-robot<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>automountServiceAccountToken</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span></code></pre></div><p>Pengaturan dari spesifikasi Pod didahulukan dibanding ServiceAccount jika keduanya menentukan nilai dari <code>automountServiceAccountToken</code>.</p><h2 id=menggunakan-beberapa-serviceaccount>Menggunakan Beberapa ServiceAccount.</h2><p>Setiap Namespace memiliki sumber daya ServiceAccount standar <code>default</code>.
Kamu dapat melihatnya dan sumber daya serviceAccount lainnya di Namespace tersebut dengan perintah:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get serviceaccounts
</span></span></code></pre></div><p>Keluarannya akan serupa dengan:</p><pre tabindex=0><code>NAME      SECRETS    AGE
default   1          1d
</code></pre><p>Kamu dapat membuat objek ServiceAccount tambahan seperti ini:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f - <span style=color:#b44>&lt;&lt;EOF
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: ServiceAccount
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: build-robot
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>Nama dari objek ServiceAccount haruslah sebuah <a href=/id/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>nama subdomain DNS</a> yang valid.</p><p>Jika kamu mendapatkan objek ServiceAccount secara komplit, seperti ini:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get serviceaccounts/build-robot -o yaml
</span></span></code></pre></div><p>Keluarannya akan serupa dengan:</p><pre tabindex=0><code>apiVersion: v1
kind: ServiceAccount
metadata:
  creationTimestamp: 2015-06-16T00:12:59Z
  name: build-robot
  namespace: default
  resourceVersion: &#34;272500&#34;
  uid: 721ab723-13bc-11e5-aec2-42010af0021e
secrets:
- name: build-robot-token-bvbk5
</code></pre><p>maka kamu dapat melihat bahwa <em>token</em> telah dibuat secara otomatis dan dirujuk oleh ServiceAccount.</p><p>Kamu dapat menggunakan <em>plugin</em> otorisasi untuk <a href=/id/docs/reference/access-authn-authz/rbac/#service-account-permissions>mengatur hak akses dari ServiceAccount</a>.</p><p>Untuk menggunakan ServiceAccount selain nilai standar, atur <em>field</em> <code>spec.serviceAccountName</code> dari Pod menjadi nama dari ServiceAccount yang hendak kamu gunakan.</p><p><em>Service account</em> harus ada ketika Pod dibuat, jika tidak maka akan ditolak.</p><p>Kamu tidak dapat memperbarui ServiceAccount dari Pod yang telah dibuat.</p><p>Kamu dapat menghapus ServiceAccount dari contoh seperti ini:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete serviceaccount/build-robot
</span></span></code></pre></div><h2 id=membuat-token-api-serviceaccount-secara-manual>Membuat token API ServiceAccount secara manual.</h2><p>Asumsikan kita memiliki ServiceAccount dengan nama "build-robot" seperti yang disebukan di atas, dan kita membuat Secret secara manual.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f - <span style=color:#b44>&lt;&lt;EOF
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: Secret
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: build-robot-secret
</span></span></span><span style=display:flex><span><span style=color:#b44>  annotations:
</span></span></span><span style=display:flex><span><span style=color:#b44>    kubernetes.io/service-account.name: build-robot
</span></span></span><span style=display:flex><span><span style=color:#b44>type: kubernetes.io/service-account-token
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>Sekarang kamu dapat mengonfirmasi bahwa Secret yang baru saja dibuat diisi dengan <em>token</em> API dari ServiceAccount "build-robot".</p><p>Setiap <em>token</em> dari ServiceAccount yang tidak ada akan dihapus oleh <em>token controller</em>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe secrets/build-robot-secret
</span></span></code></pre></div><p>Keluarannya akan serupa dengan:</p><pre tabindex=0><code>Name:           build-robot-secret
Namespace:      default
Labels:         &lt;none&gt;
Annotations:    kubernetes.io/service-account.name: build-robot
                kubernetes.io/service-account.uid: da68f9c6-9d26-11e7-b84e-002dc52800da

Type:   kubernetes.io/service-account-token

Data
====
ca.crt:         1338 bytes
namespace:      7 bytes
token:          ...
</code></pre><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Isi dari <code>token</code> tidak dirinci di sini.</div><h2 id=menambahkan-imagepullsecret-ke-serviceaccount>Menambahkan ImagePullSecret ke ServiceAccount.</h2><h3 id=membuat-imagepullsecret>Membuat imagePullSecret</h3><ul><li><p>Membuat sebuah imagePullSecret, seperti yang dijelaskan pada <a href=/id/docs/concepts/containers/images/#tentukan-imagepullsecrets-pada-sebuah-pod>Menentukan ImagePullSecret pada Pod</a>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret docker-registry myregistrykey --docker-server<span style=color:#666>=</span>DUMMY_SERVER <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>        --docker-username<span style=color:#666>=</span>DUMMY_USERNAME --docker-password<span style=color:#666>=</span>DUMMY_DOCKER_PASSWORD <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>        --docker-email<span style=color:#666>=</span>DUMMY_DOCKER_EMAIL
</span></span></code></pre></div></li><li><p>Memastikan bahwa Secret telah terbuat.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get secrets myregistrykey
</span></span></code></pre></div><p>Keluarannya akan serupa dengan:</p><pre tabindex=0><code>NAME             TYPE                              DATA    AGE
myregistrykey    kubernetes.io/.dockerconfigjson   1       1d
</code></pre></li></ul><h3 id=menambahkan-imagepullsecret-ke-serviceaccount-1>Menambahkan imagePullSecret ke ServiceAccount</h3><p>Selanjutnya, modifikasi ServiceAccount standar dari Namespace untuk menggunakan Secret ini sebagai imagePullSecret.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl patch serviceaccount default -p <span style=color:#b44>&#39;{&#34;imagePullSecrets&#34;: [{&#34;name&#34;: &#34;myregistrykey&#34;}]}&#39;</span>
</span></span></code></pre></div><p>Sebagai gantinya kamu dapat menggunakan <code>kubectl edit</code>, atau melakukan pengubahan secara manual manifes YAML seperti di bawah ini:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get serviceaccounts default -o yaml &gt; ./sa.yaml
</span></span></code></pre></div><p>Keluaran dari berkas <code>sa.yaml</code> akan serupa dengan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>apiVersion: v1
</span></span><span style=display:flex><span>kind: ServiceAccount
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  creationTimestamp: 2015-08-07T22:02:39Z
</span></span><span style=display:flex><span>  name: default
</span></span><span style=display:flex><span>  namespace: default
</span></span><span style=display:flex><span>  resourceVersion: <span style=color:#b44>&#34;243024&#34;</span>
</span></span><span style=display:flex><span>  uid: 052fb0f4-3d50-11e5-b066-42010af0d7b6
</span></span><span style=display:flex><span>secrets:
</span></span><span style=display:flex><span>- name: default-token-uudge
</span></span></code></pre></div><p>Menggunakan <em>editor</em> pilihanmu (misalnya <code>vi</code>), buka berkas <code>sa.yaml</code>, hapus baris dengan key <code>resourceVersion</code>, tambahkan baris dengan <code>imagePullSecrets:</code> dan simpan.</p><p>Keluaran dari berkas <code>sa.yaml</code> akan serupa dengan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>apiVersion: v1
</span></span><span style=display:flex><span>kind: ServiceAccount
</span></span><span style=display:flex><span>metadata:
</span></span><span style=display:flex><span>  creationTimestamp: 2015-08-07T22:02:39Z
</span></span><span style=display:flex><span>  name: default
</span></span><span style=display:flex><span>  namespace: default
</span></span><span style=display:flex><span>  uid: 052fb0f4-3d50-11e5-b066-42010af0d7b6
</span></span><span style=display:flex><span>secrets:
</span></span><span style=display:flex><span>- name: default-token-uudge
</span></span><span style=display:flex><span>imagePullSecrets:
</span></span><span style=display:flex><span>- name: myregistrykey
</span></span></code></pre></div><p>Terakhir ganti serviceaccount dengan berkas <code>sa.yaml</code> yang telah diperbarui.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl replace serviceaccount default -f ./sa.yaml
</span></span></code></pre></div><h3 id=memverifikasi-imagepullsecrets-sudah-ditambahkan-ke-spesifikasi-pod>Memverifikasi imagePullSecrets sudah ditambahkan ke spesifikasi Pod</h3><p>Ketika Pod baru dibuat dalam Namespace yang sedang aktif dan menggunakan ServiceAccount, Pod baru akan memiliki <em>field</em> <code>spec.imagePullSecrets</code> yang ditentukan secara otomatis:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl run nginx --image<span style=color:#666>=</span>nginx --restart<span style=color:#666>=</span>Never
</span></span><span style=display:flex><span>kubectl get pod nginx -o<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.spec.imagePullSecrets[0].name}{&#34;\n&#34;}&#39;</span>
</span></span></code></pre></div><p>Keluarannya adalah:</p><pre tabindex=0><code>myregistrykey
</code></pre><!--## Menambahkan Secrets ke sebuah ServiceAccount.

TODO: Tes dan jelaskan bagaimana cara menambahkan Secret tambahan non-K8s dengan ServiceAccount yang sudah ada.
--><h2 id=serviceaccounttokenvolumeprojection>ServiceAccountTokenVolumeProjection</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.12 [beta]</code></div><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong><p>ServiceAccountTokenVolumeProjection masih dalam tahap <strong>beta</strong> untuk versi 1.12 dan diaktifkan dengan memberikan <em>flag</em> berikut ini ke API server:</p><ul><li><code>--service-account-issuer</code></li><li><code>--service-account-signing-key-file</code></li><li><code>--service-account-api-audiences</code></li></ul></div><p>Kubelet juga dapat memproyeksikan <em>token</em> ServiceAccount ke Pod. Kamu dapat menentukan properti yang diinginkan dari <em>token</em> seperti target pengguna dan durasi validitas. Properti tersebut tidak dapat diubah pada <em>token</em> ServiceAccount standar. <em>Token</em> ServiceAccount juga akan menjadi tidak valid terhadap API ketika Pod atau ServiceAccount dihapus.</p><p>Perilaku ini diatur pada PodSpec menggunakan tipe ProjectedVolume yaitu <a href=/id/docs/concepts/storage/volumes/#projected>ServiceAccountToken</a>. Untuk memungkinkan Pod dengan <em>token</em> dengan pengguna bertipe <em>"vault"</em> dan durasi validitas selama dua jam, kamu harus mengubah bagian ini pada PodSpec:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/pods/pod-projected-svc-token.yaml download=pods/pod-projected-svc-token.yaml><code>pods/pod-projected-svc-token.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-pod-projected-svc-token-yaml")' title="Copy pods/pod-projected-svc-token.yaml to clipboard"></img></div><div class=includecode id=pods-pod-projected-svc-token-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/run/secrets/tokens<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>vault-token<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>serviceAccountName</span>:<span style=color:#bbb> </span>build-robot<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>vault-token<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>projected</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>sources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>serviceAccountToken</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>vault-token<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>expirationSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>7200</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>audience</span>:<span style=color:#bbb> </span>vault<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Buat Pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f https://k8s.io/examples/pods/pod-projected-svc-token.yaml
</span></span></code></pre></div><p><em>Token</em> yang mewakili Pod akan diminta dan disimpan kubelet, lalu kubelet akan membuat <em>token</em> yang dapat diakses oleh Pod pada <em>file path</em> yang ditentukan, dan melakukan <em>refresh</em> <em>token</em> ketika telah mendekati waktu berakhir. <em>Token</em> akan diganti oleh kubelet jika <em>token</em> telah melewati 80% dari total TTL, atau jika <em>token</em> telah melebihi waktu 24 jam.</p><p>Aplikasi bertanggung jawab untuk memuat ulang <em>token</em> ketika terjadi penggantian. Pemuatan ulang teratur (misalnya sekali setiap 5 menit) cukup untuk mencakup kebanyakan kasus.</p><h2 id=serviceaccountissuerdiscovery>ServiceAccountIssuerDiscovery</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.18 [alpha]</code></div><p>Fitur ServiceAccountIssuerDiscovery diaktifkan dengan mengaktifkan <a href=/docs/reference/command-line-tools-reference/feature-gate>gerbang fitur</a> <code>ServiceAccountIssuerDiscovery</code> dan mengaktifkan fitur <em>Service Account Token Volume Projection</em> seperti yang telah dijelaskan <a href=#service-account-token-volume-projection>di atas</a>.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong><p>URL <em>issuer</em> harus sesuai dengan <em><a href=https://openid.net/specs/openid-connect-discovery-1_0.html>OIDC Discovery Spec</a></em>. Pada implementasinya, hal ini berarti URL harus menggunakan skema <code>https</code> dan harus menyediakan konfigurasi penyedia OpenID pada <code>{service-account-issuer}/.well-known/openid-configuration</code>.</p><p>Jika URL tidak sesuai dengan aturan, <em>endpoint</em> <code>ServiceAccountIssuerDiscovery</code> tidak akan didaftarkan meskipun fitur telah diaktifkan.</p></div><p>Fitur <em>Service Account Issuer Discovery</em> memungkinkan federasi dari berbagai <em>token</em> ServiceAccount Kubernetes yang dibuat oleh sebuah klaster (penyedia identitas) dan sistem eksternal.</p><p>Ketika diaktifkan, server API Kubernetes menyediakan dokumen OpenID Provider Configuration pada <code>/.well-known/openid-configuration</code> dan JSON Web Key Set (JWKS) terkait pada <code>/openid/v1/jwks</code>. OpenID Provider Configuration terkadang disebut juga dengan sebutan <em>discovery document</em>.</p><p>Ketika diaktifkan, klaster juga dikonfigurasi dengan RBAC ClusterRole standar yaitu <code>system:service-account-issuer-discovery</code>. <em>Role binding</em> tidak disediakan secara <em>default</em>. Administrator dimungkinkan untuk, sebagai contoh, menentukan apakah peran akan disematkan ke <code>system:authenticated</code> atau <code>system:unauthenticated</code> tergantung terhadap kebutuhan keamanan dan sistem eksternal yang direncakanan untuk diintegrasikan.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Respons yang disediakan pada <code>/.well-known/openid-configuration</code> dan<code>/openid/v1/jwks</code> dirancang untuk kompatibel dengan OIDC, tetapi tidak sepenuhnya sesuai dengan ketentuan OIDC. Dokumen tersebut hanya berisi parameter yang dibutuhkan untuk melakukan validasi terhadap <em>token</em> ServiceAccount Kubernetes.</div><p>Respons JWKS memuat kunci publik yang dapat digunakan oleh sistem eksternal untuk melakukan validasi <em>token</em> ServiceAccount Kubernetes. Awalnya sistem eksternal akan mengkueri OpenID Provider Configuration, dan selanjutnya dapat menggunakan <em>field</em> <code>jwks_uri</code> pada respons kueri untuk mendapatkan JWKS.</p><p>Pada banyak kasus, server API Kubernetes tidak tersedia di internet publik, namun <em>endpoint</em> publik yang menyediakan respons hasil <em>cache</em> dari server API dapat dibuat menjadi tersedia oleh pengguna atau penyedia servis. Pada kasus ini, dimungkinkan untuk mengganti <code>jwks_uri</code> pada OpenID Provider Configuration untuk diarahkan ke <em>endpoint</em> publik sebagai ganti alamat server API dengan memberikan <em>flag</em> <code>--service-account-jwks-uri</code> ke API server. serupa dengan URL <em>issuer</em>, URI JWKS diharuskan untuk menggunakan skema <code>https</code>.</p><h2 id=selanjutnya>Selanjutnya</h2><p>Lihat juga:</p><ul><li><a href=/docs/reference/access-authn-authz/service-accounts-admin/>Panduan Admin Kluster mengenai ServiceAccount</a></li><li><a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-auth/20190730-oidc-discovery.md>ServiceAccount Signing Key Retrieval KEP</a></li><li><a href=https://openid.net/specs/openid-connect-discovery-1_0.html>OIDC Discovery Spec</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-d385b86a7cb496d3b1c3b2a47280ca70>4.3.7 - Menarik Image dari Register Pribadi</h1><p>Laman ini menunjukkan cara membuat Pod dengan menggunakan Secret untuk menarik <em>image</em> dari sebuah
register atau repositori pribadi untuk Docker.</p><h2 id=sebelum-kamu-memulai>Sebelum kamu memulai</h2><ul><li><p><p>Kamu harus memiliki klaster Kubernetes, dan perangkat baris perintah kubectl
juga harus dikonfigurasikan untuk berkomunikasi dengan klastermu. Jika kamu
belum memiliki klaster, kamu dapat membuatnya dengan menggunakan
<a href=/id/docs/tasks/tools/#minikube>minikube</a>,
atau kamu juga dapat menggunakan salah satu dari tempat mencoba Kubernetes berikut ini:</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>Bermain dengan Kubernetes</a></li></ul>Untuk melihat versi, tekan <code>kubectl version</code>.</p></li><li><p>Untuk melakukan latihan ini, kamu memerlukan sebuah
<a href=https://docs.docker.com/docker-id/>nama pengguna (ID) Docker</a> dan kata sandi (<em>password</em>).</p></li></ul><h2 id=masuk-ke-docker>Masuk (<em>login</em>) ke Docker</h2><p>Pada laptop kamu, kamu harus melakukan autentikasi dengan register untuk menarik <em>image</em> pribadi:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker login
</span></span></code></pre></div><p>Ketika diminta, masukkan nama pengguna dan kata sandi Docker kamu.</p><p>Proses <em>login</em> membuat atau memperbarui berkas <code>config.json</code> yang menyimpan sebuah <em>token</em> otorisasi.</p><p>Lihatlah berkas <code>config.json</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat ~/.docker/config.json
</span></span></code></pre></div><p>Keluaran berisi bagian yang serupa dengan ini:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;auths&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;https://index.docker.io/v1/&#34;</span>: {
</span></span><span style=display:flex><span>            <span style=color:green;font-weight:700>&#34;auth&#34;</span>: <span style=color:#b44>&#34;c3R...zE2&#34;</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Jika kamu menggunakan tempat penyimpanan kredensial (<em>credential</em>) untuk Docker, maka kamu tidak akan melihat entri <code>auth</code> tetapi entri <code>credsStore</code> dengan nama tempat penyimpanan sebagai nilainya.</div><h2 id=register-secret-kredensial-yang-ada>Membuat Secret berdasarkan kredensial Docker yang sudah ada</h2><p>Klaster Kubernetes menggunakan Secret dari tipe <code>docker-registry</code> untuk melakukan autentikasi dengan
register Container untuk menarik <em>image</em> pribadi.</p><p>Jika kamu sudah menjalankan <code>docker login</code>, kamu dapat menyalin kredensial itu ke Kubernetes:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret generic regcred <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    --from-file<span style=color:#666>=</span>.dockerconfigjson<span style=color:#666>=</span>&lt;path/to/.docker/config.json&gt; <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    --type<span style=color:#666>=</span>kubernetes.io/dockerconfigjson
</span></span></code></pre></div><p>Jika kamu memerlukan lebih banyak kontrol (misalnya, untuk mengatur Namespace atau label baru pada Secret)
maka kamu dapat menyesuaikan Secret tersebut sebelum menyimpannya.
Pastikan untuk:</p><ul><li>Mengatur nama dari pokok (<em>item</em>) data menjadi <code>.dockerconfigjson</code></li><li>Melakukan enkode secara <em>base64</em> dari Dockerfile (berkas Docker) dan memindahkan urutan huruf (<em>string</em>) tersebut, secara tidak terputus sebagai nilai untuk bidang <code>data[".dockerconfigjson"]</code></li><li>Mengatur <code>type</code> menjadi <code>kubernetes.io/dockerconfigjson</code></li></ul><p>Sebagai contoh:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myregistrykey<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>awesomeapps<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>.dockerconfigjson</span>:<span style=color:#bbb> </span>UmVhbGx5IHJlYWxseSByZWVlZWVlZWVlZWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGx5eXl5eXl5eXl5eXl5eXl5eXl5eSBsbGxsbGxsbGxsbGxsbG9vb29vb29vb29vb29vb29vb29vb29vb29vb25ubm5ubm5ubm5ubm5ubm5ubm5ubm5ubmdnZ2dnZ2dnZ2dnZ2dnZ2dnZ2cgYXV0aCBrZXlzCg==<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>kubernetes.io/dockerconfigjson<span style=color:#bbb>
</span></span></span></code></pre></div><p>Jika kamu mendapat pesan kesalahan <code>error: no objects passed to create</code>, ini berarti pengkodean <em>base64</em> dari urutan huruf tersebut tidak valid.
Jika kamu mendapat pesan kesalahan seperti <code>Secret "myregistrykey" is invalid: data[.dockerconfigjson]: invalid value ...</code>, ini berarti
enkode <em>base64</em> dari urutan huruf dalam data tersebut sukses didekodekan, tetapi tidak bisa diuraikan menjadi berkas <code>.docker/config.json</code>.</p><h2 id=membuat-secret-dengan-memberikan-kredensial-pada-baris-perintah>Membuat Secret dengan memberikan kredensial pada baris perintah</h2><p>Buatlah Secret ini, dan berilah nama <code>regcred</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret docker-registry regcred --docker-server<span style=color:#666>=</span>&lt;your-registry-server&gt; --docker-username<span style=color:#666>=</span>&lt;your-name&gt; --docker-password<span style=color:#666>=</span>&lt;your-pword&gt; --docker-email<span style=color:#666>=</span>&lt;your-email&gt;
</span></span></code></pre></div><p>dimana:</p><ul><li><code>&lt;your-registry-server></code> merupakan FQDN dari register privat Docker kamu. (<a href=https://index.docker.io/v1/>https://index.docker.io/v1/</a> untuk DockerHub)</li><li><code>&lt;your-name></code> adalah nama pengguna Docker kamu.</li><li><code>&lt;your-pword></code> adalah kata sandi Docker kamu.</li><li><code>&lt;your-email></code> adalah alamat email Docker kamu.</li></ul><p>Kamu telah berhasil mengatur kredensial untuk Docker kamu pada klaster sebagai sebuah Secret yang dipanggil dengan nama <code>regcred</code>.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Mengetik Secret pada baris perintah dapat menyimpannya dalam riwayat (<em>history</em>) dari <em>shell</em> kamu tanpa perlindungan, dan
Secret tersebut mungkin juga terlihat oleh pengguna lain dalam PC kamu selama perintah <code>kubectl</code> sedang berjalan.</div><h2 id=menginspeksi-secret-regcred>Menginspeksi Secret <code>regcred</code></h2><p>Untuk memahami isi Secret <code>regcred</code> yang baru saja kamu buat, mulailah dengan melihat Secret dalam format YAML:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get secret regcred --output<span style=color:#666>=</span>yaml
</span></span></code></pre></div><p>Keluarannya akan seperti ini:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>regcred<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>.dockerconfigjson</span>:<span style=color:#bbb> </span>eyJodHRwczovL2luZGV4L ... J0QUl6RTIifX0=<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>kubernetes.io/dockerconfigjson<span style=color:#bbb>
</span></span></span></code></pre></div><p>Nilai dari bidang <code>.dockerconfigjson</code> merupakan representasi dalam <em>base64</em> dari kredensial Docker kamu.</p><p>Untuk memahami apa yang ada dalam bidang <code>.dockerconfigjson</code>, ubahlah data Secret menjadi format yang bisa terbaca:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get secret regcred --output<span style=color:#666>=</span><span style=color:#b44>&#34;jsonpath={.data.\.dockerconfigjson}&#34;</span> | base64 --decode
</span></span></code></pre></div><p>Keluarannya akan seperti ini:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{<span style=color:green;font-weight:700>&#34;auths&#34;</span>:{<span style=color:green;font-weight:700>&#34;your.private.registry.example.com&#34;</span>:{<span style=color:green;font-weight:700>&#34;username&#34;</span>:<span style=color:#b44>&#34;janedoe&#34;</span>,<span style=color:green;font-weight:700>&#34;password&#34;</span>:<span style=color:#b44>&#34;xxxxxxxxxxx&#34;</span>,<span style=color:green;font-weight:700>&#34;email&#34;</span>:<span style=color:#b44>&#34;jdoe@example.com&#34;</span>,<span style=color:green;font-weight:700>&#34;auth&#34;</span>:<span style=color:#b44>&#34;c3R...zE2&#34;</span>}}}
</span></span></code></pre></div><p>Untuk memahami apa yang ada dalam bidang <code>auth</code>, ubahlah data Secret menjadi format yang bisa terbaca:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b44>&#34;c3R...zE2&#34;</span> | base64 --decode
</span></span></code></pre></div><p>Keluarannya, nama pengguna dan kata sandi yang digabungkan dengan tanda <code>:</code>, seperti dibawah ini:</p><pre tabindex=0><code class=language-none data-lang=none>janedoe:xxxxxxxxxxx
</code></pre><p>Perhatikan bahwa data Secret berisi token otorisasi yang serupa dengan berkas <code>~/.docker/config.json</code> lokal kamu.</p><p>Kamu telah berhasil menetapkan kredensial Docker kamu sebagai sebuah Secret yang dipanggil dengan <code>regcred</code> pada klaster.</p><h2 id=membuat-pod-yang-menggunakan-secret-kamu>Membuat Pod yang menggunakan Secret kamu</h2><p>Berikut ini adalah berkas konfigurasi untuk Pod yang memerlukan akses ke kredensial Docker kamu pada <code>regcred</code>:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/pods/private-reg-pod.yaml download=pods/private-reg-pod.yaml><code>pods/private-reg-pod.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-private-reg-pod-yaml")' title="Copy pods/private-reg-pod.yaml to clipboard"></img></div><div class=includecode id=pods-private-reg-pod-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>private-reg<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>private-reg-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>&lt;image-pribadi-kamu&gt;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>imagePullSecrets</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>regcred<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Unduh berkas diatas:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>wget -O my-private-reg-pod.yaml https://k8s.io/examples/pods/private-reg-pod.yaml
</span></span></code></pre></div><p>Dalam berkas <code>my-private-reg-pod.yaml</code>, ubah <code>&lt;your-private-image></code> dengan tautan ke <em>image</em> dalam register pribadi seperti ini:</p><pre tabindex=0><code class=language-none data-lang=none>your.private.registry.example.com/janedoe/jdoe-private:v1
</code></pre><p>Untuk menarik <em>image</em> dari register pribadi, Kubernetes memerlukan kredensial.
Bidang <code>imagePullSecrets</code> dalam berkas konfigurasi menentukan bahwa Kubernetes harus mendapatkan kredensial dari Secret yang bernama <code>regcred</code>.</p><p>Buatlah Pod yang menggunakan Secret kamu, dan verifikasi bahwa Pod tersebut berjalan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f my-private-reg-pod.yaml
</span></span><span style=display:flex><span>kubectl get pod private-reg
</span></span></code></pre></div><h2 id=selanjutnya>Selanjutnya</h2><ul><li>Pelajari lebih lanjut tentang <a href=/id/docs/concepts/configuration/secret/>Secret</a>.</li><li>Pelajari lebih lanjut tentang <a href=/id/docs/concepts/containers/images/#menggunakan-register-privat>menggunakan register pribadi</a>.</li><li>Pelajari lebih lanjut tentang <a href=/id/docs/tasks/configure-pod-container/configure-service-account/#add-imagepullsecrets-to-a-service-account>menambahkan Secret untuk menarik <em>image</em> ke dalam sebuah akun service</a>.</li><li>Lihatlah <a href=/docs/reference/generated/kubectl/kubectl-commands/#-em-secret-docker-registry-em->kubectl create secret docker-registry</a>.</li><li>Lihatlah <a href=/docs/reference/generated/kubernetes-api/v1.25/#secret-v1-core>Secret</a>.</li><li>Lihatlah bidang <code>imagePullSecrets</code> dari <a href=/docs/reference/generated/kubernetes-api/v1.25/#podspec-v1-core>PodSpec</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-eb54daf87df373096b5e830680194dfc>4.3.8 - Mengatur Probe Liveness, Readiness dan Startup</h1><p>Laman ini memperlihatkan bagaimana cara untuk mengatur <em>probe liveness</em>, <em>readiness</em>, dan
<em>startup</em> untuk Container.</p><p><em>Probe liveness</em> digunakan oleh <a href=/docs/admin/kubelet/>kubelet</a> untuk mengetahui
kapan perlu mengulang kembali (<em>restart</em>) sebuah Container. Sebagai contoh, <em>probe liveness</em>
dapat mendeteksi <em>deadlock</em>, ketika aplikasi sedang berjalan tapi tidak dapat berfungsi dengan baik.
Mengulang Container dengan <em>state</em> tersebut dapat membantu ketersediaan aplikasi yang lebih baik
walaupun ada kekutu (<em>bug</em>).</p><p><em>Probe readiness</em> digunakan oleh kubelet untuk mengetahui kapan sebuah Container telah siap untuk
menerima lalu lintas jaringan (<em>traffic</em>). Suatu Pod dianggap siap saat semua Container di dalamnya telah
siap. Sinyal ini berguna untuk mengontrol Pod-Pod mana yang digunakan sebagai <em>backend</em> dari Service.
Ketika Pod dalam kondisi tidak siap, Pod tersebut dihapus dari Service <em>load balancer</em>.</p><p><em>Probe startup</em> digunakan oleh kubelet untuk mengetahui kapan sebuah aplikasi Container telah mulai berjalan.
Jika <em>probe</em> tersebut dinyalakan, <em>probe</em> akan menonaktifkan pemeriksaan <em>liveness</em> dan <em>readiness</em> sampai
berhasil, kamu harus memastikan <em>probe</em> tersebut tidak mengganggu <em>startup</em> dari aplikasi.
Mekanisme ini dapat digunakan untuk mengadopsi pemeriksaan <em>liveness</em> pada saat memulai Container yang lambat,
untuk menghindari Container dimatikan oleh kubelet sebelum Container mulai dan berjalan.</p><h2 id=sebelum-kamu-memulai>Sebelum kamu memulai</h2><p><p>Kamu harus memiliki klaster Kubernetes, dan perangkat baris perintah kubectl
juga harus dikonfigurasikan untuk berkomunikasi dengan klastermu. Jika kamu
belum memiliki klaster, kamu dapat membuatnya dengan menggunakan
<a href=/id/docs/tasks/tools/#minikube>minikube</a>,
atau kamu juga dapat menggunakan salah satu dari tempat mencoba Kubernetes berikut ini:</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>Bermain dengan Kubernetes</a></li></ul>Untuk melihat versi, tekan <code>kubectl version</code>.</p><h2 id=mendefinisikan-perintah-liveness>Mendefinisikan perintah liveness</h2><p>Kebanyakan aplikasi yang telah berjalan dalam waktu lama pada akhirnya akan
bertransisi ke <em>state</em> yang rusak (<em>broken</em>), dan tidak dapat pulih kecuali diulang kembali.
Kubernetes menyediakan <em>probe liveness</em> untuk mendeteksi dan memperbaiki situasi tersebut.</p><p>Pada latihan ini, kamu akan membuat Pod yang menjalankan Container dari image
<code>k8s.gcr.io/busybox</code>. Berikut ini adalah berkas konfigurasi untuk Pod tersebut:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/pods/probe/exec-liveness.yaml download=pods/probe/exec-liveness.yaml><code>pods/probe/exec-liveness.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-probe-exec-liveness-yaml")' title="Copy pods/probe/exec-liveness.yaml to clipboard"></img></div><div class=includecode id=pods-probe-exec-liveness-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>test</span>:<span style=color:#bbb> </span>liveness<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>liveness-exec<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>liveness<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- /bin/sh<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- -c<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- touch /tmp/healthy; sleep 30; rm -f /tmp/healthy; sleep 600<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>livenessProbe</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>exec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- cat<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- /tmp/healthy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>initialDelaySeconds</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Pada berkas konfigurasi di atas, kamu dapat melihat bahwa Pod memiliki satu <code>Container</code>.
<em>Field</em> <code>periodSeconds</code> menentukan bahwa kubelet harus melakukan <em>probe liveness</em> setiap 5 detik.
<em>Field</em> <code>initialDelaySeconds</code> memberitahu kubelet untuk menunggu 5 detik sebelum mengerjakan
<em>probe</em> yang pertama. Untuk mengerjakan <em>probe</em>, kubelet menjalankan perintah <code>cat /tmp/healthy</code>
pada Container tujuan. Jika perintah berhasil, kode 0 akan dikembalikan, dan kubelet menganggap
Container sedang dalam kondisi hidup (<em>alive</em>) dan sehat (<em>healthy</em>). Jika perintah mengembalikan
kode selain 0, maka kubelet akan mematikan Container dan mengulangnya kembali.</p><p>Saat dimulai, Container akan menjalankan perintah berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>/bin/sh -c <span style=color:#b44>&#34;touch /tmp/healthy; sleep 30; rm -f /tmp/healthy; sleep 600&#34;</span>
</span></span></code></pre></div><p>Container memiliki berkas <code>/tmp/healthy</code> pada saat 30 detik pertama setelah dijalankan.
Kemudian, perintah <code>cat /tmp/healthy</code> mengembalikan kode sukses. Namun setelah 30 detik,
<code>cat /tmp/healthy</code> mengembalikan kode gagal.</p><p>Buatlah sebuah Pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/probe/exec-liveness.yaml
</span></span></code></pre></div><p>Dalam 30 detik pertama, lihatlah <em>event</em> dari Pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe pod liveness-exec
</span></span></code></pre></div><p>Keluaran dari perintah tersebut memperlihatkan bahwa belum ada <em>probe liveness</em> yang gagal:</p><pre tabindex=0><code>FirstSeen    LastSeen    Count   From            SubobjectPath           Type        Reason      Message
--------- --------    -----   ----            -------------           --------    ------      -------
24s       24s     1   {default-scheduler }                    Normal      Scheduled   Successfully assigned liveness-exec to worker0
23s       23s     1   {kubelet worker0}   spec.containers{liveness}   Normal      Pulling     pulling image &#34;k8s.gcr.io/busybox&#34;
23s       23s     1   {kubelet worker0}   spec.containers{liveness}   Normal      Pulled      Successfully pulled image &#34;k8s.gcr.io/busybox&#34;
23s       23s     1   {kubelet worker0}   spec.containers{liveness}   Normal      Created     Created container with docker id 86849c15382e; Security:[seccomp=unconfined]
23s       23s     1   {kubelet worker0}   spec.containers{liveness}   Normal      Started     Started container with docker id 86849c15382e
</code></pre><p>Setelah 35 detik, lihatlah lagi <em>event</em> Pod tersebut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe pod liveness-exec
</span></span></code></pre></div><p>Baris terakhir dari keluaran tersebut memperlihatkan pesan bahwa <em>probe liveness</em>
mengalami kegagalan, dan Container telah dimatikan dan dibuat ulang.</p><pre tabindex=0><code>FirstSeen LastSeen    Count   From            SubobjectPath           Type        Reason      Message
--------- --------    -----   ----            -------------           --------    ------      -------
37s       37s     1   {default-scheduler }                    Normal      Scheduled   Successfully assigned liveness-exec to worker0
36s       36s     1   {kubelet worker0}   spec.containers{liveness}   Normal      Pulling     pulling image &#34;k8s.gcr.io/busybox&#34;
36s       36s     1   {kubelet worker0}   spec.containers{liveness}   Normal      Pulled      Successfully pulled image &#34;k8s.gcr.io/busybox&#34;
36s       36s     1   {kubelet worker0}   spec.containers{liveness}   Normal      Created     Created container with docker id 86849c15382e; Security:[seccomp=unconfined]
36s       36s     1   {kubelet worker0}   spec.containers{liveness}   Normal      Started     Started container with docker id 86849c15382e
2s        2s      1   {kubelet worker0}   spec.containers{liveness}   Warning     Unhealthy   Liveness probe failed: cat: can&#39;t open &#39;/tmp/healthy&#39;: No such file or directory
</code></pre><p>Tunggu 30 detik lagi, dan verifikasi bahwa Container telah diulang kembali:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod liveness-exec
</span></span></code></pre></div><p>Keluaran perintah tersebut memperlihatkan bahwa jumlah <code>RESTARTS</code> telah meningkat:</p><pre tabindex=0><code>NAME            READY     STATUS    RESTARTS   AGE
liveness-exec   1/1       Running   1          1m
</code></pre><h2 id=mendefinisikan-probe-liveness-dengan-permintaan-http>Mendefinisikan probe liveness dengan permintaan HTTP</h2><p>Jenis kedua dari <em>probe liveness</em> menggunakan sebuah permintaan GET HTTP. Berikut ini
berkas konfigurasi untuk Pod yang menjalankan Container dari image <code>k8s.gcr.io/liveness</code>.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/pods/probe/http-liveness.yaml download=pods/probe/http-liveness.yaml><code>pods/probe/http-liveness.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-probe-http-liveness-yaml")' title="Copy pods/probe/http-liveness.yaml to clipboard"></img></div><div class=includecode id=pods-probe-http-liveness-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>test</span>:<span style=color:#bbb> </span>liveness<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>liveness-http<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>liveness<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/liveness<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- /server<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>livenessProbe</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>httpGet</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/healthz<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>httpHeaders</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>Custom-Header<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span>Awesome<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>initialDelaySeconds</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Pada berkas konfigurasi tersebut, kamu dapat melihat Pod memiliki sebuah Container.
<em>Field</em> <code>periodSeconds</code> menentukan bahwa kubelet harus mengerjakan <em>probe liveness</em> setiap 3 detik.
<em>Field</em> <code>initialDelaySeconds</code> memberitahu kubelet untuk menunggu 3 detik sebelum mengerjakan
<em>probe</em> yang pertama. Untuk mengerjakan <em>probe</em> tersebut, kubelet mengirimkan sebuah permintaan
GET HTTP ke server yang sedang berjalan di dalam Container dan mendengarkan (<em>listen</em>) pada porta 8080.
Jika <em>handler path</em> <code>/healthz</code> yang dimiliki server mengembalikan kode sukses, kubelet menganggap
Container sedang dalam kondisi hidup dan sehat. Jika <em>handler</em> mengembalikan kode gagal,
kubelet mematikan Container dan mengulangnya kembali.</p><p>Kode yang lebih besar atau sama dengan 200 dan kurang dari 400 mengindikasikan kesuksesan.
Kode selain ini mengindikasikan kegagalan.</p><p>Kamu dapat melihat kode program untuk server ini pada <a href=https://github.com/kubernetes/kubernetes/blob/main/test/images/agnhost/liveness/server.go>server.go</a>.</p><p>Untuk 10 detik pertama setelah Container hidup (<em>alive</em>), <em>handler</em> <code>/healthz</code> mengembalikan
status 200. Setelah itu, <em>handler</em> mengembalikan status 500.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>http.<span style=color:#00a000>HandleFunc</span>(<span style=color:#b44>&#34;/healthz&#34;</span>, <span style=color:#a2f;font-weight:700>func</span>(w http.ResponseWriter, r <span style=color:#666>*</span>http.Request) {
</span></span><span style=display:flex><span>    duration <span style=color:#666>:=</span> time.<span style=color:#00a000>Now</span>().<span style=color:#00a000>Sub</span>(started)
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>if</span> duration.<span style=color:#00a000>Seconds</span>() &gt; <span style=color:#666>10</span> {
</span></span><span style=display:flex><span>        w.<span style=color:#00a000>WriteHeader</span>(<span style=color:#666>500</span>)
</span></span><span style=display:flex><span>        w.<span style=color:#00a000>Write</span>([]<span style=color:#a2f>byte</span>(fmt.<span style=color:#00a000>Sprintf</span>(<span style=color:#b44>&#34;error: %v&#34;</span>, duration.<span style=color:#00a000>Seconds</span>())))
</span></span><span style=display:flex><span>    } <span style=color:#a2f;font-weight:700>else</span> {
</span></span><span style=display:flex><span>        w.<span style=color:#00a000>WriteHeader</span>(<span style=color:#666>200</span>)
</span></span><span style=display:flex><span>        w.<span style=color:#00a000>Write</span>([]<span style=color:#a2f>byte</span>(<span style=color:#b44>&#34;ok&#34;</span>))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>})
</span></span></code></pre></div><p>Pemeriksaan kesehatan (<em>health check</em>) dilakukan kubelet 3 detik setelah Container dimulai,
sehingga beberapa pemeriksaaan pertama akan berhasil. Namun setelah 10 detik,
pemeriksaan akan gagal, dan kubelet akan mematikan dan mengulang Container kembali.</p><p>Untuk mencoba pemeriksaan <em>liveness</em> HTTP, marilah membuat sebuah Pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/probe/http-liveness.yaml
</span></span></code></pre></div><p>Setelah 10 detik, lihatlah <em>event</em> Pod untuk memverifikasi bahwa <em>probe liveness</em>
telah gagal dan Container telah diulang kembali:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe pod liveness-http
</span></span></code></pre></div><p>Untuk rilis sebelum v1.13 (termasuk v1.13), jika variabel lingkungan
<code>http_proxy</code> (atau <code>HTTP_PROXY</code>) telah diatur pada Node dimana Pod
berjalan, <em>probe liveness</em> HTTP akan menggunakan proksi tersebut.
Untuk rilis setelah v1.13, pengaturan variabel lingkungan pada proksi HTTP lokal
tidak mempengaruhi <em>probe liveness</em> HTTP.</p><h2 id=mendefinisikan-probe-liveness-tcp>Mendefinisikan probe liveness TCP</h2><p>Jenis ketiga dari <em>probe liveness</em> menggunakaan sebuah soket TCP. Dengan konfigurasi ini,
kubelet akan mencoba untuk membuka soket pada Container kamu dengan porta tertentu.
Jika koneksi dapat terbentuk dengan sukses, maka Container dianggap dalam kondisi sehat.
Namun jika tidak berhasil terbentuk, maka Container dianggap gagal.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/pods/probe/tcp-liveness-readiness.yaml download=pods/probe/tcp-liveness-readiness.yaml><code>pods/probe/tcp-liveness-readiness.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-probe-tcp-liveness-readiness-yaml")' title="Copy pods/probe/tcp-liveness-readiness.yaml to clipboard"></img></div><div class=includecode id=pods-probe-tcp-liveness-readiness-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>goproxy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>goproxy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>goproxy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/goproxy:0.1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>readinessProbe</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>tcpSocket</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>initialDelaySeconds</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>livenessProbe</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>tcpSocket</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>initialDelaySeconds</span>:<span style=color:#bbb> </span><span style=color:#666>15</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>20</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Seperti yang terlihat, konfigurasi untuk pemeriksaan TCP cukup mirip dengan
pemeriksaan HTTP. Contoh ini menggunakan <em>probe readiness</em> dan <em>liveness</em>.
<em>Probe readiness</em> yang pertama akan dikirimkan oleh kubelet, 5 detik setelah
Container mulai dijalankan. Container akan coba dihubungkan oleh kubelet dengan
<code>goproxy</code> pada porta 8080. Jika <em>probe</em> berhasil, maka Pod akan ditandai menjadi
<em>ready</em>. Pemeriksaan ini akan dilanjutkan oleh kubelet setiap 10 detik.</p><p>Selain <em>probe readiness</em>, <em>probe liveness</em> juga termasuk di dalam konfigurasi.
<em>Probe liveness</em> yang pertama akan dijalankan oleh kubelet, 15 detik setelah Container
mulai dijalankan. Sama seperti <em>probe readiness</em>, kubelet akan mencoba untuk
terhubung dengan Container <code>goproxy</code> pada porta 8080. Jika <em>probe liveness</em> gagal,
maka Container akan diulang kembali.</p><p>Untuk mencoba pemeriksaan <em>liveness</em> TCP, marilah membuat sebuah Pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/probe/tcp-liveness-readiness.yaml
</span></span></code></pre></div><p>Setelah 15 detik, lihatlah <em>event</em> Pod untuk memverifikasi <em>probe liveness</em> tersebut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe pod goproxy
</span></span></code></pre></div><h2 id=menggunakan-sebuah-porta-dengan-nama>Menggunakan sebuah porta dengan nama</h2><p>Kamu dapat menggunakan
<a href=/docs/reference/generated/kubernetes-api/v1.25/#containerport-v1-core>ContainerPort</a>
dengan nama untuk melakukan pemeriksaan <em>liveness</em> HTTP atau TCP:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>liveness-port<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostPort</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>livenessProbe</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>httpGet</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/healthz<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span>liveness-port<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=mendefinisikan-probe-startup>Melindungi Container yang lambat untuk dimulai dengan probe startup</h2><p>Terkadang kamu harus berurusan dengan aplikasi peninggalan (<em>legacy</em>) yang
memerlukan waktu tambahan untuk mulai berjalan pada saat pertama kali diinisialisasi.
Pada kasus ini, cukup rumit untuk mengatur parameter <em>probe liveness</em> tanpa
mengkompromikan respons yang cepat terhadap <em>deadlock</em> yang memotivasi digunakannya
probe_ tersebut. Triknya adalah mengatur <em>probe startup</em> dengan perintah yang sama,
baik pemeriksaan HTTP ataupun TCP, dengan <code>failureThreshold * periodSeconds</code> yang
mencukupi untuk kemungkinan waktu memulai yang terburuk.</p><p>Sehingga, contoh sebelumnya menjadi:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>liveness-port<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostPort</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>livenessProbe</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>httpGet</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/healthz<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span>liveness-port<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>failureThreshold</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>startupProbe</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>httpGet</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/healthz<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span>liveness-port<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>failureThreshold</span>:<span style=color:#bbb> </span><span style=color:#666>30</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Berkat <em>probe startup</em>, aplikasi akan memiliki paling lambat 5 menit (30 * 10 = 300 detik)
untuk selesai memulai.
Ketika <em>probe startup</em> telah berhasil satu kali, maka <em>probe liveness</em> akan
mengambil alih untuk menyediakan respons cepat terhadap <em>deadlock</em> Container.
Jika <em>probe startup</em> tidak pernah berhasil, maka Container akan dimatikan setelah
300 detik dan perilakunya akan bergantung pada <code>restartPolicy</code> yang dimiliki Pod.</p><h2 id=mendefinisikan-probe-readiness>Mendefinisikan probe readiness</h2><p>Terkadang aplikasi tidak dapat melayani lalu lintas jaringan sementara.
Contohnya, aplikasi mungkin perlu untuk memuat data besar atau berkas konfigurasi
saat dimulai, atau aplikasi bergantung pada layanan eksternal setelah dimulai.
Pada kasus-kasus ini, kamu tidak ingin mematikan aplikasi, tetapi kamu tidak
ingin juga mengirimkan permintaan ke aplikasi tersebut. Kubernetes menyediakan
<em>probe readiness</em> sebagai solusinya. Sebuah Pod dengan Container yang melaporkan
dirinya tidak siap, tidak akan menerima lalu lintas jaringan dari Kubernetes Service.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> <em>Probe readiness</em> dijalankan di dalam Container selama siklus hidupnya.</div><p><em>Probe readiness</em> memiliki pengaturan yang mirip dengan <em>probe liveness</em>. Perbedaan
satu-satunya adalah kamu menggunakan <em>field</em> <code>readinessProbe</code>, bukan <em>field</em> <code>livenessProbe</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>readinessProbe</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>exec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- cat<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- /tmp/healthy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>initialDelaySeconds</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Pengaturan untuk <em>probe readiness</em> untuk HTTP dan TCP juga sama persis dengan
pengaturan untuk <em>probe liveness</em>.</p><p><em>Probe readiness</em> dan <em>liveness</em> dapat digunakan secara bersamaan untuk
Container yang sama. Apabila keduanya digunakan sekaligus, lalu lintas jaringan
tidak akan sampai ke Container yang belum siap, dan Container akan diulang kembali
(<em>restart</em>) saat mengalami kegagalan.</p><h2 id=mengatur-probe>Mengatur Probe</h2><p><a href=/docs/reference/generated/kubernetes-api/v1.25/#probe-v1-core>Probe</a> memiliki
beberapa <em>field</em> yang dapat digunakan untuk mengendalikan pemeriksaan <em>liveness</em> dan <em>readiness</em>
secara presisi.</p><ul><li><code>initialDelaySeconds</code>: Durasi dalam detik setelah Container dimulai,
sebelum <em>probe liveness</em> atau <em>readiness</em> diinisiasi. Nilai bawaannya adalah 0 detik. Nilai minimalnya adalah 0.</li><li><code>periodSeconds</code>: Seberapa sering (dalam detik) <em>probe</em> dijalankan. Nilai bawaannya adalah 10 detik.
Nilai minimalnya adalah 0.</li><li><code>timeoutSeconds</code>: Durasi dalam detik setelah <em>probe</em> mengalami <em>timeout</em>. Nilai bawaannya adalah 1 detik.
Nilai minimalnya adalah 0.</li><li><code>successThreshold</code>: Jumlah minimal sukses yang berurutan untuk <em>probe</em> dianggap berhasil
setelah mengalami kegagalan. Nilai bawaannya adalah 1. Nilanya harus 1 untuk <em>liveness</em>.
Nilai minimalnya adalah 1.</li><li><code>failureThreshold</code>: Ketika sebuah Pod dimulai dan <em>probe</em> mengalami kegagalan, Kubernetes
akan mencoba beberapa kali sesuai nilai <code>failureThreshold</code> sebelum menyerah. Menyerah dalam
kasus <em>probe liveness</em> berarti Container akan diulang kembali. Untuk <em>probe readiness</em>, menyerah
akan menandai Pod menjadi "tidak siap" (<em>Unready</em>). Nilai bawaannya adalah 3. Nilai minimalnya adalah 1.</li></ul><p><a href=/docs/reference/generated/kubernetes-api/v1.25/#httpgetaction-v1-core><em>Probe</em> HTTP</a>
memiliki <em>field-field</em> tambahan yang bisa diatur melalui <code>httpGet</code>:</p><ul><li><code>host</code>: Nama dari host yang akan terhubung, nilai bawaannya adalah IP dari Pod. Kamu mungkin
juga ingin mengatur "Host" pada httpHeaders.</li><li><code>scheme</code>: Skema yang digunakan untuk terhubung pada host (HTTP atau HTTPS). Nilai bawaannya adalah HTTP.</li><li><code>path</code>: <em>Path</em> untuk mengakses server HTTP.</li><li><code>httpHeaders</code>: <em>Header</em> khusus yang diatur dalam permintaan HTTP. HTTP memperbolehkan <em>header</em> yang berulang.</li><li><code>port</code>: Nama atau angka dari porta untuk mengakses Container. Angkanya harus ada di antara 1 sampai 65535.</li></ul><p>Untuk sebuah <em>probe</em> HTTP, kubelet mengirimkan permintaan HTTP untuk <em>path</em> yang ditentukan
dan porta untuk mengerjakan pemeriksaan. <em>Probe</em> dikirimkan oleh kubelet untuk alamat IP Pod,
kecuali saat alamat digantikan oleh <em>field</em> opsional pada <code>httpGet</code>. Jika <em>field</em> <code>scheme</code>
diatur menjadi <code>HTTPS</code>, maka kubelet mengirimkan permintaan HTTPS dan melewati langkah verifikasi
sertifikat. Pada skenario kebanyakan, kamu tidak menginginkan <em>field</em> <code>host</code>.
Berikut satu skenario yang memerlukan <code>host</code>. Misalkan Container mendengarkan permintaan
melalui 127.0.0.1 dan <em>field</em> <code>hostNetwork</code> pada Pod bernilai true. Kemudian <code>host</code>, melalui
<code>httpGet</code>, harus diatur menjadi 127.0.0.1. Jika Pod kamu bergantung pada host virtual, dimana
untuk kasus-kasus umum, kamu tidak perlu menggunakan <code>host</code>, tetapi perlu mengatur <em>header</em>
<code>Host</code> pada <code>httpHeaders</code>.</p><p>Untuk <em>probe</em> TCP, kubelet membuat koneksi <em>probe</em> pada Node, tidak pada Pod, yang berarti bahwa
kamu tidak menggunakan nama Service di dalam parameter <code>host</code> karena kubelet tidak bisa
me-<em>resolve</em>-nya.</p><h2 id=selanjutnya>Selanjutnya</h2><ul><li>Pelajari lebih lanjut tentang
<a href=/id/docs/concepts/workloads/pods/pod-lifecycle/#container-probes>Probe Container</a>.</li></ul><p>Kamu juga dapat membaca rujukan API untuk:</p><ul><li><a href=/docs/reference/generated/kubernetes-api/v1.25/#pod-v1-core>Pod</a></li><li><a href=/docs/reference/generated/kubernetes-api/v1.25/#container-v1-core>Container</a></li><li><a href=/docs/reference/generated/kubernetes-api/v1.25/#probe-v1-core>Probe</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-fc3f4777ae8ea685d2b54e175277ac01>4.3.9 - Menempatkan Pod pada Node Menggunakan Afinitas Pod</h1><p>Dokumen ini menunjukkan cara menempatkan Pod Kubernetes pada sebuah Node menggunakan
Afinitas Node di dalam klaster Kubernetes.</p><h2 id=sebelum-kamu-memulai>Sebelum kamu memulai</h2><p><p>Kamu harus memiliki klaster Kubernetes, dan perangkat baris perintah kubectl
juga harus dikonfigurasikan untuk berkomunikasi dengan klastermu. Jika kamu
belum memiliki klaster, kamu dapat membuatnya dengan menggunakan
<a href=/id/docs/tasks/tools/#minikube>minikube</a>,
atau kamu juga dapat menggunakan salah satu dari tempat mencoba Kubernetes berikut ini:</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>Bermain dengan Kubernetes</a></li></ul>Kubernetes servermu harus dalam versi yang sama atau lebih baru dari v1.10.
Untuk melihat versi, tekan <code>kubectl version</code>.</p><h2 id=menambahkan-sebuah-label-pada-sebuah-node>Menambahkan sebuah Label pada sebuah Node</h2><ol><li><p>Jabarkan Node-Node yang ada pada klaster kamu, bersamaan dengan label yang ada:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get nodes --show-labels
</span></span></code></pre></div><p>Keluaran dari perintah tersebut akan berupa:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME      STATUS    ROLES    AGE     VERSION        LABELS
</span></span><span style=display:flex><span>worker0   Ready     &lt;none&gt;   1d      v1.13.0        ...,kubernetes.io/hostname<span style=color:#666>=</span>worker0
</span></span><span style=display:flex><span>worker1   Ready     &lt;none&gt;   1d      v1.13.0        ...,kubernetes.io/hostname<span style=color:#666>=</span>worker1
</span></span><span style=display:flex><span>worker2   Ready     &lt;none&gt;   1d      v1.13.0        ...,kubernetes.io/hostname<span style=color:#666>=</span>worker2
</span></span></code></pre></div></li><li><p>Pilihkan salah satu dari Node yang ada dan tambahkan label pada Node tersebut.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl label nodes &lt;nama-node-kamu&gt; <span style=color:#b8860b>disktype</span><span style=color:#666>=</span>ssd
</span></span></code></pre></div><p>dimana <code>&lt;nama-node-kamu></code> merupakan nama dari Node yang kamu pilih.</p></li><li><p>Keluaran dari Node yang kamu pilih dan sudah memiliki label <code>disktype=ssd</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get nodes --show-labels
</span></span></code></pre></div><p>Keluaran dari perintah tersebut akan berupa:</p><pre tabindex=0><code>NAME      STATUS    ROLES    AGE     VERSION        LABELS
worker0   Ready     &lt;none&gt;   1d      v1.13.0        ...,disktype=ssd,kubernetes.io/hostname=worker0
worker1   Ready     &lt;none&gt;   1d      v1.13.0        ...,kubernetes.io/hostname=worker1
worker2   Ready     &lt;none&gt;   1d      v1.13.0        ...,kubernetes.io/hostname=worker2
</code></pre><p>Pada keluaran dari perintah di atas, kamu dapat melihat bahwa Node <code>worker0</code>
memiliki label <code>disktype=ssd</code>.</p></li></ol><h2 id=menjadwalkan-pod-menggunakan-afinitas-node>Menjadwalkan Pod menggunakan Afinitas Node</h2><p>Konfigurasi ini menunjukkan sebuah Pod yang memiliki afinitas node <code>requiredDuringSchedulingIgnoredDuringExecution</code>, <code>disktype: ssd</code>.
Dengan kata lain, Pod hanya akan dijadwalkan hanya pada Node yang memiliki label <code>disktype=ssd</code>.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/pods/pod-nginx-required-affinity.yaml download=pods/pod-nginx-required-affinity.yaml><code>pods/pod-nginx-required-affinity.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-pod-nginx-required-affinity-yaml")' title="Copy pods/pod-nginx-required-affinity.yaml to clipboard"></img></div><div class=includecode id=pods-pod-nginx-required-affinity-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>affinity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>nodeAffinity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requiredDuringSchedulingIgnoredDuringExecution</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>nodeSelectorTerms</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>disktype<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- ssd            <span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>IfNotPresent<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><ol><li><p>Terapkan konfigurasi berikut untuk membuat sebuah Pod yang akan dijadwalkan pada Node yang kamu pilih:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/pod-nginx-required-affinity.yaml
</span></span></code></pre></div></li><li><p>Verifikasi apakah Pod yang kamu pilih sudah dijalankan pada Node yang kamu pilih:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods --output<span style=color:#666>=</span>wide
</span></span></code></pre></div><p>Keluaran dari perintah tersebut akan berupa:</p><pre tabindex=0><code>NAME     READY     STATUS    RESTARTS   AGE    IP           NODE
nginx    1/1       Running   0          13s    10.200.0.4   worker0
</code></pre></li></ol><h2 id=jadwalkan-pod-menggunakan-afinitas-node-yang-dipilih>Jadwalkan Pod menggunakan Afinitas Node yang Dipilih</h2><p>Konfigurasi ini memberikan deskripsi sebuah Pod yang memiliki afinitas Node <code>preferredDuringSchedulingIgnoredDuringExecution</code>,<code>disktype: ssd</code>.
Artinya Pod akan diutamakan dijalankan pada Node yang memiliki label <code>disktype=ssd</code>.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/pods/pod-nginx-preferred-affinity.yaml download=pods/pod-nginx-preferred-affinity.yaml><code>pods/pod-nginx-preferred-affinity.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-pod-nginx-preferred-affinity-yaml")' title="Copy pods/pod-nginx-preferred-affinity.yaml to clipboard"></img></div><div class=includecode id=pods-pod-nginx-preferred-affinity-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>affinity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>nodeAffinity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>preferredDuringSchedulingIgnoredDuringExecution</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>weight</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>preference</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>disktype<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- ssd          <span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>IfNotPresent<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><ol><li><p>Terapkan konfigurasi berikut untuk membuat sebuah Pod yang akan dijadwalkan pada Node yang kamu pilih:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/pod-nginx-preferred-affinity.yaml
</span></span></code></pre></div></li><li><p>Verifikasi apakah Pod yang kamu pilih sudah dijalankan pada Node yang kamu pilih:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods --output<span style=color:#666>=</span>wide
</span></span></code></pre></div><p>Keluaran dari perintah tersebut akan berupa:</p><pre tabindex=0><code>NAME     READY     STATUS    RESTARTS   AGE    IP           NODE
nginx    1/1       Running   0          13s    10.200.0.4   worker0
</code></pre></li></ol><h2 id=selanjutnya>Selanjutnya</h2><p>Pelajari lebih lanjut mengenai
<a href=/id/docs/concepts/scheduling-eviction/assign-pod-node/#node-affinity>Afinitas Node</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-ed34e761c3dbd00fa79577fa78e30020>4.3.10 - Mengatur Pod untuk Menggunakan ConfigMap</h1><p>ConfigMap mengizinkan kamu untuk memisahkan artifak-artifak konfigurasi dari konten <em>image</em> untuk menjaga aplikasi yang dikontainerisasi tetap portabel. Artikel ini menyediakan sekumpulan contoh penerapan yang mendemonstrasikan bagaimana cara membuat ConfigMap dan mengatur Pod menggunakan data yang disimpan di dalam ConfigMap.</p><h2 id=sebelum-kamu-memulai>Sebelum kamu memulai</h2><p><p>Kamu harus memiliki klaster Kubernetes, dan perangkat baris perintah kubectl
juga harus dikonfigurasikan untuk berkomunikasi dengan klastermu. Jika kamu
belum memiliki klaster, kamu dapat membuatnya dengan menggunakan
<a href=/id/docs/tasks/tools/#minikube>minikube</a>,
atau kamu juga dapat menggunakan salah satu dari tempat mencoba Kubernetes berikut ini:</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>Bermain dengan Kubernetes</a></li></ul>Untuk melihat versi, tekan <code>kubectl version</code>.</p><h2 id=membuat-configmap>Membuat ConfigMap</h2><p>Kamu dapat menggunakan <code>kubectl create configmap</code> ataupun generator ConfigMap pada <code>kustomization.yaml</code> untuk membuat sebuah ConfigMap. Perlu diingat bahwa <code>kubectl</code> mulai mendukung <code>kustomization.yaml</code> sejak versi 1.14.</p><h3 id=membuat-configmap-menggunakan-kubectl-create-configmap>Membuat ConfigMap Menggunakan kubectl create configmap</h3><p>Gunakan perintah <code>kubectl create configmap</code> untuk membuat ConfigMap dari <a href=#membuat-configmap-dari-direktori>direktori</a>, <a href=#membuat-configmap-dari-berkas>berkas</a>, ataupun <a href=#membuat-configmap-dari-nilai-harfiah>nilai-nilai yang harfiah (<em>literal values</em>)</a>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create configmap &lt;map-name&gt; &lt;data-source&gt;
</span></span></code></pre></div><p>di mana &lt;map-name> merupakan nama yang ingin kamu berikan pada ConfigMap tersebut dan &lt;data-source> adalah direktori, berkas, atau nilai harfiah yang digunakan sebagai sumber data.
Nama dari sebuah objek ConfigMap haruslah berupa
<a href=/id/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>nama subdomain DNS</a> yang sah.</p><p>Ketika kamu membuat ConfigMap dari sebuah berkas, secara bawaan, <em>basename</em> dari berkas tersebut akan menjadi kunci pada &lt;data-source>, dan isi dari berkas tersebut akan menjadi nilai dari kunci tersebut.</p><p>Kamu dapat menggunakan <a href=/docs/reference/generated/kubectl/kubectl-commands/#describe><code>kubectl describe</code></a> atau
<a href=/docs/reference/generated/kubectl/kubectl-commands/#get><code>kubectl get</code></a> untuk mengambil informasi
mengenai sebuah ConfigMap.</p><h4 id=membuat-configmap-dari-direktori>Membuat ConfigMap dari direktori</h4><p>Kamu dapat menggunakan <code>kubectl create configmap</code> untuk membuat sebuah ConfigMap dari banyak berkas dalam sebuah direktori yang sama. Ketika kamu membuat sebuah ConfigMap dari sebuah direktori, kubectl akan mengidentifikasi berkas-berkas yang memiliki <em>basename</em> yang merupakan sebuah kunci yang sah pada direktori dan mengemas tiap berkas tersebut ke dalam sebuah ConfigMap baru. Seluruh entri direktori kecuali berkas reguler akan diabaikan (subdirektori, <em>symlink</em>, <em>device</em>, <em>pipe</em>, dsb).</p><p>Sebagai contoh:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Membuat direktori lokal</span>
</span></span><span style=display:flex><span>mkdir -p configure-pod-container/configmap/
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Mengunduh berkas-berkas sampel ke dalam direktori `configure-pod-container/configmap/`</span>
</span></span><span style=display:flex><span>wget https://kubernetes.io/examples/configmap/game.properties -O configure-pod-cont1ainer/configmap/game.properties
</span></span><span style=display:flex><span>wget https://kubernetes.io/examples/configmap/ui.properties -O configure-pod-container/configmap/ui.properties
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Membuat configmap</span>
</span></span><span style=display:flex><span>kubectl create configmap game-config --from-file<span style=color:#666>=</span>configure-pod-container/configmap/
</span></span></code></pre></div><p>Perintah di atas mengemas tiap berkas, dalam kasus ini, <code>game.properties</code> dan <code>ui.properties</code> dalam direktori <code>configure-pod-container/configmap/</code> ke dalam ConfigMap dengan nama game-config. Kamu dapat menampilkan detail dari ConfigMap menggunakan perintah berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe configmaps game-config
</span></span></code></pre></div><p>Keluaran akan tampil seperti berikut:</p><pre tabindex=0><code>Name:         game-config
Namespace:    default
Labels:       &lt;none&gt;
Annotations:  &lt;none&gt;

Data
====
game.properties:
----
enemies=aliens
lives=3
enemies.cheat=true
enemies.cheat.level=noGoodRotten
secret.code.passphrase=UUDDLRLRBABAS
secret.code.allowed=true
secret.code.lives=30
ui.properties:
----
color.good=purple
color.bad=yellow
allow.textmode=true
how.nice.to.look=fairlyNice
</code></pre><p>Berkas-berkas <code>game.properties</code> dan <code>ui.properties</code> pada direktori <code>configure-pod-container/configmap/</code> direpresentasikan oleh bagian <code>data</code> pada ConfigMap.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get configmaps game-config -o yaml
</span></span></code></pre></div><p>Keluaran akan tampil seperti berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2016-02-18T18:52:05Z<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>game-config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;516&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>b4952dc3-d670-11e5-8cd0-68f728db1985<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>game.properties</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    enemies=aliens
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    lives=3
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    enemies.cheat=true
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    enemies.cheat.level=noGoodRotten
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    secret.code.passphrase=UUDDLRLRBABAS
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    secret.code.allowed=true
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    secret.code.lives=30</span><span style=color:#bbb>    
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ui.properties</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    color.good=purple
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    color.bad=yellow
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    allow.textmode=true
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    how.nice.to.look=fairlyNice</span><span style=color:#bbb>    
</span></span></span></code></pre></div><h4 id=membuat-configmap-dari-berkas>Membuat ConfigMap dari berkas</h4><p>Kamu dapat menggunakan <code>kubectl create configmap</code> untuk membuat sebuah ConfigMap dari berkas individual, atau dari banyak berkas.</p><p>Sebagai contoh,</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create configmap game-config-2 --from-file<span style=color:#666>=</span>configure-pod-container/configmap/game.properties
</span></span></code></pre></div><p>akan menghasilkan ConfigMap berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe configmaps game-config-2
</span></span></code></pre></div><p>dengan keluaran seperti berikut:</p><pre tabindex=0><code>Name:         game-config-2
Namespace:    default
Labels:       &lt;none&gt;
Annotations:  &lt;none&gt;

Data
====
game.properties:
----
enemies=aliens
lives=3
enemies.cheat=true
enemies.cheat.level=noGoodRotten
secret.code.passphrase=UUDDLRLRBABAS
secret.code.allowed=true
secret.code.lives=30
</code></pre><p>Kamu dapat memasukkan argumen <code>--from-file</code> beberapa kali untuk membuat sebuah ConfigMap dari banyak sumber data.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create configmap game-config-2 --from-file<span style=color:#666>=</span>configure-pod-container/configmap/game.properties --from-file<span style=color:#666>=</span>configure-pod-container/configmap/ui.properties
</span></span></code></pre></div><p>Kamu dapat menampilkan detail dari ConfigMap <code>game-config-2</code> menggunakan perintah berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe configmaps game-config-2
</span></span></code></pre></div><p>Keluaran akan tampil seperti berikut:</p><pre tabindex=0><code>Name:         game-config-2
Namespace:    default
Labels:       &lt;none&gt;
Annotations:  &lt;none&gt;

Data
====
game.properties:
----
enemies=aliens
lives=3
enemies.cheat=true
enemies.cheat.level=noGoodRotten
secret.code.passphrase=UUDDLRLRBABAS
secret.code.allowed=true
secret.code.lives=30
ui.properties:
----
color.good=purple
color.bad=yellow
allow.textmode=true
how.nice.to.look=fairlyNice
</code></pre><p>Gunakan opsi <code>--from-env-file</code> untuk membuat sebuah ConfigMap dari sebuah <em>env-file</em>, sebagai contoh:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Env-file berisi sebuah daftar variabel _environment_.</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Ada aturan-aturan sintaks yang berlaku:</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic>#   Tiap baris pada sebuah env file harus memiliki format VAR=VAL.</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic>#   Baris yang diawali # (komentar) akan diabaikan.</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic>#   Baris-baris kosong akan diabaikan.</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic>#   Tidak ada penanganan spesial untuk tanda kutip (tanda kutip akan menjadi bagian dari nilai pada ConfigMap).</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Mengunduh berkas-berkas sampel berikut ke dalam direktori `configure-pod-container/configmap/`</span>
</span></span><span style=display:flex><span>wget https://kubernetes.io/examples/configmap/game-env-file.properties -O configure-pod-container/configmap/game-env-file.properties
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Berkas env-file `game-env-file.properties` berisi sebagai berikut:</span>
</span></span><span style=display:flex><span>cat configure-pod-container/configmap/game-env-file.properties
</span></span><span style=display:flex><span><span style=color:#b8860b>enemies</span><span style=color:#666>=</span>aliens
</span></span><span style=display:flex><span><span style=color:#b8860b>lives</span><span style=color:#666>=</span><span style=color:#666>3</span>
</span></span><span style=display:flex><span><span style=color:#b8860b>allowed</span><span style=color:#666>=</span><span style=color:#b44>&#34;true&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Komentar ini dan baris kosong di atasnya akan diabaikan.</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create configmap game-config-env-file <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>       --from-env-file<span style=color:#666>=</span>configure-pod-container/configmap/game-env-file.properties
</span></span></code></pre></div><p>akan menghasilkan ConfigMap sebagai berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get configmap game-config-env-file -o yaml
</span></span></code></pre></div><p>dengan keluaran seperti berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2017-12-27T18:36:28Z<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>game-config-env-file<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;809965&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>d9d1ca5b-eb34-11e7-887b-42010a8002b8<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>allowed</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;&#34;true&#34;&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>enemies</span>:<span style=color:#bbb> </span>aliens<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>lives</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;3&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-warning caution callout" role=alert><strong>Perhatian:</strong> Ketika memasukkan <code>--from-env-file</code> beberapa kali untuk membuat sebuah ConfigMap dari beberapa sumber data, hanya env-file terakhir yang akan digunakan.</div><p>Contoh perilaku memasukkan <code>--from-env-file</code> beberapa kali didemonstrasikan dengan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Mengunduh berkas-berkas sampel berikut ke dalam direktori `configure-pod-container/configmap/` </span>
</span></span><span style=display:flex><span>wget https://kubernetes.io/examples/configmap/ui-env-file.properties -O configure-pod-container/configmap/ui-env-file.properties
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Membuat configmap</span>
</span></span><span style=display:flex><span>kubectl create configmap config-multi-env-files <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>        --from-env-file<span style=color:#666>=</span>configure-pod-container/configmap/game-env-file.properties <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>        --from-env-file<span style=color:#666>=</span>configure-pod-container/configmap/ui-env-file.properties
</span></span></code></pre></div><p>akan menghasilkan ConfigMap sebagai berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get configmap config-multi-env-files -o yaml
</span></span></code></pre></div><p>dengan keluaran seperti berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2017-12-27T18:38:34Z<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config-multi-env-files<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;810136&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>252c4572-eb35-11e7-887b-42010a8002b8<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>color</span>:<span style=color:#bbb> </span>purple<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>how</span>:<span style=color:#bbb> </span>fairlyNice<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>textmode</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><h4 id=menentukan-kunci-yang-akan-digunakan-ketika-membuat-configmap-dari-sebuah-berkas>Menentukan kunci yang akan digunakan ketika membuat ConfigMap dari sebuah berkas</h4><p>Kamu dapat menentukan kunci selain dari nama berkas untuk digunakan pada bagian <code>data</code> pada ConfigMap yang kamu buat menggunakan argumen <code>--from-file</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create configmap game-config-3 --from-file<span style=color:#666>=</span>&lt;my-key-name&gt;<span style=color:#666>=</span>&lt;path-to-file&gt;
</span></span></code></pre></div><p>di mana <code>&lt;my-key-name></code> merupakan kunci yang ingin kamu gunakan pada ConfigMap dan <code>&lt;path-to-file></code> merupakan lokasi dari berkas sumber data yang akan menjadi nilai dari kunci tersebut.</p><p>Sebagai contoh:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create configmap game-config-3 --from-file<span style=color:#666>=</span>game-special-key<span style=color:#666>=</span>configure-pod-container/configmap/game.properties
</span></span></code></pre></div><p>akan menghasilkan ConfigMap sebagai berikut:</p><pre tabindex=0><code>kubectl get configmaps game-config-3 -o yaml
</code></pre><p>dengan keluaran seperti berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2016-02-18T18:54:22Z<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>game-config-3<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;530&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>05f8da22-d671-11e5-8cd0-68f728db1985<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>game-special-key</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    enemies=aliens
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    lives=3
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    enemies.cheat=true
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    enemies.cheat.level=noGoodRotten
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    secret.code.passphrase=UUDDLRLRBABAS
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    secret.code.allowed=true
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    secret.code.lives=30</span><span style=color:#bbb>    
</span></span></span></code></pre></div><h4 id=membuat-configmap-dari-nilai-harfiah>Membuat ConfigMap dari nilai harfiah</h4><p>Kamu dapat menggunakan <code>kubectl create configmap</code> dengan argumen <code>--from-literal</code> untuk menentukan nilai harfiah dari baris perintah:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create configmap special-config --from-literal<span style=color:#666>=</span>special.how<span style=color:#666>=</span>very --from-literal<span style=color:#666>=</span>special.type<span style=color:#666>=</span>charm
</span></span></code></pre></div><p>Kamu dapat memasukkan beberapa pasang kunci-nilai. Tiap pasang yang dimasukkan pada <em>command line</em> direpresentasikan sebagai sebuah entri terpisah pada bagian <code>data</code> dari ConfigMap.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get configmaps special-config -o yaml
</span></span></code></pre></div><p>Keluaran akan tampil seperti berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2016-02-18T19:14:38Z<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>special-config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;651&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>dadce046-d673-11e5-8cd0-68f728db1985<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>special.how</span>:<span style=color:#bbb> </span>very<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>special.type</span>:<span style=color:#bbb> </span>charm<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=membuat-configmap-dari-generator>Membuat ConfigMap dari generator</h3><p><code>kubectl</code> mendukung <code>kustomization.yaml</code> sejak versi 1.14.
Kamu juga dapat membuat ConfigMap dari generator lalu menggunakannya untuk membuat objek tersebut pada
peladen API. Generator
harus dituliskan pada <code>kustomization.yaml</code> dalam sebuah direktori.</p><h4 id=menghasilkan-configmap-dari-berkas>Menghasilkan ConfigMap dari berkas</h4><p>Sebagai contoh, untuk menghasilkan ConfigMap dari berkas <code>configure-pod-container/configmap/game.properties</code></p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Membuat berkas kustomization.yaml dengan ConfigMapGenerator</span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt;./kustomization.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>configMapGenerator:
</span></span></span><span style=display:flex><span><span style=color:#b44>- name: game-config-4
</span></span></span><span style=display:flex><span><span style=color:#b44>  files:
</span></span></span><span style=display:flex><span><span style=color:#b44>  - configure-pod-container/configmap/game.properties
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>Gunakan direktori kustomization untuk membuat objek ConfigMap.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -k .
</span></span><span style=display:flex><span>configmap/game-config-4-m9dm2f92bt created
</span></span></code></pre></div><p>Kamu dapat melihat ConfigMap yang dihasilkan seperti berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get configmap
</span></span><span style=display:flex><span>NAME                       DATA   AGE
</span></span><span style=display:flex><span>game-config-4-m9dm2f92bt   <span style=color:#666>1</span>      37s
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl describe configmaps/game-config-4-m9dm2f92bt
</span></span><span style=display:flex><span>Name:         game-config-4-m9dm2f92bt
</span></span><span style=display:flex><span>Namespace:    default
</span></span><span style=display:flex><span>Labels:       &lt;none&gt;
</span></span><span style=display:flex><span>Annotations:  kubectl.kubernetes.io/last-applied-configuration:
</span></span><span style=display:flex><span>                <span style=color:#666>{</span><span style=color:#b44>&#34;apiVersion&#34;</span>:<span style=color:#b44>&#34;v1&#34;</span>,<span style=color:#b44>&#34;data&#34;</span>:<span style=color:#666>{</span><span style=color:#b44>&#34;game.properties&#34;</span>:<span style=color:#b44>&#34;enemies=aliens\nlives=3\nenemies.cheat=true\nenemies.cheat.level=noGoodRotten\nsecret.code.p...
</span></span></span><span style=display:flex><span><span style=color:#b44>
</span></span></span><span style=display:flex><span><span style=color:#b44>Data
</span></span></span><span style=display:flex><span><span style=color:#b44>====
</span></span></span><span style=display:flex><span><span style=color:#b44>game.properties:
</span></span></span><span style=display:flex><span><span style=color:#b44>----
</span></span></span><span style=display:flex><span><span style=color:#b44>enemies=aliens
</span></span></span><span style=display:flex><span><span style=color:#b44>lives=3
</span></span></span><span style=display:flex><span><span style=color:#b44>enemies.cheat=true
</span></span></span><span style=display:flex><span><span style=color:#b44>enemies.cheat.level=noGoodRotten
</span></span></span><span style=display:flex><span><span style=color:#b44>secret.code.passphrase=UUDDLRLRBABAS
</span></span></span><span style=display:flex><span><span style=color:#b44>secret.code.allowed=true
</span></span></span><span style=display:flex><span><span style=color:#b44>secret.code.lives=30
</span></span></span><span style=display:flex><span><span style=color:#b44>Events:  &lt;none&gt;
</span></span></span></code></pre></div><p>Perlu diingat baha nama dari ConfigMap yang dihasilkan memiliki sufiks yang ditambahkan dengan melakukan <em>hashing</em> terhadap konten dari ConfigMap tersebut. Hal ini memastikan bahwa
sebuah ConfigMap baru akan dihasilkan setiap kali konten dimodifikasi.</p><h4 id=menentukan-kunci-yang-akan-digunakan-ketika-generating-configmap-dari-sebuah-berkas>Menentukan kunci yang akan digunakan ketika generating ConfigMap dari sebuah berkas</h4><p>Kamu dapat menentukan kunci selain nama berkas untuk digunakan pada generator ConfigMap.
Sebagai contoh, untuk menghasilkan sebuah ConfigMap dari berkas <code>configure-pod-container/configmap/game.properties</code>
dengan kunci <code>game-special-key</code></p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Membuat berkas kustomization.yaml dengan ConfigMapGenerator</span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt;./kustomization.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>configMapGenerator:
</span></span></span><span style=display:flex><span><span style=color:#b44>- name: game-config-5
</span></span></span><span style=display:flex><span><span style=color:#b44>  files:
</span></span></span><span style=display:flex><span><span style=color:#b44>  - game-special-key=configure-pod-container/configmap/game.properties
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>Gunakan direktori kustomization untuk membuat objek ConfigMap.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -k .
</span></span><span style=display:flex><span>configmap/game-config-5-m67dt67794 created
</span></span></code></pre></div><h4 id=menghasilkan-configmap-dari-nilai-nilai-harfiah>Menghasilkan ConfigMap dari Nilai-nilai Harfiah</h4><p>Untuk menghasilkan ConfigMap dari nilai-nilai harfiah <code>special.type=charm</code> dan <code>special.how=very</code>,
kamu dapat menentukan generator ConfigMap pada <code>kustomization.yaml</code> sebagai berikut</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Membuat berkas kustomization.yaml dengan ConfigMapGenerator</span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt;./kustomization.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>configMapGenerator:
</span></span></span><span style=display:flex><span><span style=color:#b44>- name: special-config-2
</span></span></span><span style=display:flex><span><span style=color:#b44>  literals:
</span></span></span><span style=display:flex><span><span style=color:#b44>  - special.how=very
</span></span></span><span style=display:flex><span><span style=color:#b44>  - special.type=charm
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>Gunakan direktori kustomization untuk membuat objek ConfigMap.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -k .
</span></span><span style=display:flex><span>configmap/special-config-2-c92b5mmcf2 created
</span></span></code></pre></div><h2 id=menentukan-variabel-environment-kontainer-menggunakan-data-configmap>Menentukan variabel <em>environment</em> kontainer menggunakan data ConfigMap</h2><h3 id=menentukan-variabel-environment-kontainer-dengan-data-dari-sebuah-configmap>Menentukan variabel <em>environment</em> kontainer dengan data dari sebuah ConfigMap</h3><ol><li><p>Menentukan sebuah variabel <em>environment</em> sebagai sepasang kunci-nilai pada ConfigMap:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create configmap special-config --from-literal<span style=color:#666>=</span>special.how<span style=color:#666>=</span>very
</span></span></code></pre></div></li><li><p>Memberikan nilai <code>special.how</code> yang sudah terdapat pada ConfigMap pada variabel <em>environment</em> <code>SPECIAL_LEVEL_KEY</code> di spesifikasi Pod.</p></li></ol><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/pods/pod-single-configmap-env-variable.yaml download=pods/pod-single-configmap-env-variable.yaml><code>pods/pod-single-configmap-env-variable.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-pod-single-configmap-env-variable-yaml")' title="Copy pods/pod-single-configmap-env-variable.yaml to clipboard"></img></div><div class=includecode id=pods-pod-single-configmap-env-variable-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dapi-test-pod<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/busybox<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;/bin/sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;env&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># Tentukan variabel environment</span><span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>SPECIAL_LEVEL_KEY<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>configMapKeyRef</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:#080;font-style:italic># ConfigMap berisi nilai yang ingin kamu berikan pada SPECIAL_LEVEL_KEY</span><span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>special-config<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:#080;font-style:italic># Tentukan kunci yang diasosiasikan dengan nilainya</span><span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>special.how<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
   </span></span></span></code></pre></div></div></div><p>Buat Pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f https://kubernetes.io/id/examples/pods/pod-single-configmap-env-variable.yaml
</span></span></code></pre></div><p>Sekarang, keluaran dari Pod meliputi variabel <em>environment</em> <code>SPECIAL_LEVEL_KEY=very</code>.</p><h3 id=menentukan-variabel-environment-kontainer-dengan-data-dari-beberapa-configmap>Menentukan variabel <em>environment</em> kontainer dengan data dari beberapa ConfigMap</h3><ul><li><p>Seperti pada contoh sebelumnya, buat ConfigMap terlebih dahulu.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/configmap/configmaps.yaml download=configmap/configmaps.yaml><code>configmap/configmaps.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("configmap-configmaps-yaml")' title="Copy configmap/configmaps.yaml to clipboard"></img></div><div class=includecode id=configmap-configmaps-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>special-config<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>special.how</span>:<span style=color:#bbb> </span>very<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>env-config<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>log_level</span>:<span style=color:#bbb> </span>INFO<span style=color:#bbb>
   </span></span></span></code></pre></div></div></div><p>Buat ConfigMap:</p></li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f https://kubernetes.io/examples/configmap/configmaps.yaml
</span></span></code></pre></div><ul><li><p>Tentukan variabel <em>environment</em> pada spesifikasi Pod.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/pods/pod-multiple-configmap-env-variable.yaml download=pods/pod-multiple-configmap-env-variable.yaml><code>pods/pod-multiple-configmap-env-variable.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-pod-multiple-configmap-env-variable-yaml")' title="Copy pods/pod-multiple-configmap-env-variable.yaml to clipboard"></img></div><div class=includecode id=pods-pod-multiple-configmap-env-variable-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dapi-test-pod<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/busybox<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;/bin/sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;env&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>SPECIAL_LEVEL_KEY<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>configMapKeyRef</span>:<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>special-config<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>special.how<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>LOG_LEVEL<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>configMapKeyRef</span>:<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>env-config<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>log_level<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
  </span></span></span></code></pre></div></div></div><p>Buat Pod:</p></li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f https://kubernetes.io/id/examples/pods/pod-multiple-configmap-env-variable.yaml
</span></span></code></pre></div><p>Sekarang, keluaran Pod meliputi variabel <em>environment</em> <code>SPECIAL_LEVEL_KEY=very</code> dan <code>LOG_LEVEL=INFO</code>.</p><h2 id=mengatur-semua-pasangan-kunci-nilai-pada-configmap-sebagai-variabel-environment-kontainer>Mengatur semua pasangan kunci-nilai pada ConfigMap sebagai variabel <em>environment</em> kontainer</h2><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Fungsi ini tersedia pada Kubernetes v1.6 dan selanjutnya.</div><ul><li><p>Buat ConfigMap yang berisi beberapa pasangan kunci-nilai.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/configmap/configmap-multikeys.yaml download=configmap/configmap-multikeys.yaml><code>configmap/configmap-multikeys.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("configmap-configmap-multikeys-yaml")' title="Copy configmap/configmap-multikeys.yaml to clipboard"></img></div><div class=includecode id=configmap-configmap-multikeys-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>special-config<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>SPECIAL_LEVEL</span>:<span style=color:#bbb> </span>very<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>SPECIAL_TYPE</span>:<span style=color:#bbb> </span>charm<span style=color:#bbb>
  </span></span></span></code></pre></div></div></div><p>Buat ConfigMap:</p></li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f https://kubernetes.io/examples/configmap/configmap-multikeys.yaml
</span></span></code></pre></div><ul><li>Gunakan <code>envFrom</code> untuk menentukan seluruh data pada ConfigMap sebagai variabel <em>environment</em> kontainer. Kunci dari ConfigMap akan menjadi nama variabel <em>environment</em> di dalam Pod.</li></ul><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/pods/pod-configmap-envFrom.yaml download=pods/pod-configmap-envFrom.yaml><code>pods/pod-configmap-envFrom.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-pod-configmap-envfrom-yaml")' title="Copy pods/pod-configmap-envFrom.yaml to clipboard"></img></div><div class=includecode id=pods-pod-configmap-envfrom-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
 </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
 </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
 </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dapi-test-pod<span style=color:#bbb>
 </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
 </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
 </span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
 </span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/busybox<span style=color:#bbb>
 </span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;/bin/sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;env&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
 </span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>envFrom</span>:<span style=color:#bbb>
 </span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>configMapRef</span>:<span style=color:#bbb>
 </span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>special-config<span style=color:#bbb>
 </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
 </span></span></span></code></pre></div></div></div><p>Buat Pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f https://kubernetes.io/examples/pods/pod-configmap-envFrom.yaml
</span></span></code></pre></div><p>Sekarang, Pod keluaran pod meliputi variabel <em>environment</em> <code>SPECIAL_LEVEL=very</code> dan <code>SPECIAL_TYPE=charm</code>.</p><h2 id=menggunakan-variabel-environment-yang-ditentukan-configmap-pada-perintah-pod>Menggunakan variabel <em>environment</em> yang ditentukan ConfigMap pada perintah Pod</h2><p>Kamu dapat menggunakan variabel <em>environment</em> yang ditentukan ConfigMap pada bagian <code>command</code> dari spesifikasi Pod menggunakan sintaks substitusi Kubernetes <code>$(VAR_NAME)</code>.</p><p>Sebagai contoh, spesifikasi Pod berikut</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/pods/pod-configmap-env-var-valueFrom.yaml download=pods/pod-configmap-env-var-valueFrom.yaml><code>pods/pod-configmap-env-var-valueFrom.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-pod-configmap-env-var-valuefrom-yaml")' title="Copy pods/pod-configmap-env-var-valueFrom.yaml to clipboard"></img></div><div class=includecode id=pods-pod-configmap-env-var-valuefrom-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dapi-test-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;/bin/sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;echo $(SPECIAL_LEVEL_KEY) $(SPECIAL_TYPE_KEY)&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>SPECIAL_LEVEL_KEY<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>configMapKeyRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>special-config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>SPECIAL_LEVEL<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>SPECIAL_TYPE_KEY<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>configMapKeyRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>special-config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>SPECIAL_TYPE<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>dibuat dengan menjalankan</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f https://kubernetes.io/examples/pods/pod-configmap-env-var-valueFrom.yaml
</span></span></code></pre></div><p>menghasilkan keluaran pada kontainer <code>test-container</code> seperti berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>very charm
</span></span></code></pre></div><h2 id=menambahkan-data-configmap-pada-volume>Menambahkan data ConfigMap pada Volume</h2><p>Seperti yang sudah dijelaskan pada <a href=#membuat-configmap-dari-berkas>Membuat ConfigMap dari berkas</a>, ketika kamu membuat ConfigMap menggunakan <code>--from-file</code>, nama dari berkas tersebut akan menjadi kunci yang disimpan pada bagian <code>data</code> dari ConfigMap. Isi berkas tersebut akan menjadi nilai dari kunci tersebut.</p><p>Contoh pada bagian ini merujuk pada ConfigMap bernama <code>special-config</code>, Seperti berikut.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/configmap/configmap-multikeys.yaml download=configmap/configmap-multikeys.yaml><code>configmap/configmap-multikeys.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("configmap-configmap-multikeys-yaml")' title="Copy configmap/configmap-multikeys.yaml to clipboard"></img></div><div class=includecode id=configmap-configmap-multikeys-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>special-config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>SPECIAL_LEVEL</span>:<span style=color:#bbb> </span>very<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>SPECIAL_TYPE</span>:<span style=color:#bbb> </span>charm<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Buat ConfigMap:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f https://kubernetes.io/examples/configmap/configmap-multikeys.yaml
</span></span></code></pre></div><h3 id=mengisi-volume-dengan-data-yang-disimpan-pada-configmap>Mengisi Volume dengan data yang disimpan Pada ConfigMap</h3><p>Tambahkan nama ConfigMap di bawah bagian <code>volumes</code> pada spesifikasi Pod.
Hal ini akan menambahkan data ConfigMap pada direktori yang ditentukan oleh <code>volumeMounts.mountPath</code> (pada kasus ini, <code>/etc/config</code>).
Bagian <code>command</code> berisi daftar berkas pada direktori dengan nama-nama yang sesuai dengan kunci-kunci pada ConfigMap.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/pods/pod-configmap-volume.yaml download=pods/pod-configmap-volume.yaml><code>pods/pod-configmap-volume.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-pod-configmap-volume-yaml")' title="Copy pods/pod-configmap-volume.yaml to clipboard"></img></div><div class=includecode id=pods-pod-configmap-volume-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dapi-test-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;/bin/sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;ls /etc/config/&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>configMap</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># Berikan nama dari ConfigMap yang berisi berkas-berkas yang ingin kamu</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># tambahkan ke kontainer</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>special-config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Buat Pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f https://kubernetes.io/i/examples/pods/pod-configmap-volume.yaml
</span></span></code></pre></div><p>Ketika Pod berjalan, perintah <code>ls /etc/config/</code> akan menghasilkan keluaran di bawah:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>SPECIAL_LEVEL
</span></span><span style=display:flex><span>SPECIAL_TYPE
</span></span></code></pre></div><div class="alert alert-warning caution callout" role=alert><strong>Perhatian:</strong> Jika ada beberapa berkas pada direktori <code>/etc/config/</code>, berkas-berkas tersebut akan dihapus.</div><h3 id=menambahkan-data-configmap-pada-jalur-tertentu-pada-volume>Menambahkan data ConfigMap pada jalur tertentu pada Volume</h3><p>Gunakan kolom <code>path</code> untuk menentukan jalur berkas yang diinginkan untuk butir tertentu pada ConfigMap (butir ConfigMap tertentu).
Pada kasus ini, butir <code>SPECIAL_LEVEL</code> akan akan dipasangkan sebagai <code>config-volume</code> pada <code>/etc/config/keys</code>.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/pods/pod-configmap-volume-specific-key.yaml download=pods/pod-configmap-volume-specific-key.yaml><code>pods/pod-configmap-volume-specific-key.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-pod-configmap-volume-specific-key-yaml")' title="Copy pods/pod-configmap-volume-specific-key.yaml to clipboard"></img></div><div class=includecode id=pods-pod-configmap-volume-specific-key-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dapi-test-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;/bin/sh&#34;</span>,<span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#b44>&#34;cat /etc/config/keys&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>configMap</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>special-config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>SPECIAL_LEVEL<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>keys<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Buat Pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f https://kubernetes.io/examples/pods/pod-configmap-volume-specific-key.yaml
</span></span></code></pre></div><p>Ketika Pod berjalan, perintah <code>cat /etc/config/keys</code> akan menghasilkan keluaran di bawah:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>very
</span></span></code></pre></div><div class="alert alert-warning caution callout" role=alert><strong>Perhatian:</strong> Seperti sebelumnya, semua berkas yang sebelumnya berada pada direktori <code>/etc/config/</code> akan dihapus.</div><h3 id=memproyeksikan-kunci-ke-jalur-dan-perizinan-berkas-tertentu>Memproyeksikan kunci ke jalur dan perizinan berkas tertentu</h3><p>Kamu dapat memproyeksikan kunci ke jalur dan perizinan tertentu pada setiap
berkas. Panduan pengguna <a href=/id/docs/concepts/configuration/secret/#using-secrets-as-files-from-a-pod>Secret</a> menjelaskan mengenai sintaks-sintaksnya.</p><h3 id=configmap-yang-dipasang-akan-diperbarui-secara-otomatis>ConfigMap yang dipasang akan diperbarui secara otomatis</h3><p>Ketika sebuah ConfigMap yang sudah dipasang pada sebuah volume diperbarui, kunci-kunci yang diproyeksikan akan turut diperbarui. Kubelet akan memeriksa apakah ConfigMap yang dipasang merupakan yang terbaru pada sinkronisasi berkala. Namun, ConfigMap menggunakan <em>cache</em> lokal berbasis ttl (<em>time-to-live</em>) miliknya untuk mendapatkan nilai dari ConfigMap saat ini. Hasilnya, keseluruhan penundaan dari saat ketika ConfigMap diperbarui sampai saat ketika kunci-kunci baru diproyeksikan ke pada Pod bisa selama periode sinkronisasi kubelet (secara bawaan selama 1 menit) + ttl dari <em>cache</em> ConfigMap (secara bawaan selama 1 menit) pada kubelet. Kamu dapat memicu pembaruan langsung dengan memperbarui salah satu dari anotasi Pod.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Kontainer yang menggunakan ConfigMap sebagai volume <a href=/id/docs/concepts/storage/volumes/#using-subpath>subPath</a> tidak akan menerima pembaruan ConfigMap.</div><h2 id=memahami-configmap-dan-pod>Memahami ConfigMap dan Pod</h2><p>Sumber daya API ConfigMap menyimpan data konfigurasi sebagai pasangan kunci-nilai. Data tersebut dapat dikonsumsi oleh Pod atau sebagai penyedia konfigurasi untuk komponen-komponen sistem seperti kontroler. ConfigMap mirip dengan <a href=/id/docs/concepts/configuration/secret/>Secret</a>, tetapi ConfigMap dimaksudkan untuk mengolah tulisan yang tidak memiliki informasi yang sensitif. Baik pengguna maupun komponen sistem dapat menyimpan data konfigurasi pada ConfigMap.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> ConfigMap harus mereferensikan berkas-berkas properti, bukan menggantikannya. Anggaplah ConfigMap sebagai sesuatu yang merepresentasikan direktori <code>/etc</code> beserta isinya pada Linux. Sebagai contoh, jika kamu membuat sebuah <a href=/id/docs/concepts/storage/volumes/>Volume Kubernetes</a> dari ConfigMap, tiap butir data pada ConfigMap direpresentasikan sebagai sebuah berkas pada volume.</div><p>Kolom <code>data</code> pada ConfigMap berisi data konfigurasi. Seperti pada contoh di bawah, hal ini bisa berupa sesuatu yang sederhana -- seperti properti individual yang ditentukan menggunakan <code>--from-literal</code> -- atau sesuatu yang kompleks -- seperti berkas konfigurasi atau <em>blob</em> JSON yang ditentukan dengan <code>--from-file</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2016-02-18T19:14:38Z<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example-config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># contoh properti yang sederhana yang ditentukan menggunakan --from-literal</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>example.property.1</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>example.property.2</span>:<span style=color:#bbb> </span>world<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># contoh properti yang kompleks yang ditentukan menggunakan --from-file</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>example.property.file</span>:<span style=color:#bbb> </span>|-<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    property.1=value-1
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    property.2=value-2
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    property.3=value-3</span><span style=color:#bbb>    
</span></span></span></code></pre></div><h3 id=batasan>Batasan</h3><ul><li><p>Kamu harus membuat ConfigMap sebelum merujuknya pada spesifikasi Pod (kecuali kamu menandai ConfigMap sebagai "<em>optional</em>"). Jika kamu merujuk sebuah ConfigMap yang tidak ada, Pod tersebut tidak akan berjalan. Sama halnya, mereferensikan kunci yang tidak ada pada ConfigMap akan mencegah Pod untuk berjalan.</p></li><li><p>Jika kamu menggunakan <code>envFrom</code> untuk menentukan variabel <em>environment</em> dari ConfigMap, kunci-kunci yang dianggap tidak sah akan dilewat. Pod akan diizinkan untuk berjalan, tetapi nama-nama yang tidak sah akan direkam pada <em>event log</em> (<code>InvalidVariableNames</code>). Pesan <em>log</em> tersebut mencantumkan tiap kunci yang dilewat. Sebagai contoh:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get events
</span></span></code></pre></div><p>Keluaran akan tampil seperti berikut:</p><pre tabindex=0><code>LASTSEEN FIRSTSEEN COUNT NAME          KIND  SUBOBJECT  TYPE      REASON                            SOURCE                MESSAGE
0s       0s        1     dapi-test-pod Pod              Warning   InvalidEnvironmentVariableNames   {kubelet, 127.0.0.1}  Keys [1badkey, 2alsobad] from the EnvFrom configMap default/myconfig were skipped since they are considered invalid environment variable names.
</code></pre></li><li><p>ConfigMap berada pada <a class=glossary-tooltip title='Sebuah abstraksi yang digunakan oleh Kubernetes untuk mendukung multipel klaster virtual pada klaster fisik yang sama.' data-toggle=tooltip data-placement=top href=/id/docs/concepts/overview/working-with-objects/namespaces target=_blank aria-label=Namespace>Namespace</a> tertentu. ConfigMap hanya dapat dirujuk oleh Pod yang berada pada Namespace yang sama.</p></li><li><p>Kamu tidak dapat menggunakan ConfigMap untuk <a class=glossary-tooltip title='A pod managed directly by the kubelet daemon on a specific node.' data-toggle=tooltip data-placement=top href=/docs/tasks/configure-pod-container/static-pod/ target=_blank aria-label='Pod statis'>Pod statis</a>, karena Kubelet tidak mendukung hal ini.</p></li></ul><h2 id=selanjutnya>Selanjutnya</h2><ul><li>Ikuti contoh penerapan pada dunia nyata <a href=/docs/tutorials/configuration/configure-redis-using-configmap/>Mengatur Redis menggunakan ConfigMap</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-3d7b9cb24a647c36ba63f7a02ec49010>4.3.11 - Pembagian Namespace Proses antar Container pada sebuah Pod</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.17 [stable]</code></div><p>Dokumen ini akan menjelaskan menkanisme konfigurasi pembagian namespace
process dalam sebuah Pod. Ketika pembagian <em>namespace</em> proses diaktifkan untuk sebuah Pod,
proses yang ada di dalam Container akan bersifat transparan pada semua Container
yang terdapat di dalam Pod tersebut.</p><p>Kamu dapat mengaktifkan fitur ini untuk melakukan konfigurasi kontainer yang saling terhubung,
misalnya saja kontainer <em>sidecar</em> yang bertugas dalam urusan log, atau untuk melakukan
proses pemecahan masalah (<em>troubleshoot</em>) image kontainer yang tidak memiliki utilitas <em>debugging</em> seperti shell.</p><h2 id=sebelum-kamu-memulai>Sebelum kamu memulai</h2><p><p>Kamu harus memiliki klaster Kubernetes, dan perangkat baris perintah kubectl
juga harus dikonfigurasikan untuk berkomunikasi dengan klastermu. Jika kamu
belum memiliki klaster, kamu dapat membuatnya dengan menggunakan
<a href=/id/docs/tasks/tools/#minikube>minikube</a>,
atau kamu juga dapat menggunakan salah satu dari tempat mencoba Kubernetes berikut ini:</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>Bermain dengan Kubernetes</a></li></ul>Kubernetes servermu harus dalam versi yang sama atau lebih baru dari v1.10.
Untuk melihat versi, tekan <code>kubectl version</code>.</p><h2 id=mengatur-sebuah-pod>Mengatur sebuah Pod</h2><p>Pembagian <em>namespace</em> proses (<em>Process Namespace Sharing</em>) diaktifkan menggunakan <em>field</em> <code>shareProcessNamespace</code>
<code>v1.PodSpec</code>. Sebagai contoh:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/pods/share-process-namespace.yaml download=pods/share-process-namespace.yaml><code>pods/share-process-namespace.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-share-process-namespace-yaml")' title="Copy pods/share-process-namespace.yaml to clipboard"></img></div><div class=includecode id=pods-share-process-namespace-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>shareProcessNamespace</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>shell<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>capabilities</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>add</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- SYS_PTRACE<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>stdin</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>tty</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><ol><li><p>Buatlah sebuah Pod <code>nginx</code> di dalam klaster kamu:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/share-process-namespace.yaml
</span></span></code></pre></div></li><li><p>Tempelkan kontainer <code>shell</code> dan jalankan perintah <code>ps</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl attach -it nginx -c shell
</span></span></code></pre></div><p>Jika kamu tidak melihat <em>prompt</em> perintah, kamu dapat menekan tombol enter:</p><pre tabindex=0><code>/ # ps ax
PID   USER     TIME  COMMAND
    1 root      0:00 /pause
    8 root      0:00 nginx: master process nginx -g daemon off;
   14 101       0:00 nginx: worker process
   15 root      0:00 sh
   21 root      0:00 ps ax
</code></pre></li></ol><p>Kamu dapat memberikan sinyal pada kontainer lain. Misalnya saja, mengirim sinyal <code>SIGHUP</code> pada
nginx untuk menjalankan ulang proses worker. Hal ini membutuhkan kapabilitas <code>SYS_PTRACE</code>.</p><pre tabindex=0><code>/ # kill -HUP 8
/ # ps ax
PID   USER     TIME  COMMAND
    1 root      0:00 /pause
    8 root      0:00 nginx: master process nginx -g daemon off;
   15 root      0:00 sh
   22 101       0:00 nginx: worker process
   23 root      0:00 ps ax
</code></pre><p>Hal ini juga merupakan alasan mengapa kita dapat mengakses kontainer lain menggunakan
tautan (<em>link</em>) <code>/proc/$pid/root</code>.</p><pre tabindex=0><code>/ # head /proc/8/root/etc/nginx/nginx.conf

user  nginx;
worker_processes  1;

error_log  /var/log/nginx/error.log warn;
pid        /var/run/nginx.pid;


events {
    worker_connections  1024;
</code></pre><h2 id=memahami-pembagian-namespace-process>Memahami Pembagian Namespace Process</h2><p>Pod berbagi banyak sumber daya yang ada sehingga memungkinkan adanya pembagian <em>namespace</em>
proses. Beberapa <em>image</em> kontainer bisa jadi terisolasi dari kontainer lainnya,
meskipun begitu, memahami beberapa perbedaan berikut juga merupakan hal yang
penting untuk diketahui:</p><ol><li><p><strong>Proses kontainer tidak lagi memiliki PID 1.</strong> Beberapa image kontainer akan menolak
untuk dijalankan (contohnya, kontainer yang menggunakan <code>systemd</code>) atau menjalankan
perintah seperti <code>kill -HUP 1</code> untuk memberikan sinyal pada proses kontainer. Di dalam Pod dengan
sebuah namespace process terbagi, sinyal <code>kill -HUP 1</code> akan diberikan pada <em>sandbox</em> Pod.
(<code>/pause</code> pada contoh di atas.)</p></li><li><p><strong>Proses-proses yang ada akan transparan pada kontainer lain di dalam Pod.</strong> Hal ini termasuk
informasi pada <code>/proc</code>, seperti kata sandi yang diberikan sebagai argumen atau <em>environment variable</em>.
Hal ini hanya dilindungi oleh perizinan reguler Unix.</p></li><li><p><strong>Berkas sistem (<em>filesystem</em>) kontainer bersifat transparan pada kontainer lain di dalam Pod melalui link
<code>/proc/$pid/root</code>.</strong> Hal ini memungkinkan proses <em>debugging</em> menjadi lebih mudah, meskipun begitu hal ini
juga berarti kata kunci (<em>secret</em>) yang ada di dalam <em>filesystem</em> juga hanya dilindungi oleh perizinan <em>filesystem</em> saja.</p></li></ol></div><div class=td-content style=page-break-before:always><h1 id=pg-42a59b878d4c58e5c6f4bb87483dda93>4.3.12 - Membuat Pod Statis</h1><p>Pod statis dikelola langsung oleh <em>daemon</em> kubelet pada suatu Node spesifik,
tanpa <a class=glossary-tooltip title='Komponen control plane yang mengekspos API Kubernetes. Merupakan front-end dari control plane Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-apiserver/ target=_blank aria-label='API server'>API server</a>
mengobservasi mereka.
Tidak seperti Pod yang dikelola oleh <em>control plane</em> (contohnya,
<a class=glossary-tooltip title='Mengelola aplikasi yang direplikasi di dalam klastermu.' data-toggle=tooltip data-placement=top href=/id/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Deployment>Deployment</a>);
kubelet akan memantau setiap Pod statis (dan menjalankan ulang jika
Pod mengalami kegagalan).</p><p>Pod statis selalu terikat pada satu <a class=glossary-tooltip title='Agen yang dijalankan pada setiap node di klaster yang bertugas untuk memastikan kontainer dijalankan di dalam Pod.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=Kubelet>Kubelet</a>
di dalam Node spesifik.</p><p>Kubelet secara otomatis akan mengulang untuk membuat sebuah
<a class=glossary-tooltip title='An object in the API server that tracks a static pod on a kubelet.' data-toggle=tooltip data-placement=top href='/id/docs/reference/glossary/?all=true#term-mirror-pod' target=_blank aria-label='Pod mirror'>Pod mirror</a>
pada server API Kubernetes untuk setiap Pod statis.
Ini berarti Pod yang berjalan pada Node akan terlihat oleh API server,
namun tidak dapat mengontrol dari sana.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Jika kamu menjalankan klaster Kubernetes dan menggunakan Pod statis
untuk menjalankan Pod pada setiap Node, kamu kemungkinan harus menggunakan
sebuah <a class=glossary-tooltip title='Memastikan salinan Pod dijalankan pada sekumpulan Node dalam satu klaster.' data-toggle=tooltip data-placement=top href=/id/docs/concepts/workloads/controllers/daemonset target=_blank aria-label=DaemonSet>DaemonSet</a>.</div><h2 id=sebelum-kamu-memulai>Sebelum kamu memulai</h2><p><p>Kamu harus memiliki klaster Kubernetes, dan perangkat baris perintah kubectl
juga harus dikonfigurasikan untuk berkomunikasi dengan klastermu. Jika kamu
belum memiliki klaster, kamu dapat membuatnya dengan menggunakan
<a href=/id/docs/tasks/tools/#minikube>minikube</a>,
atau kamu juga dapat menggunakan salah satu dari tempat mencoba Kubernetes berikut ini:</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>Bermain dengan Kubernetes</a></li></ul>Untuk melihat versi, tekan <code>kubectl version</code>.</p><p>Laman ini mengasumsikan kamu menggunakan <a class=glossary-tooltip title='A lightweight container runtime specifically for Kubernetes' data-toggle=tooltip data-placement=top href=https://cri-o.io/#what-is-cri-o target=_blank aria-label=CRI-O>CRI-O</a>
untuk menjalankan Pod, dan Node kamu berjalan menggunakan sistem operasi Fedora.
Instruksi untuk distribusi lain atau instalasi Kubernetes mungkin berbeda.</p><h2 id=membuat-sebuah-pod-statis>Membuat sebuah Pod statis</h2><p>Kamu dapat mengatur Pod statis dengan menggunakan sebuah
<a href=#konfigurasi-melalui-berkas-sistem>berkas konfigurasi pada <em>file system</em></a>
atau sebuah <a href=#konfigurasi-melalui-http>berkas konfigurasi ditempatkan pada web</a>.</p><h3 id=konfigurasi-melalui-berkas-sistem>Manifes Pod statis pada berkas sistem (<em>file system</em>)</h3><p>Manifes adalah standar definisi Pod dalam format JSON atau YAML pada suatu direktori.
Gunakan <em>field</em> <code>staticPodPath: &lt;direktori></code> pada
<a href=/docs/tasks/administer-cluster/kubelet-config-file>berkas konfigurasi kubelet</a>,
yang akan membaca direktori
secara berkala dan membuat atau menghapus Pod statis sesuai dengan berkas YAML/JSON
yang bertambah atau berkurang disana.</p><p>Catatan bahwa kubelet akan mengabaikan berkas yang diawali dengan titik (<em>dot</em>)
ketika memindai suatu direktori.</p><p>Sebagai contoh, ini cara untuk memulai server web sederhana sebagai Pod statis:</p><ol><li><p>Pilih Node yang kamu pilih untuk menjalankan Pod statis. Dalam contoh ini adalah <code>my-node1</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>ssh my-node1
</span></span></code></pre></div></li><li><p>Pilih sebuah direktori, katakan <code>/etc/kubelet.d</code> dan letakkan berkas definisi Pod untuk web server disana, contohnya <code>/etc/kubelet.d/static-web.yaml</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Jalankan perintah ini pada Node tempat kubelet sedang berjalan</span>
</span></span><span style=display:flex><span>mkdir /etc/kubelet.d/
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt;/etc/kubelet.d/static-web.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: Pod
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: static-web
</span></span></span><span style=display:flex><span><span style=color:#b44>  labels:
</span></span></span><span style=display:flex><span><span style=color:#b44>    role: myrole
</span></span></span><span style=display:flex><span><span style=color:#b44>spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>  containers:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - name: web
</span></span></span><span style=display:flex><span><span style=color:#b44>      image: nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>      ports:
</span></span></span><span style=display:flex><span><span style=color:#b44>        - name: web
</span></span></span><span style=display:flex><span><span style=color:#b44>          containerPort: 80
</span></span></span><span style=display:flex><span><span style=color:#b44>          protocol: TCP
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div></li><li><p>Atur kubelet pada Node untuk menggunakan direktori ini dengan menjalankannya menggunakan argumen <code>--pod-manifest-path=/etc/kubelet.d/</code>. Pada Fedora, ubah berkas <code>/etc/kubernetes/kubelet</code> dengan menambahkan baris berikut:</p><pre tabindex=0><code>KUBELET_ARGS=&#34;--cluster-dns=10.254.0.10 --cluster-domain=kube.local --pod-manifest-path=/etc/kubelet.d/&#34;
</code></pre><p>atau tambahkan <em>field</em> <code>staticPodPath: &lt;direktori></code> pada <a href=/docs/tasks/administer-cluster/kubelet-config-file>berkas konfigurasi kubelet</a>.</p></li><li><p>Jalankan ulang kubelet. Pada Fedora, kamu dapat menjalankan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Jalankan perintah berikut pada Node tempat kubelet berjalan</span>
</span></span><span style=display:flex><span>systemctl restart kubelet
</span></span></code></pre></div></li></ol><h3 id=konfigurasi-melalui-http>Manifes Pod statis pada Web</h3><p>Berkas yang ditentukan pada argumen <code>--manifest-url=&lt;URL></code> akan diunduh oleh kubelet secara berkala
dan kubelet akan menginterpretasinya sebagai sebuah berkas JSON/YAML yang berisikan definisi Pod.
Mirip dengan cara kerja <a href=#konfigurasi-melalui-berkas-sistem>manifes pada <em>filesystem</em></a>,
kubelet akan mengambil manifes berdasarkan jadwal. Jika ada perubahan pada daftar
Pod statis, maka kubelet akan menerapkannya.</p><p>Untuk menggunakan cara ini:</p><ol><li><p>Buat sebuah berkas YAML dan simpan pada suatu web server sehingga kamu pada memberikan URL tersebut pada kubelet.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>static-web<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>role</span>:<span style=color:#bbb> </span>myrole<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>web<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>web<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span></code></pre></div></li><li><p>Atur kubelet pada suatu Node untuk menggunakan manifes pada web ini dengan menjalankan menggunakan argumen <code>--manifest-url=&lt;url-manifes></code>. Pada Fedora, ubah pada <code>/etc/kubernetes/kubelet</code> untuk menambahkan baris ini:</p><pre tabindex=0><code>KUBELET_ARGS=&#34;--cluster-dns=10.254.0.10 --cluster-domain=kube.local --manifest-url=&lt;url-manifes&gt;&#34;
</code></pre></li><li><p>Jalankan ulang kubelet. Pada Fedora, kamu dapat menjalankan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Jalankan perintah ini pada Node tempat kubelet berjalan</span>
</span></span><span style=display:flex><span>systemctl restart kubelet
</span></span></code></pre></div></li></ol><h2 id=mengobservasi-perilaku-pod-statis>Mengobservasi perilaku Pod statis</h2><p>Ketika kubelet berjalan, secara otomatis akan menjalankan semua Pod statis yang terdefinisi.
Ketika kamu mendefinisikan Pod statis dan menjalankan ulang kubelet, Pod statis yang baru
akan dijalankan.</p><p>Kamu dapat melihat Container yang berjalan (termasuk Pod statis) dengan menjalankan (pada Node):</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Jalankan perintah ini pada Node tempat kubelet berjalan</span>
</span></span><span style=display:flex><span>crictl ps
</span></span></code></pre></div><p>Keluarannya kira-kira seperti berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#888>CONTAINER ID IMAGE         COMMAND  CREATED        STATUS         PORTS     NAMES
</span></span></span><span style=display:flex><span><span style=color:#888>f6d05272b57e nginx:latest  &#34;nginx&#34;  8 minutes ago  Up 8 minutes             k8s_web.6f802af4_static-web-fk-node1_default_67e24ed9466ba55986d120c867395f3c_378e5f3c
</span></span></span></code></pre></div><p>Kamu dapat melihat Pod <em>mirror</em> tersebut pada API server:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods
</span></span></code></pre></div><pre tabindex=0><code>NAME         READY   STATUS    RESTARTS        AGE
static-web   1/1     Running   0               2m
</code></pre><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Pastikan kubelet memiliki izin untuk membuat Pod <em>mirror</em> pada server API. Jika tidak,
pembuatannya akan ditolak oleh API server. Lihat
<a href=/id/docs/concepts/policy/pod-security-policy/>PodSecurityPolicy</a>.</div><p><a class=glossary-tooltip title='Tags objects with identifying attributes that are meaningful and relevant to users.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/labels target=_blank aria-label=Label>Label</a> dari Pod statis
akan dibuat juga pada Pod <em>mirror</em>. Kamu dapat menggunakan label tersebut
seperti biasa menggunakan <a class=glossary-tooltip title='Allows users to filter a list of resources based on labels.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/labels/ target=_blank aria-label=selector-selector>selector-selector</a>,
atau yang lainnya.</p><p>Kamu dapat mencoba untuk menggunakan kubelet untuk menghapus Pod <em>mirror</em> tersebut pada API server,
namun kubelet tidak akan menghapus Pod statis:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pod static-web
</span></span></code></pre></div><pre tabindex=0><code>pod &#34;static-web&#34; deleted
</code></pre><p>Kamu akan melihat bahwa Pod tersebut tetap berjalan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods
</span></span></code></pre></div><pre tabindex=0><code>NAME         READY   STATUS    RESTARTS   AGE
static-web   1/1     Running   0          4s
</code></pre><p>Kembali ke Node tempat kubelet berjalan, kamu dapat mencoba menghentikan Container
Docker secara manual.
Kamu akan melihat, setelah beberapa saat, kubelet akan mengetahui dan akan menjalankan ulang Pod
secara otomatis:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Jalankan perintah ini pada Node tempat kubelet berjalan</span>
</span></span><span style=display:flex><span>crictl stop 129fd7d382018 <span style=color:#080;font-style:italic># ganti dengan ID pada Container-mu</span>
</span></span><span style=display:flex><span>sleep <span style=color:#666>20</span>
</span></span><span style=display:flex><span>crictl ps
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#888>CONTAINER       IMAGE                                 CREATED           STATE      NAME    ATTEMPT    POD ID
</span></span></span><span style=display:flex><span><span style=color:#888>89db4553e1eeb   docker.io/library/nginx@sha256:...    19 seconds ago    Running    web     1          34533c6729106
</span></span></span></code></pre></div><h2 id=penambahan-dan-pengurangan-secara-dinamis-pada-pod-statis>Penambahan dan pengurangan secara dinamis pada Pod statis</h2><p>Direktori konfigurasi (<code>/etc/kubelet.d</code> pada contoh kita) akan dipindai secara berkala oleh kubelet
untuk melakukan perubahan dan penambahan/pengurangan
Pod sesuai dengan penambahan/pengurangan berkas pada direktori tersebut.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Ini mengasumsikan kamu menggunakan konfigurasi Pod statis pada _filesystem_</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Jalankan perintah ini pada Node tempat kubelet berjalan</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic>#</span>
</span></span><span style=display:flex><span>mv /etc/kubernetes/manifests/static-web.yaml /tmp
</span></span><span style=display:flex><span>sleep <span style=color:#666>20</span>
</span></span><span style=display:flex><span>crictl ps
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Kamu mendapatkan bahwa tidak ada Container nginx yang berjalan</span>
</span></span><span style=display:flex><span>mv /tmp/static-web.yaml  /etc/kubernetes/manifests/
</span></span><span style=display:flex><span>sleep <span style=color:#666>20</span>
</span></span><span style=display:flex><span>crictl ps
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#888>CONTAINER       IMAGE                                 CREATED           STATE      NAME    ATTEMPT    POD ID
</span></span></span><span style=display:flex><span><span style=color:#888>f427638871c35   docker.io/library/nginx@sha256:...    19 seconds ago    Running    web     1          34533c6729106
</span></span></span></code></pre></div></div><div class=td-content style=page-break-before:always><h1 id=pg-34a810f1516ad9d99b2697e36e9b0d0f>4.4 - Mengelola Sebuah Klaster</h1><div class=lead>Pelajari tugas-tugas umum dalam pengelolaan sebuah klaster.</div></div><div class=td-content><h1 id=pg-1239a77618c6278373832a142cd85519>4.4.1 - Menggunakan Calico untuk NetworkPolicy</h1><p>Laman ini menunjukkan beberapa cara cepat untuk membuat klaster Calico pada Kubernetes.</p><h2 id=sebelum-kamu-memulai>Sebelum kamu memulai</h2><p>Putuskan apakah kamu ingin menggelar (<em>deploy</em>) sebuah klaster di <a href=#membuat-klaster-calico-menggunakan-google-kubernetes-engine-gke><em>cloud</em></a> atau di <a href=#membuat-klaster-calico-dengan-kubeadm>lokal</a>.</p><h2 id=membuat-klaster-calico-menggunakan-google-kubernetes-engine-gke>Membuat klaster Calico dengan menggunakan <em>Google Kubernetes Engine</em> (GKE)</h2><p><strong>Prasyarat</strong>: <a href=https://cloud.google.com/sdk/docs/quickstarts>gcloud</a>.</p><ol><li><p>Untuk meluncurkan klaster GKE dengan Calico, cukup sertakan opsi <code>--enable-network-policy</code>.</p><p><strong>Sintaksis</strong></p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>gcloud container clusters create <span style=color:#666>[</span>CLUSTER_NAME<span style=color:#666>]</span> --enable-network-policy
</span></span></code></pre></div><p><strong>Contoh</strong></p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>gcloud container clusters create my-calico-cluster --enable-network-policy
</span></span></code></pre></div></li><li><p>Untuk memverifikasi penggelaran, gunakanlah perintah berikut ini.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods --namespace<span style=color:#666>=</span>kube-system
</span></span></code></pre></div><p>Pod Calico dimulai dengan kata <code>calico</code>. Periksa untuk memastikan bahwa statusnya <code>Running</code>.</p></li></ol><h2 id=membuat-klaster-calico-dengan-kubeadm>Membuat klaster lokal Calico dengan kubeadm</h2><p>Untuk membuat satu klaster Calico dengan hos tunggal dalam waktu lima belas menit dengan menggunakan kubeadm, silakan merujuk pada</p><p><a href=https://docs.projectcalico.org/latest/getting-started/kubernetes/>Memulai cepat Calico</a>.</p><h2 id=selanjutnya>Selanjutnya</h2><p>Setelah klaster kamu berjalan, kamu dapat mengikuti <a href=/id/docs/tasks/administer-cluster/declare-network-policy/>Mendeklarasikan Kebijakan Jaringan</a> untuk mencoba NetworkPolicy Kubernetes.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-47be5dd51f686017f1766e6ec7aa6f41>4.4.2 - Mengelola Memori, CPU, dan Sumber Daya API</h1></div><div class=td-content><h1 id=pg-adb489b1ab985c9215657b0d4c6ae92b>4.4.2.1 - Mengatur Batas Minimum dan Maksimum Memori pada sebuah Namespace</h1><p>Laman ini menunjukkan cara untuk mengatur nilai minimum dan maksimum memori yang digunakan oleh Container
yang berjalan pada sebuah Namespace. Kamu dapat menentukan nilai minimum dan maksimum memori pada objek
<a href=/docs/reference/generated/kubernetes-api/v1.25/#limitrange-v1-core>LimitRange</a>. Jika sebuah Pod tidak memenuhi batasan yang ditentukan oleh LimitRange,
maka Pod tersebut tidak dapat dibuat pada Namespace tersebut.</p><h2 id=sebelum-kamu-memulai>Sebelum kamu memulai</h2><p><p>Kamu harus memiliki klaster Kubernetes, dan perangkat baris perintah kubectl
juga harus dikonfigurasikan untuk berkomunikasi dengan klastermu. Jika kamu
belum memiliki klaster, kamu dapat membuatnya dengan menggunakan
<a href=/id/docs/tasks/tools/#minikube>minikube</a>,
atau kamu juga dapat menggunakan salah satu dari tempat mencoba Kubernetes berikut ini:</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>Bermain dengan Kubernetes</a></li></ul>Untuk melihat versi, tekan <code>kubectl version</code>.</p><p>Tiap Node dalam klastermu harus memiliki setidaknya 1 GiB memori.</p><h2 id=membuat-sebuah-namespace>Membuat sebuah Namespace</h2><p>Buat sebuah Namespace sehingga sumber daya yang kamu buat pada latihan ini
terisolasi dari komponen lain pada klastermu.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create namespace constraints-mem-example
</span></span></code></pre></div><h2 id=membuat-limitrange-dan-pod>Membuat LimitRange dan Pod</h2><p>Berikut berkas konfigurasi untuk sebuah LimitRange:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/admin/resource/memory-constraints.yaml download=admin/resource/memory-constraints.yaml><code>admin/resource/memory-constraints.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-resource-memory-constraints-yaml")' title="Copy admin/resource/memory-constraints.yaml to clipboard"></img></div><div class=includecode id=admin-resource-memory-constraints-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>LimitRange<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mem-min-max-demo-lr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>max</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>1Gi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>min</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>500Mi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Container<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Membuat LimitRange:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/admin/resource/memory-constraints.yaml --namespace<span style=color:#666>=</span>constraints-mem-example
</span></span></code></pre></div><p>Melihat informasi mendetail mengenai LimitRange:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get limitrange mem-min-max-demo-lr --namespace<span style=color:#666>=</span>constraints-mem-example --output<span style=color:#666>=</span>yaml
</span></span></code></pre></div><p>Keluaran yang dihasilkan menunjukkan batasan minimum dan maksimum dari memori seperti yang diharapkan. Tetapi
perhatikan hal berikut, meskipun kamu tidak menentukan nilai bawaan pada berkas konfigurasi untuk
LimitRange, namun nilai tersebut akan dibuat secara otomatis.</p><pre tabindex=0><code>  limits:
  - default:
      memory: 1Gi
    defaultRequest:
      memory: 1Gi
    max:
      memory: 1Gi
    min:
      memory: 500Mi
    type: Container
</code></pre><p>Mulai sekarang setiap Container yang dibuat pada Namespace constraints-mem-example, Kubernetes
akan menjalankan langkah-langkah berikut:</p><ul><li><p>Jika Container tersebut tidak menentukan permintaan dan limit memori, maka diberikan nilai permintaan
dan limit memori bawaan pada Container.</p></li><li><p>Memastikan Container memiliki permintaan memori yang lebih besar atau sama dengan 500 MiB.</p></li><li><p>Memastikan Container memiliki limit memori yang lebih kecil atau kurang dari 1 GiB.</p></li></ul><p>Berikut berkas konfigurasi Pod yang memiliki satu Container. Manifes Container
menentukan permintaan memori 600 MiB dan limit memori 800 MiB. Nilai tersebut memenuhi
batasan minimum dan maksimum memori yang ditentukan oleh LimitRange.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/admin/resource/memory-constraints-pod.yaml download=admin/resource/memory-constraints-pod.yaml><code>admin/resource/memory-constraints-pod.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-resource-memory-constraints-pod-yaml")' title="Copy admin/resource/memory-constraints-pod.yaml to clipboard"></img></div><div class=includecode id=admin-resource-memory-constraints-pod-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>constraints-mem-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>constraints-mem-demo-ctr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;800Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;600Mi&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Membuat Pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/admin/resource/memory-constraints-pod.yaml --namespace<span style=color:#666>=</span>constraints-mem-example
</span></span></code></pre></div><p>Memastikan Container pada Pod sudah berjalan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod constraints-mem-demo --namespace<span style=color:#666>=</span>constraints-mem-example
</span></span></code></pre></div><p>Melihat informasi mendetail tentang Pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod constraints-mem-demo --output<span style=color:#666>=</span>yaml --namespace<span style=color:#666>=</span>constraints-mem-example
</span></span></code></pre></div><p>Keluaran yang dihasilkan menunjukkan Container memiliki permintaan memori 600 MiB dan limit memori
800 MiB. Nilai tersebut memenuhi batasan yang ditentukan oleh LimitRange.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>800Mi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>600Mi<span style=color:#bbb>
</span></span></span></code></pre></div><p>Menghapus Podmu:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pod constraints-mem-demo --namespace<span style=color:#666>=</span>constraints-mem-example
</span></span></code></pre></div><h2 id=mencoba-membuat-pod-yang-melebihi-batasan-maksimum-memori>Mencoba membuat Pod yang melebihi batasan maksimum memori</h2><p>Berikut berkas konfigurasi untuk sebuah Pod yang memiliki satu Container. Container tersebut menentukan
permintaan memori 800 MiB dan batas memori 1.5 GiB.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/admin/resource/memory-constraints-pod-2.yaml download=admin/resource/memory-constraints-pod-2.yaml><code>admin/resource/memory-constraints-pod-2.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-resource-memory-constraints-pod-2-yaml")' title="Copy admin/resource/memory-constraints-pod-2.yaml to clipboard"></img></div><div class=includecode id=admin-resource-memory-constraints-pod-2-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>constraints-mem-demo-2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>constraints-mem-demo-2-ctr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1.5Gi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;800Mi&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Mencoba membuat Pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/admin/resource/memory-constraints-pod-2.yaml --namespace<span style=color:#666>=</span>constraints-mem-example
</span></span></code></pre></div><p>Keluaran yang dihasilkan menunjukkan Pod tidak dibuat, karena Container menentukan limit memori yang
terlalu besar:</p><pre tabindex=0><code>Error from server (Forbidden): error when creating &#34;examples/admin/resource/memory-constraints-pod-2.yaml&#34;:
pods &#34;constraints-mem-demo-2&#34; is forbidden: maximum memory usage per Container is 1Gi, but limit is 1536Mi.
</code></pre><h2 id=mencoba-membuat-pod-yang-tidak-memenuhi-permintaan-memori>Mencoba membuat Pod yang tidak memenuhi permintaan memori</h2><p>Berikut berkas konfigurasi untuk sebuah Pod yang memiliki satu Container. Container tersebut menentukan
permintaan memori 100 MiB dan limit memori 800 MiB.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/admin/resource/memory-constraints-pod-3.yaml download=admin/resource/memory-constraints-pod-3.yaml><code>admin/resource/memory-constraints-pod-3.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-resource-memory-constraints-pod-3-yaml")' title="Copy admin/resource/memory-constraints-pod-3.yaml to clipboard"></img></div><div class=includecode id=admin-resource-memory-constraints-pod-3-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>constraints-mem-demo-3<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>constraints-mem-demo-3-ctr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;800Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;100Mi&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Mencoba membuat Pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/admin/resource/memory-constraints-pod-3.yaml --namespace<span style=color:#666>=</span>constraints-mem-example
</span></span></code></pre></div><p>Keluaran yang dihasilkan menunjukkan Pod tidak dibuat, karena Container menentukan permintaan memori yang
terlalu kecil:</p><pre tabindex=0><code>Error from server (Forbidden): error when creating &#34;examples/admin/resource/memory-constraints-pod-3.yaml&#34;:
pods &#34;constraints-mem-demo-3&#34; is forbidden: minimum memory usage per Container is 500Mi, but request is 100Mi.
</code></pre><h2 id=membuat-pod-yang-tidak-menentukan-permintaan-ataupun-limit-memori>Membuat Pod yang tidak menentukan permintaan ataupun limit memori</h2><p>Berikut berkas konfigurasi untuk sebuah Pod yang memiliki satu Container. Container tersebut tidak menentukan
permintaan memori dan juga limit memori.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/admin/resource/memory-constraints-pod-4.yaml download=admin/resource/memory-constraints-pod-4.yaml><code>admin/resource/memory-constraints-pod-4.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-resource-memory-constraints-pod-4-yaml")' title="Copy admin/resource/memory-constraints-pod-4.yaml to clipboard"></img></div><div class=includecode id=admin-resource-memory-constraints-pod-4-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>constraints-mem-demo-4<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>constraints-mem-demo-4-ctr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Mencoba membuat Pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/admin/resource/memory-constraints-pod-4.yaml --namespace<span style=color:#666>=</span>constraints-mem-example
</span></span></code></pre></div><p>Melihat informasi mendetail tentang Pod:</p><pre tabindex=0><code>kubectl get pod constraints-mem-demo-4 --namespace=constraints-mem-example --output=yaml
</code></pre><p>Keluaran yang dihasilkan menunjukkan Container pada Pod memiliki permintaan memori 1 GiB dan limit memori 1 GiB.
Bagaimana Container mendapatkan nilai tersebut?</p><pre tabindex=0><code>resources:
  limits:
    memory: 1Gi
  requests:
    memory: 1Gi
</code></pre><p>Karena Containermu tidak menentukan permintaan dan limit memori, Container tersebut diberikan
<a href=/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/>permintaan dan limit memori bawaan</a>
dari LimitRange.</p><p>Pada tahap ini, Containermu mungkin saja berjalan ataupun mungkin juga tidak berjalan. Ingat bahwa prasyarat
untuk tugas ini adalah Node harus memiliki setidaknya 1 GiB memori. Jika tiap Node hanya memiliki
1 GiB memori, maka tidak akan ada cukup memori untuk dialokasikan pada setiap Node untuk memenuhi permintaan 1 Gib memori. Jika ternyata kamu menggunakan Node dengan 2 GiB memori, maka kamu mungkin memiliki cukup ruang untuk memenuhi permintaan 1 GiB tersebut.</p><p>Menghapus Pod:</p><pre tabindex=0><code>kubectl delete pod constraints-mem-demo-4 --namespace=constraints-mem-example
</code></pre><h2 id=pelaksanaan-batasan-minimum-dan-maksimum-memori>Pelaksanaan batasan minimum dan maksimum memori</h2><p>Batasan maksimum dan minimum memori yang yang ditetapkan pada sebuah Namespace oleh LimitRange dilaksanakan
hanya ketika Pod dibuat atau diperbarui. Jika kamu mengubah LimitRange, hal tersebut tidak akan memengaruhi
Pods yang telah dibuat sebelumnya.</p><h2 id=motivasi-untuk-batasan-minimum-dan-maksimum-memori>Motivasi untuk batasan minimum dan maksimum memori</h2><p>Sebagai seorang administrator klaster, kamu mungkin ingin menetapkan pembatasan jumlah memori yang dapat digunakan oleh Pod.
Sebagai contoh:</p><ul><li><p>Tiap Node dalam sebuah klaster memiliki 2 GB memori. Kamu tidak ingin menerima Pod yang meminta
lebih dari 2 GB memori, karena tidak ada Node pada klater yang dapat memenuhi permintaan tersebut.</p></li><li><p>Sebuah klaster digunakan bersama pada departemen produksi dan pengembangan.
Kamu ingin mengizinkan beban kerja (<em>workload</em>) pada produksi untuk menggunakan hingga 8 GB memori, tapi
kamu ingin beban kerja pada pengembangan cukup terbatas sampai dengan 512 MB saja. Kamu membuat Namespace terpisah
untuk produksi dan pengembangan, dan kamu menerapkan batasan memori pada tiap Namespace.</p></li></ul><h2 id=bersih-bersih>Bersih-bersih</h2><p>Menghapus Namespace:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete namespace constraints-mem-example
</span></span></code></pre></div><h2 id=selanjutnya>Selanjutnya</h2><h3 id=untuk-administrator-klaster>Untuk administrator klaster</h3><ul><li><p><a href=/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/>Mengatur Permintaan dan Limit Memori Bawaan untuk Sebuah Namespace</a></p></li><li><p><a href=/docs/tasks/administer-cluster/manage-resources/cpu-default-namespace/>Mengatur Permintaan dan Limit CPU Bawaan untuk Sebuah Namespace</a></p></li><li><p><a href=/docs/tasks/administer-cluster/manage-resources/cpu-constraint-namespace/>Mengatur Batas Minimum dan Maksimum CPU untuk Sebuah Namespace</a></p></li><li><p><a href=/docs/tasks/administer-cluster/manage-resources/quota-memory-cpu-namespace/>Mengatur Kuota Memori dan CPU untuk Sebuah Namespace</a></p></li><li><p><a href=/docs/tasks/administer-cluster/manage-resources/quota-pod-namespace/>Mengatur Kuota Pod untuk Sebuah Namespace</a></p></li><li><p><a href=/docs/tasks/administer-cluster/quota-api-object/>Mengatur Kuota untuk Objek API</a></p></li></ul><h3 id=untuk-pengembang-aplikasi>Untuk pengembang aplikasi</h3><ul><li><p><a href=/docs/tasks/configure-pod-container/assign-memory-resource/>Memberikan Sumber Daya Memori pada Container dan Pod</a></p></li><li><p><a href=/docs/tasks/configure-pod-container/assign-cpu-resource/>Memberikan Sumber Daya CPU pada Container dan Pod</a></p></li><li><p><a href=/docs/tasks/configure-pod-container/quality-service-pod/>Mengatur Kualitas Layanan Pod</a></p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-8bcf4aeb5bbb6d6969a146e5ab97557b>4.4.3 - Debugging Resolusi DNS</h1><p>Laman ini menyediakan beberapa petunjuk untuk mendiagnosis masalah DNS.</p><h2 id=sebelum-kamu-memulai>Sebelum kamu memulai</h2><p><p>Kamu harus memiliki klaster Kubernetes, dan perangkat baris perintah kubectl
juga harus dikonfigurasikan untuk berkomunikasi dengan klastermu. Jika kamu
belum memiliki klaster, kamu dapat membuatnya dengan menggunakan
<a href=/id/docs/tasks/tools/#minikube>minikube</a>,
atau kamu juga dapat menggunakan salah satu dari tempat mencoba Kubernetes berikut ini:</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>Bermain dengan Kubernetes</a></li></ul><br>Klaster kamu harus dikonfigurasi untuk menggunakan
<a class=glossary-tooltip title='Resources that extend the functionality of Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/concepts/cluster-administration/addons/ target=_blank aria-label=addon>addon</a> CoreDNS atau pendahulunya,
kube-dns.</p><p>Kubernetes servermu harus dalam versi yang sama atau lebih baru dari v1.6.
Untuk melihat versi, tekan <code>kubectl version</code>.</p><h3 id=membuat-pod-sederhana-yang-digunakan-sebagai-lingkungan-pengujian>Membuat Pod sederhana yang digunakan sebagai lingkungan pengujian</h3><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/admin/dns/dnsutils.yaml download=admin/dns/dnsutils.yaml><code>admin/dns/dnsutils.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-dns-dnsutils-yaml")' title="Copy admin/dns/dnsutils.yaml to clipboard"></img></div><div class=includecode id=admin-dns-dnsutils-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dnsutils<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dnsutils<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/e2e-test-images/jessie-dnsutils:1.3<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- sleep<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;3600&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>IfNotPresent<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Always<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Gunakan manifes berikut untuk membuat sebuah Pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/admin/dns/dnsutils.yaml
</span></span></code></pre></div><pre tabindex=0><code>pod/dnsutils created
</code></pre><p>…dan verifikasi statusnya:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods dnsutils
</span></span></code></pre></div><pre tabindex=0><code>NAME      READY     STATUS    RESTARTS   AGE
dnsutils   1/1       Running   0          &lt;some-time&gt;
</code></pre><p>Setelah Pod tersebut berjalan, kamu dapat menjalankan perintah <code>nslookup</code> di lingkungan tersebut.
Jika kamu melihat hal seperti ini, maka DNS sudah berjalan dengan benar.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> -i -t dnsutils -- nslookup kubernetes.default
</span></span></code></pre></div><pre tabindex=0><code>Server:    10.0.0.10
Address 1: 10.0.0.10

Name:      kubernetes.default
Address 1: 10.0.0.1
</code></pre><p>Jika perintah <code>nslookup</code> gagal, periksa hal berikut:</p><h3 id=periksa-konfigurasi-dns-lokal-terlebih-dahulu>Periksa konfigurasi DNS lokal terlebih dahulu</h3><p>Periksa isi dari berkas resolv.conf.
(Lihat <a href=/docs/tasks/administer-cluster/dns-custom-nameservers/#inheriting-dns-from-the-node><em>Inheriting</em> DNS dari node</a> dan
<a href=#known-issues>Isu-isu yang dikenal</a> di bawah ini untuk informasi lebih lanjut)</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> -ti dnsutils -- cat /etc/resolv.conf
</span></span></code></pre></div><p>Verifikasi <em>path</em> pencarian dan nama server telah dibuat agar tampil seperti di bawah ini (perlu diperhatikan bahwa <em>path</em> pencarian dapat berbeda tergantung dari penyedia layanan cloud):</p><pre tabindex=0><code>search default.svc.cluster.local svc.cluster.local cluster.local google.internal c.gce_project_id.internal
nameserver 10.0.0.10
options ndots:5
</code></pre><p>Kesalahan yang muncul berikut ini mengindikasikan terdapat masalah dengan <em>add-on</em> CoreDNS (atau kube-dns) atau Service terkait:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> -i -t dnsutils -- nslookup kubernetes.default
</span></span></code></pre></div><pre tabindex=0><code>Server:    10.0.0.10
Address 1: 10.0.0.10

nslookup: can&#39;t resolve &#39;kubernetes.default&#39;
</code></pre><p>atau</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> -i -t dnsutils -- nslookup kubernetes.default
</span></span></code></pre></div><pre tabindex=0><code>Server:    10.0.0.10
Address 1: 10.0.0.10 kube-dns.kube-system.svc.cluster.local

nslookup: can&#39;t resolve &#39;kubernetes.default&#39;
</code></pre><h3 id=periksa-apakah-pod-dns-sedang-berjalan>Periksa apakah Pod DNS sedang berjalan</h3><p>Gunakan perintah <code>kubectl get pods</code> untuk memverifikasi apakah Pod DNS sedang berjalan.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods --namespace<span style=color:#666>=</span>kube-system -l k8s-app<span style=color:#666>=</span>kube-dns
</span></span></code></pre></div><pre tabindex=0><code>NAME                       READY     STATUS    RESTARTS   AGE
...
coredns-7b96bf9f76-5hsxb   1/1       Running   0           1h
coredns-7b96bf9f76-mvmmt   1/1       Running   0           1h
...
</code></pre><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Nilai dari label <code>k8s-app</code> adalah <code>kube-dns</code> baik untuk CoreDNS maupun kube-dns.</div><p>Jika kamu melihat tidak ada Pod CoreDNS yang sedang berjalan atau Pod tersebut gagal/telah selesai, <em>add-on</em> DNS mungkin tidak dijalankan (<em>deployed</em>) secara bawaan di lingkunganmu saat ini dan kamu harus menjalankannya secara manual.</p><h3 id=periksa-kesalahan-pada-pod-dns>Periksa kesalahan pada Pod DNS</h3><p>Gunakan perintah <code>kubectl logs</code> untuk melihat log dari Container DNS.</p><p>Untuk CoreDNS:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl logs --namespace<span style=color:#666>=</span>kube-system -l k8s-app<span style=color:#666>=</span>kube-dns
</span></span></code></pre></div><p>Berikut contoh log dari CoreDNS yang sehat (<em>healthy</em>):</p><pre tabindex=0><code>.:53
2018/08/15 14:37:17 [INFO] CoreDNS-1.2.2
2018/08/15 14:37:17 [INFO] linux/amd64, go1.10.3, 2e322f6
CoreDNS-1.2.2
linux/amd64, go1.10.3, 2e322f6
2018/08/15 14:37:17 [INFO] plugin/reload: Running configuration MD5 = 24e6c59e83ce706f07bcc82c31b1ea1c
</code></pre><p>Periksa jika ada pesan mencurigakan atau tidak terduga dalam log.</p><h3 id=apakah-layanan-dns-berjalan>Apakah layanan DNS berjalan?</h3><p>Verifikasi apakah layanan DNS berjalan dengan menggunakan perintah <code>kubectl get service</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get svc --namespace<span style=color:#666>=</span>kube-system
</span></span></code></pre></div><pre tabindex=0><code>NAME         TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)             AGE
...
kube-dns     ClusterIP   10.0.0.10      &lt;none&gt;        53/UDP,53/TCP        1h
...
</code></pre><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Nama layanan adalah <code>kube-dns</code> baik untuk CoreDNS maupun kube-dns.</div><p>Jika kamu telah membuat Service atau seharusnya Service telah dibuat secara bawaan namun ternyata tidak muncul, lihat
<a href=/docs/tasks/debug/debug-application/debug-service/><em>debugging</em> Service</a> untuk informasi lebih lanjut.</p><h3 id=apakah-endpoint-dns-telah-ekspos>Apakah endpoint DNS telah ekspos?</h3><p>Kamu dapat memverifikasikan apakah <em>endpoint</em> DNS telah diekspos dengan menggunakan perintah <code>kubectl get endpoints</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get endpoints kube-dns --namespace<span style=color:#666>=</span>kube-system
</span></span></code></pre></div><pre tabindex=0><code>NAME       ENDPOINTS                       AGE
kube-dns   10.180.3.17:53,10.180.3.17:53    1h
</code></pre><p>Jika kamu tidak melihat <em>endpoint</em>, lihat bagian <em>endpoint</em> pada dokumentasi
<a href=/docs/tasks/debug/debug-application/debug-service/><em>debugging</em> Service</a>.</p><p>Untuk tambahan contoh Kubernetes DNS, lihat
<a href=https://github.com/kubernetes/examples/tree/master/staging/cluster-dns>contoh cluster-dns</a> pada repositori Kubernetes GitHub.</p><h3 id=apakah-kueri-dns-diterima-diproses>Apakah kueri DNS diterima/diproses?</h3><p>Kamu dapat memverifikasi apakah kueri telah diterima oleh CoreDNS dengan menambahkan plugin <code>log</code> pada konfigurasi CoreDNS (alias Corefile).
CoreDNS Corefile disimpan pada <a class=glossary-tooltip title='Sebuah objek API yang digunakan untuk menyimpan data nonkonfidensial sebagai pasangan kunci-nilai (key-value). Pod dapat menggunakan ConfigMap sebagai variabel lingkungan, argumen baris perintah (command-line), atau berkas konfigurasi dalam sebuah volume.' data-toggle=tooltip data-placement=top href=/docs/concepts/configuration/configmap/ target=_blank aria-label=ConfigMap>ConfigMap</a> dengan nama <code>coredns</code>. Untuk mengeditnya, gunakan perintah:</p><pre tabindex=0><code>kubectl -n kube-system edit configmap coredns
</code></pre><p>Lalu tambahkan <code>log</code> pada bagian Corefile seperti contoh berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>coredns<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>Corefile</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    .:53 {
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        log
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        errors
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        health
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        kubernetes cluster.local in-addr.arpa ip6.arpa {
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>          pods insecure
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>          upstream
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>          fallthrough in-addr.arpa ip6.arpa
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        }
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        prometheus :9153
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        proxy . /etc/resolv.conf
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        cache 30
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        loop
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        reload
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        loadbalance
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    }</span><span style=color:#bbb>    
</span></span></span></code></pre></div><p>Setelah perubahan disimpan, perubahan dapat memakan waktu satu hingga dua menit untuk Kubernetes menyebarkan perubahan ini pada Pod CoreDNS.</p><p>Berikutnya, coba buat beberapa kueri dan lihat log pada bagian atas dari dokumen ini. Jika pod CoreDNS menerima kueri, kamu seharusnya akan melihatnya pada log.</p><p>Berikut ini contoh kueri yang terdapat di dalam log:</p><pre tabindex=0><code>.:53
2018/08/15 14:37:15 [INFO] CoreDNS-1.2.0
2018/08/15 14:37:15 [INFO] linux/amd64, go1.10.3, 2e322f6
CoreDNS-1.2.0
linux/amd64, go1.10.3, 2e322f6
2018/09/07 15:29:04 [INFO] plugin/reload: Running configuration MD5 = 162475cdf272d8aa601e6fe67a6ad42f
2018/09/07 15:29:04 [INFO] Reloading complete
172.17.0.18:41675 - [07/Sep/2018:15:29:11 +0000] 59925 &#34;A IN kubernetes.default.svc.cluster.local. udp 54 false 512&#34; NOERROR qr,aa,rd,ra 106 0.000066649s
</code></pre><h2 id=isu-isu-yang-dikenal>Isu-isu yang Dikenal</h2><p>Beberapa distribusi Linux (contoh Ubuntu) menggunakan <em>resolver</em> DNS lokal secara bawaan (systemd-resolved).
Systemd-resolved memindahkan dan mengganti <code>/etc/resolv.conf</code> dengan berkas <em>stub</em> yang dapat menyebabkan <em>forwarding loop</em> yang fatal saat meresolusi nama pada server <em>upstream</em>. Ini dapat diatasi secara manual dengan menggunakan <em>flag</em> kubelet <code>--resolv-conf</code>
untuk mengarahkan ke <code>resolv.conf</code> yang benar (Pada <code>systemd-resolved</code>, ini berada di <code>/run/systemd/resolve/resolv.conf</code>).
kubeadm akan otomatis mendeteksi <code>systemd-resolved</code>, dan menyesuaikan <em>flag</em> kubelet sebagai mana mestinya.</p><p>Pemasangan Kubernetes tidak menggunakan berkas <code>resolv.conf</code> pada <em>node</em> untuk digunakan sebagai klaster DNS secara <em>default</em>, karena proses ini umumnya spesifik pada distribusi tertentu. Hal ini bisa jadi akan diimplementasi nantinya.</p><p>Libc Linux (alias glibc) secara bawaan memiliki batasan <code>nameserver</code> DNS sebanyak 3 rekaman (<em>records</em>). Selain itu, pada glibc versi yang lebih lama dari glibc-2.17-222 (<a href=https://access.redhat.com/solutions/58028>versi terbaru lihat isu ini</a>), jumlah rekaman DNS <code>search</code> dibatasi sejumlah 6 (<a href="https://bugzilla.redhat.com/show_bug.cgi?id=168253">lihat masalah sejak 2005 ini</a>). Kubernetes membutuhkan 1 rekaman <code>nameserver</code> dan 3 rekaman <code>search</code>. Ini berarti jika instalasi lokal telah menggunakan 3 <code>nameserver</code> atau menggunakan lebih dari 3 <code>search</code>,sementara versi glibc kamu termasuk yang terkena dampak, beberapa dari pengaturan tersebut akan hilang. Untuk menyiasati batasan rekaman DNS <code>nameserver</code>, <em>node</em> dapat menjalankan <code>dnsmasq</code>,yang akan menyediakan <code>nameserver</code> lebih banyak. Kamu juga dapat menggunakan kubelet <code>--resolv-conf</code> <em>flag</em>. Untuk menyiasati batasan rekaman <code>search</code>, pertimbangkan untuk memperbarui distribusi linux kamu atau memperbarui glibc ke versi yang tidak terdampak.</p><p>Jika kamu menggunakan Alpine versi 3.3 atau lebih lama sebagai dasar <em>image</em> kamu, DNS mungkin tidak dapat bekerja dengan benar disebabkan masalah dengan Alpine.
<a href=https://github.com/kubernetes/kubernetes/issues/30215>Masalah 30215</a> Kubernetes menyediakan informasi lebih detil tentang ini.</p><h2 id=selanjutnya>Selanjutnya</h2><ul><li>Lihat <a href=/docs/tasks/administer-cluster/dns-horizontal-autoscaling/>Penyekalaan otomatis Service DNS dalam klaster</a>.</li><li>Baca <a href=/docs/concepts/services-networking/dns-pod-service/>DNS untuk Service dan Pod</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-3d0cd7d2f13d4759094f281504cf57b8>4.4.4 - Kustomisasi Service DNS</h1><p>Laman ini menjelaskan cara mengonfigurasi DNS
<a class=glossary-tooltip title='Unit Kubernetes yang paling sederhana dan kecil. Sebuah Pod merepresentasikan sebuah set kontainer yang dijalankan pada kluster kamu.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a> kamu dan menyesuaikan
proses resolusi DNS pada klaster kamu.</p><h2 id=sebelum-kamu-memulai>Sebelum kamu memulai</h2><p>Kamu harus memiliki klaster Kubernetes, dan perangkat baris perintah kubectl
juga harus dikonfigurasikan untuk berkomunikasi dengan klastermu. Jika kamu
belum memiliki klaster, kamu dapat membuatnya dengan menggunakan
<a href=/id/docs/tasks/tools/#minikube>minikube</a>,
atau kamu juga dapat menggunakan salah satu dari tempat mencoba Kubernetes berikut ini:</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>Bermain dengan Kubernetes</a></li></ul><p>Klaster kamu harus menjalankan tambahan (<em>add-on</em>) CoreDNS terlebih dahulu.
<a href=/docs/tasks/administer-cluster/coredns/#migrasi-ke-coredns>Migrasi ke CoreDNS</a>
menjelaskan tentang bagaimana menggunakan <code>kubeadm</code> untuk melakukan migrasi dari <code>kube-dns</code>.</p><p>Kubernetes servermu harus dalam versi yang sama atau lebih baru dari v1.12.
Untuk melihat versi, tekan <code>kubectl version</code>.</p><h2 id=pengenalan>Pengenalan</h2><p>DNS adalah Service bawaan dalam Kubernetes yang diluncurkan secara otomatis
melalui <em>addon manager</em>
<a href=http://releases.k8s.io/main/cluster/addons/README.md>add-on klaster</a>.</p><p>Sejak Kubernetes v1.12, CoreDNS adalah server DNS yang direkomendasikan untuk menggantikan kube-dns. Jika klaster kamu
sebelumnya menggunakan kube-dns, maka kamu mungkin masih menggunakan <code>kube-dns</code> daripada CoreDNS.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Baik Service CoreDNS dan kube-dns diberi nama <code>kube-dns</code> pada <em>field</em> <code>metadata.name</code>.
Hal ini agar ada interoperabilitas yang lebih besar dengan beban kerja yang bergantung pada nama Service <code>kube-dns</code> lama untuk me-<em>resolve</em> alamat internal ke dalam klaster. Dengan menggunakan sebuah Service yang bernama <code>kube-dns</code> mengabstraksi detail implementasi yang dijalankan oleh penyedia DNS di belakang nama umum tersebut.</div><p>Jika kamu menjalankan CoreDNS sebagai sebuah Deployment, maka biasanya akan ditampilkan sebagai sebuah Service Kubernetes dengan alamat IP yang statis.
Kubelet meneruskan informasi DNS <em>resolver</em> ke setiap Container dengan argumen <code>--cluster-dns=&lt;dns-service-ip></code>.</p><p>Nama DNS juga membutuhkan domain. Kamu dapat mengonfigurasi domain lokal di kubelet
dengan argumen <code>--cluster-domain=&lt;default-local-domain></code>.</p><p>Server DNS mendukung <em>forward lookup</em> (<em>record</em> A dan AAAA), <em>port lookup</em> (<em>record</em> SRV), <em>reverse lookup</em> alamat IP (<em>record</em> PTR),
dan lain sebagainya. Untuk informasi lebih lanjut, lihatlah <a href=/id/docs/concepts/services-networking/dns-pod-service/>DNS untuk Service dan Pod</a>.</p><p>Jika <code>dnsPolicy</code> dari Pod diatur menjadi <code>default</code>, itu berarti mewarisi konfigurasi resolusi nama
dari Node yang dijalankan Pod. Resolusi DNS pada Pod
harus berperilaku sama dengan Node tersebut.
Tapi lihat <a href=/docs/tasks/debug-application-cluster/dns-debugging-resolution/#known-issues>Isu-isu yang telah diketahui</a>.</p><p>Jika kamu tidak menginginkan hal ini, atau jika kamu menginginkan konfigurasi DNS untuk Pod berbeda, kamu bisa
menggunakan argumen <code>--resolv-conf</code> pada kubelet. Atur argumen ini menjadi "" untuk mencegah Pod tidak
mewarisi konfigurasi DNS. Atur ke jalur (<em>path</em>) berkas yang tepat untuk berkas yang berbeda dengan
<code>/etc/resolv.conf</code> untuk menghindari mewarisi konfigurasi DNS.</p><h2 id=coredns>CoreDNS</h2><p>CoreDNS adalah server DNS otoritatif untuk kegunaan secara umum yang dapat berfungsi sebagai Service DNS untuk klaster, yang sesuai dengan <a href=https://github.com/kubernetes/dns/blob/master/docs/specification.md>spesifikasi dns</a>.</p><h3 id=opsi-configmap-pada-coredns>Opsi ConfigMap pada CoreDNS</h3><p>CoreDNS adalah server DNS yang modular dan mudah dipasang, dan setiap <em>plugin</em> dapat menambahkan fungsionalitas baru ke CoreDNS.
Fitur ini dapat dikonfigurasikan dengan menjaga berkas <a href=https://coredns.io/2017/07/23/corefile-explained/>Corefile</a>, yang merupakan
berkas konfigurasi dari CoreDNS. Sebagai administrator klaster, kamu dapat memodifikasi
<a class=glossary-tooltip title='Sebuah objek API yang digunakan untuk menyimpan data nonkonfidensial sebagai pasangan kunci-nilai (key-value). Pod dapat menggunakan ConfigMap sebagai variabel lingkungan, argumen baris perintah (command-line), atau berkas konfigurasi dalam sebuah volume.' data-toggle=tooltip data-placement=top href=/docs/concepts/configuration/configmap/ target=_blank aria-label=ConfigMap>ConfigMap</a> untuk Corefile dari CoreDNS dengan mengubah cara perilaku pencarian Service DNS
pada klaster tersebut.</p><p>Di Kubernetes, CoreDNS diinstal dengan menggunakan konfigurasi Corefile bawaan sebagai berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>coredns<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>Corefile</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    .:53 {
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        errors
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        health {
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>            lameduck 5s
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        }
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        ready
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        kubernetes cluster.local in-addr.arpa ip6.arpa {
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>            pods insecure
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>            fallthrough in-addr.arpa ip6.arpa
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>            ttl 30
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        }
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        prometheus :9153
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        forward . /etc/resolv.conf
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        cache 30
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        loop
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        reload
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        loadbalance
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    }</span><span style=color:#bbb>    
</span></span></span></code></pre></div><p>Konfigurasi Corefile meliputi <a href=https://coredns.io/plugins/><em>plugin</em></a> berikut ini dari CoreDNS:</p><ul><li><a href=https://coredns.io/plugins/errors/>errors</a>: Kesalahan yang ditampilkan ke output standar (<em>stdout</em>)</li><li><a href=https://coredns.io/plugins/health/>health</a>: Kesehatan dari CoreDNS dilaporkan pada <code>http://localhost:8080/health</code>. Dalam sintaks yang diperluas <code>lameduck</code> akan menangani proses tidak sehat agar menunggu selama 5 detik sebelum proses tersebut dimatikan.</li><li><a href=https://coredns.io/plugins/ready/>ready</a>: <em>Endpoint</em> HTTP pada port 8181 akan mengembalikan OK 200, ketika semua <em>plugin</em> yang dapat memberi sinyal kesiapan, telah memberikan sinyalnya.</li><li><a href=https://coredns.io/plugins/kubernetes/>kubernetes</a>: CoreDNS akan menjawab pertanyaan (<em>query</em>) DNS berdasarkan IP Service dan Pod pada Kubernetes. Kamu dapat menemukan <a href=https://coredns.io/plugins/kubernetes/>lebih detail</a> tentang <em>plugin</em> itu dalam situs web CoreDNS. <code>ttl</code> memungkinkan kamu untuk mengatur TTL khusus untuk respon dari pertanyaan DNS. Standarnya adalah 5 detik. TTL minimum yang diizinkan adalah 0 detik, dan maksimum hanya dibatasi sampai 3600 detik. Mengatur TTL ke 0 akan mencegah <em>record</em> untuk di simpan sementara dalam <em>cache</em>.<br>Opsi <code>pods insecure</code> disediakan untuk kompatibilitas dengan Service <em>kube-dns</em> sebelumnya. Kamu dapat menggunakan opsi <code>pods verified</code>, yang mengembalikan <em>record</em> A hanya jika ada Pod pada Namespace yang sama untuk alamat IP yang sesuai. Opsi <code>pods disabled</code> dapat digunakan jika kamu tidak menggunakan <em>record</em> Pod.</li><li><a href=https://coredns.io/plugins/metrics/>prometheus</a>: Metrik dari CoreDNS tersedia pada <code>http://localhost:9153/metrics</code> dalam format yang sesuai dengan <a href=https://prometheus.io/>Prometheus</a> (dikenal juga sebagai OpenMetrics).</li><li><a href=https://coredns.io/plugins/forward/>forward</a>: Setiap pertanyaan yang tidak berada dalam domain klaster Kubernetes akan diteruskan ke <em>resolver</em> yang telah ditentukan dalam berkas (/etc/resolv.conf).</li><li><a href=https://coredns.io/plugins/cache/>cache</a>: Ini untuk mengaktifkan <em>frontend cache</em>.</li><li><a href=https://coredns.io/plugins/loop/>loop</a>: Mendeteksi <em>forwarding loop</em> sederhana dan menghentikan proses CoreDNS jika <em>loop</em> ditemukan.</li><li><a href=https://coredns.io/plugins/reload>reload</a>: Mengizinkan <em>reload</em> otomatis Corefile yang telah diubah. Setelah kamu mengubah konfigurasi ConfigMap, beri waktu sekitar dua menit agar perubahan yang kamu lakukan berlaku.</li><li><a href=https://coredns.io/plugins/loadbalance>loadbalance</a>: Ini adalah <em>load balancer</em> DNS secara <em>round-robin</em> yang mengacak urutan <em>record</em> A, AAAA, dan MX dalam setiap responnya.</li></ul><p>Kamu dapat memodifikasi perilaku CoreDNS bawaan dengan memodifikasi ConfigMap.</p><h3 id=konfigurasi-stub-domain-dan-nameserver-upstream-dengan-menggunakan-coredns>Konfigurasi <em>Stub-domain</em> dan <em>Nameserver Upstream</em> dengan menggunakan CoreDNS</h3><p>CoreDNS memiliki kemampuan untuk mengonfigurasi <em>stubdomain</em> dan <em>nameserver upstream</em> dengan menggunakan <a href=https://coredns.io/plugins/forward/><em>plugin</em> forward</a>.</p><h4 id=contoh>Contoh</h4><p>Jika operator klaster memiliki sebuah server domain <a href=https://www.consul.io/>Consul</a> yang terletak di 10.150.0.1, dan semua nama Consul memiliki akhiran .consul.local. Untuk mengonfigurasinya di CoreDNS, administrator klaster membuat bait (<em>stanza</em>) berikut dalam ConfigMap CoreDNS.</p><pre tabindex=0><code>consul.local:53 {
        errors
        cache 30
        forward . 10.150.0.1
    }
</code></pre><p>Untuk memaksa secara eksplisit semua pencarian DNS <em>non-cluster</em> melalui <em>nameserver</em> khusus pada 172.16.0.1, arahkan <code>forward</code> ke <em>nameserver</em> bukan ke <code>/etc/resolv.conf</code></p><pre tabindex=0><code>forward .  172.16.0.1
</code></pre><p>ConfigMap terakhir bersama dengan konfigurasi <code>Corefile</code> bawaan terlihat seperti berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>coredns<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>Corefile</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    .:53 {
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        errors
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        health
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        kubernetes cluster.local in-addr.arpa ip6.arpa {
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>           pods insecure
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>           fallthrough in-addr.arpa ip6.arpa
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        }
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        prometheus :9153
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        forward . 172.16.0.1
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        cache 30
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        loop
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        reload
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        loadbalance
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    }
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    consul.local:53 {
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        errors
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        cache 30
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        forward . 10.150.0.1
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    }</span><span style=color:#bbb>    
</span></span></span></code></pre></div><p>Perangkat <code>kubeadm</code> mendukung terjemahan otomatis dari ConfigMap kube-dns
ke ConfigMap CoreDNS yang setara.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Sementara ini kube-dns dapat menerima FQDN untuk <em>stubdomain</em> dan <em>nameserver</em> (mis: ns.foo.com), namun CoreDNS belum mendukung fitur ini.
Selama penerjemahan, semua <em>nameserver</em> FQDN akan dihilangkan dari konfigurasi CoreDNS.</div><h2 id=konfigurasi-coredns-yang-setara-dengan-kube-dns>Konfigurasi CoreDNS yang setara dengan kube-dns</h2><p>CoreDNS mendukung fitur kube-dns dan banyak lagi lainnya.
ConfigMap dibuat agar kube-dns mendukung <code>StubDomains</code> dan <code>upstreamNameservers</code> untuk diterjemahkan ke <em>plugin</em> <code>forward</code> dalam CoreDNS.
Begitu pula dengan <em>plugin</em> <code>Federations</code> dalam kube-dns melakukan translasi untuk <em>plugin</em> <code>federation</code> dalam CoreDNS.</p><h3 id=contoh-1>Contoh</h3><p>Contoh ConfigMap ini untuk kube-dns menentukan federasi, <em>stub domain</em> dan server <em>upstream nameserver</em>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>federations</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    </span><span style=color:#bbb>    </span>{<span style=color:#b44>&#34;foo&#34;</span><span style=color:#bbb> </span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;foo.feddomain.com&#34;</span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>stubDomains</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    </span><span style=color:#bbb>    </span>{<span style=color:#b44>&#34;abc.com&#34;</span><span style=color:#bbb> </span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;1.2.3.4&#34;</span>],<span style=color:#bbb> </span><span style=color:#b44>&#34;my.cluster.local&#34;</span><span style=color:#bbb> </span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;2.3.4.5&#34;</span>]}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>upstreamNameservers</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    </span><span style=color:#bbb>    </span>[<span style=color:#b44>&#34;8.8.8.8&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;8.8.4.4&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span></span></span></code></pre></div><p>Untuk konfigurasi yang setara dengan CoreDNS buat Corefile berikut:</p><ul><li>Untuk federasi:</li></ul><pre tabindex=0><code>federation cluster.local {
    foo foo.feddomain.com
}
</code></pre><ul><li>Untuk stubDomain:</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>abc.com:53 {<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>errors<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>cache 30<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>forward . 1.2.3.4<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>my.cluster.local:53 {<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>errors<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>cache 30<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>forward . 2.3.4.5<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></span></span></code></pre></div><p>Corefile lengkap dengan <em>plugin</em> bawaan:</p><pre tabindex=0><code>.:53 {
    errors
    health
    kubernetes cluster.local in-addr.arpa ip6.arpa {
        pods insecure
        fallthrough in-addr.arpa ip6.arpa
    }
    federation cluster.local {
        foo foo.feddomain.com
    }
    prometheus :9153
    forward . 8.8.8.8 8.8.4.4
    cache 30
}
abc.com:53 {
    errors
    cache 30
    forward . 1.2.3.4
}
my.cluster.local:53 {
    errors
    cache 30
    forward . 2.3.4.5
}
</code></pre><h2 id=migrasi-ke-coredns>Migrasi ke CoreDNS</h2><p>Untuk bermigrasi dari kube-dns ke CoreDNS,
<a href=https://coredns.io/2018/05/21/migration-from-kube-dns-to-coredns/>artikel blog</a> yang detail
tersedia untuk membantu pengguna mengadaptasi CoreDNS sebagai pengganti dari kube-dns.</p><p>Kamu juga dapat bermigrasi dengan menggunakan
<a href=https://github.com/coredns/deployment/blob/master/kubernetes/deploy.sh>skrip <em>deploy</em></a> CoreDNS yang resmi.</p><h2 id=selanjutnya>Selanjutnya</h2><ul><li>Baca <a href=/docs/tasks/administer-cluster/dns-debugging-resolution/><em>Debugging</em> Resolusi DNS</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-b64a1d2bb3f4ed9f7021134e09a75c36>4.4.5 - Melakukan Reservasi Sumber Daya Komputasi untuk Daemon Sistem</h1><p>Node Kubernetes dapat dijadwalkan sesuai dengan kapasitas. Secara bawaan, Pod dapat menggunakan
semua kapasitas yang tersedia pada sebuah Node. Ini merupakan masalah karena Node
sebenarnya menjalankan beberapa <em>daemon</em> sistem yang diperlukan oleh OS dan Kubernetes itu sendiri.
Jika sumber daya pada Node tidak direservasi untuk <em>daemon-daemon</em> tersebut, maka
Pod dan <em>daemon</em> akan berlomba-lomba menggunakan sumber daya yang tersedia, sehingga
menyebabkan <em>starvation</em> sumber daya pada Node.</p><p>Fitur bernama <code>Allocatable</code> pada Node diekspos oleh kubelet yang berfungsi untuk melakukan
reservasi sumber daya komputasi untuk <em>daemon</em> sistem. Kubernetes merekomendasikan admin
klaster untuk mengatur <code>Allocatable</code> pada Node berdasarkan tingkat kepadatan (<em>density</em>) beban kerja setiap Node.</p><h2 id=sebelum-kamu-memulai>Sebelum kamu memulai</h2><p><p>Kamu harus memiliki klaster Kubernetes, dan perangkat baris perintah kubectl
juga harus dikonfigurasikan untuk berkomunikasi dengan klastermu. Jika kamu
belum memiliki klaster, kamu dapat membuatnya dengan menggunakan
<a href=/id/docs/tasks/tools/#minikube>minikube</a>,
atau kamu juga dapat menggunakan salah satu dari tempat mencoba Kubernetes berikut ini:</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>Bermain dengan Kubernetes</a></li></ul>Kubernetes servermu harus dalam versi yang sama atau lebih baru dari 1.8.
Untuk melihat versi, tekan <code>kubectl version</code>.
Kamu harus menjalankan Kubernetes server dengan versi 1.17 atau yang lebih baru
untuk menggunakan perintah baris kubelet dengan opsi <code>--reserved-cpus</code> untuk
menyetel <a href=#melakukan-reservasi-daftar-cpu-secara-eksplisit>daftar reservasi CPU secara eksplisit</a>.</p><h2 id=allocatable-pada-node><em>Allocatable</em> pada Node</h2><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>       Kapasitas Node
</span></span><span style=display:flex><span>------------------------------
</span></span><span style=display:flex><span>|       kube-reserved        |
</span></span><span style=display:flex><span>|----------------------------|
</span></span><span style=display:flex><span>|      system-reserved       |
</span></span><span style=display:flex><span>|----------------------------|
</span></span><span style=display:flex><span>|     eviction-threshold     |
</span></span><span style=display:flex><span>|     (batas pengusiran)     |
</span></span><span style=display:flex><span>|----------------------------|
</span></span><span style=display:flex><span>|                            |
</span></span><span style=display:flex><span>|        allocatable         |
</span></span><span style=display:flex><span>| (dapat digunakan oleh Pod) |
</span></span><span style=display:flex><span>|                            |
</span></span><span style=display:flex><span>|                            |
</span></span><span style=display:flex><span>------------------------------
</span></span></code></pre></div><p><code>Allocatable</code> atau sumber daya yang dialokasikan pada sebuah Node Kubernetes merupakan
jumlah sumber daya komputasi yang dapat digunakan oleh Pod. Penjadwal tidak
dapat melakukan penjadwalan melebihi <code>Allocatable</code>. Saat ini dukungan terhadap
<code>CPU</code>, <code>memory</code> dan <code>ephemeral-storage</code> tersedia.</p><p><code>Allocatable</code> pada Node diekspos oleh objek API <code>v1.Node</code> dan merupakan
bagian dari baris perintah <code>kubectl describe node</code>.</p><p>Sumber daya dapat direservasi untuk dua kategori <em>daemon</em> sistem melalui kubelet.</p><h3 id=mengaktifkan-qos-dan-tingkatan-cgroup-dari-pod>Mengaktifkan QoS dan tingkatan cgroup dari Pod</h3><p>Untuk menerapkan batasan <code>Allocatable</code> pada Node, kamu harus mengaktifkan
hierarki cgroup yang baru melalui <em>flag</em> <code>--cgroups-per-qos</code>. Secara bawaan, <em>flag</em> ini
telah aktif. Saat aktif, kubelet akan memasukkan semua Pod pengguna di bawah
sebuah hierarki cgroup yang dikelola oleh kubelet.</p><h3 id=mengonfigurasi-driver-cgroup>Mengonfigurasi <em>driver</em> cgroup</h3><p>Manipulasi terhadap hierarki cgroup pada hos melalui <em>driver</em> cgroup didukung oleh kubelet.
<em>Driver</em> dikonfigurasi melalui <em>flag</em> <code>--cgroup-driver</code>.</p><p>Nilai yang didukung adalah sebagai berikut:</p><ul><li><code>cgroupfs</code> merupakan <em>driver</em> bawaan yang melakukan manipulasi secara langsung
terhadap <em>filesystem</em> cgroup pada hos untuk mengelola <em>sandbox</em> cgroup.</li><li><code>systemd</code> merupakan <em>driver</em> alternatif yang mengelola <em>sandbox</em> cgroup menggunakan
bagian dari sumber daya yang didukung oleh sistem <em>init</em> yang digunakan.</li></ul><p>Tergantung dari konfigurasi <em>runtime</em> Container yang digunakan,
operator dapat memilih <em>driver</em> cgroup tertentu untuk memastikan perilaku sistem yang tepat.
Misalnya, jika operator menggunakan <em>driver</em> cgroup <code>systemd</code> yang disediakan oleh
<em>runtime</em> docker, maka kubelet harus diatur untuk menggunakan <em>driver</em> cgroup <code>systemd</code>.</p><h3 id=kube-reserved>Kube Reserved</h3><ul><li><strong><em>Flag</em> Kubelet</strong>: <code>--kube-reserved=[cpu=100m][,][memory=100Mi][,][ephemeral-storage=1Gi][,][pid=1000]</code></li><li><strong><em>Flag</em> Kubelet</strong>: <code>--kube-reserved-cgroup=</code></li></ul><p><code>kube-reserved</code> berfungsi untuk mengambil informasi sumber daya reservasi
untuk <em>daemon</em> sistem Kubernetes, seperti kubelet, <em>runtime</em> Container, detektor masalah pada Node, dsb.
<code>kube-reserved</code> tidak berfungsi untuk mereservasi sumber daya untuk <em>daemon</em> sistem yang berjalan
sebagai Pod. <code>kube-reserved</code> merupakan fungsi dari kepadatan Pod pada Node.</p><p>Selain dari <code>cpu</code>, <code>memory</code>, dan <code>ephemeral-storage</code>,<code>pid</code> juga dapat
diatur untuk mereservasi jumlah ID proses untuk <em>daemon</em> sistem Kubernetes.</p><p>Secara opsional, kamu dapat memaksa <em>daemon</em> sistem melalui setelan <code>kube-reserved</code>.
Ini dilakukan dengan menspesifikasikan <em>parent</em> cgroup sebagai nilai dari <em>flag</em> <code>--kube-reserved-cgroup</code> pada kubelet.</p><p>Kami merekomendasikan <em>daemon</em> sistem Kubernetes untuk ditempatkan pada
tingkatan cgroup yang tertinggi (contohnya, <code>runtime.slice</code> pada mesin systemd).
Secara ideal, setiap <em>daemon</em> sistem sebaiknya dijalankan pada <em>child</em> cgroup
di bawah <em>parent</em> ini. Lihat <a href=https://git.k8s.io/design-proposals-archive/node/node-allocatable.md#recommended-cgroups-setup>dokumentasi</a>
untuk mengetahui rekomendasi hierarki cgroup secara detail.</p><p>Catatan: kubelet <strong>tidak membuat</strong> <code>--kube-reserved-cgroup</code> jika cgroup
yang diberikan tidak ada pada sistem. Jika cgroup yang tidak valid diberikan,
maka kubelet akan mengalami kegagalan.</p><h3 id=system-reserved>System Reserved</h3><ul><li><strong><em>Flag</em> Kubelet</strong>: <code>--system-reserved=[cpu=100m][,][memory=100Mi][,][ephemeral-storage=1Gi][,][pid=1000]</code></li><li><strong><em>Flag</em> Kubelet</strong>: <code>--system-reserved-cgroup=</code></li></ul><p><code>system-reserved</code> berfungsi untuk mengetahui reservasi sumber daya untuk
<em>daemon</em> sistem pada OS, seperti <code>sshd</code>, <code>udev</code>, dan lainnya. <code>system-reserved</code> sebaiknya
mereservasi memori untuk kernel juga, karena memori kernel tidak termasuk dalam
hitungan kalkulasi Pod pada Kubernetes. Kami juga merekomendasikan reservasi sumber daya
untuk sesi (<em>session</em>) login pengguna (contohnya, <code>user.slice</code> di dalam dunia systemd).</p><h3 id=melakukan-reservasi-daftar-cpu-secara-eksplisit>Melakukan Reservasi Daftar CPU secara Eksplisit</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.17 [stable]</code></div><ul><li><strong><em>Flag</em> Kubelet</strong>: <code>--reserved-cpus=0-3</code></li></ul><p><code>reserved-cpus</code> berfungsi untuk mendefinisikan <a href=https://www.kernel.org/doc/Documentation/cgroup-v1/cpusets.txt>cpuset</a> secara eksplisit untuk
<em>daemon</em> sistem OS dan <em>daemon</em> sistem Kubernetes. <code>reserved-cpus</code> dimaksudkan untuk
sistem-sistem yang tidak mendefinisikan tingkatan cgroup tertinggi secara terpisah untuk
<em>daemon</em> sistem OS dan <em>daemon</em> sistem Kubernetes yang berkaitan dengan sumber daya cpuset.</p><p>Jika kubelet <strong>tidak memiliki</strong> <code>--system-reserved-cgroup</code> dan <code>--kube-reserved-cgroup</code>,
cpuset akan diberikan secara eksplisit oleh <code>reserved-cpus</code>, yang akan menimpa definisi
yang diberikan oleh opsi <code>--kube-reserved</code> dan <code>--system-reserved</code>.</p><p>Opsi ini dirancang secara spesifik untuk kasus-kasus Telco/NFV, di mana <em>interrupt</em> atau <em>timer</em>
yang tidak terkontrol bisa memengaruhi performa dari beban kerja. Kamu dapat menggunakan
opsi untuk untuk mendefinisikan cpuset secara eksplisit untuk <em>daemon</em> sistem/Kubernetes dan
<em>interrupt</em>/<em>timer</em>, sehingga CPU sisanya dalam sistem akan digunakan untuk beban kerja saja,
dengan dampak yang sedikit terhadap <em>interrupt</em>/<em>timer</em> yang tidak terkontrol. Untuk
memindahkan <em>daemon</em> sistem, <em>daemon</em> Kubernetes serta <em>interrrupt</em>/<em>timer</em> Kubernetes supaya
menggunakan cpuset yang eksplisit didefinisikan oleh opsi ini, sebaiknya digunakan mekanisme lain di luar Kubernetes. Contohnya: pada Centos, kamu dapat melakukan ini dengan menggunakan
toolset yang sudah disetel.</p><h3 id=batas-pengusiran-eviction-threshold>Batas Pengusiran (<em>Eviction Threshold</em>)</h3><ul><li><strong><em>Flag</em> Kubelet</strong>: <code>--eviction-hard=[memory.available&lt;500Mi]</code></li></ul><p>Tekanan memori pada tingkatan Node menyebabkan sistem OOM (<em>Out Of Memory</em>) yang
berdampak pada Node secara keseluruhan dan semua Pod yang dijalankan di dalamnya.
Node dapat berubah menjadi <em>offline</em> sementara sampai memori berhasil diklaim kembali.
Untuk menghindari sistem OOM, atau mengurangi kemungkinan terjadinya OOM, kubelet
menyediakan fungsi untuk pengelolaan saat <a href=/docs/tasks/administer-cluster/out-of-resource/>Kehabisan Sumber Daya (<em>Out of Resource</em>)</a>.
Pengusiran dapat dilakukan hanya untuk kasus kehabisan <code>memory</code> dan <code>ephemeral-storage</code>. Dengan mereservasi
sebagian memori melalui <em>flag</em> <code>--eviction-hard</code>, kubelet akan berusaha untuk "mengusir" (<em>evict</em>)
Pod ketika ketersediaan memori pada Node jatuh di bawah nilai yang telah direservasi.
Dalam bahasa sederhana, jika <em>daemon</em> sistem tidak ada pada Node, maka Pod tidak dapat menggunakan
memori melebihi nilai yang ditentukan oleh <em>flag</em> <code>--eviction-hard</code>. Karena alasan ini,
sumber daya yang direservasi untuk pengusiran tidak tersedia untuk Pod.</p><h3 id=memaksakan-allocatable-pada-node>Memaksakan <em>Allocatable</em> pada Node</h3><ul><li><strong><em>Flag</em> Kubelet</strong>: <code>--enforce-node-allocatable=pods[,][system-reserved][,][kube-reserved]</code></li></ul><p>Penjadwal menganggap <code>Allocatable</code> sebagai kapasitas yang tersedia untuk digunakan oleh Pod.</p><p>Secara bawaan, kubelet memaksakan <code>Allocatable</code> untuk semua Pod. Pemaksaan dilakukan
dengan cara "mengusir" Pod-Pod ketika penggunaan sumber daya Pod secara keseluruhan telah
melewati nilai <code>Allocatable</code>. Lihat <a href=/docs/tasks/administer-cluster/out-of-resource/#eviction-policy>bagian ini</a>
untuk mengetahui kebijakan pengusiran secara detail. Pemaksaan ini dikendalikan dengan
cara memberikan nilai Pod melalui <em>flag</em> <code>--enforce-node-allocatable</code> pada kubelet.</p><p>Secara opsional, kubelet dapat diatur untuk memaksakan <code>kube-reserved</code> dan
<code>system-reserved</code> dengan memberikan nilai melalui <em>flag</em> tersebut. Sebagai catatan,
jika kamu mengatur <code>kube-reserved</code>, maka kamu juga harus mengatur <code>--kube-reserved-cgroup</code>. Begitu pula
jika kamu mengatur <code>system-reserved</code>, maka kamu juga harus mengatur <code>--system-reserved-cgroup</code>.</p><h2 id=panduan-umum>Panduan Umum</h2><p><em>Daemon</em> sistem dilayani mirip seperti Pod <code>Guaranteed</code> yang terjamin sumber dayanya.
<em>Daemon</em> sistem dapat melakukan <em>burst</em> di dalam jangkauan cgroup. Perilaku ini
dikelola sebagai bagian dari penggelaran (<em>deployment</em>) Kubernetes. Sebagai contoh,
kubelet harus memiliki cgroup sendiri dan membagikan sumber daya <code>kube-reserved</code> dengan
<em>runtime</em> Container. Namun begitu, kubelet tidak dapat melakukan <em>burst</em> dan menggunakan
semua sumber daya yang tersedia pada Node jika <code>kube-reserved</code> telah dipaksakan pada sistem.</p><p>Kamu harus berhati-hati ekstra ketika memaksakan reservasi <code>system-reserved</code> karena dapat
menyebabkan layanan sistem yang terpenting mengalami CPU <em>starvation</em>, OOM <em>killed</em>, atau tidak
dapat melakukan <em>fork</em> pada Node. Kami menyarankan untuk memaksakan <code>system-reserved</code> hanya
jika pengguna telah melakukan <em>profiling</em> sebaik mungkin pada Node mereka untuk
mendapatkan estimasi yang akurat dan percaya diri terhadap kemampuan mereka untuk
memulihkan sistem ketika ada grup yang terkena OOM <em>killed</em>.</p><ul><li>Untuk memulai, paksakan <code>Allocatable</code> pada Pod.</li><li>Ketika <em>monitoring</em> dan <em>alerting</em> telah cukup dilakukan untuk memonitor <em>daemon</em>
dari sistem Kubernetes, usahakan untuk memaksakan <code>kube-reserved</code> berdasarkan penggunakan heuristik.</li><li>Jika benar-benar diperlukan, paksakan <code>system-reserved</code> secara bertahap.</li></ul><p>Sumber daya yang diperlukan oleh <em>daemon</em> sistem Kubernetes dapat tumbuh seiring waktu dengan
adanya penambahan fitur-fitur baru. Proyek Kubernetes akan berusaha untuk menurunkan penggunaan sumber daya
dari <em>daemon</em> sistem Node, tetapi belum menjadi prioritas untuk saat ini.
Kamu dapat berekspektasi bahwa fitur kapasitas <code>Allocatable</code> ini akan dihapus pada versi yang akan datang.</p><h2 id=contoh-skenario>Contoh Skenario</h2><p>Berikut ini merupakan contoh yang menggambarkan komputasi <code>Allocatable</code> pada Node:</p><ul><li>Node memiliki 16 CPU, memori sebesar 32Gi, dan penyimpanan sebesar 100Gi.</li><li><code>--kube-reserved</code> diatur menjadi <code>cpu=1,memory=2Gi,ephemeral-storage=1Gi</code></li><li><code>--system-reserved</code> diatur menjadi <code>cpu=500m,memory=1Gi,ephemeral-storage=1Gi</code></li><li><code>--eviction-hard</code> diatur menjadi <code>memory.available&lt;500Mi,nodefs.available&lt;10%</code></li></ul><p>Dalam skenario ini, <code>Allocatable</code> akan menjadi 14.5 CPU, memori 28.5Gi, dan penyimpanan
lokal 88Gi.
Penjadwal memastikan bahwa semua Pod yang berjalan pada Node ini secara total tidak meminta memori melebihi
28.5Gi dan tidak menggunakan penyimpanan lokal melebihi 88Gi.
Pengusiran Pod akan dilakukan kubelet ketika penggunaan memori keseluruhan oleh Pod telah melebihi 28.5Gi,
atau jika penggunaan penyimpanan keseluruhan telah melebihi 88Gi. Jika semua proses pada Node mengonsumsi
CPU sebanyak-banyaknya, Pod-Pod tidak dapat mengonsumsi lebih dari 14.5 CPU.</p><p>Jika <code>kube-reserved</code> dan/atau <code>system-reserved</code> tidak dipaksakan dan <em>daemon</em> sistem
melebihi reservasi mereka, maka kubelet akan mengusir Pod ketika penggunaan memori pada Node
melebihi 31.5Gi atau penggunaan penyimpanan melebihi 90Gi.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-1e966f5d0540bbee0876f9d0d08d54dc>4.4.6 - Membagi sebuah Klaster dengan Namespace</h1><p>Laman ini menunjukkan bagaimana cara melihat, menggunakan dan menghapus <a class=glossary-tooltip title='Sebuah abstraksi yang digunakan oleh Kubernetes untuk mendukung multipel klaster virtual pada klaster fisik yang sama.' data-toggle=tooltip data-placement=top href=/id/docs/concepts/overview/working-with-objects/namespaces target=_blank aria-label=namespaces>namespaces</a>. Laman ini juga menunjukkan bagaimana cara menggunakan Namespace Kubernetes namespaces untuk membagi klaster kamu.</p><h2 id=sebelum-kamu-memulai>Sebelum kamu memulai</h2><ul><li>Memiliki <a href=/id/docs/setup/>Klaster Kubernetes</a>.</li><li>Memiliki pemahaman dasar <a href=/id/docs/concepts/workloads/pods/pod/><em>Pod</em></a>, <a href=/id/docs/concepts/services-networking/service/><em>Service</em></a>, dan <a href=/id/docs/concepts/workloads/controllers/deployment/><em>Deployment</em></a> dalam Kubernetes.</li></ul><h2 id=melihat-namespace>Melihat Namespace</h2><ol><li>Untuk melihat Namespace yang ada saat ini pada sebuah klaster anda bisa menggunakan:</li></ol><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get namespaces
</span></span></code></pre></div><pre tabindex=0><code>NAME          STATUS    AGE
default       Active    11d
kube-system   Active    11d
kube-public   Active    11d
</code></pre><p>Kubernetes mulai dengan tiga Namespace pertama:</p><ul><li><code>default</code> Namespace bawaan untuk objek-objek yang belum terkait dengan Namespace lain</li><li><code>kube-system</code> Namespace untuk objek-objek yang dibuat oleh sistem Kubernetes</li><li><code>kube-public</code> Namespace ini dibuat secara otomatis dan dapat dibaca oleh seluruh pengguna (termasuk yang tidak terotentikasi). Namespace ini sering dicadangkan untuk kepentingan klaster, untuk kasus dimana beberapa sumber daya seharusnya dapat terlihat dan dapat terlihat secara publik di seluruh klaster. Aspek publik pada Namespace ini hanya sebuah konvensi bukan suatu kebutuhan.</li></ul><p>Kamu bisa mendapat ringkasan Namespace tertentu dengan menggunakan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get namespaces &lt;name&gt;
</span></span></code></pre></div><p>Atau kamu bisa mendapatkan informasi detail menggunakan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe namespaces &lt;name&gt;
</span></span></code></pre></div><pre tabindex=0><code>Name:           default
Labels:         &lt;none&gt;
Annotations:    &lt;none&gt;
Status:         Active

No resource quota.

Resource Limits
 Type       Resource    Min Max Default
 ----               --------    --- --- ---
 Container          cpu         -   -   100m
</code></pre><p>Sebagai catatan, detail diatas menunjukkan baik kuota sumber daya (jika ada) dan juga jangkauan batas sumber daya.</p><p>Kuota sumber daya melacak penggunaan total sumber daya didalam Namespace dan mengijinkan operator-operator klaster mendefinisikan batas atas penggunaan sumber daya yang dapat di gunakan sebuah Namespace.</p><p>Jangkauan batas mendefinisikan pertimbangan min/maks jumlah sumber daya yang dapat di gunakan oleh sebuah entitas dalam sebuah Namespace.</p><p>Lihatlah <a href=https://git.k8s.io/community/contributors/design-proposals/resource-management/admission_control_limit_range.md>Kontrol Admisi: Rentang Batas</a></p><p>Sebuah Namespace dapat berada dalam salah satu dari dua buah fase:</p><ul><li><code>Active</code> Namespace sedang digunakan</li><li><code>Terminating</code> Namespace sedang dihapus dan tidak dapat digunakan untuk objek-objek baru</li></ul><p>Lihat <a href=https://git.k8s.io/community/contributors/design-proposals/architecture/namespaces.md#phases>dokumentasi desain</a> untuk detil lebih lanjut.</p><h2 id=membuat-sebuah-namespace-baru>Membuat sebuah Namespace baru</h2><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Hindari membuat Namespace dengan awalan <code>kube-</code>, karena awalan ini dicadangkan untuk Namespace dari sistem Kubernetes.</div><ol><li><p>Buat berkas YAML baru dengan nama <code>my-namespace.yaml</code> dengan isi berikut ini:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Namespace<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>&lt;masukkan-nama-namespace-disini&gt;<span style=color:#bbb>
</span></span></span></code></pre></div><p>Then run:</p><pre tabindex=0><code>kubectl create -f ./my-namespace.yaml
</code></pre></li><li><p>Sebagai alternatif, kamu bisa membuat Namespace menggunakan perintah dibawah ini:</p><pre tabindex=0><code>kubectl create namespace &lt;masukkan-nama-namespace-disini&gt;
</code></pre></li></ol><p>Nama Namespace kamu harus merupakan
<a href=/docs/concepts/overview/working-with-objects/names#dns-label-names>Label DNS</a> yang valid.</p><p>Ada kolom opsional <code>finalizers</code>, yang memungkinkan <em>observables</em> untuk membersihkan sumber daya ketika Namespace dihapus. Ingat bahwa jika kamu memberikan finalizer yang tidak ada, Namespace akan dibuat tapi akan berhenti pada status <code>Terminating</code> jika pengguna mencoba untuk menghapusnya.</p><p>Informasi lebih lanjut mengenai <code>finalizers</code> bisa dibaca pada <a href=https://git.k8s.io/community/contributors/design-proposals/architecture/namespaces.md#finalizers>dokumentasi desain</a> dari Namespace.</p><h2 id=menghapus-namespace>Menghapus Namespace</h2><p>Hapus Namespace dengan</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete namespaces &lt;insert-some-namespace-name&gt;
</span></span></code></pre></div><div class="alert alert-danger warning callout" role=alert><strong>Peringatan:</strong> Ini akan menghapus semua hal yang ada dalam Namespace!</div><p>Proses penghapusan ini asinkron, jadi untuk beberapa waktu kamu akan melihat Namespace dalam status <code>Terminating</code>.</p><h2 id=membagi-klaster-kamu-menggunakan-namespace-kubernetes>Membagi klaster kamu menggunakan Namespace Kubernetes</h2><ol><li><p>Pahami Namespace bawaan</p><p>Secara bawaan, sebuah klaster Kubernetes akan membuat Namespace bawaan ketika menyediakan klaster untuk menampung Pod, Service, dan Deployment yang digunakan oleh klaster.</p><p>Dengan asumsi kamu memiliki klaster baru, kamu bisa mengecek Namespace yang tersedia dengan melakukan hal berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get namespaces
</span></span></code></pre></div><pre tabindex=0><code>NAME      STATUS    AGE
default   Active    13m
</code></pre></li><li><p>Membuat Namespace baru</p><p>Untuk latihan ini, kita akan membuat dua Namespace Kubernetes tambahan untuk menyimpan konten kita</p><p>Dalam sebuah skenario dimana sebuah organisasi menggunakan klaster Kubernetes yang digunakan bersama untuk penggunaan pengembangan dan produksi:</p><p>Tim pengembang ingin mengelola ruang di dalam klaster dimana mereka bisa melihat daftar Pod, Service, dan Deployment yang digunakan untuk membangun dan menjalankan apliksi mereka. Di ruang ini sumber daya akan datang dan pergi, dan pembatasan yang tidak ketat mengenai siapa yang bisa atau tidak bisa memodifikasi sumber daya untuk mendukung pengembangan secara gesit (<em>agile</em>).</p><p>Tim operasi ingin mengelola ruang didalam klaster dimana mereka bisa memaksakan prosedur ketat mengenai siapa yang bisa atau tidak bisa melakukan manipulasi pada kumpulan Pod, Layanan, dan Deployment yang berjalan pada situs produksi.</p><p>Satu pola yang bisa diikuti organisasi ini adalah dengan membagi klaster Kubernetes menjadi dua Namespace: <code>development</code> dan <code>production</code></p><p>Mari kita buat dua Namespace untuk menyimpan hasil kerja kita.</p><p>Buat Namespace <code>development</code> menggunakan kubectl:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f https://k8s.io/examples/admin/namespace-dev.json
</span></span></code></pre></div><p>Kemudian mari kita buat Namespace <code>production</code> menggunakan kubectl:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f https://k8s.io/examples/admin/namespace-prod.json
</span></span></code></pre></div><p>Untuk memastikan apa yang kita lakukan benar, lihat seluruh Namespace dalam klaster.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get namespaces --show-labels
</span></span></code></pre></div><pre tabindex=0><code>NAME          STATUS    AGE       LABELS
default       Active    32m       &lt;none&gt;
development   Active    29s       name=development
production    Active    23s       name=production
</code></pre></li><li><p>Buat pod pada setiap Namespace</p><p>Sebuah Namespace Kubernetes memberikan batasan untuk Pod, Service, dan Deployment dalam klaster.</p><p>Pengguna yang berinteraksi dengan salah satu Namespace tidak melihat konten di dalam Namespace lain</p><p>Untuk menunjukkan hal ini, mari kita jalankan Deployment dan Pod sederhana di dalam Namespace <code>development</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create deployment snowflake --image<span style=color:#666>=</span>k8s.gcr.io/serve_hostname -n<span style=color:#666>=</span>development
</span></span><span style=display:flex><span>kubectl scale deployment snowflake --replicas<span style=color:#666>=</span><span style=color:#666>2</span> -n<span style=color:#666>=</span>development
</span></span></code></pre></div><p>Kita baru aja membuat sebuah Deployment yang memiliki ukuran replika dua yang menjalankan Pod dengan nama <code>snowflake</code> dengan sebuah Container dasar yang hanya melayani <em>hostname</em>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get deployment -n<span style=color:#666>=</span>development
</span></span></code></pre></div><pre tabindex=0><code>NAME         READY   UP-TO-DATE   AVAILABLE   AGE
snowflake    2/2     2            2           2m
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>snowflake -n<span style=color:#666>=</span>development
</span></span></code></pre></div><pre tabindex=0><code>NAME                         READY     STATUS    RESTARTS   AGE
snowflake-3968820950-9dgr8   1/1       Running   0          2m
snowflake-3968820950-vgc4n   1/1       Running   0          2m
</code></pre><p>Dan ini merupakan sesuatu yang bagus, dimana pengembang bisa melakukan hal yang ingin mereka lakukan tanpa harus khawatir hal itu akan mempengaruhi konten pada namespace <code>production</code>.</p><p>Mari kita pindah ke Namespace <code>production</code> dan menujukkan bagaimana sumber daya di satu Namespace disembunyikan dari yang lain</p><p>Namespace <code>production</code> seharusnya kosong, dan perintah berikut ini seharusnya tidak menghasilkan apapun.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get deployment -n<span style=color:#666>=</span>production
</span></span><span style=display:flex><span>kubectl get pods -n<span style=color:#666>=</span>production
</span></span></code></pre></div><p><code>Production</code> Namespace ingin menjalankan <code>cattle</code>, mari kita buat beberapa Pod <code>cattle</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create deployment cattle --image<span style=color:#666>=</span>k8s.gcr.io/serve_hostname -n<span style=color:#666>=</span>production
</span></span><span style=display:flex><span>kubectl scale deployment cattle --replicas<span style=color:#666>=</span><span style=color:#666>5</span> -n<span style=color:#666>=</span>production
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl get deployment -n<span style=color:#666>=</span>production
</span></span></code></pre></div><pre tabindex=0><code>NAME         READY   UP-TO-DATE   AVAILABLE   AGE
cattle       5/5     5            5           10s
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>cattle -n<span style=color:#666>=</span>production
</span></span></code></pre></div><pre tabindex=0><code>NAME                      READY     STATUS    RESTARTS   AGE
cattle-2263376956-41xy6   1/1       Running   0          34s
cattle-2263376956-kw466   1/1       Running   0          34s
cattle-2263376956-n4v97   1/1       Running   0          34s
cattle-2263376956-p5p3i   1/1       Running   0          34s
cattle-2263376956-sxpth   1/1       Running   0          34s
</code></pre></li></ol><p>Sampai sini, seharusnya sudah jelas bahwa sumber daya yang dibuat pengguna pada sebuah Namespace disembunyikan dari Namespace lainnya.</p><p>Seiring dengan evolusi dukungan kebijakan di Kubernetes, kami akan memperluas skenario ini untuk menunjukkan bagaimana kamu bisa menyediakan aturan otorisasi yang berbeda untuk tiap Namespace.</p><h2 id=memahami-motivasi-penggunaan-namespace>Memahami motivasi penggunaan Namespace</h2><p>Sebuah klaster tunggal umumnya bisa memenuhi kebutuhan pengguna yang berbeda atau kelompok pengguna (itulah sebabnya disebut 'komunitas pengguna').</p><p>Namespace Kubernetes membantu proyek-proyek, tim-tim dan pelanggan yang berbeda untuk berbagi klaster Kubernetes.</p><p>Ini dilakukan dengan menyediakan hal berikut:</p><ol><li>Cakupan untuk <a href=/id/docs/concepts/overview/working-with-objects/names/>Names</a>.</li><li>Sebuah mekanisme untuk memasang otorisasi dan kebijakan untuk bagian dari klaster.</li></ol><p>Penggunaan Namespace berbeda merupakan hal opsional.</p><p>Tiap komunitas pengguna ingin bisa bekerja secara terisolasi dari komunitas lainnya.</p><p>Tiap komunitas pengguna memiliki hal berikut sendiri:</p><ol><li>sumber daya (Pod, Service, ReplicationController, dll.)</li><li>kebijakan (siapa yang bisa atau tidak bisa melakukan hal tertentu dalam komunitasnya)</li><li>batasan (komunitas ini diberi kuota sekian, dll.)</li></ol><p>Seorang operator klaster dapat membuat sebuah Namespace untuk tiap komunitas user yang unik.</p><p>Namespace tersebut memberikan cakupan yang unik untuk:</p><ol><li>penamaan sumber daya (untuk menghindari benturan penamaan dasar)</li><li>pendelegasian otoritas pengelolaan untuk pengguna yang dapat dipercaya</li><li>kemampuan untuk membatasi konsumsi sumber daya komunitas</li></ol><p>Contoh penggunaan mencakup</p><ol><li>Sebagai operator klaster, aku ingin mendukung beberapa komunitas pengguna dalam sebuah klaster.</li><li>Sebagai operator klaster, aku ingin mendelegasikan otoritas untuk mempartisi klaster ke pengguna terpercaya di komunitasnya.</li><li>Sebagai operator klaster, aku ingin membatasi jumlah sumber daya yang bisa dikonsumsi komunitas dalam rangka membatasi dampak ke komunitas lain yang menggunakan klaster yang sama.</li><li>Sebagai pengguna klaster, aku ingin berinteraksi dengan sumber daya yang berkaitan dengan komunitas pengguna saya secara terisolasi dari apa yang dilakukan komunitas lain di klaster yang sama.</li></ol><h2 id=memahami-namespace-dan-dns>Memahami Namespace dan DNS</h2><p>Ketika kamu membuat sebuah <a href=/docs/concepts/services-networking/service/>Service</a>, akan terbentuk <a href=/id/docs/concepts/services-networking/dns-pod-service/>entri DNS</a> untuk Service tersebut.
Entri DNS ini dalam bentuk <code>&lt;service-name>.&lt;namespace-name>.svc.cluster.local</code>, yang berarti jika sebuah Container hanya menggunakan <code>&lt;service-name></code> maka dia akan me-<em>resolve</em> ke layanan yang lokal dalam Namespace yang sama. Ini berguna untuk menggunakan konfigurasi yang sama pada Namespace yang berbeda seperti <em>Development</em>, <em>Staging</em> dan <em>Production</em>. Jika kami ingin menjangkau antar Namespace, kamu harus menggunakan <em>fully qualified domain name</em> (FQDN).</p><h2 id=selanjutnya>Selanjutnya</h2><ul><li>Pelajari lebih lanjut mengenai <a href=/id/docs/concepts/overview/working-with-objects/namespaces/#pengaturan-preferensi-namespace>pengaturan preferensi Namespace</a>.</li><li>Pelajari lebih lanjut mengenai <a href=/id/docs/concepts/overview/working-with-objects/namespaces/#pengaturan-namespace-untuk-sebuah-permintaan>pengaturan namespace untuk sebuah permintaan</a></li><li>Baca <a href=https://github.com/kubernetes/community/blob/main/contributors/design-proposals/architecture/namespaces.md>desain Namespace</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-0b17e83b6049e53b8ffa864bdfa07c87>4.4.7 - Mengatur Control Plane Kubernetes dengan Ketersediaan Tinggi (High-Availability)</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.5 [alpha]</code></div><p>Kamu dapat mereplikasi <em>control plane</em> Kubernetes dalam skrip <code>kube-up</code> atau <code>kube-down</code> untuk Google Compute Engine (GCE).
Dokumen ini menjelaskan cara menggunakan skrip kube-up/down untuk mengelola <em>control plane</em> dengan ketersedian tinggi atau <em>high_availability</em> (HA) dan bagaimana <em>control plane</em> HA diimplementasikan untuk digunakan dalam GCE.</p><h2 id=sebelum-kamu-memulai>Sebelum kamu memulai</h2><p><p>Kamu harus memiliki klaster Kubernetes, dan perangkat baris perintah kubectl
juga harus dikonfigurasikan untuk berkomunikasi dengan klastermu. Jika kamu
belum memiliki klaster, kamu dapat membuatnya dengan menggunakan
<a href=/id/docs/tasks/tools/#minikube>minikube</a>,
atau kamu juga dapat menggunakan salah satu dari tempat mencoba Kubernetes berikut ini:</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>Bermain dengan Kubernetes</a></li></ul>Untuk melihat versi, tekan <code>kubectl version</code>.</p><h2 id=memulai-klaster-yang-kompatibel-dengan-ha>Memulai klaster yang kompatibel dengan HA</h2><p>Untuk membuat klaster yang kompatibel dengan HA, kamu harus mengatur tanda ini pada skrip <code>kube-up</code>:</p><ul><li><p><code>MULTIZONE=true</code> - untuk mencegah penghapusan replika <em>control plane</em> kubelet dari zona yang berbeda dengan zona bawaan server.
Ini diperlukan jika kamu ingin menjalankan replika <em>control plane</em> pada zona berbeda, dimana hal ini disarankan.</p></li><li><p><code>ENABLE_ETCD_QUORUM_READ=true</code> - untuk memastikan bahwa pembacaan dari semua server API akan mengembalikan data terbaru.
Jika <code>true</code>, bacaan akan diarahkan ke replika pemimpin dari etcd.
Menetapkan nilai ini menjadi <code>true</code> bersifat opsional: pembacaan akan lebih dapat diandalkan tetapi juga akan menjadi lebih lambat.</p></li></ul><p>Sebagai pilihan, kamu dapat menentukan zona GCE tempat dimana replika <em>control plane</em> pertama akan dibuat.
Atur tanda berikut:</p><ul><li><code>KUBE_GCE_ZONE=zone</code> - zona tempat di mana replika <em>control plane</em> pertama akan berjalan.</li></ul><p>Berikut ini contoh perintah untuk mengatur klaster yang kompatibel dengan HA pada zona GCE europe-west1-b:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#b8860b>MULTIZONE</span><span style=color:#666>=</span><span style=color:#a2f>true</span> <span style=color:#b8860b>KUBE_GCE_ZONE</span><span style=color:#666>=</span>europe-west1-b  <span style=color:#b8860b>ENABLE_ETCD_QUORUM_READS</span><span style=color:#666>=</span><span style=color:#a2f>true</span> ./cluster/kube-up.sh
</span></span></code></pre></div><p>Perhatikan bahwa perintah di atas digunakan untuk membuat klaster dengan sebuah <em>control plane</em>;
Namun, kamu bisa menambahkan replika <em>control plane</em> baru ke klaster dengan perintah berikutnya.</p><h2 id=menambahkan-replika-control-plane-yang-baru>Menambahkan replika <em>control plane</em> yang baru</h2><p>Setelah kamu membuat klaster yang kompatibel dengan HA, kamu bisa menambahkan replika <em>control plane</em> ke sana.
Kamu bisa menambahkan replika <em>control plane</em> dengan menggunakan skrip <code>kube-up</code> dengan tanda berikut ini:</p><ul><li><p><code>KUBE_REPLICATE_EXISTING_MASTER=true</code> - untuk membuat replika dari <em>control plane</em> yang sudah ada.</p></li><li><p><code>KUBE_GCE_ZONE=zone</code> - zona di mana replika <em>control plane</em> itu berjalan.
Region ini harus sama dengan region dari zona replika yang lain.</p></li></ul><p>Kamu tidak perlu mengatur tanda <code>MULTIZONE</code> atau <code>ENABLE_ETCD_QUORUM_READS</code>,
karena tanda itu diturunkan pada saat kamu memulai klaster yang kompatible dengan HA.</p><p>Berikut ini contoh perintah untuk mereplikasi <em>control plane</em> pada klaster sebelumnya yang kompatibel dengan HA:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#b8860b>KUBE_GCE_ZONE</span><span style=color:#666>=</span>europe-west1-c <span style=color:#b8860b>KUBE_REPLICATE_EXISTING_MASTER</span><span style=color:#666>=</span><span style=color:#a2f>true</span> ./cluster/kube-up.sh
</span></span></code></pre></div><h2 id=menghapus-replika-control-plane>Menghapus replika <em>control plane</em></h2><p>Kamu dapat menghapus replika <em>control plane</em> dari klaster HA dengan menggunakan skrip <code>kube-down</code> dengan tanda berikut:</p><ul><li><p><code>KUBE_DELETE_NODES=false</code> - untuk mencegah penghapusan kubelet.</p></li><li><p><code>KUBE_GCE_ZONE=zone</code> - zona di mana replika <em>control plane</em> akan dihapus.</p></li><li><p><code>KUBE_REPLICA_NAME=replica_name</code> - (opsional) nama replika <em>control plane</em> yang akan dihapus.
Jika kosong: replika mana saja dari zona yang diberikan akan dihapus.</p></li></ul><p>Berikut ini contoh perintah untuk menghapus replika <em>control plane</em> dari klaster HA yang sudah ada sebelumnya:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#b8860b>KUBE_DELETE_NODES</span><span style=color:#666>=</span><span style=color:#a2f>false</span> <span style=color:#b8860b>KUBE_GCE_ZONE</span><span style=color:#666>=</span>europe-west1-c ./cluster/kube-down.sh
</span></span></code></pre></div><h2 id=mengatasi-replika-control-plane-yang-gagal>Mengatasi replika <em>control plane</em> yang gagal</h2><p>Jika salah satu replika <em>control plane</em> di klaster HA kamu gagal,
praktek terbaik adalah menghapus replika dari klaster kamu dan menambahkan replika baru pada zona yang sama.
Berikut ini contoh perintah yang menunjukkan proses tersebut:</p><ol><li>Menghapus replika yang gagal:</li></ol><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#b8860b>KUBE_DELETE_NODES</span><span style=color:#666>=</span><span style=color:#a2f>false</span> <span style=color:#b8860b>KUBE_GCE_ZONE</span><span style=color:#666>=</span>replica_zone <span style=color:#b8860b>KUBE_REPLICA_NAME</span><span style=color:#666>=</span>replica_name ./cluster/kube-down.sh
</span></span></code></pre></div><ol start=2><li>Menambahkan replika baru untuk menggantikan replika yang lama</li></ol><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#b8860b>KUBE_GCE_ZONE</span><span style=color:#666>=</span>replica-zone <span style=color:#b8860b>KUBE_REPLICATE_EXISTING_MASTER</span><span style=color:#666>=</span><span style=color:#a2f>true</span> ./cluster/kube-up.sh
</span></span></code></pre></div><h2 id=praktek-terbaik-untuk-mereplikasi-control-plane-untuk-klaster-ha>Praktek terbaik untuk mereplikasi <em>control plane</em> untuk klaster HA</h2><ul><li><p>Usahakan untuk menempatkan replika <em>control plane</em> pada zona yang berbeda. Pada saat terjadi kegagalan zona, semua <em>control plane</em> yang ditempatkan dalam zona tersebut akan gagal pula.
Untuk bertahan dari kegagalan pada sebuah zona, tempatkan juga Node pada beberapa zona yang lain
(Lihatlah <a href=/id/docs/setup/best-practices/multiple-zones/>multi-zona</a> untuk lebih detail).</p></li><li><p>Jangan gunakan klaster dengan dua replika <em>control plane</em>. Konsensus pada klaster dengan dua replika membutuhkan kedua replika tersebut berjalan pada saat mengubah keadaan yang persisten.
Akibatnya, kedua replika tersebut diperlukan dan kegagalan salah satu replika mana pun mengubah klaster dalam status kegagalan mayoritas.
Dengan demikian klaster dengan dua replika lebih buruk, dalam hal HA, daripada klaster dengan replika tunggal.</p></li><li><p>Ketika kamu menambahkan sebuah replika <em>control plane</em>, status klaster (etcd) disalin ke sebuah <em>instance</em> baru.
Jika klaster itu besar, mungkin butuh waktu yang lama untuk menduplikasi keadaannya.
Operasi ini dapat dipercepat dengan memigrasi direktori data etcd, seperti yang dijelaskan <a href=https://coreos.com/etcd/docs/latest/admin_guide.html#member-migration>di sini</a>
(Kami sedang mempertimbangkan untuk menambahkan dukungan untuk migrasi direktori data etcd di masa mendatang).</p></li></ul><h2 id=catatan-implementasi>Catatan implementasi</h2><p><img src=/images/docs/ha-master-gce.png alt=ha-master-gce></p><h3 id=ikhtisar>Ikhtisar</h3><p>Setiap replika <em>control plane</em> akan menjalankan komponen berikut dalam mode berikut:</p><ul><li><p><em>instance</em> etcd: semua <em>instance</em> akan dikelompokkan bersama menggunakan konsensus;</p></li><li><p>server API : setiap server akan berbicara dengan lokal etcd - semua server API pada cluster akan tersedia;</p></li><li><p>pengontrol (<em>controller</em>), penjadwal (<em>scheduler</em>), dan <em>scaler</em> klaster automatis: akan menggunakan mekanisme sewa - dimana hanya satu <em>instance</em> dari masing-masing mereka yang akan aktif dalam klaster;</p></li><li><p>manajer tambahan (<em>add-on</em>): setiap manajer akan bekerja secara independen untuk mencoba menjaga tambahan dalam sinkronisasi.</p></li></ul><p>Selain itu, akan ada penyeimbang beban (<em>load balancer</em>) di depan server API yang akan mengarahkan lalu lintas eksternal dan internal menuju mereka.</p><h3 id=penyeimbang-beban>Penyeimbang Beban</h3><p>Saat memulai replika <em>control plane</em> kedua, penyeimbang beban yang berisi dua replika akan dibuat
dan alamat IP dari replika pertama akan dipromosikan ke alamat IP penyeimbang beban.
Demikian pula, setelah penghapusan replika <em>control plane</em> kedua yang dimulai dari paling akhir, penyeimbang beban akan dihapus dan alamat IP-nya akan diberikan ke replika terakhir yang ada.
Mohon perhatikan bahwa pembuatan dan penghapusan penyeimbang beban adalah operasi yang rumit dan mungkin perlu beberapa waktu (~20 menit) untuk dipropagasikan.</p><h3 id=service-control-plane-kubelet>Service <em>control plane</em> & kubelet</h3><p>Daripada sistem mencoba untuk menjaga daftar terbaru dari apiserver Kubernetes yang ada dalam Service Kubernetes,
sistem akan mengarahkan semua lalu lintas ke IP eksternal:</p><ul><li><p>dalam klaster dengan satu <em>control plane</em>, IP diarahkan ke <em>control plane</em> tunggal.</p></li><li><p>dalam klaster dengan multiple <em>control plane</em>, IP diarahkan ke penyeimbang beban yang ada di depan <em>control plane</em>.</p></li></ul><p>Demikian pula, IP eksternal akan digunakan oleh kubelet untuk berkomunikasi dengan <em>control plane</em>.</p><h3 id=sertifikat-control-plane>Sertifikat <em>control plane</em></h3><p>Kubernetes menghasilkan sertifikat TLS <em>control plane</em> untuk IP publik eksternal dan IP lokal untuk setiap replika.
Tidak ada sertifikat untuk IP publik sementara (<em>ephemeral</em>) dari replika;
Untuk mengakses replika melalui IP publik sementara, kamu harus melewatkan verifikasi TLS.</p><h3 id=pengklasteran-etcd>Pengklasteran etcd</h3><p>Untuk mengizinkan pengelompokkan etcd, porta yang diperlukan untuk berkomunikasi antara <em>instance</em> etcd akan dibuka (untuk komunikasi dalam klaster).
Untuk membuat penyebaran itu aman, komunikasi antara <em>instance</em> etcd diotorisasi menggunakan SSL.</p><h2 id=bacaan-tambahan>Bacaan tambahan</h2><p><a href=https://git.k8s.io/community/contributors/design-proposals/cluster-lifecycle/ha_master.md>Dokumen desain - Penyebaran master HA automatis</a></p></div><div class=td-content style=page-break-before:always><h1 id=pg-fe5ad73163d38596340536ec03a205f0>4.4.8 - Menggunakan sysctl dalam Sebuah Klaster Kubernetes</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.12 [beta]</code></div><p>Dokumen ini menjelaskan tentang cara mengonfigurasi dan menggunakan parameter kernel dalam sebuah
klaster Kubernetes dengan menggunakan antarmuka <a class=glossary-tooltip title='An interface for getting and setting Unix kernel parameters' data-toggle=tooltip data-placement=top href=/docs/tasks/administer-cluster/sysctl-cluster/ target=_blank aria-label=sysctl>sysctl</a>.</p><h2 id=sebelum-kamu-memulai>Sebelum kamu memulai</h2><p><p>Kamu harus memiliki klaster Kubernetes, dan perangkat baris perintah kubectl
juga harus dikonfigurasikan untuk berkomunikasi dengan klastermu. Jika kamu
belum memiliki klaster, kamu dapat membuatnya dengan menggunakan
<a href=/id/docs/tasks/tools/#minikube>minikube</a>,
atau kamu juga dapat menggunakan salah satu dari tempat mencoba Kubernetes berikut ini:</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>Bermain dengan Kubernetes</a></li></ul>Untuk melihat versi, tekan <code>kubectl version</code>.</p><h2 id=melihat-daftar-semua-parameter-sysctl>Melihat Daftar Semua Parameter Sysctl</h2><p>Dalam Linux, antarmuka sysctl memungkinkan administrator untuk memodifikasi kernel
parameter pada <em>runtime</em>. Parameter tersedia melalui sistem file virtual dari proses <code>/proc/sys/</code>.
Parameter mencakup berbagai subsistem seperti:</p><ul><li>kernel (dengan prefiks umum: <code>kernel.</code>)</li><li>networking (dengan prefiks umum: <code>net.</code>)</li><li>virtual memory (dengan prefiks umum: <code>vm.</code>)</li><li>MDADM (dengan prefiks umum: <code>dev.</code>)</li><li>subsistem yang lainnya dideskripsikan pada <a href=https://www.kernel.org/doc/Documentation/sysctl/README>dokumentasi Kernel</a>.</li></ul><p>Untuk mendapatkan daftar semua parameter, kamu bisa menjalankan perintah:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sudo sysctl -a
</span></span></code></pre></div><h2 id=mengaktifkan-sysctl-unsafe>Mengaktifkan Sysctl <em>Unsafe</em></h2><p>Sysctl dikelompokkan menjadi sysctl <em>safe</em> dan sysctl <em>unsafe</em>. Sebagai tambahan untuk
pengaturan <em>Namespace</em> yang benar, sebuah sysctl <em>safe</em> harus diisolasikan dengan benar diantara Pod dalam Node yang sama.
Hal ini berarti mengatur sysctl <em>safe</em> dalam satu Pod:</p><ul><li>tidak boleh mempengaruhi Pod lain dalam Node</li><li>tidak boleh membahayakan kesehatan dari Node</li><li>tidak mengizinkan untuk mendapatkan sumber daya CPU atau memori di luar batas sumber daya dari sebuah Pod.</li></ul><p>Sejauh ini, sebagian besar sysctl yang diatur sebagai Namespace belum tentu dianggap sysctl <em>safe</em>.
Sysctl berikut ini didukung dalam kelompok <em>safe</em>:</p><ul><li><code>kernel.shm_rmid_forced</code>,</li><li><code>net.ipv4.ip_local_port_range</code>,</li><li><code>net.ipv4.tcp_syncookies</code>,</li><li><code>net.ipv4.ping_group_range</code> (sejak Kubernetes 1.18),</li><li><code>net.ipv4.ip_unprivileged_port_start</code> (sejak Kubernetes 1.22).</li></ul><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong><p>Contoh <code>net.ipv4.tcp_syncookies</code> bukan merupakan Namespace pada kernel Linux versi 4.4 atau lebih rendah.</p><p>Daftar ini akan terus dikembangkan dalam versi Kubernetes berikutnya ketika kubelet
mendukung mekanisme isolasi yang lebih baik.</p><p>Semua sysctl <em>safe</em> diaktifkan secara bawaan.</p><p>Semua sysctl <em>unsafe</em> dinon-aktifkan secara bawaan dan harus diizinkan secara manual oleh
administrator klaster untuk setiap Node. Pod dengan sysctl <em>unsafe</em> yang dinon-aktifkan akan dijadwalkan,
tetapi akan gagal untuk dijalankan.</p><p>Dengan mengingat peringatan di atas, administrator klaster dapat mengizinkan sysctl <em>unsafe</em> tertentu
untuk situasi yang sangat spesial seperti pada saat kinerja tinggi atau
penyetelan aplikasi secara <em>real-time</em>. <em>Unsafe</em> syctl diaktifkan Node demi Node melalui
<em>flag</em> pada kubelet; sebagai contoh:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubelet --allowed-unsafe-sysctls <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  <span style=color:#b44>&#39;kernel.msg*,net.core.somaxconn&#39;</span> ...
</span></span></code></pre></div><p>Untuk <a class=glossary-tooltip title='A tool for running Kubernetes locally.' data-toggle=tooltip data-placement=top href=/docs/setup/learning-environment/minikube/ target=_blank aria-label=Minikube>Minikube</a>, ini dapat dilakukan melalui <em>flag</em> <code>extra-config</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>minikube start --extra-config<span style=color:#666>=</span><span style=color:#b44>&#34;kubelet.allowed-unsafe-sysctls=kernel.msg*,net.core.somaxconn&#34;</span>...
</span></span></code></pre></div><p>Hanya sysctl yang diatur sebagai Namespace dapat diaktifkan dengan cara ini.</p><h2 id=mnegatur-sysctl-untuk-pod>Mnegatur Sysctl untuk Pod</h2><p>Sejumlah sysctl adalah diatur sebagai Namespace dalam Kernel Linux hari ini. Ini berarti
mereka dapat diatur secara independen untuk setiap Pod dalam sebuah Node. Hanya sysctl dengan Namespace
yang dapat dikonfigurasi melalui Pod securityContext dalam Kubernetes.</p><p>Sysctl berikut dikenal sebagai Namespace. Daftar ini dapat berubah
pada versi kernel Linux yang akan datang.</p><ul><li><code>kernel.shm*</code>,</li><li><code>kernel.msg*</code>,</li><li><code>kernel.sem</code>,</li><li><code>fs.mqueue.*</code>,</li><li>Parameter dibawah <code>net.*</code> dapat diatur sebagai Namespace dari <em>container networking</em>
Namun, ada beberapa perkecualian (seperti
<code>net.netfilter.nf_conntrack_max</code> dan <code>net.netfilter.nf_conntrack_expect_max</code>
yang dapat diatur dalam Namespace <em>container networking</em> padahal bukan merupakan Namespace).</li></ul><p>Sysctl tanpa Namespace disebut dengan sysctl <em>node-level</em>. Jika kamu perlu mengatur
mereka, kamu harus secara manual mengonfigurasi mereka pada sistem operasi setiap Node, atau dengan
menggunakan DaemonSet melalui Container yang berwenang.</p><p>Gunakan securityContext dari Pod untuk mengonfigurasi sysctl Namespace. securityContext
berlaku untuk semua Container dalam Pod yang sama.</p><p>Contoh ini menggunakan securityContext dari Pod untuk mengatur sebuah sysctl <em>safe</em>
<code>kernel.shm_rmid_forced</code>, dan dua buah sysctl <em>unsafe</em> <code>net.core.somaxconn</code> dan
<code>kernel.msgmax</code>. Tidak ada perbedaan antara sysctl <em>safe</em> dan sysctl <em>unsafe</em> dalam
spesifikasi tersebut.</p><div class="alert alert-danger warning callout" role=alert><strong>Peringatan:</strong> Hanya modifikasi parameter sysctl setelah kamu memahami efeknya, untuk menghindari
gangguan pada kestabilan sistem operasi kamu.</div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>sysctl-example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>sysctls</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>kernel.shm_rmid_forced<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;0&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>net.core.somaxconn<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1024&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>kernel.msgmax<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;65536&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-danger warning callout" role=alert><strong>Peringatan:</strong> Karena sifat alami dari sysctl <em>unsafe</em>, penggunaan sysctl <em>unsafe</em>
merupakan resiko kamu sendiri dan dapat menyebabkan masalah parah seperti perilaku yang salah
pada Container, kekurangan sumber daya, atau kerusakan total dari Node.</div><p>Merupakan sebuah praktik yang baik untuk mempertimbangkan Node dengan pengaturan sysctl khusus sebagai
Node yang tercemar (<em>tainted</em>) dalam sebuah cluster, dan hanya menjadwalkan Pod yang membutuhkan pengaturan sysctl.
Sangat disarankan untuk menggunakan Kubernetes <a href=/docs/reference/generated/kubectl/kubectl-commands/#taint>fitur <em>taints and toleration</em></a> untuk mengimplementasikannya.</p><p>Pod dengan sysctl <em>unsafe</em> akan gagal diluncurkan pada sembarang Node yang belum
mengaktifkan kedua sysctl <em>unsafe</em> secara eksplisit. Seperti halnya sysctl <em>node-level</em> sangat
disarankan untuk menggunakan <a href=/docs/reference/generated/kubectl/kubectl-commands/#taint>fitur <em>taints and toleration</em></a> atau
<a href=/id/docs/concepts/scheduling-eviction/taint-and-toleration/>pencemaran dalam Node</a>
untuk Pod dalam Node yang tepat.</p><h2 id=podsecuritypolicy>PodSecurityPolicy</h2><p>Kamu selanjutnya dapat mengontrol sysctl mana saja yang dapat diatur dalam Pod dengan menentukan daftar
sysctl atau pola (<em>pattern</em>) sysctl dalam <code>forbiddenSysctls</code> dan/atau <em>field</em>
<code>allowedUnsafeSysctls</code> dari PodSecurityPolicy. Pola sysctl diakhiri
dengan karakter <code>*</code>, seperti <code>kernel.*</code>. Karakter <code>*</code> saja akan mencakup
semua sysctl.</p><p>Secara bawaan, semua sysctl <em>safe</em> diizinkan.</p><p>Kedua <code>forbiddenSysctls</code> dan <code>allowedUnsafeSysctls</code> merupakan daftar dari nama sysctl
atau pola sysctl yang polos (yang diakhiri dengan karakter <code>*</code>). Karakter <code>*</code> saja berarti sesuai dengan semua sysctl.</p><p><em>Field</em> <code>forbiddenSysctls</code> tidak memasukkan sysctl tertentu. Kamu dapat melarang
kombinasi sysctl <em>safe</em> dan sysctl <em>unsafe</em> dalam daftar tersebut. Untuk melarang pengaturan
sysctl, hanya gunakan <code>*</code> saja.</p><p>Jika kamu menyebutkan sysctl <em>unsafe</em> pada <em>field</em> <code>allowedUnsafeSysctls</code> dan
tidak ada pada <em>field</em> <code>forbiddenSysctls</code>, maka sysctl dapat digunakan pada Pod
dengan menggunakan PodSecurityPolicy ini. Untuk mengizinkan semua sysctl <em>unsafe</em> diatur dalam
PodSecurityPolicy, gunakan karakter <code>*</code> saja.</p><p>Jangan mengonfigurasi kedua <em>field</em> ini sampai tumpang tindih, dimana
sysctl yang diberikan akan diperbolehkan dan dilarang sekaligus.</p><div class="alert alert-danger warning callout" role=alert><strong>Peringatan:</strong> Jika kamu mengizinkan sysctl <em>unsafe</em> melalui <em>field</em> <code>allowUnsafeSysctls</code>
pada PodSecurityPolicy, Pod apa pun yang menggunakan sysctl seperti itu akan gagal dimulai
jika sysctl <em>unsafe</em> tidak diperbolehkan dalam <em>flag</em> kubelet <code>--allowed-unsafe-sysctls</code>
pada Node tersebut.</div><p>Ini merupakan contoh sysctl <em>unsafe</em> yang diawali dengan <code>kernel.msg</code> yang diperbolehkan dan
sysctl <code>kernel.shm_rmid_forced</code> yang dilarang.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>policy/v1beta1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PodSecurityPolicy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>sysctl-psp<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>allowedUnsafeSysctls</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- kernel.msg*<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>forbiddenSysctls</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- kernel.shm_rmid_forced<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span>...<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><div class=td-content style=page-break-before:always><h1 id=pg-c4d0832845adc92b7ccd54aed63fc932>4.4.9 - Mengoperasikan klaster etcd untuk Kubernetes</h1><p><p>etcd adalah penyimpanan <i>key value</i> konsisten yang digunakan sebagai penyimpanan data klaster Kubernetes.</p></p><p>Selalu perhatikan mekanisme untuk mem-<i>backup</i> data etcd pada klaster Kubernetes kamu. Untuk informasi lebih lanjut tentang etcd, lihat <a href=https://etcd.io/docs>dokumentasi etcd</a>.</p><h2 id=sebelum-kamu-memulai>Sebelum kamu memulai</h2><p><p>Kamu harus memiliki klaster Kubernetes, dan perangkat baris perintah kubectl
juga harus dikonfigurasikan untuk berkomunikasi dengan klastermu. Jika kamu
belum memiliki klaster, kamu dapat membuatnya dengan menggunakan
<a href=/id/docs/tasks/tools/#minikube>minikube</a>,
atau kamu juga dapat menggunakan salah satu dari tempat mencoba Kubernetes berikut ini:</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>Bermain dengan Kubernetes</a></li></ul>Untuk melihat versi, tekan <code>kubectl version</code>.</p><h2 id=prerequisites>Prerequisites</h2><ul><li><p>Jalankan etcd sebagai klaster dimana anggotanya berjumlah ganjil.</p></li><li><p>Etcd adalah sistem terdistribusi berbasis <em>leader</em>. Pastikan <em>leader</em> secara berkala mengirimkan <em>heartbeat</em> dengan tepat waktu ke semua pengikutnya untuk menjaga kestabilan klaster.</p></li><li><p>Pastikan tidak terjadi kekurangan sumber daya.</p><p>Kinerja dan stabilitas dari klaster sensitif terhadap jaringan dan <em>IO disk</em>. Kekurangan sumber daya apa pun dapat menyebabkan <em>timeout</em> dari <em>heartbeat</em>, yang menyebabkan ketidakstabilan klaster. Etcd yang tidak stabil mengindikasikan bahwa tidak ada <em>leader</em> yang terpilih. Dalam keadaan seperti itu, sebuah klaster tidak dapat membuat perubahan apa pun ke kondisi saat ini, yang menyebabkan tidak ada Pod baru yang dapat dijadwalkan.</p></li><li><p>Menjaga kestabilan klaster etcd sangat penting untuk stabilitas klaster Kubernetes. Karenanya, jalankan klaster etcd pada mesin khusus atau lingkungan terisolasi untuk <a href=https://github.com/coreos/etcd/blob/master/Documentation/op-guide/hardware.md#hardware-recommendations>persyaratan sumber daya terjamin</a>.</p></li><li><p>Versi minimum yang disarankan untuk etcd yang dijalankan dalam lingkungan produksi adalah <code>3.2.10+</code>.</p></li></ul><h2 id=persyaratan-sumber-daya>Persyaratan sumber daya</h2><p>Mengoperasikan etcd dengan sumber daya terbatas hanya cocok untuk tujuan pengujian. Untuk peluncuran dalam lingkungan produksi, diperlukan konfigurasi perangkat keras lanjutan. Sebelum meluncurkan etcd dalam produksi, lihat <a href=https://github.com/coreos/etcd/blob/master/Documentation/op-guide/hardware.md#example-hardware-configurations>dokumentasi referensi persyaratan sumber daya</a>.</p><h2 id=memulai-klaster-etcd>Memulai Klaster etcd</h2><p>Bagian ini mencakup bagaimana memulai klaster etcd dalam Node tunggal dan Node multipel.</p><h3 id=klaster-etcd-dalam-node-tunggal>Klaster etcd dalam Node tunggal</h3><p>Gunakan Klaster etcd Node tunggal hanya untuk tujuan pengujian</p><ol><li><p>Jalankan perintah berikut ini:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>./etcd --listen-client-urls<span style=color:#666>=</span>http://<span style=color:#b8860b>$PRIVATE_IP</span>:2379 --advertise-client-urls<span style=color:#666>=</span>http://<span style=color:#b8860b>$PRIVATE_IP</span>:2379
</span></span></code></pre></div></li><li><p>Start server API Kubernetes dengan <em>flag</em> <code>--etcd-servers=$PRIVATE_IP:2379</code>.</p><p>Ganti <code>PRIVATE_IP</code> dengan IP klien etcd kamu.</p></li></ol><h3 id=klaster-etcd-dengan-node-multipel>Klaster etcd dengan Node multipel</h3><p>Untuk daya tahan dan ketersediaan tinggi, jalankan etcd sebagai klaster dengan Node multipel dalam lingkungan produksi dan cadangkan secara berkala. Sebuah klaster dengan lima anggota direkomendasikan dalam lingkungan produksi. Untuk informasi lebih lanjut, lihat <a href=https://github.com/coreos/etcd/blob/master/Documentation/faq.md#what-is-failure-tolerance>Dokumentasi FAQ</a>.</p><p>Mengkonfigurasi klaster etcd baik dengan informasi anggota statis atau dengan penemuan dinamis. Untuk informasi lebih lanjut tentang pengklasteran, lihat <a href=https://github.com/coreos/etcd/blob/master/Documentation/op-guide/clustering.md>Dokumentasi pengklasteran etcd</a>.</p><p>Sebagai contoh, tinjau sebuah klaster etcd dengan lima anggota yang berjalan dengan URL klien berikut: <code>http://$IP1:2379</code>, <code>http://$IP2:2379</code>, <code>http://$IP3:2379</code>, <code>http://$IP4:2379</code>, dan <code>http://$IP5:2379</code>. Untuk memulai server API Kubernetes:</p><ol><li><p>Jalankan perintah berikut ini:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>./etcd --listen-client-urls<span style=color:#666>=</span>http://<span style=color:#b8860b>$IP1</span>:2379, http://<span style=color:#b8860b>$IP2</span>:2379, http://<span style=color:#b8860b>$IP3</span>:2379, http://<span style=color:#b8860b>$IP4</span>:2379, http://<span style=color:#b8860b>$IP5</span>:2379 --advertise-client-urls<span style=color:#666>=</span>http://<span style=color:#b8860b>$IP1</span>:2379, http://<span style=color:#b8860b>$IP2</span>:2379, http://<span style=color:#b8860b>$IP3</span>:2379, http://<span style=color:#b8860b>$IP4</span>:2379, http://<span style=color:#b8860b>$IP5</span>:2379
</span></span></code></pre></div></li><li><p>Start server Kubernetes API dengan flag <code>--etcd-servers=$IP1:2379, $IP2:2379, $IP3:2379, $IP4:2379, $IP5:2379</code>.</p><p>Ganti <code>IP</code> dengan alamat IP klien kamu.</p></li></ol><h3 id=klaster-etcd-dengan-node-multipel-dengan-load-balancer>Klaster etcd dengan Node multipel dengan load balancer</h3><p>Untuk menjalankan penyeimbangan beban (<em>load balancing</em>) untuk klaster etcd:</p><ol><li>Siapkan sebuah klaster etcd.</li><li>Konfigurasikan sebuah <em>load balancer</em> di depan klaster etcd.
Sebagai contoh, anggap saja alamat <em>load balancer</em> adalah <code>$LB</code>.</li><li>Mulai Server API Kubernetes dengan <em>flag</em> <code>--etcd-servers=$LB:2379</code>.</li></ol><h2 id=mengamankan-klaster-etcd>Mengamankan klaster etcd</h2><p>Akses ke etcd setara dengan izin root pada klaster sehingga idealnya hanya server API yang memiliki akses ke etcd. Dengan pertimbangan sensitivitas data, disarankan untuk memberikan izin hanya kepada Node-Node yang membutuhkan akses ke klaster etcd.</p><p>Untuk mengamankan etcd, tetapkan aturan <em>firewall</em> atau gunakan fitur keamanan yang disediakan oleh etcd. Fitur keamanan etcd tergantung pada Infrastruktur Kunci Publik / <em>Public Key Infrastructure</em> (PKI) x509. Untuk memulai, buat saluran komunikasi yang aman dengan menghasilkan pasangan kunci dan sertifikat. Sebagai contoh, gunakan pasangan kunci <code>peer.key</code> dan <code>peer.cert</code> untuk mengamankan komunikasi antara anggota etcd, dan <code>client.key</code> dan <code>client.cert</code> untuk mengamankan komunikasi antara etcd dan kliennya. Lihat <a href=https://github.com/coreos/etcd/tree/master/hack/tls-setup>contoh skrip</a> yang disediakan oleh proyek etcd untuk menghasilkan pasangan kunci dan berkas CA untuk otentikasi klien.</p><h3 id=mengamankan-komunikasi>Mengamankan komunikasi</h3><p>Untuk mengonfigurasi etcd dengan <em>secure peer communication</em>, tentukan <em>flag</em> <code>--peer-key-file=peer.key</code> dan <code>--peer-cert-file=peer.cert</code>, dan gunakan https sebagai skema URL.</p><p>Demikian pula, untuk mengonfigurasi etcd dengan <em>secure client communication</em>, tentukan <em>flag</em> <code>--key-file=k8sclient.key</code> dan <code>--cert-file=k8sclient.cert</code>, dan gunakan https sebagai skema URL.</p><h3 id=membatasi-akses-klaster-etcd>Membatasi akses klaster etcd</h3><p>Setelah konfigurasi komunikasi aman, batasi akses klaster etcd hanya ke server API Kubernetes. Gunakan otentikasi TLS untuk melakukannya.</p><p>Sebagai contoh, anggap pasangan kunci <code>k8sclient.key</code> dan <code>k8sclient.cert</code> dipercaya oleh CA <code>etcd.ca</code>. Ketika etcd dikonfigurasi dengan <code>--client-cert-auth</code> bersama dengan TLS, etcd memverifikasi sertifikat dari klien dengan menggunakan CA dari sistem atau CA yang dilewati oleh <em>flag</em> <code>--trusted-ca-file</code>. Menentukan <em>flag</em> <code>--client-cert-auth=true</code> dan <code>--trusted-ca-file=etcd.ca</code> akan membatasi akses kepada klien yang mempunyai sertifikat <code>k8sclient.cert</code>.</p><p>Setelah etcd dikonfigurasi dengan benar, hanya klien dengan sertifikat yang valid dapat mengaksesnya. Untuk memberikan akses kepada server Kubernetes API, konfigurasikan dengan <em>flag</em> <code>--etcd-certfile=k8sclient.cert</code>,<code>--etcd-keyfile=k8sclient.key</code> dan <code>--etcd-cafile=ca.cert</code>.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Otentikasi etcd saat ini tidak didukung oleh Kubernetes. Untuk informasi lebih lanjut, lihat masalah terkait <a href=https://github.com/kubernetes/kubernetes/issues/23398>Mendukung Auth Dasar untuk Etcd v2</a>.</div><h2 id=mengganti-anggota-etcd-yang-gagal>Mengganti anggota etcd yang gagal</h2><p>Etcd klaster mencapai ketersediaan tinggi dengan mentolerir kegagalan dari sebagian kecil anggota. Namun, untuk meningkatkan kesehatan keseluruhan dari klaster, segera ganti anggota yang gagal. Ketika banyak anggota yang gagal, gantilah satu per satu. Mengganti anggota yang gagal melibatkan dua langkah: menghapus anggota yang gagal dan menambahkan anggota baru.</p><p>Meskipun etcd menyimpan ID anggota unik secara internal, disarankan untuk menggunakan nama unik untuk setiap anggota untuk menghindari kesalahan manusia. Sebagai contoh, sebuah klaster etcd dengan tiga anggota. Jadikan URL-nya, member1=http://10.0.0.1, member2=http://10.0.0.2, and member3=http://10.0.0.3. Ketika member1 gagal, ganti dengan member4=http://10.0.0.4.</p><ol><li><p>Dapatkan ID anggota yang gagal dari member1:</p><p><code>etcdctl --endpoints=http://10.0.0.2,http://10.0.0.3 member list</code></p><p>Akan tampil pesan berikut:</p><pre><code> 8211f1d0f64f3269, started, member1, http://10.0.0.1:2380, http://10.0.0.1:2379
 91bc3c398fb3c146, started, member2, http://10.0.0.2:2380, http://10.0.0.2:2379
 fd422379fda50e48, started, member3, http://10.0.0.3:2380, http://10.0.0.3:2379
</code></pre></li><li><p>Hapus anggota yang gagal:</p><p><code>etcdctl member remove 8211f1d0f64f3269</code></p><p>Akan tampil pesan berikut:</p><pre><code>Removed member 8211f1d0f64f3269 from cluster
</code></pre></li><li><p>Tambahkan anggota baru:</p><p><code>./etcdctl member add member4 --peer-urls=http://10.0.0.4:2380</code></p><p>Akan tampil pesan berikut:</p><pre><code>Member 2be1eb8f84b7f63e added to cluster ef37ad9dc622a7c4
</code></pre></li><li><p>Jalankan anggota yang baru ditambahkan pada mesin dengan IP <code>10.0.0.4</code>:</p><pre><code> export ETCD_NAME=&quot;member4&quot;
 export ETCD_INITIAL_CLUSTER=&quot;member2=http://10.0.0.2:2380,member3=http://10.0.0.3:2380,member4=http://10.0.0.4:2380&quot;
 export ETCD_INITIAL_CLUSTER_STATE=existing
 etcd [flags]
</code></pre></li><li><p>Lakukan salah satu dari yang berikut:</p><ol><li>Perbarui <em>flag</em> <code>--etcd-server</code> untuk membuat Kubernetes mengetahui perubahan konfigurasi, lalu start ulang server API Kubernetes.</li><li>Perbarui konfigurasi <em>load balancer</em> jika <em>load balancer</em> digunakan dalam Deployment.</li></ol></li></ol><p>Untuk informasi lebih lanjut tentang konfigurasi ulang klaster, lihat <a href=https://github.com/coreos/etcd/blob/master/Documentation/op-guide/runtime-configuration.md#remove-a-member>Dokumentasi Konfigurasi etcd</a>.</p><h2 id=mencadangkan-klaster-etcd>Mencadangkan klaster etcd</h2><p>Semua objek Kubernetes disimpan dalam etcd. Mencadangkan secara berkala data klaster etcd penting untuk memulihkan klaster Kubernetes di bawah skenario bencana, seperti kehilangan semua Node <em>control plane</em>. Berkas <em>snapshot</em> berisi semua status Kubernetes dan informasi penting. Untuk menjaga data Kubernetes yang sensitif aman, enkripsi berkas <em>snapshot</em>.</p><p>Mencadangkan klaster etcd dapat dilakukan dengan dua cara: <em>snapshot</em> etcd bawaan dan <em>snapshot</em> volume.</p><h3 id=snapshot-bawaan>Snapshot bawaan</h3><p>Fitur <em>snapshot</em> didukung oleh etcd secara bawaan, jadi mencadangkan klaster etcd lebih mudah. <em>Snapshot</em> dapat diambil dari anggota langsung dengan command <code>etcdctl snapshot save</code> atau dengan menyalin <code>member/snap/db</code> berkas dari etcd <a href=https://github.com/coreos/etcd/blob/master/Documentation/op-guide/configuration.md#--data-dir>direktori data</a> yang saat ini tidak digunakan oleh proses etcd. Mengambil <em>snapshot</em> biasanya tidak akan mempengaruhi kinerja anggota.</p><p>Di bawah ini adalah contoh untuk mengambil <em>snapshot</em> dari <em>keyspace</em> yang dilayani oleh <code>$ENDPOINT</code> ke berkas <code>snapshotdb</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#b8860b>ETCDCTL_API</span><span style=color:#666>=</span><span style=color:#666>3</span> etcdctl --endpoints <span style=color:#b8860b>$ENDPOINT</span> snapshot save snapshotdb
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># keluar 0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># memverifikasi hasil snapshot</span>
</span></span><span style=display:flex><span><span style=color:#b8860b>ETCDCTL_API</span><span style=color:#666>=</span><span style=color:#666>3</span> etcdctl --write-out<span style=color:#666>=</span>table snapshot status snapshotdb
</span></span><span style=display:flex><span>+----------+----------+------------+------------+
</span></span><span style=display:flex><span>|   HASH   | REVISION | TOTAL KEYS | TOTAL SIZE |
</span></span><span style=display:flex><span>+----------+----------+------------+------------+
</span></span><span style=display:flex><span>| fe01cf57 |       <span style=color:#666>10</span> |          <span style=color:#666>7</span> | 2.1 MB     |
</span></span><span style=display:flex><span>+----------+----------+------------+------------+
</span></span></code></pre></div><h3 id=snapshot-volume>Snapshot volume</h3><p>Jika etcd berjalan pada volume penyimpanan yang mendukung cadangan, seperti Amazon Elastic Block Store, buat cadangan data etcd dengan mengambil <em>snapshot</em> dari volume penyimpanan.</p><h2 id=memperbesar-skala-dari-klaster-etcd>Memperbesar skala dari klaster etcd</h2><p>Peningkatan skala klaster etcd meningkatkan ketersediaan dengan menukarnya untuk kinerja. Penyekalaan tidak akan meningkatkan kinerja atau kemampuan klaster. Aturan umum adalah untuk tidak melakukan penyekalaan naik atau turun untuk klaster etcd. Jangan mengonfigurasi grup penyekalaan otomatis untuk klaster etcd. Sangat disarankan untuk selalu menjalankan klaster etcd statis dengan lima anggota untuk klaster produksi Kubernetes untuk setiap skala yang didukung secara resmi.</p><p>Penyekalaan yang wajar adalah untuk meningkatkan klaster dengan tiga anggota menjadi dengan lima anggota, ketika dibutuhkan lebih banyak keandalan. Lihat <a href=https://github.com/coreos/etcd/blob/master/Documentation/op-guide/runtime-configuration.md#remove-a-member>Dokumentasi Rekonfigurasi etcd</a> untuk informasi tentang cara menambahkan anggota ke klaster yang ada.</p><h2 id=memulihkan-klaster-etcd>Memulihkan klaster etcd</h2><p>Etcd mendukung pemulihan dari <em>snapshot</em> yang diambil dari proses etcd dari versi <a href=http://semver.org/>major.minor</a>. Memulihkan versi dari versi patch lain dari etcd juga didukung. Operasi pemulihan digunakan untuk memulihkan data klaster yang gagal.</p><p>Sebelum memulai operasi pemulihan, berkas <em>snapshot</em> harus ada. Ini bisa berupa berkas <em>snapshot</em> dari operasi pencadangan sebelumnya, atau dari sisa <a href=https://github.com/coreos/etcd/blob/master/Documentation/op-guide/configuration.md#--data-dir>direktori data</a>. Untuk informasi dan contoh lebih lanjut tentang memulihkan klaster dari berkas <em>snapshot</em>, lihat <a href=https://github.com/coreos/etcd/blob/master/Documentation/op-guide/recovery.md#restoring-a-cluster>dokumentasi pemulihan bencana etcd</a>.</p><p>Jika akses URL dari klaster yang dipulihkan berubah dari klaster sebelumnya, maka server API Kubernetes harus dikonfigurasi ulang sesuai dengan URL tersebut. Pada kasus ini, start kembali server API Kubernetes dengan <em>flag</em> <code>--etcd-servers=$NEW_ETCD_CLUSTER</code> bukan <em>flag</em> <code>--etcd-servers=$OLD_ETCD_CLUSTER</code>. Ganti <code>$NEW_ETCD_CLUSTER</code> dan <code>$OLD_ETCD_CLUSTER</code> dengan alamat IP masing-masing. Jika <em>load balancer</em> digunakan di depan klaster etcd, kamu mungkin hanya perlu memperbarui <em>load balancer</em> sebagai gantinya.</p><p>Jika mayoritas anggota etcd telah gagal secara permanen, klaster etcd dianggap gagal. Dalam skenario ini, Kubernetes tidak dapat membuat perubahan apa pun ke kondisi saat ini. Meskipun Pod terjadwal mungkin terus berjalan, tidak ada Pod baru yang bisa dijadwalkan. Dalam kasus seperti itu, pulihkan klaster etcd dan kemungkinan juga untuk mengonfigurasi ulang server API Kubernetes untuk memperbaiki masalah ini.</p><h2 id=memutakhirkan-dan-memutar-balikan-klaster-etcd>Memutakhirkan dan memutar balikan klaster etcd</h2><p>Pada Kubernetes v1.13.0, etcd2 tidak lagi didukung sebagai <em>backend</em> penyimpanan untuk klaster Kubernetes baru atau yang sudah ada. <em>Timeline</em> untuk dukungan Kubernetes untuk etcd2 dan etcd3 adalah sebagai berikut:</p><ul><li>Kubernetes v1.0: hanya etcd2</li><li>Kubernetes v1.5.1: dukungan etcd3 ditambahkan, standar klaster baru yang dibuat masih ke etcd2</li><li>Kubernetes v1.6.0: standar klaster baru yang dibuat dengan <code>kube-up.sh</code> adalah etcd3,
dan <code>kube-apiserver</code> standarnya ke etcd3</li><li>Kubernetes v1.9.0: pengumuman penghentian <em>backend</em> penyimpanan etcd2 diumumkan</li><li>Kubernetes v1.13.0: <em>backend</em> penyimpanan etcd2 dihapus, <code>kube-apiserver</code> akan
menolak untuk start dengan <code>--storage-backend=etcd2</code>, dengan pesan
<code>etcd2 is no longer a supported storage backend</code></li></ul><p>Sebelum memutakhirkan v1.12.x kube-apiserver menggunakan <code>--storage-backend=etcd2</code> ke
v1.13.x, data etcd v2 harus dimigrasikan ke <em>backend</em> penyimpanan v3 dan
permintaan kube-apiserver harus diubah untuk menggunakan <code>--storage-backend=etcd3</code>.</p><p>Proses untuk bermigrasi dari etcd2 ke etcd3 sangat tergantung pada bagaimana
klaster etcd diluncurkan dan dikonfigurasi, serta bagaimana klaster Kubernetes diluncurkan dan dikonfigurasi. Kami menyarankan kamu berkonsultasi dengan dokumentasi penyedia kluster kamu untuk melihat apakah ada solusi yang telah ditentukan.</p><p>Jika klaster kamu dibuat melalui <code>kube-up.sh</code> dan masih menggunakan etcd2 sebagai penyimpanan <em>backend</em>, silakan baca <a href=https://v1-12.docs.kubernetes.io/docs/tasks/administer-cluster/configure-upgrade-etcd/#upgrading-and-rolling-back-etcd-clusters>Kubernetes v1.12 etcd cluster upgrade docs</a></p><h2 id=masalah-umum-penyeimbang-klien-etcd-dengan-secure-endpoint>Masalah umum: penyeimbang klien etcd dengan <em>secure endpoint</em></h2><p>Klien etcd v3, dirilis pada etcd v3.3.13 atau sebelumnya, memiliki <a href=https://github.com/kubernetes/kubernetes/issues/72102><em>critical bug</em></a> yang mempengaruhi kube-apiserver dan penyebaran HA. Pemindahan kegagalan (<em>failover</em>) penyeimbang klien etcd tidak bekerja dengan baik dengan <em>secure endpoint</em>. Sebagai hasilnya, server etcd boleh gagal atau terputus sesaat dari kube-apiserver. Hal ini mempengaruhi peluncuran HA dari kube-apiserver.</p><p>Perbaikan dibuat di <a href=https://github.com/etcd-io/etcd/pull/10911>etcd v3.4</a> (dan di-backport ke v3.3.14 atau yang lebih baru): klien baru sekarang membuat bundel kredensial sendiri untuk menetapkan target otoritas dengan benar dalam fungsi dial.</p><p>Karena perbaikan tersebut memerlukan pemutakhiran dependensi dari gRPC (ke v1.23.0), <em>downstream</em> Kubernetes <a href=https://github.com/kubernetes/kubernetes/issues/72102#issuecomment-526645978>tidak mendukung upgrade etcd</a>, yang berarti <a href=https://github.com/etcd-io/etcd/pull/10911/commits/db61ee106ca9363ba3f188ecf27d1a8843da33ab>perbaikan etcd di kube-apiserver</a> hanya tersedia mulai Kubernetes 1.16.</p><p>Untuk segera memperbaiki celah keamanan (<em>bug</em>) ini untuk Kubernetes 1.15 atau sebelumnya, buat kube-apiserver khusus. kamu dapat membuat perubahan lokal ke <a href=https://github.com/kubernetes/kubernetes/blob/7b85be021cd2943167cd3d6b7020f44735d9d90b/vendor/google.golang.org/grpc/credentials/credentials.go#L135><code>vendor/google.golang.org/grpc/credentials/credentials.go</code></a> dengan <a href=https://github.com/etcd-io/etcd/pull/10911/commits/db61ee106ca9363ba3f188ecf27d1a8843da33ab>etcd@db61ee106</a>.</p><p>Lihat <a href=https://github.com/kubernetes/kubernetes/issues/72102>"kube-apiserver 1.13.x menolak untuk bekerja ketika server etcd pertama tidak tersedia"</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-aa0731e8aa8e2f6cc9e3c1a5e9895863>4.5 - Mengelola Objek Kubernetes</h1><div class=lead>Paradigma deklaratif dan imperatif untuk berinteraksi dengan API Kubernetes.</div></div><div class=td-content><h1 id=pg-df206392be6f4d19bd8da41cee7170fa>4.5.1 - Pengelolaan Objek Kubernetes secara Deklaratif dengan Menggunakan Berkas Konfigurasi</h1><p>Objek-objek Kubernetes dapat dibuat, diperbarui, dan dihapus dengan menjalankan perintah <code>kubectl apply</code> terhadap file-file konfigurasi objek yang disimpan dalam sebuah direktori secara rekursif sesuai dengan kebutuhan. Perintah <code>kubectl diff</code> bisa digunakan untuk menampilkan pratinjau tentang perubahan apa saja yang akan dibuat oleh perintah <code>kubectil apply</code>.</p><h2 id=kelebihan-dan-kekurangan>Kelebihan dan kekurangan</h2><p>Perintah <code>kubectl</code> memungkinkan tiga cara untuk mengelola objek:</p><ul><li>Perintah imperatif</li><li>Konfigurasi objek imperatif</li><li>Konfigurasi objek deklaratif</li></ul><p>Lihat <a href=/id/docs/concepts/overview/working-with-objects/object-management/>Pengelolaan Objek Kubernetes</a> untuk menyimak diskusi mengenai kelebihan dan kekurangan dari tiap cara pengelolaan objek.</p><h2 id=sebelum-kamu-mulai>Sebelum kamu mulai</h2><p>Konfigurasi objek secara deklaratif membutuhkan pemahaman yang baik
tentang definisi dan konfigurasi objek-objek Kubernetes. Jika belum pernah, kamu disarankan untuk membaca terlebih dulu dokumen-dokumen berikut:</p><ul><li><a href=/id/docs/tasks/manage-kubernetes-objects/imperative-command/>Pengelolaan Objek Kubernetes Menggunakan Perintah Imperatif</a></li><li><a href=/id/docs/tasks/manage-kubernetes-objects/imperative-config/>Pengelolaan Objek Kubernetes Menggunakan Berkas Konfigurasi Imperatif</a></li></ul><p>Berikut adalah beberapa defnisi dari istilah-istilah yang digunakan
dalam dokumen ini:</p><ul><li><em>objek berkas konfigurasi / berkas konfigurasi</em>: Sebuah <em>file</em> yang
mendefinisikan konfigurasi untuk sebuah objek Kubernetes. Dokumen ini akan memperlihatkan cara menggunakan <em>file</em> konfigurasi dengan perintah <code>kubectl apply</code>. <em>File-file</em> konfigurasi biasanya disimpan di sebuah <em>source control</em> seperti Git.</li><li><em>konfigurasi objek live / konfigurasi live</em>: nilai konfigurasi <em>live</em> dari sebuah objek, sebagaimana yang tersimpan di klaster Kubernetes. Nilai-nilai ini disimpan di <em>storage</em> klaster Kubernetes, biasanya etcd.</li><li><em>writer konfigurasi deklaratif / writer deklaratif</em>: Seseorang atau sebuah komponen perangkat lunak yang membuat pembaruan ke objek <em>live</em>. <em>Live writer</em> yang disebut pada dokumen ini adalah <em>writer</em> yang membuat perubahan terhadap <em>file</em> konfigurasi objek dan menjalankan perintah <code>kubectl apply</code> untuk menulis perubahan-perubahan tersebut.</li></ul><h2 id=cara-membuat-objek>Cara membuat objek</h2><p>Gunakan perintah <code>kubectl apply</code> untuk membuat semua objek, kecuali objek-objek yang sudah ada sebelumnya, yang didefinisikan di <em>file-file</em> konfigurasi dalam direktori yang ditentukan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f &lt;directory&gt;/
</span></span></code></pre></div><p>Perintah di atas akan memberi anotasi <code>kubectl.kubernetes.io/last-applied-configuration: '{...}'</code> pada setiap objek yang dibuat. Anotasi ini berisi konten dari <em>file</em> konfigurasi objek yang digunakan untuk membuat objek tersebut.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Tambahkan parameter <code>-R</code> untuk memproses seluruh direktori secara rekursif.</div><p>Berikut sebuah contoh <em>file</em> konfigurasi objek:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/application/simple_deployment.yaml download=application/simple_deployment.yaml><code>application/simple_deployment.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("application-simple-deployment-yaml")' title="Copy application/simple_deployment.yaml to clipboard"></img></div><div class=includecode id=application-simple-deployment-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>minReadySeconds</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.7.9<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Jalankan perintah <code>kubectl diff</code> untuk menampilkan objek yang akan dibuat:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl diff -f https://k8s.io/examples/application/simple_deployment.yaml
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Perintah <code>diff</code> menggunakan <a href=/docs/reference/using-api/api-concepts/#dry-run><em>server-side dry-run</em></a>, yang perlu diaktifkan di <code>kube-apiserver</code>.</div><p>Buat objek dengan perintah <code>kubectl apply</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/application/simple_deployment.yaml
</span></span></code></pre></div><p>Tampilkan konfigurasi <em>live</em> dengan perintah <code>kubectl get</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get -f https://k8s.io/examples/application/simple_deployment.yaml -o yaml
</span></span></code></pre></div><p>Keluaran perintah di atas akan menunjukkan bahwa anotasi <code>kubectl.kubernetes.io/last-applied-configuration</code> sudah dituliskan ke konfigurasi <em>live</em>, dan anotasi tersebut sesuai dengan <em>file</em> konfigurasi:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># Ini merupakan representasi dari simple_deployment.yaml dalam format json</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># Ini ditulis oleh perintah `kubectl apply` ketika objek dibuat</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubectl.kubernetes.io/last-applied-configuration</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      {&#34;apiVersion&#34;:&#34;apps/v1&#34;,&#34;kind&#34;:&#34;Deployment&#34;,
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      &#34;metadata&#34;:{&#34;annotations&#34;:{},&#34;name&#34;:&#34;nginx-deployment&#34;,&#34;namespace&#34;:&#34;default&#34;},
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      &#34;spec&#34;:{&#34;minReadySeconds&#34;:5,&#34;selector&#34;:{&#34;matchLabels&#34;:{&#34;app&#34;:nginx}},&#34;template&#34;:{&#34;metadata&#34;:{&#34;labels&#34;:{&#34;app&#34;:&#34;nginx&#34;}},
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      &#34;spec&#34;:{&#34;containers&#34;:[{&#34;image&#34;:&#34;nginx:1.7.9&#34;,&#34;name&#34;:&#34;nginx&#34;,
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      &#34;ports&#34;:[{&#34;containerPort&#34;:80}]}]}}}}</span><span style=color:#bbb>      
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>minReadySeconds</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.7.9<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=cara-memperbarui-objek>Cara memperbarui objek</h2><p>Kamu juga bisa menggunakan <code>kubectl apply</code> untuk memperbarui semua objek yang didefinisikan dalam sebuah direktori, termasuk objek-objek yang sudah ada sebelumnya. Cara ini akan melakukan hal-hal berikut:</p><ol><li>Menyimpan nilai <em>field-field</em> yang ada di <em>file</em> konfigurasi ke konfigurasi <em>live</em>.</li><li>Menghapus <em>field-field</em> yang dihapus di <em>file</em> konfigurasi dari konfigurasi <em>live</em>.</li></ol><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl diff -f &lt;directory&gt;/
</span></span><span style=display:flex><span>kubectl apply -f &lt;directory&gt;/
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Tambahkan argumen <code>-R</code> untuk memproses seluruh direktori secara rekursif.</div><p>Berikut sebuah contoh <em>file</em> konfigurasi:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/application/simple_deployment.yaml download=application/simple_deployment.yaml><code>application/simple_deployment.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("application-simple-deployment-yaml")' title="Copy application/simple_deployment.yaml to clipboard"></img></div><div class=includecode id=application-simple-deployment-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>minReadySeconds</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.7.9<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Buat objek dengan perintah <code>kubectl apply</code>::</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/application/simple_deployment.yaml
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Untuk keperluan ilustrasi, perintah berikut merujuk ke satu <em>file</em> konfigurasi alih-alih ke satu direktori.</div><p>Tampilkan konfigurasi <em>live</em> dengan perintah <code>kubectl get</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get -f https://k8s.io/examples/application/simple_deployment.yaml -o yaml
</span></span></code></pre></div><p>Keluaran perintah di atas akan menunjukkan bahwa anotasi <code>kubectl.kubernetes.io/last-applied-configuration</code> sudah dituliskan ke konfigurasi <em>live</em>, dan anotasi tersebut sesuai dengan <em>file</em> konfigurasi:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># Berikut merupakan representasi dari simple_deployment.yaml dalam format json</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># Representasi berikut ditulis oleh perintah kubectl apply ketika objek dibuat</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubectl.kubernetes.io/last-applied-configuration</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      {&#34;apiVersion&#34;:&#34;apps/v1&#34;,&#34;kind&#34;:&#34;Deployment&#34;,
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      &#34;metadata&#34;:{&#34;annotations&#34;:{},&#34;name&#34;:&#34;nginx-deployment&#34;,&#34;namespace&#34;:&#34;default&#34;},
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      &#34;spec&#34;:{&#34;minReadySeconds&#34;:5,&#34;selector&#34;:{&#34;matchLabels&#34;:{&#34;app&#34;:nginx}},&#34;template&#34;:{&#34;metadata&#34;:{&#34;labels&#34;:{&#34;app&#34;:&#34;nginx&#34;}},
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      &#34;spec&#34;:{&#34;containers&#34;:[{&#34;image&#34;:&#34;nginx:1.7.9&#34;,&#34;name&#34;:&#34;nginx&#34;,
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      &#34;ports&#34;:[{&#34;containerPort&#34;:80}]}]}}}}</span><span style=color:#bbb>      
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>minReadySeconds</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.7.9<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Perbarui nilai <code>replicas</code> secara langsung di konfigurasi <code>live</code> dengan menggunakan perintah <code>kubectl scale</code>. Pembaruan ini tidak menggunakan perintah <code>kubectl apply</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl scale deployment/nginx-deployment --replicas<span style=color:#666>=</span><span style=color:#666>2</span>
</span></span></code></pre></div><p>Tampilkan konfigurasi <em>live</em> dengan perintah <code>kubectl get</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get -f https://k8s.io/examples/application/simple_deployment.yaml -o yaml
</span></span></code></pre></div><p>Keluaran perintah di atas akan menunjukkan bahwa nilai <code>replicas</code> telah diubah menjadi 2, dan anotasi <code>last-applied-configuration</code> tidak memuat nilai <code>replicas</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># perhatikan bahwa anotasi tidak memuat nilai replicas</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># karena nilai tersebut tidak diperbarui melalui perintah kubectl-apply</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubectl.kubernetes.io/last-applied-configuration</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      {&#34;apiVersion&#34;:&#34;apps/v1&#34;,&#34;kind&#34;:&#34;Deployment&#34;,
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      &#34;metadata&#34;:{&#34;annotations&#34;:{},&#34;name&#34;:&#34;nginx-deployment&#34;,&#34;namespace&#34;:&#34;default&#34;},
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      &#34;spec&#34;:{&#34;minReadySeconds&#34;:5,&#34;selector&#34;:{&#34;matchLabels&#34;:{&#34;app&#34;:nginx}},&#34;template&#34;:{&#34;metadata&#34;:{&#34;labels&#34;:{&#34;app&#34;:&#34;nginx&#34;}},
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      &#34;spec&#34;:{&#34;containers&#34;:[{&#34;image&#34;:&#34;nginx:1.7.9&#34;,&#34;name&#34;:&#34;nginx&#34;,
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      &#34;ports&#34;:[{&#34;containerPort&#34;:80}]}]}}}}</span><span style=color:#bbb>      
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># ditulis oleh perintah kubectl scale</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>minReadySeconds</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.7.9<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Perbarui <em>file</em> konfigurasi <code>simple_deployment.yaml</code>, ubah <em>image</em> dari <code>nginx:1.7.9</code> ke <code>nginx:1.11.9</code>, dan hapus <em>field</em> <code>minReadySeconds</code>:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/application/update_deployment.yaml download=application/update_deployment.yaml><code>application/update_deployment.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("application-update-deployment-yaml")' title="Copy application/update_deployment.yaml to clipboard"></img></div><div class=includecode id=application-update-deployment-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.11.9<span style=color:#bbb> </span><span style=color:#080;font-style:italic># perbarui image</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Terapkan perubahan yang telah dibuat di <em>file</em> konfigurasi:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl diff -f https://k8s.io/examples/application/update_deployment.yaml
</span></span><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/application/update_deployment.yaml
</span></span></code></pre></div><p>Tampilkan konfigurasi <em>live</em> dengan perintah <code>kubectl get</code>:</p><pre tabindex=0><code>kubectl get -f https://k8s.io/examples/application/simple_deployment.yaml -o yaml
</code></pre><p>Keluaran perintah di atas akan menunjukkan perubahan-perubahan berikut pada konfiguasi <em>live</em>:</p><ul><li><em>Field</em> <code>replicas</code> tetap bernilai 2 sesuai dengan nilai yang diatur oleh perintah <code>kubectl scale</code>. Hal ini karena <em>field</em> <code>replicas</code> dihapuskan dari <em>file</em> konfigurasi.</li><li>Nilai <em>field</em> <code>image</code> telah diperbarui menjadi <code>nginx:1.11.9</code> dari <code>nginx:1.7.9</code>.</li><li>Anotasi <code>last-applied-configuration</code> telah diperbari dengan <em>image</em> terbaru.</li><li><em>Field</em> <code>minReadySeconds</code> telah dihapus.</li><li>Anotasi <code>last-applied-configuration</code> tidak lagi memuat <em>field</em> <code>minReadySeconds</code>.</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># Anotasi memuat image yang telah diperbarui ke nginx 1.11.9,</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># tetapi tidak memuat nilai replica yang telah diperbarui menjadi 2</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubectl.kubernetes.io/last-applied-configuration</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      {&#34;apiVersion&#34;:&#34;apps/v1&#34;,&#34;kind&#34;:&#34;Deployment&#34;,
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      &#34;metadata&#34;:{&#34;annotations&#34;:{},&#34;name&#34;:&#34;nginx-deployment&#34;,&#34;namespace&#34;:&#34;default&#34;},
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      &#34;spec&#34;:{&#34;selector&#34;:{&#34;matchLabels&#34;:{&#34;app&#34;:nginx}},&#34;template&#34;:{&#34;metadata&#34;:{&#34;labels&#34;:{&#34;app&#34;:&#34;nginx&#34;}},
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      &#34;spec&#34;:{&#34;containers&#34;:[{&#34;image&#34;:&#34;nginx:1.11.9&#34;,&#34;name&#34;:&#34;nginx&#34;,
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      &#34;ports&#34;:[{&#34;containerPort&#34;:80}]}]}}}}</span><span style=color:#bbb>      
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># Diatur oleh `kubectl scale`, tidak diubah oleh `kubectl apply`.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># minReadySeconds dihapuskan oleh `kubectl apply`</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.11.9<span style=color:#bbb> </span><span style=color:#080;font-style:italic># Diatur oleh `kubectl apply`</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-danger warning callout" role=alert><strong>Peringatan:</strong> Mencampur perintah <code>kubectl apply</code> dengan perintah imperatif untuk konfigurasi objek seperti <code>create</code> dan <code>replace</code> tidak dimungkinkan. Hal ini karena <code>create</code> dan <code>replace</code> tidak menyimpan anotasi <code>kubectl.kubernetes.io/last-applied-configuration</code> yang diperlukan oleh <code>kubectl aplly</code> untuk melakukan pembaruan.</div><h2 id=cara-menghapus-objek>Cara menghapus objek</h2><p>Ada dua cara untuk menghapus objek-objek yang dikelola dengan <code>kubectl apply</code>.</p><h3 id=rekomendasi-kubectl-delete-f-filename>Rekomendasi: <code>kubectl delete -f &lt;filename></code></h3><p>Penghapusan objek secara manual dengan menggunakan perintah imperatif merupakan cara yang direkomendasikan karena lebih eksplisit dalam menentukan objek apa yang akan dihapus dan lebih kecil kemungkinannya untuk pengguna menghapus objek lain secara tidak sengaja:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete -f &lt;filename&gt;
</span></span></code></pre></div><h3 id=alternatif-kubectl-apply-f-directory-prune-l-your-label>Alternatif: <code>kubectl apply -f &lt;directory/> --prune -l your=label</code></h3><p>Lakukan ini hanya jika kamu benar-benar mengetahui apa yang kamu lakukan.</p><div class="alert alert-danger warning callout" role=alert><strong>Peringatan:</strong> Perintah <code>kubectl apply --prune</code> masih dalam versi alpha dan perubahan-perubahan yang tidak memiliki kompatibilitas dengan versi sebelumnya mungkin akan diperkenalkan pada rilis-rilis berikutnya.</div><div class="alert alert-danger warning callout" role=alert><strong>Peringatan:</strong> Kamu harus berhati-hati ketika menggunakan perintah ini agar kamu tidak menghapus objek-objek lain secara tak sengaja.</div><p>Sebagai alternatif dari <code>kubectl delete</code>, kamu bisa menggunakan <code>kubectl apply</code> untuk mengidentifikasi objek-objek yang hendak dihapus setelah berkas konfigurasi objek-objek tersebut dihapus dari direktori. Ketika dijalankan dengan argumen <code>--prune</code>, perintah <code>kubectl apply</code> akan melakukan <em>query</em> ke <em>API server</em> untuk mencari semua objek yang sesuai dengan himpunan label-label tertentu, dan berusaha untuk mencocokkan kofigurasi objek <em>live</em> yg diperoleh terhadap <em>file</em> konfigurasi objek. Jika sebuah objek cocok dengan <em>query</em> yang dilakukan, dan objek tersebut tidak memiliki <em>file</em> konfigurasi di direktori serta tidak memiliki anotasi <code>last-applied-configuration</code>, objek tersebut akan dihapus.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f &lt;directory/&gt; --prune -l &lt;labels&gt;
</span></span></code></pre></div><div class="alert alert-danger warning callout" role=alert><strong>Peringatan:</strong> Perintah <code>kubectl apply</code> dengan argumen <code>--prune</code> sebaiknya hanya dijalankan terhadap direktori <em>root</em> yang berisi <em>file-file</em> konfigurasi objek. Menjalankan perintah tadi terhadap sub direktori bisa menyebabkan terhapusnya objek-objek lain secara tidak disengaja jika objek-objek tersebut memenuhi kriteria selektor label yang dispesifikasikan oleh argumen <code>-l &lt;label></code> dan tidak muncul di sub direktori.</div><h2 id=cara-melihat-objek>Cara melihat objek</h2><p>Kamu bisa menggunakan perintah <code>kubectl get</code> dengan parameter <code>-o yaml</code> untuk melihat konfigurasi dari sebuah objek <em>live</em>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get -f &lt;filename|url&gt; -o yaml
</span></span></code></pre></div><h2 id=cara-kubectl-apply-menghitung-perbedaan-dan-menggabungkan-perubahan>Cara <code>kubectl apply</code> menghitung perbedaan dan menggabungkan perubahan</h2><div class="alert alert-warning caution callout" role=alert><strong>Perhatian:</strong> <em>Patch</em> adalah operasi pembaruan yang lingkupnya spesifik terhadap sejumlah <em>field</em> dari sebuah objek alih-alih terhadap keseluruhan objek. <em>Patch</em> memungkinkan pembaruan terhadap himpunan <em>field</em> yang spesifik tanpa harus membaca keseluruhan objek terlebih dulu.</div><p>Ketika memperbarui konfigurasi <em>live</em> dari sebuah objek, <code>kubectl apply</code> melakukannya dengan mengirimkan <em>request</em> untuk melakukan <em>patch</em> ke <em>API server</em>. <em>Patch</em> mendefinisikan pembaruan-pembaruan yang likungpnya sepsifik terhadap sejumlah <em>field</em> dari objek konfigurasi <em>live</em>. Perintah <code>kubectl apply</code> menghitung <em>patch request</em> ini menggunakan <em>file</em> konfigurasi, konfigurasi <em>live</em>, dan anotasi <code>last-applied-configuration</code> yang tersimpan di konfigurasi <em>live</em>.</p><h3 id=perhitungan-penggabungan-patch>Perhitungan penggabungan <em>patch</em></h3><p>Perintah <code>kubectl apply</code> menulis konten dari berkas konfigurasi ke anotasi <code>kubectl.kubernetes.io/last-applied-configuration</code>. Ini digunakan untuk mengidentifikasi <em>field</em> apa saja yang telah dihapus dari <em>file</em> konfigurasi dan perlu dihapus dari konfigurasi <em>live</em>. Berikut adalah langkah-langkah yang digunakan untuk menghitung <em>field</em> apa saja yang harus dihapus atau diubah:</p><ol><li>Hitung <em>field-field</em> yang perlu dihapus. Ini mencakup <em>field-field</em> yang ada di <code>last-applied-configuration</code> tapi tidak ada di <em>file</em> konfigurasi.</li><li>Hitung <em>field-field</em> yang perlu ditambah atau diubah. Ini mencakup <em>field-field</em> yang ada di <em>file</em> konfigurasi yang nilainya tidak sama dengan konfigurasi <em>live</em>.</li></ol><p>Agar lebih jelas, simak contoh berikut. Misalkan, berikut adalah <em>file</em> konfigurasi untuk sebuah objek Deployment:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/application/update_deployment.yaml download=application/update_deployment.yaml><code>application/update_deployment.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("application-update-deployment-yaml")' title="Copy application/update_deployment.yaml to clipboard"></img></div><div class=includecode id=application-update-deployment-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.11.9<span style=color:#bbb> </span><span style=color:#080;font-style:italic># perbarui image</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Juga, misalkan, berikut adalah konfigurasi <em>live</em> dari objek Deployment yang sama:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># perhatikan bagaimana anotasi berikut tidak memuat replicas</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># karena replicas tidak diperbarui melalui perintah kubectl apply</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubectl.kubernetes.io/last-applied-configuration</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      {&#34;apiVersion&#34;:&#34;apps/v1&#34;,&#34;kind&#34;:&#34;Deployment&#34;,
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      &#34;metadata&#34;:{&#34;annotations&#34;:{},&#34;name&#34;:&#34;nginx-deployment&#34;,&#34;namespace&#34;:&#34;default&#34;},
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      &#34;spec&#34;:{&#34;minReadySeconds&#34;:5,&#34;selector&#34;:{&#34;matchLabels&#34;:{&#34;app&#34;:nginx}},&#34;template&#34;:{&#34;metadata&#34;:{&#34;labels&#34;:{&#34;app&#34;:&#34;nginx&#34;}},
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      &#34;spec&#34;:{&#34;containers&#34;:[{&#34;image&#34;:&#34;nginx:1.7.9&#34;,&#34;name&#34;:&#34;nginx&#34;,
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      &#34;ports&#34;:[{&#34;containerPort&#34;:80}]}]}}}}</span><span style=color:#bbb>      
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># ditulis oleh perintah kubectl scale</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>minReadySeconds</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.7.9<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Berikut merupakan perhitungan penggabungan yang akan dilakukan oleh perintah <code>kubectl apply</code>:</p><ol><li>Hitung semua <em>field</em> yang akan dihapus dengan membaca nilai dari <code>last-applied-configuration</code> dan membandingkannya dengan nilai yang ada di <em>file</em> konfigurasi. Hapus semua <em>field</em> yang nilainya secara eksplisit diubah menjadi null pada <em>file</em> konfigurasi objek lokal terlepas dari apakah <em>field-field</em> tersebut ada di anotasi <code>last-applied-configuration</code> atau tidak. Pada contoh di atas, <em>field</em> <code>minReadySeconds</code> muncul pada anotasi <code>last-applied-configuration</code>, tapi tidak ada di <em>file</em> konfigurasi. <strong>Aksi:</strong> Hapus <code>minReadySeconds</code> dari konfigurasi <em>live</em>.</li><li>Hitung semua <em>field</em> yang akan diubah dengan membaca nilai-nilai dari <em>file</em> konfigurasi dan membandingkannya dengan nilai-nilai yang ada di konfigurasi <em>live</em>. Pada contoh ini, nilai dari <em>field</em> <code>image</code> di <em>file</em> konfigurasi tidak sama dengan nilai dari konfigurasi <em>live</em>. <strong>Aksi:</strong> Ubah nilai <code>image</code> pada konfigurasi <em>live</em>.</li><li>Ubah anotasi <code>last-applied-configuration</code> agar sesuai dengan nilai yang ada di <em>file</em> konfigurasi.</li><li>Gabungkan hasil-hasil dari langkah 1, 2, dan 3 ke dalam satu <em>patch request</em> ke <em>API server</em>.</li></ol><p>Berikut konfigurasi <em>live</em> yang dihasilkan oleh proses penggabungan pada contoh di atas:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># Anotasi memuat pembaruan image menjadi nginx 1.11.9,</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># tetapi tidak memuat pembaruan replicas menjadi 2</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubectl.kubernetes.io/last-applied-configuration</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      {&#34;apiVersion&#34;:&#34;apps/v1&#34;,&#34;kind&#34;:&#34;Deployment&#34;,
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      &#34;metadata&#34;:{&#34;annotations&#34;:{},&#34;name&#34;:&#34;nginx-deployment&#34;,&#34;namespace&#34;:&#34;default&#34;},
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      &#34;spec&#34;:{&#34;selector&#34;:{&#34;matchLabels&#34;:{&#34;app&#34;:nginx}},&#34;template&#34;:{&#34;metadata&#34;:{&#34;labels&#34;:{&#34;app&#34;:&#34;nginx&#34;}},
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      &#34;spec&#34;:{&#34;containers&#34;:[{&#34;image&#34;:&#34;nginx:1.11.9&#34;,&#34;name&#34;:&#34;nginx&#34;,
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      &#34;ports&#34;:[{&#34;containerPort&#34;:80}]}]}}}}</span><span style=color:#bbb>      
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># Diubah oleh `kubectl scale`, tidak diubah oleh `kubectl apply`.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># minReadySeconds dihapus oleh `kubectl apply`</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.11.9<span style=color:#bbb> </span><span style=color:#080;font-style:italic># Diubah oleh `kubectl apply`</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=cara-penggabungan-tipe-tipe-field-yang-berbeda>Cara penggabungan tipe-tipe <em>field</em> yang berbeda</h3><p>Cara sebuah <em>field</em> terentu dalam sebuah <em>file</em> konfigurasi digabungkan dengan konfigurasi <em>live</em> bergantung pada tipe <em>field</em> tersebut. Ada beberapa tipe <em>field</em>:</p><ul><li><p><em>primitif</em>: <em>field</em> yang bertipe string, integer, atau boolean. Sebagai contoh, <code>image</code> dan <code>replicas</code> termasuk sebagai <em>field</em> primitif. <strong>Aksi:</strong> <em>Replace</em>.</p></li><li><p><em>map</em>, atau <em>objek</em>: <em>field</em> yang bertipe <em>map</em> atau tipe kompleks yang mengandung sub <em>field</em>. Sebagai contoh, <code>labels</code>, <code>annotations</code>, <code>spec</code>, dan <code>metadata</code> termasuk sebagai map. <strong>Aksi</strong>: Lakukan penggabungan tiap-tiap elemen atau sub <em>field</em>.</p></li><li><p><em>list</em>: <em>field</em> yang berisi sejumlah item yang tiap itemnya bisa berupa tipe primitif maupun map. Sebagai contoh, <code>containers</code>, <code>ports</code>, dan <code>args</code> termasuk sebagai <em>list</em>. <strong>Aksi:</strong> Bervariasi.</p></li></ul><p>Ketika digunakan untuk memperbarui sebuah <em>field</em> bertipe <em>map</em> atau <em>list</em>, perintah <code>kubectl apply</code> memperbarui nilai tiap-tiap sub elemen ketimbang mengganti nilai semua <em>field</em>. Misalnya, ketika menggabungkan <em>field</em> <code>spec</code> pada sebuah Deployment, bukan keseluruhan <em>field</em> <code>spec</code> yang diubah nilainya. Alih-alih, sub <em>field</em> dari <code>spec</code> seperti <code>replicas</code> yang kemudian dibandingkan nilainya dan digabungkan.</p><h3 id=menggabungkan-perubahan-pada-field-primitif>Menggabungkan perubahan pada <em>field</em> primitif</h3><p><em>Field</em> primitif diganti nilainya atau dihapus sama sekali.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> <code>-</code> digunakan untuk menandai sebuah nilai "<em>not applicable</em>" karena nilai tersebut tidak digunakan.</div><table><thead><tr><th><em>Field</em> pada <em>file</em> konfigurasi objek</th><th><em>Field</em> pada objek konfigurasi <em>live</em></th><th><em>Field</em> pada <em>last-applied-configuration</em></th><th>Aksi</th></tr></thead><tbody><tr><td>Ya</td><td>Ya</td><td>-</td><td>Ubah nilai di konfigurasi <em>live</em> mengikuti nilai pada <em>file</em> konfigurasi.</td></tr><tr><td>Ya</td><td>Tidak</td><td>-</td><td>Ubah nilai di konfigurasi <em>live</em> mengikuti nilai pada konfigurasi lokal.</td></tr><tr><td>Tidak</td><td>-</td><td>Ya</td><td>Hapus dari konfigurasi <em>live</em>.</td></tr><tr><td>Tidak</td><td>-</td><td>Tidak</td><td>Tidak melakukan apa-apa, pertahankan nilai konfigurasi <em>live</em>.</td></tr></tbody></table><h3 id=menggabungkan-perubahan-pada-field-bertipe-map>Menggabungkan perubahan pada <em>field</em> bertipe <em>map</em></h3><p><em>Field</em> yang bertipe <em>map</em> digabungkan dengan membandingkan tiap sub <em>field</em> atau elemen dari map:</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> <code>-</code> digunakan untuk menandai sebuah nilai "<em>not applicable</em>" karena nilai tersebut tidak digunakan.</div><table><thead><tr><th><em>Key</em> pada <em>file</em> konfigurasi objek</th><th><em>Key</em> pada objek konfigurasi <em>live</em></th><th><em>Field</em> pada <em>last-applied-configuration</em></th><th>Aksi</th></tr></thead><tbody><tr><td>Ya</td><td>Ya</td><td>-</td><td>Bandingkan nilai tiap sub <em>field</em>.</td></tr><tr><td>Ya</td><td>Tidak</td><td>-</td><td>Ubah nilai pada konfigurasi <em>live</em> mengikuti nilai pada konfigurasi lokal.</td></tr><tr><td>Tidak</td><td>-</td><td>Ya</td><td>Hapus dari konfigurasi <em>live</em>.</td></tr><tr><td>Tidak</td><td>-</td><td>Tidak</td><td>Tidak melakukan apa-apa, pertahankan nilai konfigurasi <em>live</em>.</td></tr></tbody></table><h3 id=menggabungkan-perubahan-pada-field-yang-bertipe-list>Menggabungkan perubahan pada <em>field</em> yang bertipe <em>list</em></h3><p>Penggabungan perubahan pada sebuah <em>list</em> bisa menggunakan salah satu dari tiga strategi:</p><ul><li>Ganti nilai keseluruhan <em>list</em>.</li><li>Gabungkan nilai tiap-tiap elemen di dalam sebuah list yang elemennya kompleks.</li><li>Gabungkan list yang elemennya primitif.</li></ul><p>Pilihan strategi dibuat berbeda-beda bergantung tipe tiap <em>field</em>.</p><h4 id=ganti-nilai-keseluruhan-list>Ganti nilai keseluruhan <em>list</em></h4><p>Perlakukan <em>list</em> sama dengan <em>field</em> primitif. Ganti atau hapus keseluruhan list. Ini akan menjaga urutan dari list.</p><p><strong>Contoh:</strong> Gunakan <code>kubectl apply</code> untuk memperbarui <em>field</em> <code>args</code> pada sebuah kontainer di dalam sebuah <em>pod</em>. Ini akan mengubah nilai <code>args</code> di konfigurasi <em>live</em> mengikuti nilai di <em>file</em> konfigurasi. Elemen <code>args</code> apapun yang sebelumnya ditambahkan ke konfigurasi <em>live</em> akan hilang. Urutan dari elemen-elemen <code>args</code> yang didefinisikan di <em>file</em> konfigurasi akan dipertahankan ketika ditulis ke konfigurasi <em>live</em>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#080;font-style:italic># nilai last-applied-configuration*</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;a&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;b&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># nilai berkas konfigurasi</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;a&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;c&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># nilai konfigurasi live</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;a&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;b&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;d&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># hasil setelah penggabungan</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;a&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;c&#34;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div><p><strong>Penjelasan:</strong> Penggabungan menggunakan nilai pada <em>file</em> konfigurasi sebagai nilai baru untuk <em>list</em> <code>args</code>.</p><h4 id=menggabungkan-tiap-tiap-elemen-dari-sebuah-list-dengan-elemen-kompleks>Menggabungkan tiap-tiap elemen dari sebuah <em>list</em> dengan elemen kompleks:</h4><p>Perlakukan <em>list</em> selayaknya sebuah <em>map</em>, perlakukan <em>field</em> spesifik dari tiap element sebagai sebuah <em>key</em>. Tambah, hapus, atau perbarui tiap-tiap elemen. Operasi ini tidak mempertahankan urutan elemen di dalam <em>list</em>.</p><p>Strategi penggabungan ini menggunakan <em>tag</em> khusus <code>patchMergeKey</code> pada tiap <em>field</em>. <em>Tag</em> <code>patchMergeKey</code> didefinisikan untuk tiap <em>field</em> pada <em>source code</em> Kubernetes: <a href=https://github.com/kubernetes/api/blob/d04500c8c3dda9c980b668c57abc2ca61efcf5c4/core/v1/types.go#L2747>types.go</a>. Ketika menggabungkan sebuah <em>list</em> yang berisi <em>map</em>, <em>field</em> yang dispesifikasikan sebagai <code>patchMergeKey</code> untuk tiap elemen digunakan sebagai <em>map key</em> untuk elemen tersebut.</p><p><strong>Contoh:</strong> Gunakan <code>kubectl apply</code> untuk memperbarui <em>field</em> <code>containers</code> pada sebuah PodSpec. Perintah ini akan menggabungkan <em>list</em> <code>containers</code> seolah-olah <em>list</em> tersebut adalah sebuah <em>map</em> dan tiap elemennya menggunakan <code>name</code> sebagai <em>key</em>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#080;font-style:italic># nilai last-applied-configuration</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.10<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name: nginx-helper-a # key</span>:<span style=color:#bbb> </span>nginx-helper-a; akan dihapus pada hasil akhir<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>helper:1.3<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name: nginx-helper-b # key</span>:<span style=color:#bbb> </span>nginx-helper-b; akan dipertahankan pada hasil akhir<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>helper:1.3<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># nilai berkas konfigurasi</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.10<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-helper-b<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>helper:1.3<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name: nginx-helper-c # key</span>:<span style=color:#bbb> </span>nginx-helper-c; akan ditambahkan pada hasil akhir<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>helper:1.3<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># konfigurasi live</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.10<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-helper-a<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>helper:1.3<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-helper-b<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>helper:1.3<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;run&#34;</span>]<span style=color:#bbb> </span><span style=color:#080;font-style:italic># Field ini akan dipertahankan pada hasil akhir</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name: nginx-helper-d # key</span>:<span style=color:#bbb> </span>nginx-helper-d; akan dipertahankan pada hasil akhir<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>helper:1.3<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># hasil akhir setelah penggabungan</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.10<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># Elemen nginx-helper-a dihapus</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-helper-b<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>helper:1.3<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;run&#34;</span>]<span style=color:#bbb> </span><span style=color:#080;font-style:italic># Field dipertahankan</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-helper-c<span style=color:#bbb> </span><span style=color:#080;font-style:italic># Elemen ditambahkan</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>helper:1.3<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-helper-d<span style=color:#bbb> </span><span style=color:#080;font-style:italic># Elemen tidak diubah</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>helper:1.3<span style=color:#bbb>
</span></span></span></code></pre></div><p><strong>Penjelasan:</strong></p><ul><li>Kontainer dengan nama "nginx-helper-a" dihapus karena tidak ada kontainer dengan nama tersebut di <em>file</em> konfigurasi.</li><li>Kontainer dengan nama "nginx-helper-b" tetap mempertahankan nilai <code>args</code> pada konfigurasi <em>live</em>. Perintah <code>kubectl apply</code> bisa mengenali bahwa "nginx-helper-b" di konfigurasi <em>live</em> sama dengan "ngnix-helper-b" di <em>file</em> konfigurasi, meskipun keduanya memiliki <em>field</em> yang berbeda (tidak ada <code>args</code> pada <em>file</em> konfigurasi). Ini karena nilai <code>patchMergeKey</code> di kedua konfigurasi identik.</li><li>Kontainer dengan nama "nginx-helper-c" ditambahkan karena tidak ada kontainer dengan nama tersebut di konfigurasi <em>live</em>, tapi ada di <em>file</em> konfigurasi.</li><li>Kontainer dengan nama "nginx-helper-d" dipertahankan karena tidak ada elemen dengan nama tersebut pada <em>last-applied-configuration</em>.</li></ul><h4 id=menggabungkan-sebuah-list-dengan-elemen-elemen-primitif>Menggabungkan sebuah <em>list</em> dengan elemen-elemen primitif</h4><p>Pada versi Kubernetes 1.5, penggabungan list dengan elemen-elemen primitif tidak lagi didukung.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Strategi mana yang dipilih untuk sembarang <em>field</em> ditentukan oleh <em>tag</em> <code>patchStrategy</code> pada <a href=https://github.com/kubernetes/api/blob/d04500c8c3dda9c980b668c57abc2ca61efcf5c4/core/v1/types.go#L2748>types.go</a>. Jika <code>patchStrategy</code> tidak ditentukan untuk sebuah <em>field</em> yang bertipe <em>list</em>, maka <em>list</em> tersebut akan diubah nilainya secara keseluruhan.</div><h2 id=nilai-default-dari-sebuah-field>Nilai <em>default</em> dari sebuah <em>field</em></h2><p><em>API server</em> mengisi <em>field</em> tertentu dengan nilai <em>default</em> pada konfigurasi <em>live</em> jika nilai <em>field-field</em> tersebut tidak dispesifikasikan ketika objek dibuat.</p><p>Berikut adalah sebuah <em>file</em> konfigurasi untuk sebuah Deployment. Berkas berikut tidak menspesifikasikan <code>strategy</code>:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/application/simple_deployment.yaml download=application/simple_deployment.yaml><code>application/simple_deployment.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("application-simple-deployment-yaml")' title="Copy application/simple_deployment.yaml to clipboard"></img></div><div class=includecode id=application-simple-deployment-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>minReadySeconds</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.7.9<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Buat objek dengan perintah <code>kubectl apply</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/application/simple_deployment.yaml
</span></span></code></pre></div><p>Tampilkan konfigurasi <em>live</em> dengan perintah <code>kubectl get</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get -f https://k8s.io/examples/application/simple_deployment.yaml -o yaml
</span></span></code></pre></div><p>Keluaran dari perintah tadi menunjukkan bahwa <em>API server</em> mengisi beberapa <em>field</em> dengan nilai <em>default</em> pada konfigurasi <em>live</em>. <em>Field-field</em> berikut tidak dispesifikan pada <em>file</em> konfigurasi.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>minReadySeconds</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># nilai default dari apiserver</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>strategy</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rollingUpdate</span>:<span style=color:#bbb> </span><span style=color:#080;font-style:italic># nilai default dari apiserver - diturunkan dari strategy.type</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>maxSurge</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>maxUnavailable</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>RollingUpdate<span style=color:#bbb> </span><span style=color:#080;font-style:italic># nilai default dari apiserver</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>null</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.7.9<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>IfNotPresent<span style=color:#bbb> </span><span style=color:#080;font-style:italic># nilai default dari apiserver</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb> </span><span style=color:#080;font-style:italic># nilai default dari apiserver</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb> </span><span style=color:#080;font-style:italic># nilai default dari apiserver</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>terminationMessagePath</span>:<span style=color:#bbb> </span>/dev/termination-log<span style=color:#bbb> </span><span style=color:#080;font-style:italic># nilai default dari apiserver</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>dnsPolicy</span>:<span style=color:#bbb> </span>ClusterFirst<span style=color:#bbb> </span><span style=color:#080;font-style:italic># nilai default dari apiserver</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Always<span style=color:#bbb> </span><span style=color:#080;font-style:italic># nilai default dari apiserver</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb> </span><span style=color:#080;font-style:italic># nilai default dari apiserver</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>terminationGracePeriodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>30</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># nilai default dari apiserver</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Dalam sebuah <em>patch request</em>, <em>field-field</em> dengan nilai <em>default</em> tidak diisi kembali dengan nilai <em>default</em> kecuali secara eksplisit nilainya dihapuskan sebagai bagian dari <em>patch request</em>. Ini bisa menimbulkan hasil yang tak terduga jika sebagian <em>field</em> diisi dengan nilai <em>default</em> yang diturunkan dari nilai <em>field</em> lainnya. Ketika <em>field</em> lain tersebut nilainya diubah, <em>field-field</em> yang diisi dengan nilai <em>default</em> berdasarkan <em>field</em> yang berubah tadi tidak akan diperbarui kecuali secara eksplisit dihapus.</p><p>Oleh karena itu, beberapa <em>field</em> yang nilainya diisi secara <em>default</em> oleh <em>server</em> perlu didefinisikan secara eksplisit di <em>file</em> konfigurasi, meskipun nilai yang diinginkan sudah sesuai dengan nilai <em>default</em> dari server. Ini untuk mempermudah mengenali nilai-nilai yang berselisih yang tidak akan diisi dengan nilai <em>default</em> oleh <em>server</em>.</p><p><strong>Contoh:</strong></p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#080;font-style:italic># last-applied-configuration</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.7.9<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># berkas konfigurasi</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>strategy</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Recreate<span style=color:#bbb> </span><span style=color:#080;font-style:italic># nilai yang diperbarui</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.7.9<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># konfigurasi live</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>strategy</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>RollingUpdate<span style=color:#bbb> </span><span style=color:#080;font-style:italic># nilai default</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rollingUpdate</span>:<span style=color:#bbb> </span><span style=color:#080;font-style:italic># nilai default yang diturunkan dari type</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>maxSurge </span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>maxUnavailable</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.7.9<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># hasil setelah penggabungan - ERROR!</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>strategy</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type: Recreate # nilai yang diperbarui</span>:<span style=color:#bbb> </span>tidak kompatibel dengan field rollingUpdate<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rollingUpdate: # nilai default</span>:<span style=color:#bbb> </span>tidak kompatibel dengan &#34;type: Recreate&#34;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>maxSurge </span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>maxUnavailable</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.7.9<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div><p><strong>Penjelasan:</strong></p><ol><li>Pengguna sebelumnya sudah membuat sebuah Deployment tanpa mendefinisikan <code>strategy.type</code> (seperti yang bisa dilihat pada <code>last-applied-configuration</code>).</li><li>Server mengisi <code>strategy.type</code> dengan nilai <em>default</em> <code>RollingUpdate</code> dan mengisi <code>strategy.rollingUpdate</code> dengan nilai <em>default</em> pada konfigurasi <em>live</em>.</li><li>Pengguna mengubah nilai <em>field</em> <code>strategy.type</code> menjadi <code>Recreate</code> pada <em>file</em> konfigurasi. Nilai <code>strategy.rollingUpdate</code> tidak berubah dari nilai <em>default</em>, meskipun server sekarang berekspektasi nilai tersebut dihapus. Jika nilai <code>strategy.rollingUpdate</code> didefinisikan di awal pada <em>file</em> konfigurasi, akan jelas bagi <em>server</em> bahwa <em>field</em> tersebut perlu dihapus.</li><li>Perintah <code>kubect apply</code> gagal karena <code>strategy.rollingUpdate</code> tidak dihapus. <em>Field</em> <code>strategy.rollingUpdate</code> tidak bisa didefinisikan jika <em>field</em> <code>strategy.type</code> berisi <code>Recreate</code>.</li></ol><p>Rekomendasi: <em>Field-field</em> ini harus didefinisikan secara eksplisit di <em>file</em> konfigurasi objek:</p><ul><li>Label Selectors dan PodTemplate pada <em>workloads</em>, misalnya Deployment, StatefulSet, Job, DaemonSet, ReplicaSet, dan ReplicationController</li><li>Strategi Deployment <em>rollout</em></li></ul><h3 id=cara-menghilangkan-field-field-yang-diisi-dengan-nilai-default-atau-diisi-oleh-writer-lainnya>Cara menghilangkan <em>field-field</em> yang diisi dengan nilai <em>default</em> atau diisi oleh <em>writer</em> lainnya</h3><p><em>Field-field</em> yang tidak muncul di <em>file</em> konfigurasi bisa dihilangkan dengan mengisi nilainya dengan <code>null</code> dan kemudian jalankan <code>kubectl apply</code> dengan <em>file</em> konfigurasi tersebut. Untuk <em>field-field</em> yang nilainya diisi dengan nilai <em>default</em> oleh <em>server</em>, aksi ini akan mmenyebabkan pengisian ulang <em>field</em> dengan nilai <em>default</em>.</p><h2 id=cara-mengubah-kepemilikan-sebuah-field-antara-file-konfigurasi-dan-writer-imperatif>Cara mengubah kepemilikan sebuah <em>field</em> antara <em>file</em> konfigurasi dan <em>writer</em> imperatif</h2><p>Hanya metode-metode berikut yang bisa kamu gunakan untuk mengubah satu <em>field</em> objek:</p><ul><li>Gunakan <code>kubectl apply</code>.</li><li>Tulis secara langsung ke konfigurasi <em>live</em> tanpa memodifikasi <em>file</em> konfigurasi: misalnya, dengan perintah <code>kubectl scale</code>.</li></ul><h3 id=mengubah-kepemilikan-dari-writer-imperatif-ke-file-konfigurasi>Mengubah kepemilikan dari <em>writer</em> imperatif ke <em>file</em> konfigurasi</h3><p>Tambahkan <em>field</em> ke <em>file</em> konfigurasi. Hentikan pembaruan secara langsung ke konfigurasi <em>live</em> tanpa melalui <code>kubectl apply</code>.</p><h3 id=mengubah-kepemilikan-dari-file-konfigurasi-ke-writer-imperatif>Mengubah kepemilikan dari <em>file</em> konfigurasi ke <em>writer</em> imperatif</h3><p>Pada versi Kubernetes 1.5, mengubah kepemilikan sebuah field dari <em>file</em> konfigurasi memerlukan langkah-langkah manual:</p><ul><li>Hapus <em>field</em> dari <em>file</em> konfigurasi.</li><li>Hapus <em>field</em> dari anotasi <code>kubectl.kubernetes.io/last-applied-configuration</code> pada objek <em>live</em>.</li></ul><h2 id=mengubah-metode-metode-pengelolaan-objek>Mengubah metode-metode pengelolaan objek</h2><p>Objek-objek Kubernetes sebaiknya dikelola dengan satu metode dalam satu waktu. Berpindah dari satu metode ke metode lain dimungkinkan, tetapi memerlukan proses manual.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Boleh menggunakan perintah hapus secara imperatif dalam pengelolaan objek secara deklaratif.</div><h3 id=migrasi-dari-pengelolaan-dengan-perintah-imperatif-ke-konfigurasi-objek-deklaratif>Migrasi dari pengelolaan dengan perintah imperatif ke konfigurasi objek deklaratif</h3><p>Migrasi dari pengelolaan objek dengan perintah imperatif ke pengelolaan objek dengan konfigurasi deklaratif memerlukan beberapa langkah manual:</p><ol><li><p>Ekspor objek <em>live</em> ke <em>file</em> konfigurasi lokal:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get &lt;kind&gt;/&lt;name&gt; -o yaml &gt; &lt;kind&gt;_&lt;name&gt;.yaml
</span></span></code></pre></div></li><li><p>Hapus secara manual <em>field</em> <code>status</code> dari <em>file</em> konfigurasi.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Tahap ini opsional, karena <code>kubectl apply</code> tidak memperbarui <em>field</em> status meskipun <em>field</em> tersebut ada di <em>file</em> konfigurasi.</div></li><li><p>Ubah anotasi <code>kubectl.kubernetes.io/last-applied-configuration</code> pada objek:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl replace --save-config -f &lt;kind&gt;_&lt;name&gt;.yaml
</span></span></code></pre></div></li><li><p>Selanjutnya gunakan <code>kubectl apply</code> secara eksklusif untuk mengelola objek.</p></li></ol><h3 id=migrasi-dari-konfigurasi-objek-imperatif-ke-konfigurasi-objek-deklaratif>Migrasi dari konfigurasi objek imperatif ke konfigurasi objek deklaratif</h3><ol><li><p>Atur anotasi <code>kubectl.kubernetes.io/last-applied-configuration</code> pada objek:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl replace --save-config -f &lt;kind&gt;_&lt;name&gt;.yaml
</span></span></code></pre></div></li><li><p>Gunakan selalu perintah <code>kubectl apply</code> saja untuk mengelola objek.</p></li></ol><h2 id=pendefinisian-selektor-controller-dan-label-podtemplate>Pendefinisian selektor <em>controller</em> dan label PodTemplate</h2><div class="alert alert-danger warning callout" role=alert><strong>Peringatan:</strong> Pembaruan selektor pada <em>controllers</em> sangat tidak disarankan.</div><p>Cara yang disarankan adalah dengan mendefinisikan sebuah PodTemplate <em>immutable</em> yang hanya digunakan oleh selektor <em>controller</em> tanpa memiliki arti semantik lainnya.</p><p><strong>Contoh:</strong></p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>controller-selector</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;extensions/v1beta1/deployment/nginx&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>controller-selector</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;extensions/v1beta1/deployment/nginx&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=selanjutnya>Selanjutnya</h2><ul><li><a href=/id/docs/tasks/manage-kubernetes-objects/imperative-command/>Pengelolaan Objek Kubernetes Menggunakan Perintah Imperatif</a></li><li><a href=/id/docs/tasks/manage-kubernetes-objects/imperative-config/>Pengelolaan Objek Kubernetes secara Imperatif Menggunakan Berkas Konfigurasi</a></li><li><a href=/docs/reference/generated/kubectl/kubectl-commands/>Rujukan Perintah Kubectl</a></li><li><a href=/docs/reference/generated/kubernetes-api/v1.25/>Rujukan API Kubernetes</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-11aa6950fcb203094823c8e2cbdd517f>4.5.2 - Mengelola Objek Kubernetes secara Deklaratif menggunakan Kustomize</h1><p><a href=https://github.com/kubernetes-sigs/kustomize>Kustomize</a> merupakan sebuah alat
untuk melakukan kustomisasi objek Kubernetes melalui sebuah berkas <a href=https://github.com/kubernetes-sigs/kustomize/blob/master/docs/glossary.md#kustomization>berkas kustomization</a>.</p><p>Sejak versi 1.14, kubectl mendukung pengelolaan objek Kubernetes melalui berkas kustomization.
Untuk melihat sumber daya yang ada di dalam direktori yang memiliki berkas kustomization, jalankan perintah berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl kustomize &lt;direktori_kustomization&gt;
</span></span></code></pre></div><p>Untuk menerapkan sumber daya tersebut, jalankan perintah <code>kubectl apply</code> dengan <em>flag</em> <code>--kustomize</code> atau <code>-k</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -k &lt;kustomization_directory&gt;
</span></span></code></pre></div><h2 id=sebelum-kamu-memulai>Sebelum kamu memulai</h2><p>Instal <a href=/id/docs/tasks/tools/install-kubectl/><code>kubectl</code></a> terlebih dahulu.</p><p><p>Kamu harus memiliki klaster Kubernetes, dan perangkat baris perintah kubectl
juga harus dikonfigurasikan untuk berkomunikasi dengan klastermu. Jika kamu
belum memiliki klaster, kamu dapat membuatnya dengan menggunakan
<a href=/id/docs/tasks/tools/#minikube>minikube</a>,
atau kamu juga dapat menggunakan salah satu dari tempat mencoba Kubernetes berikut ini:</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>Bermain dengan Kubernetes</a></li></ul>Untuk melihat versi, tekan <code>kubectl version</code>.</p><h2 id=gambaran-umum-kustomize>Gambaran Umum Kustomize</h2><p>Kustomize adalah sebuah alat untuk melakukan kustomisasi konfigurasi Kubernetes. Untuk mengelola berkas-berkas konfigurasi, kustomize memiliki fitur -fitur di bawah ini:</p><ul><li>membangkitkan (<em>generate</em>) sumber daya dari sumber lain</li><li>mengatur <em>field</em> dari berbagai sumber daya yang bersinggungan</li><li>mengkomposisikan dan melakukan kustomisasi sekelompok sumber daya</li></ul><h3 id=membangkitkan-sumber-daya>Membangkitkan Sumber Daya</h3><p>ConfigMap dan Secret menyimpan konfigurasi atau data sensitif yang digunakan oleh objek-objek Kubernetes lainnya, seperti Pod.
Biasanya, <em>source of truth</em> dari ConfigMap atau Secret berasal dari luar klaster, seperti berkas <code>.properties</code> atau berkas kunci SSH.
Kustomize memiliki <code>secretGenerator</code> dan <code>configMapGenerator</code>, yang akan membangkitkan (<em>generate</em>) Secret dan ConfigMap dari berkas-berkas atau nilai-nilai literal.</p><h4 id=configmapgenerator>configMapGenerator</h4><p>Untuk membangkitkan sebuah ConfigMap dari berkas, tambahkan entri ke daftar <code>files</code> pada <code>configMapGenerator</code>.
Contoh di bawah ini membangkitkan sebuah ConfigMap dengan data dari berkas <code>.properties</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Membuat berkas application.properties</span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt;application.properties
</span></span></span><span style=display:flex><span><span style=color:#b44>FOO=Bar
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt;./kustomization.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>configMapGenerator:
</span></span></span><span style=display:flex><span><span style=color:#b44>- name: example-configmap-1
</span></span></span><span style=display:flex><span><span style=color:#b44>  files:
</span></span></span><span style=display:flex><span><span style=color:#b44>  - application.properties
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>ConfigMap yang telah dibangkitkan dapat dilihat menggunakan perintah berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl kustomize ./
</span></span></code></pre></div><p>Isinya seperti di bawah ini:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>application.properties</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    </span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>FOO</span>:<span style=color:#bbb> </span>Bar<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example-configmap-1-42cfbf598f<span style=color:#bbb>
</span></span></span></code></pre></div><p>ConfigMap juga dapat dibangkitkan dari pasangan <em>key-value</em> literal. Untuk membangkitkan secara literal, tambahkan entri pada daftar <code>literals</code> di <code>configMapGenerator</code>.
Contoh di bawah ini membangkitkan ConfigMap dengan data dari pasangan <em>key-value</em>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt;./kustomization.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>configMapGenerator:
</span></span></span><span style=display:flex><span><span style=color:#b44>- name: example-configmap-2
</span></span></span><span style=display:flex><span><span style=color:#b44>  literals:
</span></span></span><span style=display:flex><span><span style=color:#b44>  - FOO=Bar
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>ConfigMap yang dibangkitkan dapat dilihat menggunakan perintah berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl kustomize ./
</span></span></code></pre></div><p>Isinya seperti ini:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>FOO</span>:<span style=color:#bbb> </span>Bar<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example-configmap-2-g2hdhfc6tk<span style=color:#bbb>
</span></span></span></code></pre></div><h4 id=secretgenerator>secretGenerator</h4><p>Kamu dapat membangkitkan Secret dari berkas atau pasangan <em>key-value</em> literal. Untuk membangkitkan dari berkas, tambahkan entri pada daftar <code>files</code> di <code>secretGenerator</code>.
Contoh di bawah ini membangkitkan Secret dengan data dari berkas:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Membuat berkas password.txt</span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt;./password.txt
</span></span></span><span style=display:flex><span><span style=color:#b44>username=admin
</span></span></span><span style=display:flex><span><span style=color:#b44>password=secret
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt;./kustomization.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>secretGenerator:
</span></span></span><span style=display:flex><span><span style=color:#b44>- name: example-secret-1
</span></span></span><span style=display:flex><span><span style=color:#b44>  files:
</span></span></span><span style=display:flex><span><span style=color:#b44>  - password.txt
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>Isinya seperti ini:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>password.txt</span>:<span style=color:#bbb> </span>dXNlcm5hbWU9YWRtaW4KcGFzc3dvcmQ9c2VjcmV0Cg==<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example-secret-1-t2kt65hgtb<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Opaque<span style=color:#bbb>
</span></span></span></code></pre></div><p>Untuk membangkitkan secara literal dari pasangan <em>key-value</em>, tambahkan entri pada daftar <code>literals</code> di <code>secretGenerator</code>.
Contoh di bawah ini membangkitkan Secret dengan data dari pasangan <em>key-value</em>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt;./kustomization.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>secretGenerator:
</span></span></span><span style=display:flex><span><span style=color:#b44>- name: example-secret-2
</span></span></span><span style=display:flex><span><span style=color:#b44>  literals:
</span></span></span><span style=display:flex><span><span style=color:#b44>  - username=admin
</span></span></span><span style=display:flex><span><span style=color:#b44>  - password=secret
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>Isinya seperti ini:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>password</span>:<span style=color:#bbb> </span>c2VjcmV0<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>username</span>:<span style=color:#bbb> </span>YWRtaW4=<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example-secret-2-t52t6g96d8<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Opaque<span style=color:#bbb>
</span></span></span></code></pre></div><h4 id=generatoroptions>generatorOptions</h4><p>ConfigMap dan Secret yang dibangkitkan memiliki informasi sufiks <em>hash</em>. Hal ini memastikan bahwa ConfigMap atau Secret yang baru, dibangkitkan saat isinya berubah.
Untuk menonaktifkan penambahan sufiks ini, kamu bisa menggunakan <code>generatorOptions</code>. Selain itu, melalui <em>field</em> ini kamu juga bisa mengatur opsi-opsi yang bersinggungan untuk ConfigMap dan Secret yang dibangkitkan.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt;./kustomization.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>configMapGenerator:
</span></span></span><span style=display:flex><span><span style=color:#b44>- name: example-configmap-3
</span></span></span><span style=display:flex><span><span style=color:#b44>  literals:
</span></span></span><span style=display:flex><span><span style=color:#b44>  - FOO=Bar
</span></span></span><span style=display:flex><span><span style=color:#b44>generatorOptions:
</span></span></span><span style=display:flex><span><span style=color:#b44>  disableNameSuffixHash: true
</span></span></span><span style=display:flex><span><span style=color:#b44>  labels:
</span></span></span><span style=display:flex><span><span style=color:#b44>    type: generated
</span></span></span><span style=display:flex><span><span style=color:#b44>  annotations:
</span></span></span><span style=display:flex><span><span style=color:#b44>    note: generated
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>Jalankan perintah <code>kubectl kustomize ./</code> untuk melihat ConfigMap yang dibangkitkan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>FOO</span>:<span style=color:#bbb> </span>Bar<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>note</span>:<span style=color:#bbb> </span>generated<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>generated<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example-configmap-3<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=mengatur-field-yang-bersinggungan>Mengatur <em>field</em> yang bersinggungan</h3><p>Mengatur <em>field-field</em> yang bersinggungan untuk semua sumber daya Kubernetes dalam sebuah proyek.
Beberapa contoh kasusnya seperti di bawah ini:</p><ul><li>mengatur Namespace yang sama untuk semua sumber daya</li><li>menambahkan prefiks atau sufiks yang sama</li><li>menambahkan kumpulan label yang sama</li><li>menambahkan kumpulan anotasi yang sama</li></ul><p>Lihat contoh di bawah ini:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Membuat sebuah deployment.yaml</span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt;./deployment.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: apps/v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: Deployment
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: nginx-deployment
</span></span></span><span style=display:flex><span><span style=color:#b44>  labels:
</span></span></span><span style=display:flex><span><span style=color:#b44>    app: nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>  selector:
</span></span></span><span style=display:flex><span><span style=color:#b44>    matchLabels:
</span></span></span><span style=display:flex><span><span style=color:#b44>      app: nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>  template:
</span></span></span><span style=display:flex><span><span style=color:#b44>    metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>      labels:
</span></span></span><span style=display:flex><span><span style=color:#b44>        app: nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>    spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>      containers:
</span></span></span><span style=display:flex><span><span style=color:#b44>      - name: nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>        image: nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt;./kustomization.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>namespace: my-namespace
</span></span></span><span style=display:flex><span><span style=color:#b44>namePrefix: dev-
</span></span></span><span style=display:flex><span><span style=color:#b44>nameSuffix: &#34;-001&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44>commonLabels:
</span></span></span><span style=display:flex><span><span style=color:#b44>  app: bingo
</span></span></span><span style=display:flex><span><span style=color:#b44>commonAnnotations:
</span></span></span><span style=display:flex><span><span style=color:#b44>  oncallPager: 800-555-1212
</span></span></span><span style=display:flex><span><span style=color:#b44>resources:
</span></span></span><span style=display:flex><span><span style=color:#b44>- deployment.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>Jalankan perintah <code>kubectl kustomize ./</code> untuk melihat <em>field-field</em> tersebut telah terisi di dalam sumber daya Deployment:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>oncallPager</span>:<span style=color:#bbb> </span><span style=color:#666>800-555-1212</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>bingo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dev-nginx-deployment-001<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>my-namespace<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>bingo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>oncallPager</span>:<span style=color:#bbb> </span><span style=color:#666>800-555-1212</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>bingo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=mengkomposisi-dan-melakukan-kustomisasi-sumber-daya>Mengkomposisi dan Melakukan Kustomisasi Sumber Daya</h3><p>Mengkomposisi kumpulan sumber daya dalam sebuah proyek dan mengelolanya di dalam berkas atau direktori yang sama merupakan hal yang cukup umum dilakukan.
Kustomize menyediakan cara untuk mengkomposisi sumber daya dari berkas-berkas yang berbeda, lalu menerapkan <em>patch</em> atau kustomisasi lain di atasnya.</p><h4 id=melakukan-komposisi>Melakukan Komposisi</h4><p>Kustomize mendukung komposisi dari berbagai sumber daya yang berbeda. <em>Field</em> <code>resources</code> pada berkas <code>kustomization.yaml</code>, mendefinisikan daftar sumber daya yang diinginkan dalam sebuah konfigurasi. Atur terlebih dahulu jalur (<em>path</em>) ke berkas konfigurasi sumber daya pada daftar <code>resources</code>.
Contoh di bawah ini merupakan sebuah aplikasi NGINX yang terdiri dari sebuah Deployment dan sebuah Service:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Membuat berkas deployment.yaml</span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt; deployment.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: apps/v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: Deployment
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>  selector:
</span></span></span><span style=display:flex><span><span style=color:#b44>    matchLabels:
</span></span></span><span style=display:flex><span><span style=color:#b44>      run: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>  replicas: 2
</span></span></span><span style=display:flex><span><span style=color:#b44>  template:
</span></span></span><span style=display:flex><span><span style=color:#b44>    metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>      labels:
</span></span></span><span style=display:flex><span><span style=color:#b44>        run: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>    spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>      containers:
</span></span></span><span style=display:flex><span><span style=color:#b44>      - name: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>        image: nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>        ports:
</span></span></span><span style=display:flex><span><span style=color:#b44>        - containerPort: 80
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Membuat berkas service.yaml</span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt; service.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: Service
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>  labels:
</span></span></span><span style=display:flex><span><span style=color:#b44>    run: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>  ports:
</span></span></span><span style=display:flex><span><span style=color:#b44>  - port: 80
</span></span></span><span style=display:flex><span><span style=color:#b44>    protocol: TCP
</span></span></span><span style=display:flex><span><span style=color:#b44>  selector:
</span></span></span><span style=display:flex><span><span style=color:#b44>    run: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Membuat berkas kustomization.yaml yang terdiri dari keduanya</span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt;./kustomization.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>resources:
</span></span></span><span style=display:flex><span><span style=color:#b44>- deployment.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>- service.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>Sumber daya dari <code>kubectl kustomize ./</code> berisi kedua objek Deployment dan Service.</p><h4 id=melakukan-kustomisasi>Melakukan Kustomisasi</h4><p><em>Patch</em> dapat digunakan untuk menerapkan berbagai macam kustomisasi pada sumber daya. Kustomize mendukung berbagai mekanisme <em>patching</em> yang berbeda melalui <code>patchesStrategicMerge</code> dan <code>patchesJson6902</code>. <code>patchesStrategicMerge</code> adalah daftar dari yang berisi tentang <em>path</em> berkas. Setiap berkas akan dioperasikan dengan cara <a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-api-machinery/strategic-merge-patch.md>strategic merge patch</a>. Nama di dalam <em>patch</em> harus sesuai dengan nama sumber daya yang telah dimuat. Kami menyarankan <em>patch-patch</em> kecil yang hanya melakukan satu hal saja.
Contoh membuat sebuah <em>patch</em> di bawah ini akan menambahkan jumlah replika Deployment dan <em>patch</em> lainnya untuk mengatur limit memori.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Membuat berkas deployment.yaml</span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt; deployment.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: apps/v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: Deployment
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>  selector:
</span></span></span><span style=display:flex><span><span style=color:#b44>    matchLabels:
</span></span></span><span style=display:flex><span><span style=color:#b44>      run: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>  replicas: 2
</span></span></span><span style=display:flex><span><span style=color:#b44>  template:
</span></span></span><span style=display:flex><span><span style=color:#b44>    metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>      labels:
</span></span></span><span style=display:flex><span><span style=color:#b44>        run: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>    spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>      containers:
</span></span></span><span style=display:flex><span><span style=color:#b44>      - name: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>        image: nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>        ports:
</span></span></span><span style=display:flex><span><span style=color:#b44>        - containerPort: 80
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Membuat sebuah patch increase_replicas.yaml</span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt; increase_replicas.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: apps/v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: Deployment
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>  replicas: 3
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Membuat patch lainnya set_memory.yaml</span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt; set_memory.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: apps/v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: Deployment
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>  template:
</span></span></span><span style=display:flex><span><span style=color:#b44>    spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>      containers:
</span></span></span><span style=display:flex><span><span style=color:#b44>      - name: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>        resources:
</span></span></span><span style=display:flex><span><span style=color:#b44>        limits:
</span></span></span><span style=display:flex><span><span style=color:#b44>          memory: 512Mi
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt;./kustomization.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>resources:
</span></span></span><span style=display:flex><span><span style=color:#b44>- deployment.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>patchesStrategicMerge:
</span></span></span><span style=display:flex><span><span style=color:#b44>- increase_replicas.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>- set_memory.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>Jalankan perintah <code>kubectl kustomize ./</code> untuk melihat isi dari Deployment:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>512Mi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Tidak semua sumber daya atau <em>field</em> mendukung <em>strategic merge patch</em>. Untuk mendukung <em>field</em> sembarang pada sumber daya <em>field</em>, Kustomize
menyediakan penerapan <a href=https://tools.ietf.org/html/rfc6902><em>patch</em> JSON</a> melalui <code>patchesJson6902</code>.
Untuk mencari sumber daya yang tepat dengan sebuah <em>patch</em> Json, maka grup, versi, jenis dan nama dari sumber daya harus dispesifikasikan dalam <code>kustomization.yaml</code>.
Contoh di bawah ini menambahkan jumlah replika dari objek Deployment yang bisa juga dilakukan melalui <code>patchesJson6902</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Membuat berkas deployment.yaml</span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt; deployment.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: apps/v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: Deployment
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>  selector:
</span></span></span><span style=display:flex><span><span style=color:#b44>    matchLabels:
</span></span></span><span style=display:flex><span><span style=color:#b44>      run: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>  replicas: 2
</span></span></span><span style=display:flex><span><span style=color:#b44>  template:
</span></span></span><span style=display:flex><span><span style=color:#b44>    metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>      labels:
</span></span></span><span style=display:flex><span><span style=color:#b44>        run: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>    spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>      containers:
</span></span></span><span style=display:flex><span><span style=color:#b44>      - name: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>        image: nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>        ports:
</span></span></span><span style=display:flex><span><span style=color:#b44>        - containerPort: 80
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Membuat patch json</span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt; patch.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>- op: replace
</span></span></span><span style=display:flex><span><span style=color:#b44>  path: /spec/replicas
</span></span></span><span style=display:flex><span><span style=color:#b44>  value: 3
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Membuat berkas kustomization.yaml</span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt;./kustomization.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>resources:
</span></span></span><span style=display:flex><span><span style=color:#b44>- deployment.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>
</span></span></span><span style=display:flex><span><span style=color:#b44>patchesJson6902:
</span></span></span><span style=display:flex><span><span style=color:#b44>- target:
</span></span></span><span style=display:flex><span><span style=color:#b44>    group: apps
</span></span></span><span style=display:flex><span><span style=color:#b44>    version: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>    kind: Deployment
</span></span></span><span style=display:flex><span><span style=color:#b44>    name: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>  path: patch.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>Jalankan perintah <code>kubectl kustomize ./</code> untuk melihat <em>field</em> <code>replicas</code> yang telah diperbarui:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Selain <em>patch</em>, Kustomize juga menyediakan cara untuk melakukan kustomisasi <em>image</em> Container atau memasukkan nilai <em>field</em> dari objek lainnya ke dalam Container tanpa membuat <em>patch</em>. Sebagai contoh, kamu dapat melakukan kustomisasi <em>image</em> yang digunakan di dalam Container dengan menyebutkan spesifikasi <em>field</em> <code>images</code> di dalam <code>kustomization.yaml</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt; deployment.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: apps/v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: Deployment
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>  selector:
</span></span></span><span style=display:flex><span><span style=color:#b44>    matchLabels:
</span></span></span><span style=display:flex><span><span style=color:#b44>      run: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>  replicas: 2
</span></span></span><span style=display:flex><span><span style=color:#b44>  template:
</span></span></span><span style=display:flex><span><span style=color:#b44>    metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>      labels:
</span></span></span><span style=display:flex><span><span style=color:#b44>        run: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>    spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>      containers:
</span></span></span><span style=display:flex><span><span style=color:#b44>      - name: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>        image: nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>        ports:
</span></span></span><span style=display:flex><span><span style=color:#b44>        - containerPort: 80
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt;./kustomization.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>resources:
</span></span></span><span style=display:flex><span><span style=color:#b44>- deployment.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>images:
</span></span></span><span style=display:flex><span><span style=color:#b44>- name: nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>  newName: my.image.registry/nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>  newTag: 1.4.0
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>Jalankan perintah <code>kubectl kustomize ./</code> untuk melihat <em>image</em> yang sedang digunakan telah diperbarui:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>my.image.registry/nginx:1.4.0<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Terkadang, aplikasi yang berjalan di dalam Pod perlu untuk menggunakan nilai konfigurasi dari objek lainnya.
Contohnya, sebuah Pod dari objek Deployment perlu untuk membaca nama Service dari Env atau sebagai argumen perintah.
Ini karena nama Service bisa saja berubah akibat dari penambahan <code>namePrefix</code> atau <code>nameSuffix</code> pada berkas <code>kustomization.yaml</code>.
Kami tidak menyarankan kamu untuk meng-<em>hardcode</em> nama Service di dalam argumen perintah.
Untuk penggunaan ini, Kustomize dapat memasukkan nama Service ke dalam Container melalui <code>vars</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Membuat berkas deployment.yaml</span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt; deployment.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: apps/v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: Deployment
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>  selector:
</span></span></span><span style=display:flex><span><span style=color:#b44>    matchLabels:
</span></span></span><span style=display:flex><span><span style=color:#b44>      run: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>  replicas: 2
</span></span></span><span style=display:flex><span><span style=color:#b44>  template:
</span></span></span><span style=display:flex><span><span style=color:#b44>    metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>      labels:
</span></span></span><span style=display:flex><span><span style=color:#b44>        run: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>    spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>      containers:
</span></span></span><span style=display:flex><span><span style=color:#b44>      - name: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>        image: nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>        command: [&#34;start&#34;, &#34;--host&#34;, &#34;\$(MY_SERVICE_NAME)&#34;]
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Membuat berkas service.yaml</span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt; service.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: Service
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>  labels:
</span></span></span><span style=display:flex><span><span style=color:#b44>    run: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>  ports:
</span></span></span><span style=display:flex><span><span style=color:#b44>  - port: 80
</span></span></span><span style=display:flex><span><span style=color:#b44>    protocol: TCP
</span></span></span><span style=display:flex><span><span style=color:#b44>  selector:
</span></span></span><span style=display:flex><span><span style=color:#b44>    run: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt;./kustomization.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>namePrefix: dev-
</span></span></span><span style=display:flex><span><span style=color:#b44>nameSuffix: &#34;-001&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44>
</span></span></span><span style=display:flex><span><span style=color:#b44>resources:
</span></span></span><span style=display:flex><span><span style=color:#b44>- deployment.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>- service.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>
</span></span></span><span style=display:flex><span><span style=color:#b44>vars:
</span></span></span><span style=display:flex><span><span style=color:#b44>- name: MY_SERVICE_NAME
</span></span></span><span style=display:flex><span><span style=color:#b44>  objref:
</span></span></span><span style=display:flex><span><span style=color:#b44>    kind: Service
</span></span></span><span style=display:flex><span><span style=color:#b44>    name: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>    apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>Jalankan perintah <code>kubectl kustomize ./</code> untuk melihat nama Service yang dimasukkan ke dalam Container menjadi <code>dev-my-nginx-001</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dev-my-nginx-001<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- start<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- --host<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- dev-my-nginx-001<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-nginx<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=base-dan-overlay>Base dan Overlay</h2><p>Kustomize memiliki konsep <strong>base</strong> dan <strong>overlay</strong>. <strong>base</strong> merupakan direktori dengan <code>kustomization.yaml</code>, yang berisi
sekumpulan sumber daya dan kustomisasi yang terkait. <strong>base</strong> dapat berupa direktori lokal maupun direktori dari repo <em>remote</em>,
asalkan berkas <code>kustomization.yaml</code> ada di dalamnya. <strong>overlay</strong> merupakan direktori dengan <code>kustomization.yaml</code> yang merujuk pada
direktori kustomization lainnya sebagai <strong>base</strong>-nya. <strong>base</strong> tidak memiliki informasi tentang <strong>overlay</strong>. dan dapat digunakan pada beberapa <strong>overlay</strong> sekaligus.
<strong>overlay</strong> bisa memiliki beberapa <strong>base</strong> dan terdiri dari semua sumber daya yang berasal dari <strong>base</strong> yang juga dapat memiliki kustomisasi lagi di atasnya.</p><p>Contoh di bawah ini memperlihatkan kegunaan dari <strong>base</strong>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Membuat direktori untuk menyimpan base</span>
</span></span><span style=display:flex><span>mkdir base
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Membuat base/deployment.yaml</span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt; base/deployment.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: apps/v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: Deployment
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>  selector:
</span></span></span><span style=display:flex><span><span style=color:#b44>    matchLabels:
</span></span></span><span style=display:flex><span><span style=color:#b44>      run: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>  replicas: 2
</span></span></span><span style=display:flex><span><span style=color:#b44>  template:
</span></span></span><span style=display:flex><span><span style=color:#b44>    metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>      labels:
</span></span></span><span style=display:flex><span><span style=color:#b44>        run: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>    spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>      containers:
</span></span></span><span style=display:flex><span><span style=color:#b44>      - name: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>        image: nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Membuat berkas base/service.yaml</span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt; base/service.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: Service
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>  labels:
</span></span></span><span style=display:flex><span><span style=color:#b44>    run: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>  ports:
</span></span></span><span style=display:flex><span><span style=color:#b44>  - port: 80
</span></span></span><span style=display:flex><span><span style=color:#b44>    protocol: TCP
</span></span></span><span style=display:flex><span><span style=color:#b44>  selector:
</span></span></span><span style=display:flex><span><span style=color:#b44>    run: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Membuat berkas base/kustomization.yaml</span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt; base/kustomization.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>resources:
</span></span></span><span style=display:flex><span><span style=color:#b44>- deployment.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>- service.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p><strong>base</strong> ini dapat digunakan di dalam beberapa <strong>overlay</strong> sekaligus. Kamu dapat menambahkan <code>namePrefix</code> yang berbeda ataupun
<em>field</em> lainnya yang bersinggungan di dalam <strong>overlay</strong> berbeda. Di bawah ini merupakan dua buah <strong>overlay</strong> yang menggunakan <strong>base</strong> yang sama.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>mkdir dev
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt; dev/kustomization.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>bases:
</span></span></span><span style=display:flex><span><span style=color:#b44>- ../base
</span></span></span><span style=display:flex><span><span style=color:#b44>namePrefix: dev-
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>mkdir prod
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt; prod/kustomization.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>bases:
</span></span></span><span style=display:flex><span><span style=color:#b44>- ../base
</span></span></span><span style=display:flex><span><span style=color:#b44>namePrefix: prod-
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><h2 id=cara-menerapkan-melihat-menghapus-objek-menggunakan-kustomize>Cara menerapkan/melihat/menghapus objek menggunakan Kustomize</h2><p>Gunakan <code>--kustomize</code> atau <code>-k</code> di dalam perintah <code>kubectl</code> untuk mengenali sumber daya yang dikelola oleh <code>kustomization.yaml</code>.
Perhatikan bahwa <code>-k</code> harus merujuk pada direktori kustomization, misalnya:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -k &lt;direktori kustomization&gt;/
</span></span></code></pre></div><p>Buatlah <code>kustomization.yaml</code> seperti di bawah ini:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Membuat berkas deployment.yaml</span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt; deployment.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: apps/v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: Deployment
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>  selector:
</span></span></span><span style=display:flex><span><span style=color:#b44>    matchLabels:
</span></span></span><span style=display:flex><span><span style=color:#b44>      run: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>  replicas: 2
</span></span></span><span style=display:flex><span><span style=color:#b44>  template:
</span></span></span><span style=display:flex><span><span style=color:#b44>    metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>      labels:
</span></span></span><span style=display:flex><span><span style=color:#b44>        run: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>    spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>      containers:
</span></span></span><span style=display:flex><span><span style=color:#b44>      - name: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>        image: nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>        ports:
</span></span></span><span style=display:flex><span><span style=color:#b44>        - containerPort: 80
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Membuat berkas kustomization.yaml</span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt;./kustomization.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>namePrefix: dev-
</span></span></span><span style=display:flex><span><span style=color:#b44>commonLabels:
</span></span></span><span style=display:flex><span><span style=color:#b44>  app: my-nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>resources:
</span></span></span><span style=display:flex><span><span style=color:#b44>- deployment.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>Jalankan perintah di bawah ini untuk menerapkan objek Deployment <code>dev-my-nginx</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>&gt; kubectl apply -k ./
</span></span><span style=display:flex><span>deployment.apps/dev-my-nginx created
</span></span></code></pre></div><p>Jalankan perintah di bawah ini untuk melihat objek Deployment <code>dev-my-nginx</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get -k ./
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe -k ./
</span></span></code></pre></div><p>Jalankan perintah di bawah ini untuk membandingkan objek Deployment <code>dev-my-nginx</code> dengan kondisi yang diinginkan pada klaster jika manifes telah berhasil diterapkan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl diff -k ./
</span></span></code></pre></div><p>Jalankan perintah di bawah ini untuk menghapus objek Deployment <code>dev-my-nginx</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>&gt; kubectl delete -k ./
</span></span><span style=display:flex><span>deployment.apps <span style=color:#b44>&#34;dev-my-nginx&#34;</span> deleted
</span></span></code></pre></div><h2 id=daftar-fitur-kustomize>Daftar Fitur Kustomize</h2><table><thead><tr><th><em>Field</em></th><th>Tipe</th><th>Deskripsi</th></tr></thead><tbody><tr><td>namespace</td><td>string</td><td>menambahkan Namespace untuk semua sumber daya</td></tr><tr><td>namePrefix</td><td>string</td><td>nilai dari <em>field</em> ini ditambahkan di awal pada nama dari semua sumber daya</td></tr><tr><td>nameSuffix</td><td>string</td><td>nilai dari <em>field</em> ini ditambahkan di akhir pada nama dari semua sumber daya</td></tr><tr><td>commonLabels</td><td>map[string]string</td><td>label untuk ditambahkan pada semua sumber daya dan selektor</td></tr><tr><td>commonAnnotations</td><td>map[string]string</td><td>anotasi untuk ditambahkan pada semua sumber daya</td></tr><tr><td>resources</td><td>[]string</td><td>setiap entri di dalam daftar ini harus diselesaikan pada berkas konfigurasi sumber daya yang sudah ada</td></tr><tr><td>configmapGenerator</td><td>[]<a href=https://github.com/kubernetes-sigs/kustomize/blob/release-kustomize-v4.0/api/types/kustomization.go#L99>ConfigMapArgs</a></td><td>setiap entri di dalam daftar ini membangkitkan ConfigMap</td></tr><tr><td>secretGenerator</td><td>[]<a href=https://github.com/kubernetes-sigs/kustomize/blob/release-kustomize-v4.0/api/types/kustomization.go#L106>SecretArgs</a></td><td>setiap entri di dalam daftar ini membangkitkan Secret</td></tr><tr><td>generatorOptions</td><td><a href=https://github.com/kubernetes-sigs/kustomize/blob/release-kustomize-v4.0/api/types/kustomization.go#L109>GeneratorOptions</a></td><td>memodifikasi perilaku dari semua generator ConfigMap dan Secret</td></tr><tr><td>bases</td><td>[]string</td><td>setiap entri di dalam daftar ini harus diselesaikan ke dalam sebuah direktori yang berisi berkas kustomization.yaml</td></tr><tr><td>patchesStrategicMerge</td><td>[]string</td><td>setiap entri di dalam daftar ini harus diselesaikan dengan <em>strategic merge patch</em> dari sebuah objek Kubernetes</td></tr><tr><td>patchesJson6902</td><td>[]<a href=https://github.com/kubernetes-sigs/kustomize/blob/release-kustomize-v4.0/api/types/patchjson6902.go#L8>Json6902</a></td><td>setiap entri di dalam daftar ini harus diselesaikan ke suatu objek Kubernetes atau <em>patch</em> Json</td></tr><tr><td>vars</td><td>[]<a href=https://github.com/kubernetes-sigs/kustomize/blob/master/api/types/var.go#L31>Var</a></td><td>setiap entri digunakan untuk menangkap teks yang berasal dari <em>field</em> sebuah sumber daya</td></tr><tr><td>images</td><td>[]<a href=https://github.com/kubernetes-sigs/kustomize/tree/master/api/types/image.go#L23>Image</a></td><td>setiap entri digunakan untuk memodifikasi nama, tag dan/atau <em>digest</em> untuk sebuah <em>image</em> tanpa membuat <em>patch</em></td></tr><tr><td>configurations</td><td>[]string</td><td>setiap entri di dalam daftar ini harus diselesaikan ke sebuah berkas yang berisi <a href=https://github.com/kubernetes-sigs/kustomize/tree/master/examples/transformerconfigs>konfigurasi transformer Kustomize</a></td></tr><tr><td>crds</td><td>[]string</td><td>setiap entri di dalam daftar ini harus diselesaikan ke sebuah berkas definisi OpenAPI untuk tipe Kubernetes</td></tr></tbody></table><h2 id=selanjutnya>Selanjutnya</h2><ul><li><a href=https://github.com/kubernetes-sigs/kustomize>Kustomize</a></li><li><a href=https://kubectl.docs.kubernetes.io>Buku Kubectl</a></li><li><a href=/docs/reference/generated/kubectl/kubectl-commands/>Rujukan Perintah Kubectl</a></li><li><a href=/docs/reference/generated/kubernetes-api/v1.25/>Rujukan API Kubernetes</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-80c83fe9b80d0fef2681c8d59c0aa197>4.5.3 - Pengelolaan Objek Kubernetes dengan Perintah Imperatif</h1><p>Objek-objek Kubernetes bisa dibuat, diperbarui, dan dihapus secara langsung dengan menggunakan perintah-perintah imperatif yang ada pada <em>command-line</em> <code>kubectl</code>. Dokumen ini menjelaskan cara perintah-perintah tersebut diorganisir dan cara menggunakan perintah-perintah tersebut untuk mengelola objek <em>live</em>.</p><h2 id=kelebihan-dan-kekurangan>Kelebihan dan kekurangan</h2><p>Perintah <code>kubectl</code> mendukung tiga cara pengelolaan objek:</p><ul><li>Perintah imperatif</li><li>Konfigurasi objek imperatif</li><li>Konfigurasi objek deklaratif</li></ul><p>Lihat <a href=/id/docs/concepts/overview/working-with-objects/object-management/>Pengelolaan Objek Kubernetes</a> untuk mengenali lebih lanjut kelebihan dan kekurangan dari tiap pengelolaan objek.</p><h2 id=cara-membuat-objek>Cara membuat objek</h2><p>Perangkat <code>kubectl</code> mendukung perintah-perintah berbentuk kata kerja untuk membuat beberapa tipe objek yang paling umum. Perintah-perintah tersebut diberi nama yang mudah dikenali oleh pengguna yang belum familiar dengan tipe-tipe objek Kubernetes.</p><ul><li><code>run</code>: Membuat sebuah objek Deployment untuk menjalankan kontainer di satu atau lebih Pod.</li><li><code>expose</code>: Membuat sebuah objek Service untuk mengatur lalu lintas beban antar Pod.</li><li><code>autoscale</code>: Membuat sebuah objek Autoscaler untuk melakukan <em>scaling</em> horizontal secara otomatis terhadap sebuah objek <em>controller</em>, misalnya sebuah objek Deployment.</li></ul><p>Perangkat <code>kubectl</code> juga mendukung perintah-perintah pembuatan objek yang berdasarkan pada tipe objek. Perintah-perintah ini mendukung lebih banyak tipe objek dan lebih eksplisit tentang intensi mereka. Tapi, perintah-perintah ini memerlukan pengguna untuk memahami tipe dari objek-objek yang hendak mereka buat.</p><ul><li><code>create &lt;objecttype> [&lt;subtype>] &lt;instancename></code></li></ul><p>Beberapa tipe objek memiliki sub tipe yang bisa kamu spesifikasikan pada perintah <code>create</code>. Misalnya, objek Service memiliki beberapa sub tipe seperti ClusterIP, LoadBalancer, dan NodePort. Berikut adalah sebuah contoh cara membuat sebuah Service dengan sub tipe NodePort:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create service nodeport &lt;myservicename&gt;
</span></span></code></pre></div><p>Pada contoh di atas, perintah <code>create service nodeport</code> merupakan sub perintah dari <code>create service</code>.</p><p>Kamu bisa menggunakan parameter <code>-h</code> untuk mencari argumen-argumen dan paramenter-parameter yang didukung oleh sebuah sub perintah:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create service nodeport -h
</span></span></code></pre></div><h2 id=cara-memperbarui-objek>Cara memperbarui objek</h2><p>Perintah <code>kubectl</code> mendukung perintah-perintah berbasis kata kerja untuk beberapa operasi pembaruan yang umum. Perintah-perintah ini diberi nama yang memudahkan pengguna yang belum familiar dengan objek-objek Kubernetes untuk melakukan pembaruan tanpa terlebih dulu mengetahui <em>field-field</em> spesifik yang harus diperbarui:</p><ul><li><code>scale</code>: Melakukan <em>scaling</em> horizontal terhadap sebuah <em>controller</em> untuk menambah atau menghapus Pod dengan memperbarui jumlah replika dari <em>controller</em> tersebut.</li><li><code>annotate</code>: Menambah atau menghapus anotasi sebuah objek.</li><li><code>label</code>: Menambah atau menghapus label sebuah objek.</li></ul><p>Perintah <code>kubectl</code> juga mendukung perintah-perintah pembaruan berdasarkan salah satu aspek dari sebuah objek. Untuk tiap tipe objek yang berbeda, memperbarui sebuah aspek tertentu bisa berarti memperbarui sekumpulan <em>field</em> yang berbeda pula:</p><ul><li><code>set</code> <code>&lt;field></code>: Memperbarui salah satu aspek dari sebuah objek.</li></ul><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Pada Kubernetes versi 1.5, tidak semua perintah yang berdasarkan kata kerja berasosiasi dengan perintah yang berdasarkan aspek tertentu.</div><p>Perangkat <code>kubectl</code> juga mendukung beberapa cara lain untuk memperbarui objek <em>live</em> secara langsung, meskipun cara-cara berikut membutuhkan pemahaman yang lebih tentang skema objek Kubernetes.</p><ul><li><code>edit</code>: Secara langsung mengedit konfigurasi mentah dari sebuah objek <em>live</em> dengan membuka konfigurasinya di sebuah editor.</li><li><code>patch</code>: Secara langsung memodifikasi <em>field-field</em> spesifik dari sebuah objek <em>live</em> dengan menggunakan <em>patch string</em>. Untuk detil lebih lanjut mengenai <code>patch string</code>, lihat bagian tentang <em>patch</em> pada <a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#patch-operations>Konvensi API</a>.</li></ul><h2 id=cara-menghapus-objek>Cara menghapus objek</h2><p>Kamu bisa menggunakan perintah <code>delete</code> pada sebuah objek dari sebuah klaster:</p><ul><li><code>delete &lt;type>/&lt;name></code></li></ul><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Kamu bisa menggunakan <code>kubectl delete</code> baik untuk perintah imperatif maupun konfigurasi objek imperatif. Perbedaannya hanya pada argumen yang diberikan ke perintah tersebut. Untuk menggunakan <code>kubectl delete</code> sebagai perintah imperatif, argumen yang diberikan adalah objek yang hendak dihapus. Berikut adalah sebuah contoh perintah <code>kubectl delete</code> dengan sebuah objek Deployment bernama nginx sebagai argumen:</div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete deployment/nginx
</span></span></code></pre></div><h2 id=cara-melihat-objek>Cara melihat objek</h2><p>Ada beberapa perintah untuk menampilkan informasi tentang sebuah objek:</p><ul><li><code>get</code>: Menampilkan informasi dasar dari objek-objek yang sesuai dengan parameter dari perintah ini. Gunakan <code>get -h</code> untuk melihat daftar opsi yang bisa digunakan.</li><li><code>describe</code>: Menampilkan agregat informasi detil dari objek-objek yang sesuai dengan parameter dari perintah ini.</li><li><code>logs</code>: Menampilkan isi stdout dan stderr dari sebuah kontainer yang berjalan di sebuah Pod.</li></ul><h2 id=menggunakan-perintah-set-untuk-memodifikasi-objek-sebelum-dibuat>Menggunakan perintah <code>set</code> untuk memodifikasi objek sebelum dibuat</h2><p>Ada beberapa <em>field</em> objek yang tidak memiliki parameter yang bisa kamu gunakan pada perintah <code>create</code>. Pada kasus-kasus tersebut, kamu bisa menggunakan kombinasi dari perintah <code>set</code> dan <code>create</code> untuk menspesifikasikan nilai untuk <em>field-field</em> tersebut sebelum objek dibuat. Ini dilakukan dengan melakukan <em>piping</em> pada hasil dari perintah <code>create</code> ke perintah <code>set</code>, dan kemudian mengembalikan hasilnya ke perintah <code>create</code>. Simak contoh berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl create service clusterip my-svc --clusterip<span style=color:#666>=</span><span style=color:#b44>&#34;None&#34;</span> -o yaml --dry-run | kubectl <span style=color:#a2f>set</span> selector --local -f - <span style=color:#b44>&#39;environment=qa&#39;</span> -o yaml | kubectl create -f -
</span></span></code></pre></div><ol><li>Perintah <code>kubectl create service -o yaml --dry-run</code> membuat konfigurasi untuk sebuah Service, tapi kemudian menuliskan konfigurasi tadi ke stdout dalam format YAML alih-alih mengirimnya ke <em>API Server</em> Kubernetes.</li><li>Perintah <code>kubectl set selector --local -f - -o yaml</code> membaca konfigurasi dari stdin, dan menuliskan pembaruan konfigurasi ke stdout dalam format YAML.</li><li>Perintah <code>kubectl create -f -</code> membuat objek dengan menggunakan konfigurasi yang disediakan pada stdin.</li></ol><h2 id=menggunakan-edit-untuk-memodifikasi-objek-sebelum-dibuat>Menggunakan <code>--edit</code> untuk memodifikasi objek sebelum dibuat</h2><p>Kamu bisa menggunakan perintah <code>kubectl create --edit</code> untuk membuat perubahan terhadap sebuah objek sebelum objek tersebut dibuat. Simak contoh berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl create service clusterip my-svc --clusterip<span style=color:#666>=</span><span style=color:#b44>&#34;None&#34;</span> -o yaml --dry-run &gt; /tmp/srv.yaml
</span></span><span style=display:flex><span>kubectl create --edit -f /tmp/srv.yaml
</span></span></code></pre></div><ol><li>Perintah <code>kubectl create service</code> membuat konfigurasi untuk objek Service dan menyimpannya di <code>/tmp/srv.yaml</code>.</li><li>Perintah <code>kubectl create --edit</code> membuka berkas konfigurasi untuk disunting sebelum objek dibuat.</li></ol><h2 id=selanjutnya>Selanjutnya</h2><ul><li><a href=/id/docs/tasks/manage-kubernetes-objects/imperative-config/>Pengelolaan Objek Kubernetes secara Imperatif dengan Menggunakan Konfigurasi Objek</a></li><li><a href=/id//docs/tasks/manage-kubernetes-objects/declarative-config/>Pengelolaan Objek Kubernetes secara Deklaratif dengan Menggunakan Konfigurasi Objek</a></li><li><a href=/docs/reference/generated/kubectl/kubectl-commands/>Rujukan Perintah Kubectl</a></li><li><a href=/docs/reference/generated/kubernetes-api/v1.25/>Kubernetes API Reference</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-b18886277c410fc6f32ce068e2160537>4.5.4 - Pengelolaan Objek Kubernetes Secara Imperatif dengan Menggunakan File Konfigurasi</h1><p>Objek-objek Kubernetes bisa dibuat, diperbarui, dan dihapus dengan menggunakan perangkat <em>command-line</em> <code>kubectl</code> dan file konfigurasi objek yang ditulis dalam format YAML atau JSON. Dokumen ini menjelaskan cara mendefinisikan dan mengelola objek dengan menggunakan file konfigurasi.</p><h2 id=kelebihan-dan-kekurangan>Kelebihan dan kekurangan</h2><p>Perintah <code>kubectl</code> mendukung tiga cara pengelolaan objek:</p><ul><li>Perintah imperatif</li><li>Konfigurasi objek imperatif</li><li>Konfigurasi objek deklaratif</li></ul><p>Lihat <a href=/id/docs/tasks/manage-kubernetes-objects/>Pengelolaan Objek Kubernetes</a> untuk mengenali lebih lanjut kelebihan dan kekurangan dari tiap cara pengelolaan objek.</p><h2 id=cara-membuat-objek>Cara membuat objek</h2><p>Kamu bisa menggunakan perintah <code>kubectl create -f</code> untuk membuat sebuah objek dari sebuah file konfigurasi. Rujuk dokumen <a href=/docs/reference/generated/kubernetes-api/v1.25/>referensi API Kubernetes</a> untuk detil lebih lanjut.</p><ul><li><code>kubectl create -f &lt;nama-file|url></code></li></ul><h2 id=cara-memperbarui-objek>Cara memperbarui objek</h2><div class="alert alert-danger warning callout" role=alert><strong>Peringatan:</strong> Memperbarui objek dengan perintah <code>replace</code> akan menghilangkan semua bagian dari spesifikasi objek yang tidak dispesifikasikan pada file konfigurasi. Oleh karena itu, perintah ini sebaiknya tidak digunakan terhadap objek-objek yang spesifikasinya sebagian dikelola oleh klaster, misalnya Service dengan tipe <code>LoadBalancer</code>, di mana <em>field</em> <code>externalIPs</code> dikelola secara terpisah dari file konfigurasi. <em>Field-field</em> yang dikelola secara terpisah harus disalin ke file konfigurasi untuk mencegah terhapus oleh perintah <code>replace</code>.</div><p>Kamu bisa menggunakan perintah <code>kubectl replace -f</code> untuk memperbarui sebuah objek <em>live</em> sesuai dengan sebuah file konfigurasi.</p><ul><li><code>kubectl replace -f &lt;nama-file|url></code></li></ul><h2 id=cara-menghapus-objek>Cara menghapus objek</h2><p>Kamu bisa menggunakan perintah <code>kubectl delete -f</code> untuk menghapus sebuah objek yang dideskripsikan pada sebuah file konfigurasi.</p><ul><li><code>kubectl delete -f &lt;nama-file|url></code></li></ul><h2 id=cara-melihat-objek>Cara melihat objek</h2><p>Kamu bisa menggunakan perintah <code>kubectl get -f</code> untuk melihat informasi tentang sebuah objek yang dideskripsikan pada sebuah file konfigurasi.</p><ul><li><code>kubectl get -f &lt;nama-file|url> -o yaml</code></li></ul><p>Parameter <code>-o yaml</code> menetapkan bahwa keseluruhan konfigurasi objek ditulis ke file yaml. Gunakan perintah <code>kubectl get -h</code> untuk melihat daftar pilihan selengkapnya.</p><h2 id=keterbatasan>Keterbatasan</h2><p>Perintah-perintah <code>create</code>, <code>replace</code>, dan <code>delete</code> bekerja dengan baik saat tiap konfigurasi dari sebuah objek didefinisikan dan dicatat dengan lengkap pada file konfigurasi objek tersebut. Akan tetapi, ketika sebuah objek <em>live</em> diperbarui dan pembaruannya tidak dicatat di file konfigurasinya, pembaruan tersebut akan hilang ketika perintah <code>replace</code> dieksekusi di waktu berikutnya. Ini bisa terjadi saat sebuah <em>controller</em>, misalnya sebuah <code>HorizontalPodAutoscaler</code>, membuat pembaruan secara langsung ke sebuah objek <em>live</em>. Berikut sebuah contoh:</p><ol><li>Kamu membuat sebuah objek dari sebuah file konfigurasi.</li><li>Sebuah sumber lain memperbarui objek tersebut dengan mengubah beberapa <em>field</em>.</li><li>Kamu memperbarui objek tersebut dengan <code>kubectl replace</code> dari file konfigurasi. Perubahan yang dibuat dari sumber lain pada langkah nomor 2 di atas akan hilang.</li></ol><p>Jika kamu perlu mendukung beberapa <em>writer</em> untuk objek yang sama, kamu bisa menggunakan <code>kubectl apply</code> untuk mengelola objek tersebut.</p><h2 id=membuat-dan-mengedit-objek-dari-url-tanpa-menyimpan-konfigurasinya>Membuat dan mengedit objek dari URL tanpa menyimpan konfigurasinya</h2><p>Misalkan kamu memiliki URL dari sebuah file konfigurasi objek. Kamu bisa menggunakan <code>kubectl create --edit</code> untuk membuat perubahan pada konfigurasi sebelum objek tersebut dibuat. Langkah ini terutama berguna untuk mengikuti tutorial atau untuk pekerjaan-pekerjaan yang menggunakan sebuah file konfigurasi di URL terentu yang perlu dimodifikasi.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl create -f &lt;url&gt; --edit
</span></span></code></pre></div><h2 id=migrasi-dari-perintah-imperatif-ke-konfigurasi-objek-imperatif>Migrasi dari perintah imperatif ke konfigurasi objek imperatif</h2><p>Migrsasi dari perintah imperatif ke konfigurasi objek imperatif melibatkan beberapa langkah manual.</p><ol><li>Ekspor objek <em>live</em> ke sebuah file konfigurasi objek lokal:</li></ol><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl get &lt;kind&gt;/&lt;name&gt; -o yaml --export &gt; &lt;kind&gt;_&lt;name&gt;.yaml
</span></span></code></pre></div><ol><li><p>Hapus secara manual <em>field</em> status dari file konfigurasi objek.</p></li><li><p>Untuk pengelolaan objek selanjutnya, gunakan perintah <code>replace</code> secara eksklusif.</p></li></ol><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl replace -f &lt;kind&gt;_&lt;name&gt;.yaml
</span></span></code></pre></div><h2 id=mendefinisikan-controller-selectors-dan-label-podtemplate>Mendefinisikan <em>controller selectors</em> dan label PodTemplate</h2><div class="alert alert-danger warning callout" role=alert><strong>Peringatan:</strong> Memperbarui <em>selectors</em> pada <em>controllers</em> sangat tidak disarankan.</div><p>Pendekatan yang direkomendasikan adalah mendefinisikan sebuah label PodTemplate tunggal dan <em>immutable</em> yang hanya digunakan oleh <em>controller selector</em> tersebut, tanpa makna semantik lainnya.</p><p>Contoh label:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>controller-selector</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;extensions/v1beta1/deployment/nginx&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>controller-selector</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;extensions/v1beta1/deployment/nginx&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=selanjutnya>Selanjutnya</h2><ul><li><a href=/id/docs/tasks/manage-kubernetes-objects/imperative-command/>Pengelolaan Objek Kubernetes Menggunakan Perintah Imperatif</a></li><li><a href=/id/docs/tasks/manage-kubernetes-objects/declarative-config/>Pengelolaan Objek Kubernetes secara Deklaratif dengan Menggunakan File Konfigurasi</a></li><li><a href=/docs/reference/generated/kubectl/kubectl-commands/>Rujukan Perintah Kubectl</a></li><li><a href=/docs/reference/generated/kubernetes-api/v1.25/>Rujukan API Kubernetes</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-866924fa095f897ede8dfdcab9e97942>4.6 - Memasukkan Data ke dalam Aplikasi</h1></div><div class=td-content><h1 id=pg-c9af1e81bb6e109f6c41febe44f0931b>4.6.1 - Mendefinisikan Perintah dan Argumen untuk sebuah Kontainer</h1><p>Laman ini menunjukkan bagaimana cara mendefinisikan perintah-perintah
dan argumen-argumen saat kamu menjalankan Container
dalam sebuah <a class=glossary-tooltip title='Unit Kubernetes yang paling sederhana dan kecil. Sebuah Pod merepresentasikan sebuah set kontainer yang dijalankan pada kluster kamu.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>.</p><h2 id=sebelum-kamu-memulai>Sebelum kamu memulai</h2><p><p>Kamu harus memiliki klaster Kubernetes, dan perangkat baris perintah kubectl
juga harus dikonfigurasikan untuk berkomunikasi dengan klastermu. Jika kamu
belum memiliki klaster, kamu dapat membuatnya dengan menggunakan
<a href=/id/docs/tasks/tools/#minikube>minikube</a>,
atau kamu juga dapat menggunakan salah satu dari tempat mencoba Kubernetes berikut ini:</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>Bermain dengan Kubernetes</a></li></ul>Untuk melihat versi, tekan <code>kubectl version</code>.</p><h2 id=mendefinisikan-sebuah-perintah-dan-argumen-argumen-saat-kamu-membuat-sebuah-pod>Mendefinisikan sebuah perintah dan argumen-argumen saat kamu membuat sebuah Pod</h2><p>Saat kamu membuat sebuah Pod, kamu dapat mendefinisikan sebuah perintah dan argumen-argumen untuk
Container-Container yang berjalan di dalam Pod. Untuk mendefinisikan sebuah perintah, sertakan
bidang <code>command</code> di dalam berkas konfigurasi. Untuk mendefinisikan argumen-argumen untuk perintah, sertakan
bidang <code>args</code> di dalam berkas konfigurasi. Perintah dan argumen-argumen yang telah
kamu definisikan tidak dapat diganti setelah Pod telah terbuat.</p><p>Perintah dan argumen-argumen yang kamu definisikan di dalam berkas konfigurasi
membatalkan perintah dan argumen-argumen bawaan yang disediakan oleh <em>image</em> Container.
Jika kamu mendefinisikan argumen-argumen, tetapi tidak mendefinisikan sebuah perintah, perintah bawaan digunakan
dengan argumen-argumen baru kamu.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Bidang <code>command</code> menyerupai <code>entrypoint</code> di beberapa <em>runtime</em> Container.
Merujuk pada <a href=#catatan>catatan</a> di bawah.</div><p>Pada latihan ini, kamu akan membuat sebuah Pod baru yang menjalankan sebuah Container. Berkas konfigurasi
untuk Pod mendefinisikan sebuah perintah dan dua argumen:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/pods/commands.yaml download=pods/commands.yaml><code>pods/commands.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-commands-yaml")' title="Copy pods/commands.yaml to clipboard"></img></div><div class=includecode id=pods-commands-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>command-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>purpose</span>:<span style=color:#bbb> </span>demonstrate-command<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>command-demo-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>debian<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;printenv&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;HOSTNAME&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;KUBERNETES_PORT&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>OnFailure<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><ol><li><p>Buat sebuah Pod dengan berkas konfigurasi YAML:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/commands.yaml
</span></span></code></pre></div></li><li><p>Daftar Pod yang sedang berjalan</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods
</span></span></code></pre></div><p>Keluaran menunjukkan bahwa Container yang berjalan di dalam Pod command-demo
telah selesai.</p></li><li><p>Untuk melihat keluaran dari perintah yang berjalan di dalam Container, lihat log
dari Pod tersebut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl logs command-demo
</span></span></code></pre></div><p>Keluaran menunjukan nilai dari variabel lingkungan HOSTNAME dan KUBERNETES_PORT:</p><pre tabindex=0><code>command-demo
tcp://10.3.240.1:443
</code></pre></li></ol><h2 id=menggunakan-variabel-lingkungan-untuk-mendefinisikan-argumen>Menggunakan variabel lingkungan untuk mendefinisikan argumen</h2><p>Dalam contoh sebelumnya, kamu mendefinisikan langsung argumen-argumen dengan
menyediakan <em>string</em>. Sebagai sebuah alternatif untuk menyediakan <em>string</em> secara langsung,
kamu dapat mendefinisikan argumen-argumen dengan menggunakan variabel lingkungan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MESSAGE<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;hello world&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;/bin/echo&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;$(MESSAGE)&#34;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div><p>Ini berarti kamu dapat mendefinisikan sebuah argumen untuk sebuah Pod menggunakan
salah satu teknik yang tersedia untuk mendefinisikan variabel-variabel lingkungan, termasuk
<a href=/id/docs/tasks/configure-pod-container/configure-pod-configmap/>ConfigMap</a>
dan
<a href=/id/docs/concepts/configuration/secret/>Secret</a>.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Variabel lingkugan muncul dalam tanda kurung, <code>"$(VAR)"</code>. Ini
dibutuhkan untuk variabel yang akan diperuluas di bidang <code>command</code> atau <code>args</code>.</div><h2 id=menjalankan-sebuah-perintah-di-dalam-shell>Menjalankan sebuah perintah di dalam shell</h2><p>Di beberapa kasus, kamu butuh perintah untuk menjalankan sebuah <em>shell</em>. Contohnya,
perintah kamu mungkin terdiri dari beberapa perintah yang digabungkan, atau mungkin berupa
skrip <em>shell</em>. Untuk menjalankan perintah kamu di sebuah <em>shell</em>, bungkus seperti ini:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>command: <span style=color:#666>[</span><span style=color:#b44>&#34;/bin/sh&#34;</span><span style=color:#666>]</span>
</span></span><span style=display:flex><span>args: <span style=color:#666>[</span><span style=color:#b44>&#34;-c&#34;</span>, <span style=color:#b44>&#34;while true; do echo hello; sleep 10;done&#34;</span><span style=color:#666>]</span>
</span></span></code></pre></div><h2 id=catatan>Catatan</h2><p>Tabel ini merangkum nama-nama bidang yang digunakan oleh Docker dan Kubernetes.</p><table><thead><tr><th>Deskripsi</th><th>Nama bidang pada Docker</th><th>Nama bidang pada Kubernetes</th></tr></thead><tbody><tr><td>Perintah yang dijalankan oleh Container</td><td>Entrypoint</td><td>command</td></tr><tr><td>Argumen diteruskan ke perintah</td><td>Cmd</td><td>args</td></tr></tbody></table><p>Saat kamu mengesampingkan Entrypoint dan Cmd standar,
aturan-aturan ini berlaku:</p><ul><li><p>Jika kamu tidak menyediakan <code>command</code> atau <code>args</code> untuk sebuah Container,
maka <code>command</code> dan <code>args</code> yang didefinisikan di dalam <em>image</em> Docker akan digunakan.</p></li><li><p>Jika kamu menyediakan <code>command</code> tetapi tidak menyediakan <code>args</code> untuk sebuah Container, akan digunakan
<code>command</code> yang disediakan. Entrypoint dan Cmd bawaan yang didefinisikan di dalam
<em>image</em> Docker diabaikan.</p></li><li><p>Jika kamu hanya menyediakan <code>args</code> untuk sebuah Container, Entrypoint bawaan yang didefinisikan di dalam
<em>image</em> Docker dijalakan dengan <code>args</code> yang kamu sediakan.</p></li><li><p>Jika kamu menyediakan <code>command</code> dan <code>args</code>, Entrypoint dan Cmd standar yang didefinisikan
di dalam <em>image</em> Docker diabaikan. <code>command</code> kamu akan dijalankan dengan <code>args</code> kamu.</p></li></ul><p>Berikut ini beberapa contoh:</p><table><thead><tr><th>Image Entrypoint</th><th>Image Cmd</th><th>Container command</th><th>Container args</th><th>Command run</th></tr></thead><tbody><tr><td><code>[/ep-1]</code></td><td><code>[foo bar]</code></td><td>&lt;not set></td><td>&lt;not set></td><td><code>[ep-1 foo bar]</code></td></tr><tr><td><code>[/ep-1]</code></td><td><code>[foo bar]</code></td><td><code>[/ep-2]</code></td><td>&lt;not set></td><td><code>[ep-2]</code></td></tr><tr><td><code>[/ep-1]</code></td><td><code>[foo bar]</code></td><td>&lt;not set></td><td><code>[zoo boo]</code></td><td><code>[ep-1 zoo boo]</code></td></tr><tr><td><code>[/ep-1]</code></td><td><code>[foo bar]</code></td><td><code>[/ep-2]</code></td><td><code>[zoo boo]</code></td><td><code>[ep-2 zoo boo]</code></td></tr></tbody></table><h2 id=selanjutnya>Selanjutnya</h2><ul><li>Pelajari lebih lanjut tentang <a href=/id/docs/tasks/>mengatur Pod and Container</a>.</li><li>Pelajari lebih lanjut tentang <a href=/id/docs/tasks/debug-application-cluster/get-shell-running-container/>menjalankan perintah di dalam sebuah Container</a>.</li><li>Lihat <a href=/docs/reference/generated/kubernetes-api/v1.25/#container-v1-core>Container</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-82c93897176489678232542102daea40>4.6.2 - Mendefinisikan Variabel Lingkungan untuk sebuah Kontainer</h1><p>Laman ini menunjukkan bagaimana cara untuk mendefinisikan variabel lingkungan (<em>environment variable</em>) untuk sebuah Container di dalam sebuah Pod Kubernetes.</p><h2 id=sebelum-kamu-memulai>Sebelum kamu memulai</h2><p><p>Kamu harus memiliki klaster Kubernetes, dan perangkat baris perintah kubectl
juga harus dikonfigurasikan untuk berkomunikasi dengan klastermu. Jika kamu
belum memiliki klaster, kamu dapat membuatnya dengan menggunakan
<a href=/id/docs/tasks/tools/#minikube>minikube</a>,
atau kamu juga dapat menggunakan salah satu dari tempat mencoba Kubernetes berikut ini:</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>Bermain dengan Kubernetes</a></li></ul>Untuk melihat versi, tekan <code>kubectl version</code>.</p><h2 id=mendefinisikan-sebuah-variabel-lingkungan-untuk-sebuah-container>Mendefinisikan sebuah variabel lingkungan untuk sebuah Container</h2><p>Ketika kamu membuat sebuah Pod, kamu dapat mengatur variabel lingkungan untuk Container-Container yang berjalan di dalam sebuah Pod.
Untuk mengatur variabel lingkungan, sertakan bagian <code>env</code> atau <code>envFrom</code> pada berkas konfigurasi.</p><p>Dalam latihan ini, kamu membuat sebuah Pod yang menjalankan satu buah Container.
Berkas konfigurasi untuk Pod tersebut mendefinisikan sebuah variabel lingkungan dengan nama <code>DEMO_GREETING</code> yang bernilai <code>"Hello from the environment"</code>.
Berikut berkas konfigurasi untuk Pod tersebut:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/pods/inject/envars.yaml download=pods/inject/envars.yaml><code>pods/inject/envars.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-inject-envars-yaml")' title="Copy pods/inject/envars.yaml to clipboard"></img></div><div class=includecode id=pods-inject-envars-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>envar-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>purpose</span>:<span style=color:#bbb> </span>demonstrate-envars<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>envar-demo-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/google-samples/node-hello:1.0<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>DEMO_GREETING<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Hello from the environment&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>DEMO_FAREWELL<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Such a sweet sorrow&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><ol><li><p>Buatlah sebuah Pod berdasarkan berkas konfigurasi YAML tersebut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/inject/envars.yaml
</span></span></code></pre></div></li><li><p>Tampilkan Pod-Pod yang sedang berjalan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l <span style=color:#b8860b>purpose</span><span style=color:#666>=</span>demonstrate-envars
</span></span></code></pre></div><p>Keluarannya mirip seperti ini:</p><pre tabindex=0><code>NAME            READY     STATUS    RESTARTS   AGE
envar-demo      1/1       Running   0          9s
</code></pre></li><li><p>Dapatkan sebuah <em>shell</em> ke Container yang sedang berjalan di Pod kamu:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> -it envar-demo -- /bin/bash
</span></span></code></pre></div></li><li><p>Di <em>shell</em> kamu, jalankan perintah <code>printenv</code> untuk melihat daftar variabel lingkungannya.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>root@envar-demo:/# printenv
</span></span></code></pre></div><p>Keluarannya mirip seperti ini:</p><pre tabindex=0><code>NODE_VERSION=4.4.2
EXAMPLE_SERVICE_PORT_8080_TCP_ADDR=10.3.245.237
HOSTNAME=envar-demo
...
DEMO_GREETING=Hello from the environment
DEMO_FAREWELL=Such a sweet sorrow
</code></pre></li><li><p>Untuk keluar dari <em>shell</em> tersebut, masukkan perintah <code>exit</code>.</p></li></ol><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Variabel-variabel lingkungan yang diatur menggunakan bagian <code>env</code> atau <code>envFrom</code> akan mengesampingkan
variabel-variabel lingkungan yang ditentukan di dalam <em>image</em> kontainer.</div><h2 id=menggunakan-variabel-variabel-lingkungan-di-dalam-konfigurasi-kamu>Menggunakan variabel-variabel lingkungan di dalam konfigurasi kamu</h2><p>Variabel-variabel lingkungan yang kamu definisikan di dalam sebuah konfigurasi Pod dapat digunakan di tempat lain dalam konfigurasi, contohnya di dalam perintah-perintah dan argumen-argumen yang kamu atur dalam Container-Container milik Pod.
Pada contoh konfigurasi berikut, variabel-variabel lingkungan <code>GREETING</code>, <code>HONORIFIC</code>, dan <code>NAME</code> disetel masing-masing menjadi <code>Warm greetings to</code>, <code>The Most Honorable</code>, dan <code>Kubernetes</code>.
Variabel-variabel lingkungan tersebut kemudian digunakan dalam argumen CLI yang diteruskan ke Container <code>env-print-demo</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>print-greeting<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>env-print-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>bash<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>GREETING<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Warm greetings to&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>HONORIFIC<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;The Most Honorable&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>NAME<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Kubernetes&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;echo&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;$(GREETING) $(HONORIFIC) $(NAME)&#34;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div><p>Setelah dibuat, perintah <code>echo Warm greetings to The Most Honorable Kubernetes</code> dijalankan di Container tersebut.</p><h2 id=selanjutnya>Selanjutnya</h2><ul><li>Pelajari lebih lanjut tentang <a href=/docs/tasks/inject-data-application/environment-variable-expose-pod-information/>variabel lingkungan</a>.</li><li>Pelajari tentang <a href=/docs/user-guide/secrets/#using-secrets-as-environment-variables>menggunakan informasi rahasia sebagai variabel lingkungan</a>.</li><li>Lihat <a href=/docs/reference/generated/kubernetes-api/v1.25/#envvarsource-v1-core>EnvVarSource</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-7f9454a1e775548c23ee5b300a9218a3>4.6.3 - Mendistribusikan Kredensial dengan Aman Menggunakan Secret</h1><p>Laman ini menjelaskan bagaimana cara menginjeksi data sensitif, seperti kata sandi (<em>password</em>) dan kunci enkripsi, ke dalam Pod.</p><h2 id=sebelum-kamu-memulai>Sebelum kamu memulai</h2><p>Kamu harus memiliki klaster Kubernetes, dan perangkat baris perintah kubectl
juga harus dikonfigurasikan untuk berkomunikasi dengan klastermu. Jika kamu
belum memiliki klaster, kamu dapat membuatnya dengan menggunakan
<a href=/id/docs/tasks/tools/#minikube>minikube</a>,
atau kamu juga dapat menggunakan salah satu dari tempat mencoba Kubernetes berikut ini:</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>Bermain dengan Kubernetes</a></li></ul><h3 id=mengubah-data-rahasia-kamu-ke-dalam-representasi-base64>Mengubah data rahasia kamu ke dalam representasi Base64</h3><p>Misalnya kamu mempunyai dua buah data rahasia: sebuah nama pengguna <code>my-app</code> dan kata sandi
<code>39528$vdg7Jb</code>. Pertama, gunakan alat penyandian Base64 untuk mengubah nama pengguna kamu dan kata sandi ke dalam representasi Base64. Berikut ini contoh menggunakan program Base64 yang umum digunakan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>echo</span> -n <span style=color:#b44>&#39;my-app&#39;</span> | base64
</span></span><span style=display:flex><span><span style=color:#a2f>echo</span> -n <span style=color:#b44>&#39;39528$vdg7Jb&#39;</span> | base64
</span></span></code></pre></div><p>Hasil keluaran menampilkan representasi Base64 dari nama pengguna kamu yaitu <code>bXktYXBw</code>,
dan representasi Base64 dari kata sandi kamu yaitu <code>Mzk1MjgkdmRnN0pi</code>.</p><div class="alert alert-warning caution callout" role=alert><strong>Perhatian:</strong> Gunakan alat yang telah dipercayai oleh OS kamu untuk menghindari risiko dari penggunaan alat eksternal.</div><h2 id=membuat-secret>Membuat Secret</h2><p>Berikut ini adalah berkas konfigurasi yang dapat kamu gunakan untuk membuat Secret yang akan menampung nama pengguna dan kata sandi kamu:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/pods/inject/secret.yaml download=pods/inject/secret.yaml><code>pods/inject/secret.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-inject-secret-yaml")' title="Copy pods/inject/secret.yaml to clipboard"></img></div><div class=includecode id=pods-inject-secret-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>username</span>:<span style=color:#bbb> </span>bXktYXBw<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>password</span>:<span style=color:#bbb> </span>Mzk1MjgkdmRnN0pi<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><ol><li><p>Membuat Secret</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/inject/secret.yaml
</span></span></code></pre></div></li><li><p>Melihat informasi dari Secret:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get secret test-secret
</span></span></code></pre></div><p>Hasil keluaran:</p><pre tabindex=0><code>NAME          TYPE      DATA      AGE
test-secret   Opaque    2         1m
</code></pre></li><li><p>Melihat informasi detil dari Secret:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe secret test-secret
</span></span></code></pre></div><p>Hasil keluaran:</p><pre tabindex=0><code>Name:       test-secret
Namespace:  default
Labels:     &lt;none&gt;
Annotations:    &lt;none&gt;

Type:   Opaque

Data
====
password:   13 bytes
username:   7 bytes
</code></pre></li></ol><h3 id=membuat-secret-langsung-dengan-kubectl>Membuat Secret langsung dengan kubectl</h3><p>Jika kamu ingin melompati langkah penyandian dengan Base64, kamu dapat langsung membuat Secret yang sama dengan menggunakan perintah <code>kubectl create secret</code>. Contohnya:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret generic test-secret --from-literal<span style=color:#666>=</span><span style=color:#b44>&#39;username=my-app&#39;</span> --from-literal<span style=color:#666>=</span><span style=color:#b44>&#39;password=39528$vdg7Jb&#39;</span>
</span></span></code></pre></div><p>Tentu saja ini lebih mudah. Pendekatan yang mendetil setiap langkah di atas bertujuan untuk mendemonstrasikan apa yang sebenarnya terjadi pada setiap langkah.</p><h2 id=membuat-pod-yang-memiliki-akses-ke-data-secret-melalui-volume>Membuat Pod yang memiliki akses ke data Secret melalui Volume</h2><p>Berikut ini adalah berkas konfigurasi yang dapat kamu gunakan untuk membuat Pod:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/pods/inject/secret-pod.yaml download=pods/inject/secret-pod.yaml><code>pods/inject/secret-pod.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-inject-secret-pod-yaml")' title="Copy pods/inject/secret-pod.yaml to clipboard"></img></div><div class=includecode id=pods-inject-secret-pod-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-test-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># nama harus sesuai dengan nama Volume di bawah ini</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/secret-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># Data Secret diekspos ke Container di dalam Pod melalui Volume</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>test-secret<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><ol><li><p>Membuat Pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/inject/secret-pod.yaml
</span></span></code></pre></div></li><li><p>Verifikasikan apakah Pod kamu sudah berjalan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod secret-test-pod
</span></span></code></pre></div><p>Hasil keluaran:</p><pre tabindex=0><code>NAME              READY     STATUS    RESTARTS   AGE
secret-test-pod   1/1       Running   0          42m
</code></pre></li><li><p>Gunakan <em>shell</em> untuk masuk ke dalam Container yang berjalan di dalam Pod kamu:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> -i -t secret-test-pod -- /bin/bash
</span></span></code></pre></div></li><li><p>Data Secret terekspos ke Container melalui Volume yang dipasang (<em>mount</em>) pada
<code>/etc/secret-volume</code>.</p><p>Di dalam <em>shell</em> kamu, tampilkan berkas yang ada di dalam direktori <code>/etc/secret-volume</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Jalankan ini di dalam shell dalam Container</span>
</span></span><span style=display:flex><span>ls /etc/secret-volume
</span></span></code></pre></div><p>Hasil keluaran menampilkan dua buah berkas, masing-masing untuk setiap data Secret:</p><pre tabindex=0><code>password username
</code></pre></li><li><p>Di dalam <em>shell</em> kamu, tampilkan konten dari berkas <code>username</code> dan <code>password</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Jalankan ini di dalam shell dalam Container</span>
</span></span><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b44>&#34;</span><span style=color:#a2f;font-weight:700>$(</span> cat /etc/secret-volume/username <span style=color:#a2f;font-weight:700>)</span><span style=color:#b44>&#34;</span>
</span></span><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b44>&#34;</span><span style=color:#a2f;font-weight:700>$(</span> cat /etc/secret-volume/password <span style=color:#a2f;font-weight:700>)</span><span style=color:#b44>&#34;</span>
</span></span></code></pre></div><p>Hasil keluarannya adalah nama pengguna dan kata sandi kamu:</p><pre tabindex=0><code>my-app
39528$vdg7Jb
</code></pre></li></ol><h2 id=mendefinisikan-variabel-lingkungan-container-menggunakan-data-secret>Mendefinisikan variabel lingkungan Container menggunakan data Secret</h2><h3 id=mendefinisikan-variabel-lingkungan-container-menggunakan-data-dari-secret-tunggal>Mendefinisikan variabel lingkungan Container menggunakan data dari Secret tunggal</h3><ul><li><p>Definisikan variabel lingkungan sebagai pasangan <em>key-value</em> pada Secret:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret generic backend-user --from-literal<span style=color:#666>=</span>backend-username<span style=color:#666>=</span><span style=color:#b44>&#39;backend-admin&#39;</span>
</span></span></code></pre></div></li><li><p>Tentukan nilai <code>backend-username</code> yang didefinisikan di Secret ke variabel lingkungan <code>SECRET_USERNAME</code> di dalam spesifikasi Pod.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/pods/inject/pod-single-secret-env-variable.yaml download=pods/inject/pod-single-secret-env-variable.yaml><code>pods/inject/pod-single-secret-env-variable.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-inject-pod-single-secret-env-variable-yaml")' title="Copy pods/inject/pod-single-secret-env-variable.yaml to clipboard"></img></div><div class=includecode id=pods-inject-pod-single-secret-env-variable-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>env-single-secret<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>envars-test-container<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>SECRET_USERNAME<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>secretKeyRef</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>backend-user<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>backend-username<span style=color:#bbb>
   </span></span></span></code></pre></div></div></div></li><li><p>Membuat Pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f https://k8s.io/examples/pods/inject/pod-single-secret-env-variable.yaml
</span></span></code></pre></div></li><li><p>Di dalam <em>shell</em> kamu, tampilkan konten dari variabel lingkungan <code>SECRET_USERNAME</code> dari Container</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> -i -t env-single-secret -- /bin/sh -c <span style=color:#b44>&#39;echo $SECRET_USERNAME&#39;</span>
</span></span></code></pre></div><p>Hasil keluarannya</p><pre tabindex=0><code>backend-admin
</code></pre></li></ul><h3 id=mendefinisikan-variabel-lingkungan-container-dengan-data-dari-multipel-secret>Mendefinisikan variabel lingkungan Container dengan data dari multipel Secret</h3><ul><li><p>Seperti contoh sebelumnya, buat Secret terlebih dahulu.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret generic backend-user --from-literal<span style=color:#666>=</span>backend-username<span style=color:#666>=</span><span style=color:#b44>&#39;backend-admin&#39;</span>
</span></span><span style=display:flex><span>kubectl create secret generic db-user --from-literal<span style=color:#666>=</span>db-username<span style=color:#666>=</span><span style=color:#b44>&#39;db-admin&#39;</span>
</span></span></code></pre></div></li><li><p>Definisikan variabel lingkungan di dalam spesifikasi Pod.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/pods/inject/pod-multiple-secret-env-variable.yaml download=pods/inject/pod-multiple-secret-env-variable.yaml><code>pods/inject/pod-multiple-secret-env-variable.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-inject-pod-multiple-secret-env-variable-yaml")' title="Copy pods/inject/pod-multiple-secret-env-variable.yaml to clipboard"></img></div><div class=includecode id=pods-inject-pod-multiple-secret-env-variable-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>envvars-multiple-secrets<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>envars-test-container<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>BACKEND_USERNAME<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>secretKeyRef</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>backend-user<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>backend-username<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>DB_USERNAME<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>secretKeyRef</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>db-user<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>db-username<span style=color:#bbb>
   </span></span></span></code></pre></div></div></div></li><li><p>Membuat Pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f https://k8s.io/examples/pods/inject/pod-multiple-secret-env-variable.yaml
</span></span></code></pre></div></li><li><p>Di dalam <em>shell</em> kamu, tampilkan konten dari variabel lingkungan Container</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> -i -t envvars-multiple-secrets -- /bin/sh -c <span style=color:#b44>&#39;env | grep _USERNAME&#39;</span>
</span></span></code></pre></div><p>Hasil keluarannya</p><pre tabindex=0><code>DB_USERNAME=db-admin
BACKEND_USERNAME=backend-admin
</code></pre></li></ul><h2 id=mengonfigurasi-semua-pasangan-key-value-di-dalam-secret-sebagai-variabel-lingkungan-container>Mengonfigurasi semua pasangan <em>key-value</em> di dalam Secret sebagai variabel lingkungan Container</h2><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Fitur ini tersedia mulai dari Kubernetes v1.6 dan yang lebih baru.</div><ul><li><p>Membuat Secret yang berisi banyak pasangan <em>key-value</em></p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret generic test-secret --from-literal<span style=color:#666>=</span><span style=color:#b8860b>username</span><span style=color:#666>=</span><span style=color:#b44>&#39;my-app&#39;</span> --from-literal<span style=color:#666>=</span><span style=color:#b8860b>password</span><span style=color:#666>=</span><span style=color:#b44>&#39;39528$vdg7Jb&#39;</span>
</span></span></code></pre></div></li><li><p>Gunakan envFrom untuk mendefinisikan semua data Secret sebagai variabel lingkungan Container. <em>Key</em> dari Secret akan mennjadi nama variabel lingkungan di dalam Pod.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/pods/inject/pod-secret-envFrom.yaml download=pods/inject/pod-secret-envFrom.yaml><code>pods/inject/pod-secret-envFrom.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-inject-pod-secret-envfrom-yaml")' title="Copy pods/inject/pod-secret-envFrom.yaml to clipboard"></img></div><div class=includecode id=pods-inject-pod-secret-envfrom-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>envfrom-secret<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>envars-test-container<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>envFrom</span>:<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>secretRef</span>:<span style=color:#bbb>
    </span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-secret<span style=color:#bbb>
    </span></span></span></code></pre></div></div></div></li><li><p>Membuat Pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f https://k8s.io/examples/pods/inject/pod-secret-envFrom.yaml
</span></span></code></pre></div></li><li><p>Di dalam <em>shell</em> kamu, tampilkan variabel lingkungan Container <code>username</code> dan <code>password</code></p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> -i -t envfrom-secret -- /bin/sh -c <span style=color:#b44>&#39;echo &#34;username: $username\npassword: $password\n&#34;&#39;</span>
</span></span></code></pre></div><p>Hasil keluarannya</p><pre tabindex=0><code>username: my-app
password: 39528$vdg7Jb
</code></pre></li></ul><h3 id=referensi>Referensi</h3><ul><li><a href=/docs/reference/generated/kubernetes-api/v1.25/#secret-v1-core>Secret</a></li><li><a href=/docs/reference/generated/kubernetes-api/v1.25/#volume-v1-core>Volume</a></li><li><a href=/docs/reference/generated/kubernetes-api/v1.25/#pod-v1-core>Pod</a></li></ul><h2 id=selanjutnya>Selanjutnya</h2><ul><li>Pelajari lebih lanjut <a href=/id/docs/concepts/configuration/secret/>Secret</a>.</li><li>Pelajari lebih lanjut <a href=/id/docs/concepts/storage/volumes/>Volume</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-a78a5e7e765fd8c49c8f7c0d72499f72>4.7 - Menjalankan</h1><div class=lead>Menjalankan dan mengatur aplikasi stateless dan stateful.</div></div><div class=td-content><h1 id=pg-790ea02857492b3a822e981e93e3a98b>4.7.1 - Menjalankan Aplikasi Stateless Menggunakan Deployment</h1><p>Dokumen ini menunjukkan cara bagaimana cara menjalankan sebuah aplikasi menggunakan objek Deployment Kubernetes.</p><h2 id=tujuan>Tujuan</h2><ul><li>Membuat sebuah Deployment Nginx.</li><li>Menggunakan kubectl untuk mendapatkan informasi mengenai Deployment.</li><li>Mengubah Deployment.</li></ul><h2 id=sebelum-kamu-memulai>Sebelum kamu memulai</h2><p><p>Kamu harus memiliki klaster Kubernetes, dan perangkat baris perintah kubectl
juga harus dikonfigurasikan untuk berkomunikasi dengan klastermu. Jika kamu
belum memiliki klaster, kamu dapat membuatnya dengan menggunakan
<a href=/id/docs/tasks/tools/#minikube>minikube</a>,
atau kamu juga dapat menggunakan salah satu dari tempat mencoba Kubernetes berikut ini:</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>Bermain dengan Kubernetes</a></li></ul>Kubernetes servermu harus dalam versi yang sama atau lebih baru dari v1.9.
Untuk melihat versi, tekan <code>kubectl version</code>.</p><h2 id=membuat-dan-menjelajahi-deployment-nginx>Membuat dan Menjelajahi Deployment Nginx</h2><p>Kamu dapat menjalankan aplikasi dengan membuat sebuah objek Deployment Kubernetes, dan kamu
dapat mendeskripsikan sebuah Deployment di dalam berkas YAML. Sebagai contohnya, berkas
YAML berikut mendeskripsikan sebuah Deployment yang menjalankan <em>image</em> Docker nginx:1.14.2:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/application/deployment.yaml download=application/deployment.yaml><code>application/deployment.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("application-deployment-yaml")' title="Copy application/deployment.yaml to clipboard"></img></div><div class=includecode id=application-deployment-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb> </span><span style=color:#080;font-style:italic># for versions before 1.9.0 use apps/v1beta2</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># tells deployment to run 2 pods matching the template</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.7.9<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><ol><li><p>Buatlah sebuah Deployment berdasarkan berkas YAML:</p><pre><code> kubectl apply -f https://k8s.io/examples/application/deployment.yaml
</code></pre></li><li><p>Tampilkan informasi dari Deployment:</p><pre><code> kubectl describe deployment nginx-deployment
</code></pre><p>Keluaran dari perintah tersebut akan menyerupai:</p><pre><code> Name:     nginx-deployment
 Namespace:    default
 CreationTimestamp:  Tue, 30 Aug 2016 18:11:37 -0700
 Labels:     app=nginx
 Annotations:    deployment.kubernetes.io/revision=1
 Selector:   app=nginx
 Replicas:   2 desired | 2 updated | 2 total | 2 available | 0 unavailable
 StrategyType:   RollingUpdate
 MinReadySeconds:  0
 RollingUpdateStrategy:  1 max unavailable, 1 max surge
 Pod Template:
   Labels:       app=nginx
   Containers:
    nginx:
     Image:              nginx:1.14.2
     Port:               80/TCP
     Environment:        &lt;none&gt;
     Mounts:             &lt;none&gt;
   Volumes:              &lt;none&gt;
 Conditions:
   Type          Status  Reason
   ----          ------  ------
   Available     True    MinimumReplicasAvailable
   Progressing   True    NewReplicaSetAvailable
 OldReplicaSets:   &lt;none&gt;
 NewReplicaSet:    nginx-deployment-1771418926 (2/2 replicas created)
 No events.
</code></pre></li><li><p>Lihatlah daftar Pod-Pod yang dibuat oleh Deployment:</p><pre><code> kubectl get pods -l app=nginx
</code></pre><p>Keluaran dari perintah tersebut akan menyerupai:</p><pre><code> NAME                                READY     STATUS    RESTARTS   AGE
 nginx-deployment-1771418926-7o5ns   1/1       Running   0          16h
 nginx-deployment-1771418926-r18az   1/1       Running   0          16h
</code></pre></li><li><p>Tampilkan informasi mengenai Pod:</p><pre><code> kubectl describe pod &lt;nama-pod&gt;
</code></pre><p>dimana <code>&lt;nama-pod></code> merupakan nama dari Pod kamu.</p></li></ol><h2 id=mengubah-deployment>Mengubah Deployment</h2><p>Kamu dapat mengubah Deployment dengan cara mengaplikasikan berkas YAML yang baru.
Berkas YAML ini memberikan spesifikasi Deployment untuk menggunakan Nginx versi 1.16.1.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/application/deployment-update.yaml download=application/deployment-update.yaml><code>application/deployment-update.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("application-deployment-update-yaml")' title="Copy application/deployment-update.yaml to clipboard"></img></div><div class=includecode id=application-deployment-update-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb> </span><span style=color:#080;font-style:italic># untuk versi sebelum 1.9.0 gunakan apps/v1beta2</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.16.1<span style=color:#bbb> </span><span style=color:#080;font-style:italic># Memperbarui versi nginx dari 1.14.2 ke 1.16.1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><ol><li><p>Terapkan berkas YAML yang baru:</p><pre><code>  kubectl apply -f https://k8s.io/examples/application/deployment-update.yaml
</code></pre></li><li><p>Perhatikan bahwa Deployment membuat Pod-Pod dengan nama baru dan menghapus Pod-Pod lama:</p><pre><code>  kubectl get pods -l app=nginx
</code></pre></li></ol><h2 id=meningkatkan-jumlah-aplikasi-dengan-meningkatkan-ukuran-replika>Meningkatkan Jumlah Aplikasi dengan Meningkatkan Ukuran Replika</h2><p>Kamu dapat meningkatkan jumlah Pod di dalam Deployment dengan menerapkan
berkas YAML baru. Berkas YAML ini akan meningkatkan jumlah replika menjadi 4,
yang nantinya memberikan spesifikasi agar Deployment memiliki 4 buah Pod.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/application/deployment-scale.yaml download=application/deployment-scale.yaml><code>application/deployment-scale.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("application-deployment-scale-yaml")' title="Copy application/deployment-scale.yaml to clipboard"></img></div><div class=includecode id=application-deployment-scale-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb> </span><span style=color:#080;font-style:italic># untuk versi sebelum 1.9.0 gunakan apps/v1beta2</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>4</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># Memperbarui replica dari 2 menjadi 4</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><ol><li><p>Terapkan berkas YAML:</p><pre><code> kubectl apply -f https://k8s.io/examples/application/deployment-scale.yaml
</code></pre></li><li><p>Verifikasi Deployment kamu saat ini yang memiliki empat Pod:</p><pre><code> kubectl get pods -l app=nginx
</code></pre><p>Keluaran dari perintah tersebut akan menyerupai:</p><pre><code> NAME                               READY     STATUS    RESTARTS   AGE
 nginx-deployment-148880595-4zdqq   1/1       Running   0          25s
 nginx-deployment-148880595-6zgi1   1/1       Running   0          25s
 nginx-deployment-148880595-fxcez   1/1       Running   0          2m
 nginx-deployment-148880595-rwovn   1/1       Running   0          2m
</code></pre></li></ol><h2 id=menghapus-deployment>Menghapus Deployment</h2><p>Menghapus Deployment dengan nama:</p><pre><code>kubectl delete deployment nginx-deployment
</code></pre><h2 id=cara-lama-menggunakan-replicationcontroller>Cara Lama Menggunakan: ReplicationController</h2><p>Cara yang dianjurkan untuk membuat aplikasi dengan replika adalah dengan menggunakan Deployment,
yang nantinya akan menggunakan ReplicaSet. Sebelum Deployment dan ReplicaSet ditambahkan
ke Kubernetes, aplikasi dengan replika dikonfigurasi menggunakan <a href=/id/docs/concepts/workloads/controllers/replicationcontroller/>ReplicationController</a>.</p><h2 id=selanjutnya>Selanjutnya</h2><ul><li>Pelajari lebih lanjut mengenai <a href=/id/docs/concepts/workloads/controllers/deployment/>objek Deployment</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-f5f2f7a74377a9d45325c5253353fa8f>4.7.2 - Menghapus Paksa Pod StatefulSet</h1><p>Laman ini menjelaskan bagaimana cara menghapus Pod yang menjadi bagian dari sebuah <a class=glossary-tooltip title='Melakukan proses manajemen deployment dan scaling dari sebuah set Pod, serta menjamin mekanisme ordering dan keunikan dari Pod ini.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/statefulset/ target=_blank aria-label='stateful set'>stateful set</a>, dan menjelaskan pertimbangan yang harus diperhatikan saat melakukannya.</p><h2 id=sebelum-kamu-memulai>Sebelum kamu memulai</h2><ul><li>Ini merupakan tugas yang cukup rumit dan memiliki potensi melanggar beberapa properti yang melekat dari StatefulSet.</li><li>Sebelum melanjutkan, pastikan kamu paham dengan pertimbangan yang disebutkan di bawah ini.</li></ul><h2 id=pertimbangan-statefulset>Pertimbangan StatefulSet</h2><p>Pada operasi normal dari StatefulSet, <strong>tidak pernah</strong> ada kebutuhan untuk menghapus paksa sebuah Pod StatefulSet. <a href=/id/docs/concepts/workloads/controllers/statefulset/><em>Controller</em> StatefulSet</a> bertanggung jawab terhadap pembuatan, penyekalaan dan penghapusan terhadap anggota dari StatefulSet. <em>Controller</em> akan berusaha menjaga agar jumlah Pod yang ditentukan dari 0 hingga N-1 hidup dan siap sedia. StatefulSet memastikan bahwa, pada waktu kapanpun, akan ada minimal satu Pod dengan identitas yang telah ditetapkan berjalan pada klaster. Hal ini direferensikan sebagai semantik <em>at most one</em> yang disediakan StatefulSet.</p><p>Penghapusan paksa secara manual harus dilakukan dengan hati-hati, karena hal tersebut berpotensi melanggar semantik <em>at most one</em> yang melekat pada StatefulSet. StatefulSet dapat digunakan untuk menjalankan aplikasi terklaster dan terdistribusi yang membutuhkan identitas jaringan dan penyimpanan yang stabil dan tetap. Aplikasi-aplikasi ini biasanya memiliki konfigurasi yang tergantung dengan sejumlah anggota dengan identitas yang tetap. Memiliki banyak anggota dengan identitas yang sama berpotensi menimbulkan kerusakan dan kehilangan data (contohnya skenario <em>split brain</em> pada sistem berbasis kuorum).</p><h2 id=menghapus-pod>Menghapus Pod</h2><p>Kamu dapat melakukan penghapusan Pod secara <em>graceful</em> dengan perintah berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pods &lt;pod&gt;
</span></span></code></pre></div><p>Agar perintah di atas mengarah ke terminasi secara <em>graceful</em>, Pod <strong>tidak boleh</strong> menspesifikasikan <code>pod.Spec.TerminationGracePeriodSeconds</code> dengan nilai 0. Praktik untuk mengatur nilai <code>pod.Spec.TerminationGracePeriodSeconds</code> menjadi 0 detik merupakan hal yang tidak aman dan sangat tidak disarankan untuk Pod StatefulSet. Penghapusan secara <em>graceful</em> itu aman dan akan memastikan bahwa Pod <a href=/id/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination>akan mati secara <em>gracefully</em></a> sebelum kubelet menghapus nama dari apiserver.</p><p>Kubernetes (versi 1.5 atau lebih baru) tidak akan menghapus Pod hanya karena Node tidak dapat dijangkau. Pod yang berjalan pada Node yang tidak dapat dijangkau akan memasuki keadaan 'Terminating' atau 'Unknown' setelah <a href=/id/docs/admin/node/#node-condition>waktu habis</a>. Pod juga dapat memasuki keadaan ini saat pengguna berusaha melakukan penghapusan secara <em>graceful</em> terhadap Pod pada Node yang tidak dapat dijangkau. Cara yang hanya dapat dilakukan untuk menghapus Pod pada keadaan tersebut dari apiserver adalah:</p><ul><li>Objek Node telah dihapus (baik oleh kamu, atau oleh <a href=/id/docs/admin/node><em>Controller</em> Node</a>).<br></li><li>Kubelet pada Node yang tidak responsif akan menanggapi, lalu mematikan Pod dan menghapusnya dari apiserver.<br></li><li>Penghapusan paksa Pod oleh pengguna.</li></ul><p>Praktik terbaik yang direkomendasikan adalah menggunakan pendekatan pertama atau kedua. Jika sebuah Node telah terkonfirmasi mati (contohnya terputus dari jaringan secara permanen, dimatikan, dll), maka objek Node dihapus. Jika Node mengalami partisi jaringan, maka coba selesaikan masalah ini atau menunggu masalah itu terselesaikan. Saat partisi terselesaikan, kubelet akan menyelesaikan penghapusan Pod serta membebaskan namanya dari apiserver.</p><p>Normalnya, sistem akan menyelesaikan penghapusan saat Pod tidak lagi berjalan pada Node, atau Node telah dihapus oleh administrator. Kamu dapat mengabaikan hal ini dengan menghapus paksa Pod.</p><h3 id=penghapusan-paksa>Penghapusan Paksa</h3><p>Penghapusan paksa <strong>tidak</strong> menunggu konfirmasi dari kubelet bahwa Pod telah diterminasi. Terlepas dari apakah penghapusan paksa sukses mematikan sebuah Pod, namanya akan segera dibebaskan dari apiserver. Hal ini berakibat <em>controller</em> StatefulSet akan membuat Pod pengganti dengan identitas yang sama; ini dapat menimbulkan duplikasi terhadap Pod apabila ternyata Pod tersebut masih berjalan, dan jika Pod tersebut masih dapat berkomunikasi dengan anggota Statefulset lainnya, hal ini berakibat terjadi pelanggaran semantik <em>at most one</em> dari StatefulSet yang telah dijamin.</p><p>Saat kamu menghapus paksa sebuah Pod StatefulSet, berarti kamu menjamin bahwa Pod tersebut tidak akan pernah lagi berkomunikasi dengan Pod lain pada StatefulSet dan namanya dapat dibebaskan secara aman untuk pembuatan penggantinya.</p><p>Jika kamu ingin menghapus paksa Pod dengan menggunakan kubectl versi >= 1.5, lakukan perintah berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pods &lt;pod&gt; --grace-period<span style=color:#666>=</span><span style=color:#666>0</span> --force
</span></span></code></pre></div><p>Jika kamu menggunakan kubectl &lt;= 1.4, kamu harus menghilangkan pilihan <code>--force</code> dan gunakan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pods &lt;pod&gt; --grace-period<span style=color:#666>=</span><span style=color:#666>0</span>
</span></span></code></pre></div><p>Jika setelah perintah ini dijalankan dan Pod tetap berada pada kondisi <code>Unknown</code>, gunakan perintah berikut untuk menghapus Pod dari klaster:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl patch pod &lt;pod&gt; -p <span style=color:#b44>&#39;{&#34;metadata&#34;:{&#34;finalizers&#34;:null}}&#39;</span>
</span></span></code></pre></div><p>Selalu jalankan penghapusan paksa Pod StatefulSet dengan hati-hati dan penuh pemahaman terhadap risiko yang dapat timbul.</p><h2 id=selanjutnya>Selanjutnya</h2><p>Pelajari lebih lanjut <a href=/docs/tasks/debug-application-cluster/debug-stateful-set/><em>debugging</em> StatefulSet</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-0c0bb1bd76d2a9069e50e2cec6d20c2a>4.7.3 - HorizontalPodAutoscaler</h1><p>HorizontalPodAutoscaler secara otomatis akan memperbanyak jumlah Pod di dalam ReplicationController, Deployment,
ReplicaSet ataupun StatefulSet berdasarkan hasil observasi penggunaan CPU(atau, dengan
<a href=https://git.k8s.io/community/contributors/design-proposals/instrumentation/custom-metrics-api.md>metrik khusus</a>, pada beberapa aplikasi yang menyediakan metrik).
Perlu dicatat bahwa HorizontalPodAutoscale tidak dapat diterapkan pada objek yang tidak dapat diperbanyak, seperti DeamonSets.</p><p>HorizontalPodAutoscaler diimplementasikan sebagai Kubernetes API <em>resource</em> dan sebuah <em>controller</em>.
<em>Resource</em> tersebut akan menentukan perilaku dari <em>controller</em>-nya.
Kontroler akan mengubah jumlah replika pada ReplicationController atau pada Deployment untuk menyesuaikan dengan hasil observasi rata-rata
penggunaan CPU sesuai dengan yang ditentukan oleh pengguna.</p><h2 id=bagaimana-cara-kerja-horizontalpodautoscaler>Bagaimana cara kerja HorizontalPodAutoscaler?</h2><p><img src=/images/docs/horizontal-pod-autoscaler.svg alt="Diagram HorizontalPodAutoscaler"></p><p>HorizontalPodAutoscaler diimplementasikan sebagai sebuah <em>loop</em> kontrol, yang secara
berkala dikontrol oleh <em>flag</em> <code>--horizontal-pod-autoscaler-sync-period</code> pada <em>controller manager</em>
(dengan nilai bawaan 15 detik).</p><p>Dalam setiap periode, <em>controller manager</em> melakukan kueri penggunaan sumber daya dan membandingkan
dengan metrik yang dispesifikasikan pada HorizontalPodAutoscaler. <em>Controller manager</em> mendapat
metrik dari sumber daya metrik API (untuk metrik per Pod) atau dari API metrik khusus (untuk semua metrik lainnya).</p><ul><li><p>Untuk metrik per Pod (seperti CPU), <em>controller</em> mengambil metrik dari sumber daya metrik API
untuk setiap Pod yang ditargetkan oleh HorizontalPodAutoscaler. Kemudian, jika nilai target penggunaan ditentukan,
maka <em>controller</em> akan menghitung nilai penggunaan sebagai persentasi dari pengguaan sumber daya dari Container
pada masing-masing Pod. Jika target nilai mentah (<em>raw value</em>) ditentukan, maka nilai metrik mentah (<em>raw metric</em>)
akan digunakan secara langsung. <em>Controller</em> kemudian mengambil nilai rata-rata penggunaan atau nilai mentah (tergantung
dengan tipe target yang ditentukan) dari semua Pod yang ditargetkan dan menghasilkan perbandingan yang
digunakan untuk menentukan jumlah replika yang akan diperbanyak.</p><p>Perlu dicatat bahwa jika beberapa Container pada Pod tidak memiliki nilai <em>resource request</em>, penggunaan CPU
pada Pod tersebut tidak akan ditentukan dan <em>autoscaler</em> tidak akan melakukan tindakan apapun untuk metrik tersebut.
Perhatikan pada bagian <a href=#detail-algoritma>detail algoritma</a> di bawah ini untuk informasi lebih lanjut mengenai
cara kerja algoritma <em>autoscale</em>.</p></li><li><p>Untuk metrik khusus per Pod, <em>controller</em> bekerja sama seperti sumber daya metrik per Pod,
kecuali Pod bekerja dengan nilai mentah, bukan dengan nilai utilisasi (<em>utilization values</em>).</p></li><li><p>Untuk objek metrik dan metrik eksternal, sebuah metrik diambil, dimana metrik tersebut menggambarkan
objek tersebut. Metrik ini dibandingkan dengan nilai target untuk menghasilkan perbandingan seperti di atas.
Pada API <code>autoscaling/v2beta2</code>, nilai perbandingan dapat secara opsional dibagi dengan jumlah Pod
sebelum perbandingan dibuat.</p></li></ul><p>Pada normalnya, HorizontalPodAutoscaler mengambil metrik dari serangkaian API yang sudah diagregat
(<code>custom.metric.k8s.io</code>, dan <code>external.metrics.k8s.io</code>). API <code>metrics.k8s.io</code> biasanya disediakan oleh
<em>metric-server</em>, dimana <em>metric-server</em> dijalankan secara terpisah. Perhatikan
<a href=/docs/tasks/debug-application-cluster/resource-metrics-pipeline/#metrics-server><em>metrics-server</em></a> sebagai petunjuk.
HorizontalPodAutoscaler juga mengambil metrik dari Heapster secara langsung.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.11 [deprecated]</code></div><p>Pengambian metrik dari Heapster tidak didukung lagi pada Kubernetes versi 1.11.</div><p>Perhatikan <a href=#dukungan-untuk-api-metrik>Dukungan untuk API metrik</a> untuk lebih detail.</p><p><em>Autoscaler</em> mengkases <em>controller</em> yang dapat diperbanyak (seperti ReplicationController, Deployment, dan ReplicaSet)
dengan menggunakan <em>scale sub-resource</em>. Untuk lebih detail mengenai <em>scale sub-resource</em> dapat ditemukan
<a href=https://git.k8s.io/community/contributors/design-proposals/autoscaling/horizontal-pod-autoscaler.md#scale-subresource>di sini</a>.</p><h3 id=detail-algoritma>Detail Algoritma</h3><p>Dari sudut pandang paling sederhana, <em>controller</em> HorizontalPodAutoscaler mengoperasikan
perbandingan metrik yang diinginkan dengan kedaan metrik sekarang.</p><pre tabindex=0><code>desiredReplicas = ceil[currentReplicas * ( currentMetricValue / desiredMetricValue )]
</code></pre><p>Sebagai contoh, jika nilai metrik sekarang adalah <code>200m</code> dan nilai metrik yang
diinginkan adalah <code>100m</code>, jumlah replika akan ditambah dua kali lipat,
karena <code>200.0 / 100.0 == 2.0</code>. Jika nilai metrik sekarang adalah <code>50m</code>,
maka jumlah replika akan dikurangi setengah, karena <code>50.0 / 100.0 == 0.5</code>.
Kita tetap memperbanyak replika (<em>scale</em>) jika nilai perbandingan mendekati 1.0 (dalam toleransi yang
dapat dikonfigurasi secata global, dari <em>flag</em> <code>--horizontal-pod-autoscaler-tolerance</code>
dengan nilai bawaan 0.1.</p><p>Ketika <code>targetAverageValue</code> (nilai target rata-rata) atau <code>targetAverageUtilization</code>
(target penggunaan rata-rata) ditentukan, <code>currentMetricValue</code> (nilai metrik sekaraang)
dihitung dengan mengambil rata-rata dari metrik dari semua Pod yang ditargetkan oleh
HorizontalPodAutoscaler. Sebelum mengecek toleransi dan menentukan nilai akhir,
kita mengambil kesiapan Pod dan metrik yang hilang sebagai pertimbangan.</p><p>Semua Pod yang memiliki waktu penghapusan (Pod dalam proses penutupan)
dan semua Pod yang mengalami kegagalan akan dibuang.</p><p>Jika ada metrik yang hilang dari Pod, maka Pod akan dievaluasi nanti.
Pod dengan nilai metrik yang hilang akan digunakan untuk menyesuaikan
jumlah akhir Pod yang akan diperbanyak atau dikurangi.</p><p>Ketika <em>scaling</em> dilakukan karena CPU, jika terdapat Pod yang akan siap (dengan kata lain
Pod tersebut sedang dalam tahap inisialisasi) <em>atau</em> metrik terakhir dari Pod
adalah metrik sebelum Pod dalam keadaan siap, maka Pod tersebut juga
akan dievaluasi nantinya.</p><p>Akibat keterbatasan teknis, <em>controller</em> HorizontalPodAutoscaler tidak dapat
menentukan dengan tepat kapan pertama kali Pod akan dalam keadaan siap
ketika menentukan apakah metrik CPU tertentu perlu dibuang. Sebaliknya,
HorizontalPodAutoscaler mempertimbangkan sebuah Pod "tidak dalam keadaan siap"
jika Pod tersebut dalam keadaan tidak siap dan dalam transisi ke status tidak
siap dalam waktu singkat, rentang waktu dapat dikonfigurasi, sejak Pod tersebut dijalankan.
Rentang waktu tersebut dapat dikonfigurasi dengan <em>flag</em> <code>--horizontal-pod-autoscaler-initial-readiness-delay</code>
dan waktu bawaannya adalah 30 detik. Ketika suatu Pod sudah dalam keadaan siap,
Pod tersebut mempertimbangkan untuk siap menjadi yang pertama jika itu terjadi dalam
waktu yang lebih lama, rentang waktu dapat dikonfigurasi, sejak Pod tersebut dijalankan.
Rentang waktu tersebut dapat dikonfigurasi dengan <em>flag</em> <code>--horizontal-pod-autoscaler-cpu-initialization-period</code>
dan nilai bawaannya adalah 5 menit.</p><p>Skala perbandingan dasar <code>currentMetricValue / desiredMetricValue</code>
dihitung menggunakan Pod yang tersisa yang belum disisihkan atau dibuang dari
kondisi di atas.</p><p>Jika terdapat metrik yang hilang, kita menghitung ulang rata-rata dengan lebih
konservatif, dengan asumsi Pod mengkonsumsi 100% dari nilai yang diharapkan
jika jumlahnya dikurangi (<em>scale down</em>) dan 0% jika jumlahnya diperbanyak (<em>scale up</em>).
Ini akan mengurangi besarnya kemungkinan untuk <em>scale</em>.</p><p>Selanjutnya, jika terdapat Pod dalam keadaan tidak siap, dan kita akan
memperbanyak replikas (<em>scale up</em>) tanpa memperhitungkan metrik yang hilang atau Pod yang tidak dalam
keadaan siap, kita secara konservatif mengasumsikan Pod yang tidak dalam keadaan siap
mengkonsumsi 0% dari metrik yang diharapkan, akhirnya meredam jumlah replika yang diperbanyak (<em>scale up</em>).</p><p>Seteleh memperhitungkan Pod yang tidak dalam keadaan siap dan metrik yang hilang,
kita menghitung ulang menggunakan perbandingan. Jika perbandingan yang baru membalikkan
arah <em>scale</em>-nya atau masih di dalam toleransi, kita akan melakukan <em>scale</em> dengan tepat. Jika tidak,
kita menggunakan perbandingan yang baru untuk memperbanyak atau mengurangi jumlah replika.</p><p>Perlu dicatat bahwa nilai asli untuk rata-rata penggunaan dilaporkan kembali melalui
status HorizontalPodAutoscaler, tanpa memperhitungkan Pod yang tidak dalam keadaan siap atau
metrik yang hilang, bahkan ketika perbandingan yang baru digunakan.</p><p>Jika beberapa metrik ditentukan pada sebuah HorizontalPodAutoscaler, perhitungan
dilakukan untuk setiap metrik dan nilai replika terbesar yang diharapkan akan dipilih.
Jika terdapat metrik yang tidak dapat diubah menjadi jumlah replika yang diharapkan
(contohnya terdapat kesalahan ketika mengambil metrik dari API metrik) dan pengurangan replika
disarankan dari metrik yang dapat diambil, maka <em>scaling</em> akan diabaikan. Ini berarti
HorizontalPodAutoscaler masih mampu untuk memperbanyak replika jika satu atau lebih metrik
memberikan sebuah <code>desiredReplicas</code> lebih besar dari nilai yang sekarang.</p><p>Pada akhirnya, sebelum HorizontalPodAutoscaler memperbanyak target, rekomendasi <em>scaling</em> akan
dicatat. <em>Controller</em> mempertimbangkan semua rekomendasi dalam rentang waktu yang dapat
dikonfigurasi untuk memilih rekomendasi tertinggi. Nilai ini dapat dikonfigurasi menggunakan
<em>flag</em> <code>--horizontal-pod-autoscaler-downscale-stabilization</code>, dengan nilai bawaan
5 menit. Ini berarti pengurangan replika akan terjadi secara bertahap, untuk mengurangi dampak dari
perubahan nilai metrik yang cepat.</p><h2 id=objek-api>Objek API</h2><p>HorizontalPodAutoscaler adalah sebuah API dalam grup <code>autoscaling</code> pada Kubernetes.
Versi stabil, yang hanya mendukung untuk <em>autoscale</em> CPU, dapat ditemukan pada versi
API <code>autoscaling/v1</code>.</p><p>Versi <em>beta</em>, yang mendukung untuk <em>scaling</em> berdasarkan memori dan metrik khusus,
dapat ditemukan pada <code>autoscaling/v2beta2</code>. <em>Field</em> yang baru diperkenalkan pada
<code>autoscaling/v2beta2</code> adalah <em>preserved</em> sebagai anotasi ketika menggunakan <code>autoscaling/v1</code>.</p><p>Ketika kamu membuat sebuah HorizontalPodAutoscaler, pastikan nama yang ditentukan adalah valid
<a href=/id/docs/concepts/overview/working-with-objects/names#nama>nama subdomain DNS</a>.
Untuk lebih detail tentang objek API ini dapat ditemukan di
<a href=https://git.k8s.io/community/contributors/design-proposals/autoscaling/horizontal-pod-autoscaler.md#horizontalpodautoscaler-object>Objek HorizontalPodAutoscaler</a>.</p><h2 id=dukungan-untuk-horizontalpodautoscaler-pada-kubectl>Dukungan untuk HorizontalPodAutoscaler pada kubectl</h2><p>Seperti sumber daya API lainnya, HorizontalPodAutoscaler didukung secara bawaan oleh <code>kubectl</code>.
Kita dapat membuat <em>autoscaler</em> yang baru dengan menggunakan perintah <code>kubectl create</code>.
Kita dapat melihat daftar <em>autoscaler</em> dengan perintah <code>kubectl get hpa</code> dan melihat deskripsi
detailnya dengan perintah <code>kubectl describe hpa</code>. Akhirnya, kita dapat menghapus <em>autoscaler</em>
meggunakan perintah <code>kubectl delete hpa</code>.</p><p>Sebagai tambahan, terdapat sebuah perintah khusus <code>kubectl autoscaler</code> untuk mempermudah pembuatan
HorizontalPodAutoscaler. Sebagai contoh, mengeksekusi
<code>kubectl autoscaler rs foo --min=2 --max=5 --cpu-percent=80</code> akan membuat sebuah <em>autoscaler</em> untuk
ReplicaSet <em>foo</em>, dengan target pengguaan CPU <code>80%</code> dan jumlah replika antara 2 sampai dengan 5.
Dokumentasi lebih detail tentang <code>kubectl autoscaler</code> dapat ditemukan di
<a href=/docs/reference/generated/kubectl/kubectl-commands/#autoscale>sini</a>.</p><h2 id=autoscaling-ketika-rolling-update>Autoscaling ketika Rolling Update</h2><p>Saat ini, dimungkinkan untuk melakukan <em>rolling update</em> menggunakan objek Deployment, yang akan
mengatur ReplicaSet untuk kamu. HorizontalPodAutoscaler hanya mendukung pendekatan terakhir:
HorizontalPodAutoscaler terikat dengan objek Deployment, yang mengatur seberapa besar dari objek Deployment tersebut,
dan Deployment bertugas untuk mengatur besar dari ReplicaSet.</p><p>HorizontalPodAutoscaler tidak bekerja dengan <em>rolling update</em> yang menggunakan manipulasi
pada ReplicationContoller secara langsung, dengan kata lain kamu tidak bisa mengikat
HorizontalPodAutoscaler dengan ReplicationController dan melakukan <em>rolling update</em>.
Alasan HorizontalPodAutoscaler tidak bekerja ketika <em>rolling update</em> membuat ReplicationController
yang baru adalah HorizontalPodAutoscaler tidak akan terikat dengan ReplicationController yang baru tersebut.</p><h2 id=dukungan-untuk-cooldown-penundaan>Dukungan untuk <em>Cooldown</em> / Penundaan</h2><p>Ketika mengolah <em>scaleing</em> dari sebuah grup replika menggunakan HorizonalPodAutoscaler,
jumlah replika dimungkinkan tetap berubah secara sering disebabkan oleh perubahan dinamis
dari metrik yang dievaluasi. Hal ini sering disebut dengan <em>thrashing</em>.</p><p>Mulai dari versi 1.6, operator klaster dapat mengatasi masalah ini dengan mengatur
konfigurasi HorizontalPodAutoscaler global sebagai <em>flag</em> <code>kube-controller-manager</code>.</p><p>Mulai dari versi 1.12, sebuah algoritma pembaruan baru menghilangkan kebutuhan terhadap
penundaan memperbanyak replika (<em>upscale</em>).</p><ul><li><code>--horizontal-pod-autoscaler-downscale-stabilization</code>: Nilai untuk opsi ini adalah
sebuah durasi yang menentukan berapa lama <em>autoscaler</em> menunggu sebelum operasi
pengurangan replika (<em>downscale</em>) yang lain dilakukan seteleh operasi sekarang selesai. Nilai bawaannya
adalah 5 menit (<code>5m0s</code>).</li></ul><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Ketika mengubah nilai paramater ini, sebuah operator klaster sadar akan kemungkinan
konsekuensi. Jika waktu penundaan diset terlalu lama, kemungkinan akan membuat
HorizontalPodAutoscaler tidak responsif terharap perubahan beban kerja. Namun, jika
waktu penundaan diset terlalu cepat, kemungkinan replikasi akan <em>trashing</em> seperti
biasanya.</div><h2 id=dukungan-untuk-beberapa-metrik>Dukungan untuk Beberapa Metrik</h2><p>Kubernetes versi 1.6 menambah dukungan untuk <em>scaling</em> berdasarkan beberapa metrik.
Kamu dapat menggunakan API versi <code>autoscaling/v2beta2</code> untuk menentukan beberapa metrik
yang akan digunakan HorizontalPodAutoscaler untuk menambah atau mengurangi jumlah replika.
Kemudian, <em>controller</em> HorizontalPodAutoscaler akan mengevaluasi setiap metrik dan menyarankan jenis
<em>scaling</em> yang baru berdasarkan metrik tersebut. Jumlah replika terbanyak akan digunakan untuk <em>scale</em>
yang baru.</p><h2 id=dukungan-untuk-metrik-khusus>Dukungan untuk Metrik Khusus</h2><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Kubernetes versi 1.2 menambah dukungan <em>alpha</em> untuk melakukan <em>scaling</em> berdasarkan metrik
yang spesifik dengan aplikasi menggunakan anotasi khusus. Dukungan untuk anotasi ini
dihilangkan pada Kubernetes versi 1.6 untuk mendukung API <em>autoscaling</em> yang baru. Selama
cara lama untuk mendapatkan metrik khusus masih tersedia, metrik ini tidak akan tersedia untuk
digunakan oleh HorizontalPodAutoscaler dan anotasi sebelumnya untuk menentukan metrik khusus untuk
<em>scaling</em> tidak lagi digunakan oleh <em>controller</em> HorizontalPodAutscaler.</div><p>Kubernetes versi 1.6 menambah dukungan untuk menggunakan metrik khusus pada HorizontalPodAutoscaler.
Kamu dapat menambahkan metrik khusus untuk HorizontalPodAutoscaler pada API versi <code>autoscaling/v2beta2</code>.
Kubernetes kemudian memanggil API metrik khusus untuk mengambil nilai dari metrik khusus.</p><p>Lihat <a href=#dukungan-untuk-api-metrik>Dukungan untuk API metrik</a> untuk kubutuhannya.</p><h2 id=dukungan-untuk-api-metrik>Dukungan untuk API metrik</h2><p>Secara standar, <em>controller</em> HorizontalPodAutoscaler mengambil metrik dari beberapa API. Untuk dapat
mengakses API ini, administrator klaster harus memastikan bahwa:</p><ul><li><p><a href=/docs/tasks/access-kubernetes-api/configure-aggregation-layer/>API Later Pengumpulan</a> diaktifkan.</p></li><li><p>API berikut ini terdaftar:</p><ul><li><p>Untuk metrik sumber daya, ini adalah API <code>metrics.k8s.io</code>, pada umumnya disediakan oleh
<a href=https://github.com/kubernetes-incubator/metrics-server>metrics-server</a>. API tersebut dapat
diaktifkan sebagai <em>addon</em> atau tambahan pada klaster.</p></li><li><p>Untuk metrik khusus, ini adalah API <code>custom.metrics.k8s.io</code>. API ini disediakan oleh API
adaptor server yang disediakan oleh vendor yang memberi solusi untuk metrik. Cek dengan
<em>pipeline</em> metrikmu atau <a href=https://github.com/kubernetes/metrics/blob/master/IMPLEMENTATIONS.md#custom-metrics-api>daftar solusi yang sudah diketahui</a>. Jika kamu ingin membuat sendiri, perhatikan
<a href=https://github.com/kubernetes-incubator/custom-metrics-apiserver><em>boilerplate</em> berikut</a> untuk memulai.</p></li><li><p>Untuk metrik eksternal, ini adalah API <code>external.metrics.k8s.io</code>. API ini mungkin disediakan oleh penyedia
metrik khusus diatas.</p></li></ul></li><li><p>Nilai dari <code>--horizontal-pod-autoscaler-use-rest-clients</code> adalah <code>true</code> atau tidak ada. Ubah nilai tersebut menjadi
<code>false</code> untuk mengubah ke <em>autoscaling</em> berdasarkan Heapster, dimana ini sudah tidak didukung lagi.</p></li></ul><p>Untuk informasi lebih lanjut mengenai metrik-metrik ini dan bagaimana perbedaan setiap metrik, perhatikan proposal
desain untuk <a href=https://github.com/kubernetes/design-proposals-archive/blob/main/autoscaling/hpa-v2.md>HPA V2</a>,
<a href=https://github.com/kubernetes/design-proposals-archive/blob/main/instrumentation/custom-metrics-api.md>custom.metrics.k8s.io</a>
dan <a href=https://github.com/kubernetes/design-proposals-archive/blob/main/instrumentation/external-metrics-api.md>external.metrics.k8s.io</a>.</p><p>Untuk contoh bagaimana menggunakan metrik-metrik ini, perhatikan <a href=/docs/tasks/run-application/horizontal-pod-autoscale-walkthrough/#autoscaling-on-multiple-metrics-and-custom-metrics>panduan penggunaan metrik khusus</a>
dan <a href=/docs/tasks/run-application/horizontal-pod-autoscale-walkthrough/#autoscaling-on-metrics-not-related-to-kubernetes-objects>panduan penggunaan metrik eksternal</a>.</p><h2 id=dukungan-untuk-perilaku-scaling-yang-dapat-dikonfigurasi>Dukungan untuk Perilaku <em>Scaling</em> yang dapat Dikonfigurasi</h2><p>Mulai dari versi <a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-autoscaling/853-configurable-hpa-scale-velocity/README.md>v1.18</a>, API <code>v2beta2</code> mengizinkan perilaku <em>scaling</em> dapat
dikonfigurasi melalui <em>field</em> <code>behavior</code> pada HorizontalPodAutoscaler. Perilaku <em>scaling up</em> dan <em>scaling down</em>
ditentukan terpisah pada <em>field</em> <code>slaceUp</code> dan <em>field</em> <code>scaleDown</code>, dibawah dari <em>field</em> <code>behavior</code>.
Sebuah stabilisator dapat ditentukan untuk kedua arah <em>scale</em> untuk mencegah perubahan replika yang terlalu
berbeda pada target <em>scaling</em>. Menentukan <em>scaling policies</em> akan mengontrol perubahan replika
ketika <em>scaling</em>.</p><h3 id=scaling-policies>Scaling Policies</h3><p>Satu atau lebih <em>scaling policies</em> dapat ditentukan pada <em>field</em> <code>behavior</code>. Ketika beberapa
<em>policies</em> ditentukan, <em>policy</em> yang mengizinkan <em>scale</em> terbesar akan dipilih secara <em>default</em>.
Contoh berikut menunjukkan perilaku ketika mengurangi replika:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>behavior</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scaleDown</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>policies</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Pods<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#666>4</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>60</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Percent<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>60</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Ketika jumlah Pod lebih besar dari 40, <em>policy</em> kedua akan digunakan untuk <em>scaling down</em>.
Misalnya, jika terdapat 80 replika dan target sudah di <em>scale down</em> ke 10 replika, 8 replika
akan dikurangi pada tahapan pertama. Pada iterasi berikutnya, ketika jumlah replika adalah 72,
10% dari Pod adalah 7.2 tetapi akan dibulatkan menjadi 8. Dalam setiap iterasi pada <em>controller</em>
<em>autoscaler</em> jumlah Pod yang akan diubah akan dihitung ulang berdarkan jumlah replika sekarang.
Ketika jumlah replika dibawah 40, <em>policy</em> pertama (Pods) akan digunakan dan 4 replika akan dikurangi
dalam satu waktu.</p><p><code>periodSeconds</code> menunjukkan berapa lama waktu pada iterasi terkhir untuk menunjukkan <em>policy</em>
mana yang akan digunakan. <em>Policy</em> pertama mengizinkan maksimal 4 replika di <em>scale down</em>
dalam satu menit. <em>Policy</em> kedua mengixinkan maksimal 10% dari total replika sekarang di
<em>scale down</em> dalam satu menit.</p><p>Pemilihan <em>policy</em> dapat diubah dengan menentukannya pada <em>field</em> <code>selectPolicy</code> untuk sebuah
arah <em>scale</em> (baik <em>scale up</em> ataupun <em>scale down</em>). Dengan menentukan nilai <code>Min</code>,
HorizontalPodAutoscaler akan memilih <em>policy</em> yang mengizinkan pergantian replika paling sedikit.
Dengan menuntukan nilai <code>Disable</code>, akan menghentikan <em>scaling</em> pada arah <em>scale</em> tersebut.</p><h3 id=jendela-stabilisasi>Jendela Stabilisasi</h3><p>Jendela stabilisasi digunakan untuk membatasi perubahan replika yang terlalu drastis ketika
metrik yang digunakan untuk <em>scaling</em> tetap berubah-ubah. Jendela stabilisasi digunakan oleh
algoritma <em>autoscaling</em> untuk memperhitungkan jumlah replika yang diharapkan dari <em>scaling</em>
sebelumnya untuk mencengah *scaling. Berikut adalah contoh penggunaan jendela stabilisasi
pada <code>scaleDown</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>scaleDown</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>stabilizationWindowSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>300</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Ketika metrik menandakan bahwa replika pada target akan dikurangi, algoritma akan memperhatikan
jumlah replika yang diharapkan sebelumnya dan menggunakan nilai terbesar dari interval
yang ditentukan. Pada contoh diatas, semua jumlah replika yang diharapkan pada 5 menit
yang lalu akan dipertimbangkan.</p><h3 id=perilaku-standar>Perilaku Standar</h3><p>Untuk menggunakan <em>scaling</em> khusus, tidak semua <em>field</em> perlu ditentukan. Hanta nilai yang
perlu diubah saja yang ditentukan. Nilai khusus ini akan digabungkan dengan nilai standar.
Berikut adalah nilai standar perilaku pada algoritma yang digunakan HorizontalPodAutoscaler.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>behavior</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scaleDown</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>stabilizationWindowSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>300</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>policies</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Percent<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#666>100</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>15</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scaleUp</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>stabilizationWindowSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>0</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>policies</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Percent<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#666>100</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>15</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Pods<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#666>4</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>15</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>selectPolicy</span>:<span style=color:#bbb> </span>Max<span style=color:#bbb>
</span></span></span></code></pre></div><p>Untuk <code>scaleDown</code>, nilai dari jendela stabilisasi adalah 300 detik (atau nilai dari
<em>flag</em> <code>--horizontal-pod-autoscaler-downscale-stabilization</code> jika ditentukan). Hanya terdapat
satu <em>policy</em>, yaitu mengizinkan menghapus 100% dari replika yang berjalan,
artinya target replikasi di <em>scale</em> ke jumlah replika minimum. Untuk <code>scaleUp</code>, tidak terdapat
jendela stabilisasi. Jika metrik menunjukkan bahwa replika pada target perlu diperbanyak, maka replika akan
diperbanyak di secara langsung. Untuk <code>scaleUp</code> terdapat dua <em>policy</em>, yaitu empat Pod atau 100% dari
replika yang berjalan akan ditambahkan setiap 15 detik sampai HorizontalPodAutoscaler
dalam keadaan stabil.</p><h3 id=contoh-mengubah-jendela-stabiliasi-pada-field-scaledown>Contoh: Mengubah Jendela Stabiliasi pada <em>field</em> scaleDown</h3><p>Untuk membuat jendela stabilisai untuk pengurangan replika selama satu menit, perilaku
berikut ditambahkan pada HorizontalPodAutoscaler.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>behavior</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scaleDown</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>stabilizationWindowSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>60</span><span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=contoh-membatasi-nilai-scale-down>Contoh: Membatasi nilai <em>scale down</em></h3><p>Untuk membatasi total berapa Pod yang akan dihapus, 10% setiap menut, perilaku
berikut ditambahkan pada HorizontalPodAutoscaler.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>behavior</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scaleDown</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>policies</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Percent<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>60</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Untuk mengizinkan penghapusan 5 Pod terakhir, <em>policy</em> lain dapat ditambahkan.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>behavior</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scaleDown</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>policies</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Percent<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>60</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Pods<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>60</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>selectPolicy</span>:<span style=color:#bbb> </span>Max<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=contoh-menonakfitkan-scale-down>Contoh: menonakfitkan <em>scale down</em></h3><p>Nilai <code>Disable</code> pada <code>selectPolicy</code> akan menonaktifkan <em>scaling</em> pada arah yang
ditentukan. Untuk mencegah pengurangan replika dapat menggunakan <em>policy</em> berikut.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>behavior</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scaleDown</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>selectPolicy</span>:<span style=color:#bbb> </span>Disabled<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=selanjutnya>Selanjutnya</h2><ul><li>Dokumentasi desain <a href=https://git.k8s.io/community/contributors/design-proposals/autoscaling/horizontal-pod-autoscaler.md>Horizontal Pod Autoscaling</a>.</li><li>Perintah kubectl autoscale <a href=/docs/reference/generated/kubectl/kubectl-commands/#autoscale>kubectl autoscale</a>.</li><li>Contoh penggunaan <a href=/docs/tasks/run-application/horizontal-pod-autoscale-walkthrough/>HorizontalPodAutoscaler</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-8138226ce9660ac8e3e82ff86fff8ad2>4.7.4 - Panduan HorizontalPodAutoscaler</h1><p>HorizontalPodAutoscaler secara otomatis akan memperbanyak jumlah Pod di dalam ReplicationController, Deployment,
ReplicaSet ataupun StatefulSet berdasarkan hasil observasi penggunaan CPU (atau, dengan
<a href=https://git.k8s.io/community/contributors/design-proposals/instrumentation/custom-metrics-api.md>metrik khusus</a>, pada beberapa aplikasi yang menyediakan metrik).</p><p>Laman ini memandu kamu dengan contoh pengaktifan HorizontalPodAutoscaler untuk server php-apache. Untuk informasi lebih lanjut tentang perilaku HorizontalPodAutoscaler, lihat <a href=/id/docs/tasks/run-application/horizontal-pod-autoscaler/>Petunjuk pengguna HorizontalPodAutoscaler</a>.</p><h2 id=heading></h2><p>Contoh dibawah ini membutuhkan klaster Kubernetes dan kubectl di versi 1.2 atau yang lebih baru yang sedang berjalan.
<a href=https://github.com/kubernetes-incubator/metrics-server/>Server metrik</a> sebagai pemantauan perlu diluncurkan di dalam sebuah klaster
untuk menyediakan metrik melalui metrik API sumber daya, karena HorizontalPodAutoscaler menggunakan API ini untuk mengumpulkan metrik. Petunjuk untuk menerapkan server metrik ada di repositori GitHub dari <a href=https://github.com/kubernetes-incubator/metrics-server/>server metrik</a>, jika kamu mengikuti petunjuk <a href=/docs/setup/production-environment/turnkey/gce/>memulai panduan GCE</a>,
metrik-pemantauan server akan diaktifkan secara default</p><p>Untuk menentukan beberapa metrik sumber daya untuk HorizontalPodAutoscaler, kamu harus memiliki klaster Kubernetes
dan kubectl di versi 1.6 atau yang lebih baru. Selanjutnya, untuk menggunakan metrik khusus, klaster kamu
harus dapat berkomunikasi dengan server API yang menyediakan API metrik khusus. Terakhir, untuk menggunakan metrik yang tidak terkait dengan objek Kubernetes apa pun, kamu harus memiliki klaster Kubernetes pada versi 1.10 atau yang lebih baru, dan kamu harus dapat berkomunikasi dengan server API yang menyediakan API metrik eksternal.
Lihat <a href=/docs/tasks/run-application/horizontal-pod-autoscale/#support-for-custom-metrics>Panduan pengguna HorizontalPodAutoscaler</a> untuk detail lebih lanjut.</p><h2 id=menjalankan-mengekspos-server-php-apache>Menjalankan & mengekspos server php-apache</h2><p>Untuk mendemonstrasikan HorizontalPodAutoscaler kita akan menggunakan <em>image</em> Docker khusus berdasarkan <em>image</em> php-apache.
Dockerfile memiliki konten berikut:</p><pre tabindex=0><code>FROM php:5-apache
ADD index.php /var/www/html/index.php
RUN chmod a+rx index.php
</code></pre><p>Bagian ini mendefinisikan laman index.php yang melakukan beberapa komputasi intensif CPU:</p><pre tabindex=0><code>&lt;?php
  $x = 0.0001;
  for ($i = 0; $i &lt;= 1000000; $i++) {
    $x += sqrt($x);
  }
  echo &#34;OK!&#34;;
?&gt;
</code></pre><p>Pertama, kita akan memulai Deployment yang menjalankan <em>image</em> dan mengeksposnya sebagai Service
menggunakan konfigurasi berikut:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/application/php-apache.yaml download=application/php-apache.yaml><code>application/php-apache.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("application-php-apache-yaml")' title="Copy application/php-apache.yaml to clipboard"></img></div><div class=includecode id=application-php-apache-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>php-apache<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>php-apache<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>php-apache<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>php-apache<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/hpa-example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>500m<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>200m<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>php-apache<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>php-apache<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>php-apache<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Jalankan perintah berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/application/php-apache.yaml
</span></span></code></pre></div><pre tabindex=0><code>deployment.apps/php-apache created
service/php-apache created
</code></pre><h2 id=membuat-horizontalpodautoscaler>Membuat HorizontalPodAutoscaler</h2><p>Sekarang server sudah berjalan, selanjutnya kita akan membuat <em>autoscaler</em> menggunakan
<a href=/docs/reference/generated/kubectl/kubectl-commands#autoscale>kubectl autoscale</a>.
Perintah berikut akan membuat HorizontalPodAutoscaler yang mengelola antara 1 dan 10 replika Pod yang dikontrol oleh Deployment php-apache yang kita buat pada langkah pertama instruksi ini.
Secara kasar, HPA akan menambah dan mengurangi jumlah replika
(melalui Deployment) untuk mempertahankan pemakaian CPU rata-rata di semua Pod sebesar 50%
(karena setiap Pod meminta 200 mili-core menurut <code>kubectl run</code>), ini berarti penggunaan CPU rata-rata adalah 100 mili-core).
Lihat <a href=/id/docs/tasks/run-application/horizontal-pod-autoscaler/#detail-algoritma>ini</a> untuk detail lebih lanjut tentang algoritmanya.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl autoscale deployment php-apache --cpu-percent<span style=color:#666>=</span><span style=color:#666>50</span> --min<span style=color:#666>=</span><span style=color:#666>1</span> --max<span style=color:#666>=</span><span style=color:#666>10</span>
</span></span></code></pre></div><pre tabindex=0><code>horizontalpodautoscaler.autoscaling/php-apache autoscaled
</code></pre><p>Kita dapat memeriksa status <em>autoscaler</em> saat ini dengan menjalankan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get hpa
</span></span></code></pre></div><pre tabindex=0><code>NAME         REFERENCE                     TARGET    MINPODS   MAXPODS   REPLICAS   AGE
php-apache   Deployment/php-apache/scale   0% / 50%  1         10        1          18s
</code></pre><p>Harap dicatat bahwa konsumsi CPU saat ini adalah 0% karena kita tidak mengirimkan permintaan apa pun ke server
(kolom <code>TARGET</code> menunjukkan nilai rata-rata di semua Pod yang dikontrol oleh Deployment yang sesuai).</p><h2 id=menambahkan-beban>Menambahkan beban</h2><p>Sekarang, kita akan melihat bagaimana <em>autoscaler</em> bereaksi terhadap peningkatan beban.
Kita akan memulai sebuah Container, dan mengirimkan perulangan kueri tak terbatas ke Service php-apache (jalankan di terminal yang berbeda):</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl run -it --rm load-generator --image<span style=color:#666>=</span>busybox /bin/sh
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Hit enter <span style=color:#a2f;font-weight:700>for</span> <span style=color:#a2f>command</span> prompt
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>while</span> true; <span style=color:#a2f;font-weight:700>do</span> wget -q -O- http://php-apache; <span style=color:#a2f;font-weight:700>done</span>
</span></span></code></pre></div><p>Dalam satu menit atau lebih, kita akan melihat beban CPU yang lebih tinggi dengan menjalankan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get hpa
</span></span></code></pre></div><pre tabindex=0><code>NAME         REFERENCE                     TARGET      MINPODS   MAXPODS   REPLICAS   AGE
php-apache   Deployment/php-apache/scale   305% / 50%  1         10        1          3m
</code></pre><p>Di sini, konsumsi CPU meningkat hingga 305% dari permintaan.
Hasilnya, Deployment mengubah ukurannya menjadi 7 replika:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get deployment php-apache
</span></span></code></pre></div><pre tabindex=0><code>NAME         READY   UP-TO-DATE   AVAILABLE   AGE
php-apache   7/7      7           7           19m
</code></pre><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Mungkin perlu beberapa menit untuk menstabilkan jumlah replika. Karena jumlah
bebannya tidak dikendalikan dengan cara apa pun, yang mungkin terjadi adalah jumlah replika akhir
akan berbeda dari contoh.</div><h2 id=menghentikan-beban>Menghentikan beban</h2><p>Kita akan menyudahi contoh dengan menghentikan beban pengguna.</p><p>Di terminal tempat kita membuat Container dengan <em>image</em> <code>busybox</code>, hentikan
pembangkitan beban dengan mengetik <code>&lt;Ctrl> + C</code>.</p><p>Kemudian kita akan memverifikasi status hasil (setelah satu menit atau lebih):</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get hpa
</span></span></code></pre></div><pre tabindex=0><code>NAME         REFERENCE                     TARGET       MINPODS   MAXPODS   REPLICAS   AGE
php-apache   Deployment/php-apache/scale   0% / 50%     1         10        1          11m
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get deployment php-apache
</span></span></code></pre></div><pre tabindex=0><code>NAME         READY   UP-TO-DATE   AVAILABLE   AGE
php-apache   1/1     1            1           27m
</code></pre><p>Di sini penggunaan CPU turun menjadi 0, sehingga HPA secara otomatis melakukan penyekalaan jumlah replika kembali menjadi 1.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Penyekalaan otomatis replika mungkin memerlukan waktu beberapa menit.</div><h2 id=penyekalaan-otomatis-pada-metrik-multipel-dan-metrik-kustom>Penyekalaan otomatis pada metrik multipel dan metrik kustom</h2><p>Kamu dapat memperkenalkan metrik tambahan untuk digunakan saat melakukan penyekalaan otomatis pada Deployment <code>php-apache</code> dengan menggunakan versi API <code>autoscaling / v2beta2</code>.</p><p>Pertama, dapatkan YAML HorizontalPodAutoscaler kamu dalam bentuk <code>autoscaling / v2beta2</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get hpa.v2beta2.autoscaling -o yaml &gt; /tmp/hpa-v2.yaml
</span></span></code></pre></div><p>Buka berkas <code>/tmp/hpa-v2.yaml</code> di editor, dan kamu akan melihat YAML yang terlihat seperti ini:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>autoscaling/v2beta2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>HorizontalPodAutoscaler<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>php-apache<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scaleTargetRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>php-apache<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>minReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>maxReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>metrics</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Resource<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resource</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cpu<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>target</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Utilization<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>averageUtilization</span>:<span style=color:#bbb> </span><span style=color:#666>50</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>observedGeneration</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>lastScaleTime</span>:<span style=color:#bbb> </span>&lt;some-time&gt;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>currentReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>desiredReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>currentMetrics</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Resource<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resource</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cpu<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>current</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>averageUtilization</span>:<span style=color:#bbb> </span><span style=color:#666>0</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>averageValue</span>:<span style=color:#bbb> </span><span style=color:#666>0</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Perhatikan bahwa kolom <code>targetCPUUtilizationPercentage</code> telah diganti dengan himpunan yang disebut <code>metrics</code>.
Metrik penggunaan CPU adalah <em>resource metric</em>, merepresentasikan sebagai persentase sumber daya
ditentukan pada Container Pod. Perhatikan bahwa kamu dapat menentukan metrik sumber daya selain CPU. Secara bawaan,
satu-satunya metrik sumber daya lain yang didukung adalah memori. Sumber daya ini tidak mengubah nama dari klaster
ke klaster, dan harus selalu tersedia, selama API <code>metrics.k8s.io</code> tersedia.</p><p>Kamu juga dapat menentukan metrik sumber daya dalam nilai secara langsung, bukan sebagai persentase dari
nilai yang diminta, dengan menggunakan <code>target.type</code> dari <code>AverageValue</code> sebagai ganti <code>Utilization</code>, dan
menyetel <em>field</em> <code>target.averageValue</code> yang sesuai, bukan <code>target.averageUtilization</code>.</p><p>Ada dua jenis metrik lainnya, keduanya dianggap sebagai <em>metrik khusus</em>: metrik Pod dan
metrik objek. Metrik ini memungkinkan untuk memiliki nama yang spesifik untuk klaster, dan membutuhkan lebih banyak
pengaturan pemantauan klaster lanjutan.</p><p>Jenis metrik alternatif yang pertama adalah <em>metrik Pod</em>. Metrik ini mendeskripsikan Pod, dan
dirata-ratakan bersama di seluruh Pod dan dibandingkan dengan nilai target untuk menentukan jumlah replika.
Mereka bekerja seperti metrik sumber daya, kecuali bahwa mereka <em>hanya</em> mendukung jenis <code>target</code> dari <code>AverageValue</code>.</p><p>Metrik Pod ditentukan menggunakan blok metrik seperti ini:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Pods<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>pods</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>metric</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>packets-per-second<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>target</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>AverageValue<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>averageValue</span>:<span style=color:#bbb> </span>1k<span style=color:#bbb>
</span></span></span></code></pre></div><p>Jenis metrik alternatif kedua adalah <em>metrik objek</em>. Metrik ini mendeskripsikan perbedaan
objek di Namespace yang sama, bukan mendeskripsikan Pod. Metriknya belum tentu
diambil dari objek; mereka hanya mendeskripsikannya. Metrik objek mendukung jenis <code>target</code>
baik <code>Value</code> dan <code>AverageValue</code>. Dengan <code>Value</code>, target dibandingkan langsung dengan yang dikembalikan
metrik dari API. Dengan <code>AverageValue</code>, nilai yang dikembalikan dari API metrik khusus dibagi
dengan jumlah Pod sebelum dibandingkan dengan target. Contoh berikut adalah YAML
representasi dari metrik <code>requests-per-second</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Object<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>object</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>metric</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>requests-per-second<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>describedObject</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1beta1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Ingress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>main-route<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>target</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Value<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span>2k<span style=color:#bbb>
</span></span></span></code></pre></div><p>Jika kamu memberikan beberapa blok metrik seperti itu, HorizontalPodAutoscaler akan mempertimbangkan setiap metrik secara bergantian.
HorizontalPodAutoscaler akan menghitung jumlah replika yang diusulkan untuk setiap metrik, lalu memilih
satu dengan jumlah replika tertinggi.</p><p>Misalnya, jika sistem pemantauan kamu mengumpulkan metrik tentang lalu lintas jaringan,
kamu dapat memperbarui definisi di atas menggunakan <code>kubectl edit</code> agar terlihat seperti ini:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>autoscaling/v2beta2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>HorizontalPodAutoscaler<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>php-apache<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scaleTargetRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>php-apache<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>minReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>maxReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>metrics</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Resource<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resource</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cpu<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>target</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Utilization<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>averageUtilization</span>:<span style=color:#bbb> </span><span style=color:#666>50</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Pods<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>pods</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>metric</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>packets-per-second<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>target</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>AverageValue<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>averageValue</span>:<span style=color:#bbb> </span>1k<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Object<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>object</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>metric</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>requests-per-second<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>describedObject</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1beta1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Ingress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>main-route<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>target</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Value<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span>10k<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>observedGeneration</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>lastScaleTime</span>:<span style=color:#bbb> </span>&lt;some-time&gt;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>currentReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>desiredReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>currentMetrics</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Resource<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resource</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cpu<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>current</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>averageUtilization</span>:<span style=color:#bbb> </span><span style=color:#666>0</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>averageValue</span>:<span style=color:#bbb> </span><span style=color:#666>0</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Object<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>object</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>metric</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>requests-per-second<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>describedObject</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1beta1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Ingress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>main-route<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>current</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span>10k<span style=color:#bbb>
</span></span></span></code></pre></div><p>Kemudian, HorizontalPodAutoscaler kamu akan mencoba memastikan bahwa setiap Pod mengonsumsi kira-kira
50% dari CPU yang diminta, melayani 1000 paket per detik, dan semua Pod berada di belakang Ingress
rute utama melayani total 10.000 permintaan per detik.</p><h3 id=penyekalaan-otomatis-pada-metrik-yang-lebih-spesifik>Penyekalaan otomatis pada metrik yang lebih spesifik</h3><p>Banyak <em>pipeline</em> metrik memungkinkan kamu mendeskripsikan metrik baik berdasarkan nama atau kumpulan tambahan
deskriptor yang disebut <em>labels</em>. Untuk semua jenis metrik non-sumber daya (Pod, objek, dan eksternal,
dijelaskan seperti dibawah), kamu dapat menentukan pemilih label tambahan yang diteruskan ke pipa metrik kamu. Misalnya, jika kamu mengumpulkan metrik <code>http_requests</code> dengan label <code>verb</code>
, kamu dapat menentukan blok metrik berikut untuk diskalakan hanya pada permintaan GET:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Object<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>object</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>metric</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>http_requests<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb> </span>{<span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb> </span>{<span style=color:green;font-weight:700>verb</span>:<span style=color:#bbb> </span>GET}}<span style=color:#bbb>
</span></span></span></code></pre></div><p><em>Selector</em> ini menggunakan sintaksis yang sama dengan <em>selector</em> lengkap label Kubernetes. Pipa pemantauan
menentukan cara mengecilkan beberapa seri menjadi satu nilai, jika nama dan pemilih cocok dengan
beberapa seri. Selektor bersifat aditif, dan tidak dapat memilih metrik yang mendeskripsikan objek
yang <strong>bukan</strong> objek target (target pod dalam kasus tipe <code>Pod</code>, dan objek yang dijelaskan dalam kasus tipe <code>Objek</code>).</p><h3 id=penyekalaan-otomatis-pada-metrik-yang-tidak-terkait-dengan-objek-kubernetes>Penyekalaan otomatis pada metrik yang tidak terkait dengan objek Kubernetes</h3><p>Aplikasi yang berjalan di Kubernetes mungkin perlu melakukan penyekalaan otomatis berdasarkan metrik yang tidak
memiliki hubungan yang jelas dengan objek apa pun di klaster Kubernetes, seperti metrik yang mendeskripsikan
layanan yang dihosting tanpa korelasi langsung dengan namespace Kubernetes. Di Kubernetes 1.10 dan yang lebih baru, kamu dapat menangani kasus penggunaan ini dengan <em>metrik eksternal</em>.</p><p>Menggunakan metrik eksternal membutuhkan pengetahuan tentang sistem pemantauanmu; penyiapannya mirip dengan yang diperlukan saat menggunakan metrik khusus. Metrik eksternal memungkinkan kamu menskalakan klaster kamu secara otomatis berdasarkan metrik apa pun yang tersedia di sistem pemantauanmu. Cukup berikan blok <code>metric</code> dengan <code>name</code> dan <code>selector</code> (pemilih), seperti di atas, dan gunakan jenis metrik <code>External</code>, bukan <code>Object</code>.
Jika beberapa <em>series</em> cocok dengan <code>metricSelector</code>, jumlah dari nilai mereka akan digunakan oleh HorizontalPodAutoscaler.
Metrik eksternal mendukung jenis target <code>Value</code> dan <code>AverageValue</code>, yang berfungsi persis sama seperti saat kamu menggunakan tipe <code>Object</code>.</p><p>Misalnya, jika aplikasi kamu memproses tugas dari layanan antrian yang dihosting, kamu dapat menambahkan bagian berikut ke manifes HorizontalPodAutoscaler untuk menentukan bahwa kamu memerlukan satu pekerja per 30 tugas yang belum diselesaikan.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>External<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>external</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metric</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>queue_messages_ready<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;queue=worker_tasks&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>target</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>AverageValue<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>averageValue</span>:<span style=color:#bbb> </span><span style=color:#666>30</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Jika memungkinkan, lebih baik menggunakan target metrik khusus daripada metrik eksternal, karena lebih mudah bagi administrator klaster untuk mengamankan API metrik khusus. API metrik eksternal berpotensi memungkinkan akses ke metrik apa pun, jadi administrator klaster harus berhati-hati saat mengeksposnya.</p><h2 id=lampiran-kondisi-status-horizontal-pod-autoscaler>Lampiran: Kondisi Status Horizontal Pod Autoscaler</h2><p>Saat menggunakan bentuk <code>autoscaling/v2beta2</code> dari HorizontalPodAutoscaler, kamu akan dapat melihat
<em>status condition</em> yang ditetapkan oleh Kubernetes pada HorizontalPodAutoscaler. <em>Status condition</em> ini menunjukkan apakah HorizontalPodAutoscaler dapat melakukan penyekalaan atau tidak, dan apakah saat ini dibatasi atau tidak.</p><p>Kondisi muncul pada <em>field</em> <code>status.conditions</code>. Untuk melihat kondisi yang memengaruhi HorizontalPodAutoscaler, kita bisa menggunakan <code>kubectl description hpa</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe hpa cm-test
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>Name:                           cm-test
</span></span><span style=display:flex><span>Namespace:                      prom
</span></span><span style=display:flex><span>Labels:                         &lt;none&gt;
</span></span><span style=display:flex><span>Annotations:                    &lt;none&gt;
</span></span><span style=display:flex><span>CreationTimestamp:              Fri, <span style=color:#666>16</span> Jun <span style=color:#666>2017</span> 18:09:22 +0000
</span></span><span style=display:flex><span>Reference:                      ReplicationController/cm-test
</span></span><span style=display:flex><span>Metrics:                        <span style=color:#666>(</span> current / target <span style=color:#666>)</span>
</span></span><span style=display:flex><span>  <span style=color:#b44>&#34;http_requests&#34;</span> on pods:      66m / 500m
</span></span><span style=display:flex><span>Min replicas:                   <span style=color:#666>1</span>
</span></span><span style=display:flex><span>Max replicas:                   <span style=color:#666>4</span>
</span></span><span style=display:flex><span>ReplicationController pods:     <span style=color:#666>1</span> current / <span style=color:#666>1</span> desired
</span></span><span style=display:flex><span>Conditions:
</span></span><span style=display:flex><span>  Type                  Status  Reason                  Message
</span></span><span style=display:flex><span>  ----                  ------  ------                  -------
</span></span><span style=display:flex><span>  AbleToScale           True    ReadyForNewScale        the last scale <span style=color:#a2f>time</span> was sufficiently old as to warrant a new scale
</span></span><span style=display:flex><span>  ScalingActive         True    ValidMetricFound        the HPA was able to successfully calculate a replica count from pods metric http_requests
</span></span><span style=display:flex><span>  ScalingLimited        False   DesiredWithinRange      the desired replica count is within the acceptable range
</span></span><span style=display:flex><span>Events:
</span></span></code></pre></div><p>Untuk HorizontalPodAutoscaler ini, kita dapat melihat beberapa kondisi yang menandakan dalam keadaan sehat. Yang pertama, <code>AbleToScale</code>, menunjukkan apakah HPA dapat mengambil dan memperbarui skala atau tidak, serta apakah kondisi terkait <em>backoff</em> akan mencegah penyekalaan atau tidak. Yang kedua, <code>ScalingActive</code>, menunjukkan apakah HPA diaktifkan atau tidak (yaitu jumlah replika target bukan nol) dan mampu menghitung skala yang diinginkan. Jika <code>False</code>, biasanya menunjukkan masalah dengan
pengambilan metrik. Terakhir, kondisi terakhir, <code>ScalingLimited</code>, menunjukkan bahwa skala yang diinginkan telah dibatasi oleh maksimum atau minimum HorizontalPodAutoscaler. Ini adalah indikasi bahwa kamu mungkin ingin menaikkan atau menurunkan batasan jumlah replika minimum atau maksimum pada HorizontalPodAutoscaler kamu.</p><h2 id=lampiran-kuantitas>Lampiran: Kuantitas</h2><p>Semua metrik di HorizontalPodAutoscaler dan metrik API ditentukan menggunakan notasi bilangan bulat khusus yang dikenal di Kubernetes sebagai <a class=glossary-tooltip title='Representasi bilangan bulat dari bilangan kecil atau besar menggunakan sufiks SI.' data-toggle=tooltip data-placement=top href='/id/docs/reference/glossary/?all=true#term-quantity' target=_blank aria-label=kuantitas>kuantitas</a>. Misalnya, kuantitas <code>10500m</code> akan ditulis sebagai <code>10.5</code> dalam notasi desimal. Metrik API akan menampilkan bilangan bulat tanpa sufiks jika memungkinkan, dan secara umum akan mengembalikan kuantitas dalam satuan mili. Ini berarti kamu mungkin melihat nilai metrik berfluktuasi antara <code>1</code> dan <code>1500m</code>, atau <code>1</code> dan <code>1,5</code> ketika ditulis dalam notasi desimal.</p><h2 id=lampiran-skenario-lain-yang-memungkinkan>Lampiran: Skenario lain yang memungkinkan</h2><h3 id=membuat-autoscaler-secara-deklaratif>Membuat autoscaler secara deklaratif</h3><p>Daripada menggunakan perintah <code>kubectl autoscale</code> untuk membuat HorizontalPodAutoscaler secara imperatif, kita dapat menggunakan berkas berikut untuk membuatnya secara deklaratif:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/application/hpa/php-apache.yaml download=application/hpa/php-apache.yaml><code>application/hpa/php-apache.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("application-hpa-php-apache-yaml")' title="Copy application/hpa/php-apache.yaml to clipboard"></img></div><div class=includecode id=application-hpa-php-apache-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>autoscaling/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>HorizontalPodAutoscaler<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>php-apache<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scaleTargetRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>php-apache<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>minReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>maxReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>targetCPUUtilizationPercentage</span>:<span style=color:#bbb> </span><span style=color:#666>50</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Kita akan membuat <em>autoscaler</em> dengan menjalankan perintah berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f https://k8s.io/examples/application/hpa/php-apache.yaml
</span></span></code></pre></div><pre tabindex=0><code>horizontalpodautoscaler.autoscaling/php-apache created
</code></pre></div><div class=td-content style=page-break-before:always><h1 id=pg-b74b959f5a531003dd0653dfbfc2e88b>4.8 - Mengakes Aplikasi-aplikasi di sebuah Klaster</h1></div><div class=td-content><h1 id=pg-777447042cd4e81df3fa5beb3357a485>4.8.1 - Antarmuka Pengguna Berbasis Web (Dashboard)</h1><p>Dashboard adalah antarmuka pengguna Kubernetes. Kamu dapat menggunakan Dashboard untuk men-<em>deploy</em> aplikasi yang sudah dikontainerisasi ke klaster Kubernetes, memecahkan masalah pada aplikasi kamu, dan mengatur sumber daya klaster. Kamu dapat menggunakan Dashboard untuk melihat ringkasan dari aplikasi yang sedang berjalan di klaster kamu, dan juga membuat atau mengedit objek individu sumber daya Kubernetes (seperti Deployment, Job, DaemonSet, dll.). Sebagai contoh, kamu dapat mengembangkan sebuah Deployment, menginisiasi sebuah pembaruan bertahap (<em>rolling update</em>), memulai kembali sebuah Pod atau men-<em>deploy</em> aplikasi baru menggunakan sebuah <em>deploy wizard</em>.</p><p>Dashboard juga menyediakan informasi tentang status dari sumber daya Kubernetes di klaster kamu dan kesalahan apapun yang mungkin telah terjadi..</p><p><img src=/images/docs/ui-dashboard.png alt="Antarmuka Pengguna Dashboard Kubernetes"></p><h2 id=men-deploy-antarmuka-pengguna-dashboard>Men-<em>deploy</em> Antarmuka Pengguna Dashboard</h2><p>Antarmuka Dashboard tidak ter-<em>deploy</em> secara bawaan. Untuk men-<em>deploy</em>-nya, kamu dapat menjalankan perintah berikut:</p><pre tabindex=0><code>kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0/aio/deploy/recommended.yaml
</code></pre><h2 id=mengakses-antarmuka-dashboard>Mengakses Antarmuka Dashboard</h2><p>Untuk melindungi data klaster kamu, pen-<em>deploy</em>-an Dashboard menggunakan sebuah konfigurasi <em>RBAC</em> yang minimal secara bawaan. Saat ini, Dashboard hanya mendukung otentikasi dengan <em>Bearer Token</em>. Untuk membuat token untuk demo, kamu dapat mengikuti petunjuk kita untuk <a href=https://github.com/kubernetes/dashboard/blob/master/docs/user/access-control/creating-sample-user.md>membuat sebuah contoh pengguna</a>.</p><div class="alert alert-danger warning callout" role=alert><strong>Peringatan:</strong> Contoh pengguna yang telah dibuat di tutorial tersebut akan memiliki hak istimewa sebagai administrator dan hanyalah untuk tujuan pembelajaran.</div><h3 id=proksi-antarmuka-baris-perintah-cli>Proksi antarmuka baris perintah (CLI)</h3><p>Kamu dapat mengakses Dashboard menggunakan perkakas CLI kubectl dengan menjalankan perintah berikut:</p><pre tabindex=0><code>kubectl proxy
</code></pre><p>Kubectl akan membuat Dashboard tersedia di http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/.</p><p>Antarmuka pengguna berbasis web tersebut hanya dapat di akses dari mesin dimana perintah tersebut dijalankan. Lihat <code>kubectl proxy --help</code> untuk lebih lanjut.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Metode otentikasi Kubeconfig tidak mendukung penyedia identitas eksternal atau otentikasi berbasis sertifikat elektronik x509.</div><h2 id=tampilan-selamat-datang>Tampilan selamat datang</h2><p>Ketika kamu mengakses Dashboard di klaster yang kosong, kamu akan melihat laman selamat datang. Laman ini berisi tautan ke dokumen ini serta tombol untuk men-<em>deploy</em> aplikasi pertama kamu. Selain itu, kamu dapat melihat aplikasi-aplikasi sistem mana saja yang berjalan secara bawaan di <a href=/docs/tasks/administer-cluster/namespaces/>Namespace</a> <code>kube-system</code> dari klaster kamu, misalnya Dashboard itu sendiri.</p><p><img src=/images/docs/ui-dashboard-zerostate.png alt="Kubernetes Dashboard welcome page"></p><h2 id=men-deploy-aplikasi-yang-sudah-dikontainerisasi>Men-<em>deploy</em> aplikasi yang sudah dikontainerisasi</h2><p>Dashboard memungkinkan kamu untuk membuat dan men-<em>deploy</em> aplikasi yang sudah dikontainerisasi sebagai Deployment dan Service opsional dengan sebuah <em>wizard</em> sederhana. Kamu secara manual dapat menentukan detail aplikasi, atau mengunggah sebuah berkas YAML atau JSON yang berisi konfigurasi aplikasi.</p><p>Tekan tombol <strong>CREATE</strong> di pojok kanan atas di laman apapun untuk memulai.</p><h3 id=menentukan-detail-aplikasi>Menentukan detail aplikasi</h3><p><em>Deploy wizard</em> meminta kamu untuk menyediakan informasi sebagai berikut:</p><ul><li><p><strong>App name</strong> (wajib): Nama dari aplikasi kamu. Sebuah <a href=/id/docs/concepts/overview/working-with-objects/labels/>label</a> dengan nama tersebut akan ditambahkan ke Deployment dan Service, jika ada, akan di-<em>deploy</em>.</p><p>Nama aplikasi harus unik di dalam <a href=/docs/tasks/administer-cluster/namespaces/>Namespace</a> Kubernetes yang kamu pilih. Nama tersebut harus dimulai dengan huruf kecil, dan diakhiri dengan huruf kecil atau angka, dan hanya berisi huruf kecil, angka dan tanda hubung (-). Nama tersebut juga dibatasi hanya 24 karakter. Spasi di depan dan belakang nama tersebut diabaikan.</p></li><li><p><strong>Container image</strong> (wajib): Tautan publik dari sebuah <a href=/id/docs/concepts/containers/images/><em>image</em></a> kontainer Docker pada <em>registry</em> apapun, atau sebuah <em>image</em> privat (biasanya di-<em>hosting</em> di Google Container Registry atau Docker Hub). Spesifikasi <em>image</em> kontainer tersebut harus diakhiri dengan titik dua.</p></li><li><p><strong>Number of pods</strong> (wajib): Berapa banyak Pod yang kamu inginkan untuk men-<em>deploy</em> aplikasimu. Nilainya haruslah sebuah bilangan bulat positif.</p><p>Sebuah <a href=/id/docs/concepts/workloads/controllers/deployment/>Deployment</a> akan terbuat untuk mempertahankan jumlah Pod di klaster kamu.</p></li><li><p><strong>Service</strong> (opsional): Untuk beberapa aplikasi (misalnya aplikasi <em>frontend</em>) kamu mungkin akan mengekspos sebuah <a href=/id/docs/concepts/services-networking/service/>Service</a> ke alamat IP publik yang mungkin berada diluar klaster kamu(Service eksternal). Untuk Service eksternal, kamu mungkin perlu membuka lebih dari satu porta jaringan untuk mengeksposnya. Lihat lebih lanjut <a href=/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/>di sini</a>.</p><p>Service lainnya yang hanya dapat diakses dari dalam klaster disebut Service internal.</p><p>Terlepas dari jenis Service, jika kamu memilih untuk membuat sebuah Service dan Container kamu berjalan di sebuah porta(arah masuk), kamu perlu menentukan dua porta. Service akan memetakan porta(arah masuk) ke porta target yang ada di sisi Container. Service akan mengarahkan ke Pod-Pod kamu yang sudah di-<em>deploy</em>. Protokol yang didukung adalah TCP dan UDP. Nama DNS internal untuk Service ini akan sesuai dengan nama aplikasi yang telah kamu tentukan diatas.</p></li></ul><p>Jika membutuhkan, kamu dapat membuka bagian <strong>Advanced options</strong> di mana kamu dapat menyetel lebih banyak pengaturan:</p><ul><li><p><strong>Description</strong>: Tels yang kamu masukkan ke sini akan ditambahkan sebagai sebuah <a href=/id/docs/concepts/overview/working-with-objects/annotations/>anotasi</a> ke Deployment dan akan ditampilkan di detail aplikasi.</p></li><li><p><strong>Labels</strong>: <a href=/id/docs/concepts/overview/working-with-objects/labels/>Label-label</a> bawaan yang akan digunakan untuk aplikasi kamu adalah <code>name</code> dan <code>version</code> aplikasi. Kamu dapat menentukan label lain untuk diterapkan ke Deployment, Service (jika ada), dan Pod, seperti <code>release</code>, <code>environment</code>, <code>tier</code>, <code>partition</code>, dan <code>track</code> rilis.</p><p>Contoh:</p><pre tabindex=0><code class=language-conf data-lang=conf>release=1.0
tier=frontend
environment=pod
track=stable
</code></pre></li><li><p><strong><em>Namespace</em></strong>: Kubernetes mendukung beberapa klaster virtual yang berjalan di atas klaster fisik yang sama. Klaster virtual ini disebut <a href=/docs/tasks/administer-cluster/namespaces/>Namespace</a>. Mereka mengizinkan kamu untuk mempartisi sumber daya ke beberapa grup yang diberi nama secara logis.</p><p>Dashboard menampilkan semua Namespace yang tersedia dalam sebuah daftar <em>dropdown</em>, dan mengizinkan kamu untuk membuat Namespace baru. Nama yang diizinkan untuk Namespace terdiri dari maksimal 63 karakter alfanumerik dan tanda hubung (-), dan tidak boleh ada huruf kapital.
Nama dari Namespace tidak boleh terdiri dari angka saja. Jika nama Namespace disetel menjadi sebuah angka, misalnya 10, maka Pod tersebut akan ditaruh di Namespace <code>default</code>.</p><p>Jika pembuatan Namespace berhasil, Namespace tersebut akan dipilih secara bawaan. Jika pembuatannya gagal, maka Namespace yang pertama akan terpilih.</p></li><li><p><strong><em>Image Pull Secret</em></strong>: Jika kamu menggunakan <em>image</em> kontainer Docker yang privat, mungkin diperlukan kredensial <a href=/id/docs/concepts/configuration/secret/><em>pull secret</em></a>.</p><p>Dashboard menampilkan semua <em>secret</em> yang tersedia dengan daftar <em>dropdown</em>, dan mengizinkan kamu untuk membuat <em>secret</em> baru. Nama <em>secret</em> tersebut harus mengikuti aturan Nama DNS, misalnya <code>new.image-pull.secret</code>. Isi dari sebuah <em>secret</em> harus dienkode dalam bentuk <em>base64</em> dan ditentukan dalam sebuah berkas <a href=/id/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod><code>.dockercfg</code></a>. Nama kredensial dapat berisi maksimal 253 karakter.</p><p>Jika pembuatan <em>image pull secret</em> berhasil, <em>image pull secret</em> tersebut akan terpilih secara bawaan. Jika gagal, maka tidak ada <em>secret</em> yang dipilih.</p></li><li><p><strong><em>CPU requirement (cores)</em></strong> dan <strong><em>Memory requirement (MiB)</em></strong>: Kamu dapat menentukan <a href=/docs/tasks/configure-pod-container/limit-range/>batasan sumber daya</a> minimal untuk Container. Secara bawaan, Pod-Pod berjalan dengan CPU dan memori yang tak dibatasi.</p></li><li><p><strong><em>Run command</em></strong> dan <strong><em>Run command arguments</em></strong>: Secara bawaan, Container-Container kamu akan menjalankan perintah <a href=/docs/user-guide/containers/#containers-and-commands><em>entrypoint</em></a> bawaan dari <em>image</em> Docker yang ditentukan. Kamu dapat menggunakan opsi <em>Run command</em> dan <em>Run command arguments</em> untuk mengganti bawaannya.</p></li><li><p><strong><em>Run as priveleged</em></strong>: Pengaturan ini untuk menentukan sebuah proses yang berjalan dalam <a href=/docs/user-guide/pods/#privileged-mode-for-pod-containers><em>privileged container</em></a> sepadan dengan proses yang berjalan sebagai <em>root</em> pada <em>host</em>-nya. <em>Priveleged container</em> dapat menggunakan kemampuan seperti memanipulasi <em>stack</em> jaringan dan mengakses perangkat-perangkat.</p></li><li><p><strong><em>Environment variables</em></strong>: Kubernetes mengekspos Service melalui <a href=/docs/tasks/inject-data-application/environment-variable-expose-pod-information/><em>environment variable</em></a>. Kamu dapat membuat <em>environment variable</em> atau meneruskan argumen ke perintah-perintah untuk menjalankan Container dengan nilai dari <em>environment variable</em>. <em>Environment Variable</em> dapat digunakan pada aplikasi-aplikasi untuk menemukan sebuah Service. Nilai <em>environment variable</em> dapat merujuk ke variabel lain menggunakan sintaksis <code>$(VAR_NAME)</code>.</p></li></ul><h3 id=menggungah-berkas-yaml-atau-json>Menggungah berkas YAML atau JSON</h3><p>Kubernetes mendukung pengaturan deklaratif. Dengan cara ini, semua pengaturan disimpan dalam bentuk berkas YAML atau JSON menggunakan skema sumber daya [<a href=/id/docs/concepts/overview/kubernetes-api/>API</a>.</p><p>Sebagai alternatif untuk menentukan detail aplikasi di <em>deploy wizard</em>, kamu dapat menentukan sendiri detail aplikasi kamu dalam berkas YAML atau JSON, dan mengunggah berkas tersebut menggunakan Dashboard.</p><h2 id=menggunakan-dashboard>Menggunakan Dashboard</h2><p>Bagian ini akan menjelaskan bagian-bagian yang ada pada Antarmuka Dashboard Kubernetes; apa saja yang mereka sediakan dan bagaimana cara menggunakanya.</p><h3 id=navigation>Navigation</h3><p>Ketika ada objek Kubernetes yang sudah didefinisikan di dalam klaster, Dashboard akan menampilkanya di tampilan awalnya. Secara bawaan hanya objek-objek dalam Namespace <em>default</em> saja yang ditampilkan di sini dan kamu dapat menggantinya dengan selektor Namespace yang berada di menu navigasi.</p><p>Dashboard menampilkan jenis objek Kubernetes dan mengelompokanya dalam beberapa kategori menu.</p><h4 id=admin-overview>Admin Overview</h4><p>Untuk administrasi klaster dan Namespace, Dashboard menampilkan Node, Namespace dan PresistentVolume dan memiliki tampilan yang detail untuk objek-objek tersebut. Daftar Node berisi metrik penggunaan CPU dan memori yang dikumpulkan dari semua Node. Tampilan detail menampilkan metrik-metrik untuk sebuah Node, spesifikasinya, status, sumber daya yang dialokasikan, <em>event-event</em>, dan Pod-Pod yang sedang berjalan di Node tersebut.</p><h4 id=workloads>Workloads</h4><p>Menampilkan semua aplikasi yang sedang berjalan di Namespace yang dipilih. Tampilan ini menampilkan aplikasi berdasarkan jenis beban kerja (misalnya, Deployment, Replica Set, Stateful Set, dll.) dan setiap jenis beban kerja memiliki tampilanya sendiri. Daftar ini merangkum informasi yang dapat ditindaklanjuti, seperti berapa banyak Pod yang siap untuk setiap Replica Set atau penggunaan memori pada sebuah Pod.</p><p>Tampilan detail dari beban kerja menampilkan status dan informasi spesifik serta hubungan antara objek. Misalnya, Pod-Pod yang diatur oleh ReplicaSet atau, ReplicaSet-ReplicaSet baru, dan HorizontalPodAutoscaler untuk Deployment.</p><h4 id=services>Services</h4><p>Menampilkan sumber daya Kubernetes yang mengizinkan untuk mengekspos Service-Service ke jaringan luar dan menemukannya (<em>service discovery</em>) di dalam klaster. Untuk itu, tampilan dari Service dan Ingress menunjukan Pod-Pod yang ditarget oleh mereka, <em>endpoint-endpoint</em> internal untuk koneksi klaster, dan <em>endpoint-endpoint</em> eksternal untuk pengguna eksternal.</p><h4 id=storage>Storage</h4><p>Tampilan Storage menampilkan sumber-sumber daya PersistentVolumeClaim yang digunakan oleh aplikasi untuk menyimpan data.</p><h4 id=config-maps-dan-secrets>Config Maps dan Secrets</h4><p>Menampilkan semua sumber daya Kubernetes yang digunakan untuk pengaturan aplikasi yang sedang berjalan di klaster. Pada tampilan ini kamu dapat mengedit dan mengelola objek-objek konfigurasi dan menampilkan kredensial yang tersembunyi secara bawaan.</p><h4 id=logs-viewer>Logs Viewer</h4><p>Laman daftar dan detail Pod tertaut dengan laman penampil log (<em>log viewer</em>). Kamu dapat menelusuri log yang berasal dari Container-Container pada sebuah Pod.</p><p><img src=/images/docs/ui-dashboard-logs-view.png alt="Logs viewer"></p><h2 id=selanjutnya>Selanjutnya</h2><p>Untuk informasi lebih lanjut, lihat
<a href=https://github.com/kubernetes/dashboard>Laman proyek Kubernetes Dashboard</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-6a8d9e9e05f2b6825afbb8889c957370>4.8.2 - Mengakses Klaster</h1><p>Topik ini membahas tentang berbagai cara untuk berinteraksi dengan klaster.</p><h2 id=mengakses-untuk-pertama-kalinya-dengan-kubectl>Mengakses untuk pertama kalinya dengan kubectl</h2><p>Saat mengakses API Kubernetes untuk pertama kalinya, kami sarankan untuk menggunakan
CLI Kubernetes, <code>kubectl</code>.</p><p>Untuk mengakses sebuah klaster, kamu perlu mengetahui lokasi klaster dan mempunyai kredensial untuk mengaksesnya.
Biasanya, ini secara otomatis diatur saat kamu mengikuti <a href=/docs/setup/>Panduan persiapan</a>,
atau orang lain yang mengatur klaster dan memberikan kredensial dan lokasi kepadamu.</p><p>Periksa lokasi dan kredensial yang ada pada konfigurasi kubectl-mu melalui perintah ini:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config view
</span></span></code></pre></div><p>Beragam <a href=/docs/user-guide/kubectl-cheatsheet>contoh</a> menyediakan pengantar penggunaan kubectl, dan dokumentasi lengkap dapat ditemukan di <a href=/docs/user-guide/kubectl-overview>kubectl manual</a>.</p><h2 id=mengakses-rest-api-secara-langsung>Mengakses REST API secara langsung</h2><p>Kubectl menangani pencarian dan autentikasi ke apiserver.
Jika kamu ingin secara langsung mengakses REST API dengan klien HTTP seperti curl atau wget, atau peramban, ada beberapa cara untuk pencarian dan autentikasi:</p><ul><li>Jalankan kubectl dalam mode proksi.<ul><li>Pendekatan yang disarankan.</li><li>Menggunakan lokasi apiserver yang tersimpan.</li><li>Melakukan verifikasi identitas apiserver menggunakan sertifikat elektronik yang ditandatangani sendiri. Tidak memungkinkan adanya MITM.</li><li>Melakukan autentikasi ke apiserver.</li><li>Di masa depan, dimungkinkan dapat melakukan <em>load-balancing</em> dan <em>failover</em> yang cerdas dari sisi klien.</li></ul></li><li>Penyediaan lokasi dan kredensial langsung ke klien http.<ul><li>Pendekatan alternatif.</li><li>Bekerja dengan beberapa jenis kode klien dengan menggunakan proksi.</li><li>Perlu mengimpor sertifikat elektronik <em>root</em> ke peramban kamu untuk melindungi dari MITM.</li></ul></li></ul><h3 id=menggunakan-kubectl-proxy>Menggunakan kubectl proxy</h3><p>Perintah berikut akan menjalankan kubectl dalam mode di mana ia bertindak sebagai proksi terbalik (<em>reverse proxy</em>).
Hal ini menangani pencarian dan autentikasi apiserver.
Jalankan seperti ini:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl proxy --port<span style=color:#666>=</span><span style=color:#666>8080</span>
</span></span></code></pre></div><p>Lihat <a href=/docs/reference/generated/kubectl/kubectl-commands/#proxy>kubectl proxy</a> untuk lebih jelasnya.</p><p>Kemudian kamu dapat menjelajahi API-nya dengan curl, wget, atau peramban, ganti localhost dengan [::1] untuk IPv6, seperti ini:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl http://localhost:8080/api/
</span></span></code></pre></div><p>Hasil keluarannya seperti ini:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;APIVersions&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;versions&#34;</span>: [
</span></span><span style=display:flex><span>    <span style=color:#b44>&#34;v1&#34;</span>
</span></span><span style=display:flex><span>  ],
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;serverAddressByClientCIDRs&#34;</span>: [
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;clientCIDR&#34;</span>: <span style=color:#b44>&#34;0.0.0.0/0&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;serverAddress&#34;</span>: <span style=color:#b44>&#34;10.0.1.149:443&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  ]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=tanpa-menggunakan-kubectl-proxy>Tanpa menggunakan kubectl proxy</h3><p>Gunakan <code>kubectl describe secret...</code> untuk mendapatkan token untuk akun servis (<em>service account</em>) <code>default</code> dengan grep/cut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#b8860b>APISERVER</span><span style=color:#666>=</span><span style=color:#a2f;font-weight:700>$(</span>kubectl config view --minify | grep server | cut -f 2- -d <span style=color:#b44>&#34;:&#34;</span> | tr -d <span style=color:#b44>&#34; &#34;</span><span style=color:#a2f;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#b8860b>SECRET_NAME</span><span style=color:#666>=</span><span style=color:#a2f;font-weight:700>$(</span>kubectl get secrets | grep ^default | cut -f1 -d <span style=color:#b44>&#39; &#39;</span><span style=color:#a2f;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#b8860b>TOKEN</span><span style=color:#666>=</span><span style=color:#a2f;font-weight:700>$(</span>kubectl describe secret <span style=color:#b8860b>$SECRET_NAME</span> | grep -E <span style=color:#b44>&#39;^token&#39;</span> | cut -f2 -d<span style=color:#b44>&#39;:&#39;</span> | tr -d <span style=color:#b44>&#34; &#34;</span><span style=color:#a2f;font-weight:700>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>curl <span style=color:#b8860b>$APISERVER</span>/api --header <span style=color:#b44>&#34;Authorization: Bearer </span><span style=color:#b8860b>$TOKEN</span><span style=color:#b44>&#34;</span> --insecure
</span></span></code></pre></div><p>Hasil keluarannya seperti ini:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;APIVersions&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;versions&#34;</span>: [
</span></span><span style=display:flex><span>    <span style=color:#b44>&#34;v1&#34;</span>
</span></span><span style=display:flex><span>  ],
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;serverAddressByClientCIDRs&#34;</span>: [
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;clientCIDR&#34;</span>: <span style=color:#b44>&#34;0.0.0.0/0&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;serverAddress&#34;</span>: <span style=color:#b44>&#34;10.0.1.149:443&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  ]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Menggunakan <code>jsonpath</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#b8860b>APISERVER</span><span style=color:#666>=</span><span style=color:#a2f;font-weight:700>$(</span>kubectl config view --minify -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.clusters[0].cluster.server}&#39;</span><span style=color:#a2f;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#b8860b>SECRET_NAME</span><span style=color:#666>=</span><span style=color:#a2f;font-weight:700>$(</span>kubectl get serviceaccount default -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.secrets[0].name}&#39;</span><span style=color:#a2f;font-weight:700>)</span>
</span></span><span style=display:flex><span><span style=color:#b8860b>TOKEN</span><span style=color:#666>=</span><span style=color:#a2f;font-weight:700>$(</span>kubectl get secret <span style=color:#b8860b>$SECRET_NAME</span> -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.data.token}&#39;</span> | base64 --decode<span style=color:#a2f;font-weight:700>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>curl <span style=color:#b8860b>$APISERVER</span>/api --header <span style=color:#b44>&#34;Authorization: Bearer </span><span style=color:#b8860b>$TOKEN</span><span style=color:#b44>&#34;</span> --insecure
</span></span></code></pre></div><p>Hasil keluarannya seperti ini:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;APIVersions&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;versions&#34;</span>: [
</span></span><span style=display:flex><span>    <span style=color:#b44>&#34;v1&#34;</span>
</span></span><span style=display:flex><span>  ],
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;serverAddressByClientCIDRs&#34;</span>: [
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;clientCIDR&#34;</span>: <span style=color:#b44>&#34;0.0.0.0/0&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;serverAddress&#34;</span>: <span style=color:#b44>&#34;10.0.1.149:443&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  ]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Contoh di atas menggunakan <em>flag</em> <code>--insecure</code>. Hal ini membuatnya rentan terhadap serangan MITM.
Ketika kubectl mengakses klaster, kubectl menggunakan sertifikat elektronik <em>root</em> yang tersimpan dan sertifikat elektronik klien untuk mengakses server.
(Sertifikat-sertifikat elektronik tersebut diinstal di direktori <code>~/.kube</code>). Karena sertifikat elektronik klaster biasanya ditandatangani sendiri,
mungkin diperlukan konfigurasi khusus untuk membuat klien HTTP kamu menggunakan sertifikat elektronik root.</p><p>Pada beberapa klaster, apiserver tidak memerlukan autentikasi; mungkin apiserver tersebut meladen (<em>serve</em>) di localhost, atau dilindungi oleh sebuah dinding api (<em>firewall</em>).
Tidak ada standar untuk ini. <a href=/docs/reference/access-authn-authz/controlling-access/>Mengonfigurasi Akses ke API</a> menjelaskan bagaimana admin klaster dapat mengonfigurasi hal ini.
Pendekatan semacam itu dapat bertentangan dengan dukungan ketersediaan tinggi (<em>high-availability</em>) pada masa depan.</p><h2 id=akses-terprogram-ke-api>Akses terprogram ke API</h2><p>Kubernetes secara resmi mendukung pustaka (<em>library</em>) klien <a href=#klien-go>Go</a> dan <a href=#klien-python>Python</a>.</p><h3 id=klien-go>Klien Go</h3><ul><li>Untuk mendapatkan pustakanya, jalankan perintah berikut: <code>go get k8s.io/client-go@kubernetes-&lt;kubernetes-version-number></code>, lihat <a href=https://github.com/kubernetes/client-go/blob/master/INSTALL.md#for-the-casual-user>INSTALL.md</a> untuk instruksi instalasi yang lebih detail. Lihat <a href=https://github.com/kubernetes/client-go#compatibility-matrix>https://github.com/kubernetes/client-go</a> untuk melihat versi yang didukung.</li><li>Tulis aplikasi dengan menggunakan klien client-go. Perhatikan bahwa client-go mendefinisikan objek APInya sendiri, jadi jika perlu, silakan impor definisi API dari client-go daripada dari repositori utama, misalnya, <code>import "k8s.io/client-go/kubernetes"</code>.</li></ul><p>Klien Go dapat menggunakan <a href=/docs/concepts/cluster-administration/authenticate-across-clusters-kubeconfig/>berkas kubeconfig</a> yang sama dengan yang digunakan oleh CLI kubectl untuk mencari dan mengautentikasi ke apiserver. Lihat <a href=https://git.k8s.io/client-go/examples/out-of-cluster-client-configuration/main.go>contoh ini</a>.</p><p>Jika aplikasi ini digunakan sebagai Pod di klaster, silakan lihat <a href=#mengakses-api-dari-pod>bagian selanjutnya</a>.</p><h3 id=klien-python>Klien Python</h3><p>Untuk menggunakan <a href=https://github.com/kubernetes-client/python>klien Python</a>, jalankan perintah berikut: <code>pip install kubernetes</code>. Lihat <a href=https://github.com/kubernetes-client/python>halaman Pustaka Klien Python</a> untuk opsi instalasi lainnya.</p><p>Klien Python dapat menggunakan <a href=/docs/concepts/cluster-administration/authenticate-across-clusters-kubeconfig/>berkas kubeconfig</a> yang sama dengan yang digunakan oleh CLI kubectl untuk mencari dan mengautentikasi ke apiserver. Lihat <a href=https://github.com/kubernetes-client/python/tree/master/examples>contoh</a>.</p><h3 id=bahasa-lainnya>Bahasa lainnya</h3><p>Ada <a href=/docs/reference/using-api/client-libraries/>pustaka klien</a> untuk mengakses API dari bahasa lain.
Lihat dokumentasi pustaka lain untuk melihat bagaimana mereka melakukan autentikasi.</p><h2 id=mengakses-api-dari-pod>Mengakses API dari Pod</h2><p>Saat mengakses API dari Pod, pencarian dan autentikasi ke apiserver agak berbeda.</p><p>Cara yang disarankan untuk menemukan apiserver di dalam Pod adalah dengan nama DNS <code>kubernetes.default.svc</code>,
yang akan mengubah kedalam bentuk Service IP yang pada gilirannya akan dialihkan ke apiserver.</p><p>Cara yang disarankan untuk mengautentikasi ke apiserver adalah dengan kredensial <a href=/id/docs/tasks/configure-pod-container/configure-service-account/>akun servis</a>.
Oleh kube-system, Pod dikaitkan dengan sebuah akun servis (<em>service account</em>), dan sebuah kredensial (token) untuk akun servis (<em>service account</em>) tersebut ditempatkan ke pohon sistem berkas (<em>file system tree</em>) dari setiap Container di dalam Pod tersebut,
di <code>/var/run/secrets/kubernetes.io/serviceaccount/token</code>.</p><p>Jika tersedia, bundel sertifikat elektronik ditempatkan ke pohon sistem berkas dari setiap Container di <code>/var/run/secrets/kubernetes.io/serviceaccount/ca.crt</code>,
dan itu akan digunakan untuk memverifikasi sertifikat elektronik yang digunakan apiserver untuk meladen.</p><p>Terakhir, Namespace <code>default</code> yang akan digunakan untuk operasi API <em>namespaced</em> ditempatkan di dalam berkas <code>/var/run/secrets/kubernetes.io/serviceaccount/namespace</code> di dalam setiap Container.</p><p>Dari dalam Pod, cara yang disarankan untuk menghubungi API adalah:</p><ul><li>Jalankan <code>kubectl proxy</code> pada Container <em>sidecar</em> di dalam Pod, atau sebagai proses <em>background</em> di dalam Container.
Perintah tersebut memproksi API Kubernetes pada antarmuka localhost Pod tersebut, sehingga proses lain dalam Container apa pun milik Pod dapat mengaksesnya.</li><li>Gunakan pustaka klien Go, dan buatlah sebuah klien menggunakan fungsi <code>rest.InClusterConfig()</code> dan <code>kubernetes.NewForConfig()</code>.
Mereka menangani pencarian dan autentikasi ke apiserver. <a href=https://git.k8s.io/client-go/examples/in-cluster-client-configuration/main.go>contoh</a></li></ul><p>Pada setiap kasus, kredensial Pod digunakan untuk berkomunikasi secara aman dengan apiserver.</p><h2 id=mengakses-servis-yang-berjalan-di-klaster>Mengakses servis yang berjalan di klaster</h2><p>Bagian sebelumnya menjelaskan tentang menghubungi server API Kubernetes. Bagian ini menjelaskan tentang menghubungi servis lain yang berjalan di klaster Kubernetes.
Di Kubernetes, semua <a href=/docs/admin/node>Node</a>, <a href=/docs/user-guide/pods>Pod</a>, dan <a href=/docs/user-guide/services>Service</a> memiliki IP sendiri.
Dalam banyak kasus, IP Node, IP Pod, dan beberapa IP Service pada sebuah klaster tidak dapat dirutekan, sehingga mereka tidak terjangkau dari mesin di luar klaster, seperti mesin desktop kamu.</p><h3 id=cara-untuk-terhubung>Cara untuk terhubung</h3><p>Kamu memiliki beberapa opsi untuk menghubungi Node, Pod, dan Service dari luar klaster:</p><ul><li>Mengakses Service melalui IP publik.<ul><li>Gunakan Service dengan tipe <code>NodePort</code> atau <code>LoadBalancer</code> untuk membuat Service dapat dijangkau di luar klaster. Lihat dokumentasi <a href=/docs/user-guide/services>Service</a> dan perintah <a href=/docs/reference/generated/kubectl/kubectl-commands/#expose>kubectl expose</a>.</li><li>Bergantung pada lingkungan klaster kamu, hal ini mungkin hanya mengekspos Service ke jaringan perusahaan kamu, atau mungkin mengeksposnya ke internet. Pikirkan apakah Service yang diekspos aman atau tidak. Apakah layanan di balik Service tersebut melakukan autentikasinya sendiri?</li><li>Tempatkan Pod di belakang Service. Untuk mengakses satu Pod tertentu dari sekumpulan replika, misalnya untuk pengawakutuan (<em>debugging</em>), letakkan label unik di Pod dan buat Service baru yang memilih label ini.</li><li>Pada kebanyakan kasus, pengembang aplikasi tidak perlu langsung mengakses Node melalui IP Node mereka.</li></ul></li><li>Akses Service, Node, atau Pod menggunakan <em>Verb</em> Proxy.<ul><li>Apakah autentikasi dan otorisasi apiserver dilakukan sebelum mengakses Service jarak jauh. Gunakan ini jika Service tersebut tidak cukup aman untuk diekspos ke internet, atau untuk mendapatkan akses ke porta (<em>port</em>) pada IP Node, atau untuk pengawakutuan.</li><li>Proksi dapat menyebabkan masalah untuk beberapa aplikasi web.</li><li>Hanya bekerja pada HTTP/HTTPS.</li><li>Dijelaskan <a href=#url-proxy-apiserver-secara-manual>di sini</a>.</li></ul></li><li>Akses dari Node atau Pod di klaster.<ul><li>Jalankan Pod, kemudian hubungkan ke sebuah <em>shell</em> di dalamnya menggunakan <a href=/docs/reference/generated/kubectl/kubectl-commands/#exec>kubectl exec</a>. Hubungi Node, Pod, dan Service lain dari <em>shell</em> itu.</li><li>Beberapa klaster memungkinkan kamu untuk melakukan SSH ke sebuah Node di dalam klaster. Dari sana, kamu mungkin dapat mengakses Service-Service klaster. Hal ini merupakan metode yang tidak standar, dan akan bekerja pada beberapa klaster tetapi tidak pada yang lain. Peramban dan perkakas lain mungkin diinstal atau tidak. DNS Klaster mungkin tidak berfungsi.</li></ul></li></ul><h3 id=menemukan-service-bawaan-builtin>Menemukan Service bawaan (<em>builtin</em>)</h3><p>Biasanya, ada beberapa Service yang dimulai pada sebuah klaster oleh kube-system. Dapatkan daftarnya dengan perintah <code>kubectl cluster-info</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl cluster-info
</span></span></code></pre></div><p>Keluarannya mirip seperti ini:</p><pre tabindex=0><code>Kubernetes master is running at https://104.197.5.247
elasticsearch-logging is running at https://104.197.5.247/api/v1/namespaces/kube-system/services/elasticsearch-logging/proxy
kibana-logging is running at https://104.197.5.247/api/v1/namespaces/kube-system/services/kibana-logging/proxy
kube-dns is running at https://104.197.5.247/api/v1/namespaces/kube-system/services/kube-dns/proxy
grafana is running at https://104.197.5.247/api/v1/namespaces/kube-system/services/monitoring-grafana/proxy
heapster is running at https://104.197.5.247/api/v1/namespaces/kube-system/services/monitoring-heapster/proxy
</code></pre><p>Ini menunjukkan URL <em>proxy-verb</em> untuk mengakses setiap Service.
Misalnya, klaster ini mempunyai pencatatan log pada level klaster (<em>cluster-level logging</em>) yang aktif (menggunakan Elasticsearch), yang dapat dicapai di <code>https://104.197.5.247/api/v1/namespaces/kube-system/services/elasticsearch-logging/proxy/</code> jika kredensial yang sesuai diberikan.
Pencatatan log dapat pula dicapai dengan sebuah proksi <em>kubectl</em>, misalnya di:
<code>http://localhost:8080/api/v1/namespaces/kube-system/services/elasticsearch-logging/proxy/</code>.
(Lihat <a href=#mengakses-rest-api-secara-langsung>di atas</a> untuk panduan bagaimana cara meneruskan kredensial atau menggunakan <code>kubectl proxy</code>.)</p><h4 id=membuat-url-proksi-apiserver-secara-manual>Membuat URL proksi apiserver secara manual</h4><p>Seperti disebutkan di atas, kamu menggunakan perintah <code>kubectl cluster-info</code> untuk mendapatkan URL proksi suatu Service.
Untuk membuat URL proksi yang memuat <em>endpoint-endpoint</em> Service, sufiks, dan parameter, kamu cukup menambahkan ke URL proksi Service:
<code>http://</code><em><code>alamat_kubernetes_master</code></em><code>/api/v1/namespaces/</code><em><code>nama_namespace</code></em><code>/services/</code><em><code>nama_servis[:nama_porta]</code></em><code>/proxy</code></p><p>Jika kamu belum menentukan nama untuk porta kamu, kamu tidak perlu memasukan <em>nama_porta</em> di URL.</p><p>Secara bawaan, server API memproksi ke Service kamu menggunakan HTTP. Untuk menggunakan HTTPS, awali nama Service dengan <code>https:</code>:
<code>http://</code><em><code>alamat_kubernetes_master</code></em><code>/api/v1/namespaces/</code><em><code>nama_namespace</code></em><code>/services/</code><em><code>https:nama_servis:[nama_porta]</code></em><code>/proxy</code></p><p>Format yang didukung untuk segmen nama URL adalah:</p><ul><li><code>&lt;nama_servis></code> - Memproksi ke porta bawaan atau porta tanpa nama menggunakan HTTP</li><li><code>&lt;nama_servis>:&lt;nama_porta></code> - Memproksi ke porta yang telah ditentukan menggunakan HTTP</li><li><code>https:&lt;nama_servis>:</code> - Memproksi ke porta bawaan atau porta tanpa nama menggunakan HTTPS (perhatikan tanda adanya titik dua)</li><li><code>https:&lt;nama_servis>:&lt;nama_porta></code> - proksi ke porta yang telah ditentukan menggunakan https</li></ul><h5 id=contoh>Contoh</h5><ul><li>Untuk mengakses <em>endpoint</em> Service Elasticsearch <code>_search?q=user:kimchy</code>, kamu dapat menggunakan: <code>http://104.197.5.247/api/v1/namespaces/kube-system/services/elasticsearch-logging/proxy/_search?q=user:kimchy</code></li><li>Untuk mengakses informasi kesehatan klaster Elasticsearch <code>_cluster/health?pretty=true</code>, kamu dapat menggunakan: <code>https://104.197.5.247/api/v1/namespaces/kube-system/services/elasticsearch-logging/proxy/_cluster/health?pretty=true</code></li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;cluster_name&#34;</span> : <span style=color:#b44>&#34;kubernetes_logging&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;status&#34;</span> : <span style=color:#b44>&#34;yellow&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;timed_out&#34;</span> : <span style=color:#a2f;font-weight:700>false</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;number_of_nodes&#34;</span> : <span style=color:#666>1</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;number_of_data_nodes&#34;</span> : <span style=color:#666>1</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;active_primary_shards&#34;</span> : <span style=color:#666>5</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;active_shards&#34;</span> : <span style=color:#666>5</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;relocating_shards&#34;</span> : <span style=color:#666>0</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;initializing_shards&#34;</span> : <span style=color:#666>0</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;unassigned_shards&#34;</span> : <span style=color:#666>5</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=menggunakan-peramban-web-untuk-mengakses-service-yang-berjalan-di-klaster>Menggunakan peramban web untuk mengakses Service yang berjalan di klaster</h3><p>Kamu mungkin dapat memasukkan URL proksi apiserver ke bilah alamat peramban. Namun:</p><ul><li>Peramban web biasanya tidak dapat menerima token, jadi kamu mungkin perlu menggunakan autentikasi dasar/<em>basic auth</em> (kata sandi). Apiserver dapat dikonfigurasi untuk menerima autentikasi dasar, tetapi klaster kamu mungkin belum dikonfigurasi untuk menerima autentikasi dasar.</li><li>Beberapa aplikasi web mungkin tidak berfungsi, terutama yang memiliki javascript pada sisi klien yang digunakan untuk membuat URL sedemikian sehingga ia tidak mengetahui adanya prefiks jalur (<em>path</em>) proksi (<code>/proxy</code>).</li></ul><h2 id=meminta-pengalihan>Meminta pengalihan</h2><p>Kemampuan pengalihan telah usang (<em>deprecated</em>) dan dihapus. Silakan gunakan proksi (lihat di bawah) sebagai gantinya.</p><h2 id=begitu-banyaknya-proksi>Begitu Banyaknya Proksi</h2><p>Ada beberapa proksi berbeda yang mungkin kamu temui saat menggunakan Kubernetes:</p><ol><li><p><a href=#mengakses-rest-api-secara-langsung>Proksi kubectl</a>:</p><ul><li>berjalan di desktop pengguna atau di Pod</li><li>memproksi dari sebuah alamat localhost ke apiserver Kubernetes</li><li>dari klien ke proksi menggunakan HTTP</li><li>dari proksi ke apiserver menggunakan HTTPS</li><li>menemukan apiserver-nya</li><li>menambahkan <em>header-header</em> autentikasi</li></ul></li><li><p><a href=#menemukan-service-bawaan-builtin>Proksi apiserver</a>:</p><ul><li>merupakan sebuah <em>bastion</em> yang dibangun ke dalam apiserver</li><li>menghubungkan pengguna di luar klaster ke IP klaster yang mungkin tidak dapat dijangkau</li><li>berjalan dalam proses apiserver</li><li>dari klien ke proksi menggunakan HTTPS (atau HTTP jika apiserver dikonfigurasi)</li><li>dari proksi ke target dapat menggunakan HTTP atau HTTPS seperti yang dipilih oleh proksi menggunakan informasi yang tersedia</li><li>dapat digunakan untuk menjangkau Node, Pod, atau Service</li><li>melakukan <em>load balancing</em> saat digunakan untuk menjangkau sebuah Service</li></ul></li><li><p><a href=/id/docs/concepts/services-networking/service/#ips-and-vips>kube-proxy</a>:</p><ul><li>berjalan di setiap Node</li><li>memproksi UDP dan TCP</li><li>tidak mengerti HTTP</li><li>menyediakan <em>load balancing</em></li><li>hanya digunakan untuk menjangkau Service</li></ul></li><li><p>Sebuah Proksi/<em>Load-balancer</em> di depan apiserver:</p><ul><li>keberadaan dan implementasi bervariasi dari satu klaster ke klaster lainnya (mis. nginx)</li><li>terletak di antara semua klien dan satu atau lebih apiserver</li><li>bertindak sebagai <em>load balancer</em> jika terdapat beberapa apiserver.</li></ul></li><li><p><em>Cloud Load Balancer</em> pada Service eksternal:</p><ul><li>disediakan oleh beberapa penyedia layanan <em>cloud</em> (mis. AWS ELB, Google Cloud Load Balancer)</li><li>dibuat secara otomatis ketika Service Kubernetes memiliki tipe <code>LoadBalancer</code></li><li>hanya menggunakan UDP/TCP</li><li>implementasi bervariasi berdasarkan penyedia layanan <em>cloud</em>.</li></ul></li></ol><p>Pengguna Kubernetes biasanya tidak perlu khawatir tentang apa pun selain dua jenis pertama. Admin klaster biasanya akan memastikan bahwa tipe yang terakhir telah diatur dengan benar.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-5a233e14205d77fe1294917d2da6f876>4.8.3 - Mengkonfigurasi Akses ke Banyak Klaster</h1><p>Halaman ini menunjukkan bagaimana mengkonfigurasi akses ke banyak klaster dengan menggunakan
berkas (<em>file</em>) konfigurasi. Setelah semua klaster, pengguna, dan konteks didefinisikan di
satu atau lebih berkas konfigurasi, kamu akan dengan cepat berpindah antar klaster dengan menggunakan
perintah <code>kubectl config use-context</code>.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Berkas yang digunakan untuk mengkonfigurasi akses ke sebuah klaster terkadang disebut
berkas <em>kubeconfig</em>. Ini adalah cara umum untuk merujuk ke berkas konfigurasi.
Itu tidak berarti bahwa selalu ada berkas bernama <code>kubeconfig</code>.</div><h2 id=sebelum-kamu-memulai>Sebelum kamu memulai</h2><p><p>Kamu harus memiliki klaster Kubernetes, dan perangkat baris perintah kubectl
juga harus dikonfigurasikan untuk berkomunikasi dengan klastermu. Jika kamu
belum memiliki klaster, kamu dapat membuatnya dengan menggunakan
<a href=/id/docs/tasks/tools/#minikube>minikube</a>,
atau kamu juga dapat menggunakan salah satu dari tempat mencoba Kubernetes berikut ini:</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>Bermain dengan Kubernetes</a></li></ul>Untuk melihat versi, tekan <code>kubectl version</code>.</p><h2 id=mendefinisikan-klaster-pengguna-dan-konteks>Mendefinisikan klaster, pengguna, dan konteks</h2><p>Misalkan kamu memiliki dua klaster, satu untuk pekerjaan pengembangan dan satu untuk pekerjaan eksperimen (<em>scratch</em>).
Di klaster <code>pengembangan</code>, pengembang <em>frontend</em> kamu bekerja di sebuah Namespace bernama <code>frontend</code>,
dan pengembang penyimpanan kamu bekerja di sebuah Namespace bernama <code>storage</code>. Di klaster <code>scratch</code> kamu,
pengembang bekerja di Namespace <code>default</code>, atau mereka membuat Namespace tambahan sesuai keinginan mereka.
Akses ke klaster <code>development</code> membutuhkan autentikasi dengan sertifikat.
Akses ke klaster <code>scratch</code> membutuhkan autentikasi dengan nama pengguna dan kata sandi.</p><p>Buat sebuah direktori bernama <code>config-exercise</code>. Di direktori <code>config-exercise</code> kamu,
buat sebuah berkas bernama <code>config-demo</code> dengan konten ini:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>apiVersion: v1
</span></span><span style=display:flex><span>kind: Config
</span></span><span style=display:flex><span>preferences: <span style=color:#666>{}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>clusters:
</span></span><span style=display:flex><span>- cluster:
</span></span><span style=display:flex><span>  name: development
</span></span><span style=display:flex><span>- cluster:
</span></span><span style=display:flex><span>  name: scratch
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>users:
</span></span><span style=display:flex><span>- name: developer
</span></span><span style=display:flex><span>- name: experimenter
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>contexts:
</span></span><span style=display:flex><span>- context:
</span></span><span style=display:flex><span>  name: dev-frontend
</span></span><span style=display:flex><span>- context:
</span></span><span style=display:flex><span>  name: dev-storage
</span></span><span style=display:flex><span>- context:
</span></span><span style=display:flex><span>  name: exp-scratch
</span></span></code></pre></div><p>Berkas konfigurasi di atas mendeskripsikan semua klaster, pengguna, dan konteks.
Berkas <code>config-demo</code> kamu memiliki kerangka kerja untuk mendeskripsikan dua klaster, dua pengguna, dan tiga konteks.</p><p>Buka direktori <code>config-exercise</code> kamu. Masukkan perintah-perintah berikut untuk menambahkan detail ke
berkas konfigurasi kamu:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo set-cluster development --server<span style=color:#666>=</span>https://1.2.3.4 --certificate-authority<span style=color:#666>=</span>fake-ca-file
</span></span><span style=display:flex><span>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo set-cluster scratch --server<span style=color:#666>=</span>https://5.6.7.8 --insecure-skip-tls-verify
</span></span></code></pre></div><p>Tambahkan detail pengguna ke berkas konfigurasi kamu:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo set-credentials developer --client-certificate<span style=color:#666>=</span>fake-cert-file --client-key<span style=color:#666>=</span>fake-key-seefile
</span></span><span style=display:flex><span>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo set-credentials experimenter --username<span style=color:#666>=</span>exp --password<span style=color:#666>=</span>some-password
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong><ul><li>Untuk menghapus sebuah pengguna, kamu dapat menjalankan perintah <code>kubectl --kubeconfig=config-demo config unset users.&lt;name></code></li><li>Untuk menghapus sebuah klaster, kamu dapat menjalankan perintah <code>kubectl --kubeconfig=config-demo config unset clusters.&lt;name></code></li><li>Untuk menghapus sebuah konteks, kamu dapat menjalankan perintah <code>kubectl --kubeconfig=config-demo config unset contexts.&lt;name></code></li></ul></div><p>Tambahkan detail konteks ke berkas konfigurasi kamu:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo set-context dev-frontend --cluster<span style=color:#666>=</span>development --namespace<span style=color:#666>=</span>frontend --user<span style=color:#666>=</span>developer
</span></span><span style=display:flex><span>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo set-context dev-storage --cluster<span style=color:#666>=</span>development --namespace<span style=color:#666>=</span>storage --user<span style=color:#666>=</span>developer
</span></span><span style=display:flex><span>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo set-context exp-scratch --cluster<span style=color:#666>=</span>scratch --namespace<span style=color:#666>=</span>default --user<span style=color:#666>=</span>experimenter
</span></span></code></pre></div><p>Buka berkas <code>config-demo</code> kamu untuk melihat detail-detail yang telah ditambah. Sebagai alternatif dari membuka
berkas <code>config-demo</code>, kamu bisa menggunakan perintah <code>config view</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo view
</span></span></code></pre></div><p>Keluaran akan menampilkan dua klaster, dua pengguna, dan tiga konteks:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>apiVersion: v1
</span></span><span style=display:flex><span>clusters:
</span></span><span style=display:flex><span>- cluster:
</span></span><span style=display:flex><span>    certificate-authority: fake-ca-file
</span></span><span style=display:flex><span>    server: https://1.2.3.4
</span></span><span style=display:flex><span>  name: development
</span></span><span style=display:flex><span>- cluster:
</span></span><span style=display:flex><span>    insecure-skip-tls-verify: <span style=color:#a2f>true</span>
</span></span><span style=display:flex><span>    server: https://5.6.7.8
</span></span><span style=display:flex><span>  name: scratch
</span></span><span style=display:flex><span>contexts:
</span></span><span style=display:flex><span>- context:
</span></span><span style=display:flex><span>    cluster: development
</span></span><span style=display:flex><span>    namespace: frontend
</span></span><span style=display:flex><span>    user: developer
</span></span><span style=display:flex><span>  name: dev-frontend
</span></span><span style=display:flex><span>- context:
</span></span><span style=display:flex><span>    cluster: development
</span></span><span style=display:flex><span>    namespace: storage
</span></span><span style=display:flex><span>    user: developer
</span></span><span style=display:flex><span>  name: dev-storage
</span></span><span style=display:flex><span>- context:
</span></span><span style=display:flex><span>    cluster: scratch
</span></span><span style=display:flex><span>    namespace: default
</span></span><span style=display:flex><span>    user: experimenter
</span></span><span style=display:flex><span>  name: exp-scratch
</span></span><span style=display:flex><span>current-context: <span style=color:#b44>&#34;&#34;</span>
</span></span><span style=display:flex><span>kind: Config
</span></span><span style=display:flex><span>preferences: <span style=color:#666>{}</span>
</span></span><span style=display:flex><span>users:
</span></span><span style=display:flex><span>- name: developer
</span></span><span style=display:flex><span>  user:
</span></span><span style=display:flex><span>    client-certificate: fake-cert-file
</span></span><span style=display:flex><span>    client-key: fake-key-file
</span></span><span style=display:flex><span>- name: experimenter
</span></span><span style=display:flex><span>  user:
</span></span><span style=display:flex><span>    password: some-password
</span></span><span style=display:flex><span>    username: exp
</span></span></code></pre></div><p><code>fake-ca-file</code>, <code>fake-cert-file</code>, dan <code>fake-key-file</code> di atas adalah <em>placeholder</em>
untuk nama jalur (<em>pathname</em>) dari berkas-berkas sertifikat. Kamu harus menggantinya menjadi nama jalur
sebenarnya dari berkas-berkas sertifikat di dalam lingkungan (<em>environment</em>) kamu.</p><p>Terkadang kamu mungkin ingin menggunakan data yang disandikan Base64 yang langsung dimasukkan di berkas konfigurasi
daripada menggunakan berkas sertifikat yang terpisah. Dalam kasus ini, kamu perlu menambahkan akhiran <code>-data</code> ke kunci. Contoh, <code>certificate-authority-data</code>, <code>client-certificate-data</code>, dan <code>client-key-data</code>.</p><p>Setiap konteks memiliki tiga bagian: klaster, pengguna, dan Namespace.
Sebagai contoh, konteks <code>dev-frontend</code> menyatakan, "Gunakan kredensial dari pengguna <code>developer</code>
untuk mengakses Namespace <code>frontend</code> di klaster <code>development</code>.</p><p>Mengatur konteks yang digunakan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo use-context dev-frontend
</span></span></code></pre></div><p>Sekarang kapanpun kamu memasukkan perintah <code>kubectl</code>, aksi tersebut akan diterapkan untuk klaster,
dan Namespace yang terdaftar pada konteks <code>dev-frontend</code>. Dan perintah tersebut akan menggunakan
kredensial dari pengguna yang terdaftar pada konteks <code>dev-frontend</code>.</p><p>Untuk melihat hanya informasi konfigurasi yang berkaitan dengan konteks saat ini,
gunakan <code>--minify</code> flag.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo view --minify
</span></span></code></pre></div><p>Output menunjukkan informasi konfigurasi yang berkaitan dengan konteks <code>dev-frontend</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>apiVersion: v1
</span></span><span style=display:flex><span>clusters:
</span></span><span style=display:flex><span>- cluster:
</span></span><span style=display:flex><span>    certificate-authority: fake-ca-file
</span></span><span style=display:flex><span>    server: https://1.2.3.4
</span></span><span style=display:flex><span>  name: development
</span></span><span style=display:flex><span>contexts:
</span></span><span style=display:flex><span>- context:
</span></span><span style=display:flex><span>    cluster: development
</span></span><span style=display:flex><span>    namespace: frontend
</span></span><span style=display:flex><span>    user: developer
</span></span><span style=display:flex><span>  name: dev-frontend
</span></span><span style=display:flex><span>current-context: dev-frontend
</span></span><span style=display:flex><span>kind: Config
</span></span><span style=display:flex><span>preferences: <span style=color:#666>{}</span>
</span></span><span style=display:flex><span>users:
</span></span><span style=display:flex><span>- name: developer
</span></span><span style=display:flex><span>  user:
</span></span><span style=display:flex><span>    client-certificate: fake-cert-file
</span></span><span style=display:flex><span>    client-key: fake-key-file
</span></span></code></pre></div><p>Sekarang apabila kamu ingin bekerja sebentar di klaster eksperimen.</p><p>Ubah konteks saat ini menjadi <code>exp-scratch</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo use-context exp-scratch
</span></span></code></pre></div><p>Sekarang, setiap perintah <code>kubectl</code> yang diberikan akan berlaku untuk Namespace <code>default</code>
dari klaster <code>scratch</code>. Dan perintah akan menggunakan kredensial dari pengguna yang
terdaftar di konteks <code>exp-scratch</code>.</p><p>Untuk melihat konfigurasi yang berkaitan dengan konteks saat ini, <code>exp-scratch</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo view --minify
</span></span></code></pre></div><p>Akhirnya, misalkan kamu ingin bekerja sebentar di Namespace <code>storage</code> pada
klaster <code>development</code>.</p><p>Ubah konteks saat ini menjadi <code>dev-storage</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo use-context dev-storage
</span></span></code></pre></div><p>Untuk melihat konfigurasi yang berkaitan dengan konteks baru saat ini, <code>dev-storage</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config --kubeconfig<span style=color:#666>=</span>config-demo view --minify
</span></span></code></pre></div><h2 id=membuat-sebuah-berkas-konfigurasi-kedua>Membuat sebuah berkas konfigurasi kedua</h2><p>Di direktori <code>config-exercise</code> kamu, buat sebuah berkas bernama <code>config-demo-2</code> dengan konten ini:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>apiVersion: v1
</span></span><span style=display:flex><span>kind: Config
</span></span><span style=display:flex><span>preferences: <span style=color:#666>{}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>contexts:
</span></span><span style=display:flex><span>- context:
</span></span><span style=display:flex><span>    cluster: development
</span></span><span style=display:flex><span>    namespace: ramp
</span></span><span style=display:flex><span>    user: developer
</span></span><span style=display:flex><span>  name: dev-ramp-up
</span></span></code></pre></div><p>Berkas konfigurasi di atas mendefinisikan sebuah konteks baru bernama <code>dev-ramp-up</code>.</p><h2 id=mengatur-variabel-lingkungan-kubeconfig>Mengatur variabel lingkungan KUBECONFIG</h2><p>Lihat apakah kamu sudah memiliki sebuah variabel lingkungan bernama <code>KUBECONFIG</code>.
Jika iya, simpan nilai saat ini dari variabel lingkungan <code>KUBECONFIG</code> kamu, sehingga kamu dapat mengembalikannya nanti.
Sebagai contohL</p><h3 id=linux>Linux</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>export</span> <span style=color:#b8860b>KUBECONFIG_SAVED</span><span style=color:#666>=</span><span style=color:#b8860b>$KUBECONFIG</span>
</span></span></code></pre></div><h3 id=windows-powershell>Windows PowerShell</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#b8860b>$Env</span>:KUBECONFIG_SAVED<span style=color:#666>=</span><span style=color:#b8860b>$ENV</span>:KUBECONFIG
</span></span></code></pre></div><p>Variabel lingkungan <code>KUBECONFIG</code> adalah sebuah daftar dari jalur-jalur (beragam <em>path</em>) menuju berkas konfigurasi.
Daftar ini dibatasi oleh tanda titik dua untuk Linux dan Mac, dan tanda titik koma untuk Windows. Jika kamu
memiliki sebuah variabel lingkungan <code>KUBECONFIG</code>, biasakan diri kamu dengan berkas-berkas konfigurasi
yang ada pada daftar.</p><p>Tambahkan sementara dua jalur ke variabel lingkungan <code>KUBECONFIG</code> kamu. Sebagai contoh:</p><h3 id=linux-1>Linux</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>export</span> <span style=color:#b8860b>KUBECONFIG</span><span style=color:#666>=</span><span style=color:#b8860b>$KUBECONFIG</span>:config-demo:config-demo-2
</span></span></code></pre></div><h3 id=windows-powershell-1>Windows PowerShell</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#b8860b>$Env</span>:KUBECONFIG<span style=color:#666>=(</span><span style=color:#b44>&#34;config-demo;config-demo-2&#34;</span><span style=color:#666>)</span>
</span></span></code></pre></div><p>Di direktori <code>config-exercise</code> kamu, masukan perintah ini:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config view
</span></span></code></pre></div><p>Keluaran menunjukkan informasi gabungan dari semua berkas yang terdaftar dalam variabel lingkungan <code>KUBECONFIG</code> kamu.
Secara khusus, perhatikan bahwa informasi gabungan tersebut memiliki konteks <code>dev-ramp-up</code>, konteks dari berkas
<code>config-demo-2</code>, dan tiga konteks dari berkas <code>config-demo</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>contexts:
</span></span><span style=display:flex><span>- context:
</span></span><span style=display:flex><span>    cluster: development
</span></span><span style=display:flex><span>    namespace: frontend
</span></span><span style=display:flex><span>    user: developer
</span></span><span style=display:flex><span>  name: dev-frontend
</span></span><span style=display:flex><span>- context:
</span></span><span style=display:flex><span>    cluster: development
</span></span><span style=display:flex><span>    namespace: ramp
</span></span><span style=display:flex><span>    user: developer
</span></span><span style=display:flex><span>  name: dev-ramp-up
</span></span><span style=display:flex><span>- context:
</span></span><span style=display:flex><span>    cluster: development
</span></span><span style=display:flex><span>    namespace: storage
</span></span><span style=display:flex><span>    user: developer
</span></span><span style=display:flex><span>  name: dev-storage
</span></span><span style=display:flex><span>- context:
</span></span><span style=display:flex><span>    cluster: scratch
</span></span><span style=display:flex><span>    namespace: default
</span></span><span style=display:flex><span>    user: experimenter
</span></span><span style=display:flex><span>  name: exp-scratch
</span></span></code></pre></div><p>Untuk informasi lebih tentang bagaimana berkas Kubeconfig tergabung, lihat
<a href=/id/docs/concepts/configuration/organize-cluster-access-kubeconfig/>Mengatur Akses Cluster Menggunakan Berkas Kubeconfig</a></p><h2 id=jelajahi-direktori-home-kube>Jelajahi direktori $HOME/.kube</h2><p>Jika kamu sudah memiliki sebuah klaster, dan kamu bisa menggunakan <code>kubectl</code> untuk berinteraksi dengan
klaster kamu, kemudian kamu mungkin memiliki sebuah berkas bernama <code>config</code> di
direktori <code>$HOME/.kube</code>.</p><p>Buka <code>$HOME/.kube</code>, dan lihat berkas-berkas apa saja yang ada. Biasanya ada berkas bernama
<code>config</code>. Mungkin juga ada berkas-berkas konfigurasi lain di direktori ini.
Biasakan diri anda dengan konten-konten yang ada di berkas-berkas tersebut.</p><h2 id=tambahkan-home-kube-config-ke-variabel-lingkungan-kubeconfig-kamu>Tambahkan $HOME/.kube/config ke variabel lingkungan KUBECONFIG kamu</h2><p>Jika kamu memiliki sebuah berkas <code>$HOME/.kube/config</code>, dan belum terdaftar dalam variabel lingungan
<code>KUBECONFIG</code> kamu, tambahkan berkas tersebut ke variabel lingkungan <code>KUBECONFIG</code> kamu sekarang.
Sebagai contoh:</p><h3 id=linux-2>Linux</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>export</span> <span style=color:#b8860b>KUBECONFIG</span><span style=color:#666>=</span><span style=color:#b8860b>$KUBECONFIG</span>:<span style=color:#b8860b>$HOME</span>/.kube/config
</span></span></code></pre></div><h3 id=windows-powershell-2>Windows Powershell</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#b8860b>$Env</span>:KUBECONFIG<span style=color:#666>=(</span><span style=color:#b8860b>$Env</span>:KUBECONFIG;<span style=color:#b8860b>$HOME</span>/.kube/config<span style=color:#666>)</span>
</span></span></code></pre></div><p>Lihat gabungan informasi konfigurasi dari semua berkas yang sekarang tergabung
dalam variabel lingkungan <code>KUBECONFIG</code> kamu. Di direktori <code>config-exercise</code> kamu, masukkan perintah:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config view
</span></span></code></pre></div><h2 id=membersihkan>Membersihkan</h2><p>Kembalikan variabel lingkungan <code>KUBECONFIG</code> kamu ke nilai asilnya. Sebagai contoh:<br></p><h3 id=linux-3>Linux</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>export</span> <span style=color:#b8860b>KUBECONFIG</span><span style=color:#666>=</span><span style=color:#b8860b>$KUBECONFIG_SAVED</span>
</span></span></code></pre></div><h3 id=windows-powershell-3>Windows PowerShell</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#b8860b>$Env</span>:KUBECONFIG<span style=color:#666>=</span><span style=color:#b8860b>$ENV</span>:KUBECONFIG_SAVED
</span></span></code></pre></div><h2 id=selanjutnya>Selanjutnya</h2><ul><li><a href=/id/docs/concepts/configuration/organize-cluster-access-kubeconfig/>Mengatur Akses Cluster Menggunakan Berkas Kubeconfig</a></li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#config>kubectl config</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-72d3dddbc0c166c9a364e753d2b31ff0>4.8.4 - Menggunakan Port Forwarding untuk Mengakses Aplikasi di sebuah Klaster</h1><p>Halaman ini menunjukkan bagaimana menggunakan <code>kubectl port-forward</code> untuk menghubungkan sebuah server Redis yang sedang berjalan di sebuah klaster Kubernetes. Tipe dari koneksi ini dapat berguna untuk melakukan <em>debugging</em> basis data.</p><h2 id=sebelum-kamu-memulai>Sebelum kamu memulai</h2><p><p>Kamu harus memiliki klaster Kubernetes, dan perangkat baris perintah kubectl
juga harus dikonfigurasikan untuk berkomunikasi dengan klastermu. Jika kamu
belum memiliki klaster, kamu dapat membuatnya dengan menggunakan
<a href=/id/docs/tasks/tools/#minikube>minikube</a>,
atau kamu juga dapat menggunakan salah satu dari tempat mencoba Kubernetes berikut ini:</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>Bermain dengan Kubernetes</a></li></ul>Kubernetes servermu harus dalam versi yang sama atau lebih baru dari v1.10.
Untuk melihat versi, tekan <code>kubectl version</code>.</p><ul><li>Install <a href=http://redis.io/topics/rediscli>redis-cli</a>.</li></ul><h2 id=membuat-deployment-dan-service-redis>Membuat Deployment dan Service Redis</h2><ol><li><p>Buat sebuah Deployment yang menjalankan Redis:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/application/guestbook/redis-master-deployment.yaml
</span></span></code></pre></div><p>Keluaran dari sebuah perintah yang sukses akan memverifikasi bahwa Deployment telah terbuat:</p><pre tabindex=0><code>deployment.apps/redis-master created
</code></pre><p>Lihat status Pod untuk memeriksa apakah sudah siap:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods
</span></span></code></pre></div><p>Keluaran menampilkan Pod yang telah terbuat:</p><pre tabindex=0><code>NAME                            READY     STATUS    RESTARTS   AGE
redis-master-765d459796-258hz   1/1       Running   0          50s
</code></pre><p>Lihat status Deployment:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get deployment
</span></span></code></pre></div><p>Keluaran menampilkan bahwa Deployment telah terbuat:</p><pre tabindex=0><code>NAME         READY   UP-TO-DATE   AVAILABLE   AGE
redis-master 1/1     1            1           55s
</code></pre><p>Deployment secara otomatis mengatur sebuah ReplicaSet.
Lihat status ReplicaSet menggunakan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get replicaset
</span></span></code></pre></div><p>Keluaran menampilkan bahwa ReplicaSet telah terbuat:</p><pre tabindex=0><code>NAME                      DESIRED   CURRENT   READY     AGE
redis-master-765d459796   1         1         1         1m
</code></pre></li><li><p>Buat sebuah Service untuk mengekspos Redis di jaringan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/application/guestbook/redis-master-service.yaml
</span></span></code></pre></div><p>Keluaran dari perintah yang sukses akan memverifikasi bahwa Service telah terbuat:</p><pre tabindex=0><code>service/redis-master created
</code></pre><p>Lihat Service yang telah terbuat menggunakan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get service redis-master
</span></span></code></pre></div><p>Keluaran menampilkan service yang telah terbuat:</p><pre tabindex=0><code>NAME           TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)    AGE
redis-master   ClusterIP   10.0.0.213   &lt;none&gt;        6379/TCP   27s
</code></pre></li><li><p>Periksa apakah server Redis berjalan di Pod, dan mendengarkan porta 6379:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Ubah redis-master-765d459796-258hz menjadi nama Pod</span>
</span></span><span style=display:flex><span>kubectl get pod redis-master-765d459796-258hz --template<span style=color:#666>=</span><span style=color:#b44>&#39;{{(index (index .spec.containers 0).ports 0).containerPort}}{{&#34;\n&#34;}}&#39;</span>
</span></span></code></pre></div><p>Keluaran akan menampilkan porta dari Redis di Pod tersebut:</p><pre tabindex=0><code>6379
</code></pre><p>(ini adalah porta TCP yang dialokasi untuk Redis di internet)</p></li></ol><h2 id=meneruskan-sebuah-porta-lokal-ke-sebuah-porta-pada-pod>Meneruskan sebuah porta lokal ke sebuah porta pada Pod</h2><ol><li><p><code>kubectl port-forward</code> memungkinkan penggunaan nama sumber daya, seperti sebuah nama Pod, untuk memilih Pod yang sesuai untuk melakukan penerusan porta.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Ubah redis-master-765d459796-258hz menjadi nama Pod</span>
</span></span><span style=display:flex><span>kubectl port-forward redis-master-765d459796-258hz 7000:6379
</span></span></code></pre></div><p>yang sama seperti</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl port-forward pods/redis-master-765d459796-258hz 7000:6379
</span></span></code></pre></div><p>atau</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl port-forward deployment/redis-master 7000:6379
</span></span></code></pre></div><p>atau</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl port-forward replicaset/redis-master 7000:6379
</span></span></code></pre></div><p>atau</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl port-forward service/redis-master 7000:6379
</span></span></code></pre></div><p>Semua perintah di atas berfungsi. Keluarannya mirip dengan ini:</p><pre tabindex=0><code>I0710 14:43:38.274550    3655 portforward.go:225] Forwarding from 127.0.0.1:7000 -&gt; 6379
I0710 14:43:38.274797    3655 portforward.go:225] Forwarding from [::1]:7000 -&gt; 6379
</code></pre></li><li><p>Memulai antarmuka baris perintah (<em>command line</em>) Redis:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>redis-cli -p <span style=color:#666>7000</span>
</span></span></code></pre></div></li><li><p>Pada baris perintah di Redis, masukkan perintah <code>ping</code>:</p><pre tabindex=0><code>ping
</code></pre><p>Sebuah permintaan <em>ping</em> yang sukses akan mengembalikan:</p><pre tabindex=0><code>PONG
</code></pre></li></ol><h2 id=diskusi>Diskusi</h2><p>Koneksi-koneksi yang dibuat ke porta lokal 7000 diteruskan ke porta 6379 dari Pod yang menjalankan server Redis.
Dengan koneksi ini, kamu dapat menggunakan <em>workstation</em> lokal untuk melakukan <em>debug</em> basis data yang berjalan di Pod.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> <code>kubectl port-forward</code> hanya bisa diimplementasikan untuk porta TCP saja.
Dukungan untuk protokol UDP bisa dilihat di
<a href=https://github.com/kubernetes/kubernetes/issues/47862>issue 47862</a>.</div><h2 id=selanjutnya>Selanjutnya</h2><p>Belajar lebih tentang <a href=/docs/reference/generated/kubectl/kubectl-commands/#port-forward>kubectl port-forward</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-21cd8f87563675fb0278d3694ba9ecb0>4.8.5 - Membuat Load Balancer Eksternal</h1><p>Laman ini menjelaskan bagaimana membuat <em>Load Balancer</em> Eksternal.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Fitur ini hanya tersedia untuk penyedia cloud atau lingkungan yang mendukung <em>load balancer</em> eksternal.</div><p>Ketika membuat Service, kamu mempunyai opsi untuk tersambung dengan jaringan cloud <em>load balancer</em> secara otomatis.
Hal ini menyediakan akses eksternal alamat IP yang dapat mengirim lalu lintas melalui porta yang tepat pada klaster Node kamu
<em>asalkan klaster kamu beroperasi pada lingkungan yang mendukung dan terkonfigurasi dengan paket penyedia cloud load balancer yang benar</em>.</p><p>Untuk informasi mengenai penyediaan dan penggunaan sumber daya Ingress yang dapat memberikan
servis URL yang dapat dijangkau secara eksternal, penyeimbang beban lalu lintas, terminasi SSL, dll.,
silahkan cek dokumentasi <a href=/id/docs/concepts/services-networking/ingress/>Ingress</a></p><h2 id=sebelum-kamu-memulai>Sebelum kamu memulai</h2><ul><li><p>Kamu harus memiliki klaster Kubernetes, dan perangkat baris perintah kubectl
juga harus dikonfigurasikan untuk berkomunikasi dengan klastermu. Jika kamu
belum memiliki klaster, kamu dapat membuatnya dengan menggunakan
<a href=/id/docs/tasks/tools/#minikube>minikube</a>,
atau kamu juga dapat menggunakan salah satu dari tempat mencoba Kubernetes berikut ini:</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>Bermain dengan Kubernetes</a></li></ul>Untuk melihat versi, tekan <code>kubectl version</code>.</li></ul><h2 id=berkas-konfigurasi>Berkas konfigurasi</h2><p>Untuk membuat <em>load balancer</em> eksternal, tambahkan baris di bawah ini ke
<a href=/id/docs/concepts/services-networking/service/#loadbalancer>berkas konfigurasi Service</a> kamu:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>LoadBalancer<span style=color:#bbb>
</span></span></span></code></pre></div><p>Berkas konfigurasi kamu mungkin terlihat seperti ini:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>8765</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>LoadBalancer<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=menggunakan-kubectl>Menggunakan kubectl</h2><p>Kamu dapat membuat Service dengan perintah <code>kubectl expose</code> dan
<em>flag</em> <code>--type=LoadBalancer</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl expose rc example --port<span style=color:#666>=</span><span style=color:#666>8765</span> --target-port<span style=color:#666>=</span><span style=color:#666>9376</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>        --name<span style=color:#666>=</span>example-service --type<span style=color:#666>=</span>LoadBalancer
</span></span></code></pre></div><p>Perintah ini membuat Service baru dengan menggunakan pemilih yang sama dengan
sumber daya yang dirujuk (dalam hal contoh di atas, ReplicationController bernama <code>example</code>).</p><p>Untuk informasi lebih lanjut, termasuk opsi <em>flag</em>, mengacu kepada
<a href=/docs/reference/generated/kubectl/kubectl-commands/#expose>referensi <code>kubectl expose</code></a>.</p><h2 id=menemukan-alamat-ip-kamu>Menemukan alamat IP kamu</h2><p>Kamu dapat menemukan alamat IP yang telah dibuat untuk Service kamu dengan mendapatkan
informasi Service melalui <code>kubectl</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl describe services example-service
</span></span></code></pre></div><p>yang seharusnya menghasilkan keluaran seperti ini:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>    Name:                   example-service
</span></span><span style=display:flex><span>    Namespace:              default
</span></span><span style=display:flex><span>    Labels:                 &lt;none&gt;
</span></span><span style=display:flex><span>    Annotations:            &lt;none&gt;
</span></span><span style=display:flex><span>    Selector:               <span style=color:#b8860b>app</span><span style=color:#666>=</span>example
</span></span><span style=display:flex><span>    Type:                   LoadBalancer
</span></span><span style=display:flex><span>    IP:                     10.67.252.103
</span></span><span style=display:flex><span>    LoadBalancer Ingress:   192.0.2.89
</span></span><span style=display:flex><span>    Port:                   &lt;unnamed&gt; 80/TCP
</span></span><span style=display:flex><span>    NodePort:               &lt;unnamed&gt; 32445/TCP
</span></span><span style=display:flex><span>    Endpoints:              10.64.0.4:80,10.64.1.5:80,10.64.2.4:80
</span></span><span style=display:flex><span>    Session Affinity:       None
</span></span><span style=display:flex><span>    Events:                 &lt;none&gt;
</span></span></code></pre></div><p>Alamat IP tercantum di sebelah <code>LoadBalancer Ingress</code>.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Jika kamu menjalankan Service dari Minikube, kamu dapat menemukan alamat IP dan porta yang ditetapkan dengan:</div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>minikube service example-service --url
</span></span></code></pre></div><h2 id=preservasi-ip-sumber-klien>Preservasi IP sumber klien</h2><p>Implementasi dari fitur ini menyebabkan sumber IP yang terlihat pada Container
target <em>bukan sebagai sumber IP asli</em> dari klien. Untuk mengaktifkan
preservasi IP klien, bidang berikut dapat dikonfigurasikan di dalam
spek Service (mendukung lingkungan GCE/Google Kubernetes Engine):</p><ul><li><code>service.spec.externalTrafficPolicy</code> - menunjukkan jika Service menginginkan rute lalu lintas
eksternal ke titik akhir <em>node-local</em> atau <em>cluster-wide</em>. Terdapat dua opsi yang tersedia:
<code>Cluster</code> (bawaan) dan <code>Local</code>. <code>Cluster</code> mengaburkan sumber IP klien dan mungkin menyebabkan
hop kedua ke Node berbeda, namun harus mempunyai penyebaran beban (<em>load-spreading</em>) yang baik secara keseluruhan.
<code>Local</code> mempreservasi sumber IP client dan menghindari hop kedua <code>LoadBalancer</code> dan Service dengan tipe <code>NodePort</code>, namun
resiko berpotensi penyebaran lalu lintas yang tidak merata.</li><li><code>service.spec.healthCheckNodePort</code> - menentukan pemeriksaan kesehatan porta dari sebuah Node (angka porta numerik) untuk Service.
Jika <code>healthCheckNodePort</code> tidak ditentukan, pengendali Service mengalokasi
porta dari rentang <code>NodePort</code> dari klaster kamu. Kamu dapat mengonfigurasi
rentangan tersebut dari pengaturan opsi barisan perintah API server,
<code>--service-node-port-range</code>. Hal itu menggunakan nilai <code>healthCheckNodePort</code> pengguna spesifik
jika ditentukan oleh klien. Hal itu dapat berefek hanya ketika <code>type</code> diset ke <code>LoadBalancer</code> dan
<code>externalTrafficPolicy</code> diset ke <code>Local</code>.</li></ul><p>Pengaturan <code>externalTrafficPolicy</code> ke <code>Local</code> pada berkas konfigurasi Service mengaktifkan
fitur ini.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>8765</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>externalTrafficPolicy</span>:<span style=color:#bbb> </span>Local<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>LoadBalancer<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=pengumpul-sampah-garbage-collector-load-balancer>Pengumpul Sampah (Garbage Collector) Load Balancer</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.17 [stable]</code></div><p>Pada kasus biasa, sumber daya <em>load balancer</em> yang berkorelasi pada penyedia cloud perlu
dibersihkan segera setelah Service bertipe <em>LoadBalancer</em> dihapus. Namun perlu diketahui
bahwa terdapat kasus tepi dimana sumber daya cloud yatim piatu (<em>orphaned</em>) setelah
Service yang berkaitan dihapus. <em>Finalizer Protection</em> untuk Service <em>LoadBalancer</em>
diperkenalkan untuk mencegah hal ini terjadi. Dengan menggunakan <em>finalizers</em>, sebuah sumber daya Service
tidak akan pernah dihapus hingga sumber daya <em>load balancer</em> yang berkorelasi juga dihapus.</p><p>Secara khusus, jika Service mempunyai <code>type LoadBalancer</code>, pengendali Service akan melekatkan
<em>finalizer</em> bernama <code>service.kubernetes.io/load-balancer-cleanup</code>.
<em>Finalizer</em> hanya akan dihapus setelah sumber daya <em>load balancer</em> dibersihkan.
Hal ini mencegah sumber daya <em>load balancer</em> yang teruntai bahkan setelah kasus tepi seperti
pengendali Service berhenti.</p><h2 id=penyedia-load-balancer-eksternal>Penyedia Load Balancer Eksternal</h2><p>Penting untuk dicatat bahwa jalur data untuk fungsionalitas ini disediakan oleh <em>load balancer</em> eksternal ke klaster Kubernetes.</p><p>Ketika Service <code>type</code> diset <code>LoadBalancer</code>, Kubernetes menyediakan fungsionalitas yang ekuivalen dengan <code>type</code> sebanding <code>ClusterIP</code>
ke berbagai Pod di dalam klaster dan mengekstensinya dengan pemrograman (eksternal dari Kubernetes) <em>load balancer</em> dengan entri pada Pod
Kubernetes. Pengendali Service Kubernetes mengotomasi pembuatan <em>load balancer</em> eksternal, cek kesehatan (jika dibutuhkan),
dinding api (<em>firewall</em>) (jika dibutuhkan), dan mengambil IP eksternal yang dialokasikan oleh penyedia cloud dan mengisinya pada objek Service.</p><h2 id=peringatan-dan-and-limitasi-ketika-preservasi-sumber-ip>Peringatan dan and Limitasi ketika preservasi sumber IP</h2><p><em>Load balancers</em> GCE/AWS tidak menyediakan bobot pada kolam targetnya (target pools). Hal ini bukan merupakan isu dengan aturan kube-proxy
<em>Load balancer</em> lama yang akan menyeimbangkan semua titik akhir dengan benar.</p><p>Dengan fungsionalitas yang baru, lalu lintas eksternal tidak menyeimbangkan beban secara merata pada seluruh Pod, namun
sebaliknya menyeimbangkan secara merata pada level Node (karena GCE/AWS dan implementasi <em>load balancer</em> eksternal lainnya tidak mempunyai
kemampuan untuk menentukan bobot setiap Node, mereka menyeimbangkan secara merata pada semua Node target, mengabaikan jumlah
Pod pada tiap Node).</p><p>Namun demikian, kita dapat menyatakan bahwa NumServicePods &lt;&lt; NumNodes atau NumServicePods >> NumNodes, distribusi yang cukup mendekati
sama akan terlihat, meski tanpa bobot.</p><p>Sekali <em>load balancer</em> eksternal menyediakan bobot, fungsionalitas ini dapat ditambahkan pada jalur pemrograman <em>load balancer</em>.
<em>Pekerjaan Masa Depan: Tidak adanya dukungan untuk bobot yang disediakan untuk rilis 1.4, namun dapat ditambahkan di masa mendatang</em></p><p>Pod internal ke lalu lintas Pod harus berperilaku sama seperti Service ClusterIP, dengan probabilitas yang sama pada seluruh Pod.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-48e8f306f919c5b81265e265a2b76ab4>4.8.6 - Membuat Daftar Semua Image Container yang Berjalan dalam Klaster</h1><p>Laman ini menunjukkan cara menggunakan kubectl untuk membuat daftar semua <em>image</em> Container
untuk Pod yang berjalan dalam sebuah klaster.</p><h2 id=sebelum-kamu-memulai>Sebelum kamu memulai</h2><p><p>Kamu harus memiliki klaster Kubernetes, dan perangkat baris perintah kubectl
juga harus dikonfigurasikan untuk berkomunikasi dengan klastermu. Jika kamu
belum memiliki klaster, kamu dapat membuatnya dengan menggunakan
<a href=/id/docs/tasks/tools/#minikube>minikube</a>,
atau kamu juga dapat menggunakan salah satu dari tempat mencoba Kubernetes berikut ini:</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>Bermain dengan Kubernetes</a></li></ul>Untuk melihat versi, tekan <code>kubectl version</code>.</p><p>Dalam latihan ini kamu akan menggunakan kubectl untuk mengambil semua Pod yang
berjalan dalam sebuah klaster, dan mengubah format keluarannya untuk melihat daftar
Container untuk masing-masing Pod.</p><h2 id=membuat-daftar-semua-image-container-pada-semua-namespace>Membuat daftar semua <em>image</em> Container pada semua Namespace</h2><ul><li>Silakan ambil semua Pod dalam Namespace dengan menggunakan perintah <code>kubectl get pods --all-namespaces</code></li><li>Silakan format keluarannya agar hanya menyertakan daftar nama <em>image</em> dari Container
dengan menggunakan perintah <code>-o jsonpath={.items[*].spec.containers[*].image}</code>. Perintah ini akan mem-<em>parsing field</em>
<code>image</code> dari keluaran json yang dihasilkan.<ul><li>Silakan lihat <a href=/docs/user-guide/jsonpath/>referensi jsonpath</a>
untuk informasi lebih lanjut tentang cara menggunakan <code>jsonpath</code>.</li></ul></li><li>Silakan format keluaran dengan menggunakan peralatan standar: <code>tr</code>, <code>sort</code>, <code>uniq</code><ul><li>Gunakan <code>tr</code> untuk mengganti spasi dengan garis baru</li><li>Gunakan <code>sort</code> untuk menyortir hasil</li><li>Gunakan <code>uniq</code> untuk mengumpulkan jumlah <em>image</em></li></ul></li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl get pods --all-namespaces -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#34;{.items[*].spec.containers[*].image}&#34;</span> |<span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>tr -s <span style=color:#b44>&#39;[[:space:]]&#39;</span> <span style=color:#b44>&#39;\n&#39;</span> |<span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>sort |<span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>uniq -c
</span></span></code></pre></div><p>Perintah di atas secara berulang akan mengembalikan semua <em>field</em> bernama <code>image</code>
dari semua poin yang dikembalikan.</p><p>Sebagai pilihan, dimungkinkan juga untuk menggunakan jalur (<em>path</em>) absolut ke <em>field image</em>
di dalam Pod. Hal ini memastikan <em>field</em> yang diambil benar
bahkan ketika nama <em>field</em> tersebut diulangi,
misalnya banyak <em>field</em> disebut dengan <code>name</code> dalam sebuah poin yang diberikan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl get pods --all-namespaces -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#34;{.items[*].spec.containers[*].image}&#34;</span>
</span></span></code></pre></div><p><code>Jsonpath</code> dapat diartikan sebagai berikut:</p><ul><li><code>.items[*]</code>: untuk setiap nilai yang dihasilkan</li><li><code>.spec</code>: untuk mendapatkan spesifikasi</li><li><code>.containers[*]</code>: untuk setiap Container</li><li><code>.image</code>: untuk mendapatkan <em>image</em></li></ul><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Pada saat mengambil sebuah Pod berdasarkan namanya, misalnya <code>kubectl get pod nginx</code>,
bagian <code>.items[*]</code> dari jalur harus dihilangkan karena hanya akan menghasilkan sebuah Pod
sebagai keluarannya, bukan daftar dari semua Pod.</div><h2 id=membuat-daftar-image-container-berdasarkan-pod>Membuat daftar <em>image</em> Container berdasarkan Pod</h2><p>Format dapat dikontrol lebih lanjut dengan menggunakan operasi <code>range</code> untuk
melakukan iterasi untuk setiap elemen secara individual.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl get pods --all-namespaces -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{range .items[*]}{&#34;\n&#34;}{.metadata.name}{&#34;:\t&#34;}{range .spec.containers[*]}{.image}{&#34;, &#34;}{end}{end}&#39;</span> |<span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>sort
</span></span></code></pre></div><h2 id=membuat-daftar-image-yang-difilter-berdasarkan-label-dari-pod>Membuat daftar <em>image</em> yang difilter berdasarkan label dari Pod</h2><p>Untuk menargetkan hanya Pod yang cocok dengan label tertentu saja, gunakan tanda -l. Filter
dibawah ini akan menghasilkan Pod dengan label yang cocok dengan <code>app=nginx</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl get pods --all-namespaces -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#34;{.items[*].spec.containers[*].image}&#34;</span> -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx
</span></span></code></pre></div><h2 id=membuat-daftar-image-container-yang-difilter-berdasarkan-namespace-pod>Membuat daftar <em>image</em> Container yang difilter berdasarkan Namespace Pod</h2><p>Untuk hanya menargetkan Pod pada Namespace tertentu, gunakankan tanda Namespace. Filter
dibawah ini hanya menyaring Pod pada Namespace <code>kube-system</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl get pods --namespace kube-system -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#34;{.items[*].spec.containers[*].image}&#34;</span>
</span></span></code></pre></div><h2 id=membuat-daftar-image-container-dengan-menggunakan-go-template-sebagai-alternatif-dari-jsonpath>Membuat daftar <em>image</em> Container dengan menggunakan go-template sebagai alternatif dari jsonpath</h2><p>Sebagai alternatif untuk <code>jsonpath</code>, kubectl mendukung penggunaan <a href=https://golang.org/pkg/text/template/>go-template</a>
untuk memformat keluaran seperti berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl get pods --all-namespaces -o go-template --template<span style=color:#666>=</span><span style=color:#b44>&#34;{{range .items}}{{range .spec.containers}}{{.image}} {{end}}{{end}}&#34;</span>
</span></span></code></pre></div><h2 id=selanjutnya>Selanjutnya</h2><h3 id=referensi>Referensi</h3><ul><li>Referensi panduan <a href=/docs/user-guide/jsonpath/>Jsonpath</a>.</li><li>Referensi panduan <a href=https://golang.org/pkg/text/template/>Go template</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-f6a755efe831d24956501e4bcd49ff96>4.9 - Pemantauan, Pencatatan, and Debugging</h1><div class=lead>Mengatur pemantauan dan pencatatan untuk memecahkan masalah klaster, atau men-<em>debug</em> aplikasi yang terkontainerisasi.</div></div><div class=td-content><h1 id=pg-731bb8b338c16aebfb9590ba2bd3fdd1>4.9.1 - Introspeksi dan _Debugging_ Aplikasi</h1><p>Setelah aplikasi kamu berjalan, kamu pasti perlu untuk men-<em>debug</em> masalah yang ada di dalamnya.
Sebelumnya telah dijelaskan bagaimana kamu dapat menggunakan <code>kubectl get pods</code> untuk mengambil informasi status sederhana tentang
Pod kamu. Namun ada sejumlah cara untuk mendapatkan lebih banyak informasi tentang aplikasi kamu.</p><h2 id=menggunakan-kubectl-describe-pod-untuk-mengambil-detil-informasi-pod>Menggunakan <code>kubectl describe pod</code> untuk mengambil detil informasi Pod</h2><p>Dalam contoh ini, kamu menggunakan Deployment untuk membuat dua buah Pod, yang hampir sama dengan contoh sebelumnya.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/application/nginx-with-request.yaml download=application/nginx-with-request.yaml><code>application/nginx-with-request.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("application-nginx-with-request-yaml")' title="Copy application/nginx-with-request.yaml to clipboard"></img></div><div class=includecode id=application-nginx-with-request-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;128Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;500m&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Buat Deployment dengan menjalankan perintah ini:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/application/nginx-with-request.yaml
</span></span></code></pre></div><pre tabindex=0><code class=language-none data-lang=none>deployment.apps/nginx-deployment created
</code></pre><p>Cek status dari Pod dengan menggunakan perintah:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods
</span></span></code></pre></div><pre tabindex=0><code class=language-none data-lang=none>NAME                                READY     STATUS    RESTARTS   AGE
nginx-deployment-1006230814-6winp   1/1       Running   0          11s
nginx-deployment-1006230814-fmgu3   1/1       Running   0          11s
</code></pre><p>Kamu dapat memperoleh lebih banyak informasi tentang masing-masing Pod ini dengan menggunakan perintah <code>kubectl describe pod</code>. Sebagai contoh:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe pod nginx-deployment-1006230814-6winp
</span></span></code></pre></div><pre tabindex=0><code class=language-none data-lang=none>Name:		nginx-deployment-1006230814-6winp
Namespace:	default
Node:		kubernetes-node-wul5/10.240.0.9
Start Time:	Thu, 24 Mar 2016 01:39:49 +0000
Labels:		app=nginx,pod-template-hash=1006230814
Annotations:    kubernetes.io/created-by={&#34;kind&#34;:&#34;SerializedReference&#34;,&#34;apiVersion&#34;:&#34;v1&#34;,&#34;reference&#34;:{&#34;kind&#34;:&#34;ReplicaSet&#34;,&#34;namespace&#34;:&#34;default&#34;,&#34;name&#34;:&#34;nginx-deployment-1956810328&#34;,&#34;uid&#34;:&#34;14e607e7-8ba1-11e7-b5cb-fa16&#34; ...
Status:		Running
IP:		10.244.0.6
Controllers:	ReplicaSet/nginx-deployment-1006230814
Containers:
  nginx:
    Container ID:	docker://90315cc9f513c724e9957a4788d3e625a078de84750f244a40f97ae355eb1149
    Image:		nginx
    Image ID:		docker://6f62f48c4e55d700cf3eb1b5e33fa051802986b77b874cc351cce539e5163707
    Port:		80/TCP
    QoS Tier:
      cpu:	Guaranteed
      memory:	Guaranteed
    Limits:
      cpu:	500m
      memory:	128Mi
    Requests:
      memory:		128Mi
      cpu:		500m
    State:		Running
      Started:		Thu, 24 Mar 2016 01:39:51 +0000
    Ready:		True
    Restart Count:	0
    Environment:        &lt;none&gt;
    Mounts:
      /var/run/secrets/kubernetes.io/serviceaccount from default-token-5kdvl (ro)
Conditions:
  Type          Status
  Initialized   True
  Ready         True
  PodScheduled  True
Volumes:
  default-token-4bcbi:
    Type:	Secret (a volume populated by a Secret)
    SecretName:	default-token-4bcbi
    Optional:   false
QoS Class:      Guaranteed
Node-Selectors: &lt;none&gt;
Tolerations:    &lt;none&gt;
Events:
  FirstSeen	LastSeen	Count	From					SubobjectPath		Type		Reason		Message
  ---------	--------	-----	----					-------------		--------	------		-------
  54s		54s		1	{default-scheduler }						Normal		Scheduled	Successfully assigned nginx-deployment-1006230814-6winp to kubernetes-node-wul5
  54s		54s		1	{kubelet kubernetes-node-wul5}	spec.containers{nginx}	Normal		Pulling		pulling image &#34;nginx&#34;
  53s		53s		1	{kubelet kubernetes-node-wul5}	spec.containers{nginx}	Normal		Pulled		Successfully pulled image &#34;nginx&#34;
  53s		53s		1	{kubelet kubernetes-node-wul5}	spec.containers{nginx}	Normal		Created		Created container with docker id 90315cc9f513
  53s		53s		1	{kubelet kubernetes-node-wul5}	spec.containers{nginx}	Normal		Started		Started container with docker id 90315cc9f513
</code></pre><p>Di sini kamu dapat melihat informasi konfigurasi tentang Container dan Pod (label, kebutuhan resource, dll.), serta informasi status tentang Container dan Pod (status, kesiapan, berapa kali <em>restart</em>, <em>event</em>, dll.) .</p><p>Keadaan (<em>state</em>) Container merupakan salah satu dari keadaan <em>Waiting, Running,</em> atau <em>Terminated</em>. Tergantung dari keadaannya, informasi tambahan akan diberikan - di sini kamu dapat melihat bahwa untuk Container dalam keadaan <em>running</em>, sistem memberi tahu kamu kapan Container tersebut mulai dijalankan.</p><p><em>Ready</em> memberi tahu kepada kamu apakah Container berhasil melewati pemeriksaan kesiapan terakhir. (Dalam kasus ini, Container tidak memiliki pemeriksaan kesiapan yang dikonfigurasi; Container dianggap selalu siap jika tidak ada pemeriksaan kesiapan yang dikonfigurasi.)</p><p>Jumlah <em>restart</em> memberi tahu kamu berapa kali Container telah dimulai ulang; informasi ini dapat berguna untuk mendeteksi kemacetan tertutup (<em>crash loop</em>) dalam Container yang dikonfigurasi dengan nilai <em>restart policy</em> 'always.'.</p><p>Saat ini, satu-satunya kondisi yang terkait dengan Pod adalah kondisi <em>Binary Ready</em>, yang menunjukkan bahwa Pod tersebut dapat melayani permintaan dan harus ditambahkan ke kumpulan penyeimbang beban (<em>load balancing</em>) dari semua Service yang sesuai.</p><p>Terakhir, kamu melihat catatan (<em>log</em>) peristiwa terbaru yang terkait dengan Pod kamu. Sistem mengompresi beberapa peristiwa yang identik dengan menunjukkan kapan pertama dan terakhir kali peristiwa itu dilihat dan berapa kali peristiwa itu dilihat. "From" menunjukkan komponen yang mencatat peristiwa, "SubobjectPath" memberi tahu kamu objek mana (mis. Container dalam pod) yang dimaksud, dan "Reason" dan "Message" memberi tahu kamu apa yang sudah terjadi.</p><h2 id=contoh-men-debug-pod-yang-pending>Contoh: Men-<em>debug</em> Pod yang <em>Pending</em></h2><p>Skenario umum yang bisa kamu deteksi menggunakan peristiwa (<em>event</em>) adalah saat kamu telah membuat Pod yang tidak muat di Node mana pun. Misalnya, karena Pod mungkin meminta lebih banyak sumber daya yang tersedia dalam Node mana pun, atau mungkin Pod menentukan <em>label selector</em> yang tidak sesuai dengan Node mana pun. Katakanlah kamu sebelumnya membuat Deployment dengan 5 replika (bukan 2) dan meminta 600 millicore, bukan 500, pada klaster dengan empat Node di mana setiap mesin (virtual) memiliki 1 CPU. Sehingga salah satu Pod tidak akan bisa dijadwalkan. (Perhatikan bahwa Pod <em>addon</em> seperti fluentd, skydns, dll., yang berjalan di setiap Node pada klaster, tidak bisa dijadwalkan jika kamu meminta sebanyak 1000 millicore.)</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods
</span></span></code></pre></div><pre tabindex=0><code class=language-none data-lang=none>NAME                                READY     STATUS    RESTARTS   AGE
nginx-deployment-1006230814-6winp   1/1       Running   0          7m
nginx-deployment-1006230814-fmgu3   1/1       Running   0          7m
nginx-deployment-1370807587-6ekbw   1/1       Running   0          1m
nginx-deployment-1370807587-fg172   0/1       Pending   0          1m
nginx-deployment-1370807587-fz9sd   0/1       Pending   0          1m
</code></pre><p>Untuk mencari sebab kenapa Pod nginx-deployment-1370807587-fz9sd tidak berjalan, kamu dapat menggunakan <code>kubectl describe pod</code> pada Pod yang <em>pending</em> dan melihat setiap peristiwa yang terjadi di dalamnya:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe pod nginx-deployment-1370807587-fz9sd
</span></span></code></pre></div><pre tabindex=0><code class=language-none data-lang=none>  Name:		nginx-deployment-1370807587-fz9sd
  Namespace:	default
  Node:		/
  Labels:		app=nginx,pod-template-hash=1370807587
  Status:		Pending
  IP:
  Controllers:	ReplicaSet/nginx-deployment-1370807587
  Containers:
    nginx:
      Image:	nginx
      Port:	80/TCP
      QoS Tier:
        memory:	Guaranteed
        cpu:	Guaranteed
      Limits:
        cpu:	1
        memory:	128Mi
      Requests:
        cpu:	1
        memory:	128Mi
      Environment Variables:
  Volumes:
    default-token-4bcbi:
      Type:	Secret (a volume populated by a Secret)
      SecretName:	default-token-4bcbi
  Events:
    FirstSeen	LastSeen	Count	From			        SubobjectPath	Type		Reason			    Message
    ---------	--------	-----	----			        -------------	--------	------			    -------
    1m		    48s		    7	    {default-scheduler }			        Warning		FailedScheduling	pod (nginx-deployment-1370807587-fz9sd) failed to fit in any node
  fit failure on node (kubernetes-node-6ta5): Node didn&#39;t have enough resource: CPU, requested: 1000, used: 1420, capacity: 2000
  fit failure on node (kubernetes-node-wul5): Node didn&#39;t have enough resource: CPU, requested: 1000, used: 1100, capacity: 2000
</code></pre><p>Di sini kamu dapat melihat peristiwa yang dibuat oleh penjadwal yang mengatakan bahwa Pod gagal dijadwalkan karena alasan <code>FailedScheduling</code> (dan mungkin karena sebab yang lainnya). Pesan tersebut memberi tahu kamu bahwa tidak ada cukup sumber daya untuk Pod pada salah satu Node.</p><p>Untuk memperbaiki situasi ini, kamu dapat menggunakan <code>kubectl scale</code> untuk memperbarui Deployment kamu untuk menentukan empat replika atau yang lebih kecil. (Atau kamu bisa membiarkan satu Pod tertunda, dimana hal ini tidak berbahaya.)</p><p>Peristiwa seperti yang kamu lihat di bagian akhir keluaran dari perintah <code>kubectl description pod</code> akan tetap ada dalam etcd dan memberikan informasi tingkat tinggi tentang apa yang terjadi pada klaster. Untuk melihat daftar semua peristiwa kamu dapat menggunakan perintah</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get events
</span></span></code></pre></div><p>tetapi kamu harus ingat bahwa peristiwa bersifat Namespace. Artinya, jika kamu tertarik dengan peristiwa untuk beberapa objek dalam Namespace (misalnya, apa yang terjadi dengan Pod pada Namespace <code>my-namespace</code>), kamu perlu secara eksplisit menyebutkan Namespace tersebut pada perintah:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get events --namespace<span style=color:#666>=</span>my-namespace
</span></span></code></pre></div><p>Untuk melihat peristiwa dari semua Namespace, kamu dapat menggunakan argumen <code>--all-namespaces</code>.</p><p>Sebagai tambahan dari perintah <code>kubectl describe pod</code>, cara lain untuk mendapatkan informasi tambahan tentang sebuah Pod (selain yang disediakan oleh <code>kubectl get pod</code>) adalah dengan meneruskan <em>flag</em> format keluaran <code>-o yaml</code> ke perintah <code>kubectl get pod</code>. Ini akan memberikan kamu lebih banyak informasi dalam format YAML daripada <code>kubectl describe pod</code>--semua informasi dasar yang dimiliki sistem tentang Pod. Di sini kamu akan melihat hal-hal seperti anotasi (yang merupakan metadata nilai kunci tanpa batasan label, yang digunakan secara internal oleh komponen sistem Kubernetes), kebijakan mulai ulang, porta, dan volume.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod nginx-deployment-1006230814-6winp -o yaml
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/created-by</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      </span><span style=color:#bbb>      </span>{<span style=color:#b44>&#34;kind&#34;</span>:<span style=color:#b44>&#34;SerializedReference&#34;</span>,<span style=color:#b44>&#34;apiVersion&#34;</span>:<span style=color:#b44>&#34;v1&#34;</span>,<span style=color:#b44>&#34;reference&#34;</span>:{<span style=color:#b44>&#34;kind&#34;</span>:<span style=color:#b44>&#34;ReplicaSet&#34;</span>,<span style=color:#b44>&#34;namespace&#34;</span>:<span style=color:#b44>&#34;default&#34;</span>,<span style=color:#b44>&#34;name&#34;</span>:<span style=color:#b44>&#34;nginx-deployment-1006230814&#34;</span>,<span style=color:#b44>&#34;uid&#34;</span>:<span style=color:#b44>&#34;4c84c175-f161-11e5-9a78-42010af00005&#34;</span>,<span style=color:#b44>&#34;apiVersion&#34;</span>:<span style=color:#b44>&#34;extensions&#34;</span>,<span style=color:#b44>&#34;resourceVersion&#34;</span>:<span style=color:#b44>&#34;133434&#34;</span>}}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2016-03-24T01:39:50Z<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>generateName</span>:<span style=color:#bbb> </span>nginx-deployment-1006230814-<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>pod-template-hash</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1006230814&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment-1006230814-6winp<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;133447&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>4c879808-f161-11e5-9a78-42010af00005<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>Always<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>500m<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>128Mi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>500m<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>128Mi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>terminationMessagePath</span>:<span style=color:#bbb> </span>/dev/termination-log<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/run/secrets/kubernetes.io/serviceaccount<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default-token-4bcbi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>dnsPolicy</span>:<span style=color:#bbb> </span>ClusterFirst<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodeName</span>:<span style=color:#bbb> </span>kubernetes-node-wul5<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Always<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>serviceAccount</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>serviceAccountName</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>terminationGracePeriodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>30</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default-token-4bcbi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>default-token-4bcbi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>conditions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>lastProbeTime</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>null</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>lastTransitionTime</span>:<span style=color:#bbb> </span>2016-03-24T01:39:51Z<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;True&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Ready<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containerStatuses</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>containerID</span>:<span style=color:#bbb> </span>docker://90315cc9f513c724e9957a4788d3e625a078de84750f244a40f97ae355eb1149<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imageID</span>:<span style=color:#bbb> </span>docker://6f62f48c4e55d700cf3eb1b5e33fa051802986b77b874cc351cce539e5163707<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>lastState</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ready</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>restartCount</span>:<span style=color:#bbb> </span><span style=color:#666>0</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>state</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>running</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>startedAt</span>:<span style=color:#bbb> </span>2016-03-24T01:39:51Z<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostIP</span>:<span style=color:#bbb> </span><span style=color:#666>10.240.0.9</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>phase</span>:<span style=color:#bbb> </span>Running<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>podIP</span>:<span style=color:#bbb> </span><span style=color:#666>10.244.0.6</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>startTime</span>:<span style=color:#bbb> </span>2016-03-24T01:39:49Z<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=contoh-men-debug-node-yang-mati-tidak-terjangkau-down-unreachable>Contoh: Men-<em>debug</em> Node yang mati/tidak terjangkau (<em>down/unreachable</em>)</h2><p>Terkadang saat men-<em>debug</em> melihat status sebuah Node akan sangat berguna - misalnya, karena kamu telah melihat perilaku aneh dari sebuah Pod yang sedang berjalan pada Node tersebut, atau untuk mencari tahu mengapa sebuah Pod tidak dapat dijadwalkan ke dalam Node tersebut. Seperti pada Pod, kamu dapat menggunakan perintah <code>kubectl description node</code> dan <code>kubectl get node -o yaml</code> untuk mengambil informasi mendetil tentang Node. Misalnya, disini kamu akan melihat jika sebuah Node sedang mati (terputus dari jaringan, atau kubelet mati dan tidak mau restart, dll.). Perhatikan peristiwa yang menunjukkan Node tersebut NotReady, dan juga perhatikan bahwa Pod tidak lagi berjalan (mereka akan dikeluarkan setelah lima menit berstatus NotReady).</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get nodes
</span></span></code></pre></div><pre tabindex=0><code class=language-none data-lang=none>NAME                     STATUS       ROLES     AGE     VERSION
kubernetes-node-861h     NotReady     &lt;none&gt;    1h      v1.13.0
kubernetes-node-bols     Ready        &lt;none&gt;    1h      v1.13.0
kubernetes-node-st6x     Ready        &lt;none&gt;    1h      v1.13.0
kubernetes-node-unaj     Ready        &lt;none&gt;    1h      v1.13.0
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe node kubernetes-node-861h
</span></span></code></pre></div><pre tabindex=0><code class=language-none data-lang=none>Name:			kubernetes-node-861h
Role
Labels:		 kubernetes.io/arch=amd64
           kubernetes.io/os=linux
           kubernetes.io/hostname=kubernetes-node-861h
Annotations:        node.alpha.kubernetes.io/ttl=0
                    volumes.kubernetes.io/controller-managed-attach-detach=true
Taints:             &lt;none&gt;
CreationTimestamp:	Mon, 04 Sep 2017 17:13:23 +0800
Phase:
Conditions:
  Type		Status		LastHeartbeatTime			LastTransitionTime			Reason					Message
  ----    ------    -----------------     ------------------      ------          -------
  OutOfDisk             Unknown         Fri, 08 Sep 2017 16:04:28 +0800         Fri, 08 Sep 2017 16:20:58 +0800         NodeStatusUnknown       Kubelet stopped posting node status.
  MemoryPressure        Unknown         Fri, 08 Sep 2017 16:04:28 +0800         Fri, 08 Sep 2017 16:20:58 +0800         NodeStatusUnknown       Kubelet stopped posting node status.
  DiskPressure          Unknown         Fri, 08 Sep 2017 16:04:28 +0800         Fri, 08 Sep 2017 16:20:58 +0800         NodeStatusUnknown       Kubelet stopped posting node status.
  Ready                 Unknown         Fri, 08 Sep 2017 16:04:28 +0800         Fri, 08 Sep 2017 16:20:58 +0800         NodeStatusUnknown       Kubelet stopped posting node status.
Addresses:	10.240.115.55,104.197.0.26
Capacity:
 cpu:           2
 hugePages:     0
 memory:        4046788Ki
 pods:          110
Allocatable:
 cpu:           1500m
 hugePages:     0
 memory:        1479263Ki
 pods:          110
System Info:
 Machine ID:                    8e025a21a4254e11b028584d9d8b12c4
 System UUID:                   349075D1-D169-4F25-9F2A-E886850C47E3
 Boot ID:                       5cd18b37-c5bd-4658-94e0-e436d3f110e0
 Kernel Version:                4.4.0-31-generic
 OS Image:                      Debian GNU/Linux 8 (jessie)
 Operating System:              linux
 Architecture:                  amd64
 Container Runtime Version:     docker://1.12.5
 Kubelet Version:               v1.6.9+a3d1dfa6f4335
 Kube-Proxy Version:            v1.6.9+a3d1dfa6f4335
ExternalID:                     15233045891481496305
Non-terminated Pods:            (9 in total)
  Namespace                     Name                                            CPU Requests    CPU Limits      Memory Requests Memory Limits
  ---------                     ----                                            ------------    ----------      --------------- -------------
......
Allocated resources:
  (Total limits may be over 100 percent, i.e., overcommitted.)
  CPU Requests  CPU Limits      Memory Requests         Memory Limits
  ------------  ----------      ---------------         -------------
  900m (60%)    2200m (146%)    1009286400 (66%)        5681286400 (375%)
Events:         &lt;none&gt;
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get node kubernetes-node-861h -o yaml
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Node<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2015-07-10T21:32:29Z<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/hostname</span>:<span style=color:#bbb> </span>kubernetes-node-861h<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>kubernetes-node-861h<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;757&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>2a69374e-274b-11e5-a234-42010af0d969<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>externalID</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;15233045891481496305&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>podCIDR</span>:<span style=color:#bbb> </span><span style=color:#666>10.244.0.0</span>/24<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>providerID</span>:<span style=color:#bbb> </span>gce://striped-torus-760/us-central1-b/kubernetes-node-861h<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>addresses</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>address</span>:<span style=color:#bbb> </span><span style=color:#666>10.240.115.55</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>InternalIP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>address</span>:<span style=color:#bbb> </span><span style=color:#666>104.197.0.26</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>ExternalIP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>capacity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>3800808Ki<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>pods</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;100&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>conditions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>lastHeartbeatTime</span>:<span style=color:#bbb> </span>2015-07-10T21:34:32Z<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>lastTransitionTime</span>:<span style=color:#bbb> </span>2015-07-10T21:35:15Z<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>reason</span>:<span style=color:#bbb> </span>Kubelet stopped posting node status.<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb> </span>Unknown<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Ready<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodeInfo</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>bootID</span>:<span style=color:#bbb> </span><span style=color:#666>4e316776</span>-b40d-4f78-a4ea-ab0d73390897<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>containerRuntimeVersion</span>:<span style=color:#bbb> </span>docker://Unknown<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kernelVersion</span>:<span style=color:#bbb> </span><span style=color:#666>3.16.0-0.</span>bpo.4-amd64<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubeProxyVersion</span>:<span style=color:#bbb> </span>v0.21.1-185-gffc5a86098dc01<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubeletVersion</span>:<span style=color:#bbb> </span>v0.21.1-185-gffc5a86098dc01<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>machineID</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>osImage</span>:<span style=color:#bbb> </span>Debian GNU/Linux 7 (wheezy)<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>systemUUID</span>:<span style=color:#bbb> </span>ABE5F6B4-D44B-108B-C46A-24CCE16C8B6E<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=selanjutnya>Selanjutnya</h2><p>Pelajari tentang alat <em>debugging</em> tambahan, termasuk:</p><ul><li><a href=/id/docs/concepts/cluster-administration/logging/>Pencatatan (<em>logging</em>)</a></li><li><a href=/docs/tasks/debug-application-cluster/resource-usage-monitoring/>Monitoring</a></li><li><a href=/docs/tasks/debug-application-cluster/get-shell-running-container/>Masuk ke Container melalui <code>exec</code></a></li><li><a href=/docs/tasks/extend-kubernetes/http-proxy-access-api/>Masuk ke Container melalui <em>proxy</em></a></li><li><a href=/docs/tasks/access-application-cluster/port-forward-access-application-cluster/>Masuk ke Container melalui <em>port forwarding</em></a></li><li><a href=/docs/tasks/debug-application-cluster/crictl/>Inspeksi Node Kubernetes dengan menggunakan crictl</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-9713ac27b6d9e3034033200d968221f2>4.9.2 - Mendapatkan Shell Untuk Masuk ke Container yang Sedang Berjalan</h1><p>Laman ini menunjukkan bagaimana cara menggunakan <code>kubectl exec</code> untuk
mendapatkan <em>shell</em> untuk masuk ke dalam Container yang sedang berjalan.</p><h2 id=sebelum-kamu-memulai>Sebelum kamu memulai</h2><p><p>Kamu harus memiliki klaster Kubernetes, dan perangkat baris perintah kubectl
juga harus dikonfigurasikan untuk berkomunikasi dengan klastermu. Jika kamu
belum memiliki klaster, kamu dapat membuatnya dengan menggunakan
<a href=/id/docs/tasks/tools/#minikube>minikube</a>,
atau kamu juga dapat menggunakan salah satu dari tempat mencoba Kubernetes berikut ini:</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>Bermain dengan Kubernetes</a></li></ul>Untuk melihat versi, tekan <code>kubectl version</code>.</p><h2 id=mendapatkan-sebuah-shell-untuk-masuk-ke-sebuah-container>Mendapatkan sebuah <em>shell</em> untuk masuk ke sebuah Container</h2><p>Dalam latihan ini, kamu perlu membuat Pod yang hanya memiliki satu Container saja. Container
tersebut menjalankan <em>image</em> nginx. Berikut ini adalah berkas konfigurasi untuk Pod tersebut:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/application/shell-demo.yaml download=application/shell-demo.yaml><code>application/shell-demo.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("application-shell-demo-yaml")' title="Copy application/shell-demo.yaml to clipboard"></img></div><div class=includecode id=application-shell-demo-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>shell-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>shared-data<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>shared-data<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/usr/share/nginx/html<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostNetwork</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>dnsPolicy</span>:<span style=color:#bbb> </span>Default<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Buatlah Pod tersebut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/application/shell-demo.yaml
</span></span></code></pre></div><p>Pastikan bahwa Container dalam Pod berjalan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod shell-demo
</span></span></code></pre></div><p>Dapatkan <em>shell</em> untuk masuk ke dalam Container:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> -it shell-demo -- /bin/bash
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Simbol tanda hubung ganda "--" digunakan untuk memisahkan antara argumen perintah yang ingin kamu eksekusi pada Container dan argumen dari kubectl itu sendiri.</div><p>Di dalam <em>shell</em> kamu, perlihatkan isi dari direktori <em>root</em>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>root@shell-demo:/# ls /
</span></span></code></pre></div><p>Di dalam <em>shell</em> kamu, cobalah perintah-perintah yang lainnya. Berikut beberapa contohnya:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>root@shell-demo:/# ls /
</span></span><span style=display:flex><span>root@shell-demo:/# cat /proc/mounts
</span></span><span style=display:flex><span>root@shell-demo:/# cat /proc/1/maps
</span></span><span style=display:flex><span>root@shell-demo:/# apt-get update
</span></span><span style=display:flex><span>root@shell-demo:/# apt-get install -y tcpdump
</span></span><span style=display:flex><span>root@shell-demo:/# tcpdump
</span></span><span style=display:flex><span>root@shell-demo:/# apt-get install -y lsof
</span></span><span style=display:flex><span>root@shell-demo:/# lsof
</span></span><span style=display:flex><span>root@shell-demo:/# apt-get install -y procps
</span></span><span style=display:flex><span>root@shell-demo:/# ps aux
</span></span><span style=display:flex><span>root@shell-demo:/# ps aux | grep nginx
</span></span></code></pre></div><h2 id=menulis-halaman-utama-root-untuk-nginx>Menulis halaman utama (<em>root</em>) untuk nginx</h2><p>Lihat kembali berkas konfigurasi untuk Pod kamu. Pod
memiliki volume <code>emptyDir</code>, dan Container melakukan pemasangan (<em>mounting</em>) untuk volume tersebut
pada <code>/usr/share/nginx/html</code>.</p><p>Pada <em>shell</em> kamu, buatlah berkas <code>index.html</code> dalam direktori <code>/usr/share/nginx/html</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>root@shell-demo:/# <span style=color:#a2f>echo</span> Hello shell demo &gt; /usr/share/nginx/html/index.html
</span></span></code></pre></div><p>Pada <em>shell</em> kamu, kirimkan sebuah permintaan (<em>request</em>) GET ke server nginx.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>root@shell-demo:/# apt-get update
</span></span><span style=display:flex><span>root@shell-demo:/# apt-get install curl
</span></span><span style=display:flex><span>root@shell-demo:/# curl localhost
</span></span></code></pre></div><p>Keluarannya akan menunjukkan teks yang kamu tulis pada berkas <code>index.html</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>Hello shell demo
</span></span></code></pre></div><p>Setelah kamu selesai dengan <em>shell</em> kamu, ketiklah <code>exit</code>.</p><h2 id=menjalankan-perintah-individu-di-dalam-sebuah-container>Menjalankan perintah individu di dalam sebuah Container</h2><p>Pada jendela (<em>window</em>) perintah biasa, bukan pada <em>shell</em> kamu di dalam Container,
lihatlah daftar variabel lingkungan (<em>environment variable</em>) pada Container yang sedang berjalan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> shell-demo env
</span></span></code></pre></div><p>Cobalah dengan menjalankan perintah lainnya. Berikut beberapa contohnya:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> shell-demo ps aux
</span></span><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> shell-demo ls /
</span></span><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> shell-demo cat /proc/1/mounts
</span></span></code></pre></div><h2 id=membuka-sebuah-shell-ketika-sebuah-pod-memiliki-lebih-dari-satu-container>Membuka sebuah <em>shell</em> ketika sebuah Pod memiliki lebih dari satu Container</h2><p>Jika sebuah Pod memiliki lebih dari satu Container, gunakanlah <code>--container</code> atau <code>-c</code> untuk
menentukan Container yang dimaksud pada perintah <code>kubectl exec</code>. Sebagai contoh,
misalkan kamu memiliki Pod yang bernama my-pod, dan Pod tersebut memiliki dua Container
yang bernama main-app dan helper-app. Perintah berikut ini akan membuka sebuah
<em>shell</em> ke Container dengan nama main-app.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> -it my-pod --container main-app -- /bin/bash
</span></span></code></pre></div><h2 id=selanjutnya>Selanjutnya</h2><ul><li><a href=/docs/reference/generated/kubectl/kubectl-commands/#exec>kubectl exec</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-9e6e1b706f11386fe2c4b4ffda1409e4>4.9.3 - Perangkat untuk Memantau Sumber Daya</h1><p>Untuk melukan penyekalaan aplikasi dan memberikan Service yang handal, kamu perlu
memahami bagaimana aplikasi berperilaku ketika aplikasi tersebut digelar (<em>deploy</em>). Kamu bisa memeriksa
kinerja aplikasi dalam klaster Kubernetes dengan memeriksa Container,
<a href=/docs/user-guide/pods>Pod</a>, <a href=/docs/user-guide/services>Service</a>, dan
karakteristik klaster secara keseluruhan. Kubernetes memberikan detail
informasi tentang penggunaan sumber daya dari aplikasi pada setiap level ini.
Informasi ini memungkinkan kamu untuk mengevaluasi kinerja aplikasi kamu dan
mengevaluasi di mana kemacetan dapat dihilangkan untuk meningkatkan kinerja secara keseluruhan.</p><p>Di Kubernetes, pemantauan aplikasi tidak bergantung pada satu solusi pemantauan saja. Pada klaster baru, kamu bisa menggunakan <em>pipeline</em> <a href=#pipeline-metrik-sumber-daya>metrik sumber daya</a> atau <em>pipeline</em> <a href=#pipeline-metrik-penuh>metrik penuh</a> untuk mengumpulkan statistik pemantauan.</p><h2 id=pipeline-metrik-sumber-daya><em>Pipeline</em> Metrik Sumber Daya</h2><p><em>Pipeline</em> metrik sumber daya menyediakan sekumpulan metrik terbatas yang terkait dengan
komponen-komponen klaster seperti <em>controller</em> <a href=/id/docs/tasks/run-application/horizontal-pod-autoscaler>HorizontalPodAutoscaler</a>, begitu juga dengan utilitas <code>kubectl top</code>.
Metrik ini dikumpulkan oleh memori yang ringan, jangka pendek, dalam
<a href=https://github.com/kubernetes-incubator/metrics-server><em>metrics-server</em></a> dan
diekspos ke API <code>metrics.k8s.io</code>.</p><p><em>Metrics-server</em> menemukan semua Node dalam klaster dan
bertanya ke setiap
<a href=/docs/reference/command-line-tools-reference/kubelet>kubelet</a> dari Node tentang penggunaan CPU dan
memori. Kubelet bertindak sebagai jembatan antara <em>control plane</em> Kubernetes dan
Node, mengelola Pod dan Container yang berjalan pada sebuah mesin. Kubelet
menerjemahkan setiap Pod ke Container yang menyusunnya dan mengambil masing-masing
statistik penggunaan untuk setiap Container dari <em>runtime</em> Container melalui
antarmuka <em>runtime</em> Container. Kubelet mengambil informasi ini dari cAdvisor yang terintegrasi
untuk pengintegrasian Docker yang lama. Hal ini yang kemudian memperlihatkan
statistik penggunaan sumber daya dari kumpulan Pod melalui API sumber daya <em>metrics-server</em>.
API ini disediakan pada <code>/metrics/resource/v1beta1</code> pada kubelet yang terautentikasi dan
porta <em>read-only</em>.</p><h2 id=pipeline-metrik-penuh><em>Pipeline</em> Metrik Penuh</h2><p><em>Pipeline</em> metrik penuh memberi kamu akses ke metrik yang lebih banyak. Kubernetes bisa
menanggapi metrik ini secara otomatis dengan mengubah skala atau mengadaptasi klaster
berdasarkan kondisi saat ini, dengan menggunakan mekanisme seperti HorizontalPodAutoscaler.
<em>Pipeline</em> pemantauan mengambil metrik dari kubelet dan
kemudian memgekspos ke Kubernetes melalui adaptor dengan mengimplementasikan salah satu dari API
<code>custom.metrics.k8s.io</code> atau API <code>external.metrics.k8s.io</code>.</p><p><a href=https://prometheus.io>Prometheus</a>, sebuah proyek CNCF, yang dapat secara alami memonitor Kubernetes, Node, dan Prometheus itu sendiri.
Proyek <em>pipeline</em> metrik penuh yang bukan merupakan bagian dari CNCF berada di luar ruang lingkup dari dokumentasi Kubernetes.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-d3c88a8663f58e9ec0bed73faff5b670>4.10 - TLS</h1></div><div class=td-content><h1 id=pg-9a87de8ee8332cb487f34a05debb1125>4.10.1 - Kelola Sertifikat TLS Pada Klaster</h1><p>Kubernetes menyediakan API <code>certificates.k8s.io</code> yang memungkinkan kamu membuat sertifikat
TLS yang ditandatangani oleh Otoritas Sertifikat (CA) yang kamu kendalikan. CA dan sertifikat ini
bisa digunakan oleh <em>workload</em> untuk membangun kepercayaan.</p><p>API <code>certificates.k8s.io</code> menggunakan protokol yang mirip dengan <a href=https://github.com/ietf-wg-acme/acme/>konsep ACME</a>.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Sertifikat yang dibuat menggunakan API <code>certificates.k8s.io</code> ditandatangani oleh CA
khusus. Ini memungkinkan untuk mengkonfigurasi klaster kamu agar menggunakan CA <em>root</em> klaster untuk tujuan ini,
namun jangan pernah mengandalkan ini. Jangan berasumsi bahwa sertifikat ini akan melakukan validasi
dengan CA <em>root</em> klaster</div><h2 id=sebelum-kamu-memulai>Sebelum kamu memulai</h2><p><p>Kamu harus memiliki klaster Kubernetes, dan perangkat baris perintah kubectl
juga harus dikonfigurasikan untuk berkomunikasi dengan klastermu. Jika kamu
belum memiliki klaster, kamu dapat membuatnya dengan menggunakan
<a href=/id/docs/tasks/tools/#minikube>minikube</a>,
atau kamu juga dapat menggunakan salah satu dari tempat mencoba Kubernetes berikut ini:</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>Bermain dengan Kubernetes</a></li></ul>Untuk melihat versi, tekan <code>kubectl version</code>.</p><h2 id=mempercayai-tls-dalam-klaster>Mempercayai TLS dalam Klaster</h2><p>Mempercayai CA khusus dari aplikasi yang berjalan sebagai Pod biasanya memerlukan
beberapa tambahan konfigurasi aplikasi. Kamu harus menambahkan bundel sertifikat CA
ke daftar sertifikat CA yang dipercaya klien atau server TLS.
Misalnya, kamu akan melakukan ini dengan konfigurasi TLS golang dengan mengurai rantai sertifikat
dan menambahkan sertifikat yang diurai ke <code>RootCAs</code> di <em>struct</em>
<a href=https://godoc.org/crypto/tls#Config><code>tls.Config</code></a>.</p><p>Kamu bisa mendistribusikan sertifikat CA sebagai sebuah
<a href=/id/docs/tasks/configure-pod-container/configure-pod-configmap>ConfigMap</a> yang bisa diakses oleh Pod kamu.</p><h2 id=meminta-sertifikat>Meminta Sertifikat</h2><p>Bagian berikut mendemonstrasikan cara membuat sertifikat TLS untuk sebuah
Service kubernetes yang diakses melalui DNS.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Tutorial ini menggunakan CFSSL: PKI dan peralatan TLS dari Cloudflare <a href=https://blog.cloudflare.com/introducing-cfssl/>klik disini</a> untuk mengetahui lebih jauh.</div><h2 id=unduh-dan-pasang-cfssl>Unduh dan Pasang CFSSL</h2><p>Contoh ini menggunakan cfssl yang dapat diunduh pada
<a href=https://github.com/cloudflare/cfssl/releases>https://github.com/cloudflare/cfssl/releases</a>.</p><h2 id=membuat-certificatesigningrequest>Membuat CertificateSigningRequest</h2><p>Buat kunci pribadi dan CertificateSigningRequest (CSR) dengan menggunakan perintah berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF | cfssl genkey - | cfssljson -bare server
</span></span></span><span style=display:flex><span><span style=color:#b44>{
</span></span></span><span style=display:flex><span><span style=color:#b44>  &#34;hosts&#34;: [
</span></span></span><span style=display:flex><span><span style=color:#b44>    &#34;my-svc.my-namespace.svc.cluster.local&#34;,
</span></span></span><span style=display:flex><span><span style=color:#b44>    &#34;my-pod.my-namespace.pod.cluster.local&#34;,
</span></span></span><span style=display:flex><span><span style=color:#b44>    &#34;192.0.2.24&#34;,
</span></span></span><span style=display:flex><span><span style=color:#b44>    &#34;10.0.34.2&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44>  ],
</span></span></span><span style=display:flex><span><span style=color:#b44>  &#34;CN&#34;: &#34;my-pod.my-namespace.pod.cluster.local&#34;,
</span></span></span><span style=display:flex><span><span style=color:#b44>  &#34;key&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#b44>    &#34;algo&#34;: &#34;ecdsa&#34;,
</span></span></span><span style=display:flex><span><span style=color:#b44>    &#34;size&#34;: 256
</span></span></span><span style=display:flex><span><span style=color:#b44>  }
</span></span></span><span style=display:flex><span><span style=color:#b44>}
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p><code>192.0.2.24</code> adalah klaster IP Service,
<code>my-svc.my-namespace.svc.cluster.local</code> adalah nama DNS Service,
<code>10.0.34.2</code> adalah IP Pod dan <code>my-pod.my-namespace.pod.cluster.local</code>
adalah nama DNS Pod. Kamu akan melihat keluaran berikut:</p><pre tabindex=0><code>2017/03/21 06:48:17 [INFO] generate received request
2017/03/21 06:48:17 [INFO] received CSR
2017/03/21 06:48:17 [INFO] generating key: ecdsa-256
2017/03/21 06:48:17 [INFO] encoded CSR
</code></pre><p>Perintah ini menghasilkan dua berkas; Ini menghasilkan <code>server.csr</code> yang berisi permintaan sertifikasi PEM
tersandi <a href=https://tools.ietf.org/html/rfc2986>pkcs#10</a>,
dan <code>server-key.pem</code> yang berisi PEM kunci yang tersandi untuk sertifikat yang
masih harus dibuat.</p><h2 id=membuat-objek-certificatesigningrequest-untuk-dikirim-ke-api-kubernetes>Membuat objek CertificateSigningRequest untuk dikirim ke API Kubernetes</h2><p>Buat sebuah yaml CSR dan kirim ke API Server dengan menggunakan perintah berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF | kubectl apply -f -
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: certificates.k8s.io/v1beta1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: CertificateSigningRequest
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: my-svc.my-namespace
</span></span></span><span style=display:flex><span><span style=color:#b44>spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>  request: $(cat server.csr | base64 | tr -d &#39;\n&#39;)
</span></span></span><span style=display:flex><span><span style=color:#b44>  usages:
</span></span></span><span style=display:flex><span><span style=color:#b44>  - digital signature
</span></span></span><span style=display:flex><span><span style=color:#b44>  - key encipherment
</span></span></span><span style=display:flex><span><span style=color:#b44>  - server auth
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>Perhatikan bahwa berkas <code>server.csr</code> yang dibuat pada langkah 1 merupakan base64 tersandi
dan disimpan di <em>field</em> <code>.spec.request</code>. Kami juga meminta
sertifikat dengan penggunaan kunci "<em>digital signature</em>", "<em>key enchiperment</em>", dan "<em>server
auth</em>". Kami mendukung semua penggunaan kunci dan penggunaan kunci yang diperpanjang yang terdaftar
<a href=https://godoc.org/k8s.io/api/certificates/v1beta1#KeyUsage>di sini</a>
sehingga kamu dapat meminta sertifikat klien dan sertifikat lain menggunakan
API yang sama.</p><p>CSR semestinya bisa dilihat dari API pada status <em>Pending</em>. Kamu bisa melihatnya dengan menjalankan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe csr my-svc.my-namespace
</span></span></code></pre></div><pre tabindex=0><code class=language-none data-lang=none>Name:                   my-svc.my-namespace
Labels:                 &lt;none&gt;
Annotations:            &lt;none&gt;
CreationTimestamp:      Tue, 21 Mar 2017 07:03:51 -0700
Requesting User:        yourname@example.com
Status:                 Pending
Subject:
        Common Name:    my-svc.my-namespace.svc.cluster.local
        Serial Number:
Subject Alternative Names:
        DNS Names:      my-svc.my-namespace.svc.cluster.local
        IP Addresses:   192.0.2.24
                        10.0.34.2
Events: &lt;none&gt;
</code></pre><h2 id=mendapatkan-persetujuan-certificatesigningrequest>Mendapatkan Persetujuan CertificateSigningRequest</h2><p>Penyetujuan CertificateSigningRequest dapat dilakukan dengan otomatis
atau dilakukan sekali oleh administrator klaster. Informasi lebih lanjut tentang
apa yang terjadi dibahas dibawah ini.</p><h2 id=unduh-dan-gunakan-sertifikat>Unduh dan Gunakan Sertifikat</h2><p>Setelah CSR ditandatangani dan disetujui, kamu akan melihat:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get csr
</span></span></code></pre></div><pre tabindex=0><code class=language-none data-lang=none>NAME                  AGE       REQUESTOR               CONDITION
my-svc.my-namespace   10m       yourname@example.com    Approved,Issued
</code></pre><p>Kamu bisa mengundur sertifikat yang telah diterbitkan dan menyimpannya ke berkas
<code>server.crt</code> dengan menggunakan perintah berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get csr my-svc.my-namespace -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.status.certificate}&#39;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    | base64 --decode &gt; server.crt
</span></span></code></pre></div><p>Sekarang kamu bisa menggunakan <code>server.crt</code> dan <code>server-key.pem</code> sebagai pasangan
kunci untuk memulai server HTTPS kamu.</p><h2 id=penyetujuan-certificatesigningrequest>Penyetujuan CertificateSigningRequest</h2><p>Administrator Kubernetes (dengan izin yang cukup) dapat menyetujui secara manual
(atau menolak) Certificate Signing Requests dengan menggunakan perintah <code>kubectl certificate approve</code> dan <code>kubectl certificate deny</code>. Namun jika kamu bermaksud
untuk menggunakan API ini secara sering, kamu dapat mempertimbangkan untuk menulis
Certificate <em>controller</em> otomatis.</p><p>Baik itu mesin atau manusia yang menggunakan kubectl seperti di atas, peran pemberi persetujuan adalah
untuk memverifikasi bahwa CSR memenuhi dua persyaratan:</p><ol><li>Subjek CSR mengontrol kunci pribadi yang digunakan untuk menandatangani CSR. Ini
mengatasi ancaman pihak ketiga yang menyamar sebagai subjek resmi.
Pada contoh di atas, langkah ini adalah untuk memverifikasi bahwa Pod mengontrol
kunci pribadi yang digunakan untuk menghasilkan CSR.</li><li>Subjek CSR berwenang untuk bertindak dalam konteks yang diminta. Ini
mengatasi ancaman subjek yang tidak diinginkan bergabung dengan klaster. Dalam
contoh di atas, langkah ini untuk memverifikasi bahwa Pod diizinkan
berpartisipasi dalam Service yang diminta.</li></ol><p>Jika dan hanya jika kedua persyaratan ini dipenuhi, pemberi persetujuan harus menyetujui
CSR dan sebaliknya harus menolak CSR.</p><h2 id=peringatan-tentang-izin-persetujuan>Peringatan tentang Izin Persetujuan</h2><p>Kemampuan untuk menyetujui CSR menentukan siapa yang mempercayai siapa di dalam lingkungan kamu.
Kemampuan untuk menyetujui CSR tersebut seharusnya tidak diberikan secara luas.
Persyaratan tantangan yang disebutkan di bagian sebelumnya dan
dampak dari mengeluarkan sertifikat khusus, harus sepenuhnya dipahami
sebelum memberikan izin ini.</p><h2 id=catatan-untuk-administrator-klaster>Catatan Untuk Administrator Klaster</h2><p>Tutorial ini mengasumsikan bahwa penanda tangan diatur untuk melayani API sertifikat.
Kubernetes <em>controller manager</em> menyediakan implementasi bawaan dari penanda tangan. Untuk
mengaktifkan, berikan parameter <code>--cluster-signed-cert-file</code> dan
<code>--cluster-signed-key-file</code> ke <em>controller manager</em> dengan <em>path</em> ke
pasangan kunci CA kamu.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-ba58efa15c6d46f10e34d799be220965>4.11 - Mengelola Daemon Klaster</h1><div class=lead>Melakukan tugas-tugas umum untuk mengelola sebuah DaemonSet, misalnya <em>rolling update</em>.</div></div><div class=td-content><h1 id=pg-f1bf7e426f482a85e1a417d1fd9ea7b7>4.11.1 - Melakukan Rollback pada DaemonSet</h1><p>Laman ini memperlihatkan bagaimana caranya untuk melakukan <em>rollback</em> pada sebuah <a class=glossary-tooltip title='Memastikan salinan Pod dijalankan pada sekumpulan Node dalam satu klaster.' data-toggle=tooltip data-placement=top href=/id/docs/concepts/workloads/controllers/daemonset target=_blank aria-label=DaemonSet>DaemonSet</a>.</p><h2 id=sebelum-kamu-memulai>Sebelum kamu memulai</h2><p><p>Kamu harus memiliki klaster Kubernetes, dan perangkat baris perintah kubectl
juga harus dikonfigurasikan untuk berkomunikasi dengan klastermu. Jika kamu
belum memiliki klaster, kamu dapat membuatnya dengan menggunakan
<a href=/id/docs/tasks/tools/#minikube>minikube</a>,
atau kamu juga dapat menggunakan salah satu dari tempat mencoba Kubernetes berikut ini:</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>Bermain dengan Kubernetes</a></li></ul>Kubernetes servermu harus dalam versi yang sama atau lebih baru dari 1.7.
Untuk melihat versi, tekan <code>kubectl version</code>.</p><p>Sebelum lanjut, alangkah baiknya jika kamu telah mengetahui cara
untuk <a href=/docs/tasks/manage-daemon/update-daemon-set/>melakukan <em>rolling update</em> pada sebuah DaemonSet</a>.</p><h2 id=melakukan-rollback-pada-daemonset>Melakukan <em>rollback</em> pada DaemonSet</h2><h3 id=langkah-1-dapatkan-nomor-revisi-daemonset-yang-ingin-dikembalikan>Langkah 1: Dapatkan nomor revisi DaemonSet yang ingin dikembalikan</h3><p>Lompati langkah ini jika kamu hanya ingin kembali (<em>rollback</em>) ke revisi terakhir.</p><p>Perintah di bawah ini akan memperlihatkan daftar semua revisi dari DaemonSet:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl rollout <span style=color:#a2f>history</span> daemonset &lt;nama-daemonset&gt;
</span></span></code></pre></div><p>Perintah tersebut akan menampilkan daftar revisi seperti di bawah:</p><pre tabindex=0><code>daemonsets &#34;&lt;nama-daemonset&gt;&#34;
REVISION        CHANGE-CAUSE
1               ...
2               ...
...
</code></pre><ul><li>Alasan perubahan (<em>change cause</em>) kolom di atas merupakan salinan dari anotasi <code>kubernetes.io/change-cause</code> yang berkaitan dengan revisi pada DaemonSet. Kamu boleh menyetel <em>flag</em> <code>--record=true</code> melalui <code>kubectl</code> untuk merekam perintah yang dijalankan akibat dari anotasi alasan perubahan.</li></ul><p>Untuk melihat detail dari revisi tertentu, jalankan perintah di bawah ini:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl rollout <span style=color:#a2f>history</span> daemonset &lt;daemonset-name&gt; --revision<span style=color:#666>=</span><span style=color:#666>1</span>
</span></span></code></pre></div><p>Perintah tersebut memberikan detail soal nomor revisi tertentu:</p><pre tabindex=0><code>daemonsets &#34;&lt;nama-daemonset&gt;&#34; with revision #1
Pod Template:
Labels:       foo=bar
Containers:
app:
 Image:        ...
 Port:         ...
 Environment:  ...
 Mounts:       ...
Volumes:      ...
</code></pre><h3 id=langkah-2-rollback-ke-revisi-tertentu>Langkah 2: <em>Rollback</em> ke revisi tertentu</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Tentukan nomor revisi yang kamu dapatkan dari Langkah 1 melalui --to-revision</span>
</span></span><span style=display:flex><span>kubectl rollout undo daemonset &lt;nama-daemonset&gt; --to-revision<span style=color:#666>=</span>&lt;nomor-revisi&gt;
</span></span></code></pre></div><p>Jika telah berhasil, perintah tersebut akan memberikan keluaran berikut:</p><pre tabindex=0><code>daemonset &#34;&lt;nama-daemonset&gt;&#34; rolled back
</code></pre><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Jika <em>flag</em> <code>--to-revision</code> tidak diberikan, maka kubectl akan memilihkan revisi yang terakhir.</div><h3 id=langkah-3-lihat-progres-pada-saat-rollback-daemonset>Langkah 3: Lihat progres pada saat <em>rollback</em> DaemonSet</h3><p>Perintah <code>kubectl rollout undo daemonset</code> memberitahu server untuk memulai <em>rollback</em> DaemonSet.
<em>Rollback</em> sebenarnya terjadi secara <em>asynchronous</em> di dalam klaster <a class=glossary-tooltip title='Merupakan lapisan orkestrasi Container yang mengekspos API dan antarmuka untuk mendefinisikan, menggelar, dan mengelola siklus hidup suatu Container.' data-toggle=tooltip data-placement=top href='/id/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='_control plane_'>_control plane_</a>.</p><p>Perintah di bawah ini dilakukan untuk melihat progres dari <em>rollback</em>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl rollout status ds/&lt;nama-daemonset&gt;
</span></span></code></pre></div><p>Ketika <em>rollback</em> telah selesai dilakukan, keluaran di bawah akan ditampilkan:</p><pre tabindex=0><code>daemonset &#34;&lt;nama-daemonset&gt;&#34; successfully rolled out
</code></pre><h2 id=memahami-revisi-daemonset>Memahami revisi DaemonSet</h2><p>Pada langkah <code>kubectl rollout history</code> sebelumnya, kamu telah mendapatkan
daftar revisi DaemonSet. Setiap revisi disimpan di dalam sumber daya bernama ControllerRevision.</p><p>Untuk melihat apa yang disimpan pada setiap revisi, dapatkan sumber daya mentah (<em>raw</em>) dari
revisi DaemonSet:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get controllerrevision -l &lt;kunci-selektor-daemonset&gt;<span style=color:#666>=</span>&lt;nilai-selektor-daemonset&gt;
</span></span></code></pre></div><p>Perintah di atas akan mengembalikan daftar ControllerRevision:</p><pre tabindex=0><code>NAME                               CONTROLLER                     REVISION   AGE
&lt;nama-daemonset&gt;-&lt;hash-revisi&gt;   DaemonSet/&lt;nama-daemonset&gt;     1          1h
&lt;nama-daemonset&gt;-&lt;hash-revisi&gt;   DaemonSet/&lt;nama-daemonset&gt;     2          1h
</code></pre><p>Setiap ControllerRevision menyimpan anotasi dan templat dari sebuah revisi DaemonSet.</p><p>Perintah <code>kubectl rollout undo</code> mengambil ControllerRevision yang spesifik dan mengganti templat
DaemonSet dengan templat yang tersimpan pada ControllerRevision.
Perintah <code>kubectl rollout undo</code> sama seperti untuk memperbarui templat
DaemonSet ke revisi sebelumnya dengan menggunakan perintah lainnya, seperti <code>kubectl edit</code> atau <code>kubectl apply</code>.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Revisi DaemonSet hanya bisa <em>roll</em> ke depan. Artinya, setelah <em>rollback</em> selesai dilakukan,
nomor revisi dari ControllerRevision (<em>field</em> <code>.revision</code>) yang sedang di-<em>rollback</em> akan maju ke depan.
Misalnya, jika kamu memiliki revisi 1 dan 2 pada sistem, lalu <em>rollback</em> dari revisi 2 ke revisi 1,
ControllerRevision dengan <code>.revision: 1</code> akan menjadi <code>.revision: 3</code>.</div><h2 id=troubleshoot><em>Troubleshoot</em></h2><ul><li>Lihat cara untuk melakukan <a href=/docs/tasks/manage-daemon/update-daemon-set/#troubleshooting><em>troubleshoot rolling update</em> pada DaemonSet</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-68ec2370d0409cc27325be36693f9368>5 - Tutorial</h1><p>Bagian ini membahas tentang tutorial Kubernetes.
Tutorial berfungsi untuk memperlihatkan bagaimana caranya mencapai suatu tujuan yang lebih dari sekedar <a href=/docs/tasks/>task</a> sederhana.
Biasanya, sebuah tutorial punya beberapa bagian, masing-masing bagian terdiri dari langkah-langkah yang berurutan.
Sebelum melangkah lebih lanjut ke tutorial, sebaiknya tandai dulu halaman <a href=/docs/reference/glossary/>Kamus Istilah</a> untuk referensi nanti.</p><h2 id=prinsip-dasar>Prinsip Dasar</h2><ul><li><p><a href=/id/docs/tutorials/kubernetes-basics/>Prinsip Dasar Kubernetes</a> merupakan tutorial yang sangat interaktif, membantu kamu mengerti apa itu sistem Kubernetes dan beberapa fitur Kubernetes yang umum digunakan.</p></li><li><p><a href=https://www.udacity.com/course/scalable-microservices-with-kubernetes--ud615>Mikroservis yang Scalable dengan Kubernetes (Udacity)</a></p></li><li><p><a href=https://www.edx.org/course/introduction-kubernetes-linuxfoundationx-lfs158x#>Pengenalan Kubernetes (edX)</a></p></li><li><p><a href=/id/docs/tutorials/hello-minikube/>Halo Minikube</a></p></li></ul><h2 id=konfigurasi>Konfigurasi</h2><ul><li><a href=/docs/tutorials/configuration/configure-redis-using-configmap/>Konfigurasi Redis menggunakan sebuah ConfigMap</a></li></ul><h2 id=aplikasi-stateless>Aplikasi Stateless</h2><ul><li><p><a href=/id/docs/tutorials/stateless-application/expose-external-ip-address/>Memberi Akses Aplikasi di dalam Klaster melalui IP Eksternal</a></p></li><li><p><a href=/docs/tutorials/stateless-application/guestbook/>Contoh: Deploy aplikasi Guestbook PHP dengan Redis</a></p></li></ul><h2 id=aplikasi-stateful>Aplikasi Stateful</h2><ul><li><p><a href=/docs/tutorials/stateful-application/basic-stateful-set/>Prinsip Dasar StatefulSet</a></p></li><li><p><a href=/docs/tutorials/stateful-application/mysql-wordpress-persistent-volume/>Contoh: WordPress dan MySQL dengan Persistent Volumes</a></p></li><li><p><a href=/docs/tutorials/stateful-application/cassandra/>Contoh: Deploy Cassandra dengan Stateful Sets</a></p></li><li><p><a href=/docs/tutorials/stateful-application/zookeeper/>Menjalankan ZooKeeper, sebuah sistem terdistribusi yang berbasis CP</a></p></li></ul><h2 id=klaster>Klaster</h2><ul><li><p><a href=/docs/tutorials/clusters/apparmor/>AppArmor</a></p></li><li><p><a href=/docs/tutorials/clusters/seccomp/>seccomp</a></p></li></ul><h2 id=servis>Servis</h2><ul><li><a href=/docs/tutorials/services/source-ip/>Menggunakan Source IP</a></li></ul><h2 id=selanjutnya>Selanjutnya</h2><p>Tertarik menulis tutorial? Lihat
<a href=/docs/home/contribute/page-templates/>Menggunakan Template Halaman</a>
untuk info mengenai template dan ragam halaman tutorial.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-5e3051fff9e84735871d9fb5e7b93f33>5.1 - Halo Minikube</h1><p>Tutorial ini menunjukkan bagaimana caranya menjalankan aplikasi sederhana Node.js Halo Dunia di Kubernetes, dengan <a href=/docs/getting-started-guides/minikube><code>minikube</code></a> dan Katacoda.
Katacoda menyediakan <i>environment</i> Kubernetes secara gratis di dalam browser.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Kamupun bisa mengikuti tutorial ini kalau sudah instalasi minikube di lokal. Silakan lihat <a href=https://minikube.sigs.k8s.io/docs/start/>memulai <code>minikube</code></a> untuk instruksi instalasi.</div><h2 id=tujuan>Tujuan</h2><ul><li>Deploy aplikasi halo dunia pada minikube.</li><li>Jalankan aplikasinya.</li><li>Melihat log aplikasi.</li></ul><h2 id=sebelum-kamu-memulai>Sebelum kamu memulai</h2><p>Tutorial ini menyediakan image Kontainer yang dibuat melalui barisan kode berikut:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/minikube/server.js download=minikube/server.js><code>minikube/server.js</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("minikube-server-js")' title="Copy minikube/server.js to clipboard"></img></div><div class=includecode id=minikube-server-js><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#a2f;font-weight:700>var</span> http <span style=color:#666>=</span> require(<span style=color:#b44>&#39;http&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>var</span> handleRequest <span style=color:#666>=</span> <span style=color:#a2f;font-weight:700>function</span>(request, response) {
</span></span><span style=display:flex><span>  console.log(<span style=color:#b44>&#39;Received request for URL: &#39;</span> <span style=color:#666>+</span> request.url);
</span></span><span style=display:flex><span>  response.writeHead(<span style=color:#666>200</span>);
</span></span><span style=display:flex><span>  response.end(<span style=color:#b44>&#39;Hello World!&#39;</span>);
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>var</span> www <span style=color:#666>=</span> http.createServer(handleRequest);
</span></span><span style=display:flex><span>www.listen(<span style=color:#666>8080</span>);
</span></span></code></pre></div></div></div><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/minikube/Dockerfile download=minikube/Dockerfile><code>minikube/Dockerfile</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("minikube-dockerfile")' title="Copy minikube/Dockerfile to clipboard"></img></div><div class=includecode id=minikube-dockerfile><pre tabindex=0><code class=language-conf data-lang=conf>FROM node:6.14.2
EXPOSE 8080
COPY server.js .
CMD node server.js
</code></pre></div></div><p>Untuk info lebih lanjut tentang perintah <code>docker build</code>, baca <a href=https://docs.docker.com/engine/reference/commandline/build/>dokumentasi Docker</a>.</p><h2 id=membuat-sebuah-klaster-minikube>Membuat sebuah klaster Minikube</h2><ol><li><p>Tekan <strong>Launch Terminal</strong></p><script defer src=https://katacoda.com/embed.js></script>
<button class=button onclick=window.katacoda.init()>Launch Terminal</button><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Kalau kamu memilih instalasi minikube secara lokal, jalankan <code>minikube start</code>.</div></li><li><p>Buka dasbor Kubernetes di dalam browser:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>minikube dashboard
</span></span></code></pre></div></li><li><p>Hanya untuk <i>environment</i> Katacoda: Di layar terminal paling atas, tekan tombol plus, lalu lanjut tekan <strong>Select port to view on Host 1</strong>.</p></li><li><p>Hanya untuk <i>environment</i> Katacoda: Ketik <code>30000</code>, lalu lanjut tekan <strong>Display Port</strong>.</p></li></ol><h2 id=membuat-sebuah-deployment>Membuat sebuah Deployment</h2><p>Sebuah Kubernetes <a href=/id/docs/concepts/workloads/pods/pod/><em>Pod</em></a> adalah kumpulan dari satu atau banyak Kontainer,
saling terhubung untuk kebutuhan administrasi dan jaringan. Pod dalam tutorial ini hanya punya satu Kontainer. Sebuah Kubernetes
<a href=/id/docs/concepts/workloads/controllers/deployment/><em>Deployment</em></a> selalu memeriksa kesehatan
Pod kamu dan melakukan <i>restart</i> saat Kontainer di dalam Pod tersebut mati. Deployment adalah cara jitu untuk membuat dan mereplikasi Pod.</p><ol><li><p>Gunakan perintah <code>kubectl create</code> untuk membuat Deployment yang dapat mengatur Pod.
Pod menjalankan Kontainer sesuai dengan image Docker yang telah diberikan.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create deployment hello-node --image<span style=color:#666>=</span>k8s.gcr.io/echoserver:1.4
</span></span></code></pre></div></li><li><p>Lihat Deployment:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get deployments
</span></span></code></pre></div><p>Keluaran:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME         DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
</span></span><span style=display:flex><span>hello-node   <span style=color:#666>1</span>         <span style=color:#666>1</span>         <span style=color:#666>1</span>            <span style=color:#666>1</span>           1m
</span></span></code></pre></div></li><li><p>Lihat Pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods
</span></span></code></pre></div><p>Keluaran:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME                          READY     STATUS    RESTARTS   AGE
</span></span><span style=display:flex><span>hello-node-5f76cf6ccf-br9b5   1/1       Running   <span style=color:#666>0</span>          1m
</span></span></code></pre></div></li><li><p>Lihat <i>event</i> klaster:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get events
</span></span></code></pre></div></li><li><p>Lihat konfigurasi <code>kubectl</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config view
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Untuk info lebih lanjut tentang perintah <code>kubectl</code>, lihat <a href=/docs/user-guide/kubectl-overview/>ringkasan kubectl</a>.</div></li></ol><h2 id=membuat-sebuah-servis>Membuat sebuah Servis</h2><p>Secara <i>default</i>, Pod hanya bisa diakses melalui alamat IP internal di dalam klaster Kubernetes.
Supaya Kontainer <code>hello-node</code> bisa diakses dari luar jaringan virtual Kubernetes, kamu harus ekspos Pod sebagai <a href=/id/docs/concepts/services-networking/service/><em>Servis</em></a> Kubernetes.</p><ol><li><p>Ekspos Pod pada internet publik menggunakan perintah <code>kubectl expose</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl expose deployment hello-node --type<span style=color:#666>=</span>LoadBalancer --port<span style=color:#666>=</span><span style=color:#666>8080</span>
</span></span></code></pre></div><p>Tanda <code>--type=LoadBalancer</code> menunjukkan bahwa kamu ingin ekspos Servis keluar dari klaster.</p></li><li><p>Lihat Servis yang baru kamu buat:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get services
</span></span></code></pre></div><p>Keluaran:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME         TYPE           CLUSTER-IP      EXTERNAL-IP   PORT<span style=color:#666>(</span>S<span style=color:#666>)</span>          AGE
</span></span><span style=display:flex><span>hello-node   LoadBalancer   10.108.144.78   &lt;pending&gt;     8080:30369/TCP   21s
</span></span><span style=display:flex><span>kubernetes   ClusterIP      10.96.0.1       &lt;none&gt;        443/TCP          23m
</span></span></code></pre></div><p>Untuk penyedia cloud yang memiliki <i>load balancer</i>, sebuah alamat IP eksternal akan disediakan untuk mengakses Servis tersebut.
Pada minikube, tipe <code>LoadBalancer</code> membuat Servis tersebut dapat diakses melalui perintah <code>minikube service</code>.</p></li><li><p>Jalankan perintah berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>minikube service hello-node
</span></span></code></pre></div></li><li><p>Hanya untuk <i>environment</i> Katacoda: Tekan tombol plus, lalu lanjut tekan <strong>Select port to view on Host 1</strong>.</p></li><li><p>Hanya untuk <i>environment</i> Katacoda: Ketik <code>30369</code> (lihat port di samping <code>8080</code> pada keluaran servis), lalu lanjut tekan</p><p>Ini akan membuka jendela browser yang menjalankan aplikasimu dan memperlihatkan pesan "Halo Dunia".</p></li></ol><h2 id=aktifkan-addons>Aktifkan addons</h2><p>Perangkat minikube meliputi sekumpulan <a class=glossary-tooltip title='Resources that extend the functionality of Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/concepts/cluster-administration/addons/ target=_blank aria-label=addons>addons</a> bawaan yang bisa diaktifkan, dinonaktifkan, maupun dibuka di dalam <i>environment</i> Kubernetes lokal.</p><ol><li><p>Daftar <i>addons</i> yang ada saat ini:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>minikube addons list
</span></span></code></pre></div><p>Keluaran:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>addon-manager: enabled
</span></span><span style=display:flex><span>coredns: disabled
</span></span><span style=display:flex><span>dashboard: enabled
</span></span><span style=display:flex><span>default-storageclass: enabled
</span></span><span style=display:flex><span>efk: disabled
</span></span><span style=display:flex><span>freshpod: disabled
</span></span><span style=display:flex><span>heapster: disabled
</span></span><span style=display:flex><span>ingress: disabled
</span></span><span style=display:flex><span>kube-dns: enabled
</span></span><span style=display:flex><span>metrics-server: disabled
</span></span><span style=display:flex><span>nvidia-driver-installer: disabled
</span></span><span style=display:flex><span>nvidia-gpu-device-plugin: disabled
</span></span><span style=display:flex><span>registry: disabled
</span></span><span style=display:flex><span>registry-creds: disabled
</span></span><span style=display:flex><span>storage-provisioner: enabled
</span></span></code></pre></div></li><li><p>Aktifkan sebuah <i>addon</i>, misalnya <code>heapster</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>minikube addons <span style=color:#a2f>enable</span> heapster
</span></span></code></pre></div><p>Keluaran:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>heapster was successfully enabled
</span></span></code></pre></div></li><li><p>Lihat Pod dan Servis yang baru saja kamu buat:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod,svc -n kube-system
</span></span></code></pre></div><p>Keluaran:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME                                        READY     STATUS    RESTARTS   AGE
</span></span><span style=display:flex><span>pod/heapster-9jttx                          1/1       Running   <span style=color:#666>0</span>          26s
</span></span><span style=display:flex><span>pod/influxdb-grafana-b29w8                  2/2       Running   <span style=color:#666>0</span>          26s
</span></span><span style=display:flex><span>pod/kube-addon-manager-minikube             1/1       Running   <span style=color:#666>0</span>          34m
</span></span><span style=display:flex><span>pod/kube-dns-6dcb57bcc8-gv7mw               3/3       Running   <span style=color:#666>0</span>          34m
</span></span><span style=display:flex><span>pod/kubernetes-dashboard-5498ccf677-cgspw   1/1       Running   <span style=color:#666>0</span>          34m
</span></span><span style=display:flex><span>pod/storage-provisioner                     1/1       Running   <span style=color:#666>0</span>          34m
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>NAME                           TYPE        CLUSTER-IP      EXTERNAL-IP   PORT<span style=color:#666>(</span>S<span style=color:#666>)</span>             AGE
</span></span><span style=display:flex><span>service/heapster               ClusterIP   10.96.241.45    &lt;none&gt;        80/TCP              26s
</span></span><span style=display:flex><span>service/kube-dns               ClusterIP   10.96.0.10      &lt;none&gt;        53/UDP,53/TCP       34m
</span></span><span style=display:flex><span>service/kubernetes-dashboard   NodePort    10.109.29.1     &lt;none&gt;        80:30000/TCP        34m
</span></span><span style=display:flex><span>service/monitoring-grafana     NodePort    10.99.24.54     &lt;none&gt;        80:30002/TCP        26s
</span></span><span style=display:flex><span>service/monitoring-influxdb    ClusterIP   10.111.169.94   &lt;none&gt;        8083/TCP,8086/TCP   26s
</span></span></code></pre></div></li><li><p>Non-aktifkan <code>heapster</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>minikube addons disable heapster
</span></span></code></pre></div><p>Keluaran:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>heapster was successfully disabled
</span></span></code></pre></div></li></ol><h2 id=bersih-bersih>Bersih-bersih</h2><p>Sekarang, mari kita bersihkan semua <i>resource</i> yang kamu buat di klaster:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete service hello-node
</span></span><span style=display:flex><span>kubectl delete deployment hello-node
</span></span></code></pre></div><p>Kamu juga boleh mematikan mesin virtual atau <em>virtual machine</em> (VM) untuk minikube:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>minikube stop
</span></span></code></pre></div><p>Kamu juga boleh menghapus minikube VM:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>minikube delete
</span></span></code></pre></div><h2 id=selanjutnya>Selanjutnya</h2><ul><li>Pelajari lebih lanjut tentang <a href=/id/docs/concepts/workloads/controllers/deployment/>Deployment</a>.</li><li>Pelajari lebih lanjut tentang <a href=/docs/user-guide/deploying-applications/>Deploy aplikasi</a>.</li><li>Pelajari lebih lanjut tentang <a href=/id/docs/concepts/services-networking/service/>Servis</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-3c83f53a74233ace9b289ac5e24c3e62>5.2 - Mempelajari Panduan Dasar Kubernetes</h1><!doctype html><html lang=en><body><link href=/docs/tutorials/kubernetes-basics/public/css/styles.css rel=stylesheet><div class=layout id=top><main class=content><div class=row><div class=col-md-9><h2>Panduan Dasar Kubernetes</h2><p>Tutorial ini menyediakan panduan dasar mekanisme orkestrasi klaster Kubernetes. Setiap modul memliki beberapa informasi mengenai latar belakang bagi konsep mendasar dan <i>feature</i> Kubernetes, termasuk mode interaktif yang dapat digunakan sebagai metode pembelajaran <i>online</i>. Mode tutorial interaktif ini memberikan kesempatan pengguna untuk melakukan manajemen klaster sederhana beserta aplikasi terkontainerisasi yang kamu miliki.</p><p>Dengan menggunakan mode tutorial interaktif ini, pengguna diharapkan dapat memahami:</p><ul><li><i>Deploy</i> sebuah aplikasi yang sudah dikontainerisasi pada klaster</li><li>Melakukan <i>scale</i> <i>deployment</i></li><li>Memperbarui aplikasi yang sudah dikontainerisasi dengan menggunakan versi aplikasi terbaru</li><li>Men-<i>debug</i> aplikasi yang sudah dikontainerisasi</li></ul><p>Tutorial ini menggunakan Katakoda untuk menjalankan terminal virtual diatas Minikube pada <i>web browser</i> kamu. Dengan demikian, kamu tidak perlu melakukan instalasi perangkat lunak apa pun, segala modul yang ada dijalankan secara langsung melalui <i>web browser</i> yang kamu miliki.</p></div></div><br><div class=row><div class=col-md-9><h2>Apa yang dapat dilakukan oleh Kubernetes untuk kamu?</h2><p>Seiring berkembangnya web servis modern, pengguna memiliki ekspektasi agar aplikasi selalu dapat diakses 24/7, selain itu <i>developers</i> juga memiliki harapan agar mereka dapat melakukan <i>deployment</i> aplikasi dengan versi terbaru yang mereka miliki berulang per hari. Mekanisme kontainerisasi mengepak perangkat lunak agar memenuhi kebutuhan yang ada, memudahkan serta mempercepat proses rilis dan pembaharuan aplikasi tanpa adanya <i>downtime</i> proses ini dapat dilakukan berulang per hari. Kubernetes membantu kamu menjaga aplikasi yang kamu buat untuk dapat dijalankan dimana pun dan kapan pun kamu menginginkannya, serta menjamin segala kebutuhan dan peralatan yang dibutuhkan oleh aplikasi kamu tersedia. Kubernetes merupakan platform <i>open source</i> yang sudah matang yang didesain berdasarkan pengalaman Google serta ide yang brilian dari komunitas yang ada.</p></div></div><br><div id=basics-modules class=content__modules><h2>Modul Dasar Kubernetes</h2><div class=row><div class=col-md-12><div class=row><div class=col-md-4><div class=thumbnail><a href=/id/docs/tutorials/kubernetes-basics/create-cluster/cluster-intro/><img src="/docs/tutorials/kubernetes-basics/public/images/module_01.svg?v=1469803628347" alt></a><div class=caption><a href=/id/docs/tutorials/kubernetes-basics/create-cluster/cluster-intro/><h5>1. Membuat klaster Kubernetes</h5></a></div></div></div><div class=col-md-4><div class=thumbnail><a href=/id/docs/tutorials/kubernetes-basics/deploy-app/deploy-intro/><img src="/docs/tutorials/kubernetes-basics/public/images/module_02.svg?v=1469803628347" alt></a><div class=caption><a href=/id/docs/tutorials/kubernetes-basics/deploy-app/deploy-intro/><h5>2. Menyebarkan (Deploy) Aplikasi</h5></a></div></div></div><div class=col-md-4><div class=thumbnail><a href=/id/docs/tutorials/kubernetes-basics/explore/explore-intro/><img src="/docs/tutorials/kubernetes-basics/public/images/module_03.svg?v=1469803628347" alt></a><div class=caption><a href=/id/docs/tutorials/kubernetes-basics/explore/explore-intro/><h5>3. Menjelajahi aplikasimu</h5></a></div></div></div></div></div><div class=col-md-12><div class=row><div class=col-md-4><div class=thumbnail><a href=/id/docs/tutorials/kubernetes-basics/expose/expose-intro/><img src="/docs/tutorials/kubernetes-basics/public/images/module_04.svg?v=1469803628347" alt></a><div class=caption><a href=/id/docs/tutorials/kubernetes-basics/expose/expose-intro/><h5>4. Mengekspos aplikasimu secara publik</h5></a></div></div></div><div class=col-md-4><div class=thumbnail><a href=/id/docs/tutorials/kubernetes-basics/scale/scale-intro/><img src="/docs/tutorials/kubernetes-basics/public/images/module_05.svg?v=1469803628347" alt></a><div class=caption><a href=/id/docs/tutorials/kubernetes-basics/scale/scale-intro/><h5>5. Penyekalaan naik aplikasimu</h5></a></div></div></div><div class=col-md-4><div class=thumbnail><a href=/id/docs/tutorials/kubernetes-basics/update/update-intro/><img src="/docs/tutorials/kubernetes-basics/public/images/module_06.svg?v=1469803628347" alt></a><div class=caption><a href=/id/docs/tutorials/kubernetes-basics/update/update-intro/><h5>6. Memperbarui aplikasimu</h5></a></div></div></div></div></div></div></div></main></div></body></html></div><div class=td-content style=page-break-before:always><h1 id=pg-7df66040311338d6098ebeab43ba9afb>5.2.1 - Membuat Klaster</h1></div><div class=td-content><h1 id=pg-de49316920e97a82e36763cb66781ada>5.2.1.1 - Menggunakan Minikube Untuk Membuat Klaster</h1><!doctype html><html lang=id><body><link href=/docs/tutorials/kubernetes-basics/public/css/styles.css rel=stylesheet><div class=layout id=top><main class=content><div class=row><div class=col-md-8><h3>Objectives</h3><ul><li>Belajar apa itu klaster Kubernetes.</li><li>Belajar apa itu Minikube.</li><li>Memulai klaster Kubernetes menggunakan terminal _online_.</li></ul></div><div class=col-md-8><h3>Klaster Kubernetes</h3><p><b>Kubernetes mengoordinasikan klaster komputer ketersediaan tinggi (_highly available_) yang saling terhubung sebagai unit tunggal.</b> Abstraksi pada Kubernetes mengizinkan kamu untuk men-_deploy_ aplikasi terkemas (_containerized_) ke sebuah klaster tanpa perlu membalutnya secara spesifik pada setiap mesin. Untuk menggunakan model baru _deployment_ ini, aplikasi perlu dikemas dengan cara memisahkan mereka dari hos individu: mereka perlu dikemas. Aplikasi terkemas lebih fleksibel dan tersedia dibanding model _deployment_ lama, dimana aplikasi dipasang secara langsung didalam mesin spesifik sebagai paket yang sangat terintegrasi dengan hos. <b>Kubernetes mengotomasisasikan distribusi dan penjadwalan kontainer aplikasi sebuah klaster secara menyeluruh dengan cara yang lebih efisien.</b> Kubernetes merupakan platform _open-source_ dan siap produksi.</p><p>Klaster Kubernetes terdiri dari 2 tipe sumber daya:<ul><li><b>Master</b> mengoordinasikan klaster</li><li><b>Node</b> adalah pekerja (_worker_) yang menjalankan aplikasi</li></ul></p></div><div class=col-md-4><div class="content_box content_box_lined"><h3>Summary:</h3><ul><li>Klaster Kubernetes</li><li>Minikube</li></ul></div><div class="content_box content_box_fill"><p><i>Kubernetes merupakan platform _open-source_ tingkat produksi yang mengatur penjadwalan dan eksekusi kontainer aplikasi didalam dan keseluruhan klaster komputer.</i></p></div></div></div><br><div class=row><div class=col-md-8><h2 style=color:#3771e3>Diagram Klaster</h2></div></div><div class=row><div class=col-md-8><p><img src=/docs/tutorials/kubernetes-basics/public/images/module_01_cluster.svg></p></div></div><br><div class=row><div class=col-md-8><p><b>Master mempunyai kewajiban untuk mengelola klaster.</b> Master mengoordinasikan semua aktifitas di klaster kamu, seperti penjadwalan aplikasi, pemeliharaan keadaan (_state_) aplikasi yang diinginkan, _scaling_ aplikasi, dan _roll-out_ pembaharuan.</p><p><b>Node merupakan VM atau komputer fisik yang berfungsi sebagai mesin pekerja dalam klaster Kubernetes.</b> Setiap node mempunyai Kubelet, sebuah agen untuk mengatur Node dan komunikasi dengan Kubernetes master. Node juga harus mempunyai alat untuk menangani operasi kontainer, seperti Docker atau rkt. Sebuah klaster Kubernetes yang menangani trafik produksi harus mempunyai minimal 3 Node.</p></div><div class=col-md-4><div class="content_box content_box_fill"><p><i>Master mengatur klaster dan Node yang digunakan sebagai hos dari aplikasi yang berjalan.</i></p></div></div></div><div class=row><div class=col-md-8><p>Ketika kamu men-_deploy_ aplikasi pada Kubernetes, kamu memberitahu master untuk memulai kontainer aplikasi. Master melakukan penjadwalan kontainer untuk berjalan diatas klaster Node. <b>Node berkomunikasi dengan master menggunakan <a href=/docs/concepts/overview/kubernetes-api/>Kubernetes API</a></b>, yang disediakan oleh master. Pengguna akhir juga dapat menggunakan Kubernetes API secara langsung untuk berinteraksi dengan klaster.</p><p>Klaster Kubernetes dapat di-_deploy_ ke mesik fisik maupun virtual. Untuk memulai pengembangan Kubernetes, kamu dapat menggunakan Minikube. Minikube merupakan implementasi Kubernetes ringan yang membuat VM padi mesin lokal kamu dan men-_deploy_ klaster sederhanya yang terdiri atas 1 Node. Minikube tersedia untuk Linux, macOS, dan sistem Windows. Minikube CLI menyediakan operasi _bootstraping_ dasar untuk bekerja dengan klaster kamu. Namun untuk tutorial ini, kamu akan menggunakan online terminal yang sudah disediakan dengan Minikube yang sudah diinstall sebelumnya.</p><p>Sekarang kamu telah mengetahui apa itu Kubernetes, mari kita pergi ke tutorial online dan memulai klaster pertama kita!</p></div></div><br><div class=row><div class=col-md-12><a class="btn btn-lg btn-success" href=/docs/tutorials/kubernetes-basics/create-cluster/cluster-interactive/ role=button>Mulai Tutorial Interaktif<span class=btn_next>›</span></a></div></div></main></div></body></html></div><div class=td-content style=page-break-before:always><h1 id=pg-323b75976001e8dfe35d67d61bc74f1a>5.2.1.2 - Tutorial Interaktif - Membuat Klaster</h1><!doctype html><html lang=id><body><link href=/docs/tutorials/kubernetes-basics/public/css/styles.css rel=stylesheet><link href=/docs/tutorials/kubernetes-basics/public/css/overrides.css rel=stylesheet><script src=https://katacoda.com/embed.js></script><div class=layout id=top><main class="content katacoda-content"><div class=katacoda><div class=katacoda__alert>Layar terlalu kecil untuk berinteraksi dengan Terminal, silahkan gunakan desktop/tablet.</div><div class=katacoda__box id=inline-terminal-1 data-katacoda-lang=id data-katacoda-id=kubernetes-bootcamp/1 data-katacoda-color=326de6 data-katacoda-secondary=273d6d data-katacoda-hideintro=false data-katacoda-prompt="Kubernetes Bootcamp Terminal" style=height:600px></div></div><div class=row><div class=col-md-12><a class="btn btn-lg btn-success" href=/id/docs/tutorials/kubernetes-basics/deploy-app/deploy-intro/ role=button>Lanjut ke Modul 2<span class=btn__next>›</span></a></div></div></main></div></body></html></div><div class=td-content style=page-break-before:always><h1 id=pg-76d78b3fba507f7ed33cef14a35b631d>5.2.2 - Menyebarkan (Deploy) Aplikasi</h1></div><div class=td-content><h1 id=pg-2b1bba431989008c7493109a0f049ece>5.2.2.1 - Menggunakan kubectl untuk membuat Deployment</h1><!doctype html><html lang=id><body><link href=/docs/tutorials/kubernetes-basics/public/css/styles.css rel=stylesheet><div class=layout id=top><main class=content><div class=row><div class=col-md-8><h3>Tujuan</h3><ul><li>Belajar tentang menyebarkan (<i>deploy</i>) aplikasi.</li><li>Menyebarkan aplikasi pertama kamu di Kubernetes dengan kubectl.</li></ul></div><div class=col-md-8><h3><i>Deployment</i> Kubernetes</h3><p>Ketika klaster Kubernetes kamu sudah berjalan, kamu dapat menyebarkan aplikasi terkontainerisasi di atasnya.
Untuk melakukannya, kamu perlu membuat konfigurasi <b>Deployment</b>. Deployment menginstruksikan Kubernetes
tentang bagaimana cara membuat dan memperbarui <i>instance</i> aplikasi kamu. Ketika kamu selesai membuat Deployment, Kubernetes <i>control plane</i>
melakukan penjadwalan <i>instance</i> aplikasi yang terlibat dalam Deployment untuk berjalan di Node individu pada klaster.</p><p>Setelah <i>instance</i> aplikasi telah dibuat, Kubernetes Deployment Controller akan melakukan monitoring <i>instance</i> tersebut secara kontinu. Jika <i>instance</i> pada hos Node mati atau terhapus, Deployment Controller akan mengganti <i>instance</i> tersebut dengan <i>instance</i> Node lain dalam klaster. <b>Ia menyediakan mekanisme penyembuhan diri (<i>self-healing</i>) untuk mengatasi kegagalan mesin atau pemeliharaan (<i>maintenance</i>)</b></p><p>Pada masa pra-orkestrasi, instalasi <i>script</i> sering digunakan untuk memulai aplikasi, namun cara ini tidak memberikan mekanisme pemulihan ketika terjadi kegagalan mesin. Dengan kemampuan membuat <i>instance</i> aplikasi dan menjaganya tetap berjalan pada Node, Deployment Kubernetes menyediakan manajemen aplikasi dengan pendekatan fundamental yang berbeda.</p></div><div class=col-md-4><div class="content__box content__box_lined"><h3>Ringkasan:</h3><ul><li>Deployment</li><li>Kubectl</li></ul></div><div class="content__box content__box_fill"><p><i>Sebuah Deployment bertanggung jawab untuk membuat dan memperbarui instance dari aplikasi kamu</i></p></div></div></div><br><div class=row><div class=col-md-8><h2 style=color:#3771e3>Menyebarkan aplikasi pertama kamu dalam Kubernetes</h2></div></div><div class=row><div class=col-md-8><p><img src=/docs/tutorials/kubernetes-basics/public/images/module_02_first_app.svg></p></div></div><br><div class=row><div class=col-md-8><p>Kamu dapat membuat dan mengatur Deployment dengan menggunakan antar muka baris perintah (CLI) Kubernetes, <b>Kubectl</b>. Kubectl menggunakan Kubernetes API untuk berinteraksi dengan klaster. Pada modul ini, kamu akan belajar perintah-perintah yang sering digunakan Kubectl untuk membuat Deployment untuk menjalankan aplikasi kamu pada klaster Kubernetes.</p><p>Ketika kamu membuat Deployment, kamu perlu mendefinisikan Container <i>image</i> untuk aplikasi kamu dan jumlah replika yang kamu inginkan. Kamu dapat mengganti informasi tersebut nanti dengan melakukan pembaharuan Deployment kamu; Modul <a href=docs/tutorials/kubernetes-basics/scale/scale-intro/>5</a> dan <a href=/docs/tutorials/kubernetes-basics/update/update-intro/>6</a> pada <i>bootcamp</i> ini mendiskusikan bagaimana cara melakukan perluasan (<i>scale</i>) dan pembaruan Deployment kamu.</p></div><div class=col-md-4><div class="content__box content__box_fill"><p><i>Aplikasi perlu dikemas menjadi satu dengan format Container yang didukung supaya tersebar pada Kubernetes</i></p></div></div></div><div class=row><div class=col-md-8><p>Pada Deployment pertama kamu, kamu akan menggunakan aplikasi Node.js yang terkemas dalam Container Docker. (Jika kamu belum pernah mencoba membuat aplikasi Node.js dan menyebarkannya dengan Container, kamu dapat melakukannya dengan mengikuti instruksi pada <a href=/id/docs/tutorials/hello-minikube/>tutorial Hello Minikube</a>).</p><p>Sekarang kamu tahu apa itu Deployment, mari kita ke tutorial <i>online</i> dan menyebarkan aplikasi pertama kita!</p></div></div><br><div class=row><div class=col-md-12><a class="btn btn-lg btn-success" href=/id/docs/tutorials/kubernetes-basics/deploy-app/deploy-interactive/ role=button>Mulai Tutorial Interaktif <span class=btn__next>›</span></a></div></div></main></div></body></html></div><div class=td-content style=page-break-before:always><h1 id=pg-f8997ec143b382fa6c9621941ea62ca3>5.2.2.2 - Tutorial Interaktif - Menyebarkan (Deploy) Aplikasi</h1><!doctype html><html lang=id><body><link href=/docs/tutorials/kubernetes-basics/public/css/styles.css rel=stylesheet><link href=/docs/tutorials/kubernetes-basics/public/css/overrides.css rel=stylesheet><script src=https://katacoda.com/embed.js></script><div class=layout id=top><main class="content katacoda-content"><div class=row><div class=col-md-12><p>Pod merupakan unit eksekusi utama pada aplikasi Kubernetes. Setiap Pod mewakili sebagian dari beban kerja (<i>workload</i>) yang berjalan pada klaster kamu. <a href=/id/docs/concepts/workloads/pods/pod-overview/#understanding-pods>Learn more about Pods</a>.</p></div></div><br><div class=katacoda><div class=katacoda__alert>Untuk berinteraksi dengan Terminal, silahkan gunakan desktop/tablet.</div><div class=katacoda__box id=inline-terminal-1 data-katacoda-lang=id data-katacoda-id=kubernetes-bootcamp/7 data-katacoda-color=326de6 data-katacoda-secondary=273d6d data-katacoda-hideintro=false data-katacoda-prompt="Kubernetes Bootcamp Terminal" style=height:600px></div></div><div class=row><div class=col-md-12><a class="btn btn-lg btn-success" href=/id/docs/tutorials/kubernetes-basics/explore/explore-intro/ role=button>Lanjut ke Modul 3<span class=btn__next>›</span></a></div></div></main></div></body></html></div><div class=td-content style=page-break-before:always><h1 id=pg-250d620a73ec8be7e1f7d835574c4596>5.2.3 - Menjelajahi Aplikasimu</h1></div><div class=td-content><h1 id=pg-2771f4e8c45321b17cb0114a2d266453>5.2.3.1 - Melihat Pod dan Node</h1><!doctype html><html lang=id><body><link href=/docs/tutorials/kubernetes-basics/public/css/styles.css rel=stylesheet><div class=layout id=top><main class=content><div class=row><div class=col-md-8><h3>Tujuan</h3><ul><li>Belajar tentang Pod Kubernetes.</li><li>Belajar tentang Node Kubernetes.</li><li>Mengatasi masalah pada aplikasi-aplikasi yang digelar.</li></ul></div><div class=col-md-8><h2>Pod Kubernetes</h2><p>Ketika kamu membuat sebuah Deployment pada Modul <a href=/id/docs/tutorials/kubernetes-basics/deploy-app/deploy-intro/>2</a>, Kubernetes membuatkan sebuah <b>Pod</b> untuk menempatkan instans aplikasimu. Pod merupakan sebuah abstraksi Kubernetes yang merepresentasikan sebuah grup yang terdiri dari satu atau lebih kontainer (seperti Docker), dan beberapa sumber daya bersama untuk kontainer-kontainer itu. Sumber daya tersebut termasuk:</p><ul><li>Penyimpanan bersama, disebut Volume</li><li>Jaringan, sebagai satu alamat IP klaster unik</li><li>Informasi tentang bagaimana mejalankan tiap kontainer, seperti versi <i>image</i> atau porta spesifik yang digunakan oleh kontainer</li></ul><p>Pod memodelkan sebuah "logical host" spesifik aplikasi dan dapat berisi beberapa kontainer aplikasi berbeda yang relatif terkait erat. Contohnya, sebuah Pod mungkin terdiri atas kontainer aplikasi Node.js dan juga kontainer berbeda yang bertugas menyediakan data untuk dipublikasikan ke server web Node.js. Kontainer-kontainer dalam sebuah Pod berbagi satu alamat IP dan ruang porta, selalu terletak bersama dan terjadwal bersama, dan berjalankan dalam satu konteks bersama (<i>shared context</i>) pada Node yang sama.</p><p>Pod merupakan unit terkecil dalam platform Kubernetes. Ketika kita membuat sebuat Deployment, Deployment tersebut membuat Pod dengan kontainer-kontainer di dalamnya (bukannya dengan membuat kontainer secara langsung). Tiap Pod terikat langsung dengan Node di mana dia dijadwalkan dan tetap di sana sampai diterminasi (berdasarkan <i>restart policy</i>) atau penghapusan. Jika terjadi kegagalan pada sebuah Node, Pod indentik akan dijadwalkan di Node lain dalam klaster.</p></div><div class=col-md-4><div class="content__box content__box_lined"><h3>Ringkasan:</h3><ul><li>Pod</li><li>Node</li><li>Perintah utama kubectl</li></ul></div><div class="content__box content__box_fill"><p><i>Pod merupakan sebuah grup yang terdiri dari satu atau lebih kontainer aplikasi (seperti Docker) dan berisi penyimpanan bersama (<i>volume</i>), alamat IP dan informasi tentang bagaimana menjalankan mereka.</i></p></div></div></div><br><div class=row><div class=col-md-8><h2 style=color:#3771e3>Ikhtisar Pod</h2></div></div><div class=row><div class=col-md-8><p><img src=/docs/tutorials/kubernetes-basics/public/images/module_03_pods.svg></p></div></div><br><div class=row><div class=col-md-8><h2>Node</h2><p>Sebuah Pod selalu berjalan dalam sebuah <b>Node</b>. Node merupakan sebuah mesin pekerja (<i>worker</i>) di Kubernetes dan mungkin merupakan mesin virtual ataupun fisik, tergantung dari klaster. Tiap Node dikelola oleh control plane. Satu Node dapat memiliki beberapa Pod, dan control plane Kubernetes yang otomatis menangani penjadwalan pod seluruh Node-Node dalam klaster. Penjadwalan otomatis oleh control plane memperhitungkan tersedianya sumber daya tiap Node.</p><p>Tiap Node Kubernetes menjalankan setidaknya:</p><ul><li>Kubelet, satu proses yang bertanggung jawab untuk berkomunikasi antara control plane Kubernetes dan Node; ini juga mengelola Pod-Pod dan kontainer-kontainer yang berjalan di sebuah mesin.</li><li>Satu <i>container runtime</i>, seperti Docker, bertanggung jawab untuk menarik <i>image</i> kontainer dari register, membuka kontainer, dan menjalankan aplikasi.</li></ul></div><div class=col-md-4><div class="content__box content__box_fill"><p><i>Kontainer seharusnya hanya dijadwalkan bersama di satu Pod jika terkait erat dan membutuhkan sumber daya bersama seperti diska.</i></p></div></div></div><br><div class=row><div class=col-md-8><h2 style=color:#3771e3>Ikhtisar Node</h2></div></div><div class=row><div class=col-md-8><p><img src=/docs/tutorials/kubernetes-basics/public/images/module_03_nodes.svg></p></div></div><br><div class=row><div class=col-md-8><h2>Mengatasi masalah dengan kubectl</h2><p>Dalam Modul <a href=/id/docs/tutorials/kubernetes-basics/deploy-app/deploy-intro/>2</a>, kamu menggunakan antarmuka baris perintah kubectl. Kamu akan lanjut menggunakannya pada modul 3 untuk mendapatkan informasi tentang aplikasi-aplikasi yang digelar dan lingkungannya. Operasi yang paling umum dapat dilakukan dengan perintah kubectl berikut:</p><ul><li><b>kubectl get</b> - melihat daftar sumber daya</li><li><b>kubectl describe</b> - menampilkan detil informasi tentang suatu sumber daya</li><li><b>kubectl logs</b> - mencetak log-log dari satu kontainer dalam sebuah Pod</li><li><b>kubectl exec</b> - eksekusi sebuah perintah pada satu kontainer dalam sebuah Pod</li></ul><p>Kamu dapat menggunakan perintah ini kapan aplikasi-aplikasi digelar, apa status mereka saat ini, di mana mereka berjalan, dan apa konfigurasi mereka.</p><p>Sekarang karena kita lebih mengetahui tentang klaster kita dan baris perintahnya, mari kita menjelajah aplikasi kita.</p></div><div class=col-md-4><div class="content__box content__box_fill"><p><i>Node merupakan mesin pekerja di Kubernetes dan bisa berupa VM ataupun mesin fisik, tergantung pada klaster. Beberapa Pod dapat berjalan dalam satu Node.</i></p></div></div></div><br><div class=row><div class=col-md-12><a class="btn btn-lg btn-success" href=/id/docs/tutorials/kubernetes-basics/explore/explore-interactive/ role=button>Mulai Tutorial Interaktif <span class=btn__next>›</span></a></div></div></main></div></body></html></div><div class=td-content style=page-break-before:always><h1 id=pg-4b01eab98a9844ad91131079654199dd>5.2.3.2 - Tutorial Interaktif - Menjelajahi Aplikasimu</h1><!doctype html><html lang=id><body><link href=/docs/tutorials/kubernetes-basics/public/css/styles.css rel=stylesheet><link href=/docs/tutorials/kubernetes-basics/public/css/overrides.css rel=stylesheet><script src=https://katacoda.com/embed.js></script><div class=layout id=top><main class="content katacoda-content"><br><div class=katacoda><div class=katacoda__alert>Untuk berinteraksi dengan Terminal, tolong gunakan dalam desktop/tablet</div><div class=katacoda__box id=inline-terminal-1 data-katacoda-lang=id data-katacoda-id=kubernetes-bootcamp/4 data-katacoda-color=326de6 data-katacoda-secondary=273d6d data-katacoda-hideintro=false data-katacoda-prompt="Kubernetes Bootcamp Terminal" style=height:600px></div></div><div class=row><div class=col-md-12><a class="btn btn-lg btn-success" href=/id/docs/tutorials/kubernetes-basics/expose/expose-intro/ role=button>Lanjut ke Modul 4<span class=btn__next>›</span></a></div></div></main></div></body></html></div><div class=td-content style=page-break-before:always><h1 id=pg-4b0e31c9e0eae68bbb0a358b4042ada9>5.2.4 - Mengekspos Aplikasimu Secara Publik</h1></div><div class=td-content><h1 id=pg-8ef4dad8f743b191a9e8c6f891cb191a>5.2.4.1 - Menggunakan Service untuk Mengekspos Aplikasimu</h1><!doctype html><html lang=id><body><link href=/docs/tutorials/kubernetes-basics/public/css/styles.css rel=stylesheet><div class=layout id=top><main class=content><div class=row><div class=col-md-8><h3>Tujuan</h3><ul><li>Belajar tentang Service di Kubernetes</li><li>Memahami bagaimana label dan objek LabelSelector berhubungan dengan sebuah Service</li><li>Mengekspos sebuah aplikasi keluar klaster Kubernetes menggunakan sebuah Service</li></ul></div><div class=col-md-8><h3>Ikhtisar Service Kubernetes</h3><p><a href=/id/docs/concepts/workloads/pods/>Pod-Pod</a> Kubernetes itu fana. Pod pada kenyataannya punya <a href=/id/docs/concepts/workloads/pods/pod-lifecycle/>siklus hidup</a>. Ketika sebuah Node pekerja mati, Pod yang berjalan dalam Node itu juga hilang. <a href=/id/docs/concepts/workloads/controllers/replicaset/>ReplicaSet</a> mungkin kemudian secara dinamis mendorong klaster kembali ke keadaan yang diinginkan melalui penciptaan Pod baru untuk memastikan aplikasimu berjalan. Contoh lainnya, katakanlah ada <i>backend</i> pengolahan citra dengan 3 replika. Replika tersebut dapat ditukar; sistem <i>front-end</i> seharusnya tidak peduli tentang replika <i>backend</i> atau bahkan jika Pod hilang dan dibuat ulang. Walaupun demikian, tiap Pod dalam sebuah klaster Kubernetes memiliki alamat IP unik, meskipun Pod-Pod itu berada dalam satu Node yang sama, sehingga seharusnya ada jalan untuk mencocokan perubahan antara Pod-Pod itu sehingga aplikasimu tetap berfungsi.</p><p>Service di Kubernetes merupakan abstraksi yang mendefinisikan satu set Pod secara logis dan aturan untuk mengakses mereka. Service memungkinkan keterkaitan renggang antara Pod-Pod. Sebuah Service didefinisikan menggunakan YAML <a href=/id/docs/concepts/configuration/overview/#tip-konfigurasi-secara-umum>(lebih disukai)</a> atau JSON, sebagaimana semua objek Kubernetes. Kumpulan Pod yang ditargetkan oleh Service biasanya ditentukan oleh <i>LabelSelector</i> (lihat di bawah mengapa kamu mungkin ingin Service tanpa <code>selector</code> dalam <i>spec</i>).</p><p>Meskipun tiap Pod memiliki alamat IP unik, IP tersebut tidak diekpos ke luar klaster tanpa sebuah Service. Service memperbolehkan aplikasimu untuk menerima kunjungan. Service dapat diekspos dengan cara yang berbeda menggunakan <code>type</code> di ServiceSpec:<ul><li><i>ClusterIP</i> (bawaan) - Mengekspos Service dengan internal IP dalam klaster. <i>Type</i> ini membuat Service hanya bisa diakses dalam klaster.</li><li><i>NodePort</i> - Mengekspos Service dengan porta yang sama untuk tiap Node dalam klaster menggunakan NAT. Ini membuat Service dapat diakses dari luar dengan <code>&lt;NodeIP>:&lt;NodePort></code>. <i>Superset</i> dari ClusterIP.</li><li><i>LoadBalancer</i> - Membuat <i>load balancer</i> eksternal di <i>cloud</i> saat ini (jika didukung) dan memberikan IP eksternal tetap kepada Service. <i>Superset</i> dari NodePort.</li><li><i>ExternalName</i> - Mengekpos Service menggunakan nama sesuai keinginan (ditentukan oleh <code>externalName</code> dalam <i>spec</i>) dengan mengembalikan catatan CNAME dengan nama tersebut. Tidak menggunakan proksi. <i>Type</i> ini membutuhkan <code>kube-dns</code> versi v1.7 atau lebih tinggi.</li></ul><p>Informasi lebih tentang <i>type</i> Service berbeda dapat ditemukan di tutorial <a href=/docs/tutorials/services/source-ip/>Menggunakan IP pengirim</a>. Lihat juga <a href=/id/docs/concepts/services-networking/connect-applications-service>Menghubungkan aplikasi dengan Service</a>.</p><p>Selain itu, catat bahwa ada kasus penggunaan Service yang tidak mendefinisikan <code>selector</code> di <i>spec</i>. Sebuah Service yang dibuat tanpa <code>selector</code> juga tidak akan membuat objek Endpoint yang sesuai. Ini mengizinkan pengguna untuk memetakan Service secara manual ke <i>endpoint</i> spesifik. Kemungkinan lain kenapa dimungkinan tanpa <i>selector</i> adalah kamu dengan tegas menggunakan <code>type: ExternalName</code>.</p></div><div class=col-md-4><div class="content__box content__box_lined"><h3>Ringkasan</h3><ul><li>Mengekspos Pod ke kunjungan eksternal</li><li><i>Load balancing</i> kunjungan melintasi beberapa Pod</li><li>Menggunakan label</li></ul></div><div class="content__box content__box_fill"><p><i>Service Kubernetes adalah lapisan abstraksi yang mendefinisikan kumpulan Pod secara logis dan mengijinkan paparan kunjungan eksternal, <i>load balancing</i>, dan <i>service discovery</i> untuk Pod-Pod tersebut.</i></p></div></div></div><br><div class=row><div class=col-md-8><h3>Service dan Label</h3></div></div><div class=row><div class=col-md-8><p><img src=/docs/tutorials/kubernetes-basics/public/images/module_04_services.svg width=150% height=150%></p></div></div><div class=row><div class=col-md-8><p>Service mengarahkan kunjungan melintasi sekumpulan Pod. Service merupakan abstraksi yang mengizinkan Pod-Pod untuk mati dan replikasi dalam Kubernetes tanpa memengaruhi aplikasimu. Menemukan dan <i>routing</i> antara Pod dependen (seperti komponen <i>frontend</i> dan <i>backend</i>) yang ditangani oleh Service Kubernetes.</p><p>Service mencocokan satu set Pod menggunakan <a href=/id/docs/concepts/overview/working-with-objects/labels/>label dan selektor</a>, mengelompokan primitif yang mengizinkan operasi logika pada objek-objek dalam Kubernetes. Label adalah pasangan <i>key/value</i> yang melekat pada objek-objek dan dapat digunakan untuk beberapa tujuan:</p><ul><li>Menandai objek-objek untuk lingkungan <i>development</i>, <i>test</i>, dan <i>production</i></li><li>Melekatkan label versi</li><li>Klasifikasi sebuah objek dengan label-label</li></ul></div></div><br><div class=row><div class=col-md-8><p><img src=/docs/tutorials/kubernetes-basics/public/images/module_04_labels.svg></p></div></div><br><div class=row><div class=col-md-8><p>Label-label dapat dilekatkan pada objek-objek pada waktu pembuatan ataupun setelahnya. Mereka dapat diubah kapanpun. Mari kita ekspos aplikasi kita sekarang dengan sebuah Service dan menerapkan beberapa label.</p></div></div><br><div class=row><div class=col-md-12><a class="btn btn-lg btn-success" href=/id/docs/tutorials/kubernetes-basics/expose/expose-interactive/ role=button>Mulai Tutorial Interaktif<span class=btn__next>›</span></a></div></div></main></div></body></html></div><div class=td-content style=page-break-before:always><h1 id=pg-352241d22effe0714772d21c7d1b512d>5.2.4.2 - Tutorial Interaktif - Mengekspos Aplikasimu</h1><!doctype html><html lang=id><body><link href=/docs/tutorials/kubernetes-basics/public/css/styles.css rel=stylesheet><link href=/docs/tutorials/kubernetes-basics/public/css/overrides.css rel=stylesheet><script src=https://katacoda.com/embed.js></script><div class=layout id=top><main class="content katacoda-content"><div class=katacoda><div class=katacoda__alert>Untuk berinteraksi dengan Terminal, harap gunakan desktop/tablet</div><div class=katacoda__box id=inline-terminal-1 data-katacoda-lang=id data-katacoda-id=kubernetes-bootcamp/8 data-katacoda-color=326de6 data-katacoda-secondary=273d6d data-katacoda-hideintro=false data-katacoda-prompt="Kubernetes Bootcamp Terminal" style=height:600px></div></div><div class=row><div class=col-md-12><a class="btn btn-lg btn-success" href=/id/docs/tutorials/kubernetes-basics/scale/scale-intro/ role=button>Lanjutkan ke Modul 5<span class=btn__next>›</span></a></div></div></main></div></body></html></div><div class=td-content style=page-break-before:always><h1 id=pg-be4996c93fb39c459a30b6669569d423>5.2.5 - Penyekalaan Aplikasimu</h1></div><div class=td-content><h1 id=pg-d1c15c9bd4f625adbc13149b1475287c>5.2.5.1 - Menjalankan Multipel Instans dari Aplikasimu</h1><!doctype html><html lang=id><body><link href=/docs/tutorials/kubernetes-basics/public/css/styles.css rel=stylesheet><div class=layout id=top><main class=content><div class=row><div class=col-md-8><h3>Tujuan</h3><ul><li>Penyekalaan aplikasi menggunakan kubectl.</li></ul></div><div class=col-md-8><h3>Penyekalaan sebuah Aplikasi</h3><p>Di modul-modul sebelumnya kita telah membuat <a href=/id/docs/concepts/workloads/controllers/deployment/>Deployment</a>, dan mengeksposnya secara publik via <a href=/id/docs/concepts/services-networking/service/>Service</a>. Deployment tersebut hanya membuat satu Pod untuk menjalankan aplikasi kita. Ketika kunjungan meningkat, kita perlu melakukan penyekalaan (<i>scale</i>) aplikasi kita untuk mengikuti tingkat permintaan pengguna.</p><p><b>Penyekalaan</b> dapat dicapai dengan mengubah nilai replicas dalam Deployment</p></div><div class=col-md-4><div class="content__box content__box_lined"><h3>Ringkasan:</h3><ul><li>Penyekalaan sebuah Deployment</li></ul></div><div class="content__box content__box_fill"><p><i>Kamu dapat membuat Deployment dengan beberapa instans sekaligus dari awal dengan menggunakan parameter --replicas pada perintah kubectl create deployment</i></p></div></div></div><br><div class=row><div class=col-md-8><h2 style=color:#3771e3>Ikhtisar Penyekalaan</h2></div></div><div class=row><div class=col-md-1></div><div class=col-md-8><div id=myCarousel class=carousel data-ride=carousel data-interval=3000><ol class=carousel-indicators><li data-target=#myCarousel data-slide-to=0 class=active></li><li data-target=#myCarousel data-slide-to=1></li></ol><div class=carousel-inner role=listbox><div class="item carousel-item active"><img src=/docs/tutorials/kubernetes-basics/public/images/module_05_scaling1.svg></div><div class="item carousel-item"><img src=/docs/tutorials/kubernetes-basics/public/images/module_05_scaling2.svg></div></div><a class="left carousel-control" href=#myCarousel role=button data-slide=prev><span class=sr-only>Sebelumnya</span></a>
<a class="right carousel-control" href=#myCarousel role=button data-slide=next><span class=sr-only>Selanjutnya</span></a></div></div></div><br><div class=row><div class=col-md-8><p>Perluasan skala Deployment akan memastikan Pod baru dibuat dan dijadwalkan ke Node-Node dengan sumber daya yang tersedia. Penyekalaan akan meningkatkan jumlah Pod ke keadaan yang diinginkan. Kubernetes juga mendukung <a href=/id/docs/tasks/run-application/horizontal-pod-autoscale/><i>autoscaling</i></a> Pod, tetapi itu di luar cakupan tutorial ini. Penyekalaan ke nol juga dimungkinkan, dan tindakan ini akan mengakhiri semua Pod pada Deployment tersebut.</p><p>Menjalankan beberapa instans dari aplikasi akan membutuhkan cara untuk mendistribusikan trafik ke semuanya. Service memiliki penyeimbang beban terintegrasi yang akan mendistribusikan trafik jaringan ke semua Pod dari sebuah Deployment yang diekspos. Service akan terus memonitor Pod-Pod yang berjalan menggunakan Endpoints, untuk memastikan trafik hanya dikirim ke Pod yang tersedia.</p></div><div class=col-md-4><div class="content__box content__box_fill"><p><i>Penyekalaan dapat dicapai dengan mengubah jumlah replicas pada sebuah Deployment.</i></p></div></div></div><br><div class=row><div class=col-md-8><p>Sewaktu kamu memiliki multipel instans dari aplikasi yang berjalan, kamu akan bisa melakukan pembaruan bertahap tanpa henti. Kita akan akan membahas hal tersebut pada modul selanjutnya. Sekarang, mari kita pergi ke terminal daring dan melakukan penyekalaan terhadap aplikasi kita.</p></div></div><br><div class=row><div class=col-md-12><a class="btn btn-lg btn-success" href=/id/docs/tutorials/kubernetes-basics/scale/scale-interactive/ role=button>Mulai Tutorial Interaktif <span class=btn__next>›</span></a></div></div></main></div></body></html></div><div class=td-content style=page-break-before:always><h1 id=pg-7bdb3fbaa1177ff5dfa3fe86bd35ef59>5.2.5.2 - Tutorial Interaktif - Penyekalaan Aplikasimu</h1><!doctype html><html lang=id><body><link href=/docs/tutorials/kubernetes-basics/public/css/styles.css rel=stylesheet><link href=/docs/tutorials/kubernetes-basics/public/css/overrides.css rel=stylesheet><script src=https://katacoda.com/embed.js></script><div class=layout id=top><main class="content katacoda-content"><div class=katacoda><div class=katacoda__alert>Untuk berinteraksi dengan Terminal, harap gunakan desktop/tablet</div><div class=katacoda__box id=inline-terminal-1 data-katacoda-lang=id data-katacoda-id=kubernetes-bootcamp/5 data-katacoda-color=326de6 data-katacoda-secondary=273d6d data-katacoda-hideintro=false data-katacoda-prompt="Kubernetes Bootcamp Terminal" style=height:600px></div></div><div class=row><div class=col-md-12><a class="btn btn-lg btn-success" href=/id/docs/tutorials/kubernetes-basics/update/update-intro/ role=button>Lanjutkan ke Modul 6<span class=btn__next>›</span></a></div></div></main><a class=scrolltop href=#top></a></div></body></html></div><div class=td-content style=page-break-before:always><h1 id=pg-62b8b17dadfb55f1801cf8439e944e58>5.2.6 - Memperbarui Aplikasimu</h1></div><div class=td-content><h1 id=pg-12e04355145afad615ca3c38335ba019>5.2.6.1 - Melakukan Pembaruan Bertahap</h1><!doctype html><html lang=id><body><link href=/docs/tutorials/kubernetes-basics/public/css/styles.css rel=stylesheet><div class=layout id=top><main class=content><div class=row><div class=col-md-8><h3>Tujuan</h3><ul><li>Melakukan pembaruan bertahap (<i>rolling update</i>) menggunakan kubectl.</li></ul></div><div class=col-md-8><h3>Memperbarui suatu aplikasi</h3><p>Pengguna mengharapkan aplikasi tersedia sepanjang waktu dan pengembang bisa jadi diharapkan untuk men-<i>deploy</i> versi terbaru dari aplikasi tersebut beberapa kali dalam suatu waktu. Di Kubernetes hal ini dilakukan melalui pembaruan bertahap. <b>Pembaruan bertahap</b> memungkinkan pembaruan Deployment terjadi tanpa berhenti dengan memperbarui instans Pod secara bertahap dengan versi yang baru. Pod yang baru akan dijadwalkan pada Node dengan sumber daya yang tersedia.</p><p>Dalam modul sebelumnya kita telah melakukan penyekalaan aplikasi kita untuk menjalankan beberapa instans. Hal ini dibutuhkan untuk menjalankan pembaruan tanpa mempengaruhi ketersediaan aplikasi. Secara bawaan, jumlah maksimum dari Pod lama yang akan digantikan (menjadi tidak tersedia) selama pembaruan dan jumlah maksimum Pod baru yang dapat dibuat adalah satu. Kedua opsi ini dapat dikonfigurasi dengan angka atau persentase (dari Pod). Di Kubernetes, setiap pembaruan diberi versi masing-masing dan suatu pembaruan Deployment dapat dikembalikan ke versi sebelumnya (yang stabil).</p></div><div class=col-md-4><div class="content__box content__box_lined"><h3>Ringkasan:</h3><ul><li>Memperbarui aplikasi</li></ul></div><div class="content__box content__box_fill"><p><i>Pembaruan bertahap memungkinkan pembaruan Deployment terjadi tanpa berhenti dengan memperbarui instans Pod secara bertahap dengan versi yang baru.</i></p></div></div></div><br><div class=row><div class=col-md-8><h2 style=color:#3771e3>Gambaran pembaruan bertahap</h2></div></div><div class=row><div class=col-md-1></div><div class=col-md-8><div id=myCarousel class=carousel data-ride=carousel data-interval=3000><ol class=carousel-indicators><li data-target=#myCarousel data-slide-to=0 class=active></li><li data-target=#myCarousel data-slide-to=1></li><li data-target=#myCarousel data-slide-to=2></li><li data-target=#myCarousel data-slide-to=3></li></ol><div class=carousel-inner role=listbox><div class="item carousel-item active"><img src=/docs/tutorials/kubernetes-basics/public/images/module_06_rollingupdates1.svg></div><div class="item carousel-item"><img src=/docs/tutorials/kubernetes-basics/public/images/module_06_rollingupdates2.svg></div><div class="item carousel-item"><img src=/docs/tutorials/kubernetes-basics/public/images/module_06_rollingupdates3.svg></div><div class="item carousel-item"><img src=/docs/tutorials/kubernetes-basics/public/images/module_06_rollingupdates4.svg></div></div><a class="left carousel-control" href=#myCarousel role=button data-slide=prev><span class=sr-only>Sebelumnya</span></a>
<a class="right carousel-control" href=#myCarousel role=button data-slide=next><span class=sr-only>Selanjutnya</span></a></div></div></div><br><div class=row><div class=col-md-8><p>Seperti penyekalaan aplikasi, jika suatu Deployment terekspos secara publik, maka Service akan menyeimbangkan beban trafik hanya ke Pod yang tersedia saat pembaruan berlangsung. Pod yang tersedia adalah instans yang dapat diakses oleh pengguna aplikasi.</p><p>Pembaruan bertahap memungkinan dilakukannya aktivitas-aktivitas berikut:</p><ul><li>Mempromosikan suatu aplikasi dari satu <i>environment</i> yang ke <i>environment</i> yang lain (via pembaruan kontainer <i>image</i>)</li><li>Kembali (<i>rollback</i>) ke versi-versi sebelumnya</li><li>Continuous Integration dan Continuous Delivery (CI/CD) dari aplikasi tanpa henti</li></ul></div><div class=col-md-4><div class="content__box content__box_fill"><p><i>Jika suatu Deployment terekspos secara publik, maka Service akan menyeimbangkan beban trafik hanya ke Pod yang tersedia saat pembaruan berlangsung.</i></p></div></div></div><br><div class=row><div class=col-md-8><p>Pada tutorial interaktif berikut ini, kita akan mencoba untuk memperbarui aplikasi kita ke versi terbaru dan kemudian melakukan <i>rollback</i>.</p></div></div><br><div class=row><div class=col-md-12><a class="btn btn-lg btn-success" href=/id/docs/tutorials/kubernetes-basics/update/update-interactive/ role=button>Mulai Tutorial Interaktif <span class=btn__next>›</span></a></div></div></main></div></body></html></div><div class=td-content style=page-break-before:always><h1 id=pg-dddc0cb356c280e0339bcf42776987dc>5.2.6.2 - Tutorial Interaktif - Memperbarui Aplikasimu</h1><!doctype html><html lang=id><body><link href=/docs/tutorials/kubernetes-basics/public/css/styles.css rel=stylesheet><link href=/docs/tutorials/kubernetes-basics/public/css/overrides.css rel=stylesheet><script src=https://katacoda.com/embed.js></script><div class=layout id=top><main class="content katacoda-content"><div class=katacoda><div class=katacoda__alert>Untuk berinteraksi dengan Terminal, silahkan gunakan versi desktop/tablet</div><div class=katacoda__box id=inline-terminal-1 data-katacoda-lang=id data-katacoda-id=kubernetes-bootcamp/6 data-katacoda-color=326de6 data-katacoda-secondary=273d6d data-katacoda-hideintro=false data-katacoda-prompt="Kubernetes Bootcamp Terminal" style=height:600px></div></div><div class=row><div class=col-md-12><a class="btn btn-lg btn-success" href=/docs/tutorials/kubernetes-basics/ role=button>Kembali Mempelajari Panduan Dasar Kubernetes<span class=btn__next>›</span></a></div></div></main></div></body></html></div><div class=td-content style=page-break-before:always><h1 id=pg-1efbbc2c3015389f835b1661d5effb29>5.3 - Aplikasi Stateless</h1></div><div class=td-content><h1 id=pg-62caf420877232190a7404b8d93c6724>5.3.1 - Mengekspos Alamat IP Eksternal untuk Mengakses Aplikasi di dalam Klaster</h1><p>Dokumen ini menjelaskan bagaimana cara membuat objek Service Kubernetes
yang mengekspos alamat IP eksternal.</p><h2 id=sebelum-kamu-memulai>Sebelum kamu memulai</h2><ul><li><p>Instal <a href=/id/docs/tasks/tools/install-kubectl/>kubectl</a>.</p></li><li><p>Gunakan sebuah penyedia layanan cloud seperti Google Kubernetes Engine atau Amazon Web Services
untuk membuat sebuah klaster Kubernetes. Tutorial ini membuat sebuah
<a href=/id/docs/tasks/access-application-cluster/create-external-load-balancer/><em>load balancer</em> eksternal</a>,
yang membutuhkan sebuah penyedia layanan cloud.</p></li><li><p>Konfigurasi <code>kubectl</code> agar dapat berkomunikasi dengan Kubernetes API Server kamu.
Untuk informasi lebih lanjut, kamu dapat merujuk pada dokumentasi penyedia layanan cloud
yang kamu gunakan.</p></li></ul><h2 id=tujuan>Tujuan</h2><ul><li>Jalankan lima buah instans dari aplikasi Hello World.</li><li>Buatlah sebuah objek Service yang mengekspos sebuah alamat IP eksternal.</li><li>Gunakan sebuah objek Service untuk mengakses aplikasi yang sedang dijalankan.</li></ul><h2 id=membuat-sebuah-objek-service-untuk-sebuah-aplikasi-yang-dijalankan-pada-lima-buah-pod>Membuat sebuah objek Service untuk sebuah aplikasi yang dijalankan pada lima buah Pod</h2><ol><li>Jalankan sebuah aplikasi Hello World pada klaster kamu:</li></ol><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/service/load-balancer-example.yaml download=service/load-balancer-example.yaml><code>service/load-balancer-example.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("service-load-balancer-example-yaml")' title="Copy service/load-balancer-example.yaml to clipboard"></img></div><div class=includecode id=service-load-balancer-example-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>load-balancer-example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello-world<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>load-balancer-example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>load-balancer-example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/google-samples/node-hello:1.0<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello-world<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/service/load-balancer-example.yaml
</span></span></code></pre></div><p>Perintah di atas akan membuat sebuah
objek <a href=/id/docs/concepts/workloads/controllers/deployment/>Deployment</a>
dan sebuah objek
<a href=/id/docs/concepts/workloads/controllers/replicaset/>ReplicaSet</a>
yang diasosiasikan dengan Deployment yang dibuat. ReplicaSet memiliki lima buah
<a href=/id/docs/concepts/workloads/pods/pod/>Pod</a>,
yang masing-masing dari Pod tersebut menjalankan aplikasi Hello World.</p><ol><li><p>Tampilkan informasi mengenai Deployment:</p><pre><code> kubectl get deployments hello-world
 kubectl describe deployments hello-world
</code></pre></li><li><p>Tampilkan informasi mengenai objek ReplicaSet:</p><pre><code> kubectl get replicasets
 kubectl describe replicasets
</code></pre></li><li><p>Buatlah sebuah objek Service yang mengekspos deployment:</p><pre><code> kubectl expose deployment hello-world --type=LoadBalancer --name=my-service
</code></pre></li><li><p>Tampilkan informasi mengenai Service:</p><pre><code> kubectl get services my-service
</code></pre><p>Keluaran dari perintah di atas akan menyerupai tampilan berikut:</p><pre><code> NAME         TYPE           CLUSTER-IP     EXTERNAL-IP      PORT(S)    AGE
 my-service   LoadBalancer   10.3.245.137   104.198.205.71   8080/TCP   54s
</code></pre><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Service dengan <code>type=LoadBalancer</code> didukung oleh penyedia layanan cloud eksternal, yang tidak tercakup dalam contoh ini, silahkan merujuk pada <a href=/id/docs/concepts/services-networking/service/#loadbalancer>laman berikut</a> untuk informasi lebih lanjut.</div><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Jika sebuah alamat IP eksternal yang ditunjukkan dalam status &lt;pending>, tunggulah hingga satu menit kemudian masukkan perintah yang sama lagi.</div></li><li><p>Tampilkan informasi detail mengenai Service:</p><pre><code> kubectl describe services my-service
</code></pre><p>Perintah di atas akan menampilkan keluaran sebagai berikut:</p><pre><code> Name:           my-service
 Namespace:      default
 Labels:         app.kubernetes.io/name=load-balancer-example
 Annotations:    &lt;none&gt;
 Selector:       app.kubernetes.io/name=load-balancer-example
 Type:           LoadBalancer
 IP:             10.3.245.137
 LoadBalancer Ingress:   104.198.205.71
 Port:           &lt;unset&gt; 8080/TCP
 NodePort:       &lt;unset&gt; 32377/TCP
 Endpoints:      10.0.0.6:8080,10.0.1.6:8080,10.0.1.7:8080 + 2 more...
 Session Affinity:   None
 Events:         &lt;none&gt;
</code></pre><p>Pastikan nilai dari alamat IP eksternal (<code>LoadBalancer Ingress</code>) diekspos
pada Service yang kamu buat. Pada contoh ini, alamat IP eksternal yang diberikan adalah 104.198.205.71.
Kemudian pastikan nilai dari <code>Port</code> dan <code>NodePort</code>. Pada contoh ini, <code>Port</code>
yang digunakan adalah 8080 dan <code>NodePort</code> adalah 32377.</p></li><li><p>Pada keluaran perintah sebelumnya, kamu dapat melihat beberapa Service dengan beberapa endpoint:
10.0.0.6:8080,10.0.1.6:8080,10.0.1.7:8080 + 2 lainnya. Berikut ini merupakan alamat IP dari Pod
dimana aplikasi tersebut dijalankan. Untuk melakukan verifikasi alamat-alamat IP yang digunakan oleh Pod,
masukkan perintah berikut:</p><pre><code> kubectl get pods --output=wide
</code></pre><p>Keluaran yang diberikan akan menyerupai:</p><pre><code> NAME                         ...  IP         NODE
 hello-world-2895499144-1jaz9 ...  10.0.1.6   gke-cluster-1-default-pool-e0b8d269-1afc
 hello-world-2895499144-2e5uh ...  10.0.1.8   gke-cluster-1-default-pool-e0b8d269-1afc
 hello-world-2895499144-9m4h1 ...  10.0.0.6   gke-cluster-1-default-pool-e0b8d269-5v7a
 hello-world-2895499144-o4z13 ...  10.0.1.7   gke-cluster-1-default-pool-e0b8d269-1afc
 hello-world-2895499144-segjf ...  10.0.2.5   gke-cluster-1-default-pool-e0b8d269-cpuc
</code></pre></li><li><p>Gunakan alamat IP eksternal (<code>LoadBalancer Ingress</code>) untuk mengakses aplikasi Hello World:</p><pre><code> curl http://&lt;external-ip&gt;:&lt;port&gt;
</code></pre><p>dimana <code>&lt;external-ip></code> adalah alamat IP eksternal (<code>LoadBalancer Ingress</code>)
dari Service kamu, dan <code>&lt;port></code> adalah nilai dari <code>Port</code> dari deskripsi Service kamu.
Jika kamu menggunakan minikube, menuliskan perintah <code>minikube service my-service</code> akan
secara otomatis membuka aplikasi Hello World pada <em>browser</em>.</p><p>Respons yang diberikan apabila permintaan ini berhasil adalah sebuah pesan sapaan:</p><pre><code> Hello Kubernetes!
</code></pre></li></ol><h2 id=bersihkan>Bersihkan</h2><p>Untuk menghapus Service, kamu dapat menggunakan perintah ini:</p><pre><code>kubectl delete services my-service
</code></pre><p>Untuk menghapus Deployment, ReplicaSet, dan Pod-Pod yang digunakan untuk
menjalankan aplikasi Hello World, kamu dapat memasukkan perintah berikut:</p><pre><code>kubectl delete deployment hello-world
</code></pre><h2 id=selanjutnya>Selanjutnya</h2><p>Pelajari lebih lanjut cara untuk
<a href=/id/docs/concepts/services-networking/connect-applications-service/>menghubungkan aplikasi dengan berbagai Service</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-d6336d9712aa433eb5f0fb8cbed6bef7>5.4 - Aplikasi Stateful</h1></div><div class=td-content><h1 id=pg-42e39658021b706bcc9478c8cc73c4a3>5.4.1 - Dasar-dasar StatefulSet</h1><p>Tutorial ini memberikan pengantar untuk manajemen aplikasi dengan
<a class=glossary-tooltip title='Melakukan proses manajemen deployment dan scaling dari sebuah set Pod, serta menjamin mekanisme ordering dan keunikan dari Pod ini.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/statefulset/ target=_blank aria-label=StatefulSet>StatefulSet</a>.
Di sini dicontohkan bagaimana cara untuk membuat, menghapus, melakukan penyekalaan,
dan memperbarui Pod dari StatefulSet.</p><h2 id=sebelum-kamu-memulai>Sebelum kamu memulai</h2><p>Sebelum memulai tutorial ini, kamu harus mengakrabkan dirimu dengan
konsep-konsep Kubernetes sebagai berikut:</p><ul><li><a href=/id/docs/concepts/workloads/pods/>Pod</a></li><li><a href=/id/docs/concepts/services-networking/dns-pod-service/>DNS klaster</a></li><li><a href=/id/docs/concepts/services-networking/service/#service-headless>Service <em>headless</em></a></li><li><a href=/id/docs/concepts/storage/persistent-volumes/>PersistentVolume</a></li><li><a href=https://github.com/kubernetes/examples/tree/main/staging/persistent-volume-provisioning/>Penyediaan PersistentVolume</a></li><li><a href=/id/docs/concepts/workloads/controllers/statefulset/>StatefulSet</a></li><li>Alat baris perintah (<em>command line tool</em>) <a href=/docs/reference/kubectl/kubectl/>kubectl</a></li></ul><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Tutorial ini mengasumsikan bahwa klastermu telah dikonfigurasikan untuk
melakukan penyediaan PersistentVolume secara dinamis. Jika klastermu belum
dikonfigurasikan seperti itu, kamu harus menyediakan dua volume masing-masing dengan
ukuran 1 GiB sebelum memulai tutorial.</div><h2 id=tujuan>Tujuan</h2><p>StatefulSet ditujukan untuk digunakan dengan aplikasi-aplikasi <em>stateful</em>
dan sistem terdistribusi. Akan tetapi, tata kelola aplikasi-aplikasi <em>stateful</em>
dan sistem terdistribusi pada Kubernetes merupakan topik yang luas dan kompleks.
Untuk menunjukkan fitur-fitur dasar dari StatefulSet dan tidak mencampuradukkan
topik sebelum dan terakhir, kamu akan menggelar sebuah aplikasi web sederhana
menggunakan StatefulSet.</p><p>Setelah tutorial ini, kamu akan akrab hal-hal berikut:</p><ul><li>Bagaimana cara membuat sebuah StatefulSet</li><li>Bagaimana suatu StatefulSet mengelola Pod</li><li>Bagaimana cara menghapus StatefulSet</li><li>Bagaimana cara melakukan penyekalaan terhadap suatu StatefulSet</li><li>Bagaimana cara memperbarui Pod dari StatefulSet</li></ul><h2 id=membuat-sebuah-statefulset>Membuat Sebuah StatefulSet</h2><p>Mulailah dengan membuat sebuah Statefulset dengan menggunakan contoh di bawah ini.
Hal ini mirip dengan contoh yang ditunjukkan di dalam konsep
<a href=/id/docs/concepts/workloads/controllers/statefulset/>StatefulSet</a>.
Contoh ini menciptakan sebuah
<a href=/id/docs/concepts/services-networking/service/#service-headless>Service <em>headless</em></a>,
<code>nginx</code>, untuk mempublikasikan alamat IP Pod di dalam StatefulSet, <code>web</code>.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/application/web/web.yaml download=application/web/web.yaml><code>application/web/web.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("application-web-web-yaml")' title="Copy application/web/web.yaml to clipboard"></img></div><div class=includecode id=application-web-web-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>web<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clusterIP</span>:<span style=color:#bbb> </span>None<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StatefulSet<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>web<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>serviceName</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;nginx&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/nginx-slim:0.8<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>web<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>www<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/usr/share/nginx/html<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeClaimTemplates</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>www<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;ReadWriteOnce&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>1Gi<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Unduh contoh di atas, dan simpan ke dalam berkas dengan nama <code>web.yaml</code>.</p><p>Kamu perlu menggunakan dua jendela terminal. Pada terminal yang pertama, gunakan perintah
<a href=/docs/reference/generated/kubectl/kubectl-commands/#get><code>kubectl get</code></a> untuk mengamati
pembuatan Pod dari StatefulSet.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -w -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx
</span></span></code></pre></div><p>Pada terminal yang kedua, gunakan
<a href=/docs/reference/generated/kubectl/kubectl-commands/#apply><code>kubectl apply</code></a> untuk membuat
Service <em>headless</em> dan StatefulSet yang didefinisikan di dalam <code>web.yaml</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f web.yaml
</span></span></code></pre></div><pre tabindex=0><code>service/nginx created
statefulset.apps/web created
</code></pre><p>Perintah di atas menciptakan dua Pod, masing-masing menjalankan server web
<a href=https://www.nginx.com>NGINX</a>. Dapatkan Service <code>nginx</code>...</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get service nginx
</span></span></code></pre></div><pre tabindex=0><code>NAME      TYPE         CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE
nginx     ClusterIP    None         &lt;none&gt;        80/TCP    12s
</code></pre><p>...kemudian dapatkan StatefulSet <code>web</code>, untuk memastikan keduanya berhasil dibuat:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get statefulset web
</span></span></code></pre></div><pre tabindex=0><code>NAME      DESIRED   CURRENT   AGE
web       2         1         20s
</code></pre><h3 id=pembuatan-pod-berurutan>Pembuatan Pod Berurutan</h3><p>Untuk StatefulSet dengan <em>n</em> replika, ketika Pod sedang digelar, kesemuanya
akan dibuat secara berurutan, terurut dari <em>{0..n-1}</em>. Periksa keluaran dari
perintah <code>kubectl get</code> pada terminal pertama. Pada akhirnya, keluaran yang dihasilkan
akan seperti contoh di bawah ini.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -w -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx
</span></span></code></pre></div><pre tabindex=0><code>NAME      READY     STATUS    RESTARTS   AGE
web-0     0/1       Pending   0          0s
web-0     0/1       Pending   0         0s
web-0     0/1       ContainerCreating   0         0s
web-0     1/1       Running   0         19s
web-1     0/1       Pending   0         0s
web-1     0/1       Pending   0         0s
web-1     0/1       ContainerCreating   0         0s
web-1     1/1       Running   0         18s
</code></pre><p>Perhatikan Pod <code>web-1</code> tidak dijalankan hingga <code>web-0</code> berganti status menjadi <em>Running</em>
(lihat <a href=/id/docs/concepts/workloads/pods/pod-lifecycle/#fase-pod>Fase Pod</a>) dan <em>Ready</em>
(lihat <code>type</code> di <a href=/id/docs/concepts/workloads/pods/pod-lifecycle/#kondisi-pod>Kondisi Pod</a>).</p><h2 id=pod-pada-statefulset>Pod pada StatefulSet</h2><p>Pod pada StatefulSet memiliki satu indeks urutan unik dan satu identitas jaringan yang tetap.</p><h3 id=memeriksa-indeks-urutan-pod>Memeriksa Indeks Urutan Pod</h3><p>Dapatkan Pod dari StatefulSet:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx
</span></span></code></pre></div><pre tabindex=0><code>NAME      READY     STATUS    RESTARTS   AGE
web-0     1/1       Running   0          1m
web-1     1/1       Running   0          1m
</code></pre><p>Sebagaimana telah disebutkan di dalam konsep
<a href=/id/docs/concepts/workloads/controllers/statefulset/>StatefulSet</a>,
Pod pada StatefulSet memiliki suatu identitas yang melekat (<em>sticky</em>) dan unik.
Identitas ini didasarkan pada sebuah indeks urutan yang unik yang di tetapkan
ke masing-masing Pod oleh <a class=glossary-tooltip title='Kontrol tertutup yang mengawasi kondisi bersama dari klaster melalui apiserver dan membuat perubahan yang mencoba untuk membawa kondisi saat ini ke kondisi yang diinginkan.' data-toggle=tooltip data-placement=top href=/id/docs/concepts/architecture/controller/ target=_blank aria-label=pengontrol>pengontrol</a> StatefulSet.
Nama Pod memiliki format <code>&lt;nama statefulset>-&lt;indeks urutan></code>.
Karena StatefulSet <code>web</code> memiliki dua replika, maka ada dua Pod yang tercipta, <code>web-0</code> dan <code>web-1</code>.</p><h3 id=menggunakan-identitas-jaringan-yang-tetap>Menggunakan Identitas Jaringan yang Tetap</h3><p>Setiap Pod memiliki nama hos yang tetep berdasarkan indeks urutannya. Gunakan perintah
<a href=/docs/reference/generated/kubectl/kubectl-commands/#exec><code>kubectl exec</code></a> untuk menjalankan
perintah <code>hostname</code> di tiap Pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f;font-weight:700>for</span> i in <span style=color:#666>0</span> 1; <span style=color:#a2f;font-weight:700>do</span> kubectl <span style=color:#a2f>exec</span> <span style=color:#b44>&#34;web-</span><span style=color:#b8860b>$i</span><span style=color:#b44>&#34;</span> -- sh -c <span style=color:#b44>&#39;hostname&#39;</span>; <span style=color:#a2f;font-weight:700>done</span>
</span></span></code></pre></div><pre tabindex=0><code>web-0
web-1
</code></pre><p>Gunakan perintah <a href=/docs/reference/generated/kubectl/kubectl-commands/#run><code>kubectl run</code></a> untuk
menjalankan sebuah Container yang menyediakan perintah <code>nslookup</code> dari paket <code>dnsutils</code>.
Dengan menjalankan perintah <code>nslookup</code> dengan nama hos dari Pod, kamu dapat memeriksa alamat
DNS mereka di dalam klaster:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl run -i --tty --image busybox:1.28 dns-test --restart<span style=color:#666>=</span>Never --rm
</span></span></code></pre></div><p>perintah itu akan memulai sebuah <em>shell</em> baru. Pada <em>shell</em> tersebut, jalankan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Jalankan ini di dalam shell Container dns-test</span>
</span></span><span style=display:flex><span>nslookup web-0.nginx
</span></span></code></pre></div><p>Keluarannya akan seperti:</p><pre tabindex=0><code>Server:    10.0.0.10
Address 1: 10.0.0.10 kube-dns.kube-system.svc.cluster.local

Name:      web-0.nginx
Address 1: 10.244.1.6

nslookup web-1.nginx
Server:    10.0.0.10
Address 1: 10.0.0.10 kube-dns.kube-system.svc.cluster.local

Name:      web-1.nginx
Address 1: 10.244.2.6
</code></pre><p>(dan selanjutnya keluarlah dari <em>shell</em> Container dengan menjalankan: <code>exit</code>)</p><p>CNAME dari <em>headless service</em> mengarah ke SRV <em>record</em> (satu untuk tiap Pod yang
Running dan Ready). SRC <em>record</em> mengarah ke entri A <em>record</em> yang memuat
alamat IP Pod.</p><p>Pada salah satu terminal, amati Pod dari StatefulSet:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod -w -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx
</span></span></code></pre></div><p>Pada terminal yang lain, gunakan perintah
<a href=/docs/reference/generated/kubectl/kubectl-commands/#delete><code>kubectl delete</code></a> untuk menghapus
semua Pod pada StatefulSet:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pod -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx
</span></span></code></pre></div><pre tabindex=0><code>pod &#34;web-0&#34; deleted
pod &#34;web-1&#34; deleted
</code></pre><p>Tunggu sampai StatefulSet menjalankan mereka kembali, dan untuk keduanya menjadi
Running dan Ready:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod -w -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx
</span></span></code></pre></div><pre tabindex=0><code>NAME      READY     STATUS              RESTARTS   AGE
web-0     0/1       ContainerCreating   0          0s
NAME      READY     STATUS    RESTARTS   AGE
web-0     1/1       Running   0          2s
web-1     0/1       Pending   0         0s
web-1     0/1       Pending   0         0s
web-1     0/1       ContainerCreating   0         0s
web-1     1/1       Running   0         34s
</code></pre><p>Gunakan perintah <code>kubectl exec</code> dan <code>kubectl run</code> untuk menampilkan nama hos Pod
dan entri DNS mereka dalam klaster. Pertama-tama, tampilkan nama hos Pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f;font-weight:700>for</span> i in <span style=color:#666>0</span> 1; <span style=color:#a2f;font-weight:700>do</span> kubectl <span style=color:#a2f>exec</span> web-<span style=color:#b8860b>$i</span> -- sh -c <span style=color:#b44>&#39;hostname&#39;</span>; <span style=color:#a2f;font-weight:700>done</span>
</span></span></code></pre></div><pre tabindex=0><code>web-0
web-1
</code></pre><p>selanjutnya, jalankan:</p><pre tabindex=0><code>kubectl run -i --tty --image busybox:1.28 dns-test --restart=Never --rm /bin/sh
</code></pre><p>perintah itu akan menjalankan <em>shell</em> baru.
Di dalam <em>shell</em> yang baru jalankan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Jalankan ini di dalam shell Container dns-test</span>
</span></span><span style=display:flex><span>nslookup web-0.nginx
</span></span></code></pre></div><p>Keluarannya akan seperti:</p><pre tabindex=0><code>Server:    10.0.0.10
Address 1: 10.0.0.10 kube-dns.kube-system.svc.cluster.local

Name:      web-0.nginx
Address 1: 10.244.1.7

nslookup web-1.nginx
Server:    10.0.0.10
Address 1: 10.0.0.10 kube-dns.kube-system.svc.cluster.local

Name:      web-1.nginx
Address 1: 10.244.2.8
</code></pre><p>(dan selanjutnya keluarlah dari <em>shell</em> Container dengan menjalankan: <code>exit</code>)</p><p>Urutan, nama hos, SRV <em>record</em>, dan nama A <em>record</em> dari Pod tidak berubah,
akan tetapi alamat IP yang terkait dengan Pod bisa jadi mengalami perubahan. Pada klaster
yang digunakan dalam tutorial ini terjadi perubahan. Karena itulah mengapa sangat penting
untuk menghindari pengaturan terhadap aplikasi lain yang terhubung ke Pod di dalam
StatefulSet menggunakan alamat IP.</p><p>Jika kamu ingin mencari dan terhubung dengan anggota aktif dari StatefulSet, kamu
perlu melakukan kueri CNAME dari Service <em>headless</em> (<code>nginx.default.svc.cluster.local</code>).
SRV <em>record</em> yang terkait dengan CNAME hanya akan memuat Pod dari StatefulSet yang
Running dan Ready.</p><p>Jika aplikasimu telah menerapkan logika koneksi yang menguji keaktifan
(<em>liveness</em>) dan kesiapan (<em>readiness</em>), kamu dapat menggunakan SRV <em>record</em> dari Pod (
<code>web-0.nginx.default.svc.cluster.local</code>,
<code>web-1.nginx.default.svc.cluster.local</code>), karena mereka tidak akan berubah, dan
aplikasimu akan bisa menemukan alamat-alamat Pod ketika mereka mengalami peralihan
ke Running dan Ready.</p><h3 id=menulis-ke-penyimpanan-tetap>Menulis ke Penyimpanan Tetap</h3><p>Dapatkan PersistentVolumeClaim untuk <code>web-0</code> dan <code>web-1</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pvc -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx
</span></span></code></pre></div><p>Keluarannya akan seperti:</p><pre tabindex=0><code>NAME        STATUS    VOLUME                                     CAPACITY   ACCESSMODES   AGE
www-web-0   Bound     pvc-15c268c7-b507-11e6-932f-42010a800002   1Gi        RWO           48s
www-web-1   Bound     pvc-15c79307-b507-11e6-932f-42010a800002   1Gi        RWO           48s
</code></pre><p>Pengontrol StatefulSet membuat dua
<a class=glossary-tooltip title='Mengklaim sumber daya penyimpanan yang didefinisikan di dalam suatu PersistentVolume, sehingga PersistentVolume tersebut dapat dipasang (mounted) sebagai sebuah volume pada suatu Container.' data-toggle=tooltip data-placement=top href=/id/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims target=_blank aria-label=PersistentVolumeClaim>PersistentVolumeClaim</a>
yang terikat ke dua
<a class=glossary-tooltip title='Sebuat objek API yang merepresentasikan bagian penyimpanan pada klaster. Tersedia sebagai sumber daya umum yang dapat dipasang (pluggable) yang tetap bertahan bahkan di luar siklus hidup suatu Pod.' data-toggle=tooltip data-placement=top href=/docs/concepts/storage/persistent-volumes/ target=_blank aria-label=PersistentVolume>PersistentVolume</a>.</p><p>Karena klaster yang digunakan dalam tutorial ini dikonfigurasi untuk melakukan penyediaan
PersistentVolume secara dinamis, maka PersistentVolume dibuat dan terikat secara otomatis.</p><p>Server web NGINX, secara bawaan, menyajikan berkas indeks dari
<code>/usr/share/nginx/html/index.html</code>. <em>Field</em> <code>volumeMounts</code> pada <code>spec</code> StatefulSet
memastikan direktori <code>/usr/share/nginx/html</code> didukung oleh sebuah PersistentVolume.</p><p>Tulis nama hos Pod ke dalam berkas <code>index.html</code> mereka masing-masing dan periksa
apakah server web NGINX menyajikan nama hos tersebut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f;font-weight:700>for</span> i in <span style=color:#666>0</span> 1; <span style=color:#a2f;font-weight:700>do</span> kubectl <span style=color:#a2f>exec</span> <span style=color:#b44>&#34;web-</span><span style=color:#b8860b>$i</span><span style=color:#b44>&#34;</span> -- sh -c <span style=color:#b44>&#39;echo &#34;$(hostname)&#34; &gt; /usr/share/nginx/html/index.html&#39;</span>; <span style=color:#a2f;font-weight:700>done</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>for</span> i in <span style=color:#666>0</span> 1; <span style=color:#a2f;font-weight:700>do</span> kubectl <span style=color:#a2f>exec</span> -i -t <span style=color:#b44>&#34;web-</span><span style=color:#b8860b>$i</span><span style=color:#b44>&#34;</span> -- curl http://localhost/; <span style=color:#a2f;font-weight:700>done</span>
</span></span></code></pre></div><pre tabindex=0><code>web-0
web-1
</code></pre><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong><p>Jika kamu melihat respon <strong>403 Forbidden</strong> untuk perintah curl di atas,
kamu perlu untuk memperbaiki izin (<em>permission</em>) dari direktori yang dipasang
oleh <code>volumeMounts</code> (disebabkan oleh sebuah
<a href=https://github.com/kubernetes/kubernetes/issues/2630><em>bug</em> ketika menggunakan volume hostPath</a>),
dengan menjalankan:</p><p><code>for i in 0 1; do kubectl exec web-$i -- chmod 755 /usr/share/nginx/html; done</code></p><p>sebelum mencoba kembali perintah <code>curl</code> di atas.</p></div><p>Di salah satu terminal, amati Pod dari StatefulSet:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod -w -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx
</span></span></code></pre></div><p>Di terminal yang lain, hapus semua Pod dari StatefulSet:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pod -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx
</span></span></code></pre></div><pre tabindex=0><code>pod &#34;web-0&#34; deleted
pod &#34;web-1&#34; deleted
</code></pre><p>Periksa keluaran dari perintah <code>kubectl get</code> pada terminal yang pertama dan tunggu
semua Pod berubah menjadi Running dan Ready.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod -w -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx
</span></span></code></pre></div><pre tabindex=0><code>NAME      READY     STATUS              RESTARTS   AGE
web-0     0/1       ContainerCreating   0          0s
NAME      READY     STATUS    RESTARTS   AGE
web-0     1/1       Running   0          2s
web-1     0/1       Pending   0         0s
web-1     0/1       Pending   0         0s
web-1     0/1       ContainerCreating   0         0s
web-1     1/1       Running   0         34s
</code></pre><p>Periksa apakah server web masih terus menyajikan nama hosnya:</p><pre tabindex=0><code>for i in 0 1; do kubectl exec -i -t &#34;web-$i&#34; -- curl http://localhost/; done
</code></pre><pre tabindex=0><code>web-0
web-1
</code></pre><p>Walaupun <code>web-0</code> dan <code>web-1</code> telah dijadwalkan ulang, mereka masih menyajikan
nama hos masing-masing karena PersistentVolume yang terkait dengan
PersistentVolumeClaim-nya dipasang kembali (<em>remounted</em>) ke setiap <code>volumeMounts</code>.
Di Node manapun <code>web-0</code> dan <code>web-1</code> dijadwalkan, PersistentVolume-nya akan
dipasangkan ke titik pasang (<em>mount point</em>) yang sesuai.</p><h2 id=penyekalaan-statefulset>Penyekalaan StatefulSet</h2><p>Melakukan penyekalaan pada StatefulSet berarti meningkatkan atau mengurangi jumlah
replika. Hal ini dicapai dengan memperbarui <em>field</em> <code>replicas</code>. Kamu dapat menggunakan
<a href=/docs/reference/generated/kubectl/kubectl-commands/#scale><code>kubectl scale</code></a> atau
<a href=/docs/reference/generated/kubectl/kubectl-commands/#patch><code>kubectl patch</code></a> untuk
melakukan penyekalaan terhadap StatefulSet.</p><h3 id=penyekalaan-naik>Penyekalaan Naik</h3><p>Pada salah satu jendela terminal, amati Pod pada StatefulSet:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -w -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx
</span></span></code></pre></div><p>Di jendela terminal yang lain gunakan perintah <code>kubectl scale</code> untuk melakukan
penyekalaan jumlah replika menjadi 5:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl scale sts web --replicas<span style=color:#666>=</span><span style=color:#666>5</span>
</span></span></code></pre></div><pre tabindex=0><code>statefulset.apps/web scaled
</code></pre><p>Periksa keluaran dari perintah <code>kubectl get</code> pada terminal pertama dan tunggu
tambahan tiga Pod yang baru berubah menjadi Running dan Ready.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -w -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx
</span></span></code></pre></div><pre tabindex=0><code>NAME      READY     STATUS    RESTARTS   AGE
web-0     1/1       Running   0          2h
web-1     1/1       Running   0          2h
NAME      READY     STATUS    RESTARTS   AGE
web-2     0/1       Pending   0          0s
web-2     0/1       Pending   0         0s
web-2     0/1       ContainerCreating   0         0s
web-2     1/1       Running   0         19s
web-3     0/1       Pending   0         0s
web-3     0/1       Pending   0         0s
web-3     0/1       ContainerCreating   0         0s
web-3     1/1       Running   0         18s
web-4     0/1       Pending   0         0s
web-4     0/1       Pending   0         0s
web-4     0/1       ContainerCreating   0         0s
web-4     1/1       Running   0         19s
</code></pre><p>Pengontrol StatefulSet telah melakukan penyekalaan terhadap jumlah replika.
Sama seperti <a href=#pembuatan-pod-dengan-urutan>pembuatan StatefulSet</a>, pengontrol
StatefulSet membuat tiap Pod berurutan sesuai dengan indeks urutan masing-masing
dan menunggu setiap Pod yang dibuat sebelumnya menjadi Running dan Ready sebelum
menjalankan Pod berikutnya.</p><h3 id=penyekalaan-turun>Penyekalaan Turun</h3><p>Di salah satu terminal, amati Pod pada StatefulSet:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -w -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx
</span></span></code></pre></div><p>Di terminal yang lain, gunakan perintah <code>kubectl patch</code> untuk melakukan penyekalaan
StatefulSet turun menjadi tiga replika:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl patch sts web -p <span style=color:#b44>&#39;{&#34;spec&#34;:{&#34;replicas&#34;:3}}&#39;</span>
</span></span></code></pre></div><pre tabindex=0><code>statefulset.apps/web patched
</code></pre><p>Tunggu hingga <code>web-4</code> dan <code>web-3</code> berubah menjadi Terminating.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -w -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx
</span></span></code></pre></div><pre tabindex=0><code>NAME      READY     STATUS              RESTARTS   AGE
web-0     1/1       Running             0          3h
web-1     1/1       Running             0          3h
web-2     1/1       Running             0          55s
web-3     1/1       Running             0          36s
web-4     0/1       ContainerCreating   0          18s
NAME      READY     STATUS    RESTARTS   AGE
web-4     1/1       Running   0          19s
web-4     1/1       Terminating   0         24s
web-4     1/1       Terminating   0         24s
web-3     1/1       Terminating   0         42s
web-3     1/1       Terminating   0         42s
</code></pre><h3 id=penghentian-pod-berurutan>Penghentian Pod Berurutan</h3><p>Pengontrol menghapus satu Pod dalam satu waktu, dengan urutan terbalik dari indeks
urutannya, dan setiap Pod akan ditunggu sampai benar-benar mati terlebih dahulu
sebelum menghapus Pod berikutnya.</p><p>Dapatkan PersistentVolumeClaim dari StatefulSet:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pvc -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx
</span></span></code></pre></div><pre tabindex=0><code>NAME        STATUS    VOLUME                                     CAPACITY   ACCESSMODES   AGE
www-web-0   Bound     pvc-15c268c7-b507-11e6-932f-42010a800002   1Gi        RWO           13h
www-web-1   Bound     pvc-15c79307-b507-11e6-932f-42010a800002   1Gi        RWO           13h
www-web-2   Bound     pvc-e1125b27-b508-11e6-932f-42010a800002   1Gi        RWO           13h
www-web-3   Bound     pvc-e1176df6-b508-11e6-932f-42010a800002   1Gi        RWO           13h
www-web-4   Bound     pvc-e11bb5f8-b508-11e6-932f-42010a800002   1Gi        RWO           13h
</code></pre><p>Di sana masih ada lima PersistentVolumeClaim dan lima PersistentVolume.
Ketika mengeksplorasi <a href=#menulis-ke-penyimpanan-tetap>penyimpanan tetap</a> pada Pod,
kita dapat melihat bahwa PersistentVolume yang terpasang pada Pod dari suatu StatefulSet
tidak terhapus ketika Pod-nya dihapus. Hal ini tetap berlaku ketika penghapusan Pod
terjadi karena penyekalaan turun pada suatu StatefulSet.</p><h2 id=memperbarui-statefulset>Memperbarui StatefulSet</h2><p>Di Kubernetes 1.7 dan yang lebih baru, pengontrol StatefulSet mendukung
pembaruan otomatis. Strategi yang digunakan ditentukan oleh <em>field</em>
<code>spec.updateStrategy</code> dari objek API StatefulSet. Fitur ini dapat digunakan untuk
memperbarui <em>image</em> Container, permintaan sumber daya dan/atau pembatasan, label,
dan anotasi Pod dalam suatu StatefulSet. Ada dua strategi pembaruan yang berlaku,
<code>RollingUpdate</code> dan <code>OnDelete</code>.</p><p>Pembaruan dengan <code>RollingUpdate</code> adalah strategi bawaan untuk StatefulSet.</p><h3 id=pembaruan-bertahap-rollingupdate>Pembaruan Bertahap (RollingUpdate)</h3><p>Pembaruan dengan strategi <code>RollingUpdate</code> akan memperbarui semua Pod di dalam
StatefulSet dalam urutan indeks terbalik, dengan tetap memperhatikan
jaminan dari StatefulSet.</p><p>Lakukan <em>patch</em> pada StatefulSet <code>web</code> dengan menerapkan <code>RollingUpdate</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl patch statefulset web -p <span style=color:#b44>&#39;{&#34;spec&#34;:{&#34;updateStrategy&#34;:{&#34;type&#34;:&#34;RollingUpdate&#34;}}}&#39;</span>
</span></span></code></pre></div><pre tabindex=0><code>statefulset.apps/web patched
</code></pre><p>Pada salah satu jendela terminal, <em>patch</em> StatefulSet <code>web</code> untuk mengubah
<em>image</em> Container lagi:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl patch statefulset web --type<span style=color:#666>=</span><span style=color:#b44>&#39;json&#39;</span> -p<span style=color:#666>=</span><span style=color:#b44>&#39;[{&#34;op&#34;: &#34;replace&#34;, &#34;path&#34;: &#34;/spec/template/spec/containers/0/image&#34;, &#34;value&#34;:&#34;gcr.io/google_containers/nginx-slim:0.8&#34;}]&#39;</span>
</span></span></code></pre></div><pre tabindex=0><code>statefulset.apps/web patched
</code></pre><p>Pada terminal yang lain, amati Pod pada StatefulSet:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx -w
</span></span></code></pre></div><p>Keluarannya akan seperti:</p><pre tabindex=0><code>NAME      READY     STATUS    RESTARTS   AGE
web-0     1/1       Running   0          7m
web-1     1/1       Running   0          7m
web-2     1/1       Running   0          8m
web-2     1/1       Terminating   0         8m
web-2     1/1       Terminating   0         8m
web-2     0/1       Terminating   0         8m
web-2     0/1       Terminating   0         8m
web-2     0/1       Terminating   0         8m
web-2     0/1       Terminating   0         8m
web-2     0/1       Pending   0         0s
web-2     0/1       Pending   0         0s
web-2     0/1       ContainerCreating   0         0s
web-2     1/1       Running   0         19s
web-1     1/1       Terminating   0         8m
web-1     0/1       Terminating   0         8m
web-1     0/1       Terminating   0         8m
web-1     0/1       Terminating   0         8m
web-1     0/1       Pending   0         0s
web-1     0/1       Pending   0         0s
web-1     0/1       ContainerCreating   0         0s
web-1     1/1       Running   0         6s
web-0     1/1       Terminating   0         7m
web-0     1/1       Terminating   0         7m
web-0     0/1       Terminating   0         7m
web-0     0/1       Terminating   0         7m
web-0     0/1       Terminating   0         7m
web-0     0/1       Terminating   0         7m
web-0     0/1       Pending   0         0s
web-0     0/1       Pending   0         0s
web-0     0/1       ContainerCreating   0         0s
web-0     1/1       Running   0         10s
</code></pre><p>Pod dalam StatefulSet diperbarui dengan urutan indeks terbalik. Pengontrol
StatefulSet mengakhiri setiap Pod, dan menunggunya beralih menjadi Running dan Ready
sebelum melakukan pembaruan ke Pod berikutnya. Sebagai catatan, walaupun pengontrol
StatefulSet tidak akan melanjutkan pembaruan terhadap Pod berikutnya hingga penggantinya
Running dan Ready, pengontrol akan memulihkan Pod apa pun yang mengalami kegagalan selama
proses pembaruan berlangsung.</p><p>Pod yang telah menerima pembaruan akan dipulihkan ke versi yang diperbarui, sedangkan
Pod yang belum menerima pembaruan akan dipulihkan ke versi sebelumnya. Dengan cara inilah
pengontrol mencoba untuk terus mempertahankan kesehatan aplikasi dan
pembaruan tetap konsisten ditengah adanya kemungkinan kegagalan intermiten.</p><p>Dapatkan Pod untuk melihat <em>image</em> Container-nya:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f;font-weight:700>for</span> p in <span style=color:#666>0</span> <span style=color:#666>1</span> 2; <span style=color:#a2f;font-weight:700>do</span> kubectl get pod <span style=color:#b44>&#34;web-</span><span style=color:#b8860b>$p</span><span style=color:#b44>&#34;</span> --template <span style=color:#b44>&#39;{{range $i, $c := .spec.containers}}{{$c.image}}{{end}}&#39;</span>; echo; <span style=color:#a2f;font-weight:700>done</span>
</span></span></code></pre></div><pre tabindex=0><code>k8s.gcr.io/nginx-slim:0.8
k8s.gcr.io/nginx-slim:0.8
k8s.gcr.io/nginx-slim:0.8
</code></pre><p>Semua Pod pada StatefulSet saat ini sedang menjalankan <em>image</em> Container sebelumnya.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Kamu juga bisa menggunakan perintah <code>kubectl rollout status sts/&lt;name></code>
untuk menampilkan status pembaruan bertahap terhadap sebuah StatefulSet</div><h4 id=pembaruan-dengan-staging>Pembaruan dengan <em>Staging</em></h4><p>Kamu dapat melakukan <em>staging</em> terhadap suatu pembaruan StatefulSet dengan
menggunakan parameter <code>partition</code> dari strategi pembaruan <code>RollingUpdate</code>. Suatu
pembaruan yang di-<em>staging</em> akan akan mempertahankan semua Pod dalam StatefulSet
tersebut pada versi yang digunakan saat ini sembari mengizinkan terjadinya
perubahan pada <code>.spec.template</code> dari StatefulSet.</p><p>Lakukan <em>patch</em> terhadap StatefulSet <code>web</code> untuk menambahkan partisi pada
<em>field</em> <code>updateStrategy</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl patch statefulset web -p <span style=color:#b44>&#39;{&#34;spec&#34;:{&#34;updateStrategy&#34;:{&#34;type&#34;:&#34;RollingUpdate&#34;,&#34;rollingUpdate&#34;:{&#34;partition&#34;:3}}}}&#39;</span>
</span></span></code></pre></div><pre tabindex=0><code>statefulset.apps/web patched
</code></pre><p>Lakukan <em>patch</em> terhadap StatefulSet lagi, untuk mengubah <em>image</em> Container:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl patch statefulset web --type<span style=color:#666>=</span><span style=color:#b44>&#39;json&#39;</span> -p<span style=color:#666>=</span><span style=color:#b44>&#39;[{&#34;op&#34;: &#34;replace&#34;, &#34;path&#34;: &#34;/spec/template/spec/containers/0/image&#34;, &#34;value&#34;:&#34;k8s.gcr.io/nginx-slim:0.7&#34;}]&#39;</span>
</span></span></code></pre></div><pre tabindex=0><code>statefulset.apps/web patched
</code></pre><p>Hapus sebuah Pod dari StatefulSet:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pod web-2
</span></span></code></pre></div><pre tabindex=0><code>pod &#34;web-2&#34; deleted
</code></pre><p>Tunggu hingga Pod menjadi Running dan Ready.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx -w
</span></span></code></pre></div><pre tabindex=0><code>NAME      READY     STATUS              RESTARTS   AGE
web-0     1/1       Running             0          4m
web-1     1/1       Running             0          4m
web-2     0/1       ContainerCreating   0          11s
web-2     1/1       Running   0         18s
</code></pre><p>Dapatkan <em>image</em> Container Pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod web-2 --template <span style=color:#b44>&#39;{{range $i, $c := .spec.containers}}{{$c.image}}{{end}}&#39;</span>
</span></span></code></pre></div><pre tabindex=0><code>k8s.gcr.io/nginx-slim:0.8
</code></pre><p>Perhatikan, walaupun strategi pembaruan yang digunakan adalah <code>RollingUpdate</code>,
StatefulSet mengembalikan Pod dengan Container-nya yang semula. Hal ini karena
urutan Pod kurang dari nilai <code>partition</code> yang ditetapkan pada <code>updateStrategy</code>.</p><h4 id=meluncurkan-canary>Meluncurkan <em>Canary</em></h4><p>Kamu dapat meluncurkan <em>canary</em> untuk mencoba suatu perubahan dengan mengurangi
<code>partition</code> yang kamu tentukan sebelumnya di <a href=#pembaruan-dengan-staging>atas</a>.</p><p>Lakukan <em>patch</em> terhadap StatefulSet untuk mengurangi jumlah partisi:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl patch statefulset web -p <span style=color:#b44>&#39;{&#34;spec&#34;:{&#34;updateStrategy&#34;:{&#34;type&#34;:&#34;RollingUpdate&#34;,&#34;rollingUpdate&#34;:{&#34;partition&#34;:2}}}}&#39;</span>
</span></span></code></pre></div><pre tabindex=0><code>statefulset.apps/web patched
</code></pre><p>Tunggu hingga <code>web-2</code> menjadi Running dan Ready.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx -w
</span></span></code></pre></div><pre tabindex=0><code>NAME      READY     STATUS              RESTARTS   AGE
web-0     1/1       Running             0          4m
web-1     1/1       Running             0          4m
web-2     0/1       ContainerCreating   0          11s
web-2     1/1       Running   0         18s
</code></pre><p>Dapatkan <em>image</em> Container Pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod web-2 --template <span style=color:#b44>&#39;{{range $i, $c := .spec.containers}}{{$c.image}}{{end}}&#39;</span>
</span></span></code></pre></div><pre tabindex=0><code>k8s.gcr.io/nginx-slim:0.7
</code></pre><p>Ketika kamu mengubah <code>partition</code>, pengontrol StatefulSet secara otomatis memperbarui Pod
<code>web-2</code> karena urutan dari Pod tersebut lebih besar dari atau sama dengan
nilai <code>partition</code>.</p><p>Hapus Pod <code>web-1</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pod web-1
</span></span></code></pre></div><pre tabindex=0><code>pod &#34;web-1&#34; deleted
</code></pre><p>Tunggu sampai Pod <code>web-1</code> menjadi Running dan Ready.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx -w
</span></span></code></pre></div><p>Keluarannya akan seperti:</p><pre tabindex=0><code>NAME      READY     STATUS        RESTARTS   AGE
web-0     1/1       Running       0          6m
web-1     0/1       Terminating   0          6m
web-2     1/1       Running       0          2m
web-1     0/1       Terminating   0         6m
web-1     0/1       Terminating   0         6m
web-1     0/1       Terminating   0         6m
web-1     0/1       Pending   0         0s
web-1     0/1       Pending   0         0s
web-1     0/1       ContainerCreating   0         0s
web-1     1/1       Running   0         18s
</code></pre><p>Dapatkan <em>image</em> Container dari Pod <code>web-1</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod web-1 --template <span style=color:#b44>&#39;{{range $i, $c := .spec.containers}}{{$c.image}}{{end}}&#39;</span>
</span></span></code></pre></div><pre tabindex=0><code>k8s.gcr.io/nginx-slim:0.8
</code></pre><p><code>web-1</code> dikembalikan ke konfigurasinya yang semula karena urutan Pod lebih kecil
dari partisi. Ketika partisi ditentukan, semua Pod dengan urutan yang lebih besar
dari atau sama dengan jumlah partisi akan diperbarui ketika <code>.spec.template</code> dari
StatefulSet diubah. Jika suatu Pod yang memiliki urutan lebih kecil dari partisi
dihapus atau diakhiri, Pod tersebut akan dikembalikan ke konfigurasinya yang semula.</p><h4 id=peluncuran-bertahap>Peluncuran Bertahap</h4><p>Kamu dapat melakukan peluncuran bertahap (misalkan peluncuran: linier, geometris, atau eksponensial)
dengan menggunakan pembaruan bertahap yang terpartisi dengan cara yang serupa
ketika kamu meluncurkan <a href=#meluncurkan-canary><em>canary</em></a>. Untuk melakukan peluncuran bertahap,
atur <code>partition</code> ke urutan di mana kamu menginginkan pengontrol untuk melakukan
pause terhadap pembaruan.</p><p>Saat ini partisi sedang di atur menjadi <code>2</code>. Ganti partisi menjadi <code>0</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl patch statefulset web -p <span style=color:#b44>&#39;{&#34;spec&#34;:{&#34;updateStrategy&#34;:{&#34;type&#34;:&#34;RollingUpdate&#34;,&#34;rollingUpdate&#34;:{&#34;partition&#34;:0}}}}&#39;</span>
</span></span></code></pre></div><pre tabindex=0><code>statefulset.apps/web patched
</code></pre><p>Tunggu semua Pod pada StatefulSet menjadi Running dan Ready.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx -w
</span></span></code></pre></div><p>Keluarannya akan seperti:</p><pre tabindex=0><code>NAME      READY     STATUS              RESTARTS   AGE
web-0     1/1       Running             0          3m
web-1     0/1       ContainerCreating   0          11s
web-2     1/1       Running             0          2m
web-1     1/1       Running   0         18s
web-0     1/1       Terminating   0         3m
web-0     1/1       Terminating   0         3m
web-0     0/1       Terminating   0         3m
web-0     0/1       Terminating   0         3m
web-0     0/1       Terminating   0         3m
web-0     0/1       Terminating   0         3m
web-0     0/1       Pending   0         0s
web-0     0/1       Pending   0         0s
web-0     0/1       ContainerCreating   0         0s
web-0     1/1       Running   0         3s
</code></pre><p>Dapatkan detail <em>image</em> Container dari Pod pada StatefulSet:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f;font-weight:700>for</span> p in <span style=color:#666>0</span> <span style=color:#666>1</span> 2; <span style=color:#a2f;font-weight:700>do</span> kubectl get pod <span style=color:#b44>&#34;web-</span><span style=color:#b8860b>$p</span><span style=color:#b44>&#34;</span> --template <span style=color:#b44>&#39;{{range $i, $c := .spec.containers}}{{$c.image}}{{end}}&#39;</span>; echo; <span style=color:#a2f;font-weight:700>done</span>
</span></span></code></pre></div><pre tabindex=0><code>k8s.gcr.io/nginx-slim:0.7
k8s.gcr.io/nginx-slim:0.7
k8s.gcr.io/nginx-slim:0.7
</code></pre><p>Dengan mengubah nilai <code>partition</code> menjadi <code>0</code>, kamu mengizinkan StatefulSet
untuk melanjutkan proses pembaruan.</p><h3 id=pembaruan-ondelete>Pembaruan OnDelete</h3><p>Strategi pembaruan <code>OnDelete</code> menerapkan mekanisme lama (versi 1.6 dan sebelumnya).
Ketika kamu memilih strategi pembaruan ini, pengontrol StatefulSet tidak akan secara
otomatis melakukan pembaruan terhadap Pod ketika suatu perubahan terjadi pada <em>field</em>
<code>.spec.template</code> pada StatefulSet. Strategi ini dapat dipilih dengan mengatur
<code>.spec.template.updateStrategy.type</code> menjadi <code>OnDelete</code>.</p><h2 id=menghapus-statefulset>Menghapus StatefulSet</h2><p>StatefulSet mendukung penghapusan tidak berjenjang (<em>non-cascading</em>) dan berjenjang (<em>cascading</em>).
Dalam penghapusan tidak berjenjang (<em>non-cascading delete</em>), Pod pada StatefulSet
tidak dihapus ketika StatefulSet terhapus. Pada penghapusan berjenjang (Cascading Delete),
StatefulSet bersama Pod-nya dihapus semua.</p><h3 id=penghapusan-tidak-berjenjang-non-cascading>Penghapusan Tidak Berjenjang (<em>Non-Cascading</em>)</h3><p>Pada salah satu jendela terminal, amati Pod pada StatefulSet.</p><pre tabindex=0><code>kubectl get pods -w -l app=nginx
</code></pre><p>Gunakan perintah <a href=/docs/reference/generated/kubectl/kubectl-commands/#delete><code>kubectl delete</code></a>
untuk menghapus StatefulSet. Pastikan kamu menambahkan parameter <code>--cascade=orphan</code> ke
perintah tersebut. Parameter ini memberitahukan Kubernetes untuk hanya menghapus StatefulSet
dan agar tidak menghapus Pod yang ada padanya.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete statefulset web --cascade<span style=color:#666>=</span>orphan
</span></span></code></pre></div><pre tabindex=0><code>statefulset.apps &#34;web&#34; deleted
</code></pre><p>Dapatkan Pod untuk melihat statusnya masing-masing:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx
</span></span></code></pre></div><pre tabindex=0><code>NAME      READY     STATUS    RESTARTS   AGE
web-0     1/1       Running   0          6m
web-1     1/1       Running   0          7m
web-2     1/1       Running   0          5m
</code></pre><p>Walaupun <code>web</code> telah dihapus, semua Pod masih Running dan Ready.
Hapus <code>web-0</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pod web-0
</span></span></code></pre></div><pre tabindex=0><code>pod &#34;web-0&#34; deleted
</code></pre><p>Dapatkan Pod dari StatefulSet:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx
</span></span></code></pre></div><pre tabindex=0><code>NAME      READY     STATUS    RESTARTS   AGE
web-1     1/1       Running   0          10m
web-2     1/1       Running   0          7m
</code></pre><p>Karena StatefulSet <code>web</code> telah dihapus, maka <code>web-0</code> tidak dijalankan lagi.</p><p>Di salah satu terminal, amati Pod pada StatefulSet.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -w -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx
</span></span></code></pre></div><p>Pada terminal yang lain, buat kembali StatefulSet. Perhatikan, terkecuali
jika kamu telah menghapus Service <code>ngingx</code> (yang seharusnya belum kamu lakukan),
kamu akan melihat sebuah galat yang mengindikasikan bahwa Service tersebut sudah ada.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f web.yaml
</span></span></code></pre></div><pre tabindex=0><code>statefulset.apps/web created
service/nginx unchanged
</code></pre><p>Abaikan galat yang terjadi. Hal itu hanya menunjukkan bahwa suatu upaya telah dilakukan
untuk membuat Service <em>headless</em> <code>nginx</code> walaupun Service tersebut sebenarnya sudah ada.</p><p>Perhatikan keluaran dari perintah <code>kubectl get</code> yang dijalankan pada terminal
yang pertama.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -w -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx
</span></span></code></pre></div><pre tabindex=0><code>NAME      READY     STATUS    RESTARTS   AGE
web-1     1/1       Running   0          16m
web-2     1/1       Running   0          2m
NAME      READY     STATUS    RESTARTS   AGE
web-0     0/1       Pending   0          0s
web-0     0/1       Pending   0         0s
web-0     0/1       ContainerCreating   0         0s
web-0     1/1       Running   0         18s
web-2     1/1       Terminating   0         3m
web-2     0/1       Terminating   0         3m
web-2     0/1       Terminating   0         3m
web-2     0/1       Terminating   0         3m
</code></pre><p>Ketika StatefulSet <code>web</code> dibuat ulang, yang dijalankan pertama kali adalah <code>web-0</code>.
Karena <code>web-1</code> telah menjadi Running dan Ready, ketika <code>web-0</code> berubah menjadi
Running dan Ready, <code>web-0</code> mengadopsi Pod tersebut. Karena kamu membuat ulang
StatefulSet dengan <code>replicas</code> sama dengan 2, ketika <code>web-0</code> selesai dibuat ulang, dan
ketika <code>web-1</code> telah ditetapkan menjadi Running dan Ready, maka <code>web-2</code> diakhiri.</p><p>Mari kita lihat kembali konten dari berkas <code>index.html</code> yang disajikan oleh server
web Pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f;font-weight:700>for</span> i in <span style=color:#666>0</span> 1; <span style=color:#a2f;font-weight:700>do</span> kubectl <span style=color:#a2f>exec</span> -i -t <span style=color:#b44>&#34;web-</span><span style=color:#b8860b>$i</span><span style=color:#b44>&#34;</span> -- curl http://localhost/; <span style=color:#a2f;font-weight:700>done</span>
</span></span></code></pre></div><pre tabindex=0><code>web-0
web-1
</code></pre><p>Walaupun kamu sebelumnya pernah menghapus StatefulSet dan Pod <code>web-0</code>, server web
masih terus menyajikan nama hos sebelumnya yang dimasukkan ke dalam berkas
<code>index.html</code>. Hal ini terjadi karena StatefulSet tidak menghapus PersistentVolume
yang terkait dengan Pod. Ketika kamu membuat ulang StatefulSet dan menjalankan
kembali <code>web-0</code>, PersistentVolume yang digunakan sebelumnya akan dipasang kembali.</p><h3 id=penghapusan-berjenjang-cascading>Penghapusan Berjenjang (Cascading)</h3><p>Pada salah satu jendela terminal, amati Pod pada StatefulSet.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -w -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx
</span></span></code></pre></div><p>Pada terminal yang lain, hapus StatefulSet lagi. Kali ini, hilangkan parameter
<code>--cascade=orphan</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete statefulset web
</span></span></code></pre></div><pre tabindex=0><code>statefulset.apps &#34;web&#34; deleted
</code></pre><p>Perhatikan keluaran dari perintah <code>kubectl get</code> yang dijalankan di terminal
yang pertama, dan tunggu semua status Pod berubah menjadi Terminating.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -w -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx
</span></span></code></pre></div><pre tabindex=0><code>NAME      READY     STATUS    RESTARTS   AGE
web-0     1/1       Running   0          11m
web-1     1/1       Running   0          27m
NAME      READY     STATUS        RESTARTS   AGE
web-0     1/1       Terminating   0          12m
web-1     1/1       Terminating   0         29m
web-0     0/1       Terminating   0         12m
web-0     0/1       Terminating   0         12m
web-0     0/1       Terminating   0         12m
web-1     0/1       Terminating   0         29m
web-1     0/1       Terminating   0         29m
web-1     0/1       Terminating   0         29m
</code></pre><p>Seperti yang telah kamu saksikan pada bagian <a href=#penyekalaan-turun>Penyekalaan Turun</a>,
Pod diakhiri satu demi satu dengan urutan terbalik dari indeks urutan mereka. Sebelum
mengakhiri suatu Pod, pengontrol StatefulSet menunggu Pod pengganti hingga benar-benar
berakhir.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Walaupun penghapusan berjenjang menghapus suatu StatefulSet bersama Pod yang ada,
penghapusan ini tidak menghapus Service <em>headless</em> yang terkait dengan StatefulSet.
Kamu hapus menghapus Service <code>nginx</code> secara manual.</div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete service nginx
</span></span></code></pre></div><pre tabindex=0><code>service &#34;nginx&#34; deleted
</code></pre><p>Buat ulang StatefulSet dan Service <em>headless</em> sekali lagi:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f web.yaml
</span></span></code></pre></div><pre tabindex=0><code>service/nginx created
statefulset.apps/web created
</code></pre><p>Saat semua Pod StatefulSet mengalami transisi ke Running dan Ready, dapatkan
konten dari berkas <code>index.html</code> masing-masing:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f;font-weight:700>for</span> i in <span style=color:#666>0</span> 1; <span style=color:#a2f;font-weight:700>do</span> kubectl <span style=color:#a2f>exec</span> -i -t <span style=color:#b44>&#34;web-</span><span style=color:#b8860b>$i</span><span style=color:#b44>&#34;</span> -- curl http://localhost/; <span style=color:#a2f;font-weight:700>done</span>
</span></span></code></pre></div><pre tabindex=0><code>web-0
web-1
</code></pre><p>Walaupun kamu telah menghapus StatefulSet dan semua Pod di dalamnya, Pod dibuat
lagi dengan PersistentVolume yang sama terpasang, dan <code>web-0</code> dan <code>web-1</code> masih
menyajikan nama hos masing-masing.</p><p>Akhirnya, hapus Service <code>nginx</code>...</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete service nginx
</span></span></code></pre></div><pre tabindex=0><code>service &#34;nginx&#34; deleted
</code></pre><p>...dan StatefulSet <code>web</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete statefulset web
</span></span></code></pre></div><pre tabindex=0><code>statefulset &#34;web&#34; deleted
</code></pre><h2 id=kebijakan-manajemen-pod>Kebijakan Manajemen Pod</h2><p>Untuk beberapa sistem terdistribusi, jaminan pengurutan StatefulSet tidak
penting dan/atau tidak diharapkan. Sistem-sistem tersebut hanya membutuhkan
keunikan dan identitas. Untuk mengatasi ini, pada Kubernetes 1.7, kami
memperkenalkan <code>.spec.podManagementPolicy</code> pada objek API StatefulSet.</p><h3 id=manajemen-pod-orderedready>Manajemen Pod OrderedReady</h3><p>Manajemen Pod <code>OrderedReady</code> adalah bawaan dari StatefulSet. Manajemen
dengan cara ini memberitahukan pengontrol StatefulSet untuk menghormati
jaminan pengurutan yang sudah ditunjukkan sebelumnya.</p><h3 id=manajemen-pod-parallel>Manajemen Pod Parallel</h3><p>Manajemen Pod <code>Parallel</code> memberitahukan pengontrol StatefulSet untuk
menjalankan atau mengakhiri semua Pod secara bersamaan (paralel), dan tidak menunggu
suatu Pod menjadi Running dan Ready atau benar-benar berakhir sebelum menjalankan atau
mengakhiri Pod yang lain.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/id/examples/application/web/web-parallel.yaml download=application/web/web-parallel.yaml><code>application/web/web-parallel.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("application-web-web-parallel-yaml")' title="Copy application/web/web-parallel.yaml to clipboard"></img></div><div class=includecode id=application-web-web-parallel-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>web<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clusterIP</span>:<span style=color:#bbb> </span>None<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StatefulSet<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>web<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>serviceName</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;nginx&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>podManagementPolicy</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Parallel&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/nginx-slim:0.8<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>web<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>www<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/usr/share/nginx/html<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeClaimTemplates</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>www<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;ReadWriteOnce&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>1Gi<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Unduh contoh di atas, dan simpan ke sebuah berkas dengan nama <code>web-parallel.yaml</code>.</p><p>Manifes ini serupa dengan yang telah kamu unduh sebelumnya kecuali <code>.spec.podManagementPolicy</code>
dari StatefulSet <code>web</code> diatur ke <code>Parallel</code>.</p><p>Di salah satu terminal, amati Pod pada StatefulSet.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx -w
</span></span></code></pre></div><p>Pada terminal yang lain, buat StatefulSet dan Service dari manifes tadi:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f web-parallel.yaml
</span></span></code></pre></div><pre tabindex=0><code>service/nginx created
statefulset.apps/web created
</code></pre><p>Perhatikan keluaran dari perintah <code>kubectl get</code> yang kamu jalankan pada
terminal yang pertama.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx -w
</span></span></code></pre></div><pre tabindex=0><code>NAME      READY     STATUS    RESTARTS   AGE
web-0     0/1       Pending   0          0s
web-0     0/1       Pending   0         0s
web-1     0/1       Pending   0         0s
web-1     0/1       Pending   0         0s
web-0     0/1       ContainerCreating   0         0s
web-1     0/1       ContainerCreating   0         0s
web-0     1/1       Running   0         10s
web-1     1/1       Running   0         10s
</code></pre><p>Pengontrol StatefulSet menjalankan <code>web-0</code> dan <code>web-</code> berbarengan.</p><p>Biarkan terminal kedua tetap terbuka, kemudian, di jendela terminal
yang lain lakukan penyekalaan terhadap StatefulSet:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl scale statefulset/web --replicas<span style=color:#666>=</span><span style=color:#666>4</span>
</span></span></code></pre></div><pre tabindex=0><code>statefulset.apps/web scaled
</code></pre><p>Perhatikan keluaran terminal di mana perintah <code>kubectl get</code> dijalankan.</p><pre tabindex=0><code>web-3     0/1       Pending   0         0s
web-3     0/1       Pending   0         0s
web-3     0/1       Pending   0         7s
web-3     0/1       ContainerCreating   0         7s
web-2     1/1       Running   0         10s
web-3     1/1       Running   0         26s
</code></pre><p>StatefulSet menjalankan dua Pod baru dan tidak menunggu Pod pertama
menjadi Running dan Ready terlebih dahulu sebelum menjalankan Pod
yang kedua.</p><h2 id=bersihkan>Bersihkan</h2><p>Kamu harus membuka dua terminal yang siap untuk menjalankan perintah <code>kubectl</code>
sebagai bagian dari pembersihan.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete sts web
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># sts adalah singkatan dari statefulset</span>
</span></span></code></pre></div><p>Kamu dapat mengamati <code>kubectl get</code> untuk melihat semua Pod yang sedang dihapus.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx -w
</span></span></code></pre></div><pre tabindex=0><code>web-3     1/1       Terminating   0         9m
web-2     1/1       Terminating   0         9m
web-3     1/1       Terminating   0         9m
web-2     1/1       Terminating   0         9m
web-1     1/1       Terminating   0         44m
web-0     1/1       Terminating   0         44m
web-0     0/1       Terminating   0         44m
web-3     0/1       Terminating   0         9m
web-2     0/1       Terminating   0         9m
web-1     0/1       Terminating   0         44m
web-0     0/1       Terminating   0         44m
web-2     0/1       Terminating   0         9m
web-2     0/1       Terminating   0         9m
web-2     0/1       Terminating   0         9m
web-1     0/1       Terminating   0         44m
web-1     0/1       Terminating   0         44m
web-1     0/1       Terminating   0         44m
web-0     0/1       Terminating   0         44m
web-0     0/1       Terminating   0         44m
web-0     0/1       Terminating   0         44m
web-3     0/1       Terminating   0         9m
web-3     0/1       Terminating   0         9m
web-3     0/1       Terminating   0         9m
</code></pre><p>Selama penghapusan, StatefulSet menghapus semua Pod secara serentak; tidak menghentikan
Pod berdasarkan urutan indeksnya terlebih dahulu sebelum menghapus Pod tersebut.</p><p>Tutup terminal di mana perintah <code>kubectl get</code> dijalankan dan hapus Service <code>nginx</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete svc nginx
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong><p>Kamu juga perlu menghapus media penyimpanan persisten untuk PersistentVolume
yang digunakan dalam tutorial ini.</p><p>Ikuti langkah-langkah yang dibutuhkan, berdasarkan lingkungan yang kamu gunakan,
konfigurasi penyimpanan, dan metode penyediaannya, untuk memastikan semua
penyimpanan dapat dimanfaatkan lagi.</p></div></div><div class=td-content style=page-break-before:always><h1 id=pg-b00a88a07ceb21b1a83e5822e0c86c1d>6 - Referensi</h1><p>Bagian dari dokumentasi Kubernetes ini berisi referensi-referensi.</p></div><div class=td-content><h1 id=pg-2b03679960950df772fb4fe7d78427b9>6.1 - Glosarium</h1></div><div class=td-content style=page-break-before:always><h1 id=pg-99b26586d8a33ec06996dcf7892a9683>6.2 - Mengakses API</h1></div><div class=td-content><h1 id=pg-954776b47f2d90515f375623a0ce98e1>6.2.1 - Menggunakan Otorisasi RBAC</h1><p><em>Role-based access control</em> (RBAC) atau kontrol akses berbasis rol adalah metode pengaturan akses ke sumber daya komputer
atau jaringan berdasarkan rol pengguna individu dalam organisasimu.</p><p>Otorisasi RBAC menggunakan <a class=glossary-tooltip title='Sekumpulan path terkait pada API Kubernetes.' data-toggle=tooltip data-placement=top href=/id/docs/concepts/overview/kubernetes-api/#api-groups target=_blank aria-label='grup API'>grup API</a> <code>rbac.authorization.k8s.io</code> untuk mengendalikan keputusan
otorisasi. Hal ini memungkinkanmu untuk mengonfigurasi kebijakan secara dinamis melalui
API Kubernetes.</p><p>Untuk mengaktifkan RBAC, jalankan <a class=glossary-tooltip title='Komponen control plane yang mengekspos API Kubernetes. Merupakan front-end dari control plane Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-apiserver/ target=_blank aria-label='server API'>server API</a> dengan <em>flag</em> <code>--authorization-mode</code> diatur
dengan daftar yang dipisahkan koma yang menyertakan <code>RBAC</code>;
sebagai contoh:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kube-apiserver --authorization-mode<span style=color:#666>=</span>Example,RBAC --other-options --more-options
</span></span></code></pre></div><h2 id=api-overview>Objek API</h2><p>API RBAC mendeklarasikan empat jenis objek Kubernetes: Role, ClusterRole,
RoleBinding dan ClusterRoleBinding. kamu bisa <a href=/id/docs/concepts/overview/working-with-objects/kubernetes-objects/#understanding-kubernetes-objects>mendeskripsikan beberapa objek</a>, atau mengubahnya menggunakan alat seperti <code>kubectl</code>, seperti objek Kubernetes lain.</p><div class="alert alert-warning caution callout" role=alert><strong>Perhatian:</strong> Objek-objek ini, dengan disengaja, memaksakan pembatasan akses. Jika kamu melakukan perubahan
ke klaster saat kamu belajar, lihat
<a href=#pencegahan-eskalasi-privilese-dan-bootstrapping>pencegahan eskalasi privilese dan <em>bootstrapping</em></a>
untuk memahami bagaimana pembatasan tersebut dapat mencegah kamu melakukan beberapa perubahan.</div><h3 id=role-dan-clusterrole>Role dan ClusterRole</h3><p>Sebuah Role RBAC atau ClusterRole memuat aturan yang mewakili sekumpulan izin.
Izin bersifat aditif (tidak ada aturan "tolak").</p><p>Sebuah Role selalu mengatur izin dalam <a class=glossary-tooltip title='Sebuah abstraksi yang digunakan oleh Kubernetes untuk mendukung multipel klaster virtual pada klaster fisik yang sama.' data-toggle=tooltip data-placement=top href=/id/docs/concepts/overview/working-with-objects/namespaces target=_blank aria-label=Namespace>Namespace</a> tertentu;
ketika kamu membuat Role, kamu harus menentukan Namespace tempat Role tersebut berada.</p><p>ClusterRole, sebaliknya, adalah sumber daya tanpa Namespace. Sumber daya tersebut memiliki nama yang berbeda (Role
dan ClusterRole) karena objek Kubernetes selalu harus menggunakan Namespace atau tanpa Namespace;
tidak mungkin keduanya.</p><p>ClusterRole memiliki beberapa kegunaan. Kamu bisa menggunakan ClusterRole untuk:</p><ol><li>mendefinisikan izin pada sumber daya dalam Namespace dan diberikan dalam sebuah Namespace atau lebih</li><li>mendefinisikan izin pada sumber daya dalam Namespace dan diberikan dalam seluruh Namespace</li><li>mendefinisikan izin pada sumber daya dalam lingkup klaster</li></ol><p>Jika kamu ingin mendefinisikan sebuah rol dalam Namespace, gunakan Role; jika kamu ingin mendefinisikan
rol di level klaster, gunakan ClusterRole.</p><h4 id=contoh-role>Contoh Role</h4><p>Berikut adalah contoh Role dalam Namespace bawaan yang dapat digunakan
untuk memberikan akses baca pada <a class=glossary-tooltip title='Unit Kubernetes yang paling sederhana dan kecil. Sebuah Pod merepresentasikan sebuah set kontainer yang dijalankan pada kluster kamu.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Role<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pod-reader<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb> </span><span style=color:#080;font-style:italic># &#34;&#34; mengindikasikan grup API inti</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;pods&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;get&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;watch&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;list&#34;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div><h4 id=contoh-clusterrole>Contoh ClusterRole</h4><p>ClusterRole dapat digunakan untuk memberikan izin yang sama dengan Role.
Karena ClusterRole memiliki lingkup klaster, kamu juga dapat menggunakannya untuk memberikan akses ke:</p><ul><li>sumber daya lingkup klaster (seperti <a class=glossary-tooltip title='A node is a worker machine in Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/nodes/ target=_blank aria-label=Node>Node</a>)</li><li>berbagai <em>endpoint</em> non-sumber daya (seperti <code>/healthz</code>)</li><li>sumber daya Namespace (seperti Pod), di semua Namespace
Sebagai contoh: kamu bisa menggunakan ClusterRole untuk memungkinkan pengguna tertentu untuk menjalankan
<code>kubectl get pods --all-namespaces</code>.</li></ul><p>Berikut adalah contoh ClusterRole yang dapat digunakan untuk memberikan akses baca pada
<a class=glossary-tooltip title='Stores sensitive information, such as passwords, OAuth tokens, and ssh keys.' data-toggle=tooltip data-placement=top href=/docs/concepts/configuration/secret/ target=_blank aria-label=Secret>Secret</a> di Namespace tertentu, atau di semua Namespace (tergantung bagaimana <a href=#rolebinding-dan-clusterrolebinding>keterikatannya</a>):</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># &#34;namespace&#34; dihilangkan karena ClusterRole tidak menggunakan Namespace</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-reader<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>  # di tingkat HTTP, nama sumber daya untuk mengakses objek Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>  # adalah &#34;secrets&#34;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;secrets&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;get&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;watch&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;list&#34;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div><p>Nama objek Role dan ClusterRole harus menggunakan <a href=/id/docs/concepts/overview/working-with-objects/names#path-segment-names>nama <em>path segment</em></a> yang valid.</p><h3 id=rolebinding-dan-clusterrolebinding>RoleBinding dan ClusterRoleBinding</h3><p>Sebuah RoleBinding memberikan izin yang ditentukan dalam sebuah Role kepada pengguna atau sekelompok pengguna.
Ini menyimpan daftar subjek (pengguna, grup, atau ServiceAccount), dan referensi ke
Role yang diberikan.
RoleBinding memberikan izin dalam Namespace tertentu sedangkan ClusterRoleBinding
memberikan akses tersebut pada lingkup klaster.</p><p>RoleBinding dapat merujuk Role apa pun di Namespace yang sama. Atau, RoleBinding
dapat mereferensikan ClusterRole dan memasangkan ClusterRole tersebut ke Namespace dari RoleBinding.
Jika kamu ingin memasangkan ClusterRole ke semua Namespace di dalam klastermu, kamu dapat menggunakan
ClusterRoleBinding.</p><p>Nama objek RoleBinding atau ClusterRoleBinding harus valid menggunakan
<a href=/id/docs/concepts/overview/working-with-objects/names#path-segment-names>nama <em>path segment</em></a> yang valid.</p><h4 id=contoh-rolebinding>Contoh RoleBinding</h4><p>Berikut adalah contoh dari RoleBinding yang memberikan Role "pod-reader" kepada pengguna "jane"
pada Namespace "default".
Ini memungkinkan "jane" untuk membaca Pod di Namespace "default".</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># RoleBinding memungkinkan &#34;jane&#34; untuk membaca Pod di Namespace &#34;default&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># Kamu harus sudah memiliki Role bernama &#34;pod-reader&#34; di Namespace tersebut.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>RoleBinding<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>read-pods<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># Kamu bisa mencantumkan lebih dari satu &#34;subjek&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>User<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>jane<span style=color:#bbb> </span><span style=color:#080;font-style:italic># &#34;name&#34; peka huruf besar-kecil</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>roleRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># &#34;roleRef&#34; menentukan pengikatan (binding) ke Role / ClusterRole</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Role<span style=color:#bbb> </span><span style=color:#080;font-style:italic># ini harus Role atau ClusterRole</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pod-reader<span style=color:#bbb> </span><span style=color:#080;font-style:italic># ini harus sesuai dengan nama Role atau ClusterRole yang ingin kamu gunakan</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></span></span></code></pre></div><p>RoleBinding juga bisa mereferensikan ClusterRole untuk memberikan izin yang didefinisikan di dalam
ClusterRole ke sumber daya di dalam Namespace RoleBinding. Referensi semacam ini
memungkinkan kamu menentukan sekumpulan Role yang umum di seluruh klastermu, lalu menggunakannya kembali di dalam
beberapa Namespace.</p><p>Sebagai contoh, meskipun RoleBinding berikut merujuk ke ClusterRole,
"dave" (subjek, peka kapital) hanya akan dapat membaca Secret di dalam Namespace "development",
karena Namespace RoleBinding (di dalam metadatanya) adalah "development".</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># RoleBinding memungkinkan &#34;dave&#34; untuk membaca Secret di Namespace &#34;development&#34;.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># Kamu sudah harus memiliki ClusterRole bernama &#34;secret-reader&#34;.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>RoleBinding<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>read-secrets<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># Namespace dari RoleBinding menentukan di mana izin akan diberikan.  </span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># Ini hanya memberikan izin di dalam Namespace &#34;development&#34;.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>development<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>User<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dave<span style=color:#bbb> </span><span style=color:#080;font-style:italic># Nama peka huruf besar-kecil</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>roleRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-reader<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></span></span></code></pre></div><h4 id=contoh-clusterrolebinding>Contoh ClusterRoleBinding</h4><p>Untuk memberikan izin di seluruh klaster, kamu dapat menggunakan ClusterRoleBinding.
ClusterRoleBinding berikut memungkinkan seluruh pengguna di dalam kelompok "manager" untuk
membaca Secret di berbagai Namespace.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># ClusterRoleBinding ini memungkinkan siapapun di dalam kelompok &#34;manager&#34; untuk membaca Secret di berbagai Namespace.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRoleBinding<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>read-secrets-global<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Group<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>manager<span style=color:#bbb> </span><span style=color:#080;font-style:italic># Nama peka kapital</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>roleRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-reader<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></span></span></code></pre></div><p>Setelah kamu membuat ClusterRoleBinding, kamu tidak dapat mengganti Role atau ClusterRole yang dirujuk.
Jika kamu mencoba mengganti <code>roleRef</code> dari sebuah ClusterRoleBinding, kamu akan mendapatkan galat validasi. Jika kamu
tidak ingin mengganti <code>roleRef</code> untuk sebuah ClusterRoleBinding, kamu harus menghapus objek ClusterRoleBinding tersebut dan membuat
sebuah pengganti.</p><p>Ada dua alasan untuk pembatasan tersebut:</p><ol><li><p>Membuat <code>roleRef</code> menjadi tidak dapat diubah (<em>immutable</em>) memungkinkan pemberian izin <code>update</code> kepada seseorang pada objek ClusterRoleBinding yang ada,
sehingga mereka dapat mengelola daftar subjek, tanpa bisa berubah
Role yang diberikan kepada subjek tersebut.</p></li><li><p>ClusterRoleBinding dengan Role yang berbeda adalah ClusterRoleBinding yang berbeda secara fundamental.
Mengharuskan sebuah ClusterRoleBinding untuk dihapus/diciptakan kembali untuk mengubah <code>roleRef</code> akan
memastikan daftar lengkap subjek dalam ClusterRoleBinding akan diberikan
Role baru (sebagai langkah untuk mencegah modifikasi secara tidak sengaja hanya pada <code>roleRef</code>
tanpa memastikan semua subjek yang seharusnya diberikan izin pada Role baru).</p></li></ol><p>Utilitas baris perintah <code>kubectl auth reconcile</code> membuat atau memperbarui berkas manifes yang mengandung objek RBAC,
dan menangani penghapusan dan pembuatan objek ikatan jika dibutuhkan untuk mengganti Role yang dirujuk.
Lihat <a href=#kubectl-auth-reconcile>penggunaan perintah dan contoh</a> untuk informasi tambahan.</p><h3 id=mengacu-pada-sumber-daya>Mengacu pada sumber daya</h3><p>Pada API Kubernetes, sebagian besar sumber daya diwakili dan diakses menggunakan representasi
nama objek, seperti <code>pods</code> untuk Pod. RBAC mengacu pada sumber daya yang menggunakan nama yang persis sama
dengan yang muncul di URL untuk berbagai <em>endpoint</em> API yang relevan.
Beberapa Kubernetes APIs melibatkan
<em>subresource</em>, seperti log untuk Pod. Permintaan untuk log Pod terlihat seperti:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=display:flex><span><span>GET /api/v1/namespaces/{namespace}/pods/{name}/log
</span></span></span></code></pre></div><p>Dalam hal ini, <code>pods</code> adalah sumber daya Namespace untuk sumber daya Pod, dan <code>log</code> adalah sebuah
sub-sumber daya <code>pods</code>. Untuk mewakili ini dalam sebuah Role RBAC, gunakan garis miring (<code>/</code>) untuk
membatasi sumber daya dan sub-sumber daya. Untuk memungkinkan subjek membaca <code>pods</code> dan
juga mengakses sub-sumber daya <code>log</code> untuk masing-masing Pod tersebut, kamu dapat menulis:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Role<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pod-and-pod-logs-reader<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;pods&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;pods/log&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;get&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;list&#34;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div><p>Kamu juga dapat merujuk ke sumber daya dengan nama untuk permintaan tertentu melalui daftar <code>resourceNames</code>.
Ketika nama dicantumkan, permintaan dapat dibatasi untuk setiap objek sumber daya.
Berikut adalah contoh yang membatasi subjeknya hanya untuk melakukan <code>get</code> atau <code>update</code> pada sebuah
<a class=glossary-tooltip title='Sebuah objek API yang digunakan untuk menyimpan data nonkonfidensial sebagai pasangan kunci-nilai (key-value). Pod dapat menggunakan ConfigMap sebagai variabel lingkungan, argumen baris perintah (command-line), atau berkas konfigurasi dalam sebuah volume.' data-toggle=tooltip data-placement=top href=/docs/concepts/configuration/configmap/ target=_blank aria-label=ConfigMap>ConfigMap</a> bernama <code>my-configmap</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Role<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>configmap-updater<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># pada level HTTP, nama sumber daya untuk mengakses objek ConfigMap</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># adalah &#34;configmaps&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;configmaps&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceNames</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;my-configmap&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;update&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;get&#34;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Kamu tidak dapat membatasi permintaan <code>create</code> atau <code>deletecollection</code> dengan nama sumber daya. Untuk <code>create</code>,
keterbatasan ini dikarenakan nama objek tidak diketahui pada waktu otorisasi.</div><h3 id=clusterrole-gabungan>ClusterRole gabungan</h3><p>Kamu dapat mengumpulkan beberapa ClusterRole menjadi satu ClusterRole gabungan.
Pengontrol, yang berjalan sebagai bagian dari <em>control plane</em> klaster, mengamati objek ClusterRole
dengan <code>aggregationRule</code>. <code>AggregationRule</code> mendefinisikan
<a class=glossary-tooltip title='Allows users to filter a list of resources based on labels.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/labels/ target=_blank aria-label=Selector>Selector</a> label yang digunakan oleh pengontrol untuk mencocokkan objek ClusterRole lain
yang harus digabungkan ke dalam <code>rules</code>.</p><p>Berikut adalah contoh ClusterRole gabungan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>monitoring<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>aggregationRule</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clusterRoleSelectors</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>rbac.example.com/aggregate-to-monitoring</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb> </span>[]<span style=color:#bbb> </span><span style=color:#080;font-style:italic># Control plane secara otomatis mengisi rules</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Jika kamu membuat ClusterRole baru yang cocok dengan label Selector dari ClusterRole gabungan yang ada,
maka perubahan itu akan memicu penambahan aturan baru ke dalam ClusterRole gabungan.
Berikut adalah contoh yang menambahkan aturan ke ClusterRole "monitoring", dengan membuat sebuah
ClusterRole lain berlabel <code>rbac.example.com/aggregate-to-monitoring: true</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>monitoring-endpoints<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rbac.example.com/aggregate-to-monitoring</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># ketika kamu membuat ClusterRole &#34;monitoring-endpoints&#34;,</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># aturan di bawah ini akan ditambahkan ke ClusterRole &#34;monitoring&#34;.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;services&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;endpoints&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;pods&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;get&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;list&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;watch&#34;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div><p><a href=#role-dan-rolebinding-bawaan>Role bawaan pengguna</a> menggunakan agregasi ClusterRole. Ini memungkinkan kamu,
sebagai administrator klaster, menambahkan aturan untuk sumber daya ubah suai, seperti yang dilayani oleh <a class=glossary-tooltip title='Kode khusus yang mendefinisikan sebuah sumber daya untuk ditambahkan ke server API Kubernetes-mu tanpa membangun server khusus tersendiri.' data-toggle=tooltip data-placement=top href=/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/ target=_blank aria-label=CustomResourceDefinitions>CustomResourceDefinitions</a>
atau server API gabungan, untuk memperluas Role bawaan.</p><p>Sebagai contoh: ClusterRole berikut mengizinkan Role bawaan "admin" dan "edit" mengelola sumber daya ubah suai
bernama CronTab, sedangkan Role "view" hanya dapat membaca sumber daya CronTab.
Kamu dapat mengasumsikan bahwa objek CronTab dinamai <code>"crontab"</code> dalam URL yang terlihat oleh server API.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>aggregate-cron-tabs-edit<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># Tambahkan izin berikut ke Role bawaan &#34;admin&#34; and &#34;edit&#34;.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rbac.authorization.k8s.io/aggregate-to-admin</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rbac.authorization.k8s.io/aggregate-to-edit</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;stable.example.com&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;crontabs&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;get&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;list&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;watch&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;create&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;update&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;patch&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;delete&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>aggregate-cron-tabs-view<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># Tambahkan izin berikut ke Role bawaan &#34;view&#34;    </span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rbac.authorization.k8s.io/aggregate-to-view</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;stable.example.com&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;crontabs&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;get&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;list&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;watch&#34;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div><h4 id=contoh-role-1>Contoh Role</h4><p>Contoh berikut adalah potongan dari objek Role atau ClusterRole yang hanya menampilkan
bagian <code>rules</code>.</p><p>Mengizinkan pembacaan sumber daya <code>"pods"</code> pada <a class=glossary-tooltip title='Sekumpulan path terkait pada API Kubernetes.' data-toggle=tooltip data-placement=top href=/id/docs/concepts/overview/kubernetes-api/#api-groups target=_blank aria-label='grup API'>grup API</a> inti:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># pada tingkat HTTP, nama dari sumber daya untuk mengakses objek Pod</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># adalah &#34;pods&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;pods&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;get&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;list&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;watch&#34;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div><p>Mengizinkan pembacaan/penulisan Deployment (pada tingkat HTTP: objek dengan <code>"deployments"</code>
di bagian sumber daya dari URL) pada masing-masing grup API <code>"extensions"</code> dan <code>"apps"</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;extensions&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;apps&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># pada tingkat HTTP, nama dari sumber daya untuk mengakses objek Deployment</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># adalah &#34;deployments&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;deployments&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;get&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;list&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;watch&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;create&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;update&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;patch&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;delete&#34;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div><p>Mengizinkan pembacaan pada Pods pada grup API inti, dan juga serta pembacaan atau penulisan Job
di grup API <code>"batch"</code> atau <code>"extensions"</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># pada tingkat HTTP, nama dari sumber daya untuk mengakses objek Pod</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># adalah &#34;pods&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;pods&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;get&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;list&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;watch&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;batch&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;extensions&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># pada tingkat HTTP, nama dari sumber daya untuk mengakses objek Job</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># adalah &#34;jobs&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;jobs&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;get&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;list&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;watch&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;create&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;update&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;patch&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;delete&#34;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div><p>Mengizinkan pembacaan ConfigMap bernama "my-config" (harus terikat dengan suatu
RoleBinding untuk membatasi ke satu ConfigMap di satu Namespace):</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># pada tingkat HTTP, nama dari sumber daya untuk mengakses objek ConfigMap</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># adalah &#34;configmaps&#34;  </span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;configmaps&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceNames</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;my-config&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;get&#34;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div><p>Mengizinkan pembacaan sumber daya <code>"nodes"</code> pada grup API inti (karena sebuah node
ada pada lingkup-klaster, ini harus berupa ClusterRole yang terikat dengan ClusterRoleBinding
agar efektif):</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># pada tingkat HTTP, nama dari sumber daya untuk mengakses objek Node</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># adalah &#34;nodes&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;nodes&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;get&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;list&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;watch&#34;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div><p>Mengizinkan permintaan GET dan POST kepada <em>endpoint</em> non-sumber daya <code>/healthz</code> dan seluruh <em>subpath</em>
(harus berada di dalam ClusterRole yang terikat dengan ClusterRoleBinding agar efektif):</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>nonResourceURLs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;/healthz&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;/healthz/*&#34;</span>]<span style=color:#bbb> </span><span style=color:#080;font-style:italic># &#39;*&#39; in a nonResourceURL is a suffix glob match</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;get&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;post&#34;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=mengacu-pada-subjek>Mengacu pada subjek</h3><p>RoleBinding atau ClusterRoleBinding mengikat sebuah Role ke subjek.
Subjek dapat berupa kelompok, pengguna atau <a class=glossary-tooltip title='Provides an identity for processes that run in a Pod.' data-toggle=tooltip data-placement=top href=/docs/tasks/configure-pod-container/configure-service-account/ target=_blank aria-label=ServiceAccounts>ServiceAccounts</a>.</p><p>Kubernetes merepresentasikan <em>username</em> sebagai <em>string</em>.
Ini bisa berupa: nama sederhana, seperti "alice"; email, seperti "bob@example.com";
atau ID pengguna numerik yang direpresentasikan sebagai <em>string</em>. Terserah kamu sebagai administrator klaster
untuk mengonfigurasi <a href=/docs/reference/access-authn-authz/authentication/>modul otentikasi</a>
sehingga otentikasi menghasilkan <em>username</em> dalam format yang kamu inginkan.</p><div class="alert alert-warning caution callout" role=alert><strong>Perhatian:</strong> Awalan <code>system:</code> direservasi untuk sistem Kubernetes, jadi kamu harus memastikan
bahwa kamu tidak memiliki pengguna atau grup dengan nama yang dimulai dengan <code>system:</code> secara tidak sengaja.
Selain prefiks khusus ini, sistem otorisasi RBAC tidak memerlukan format apa pun
untuk nama pengguna.</div><p>Di Kubernetes, modul otentikasi menyediakan informasi grup.
Grup, seperti halnya pengguna, direpresentasikan sebagai string, dan string tersebut tidak memiliki format tertentu,
selain prefiks <code>system:</code> yang sudah direservasi.</p><p><a href=/id/docs/tasks/configure-pod-container/configure-service-account/>ServiceAccount</a> memiliki nama yang diawali dengan <code>system:serviceaccount:</code>, dan menjadi milik grup yang diawali dengan nama <code>system:serviceaccounts:</code>.</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong><ul><li><code>system:serviceaccount:</code> (tunggal) adalah prefiks untuk <em>username</em> ServiceAccount.</li><li><code>system:serviceaccounts:</code> (jamak) adalah prefiks untuk grup ServiceAccount.</li></ul></div><h4 id=role-binding-examples>Contoh RoleBinding</h4><p>Contoh-contoh berikut ini hanya potongan RoleBinding yang hanya memperlihatkan
bagian <code>subjects</code>.</p><p>Untuk pengguna bernama <code>alice@example.com</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>User<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;alice@example.com&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></span></span></code></pre></div><p>Untuk grup bernama <code>frontend-admins</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Group<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;frontend-admins&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></span></span></code></pre></div><p>Untuk ServiceAccount bawaan di Namespace "kube-system":</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ServiceAccount<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span></span></span></code></pre></div><p>Untuk seluruh ServiceAccount di Namespace qa:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Group<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:serviceaccounts:qa<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></span></span></code></pre></div><p>Untuk seluruh ServiceAccount di Namespace apapun:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Group<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:serviceaccounts<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></span></span></code></pre></div><p>Untuk seluruh pengguna yang terotentikasi:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Group<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:authenticated<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></span></span></code></pre></div><p>Untuk seluruh pengguna yang tidak terotentikasi:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Group<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:unauthenticated<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></span></span></code></pre></div><p>Untuk seluruh pengguna:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Group<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:authenticated<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Group<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:unauthenticated<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=role-dan-rolebinding-bawaan>Role dan RoleBinding bawaan</h2><p>API membuat satu set objek ClusterRole dan ClusterRoleBinding bawaan.
Sebagian besar dari objek dengan prefiks <code>system:</code> menunjukkan bahwa sumber daya tersebut
secara langsung dikelola oleh <em>control plane</em> klaster. Seluruh ClusterRole dan ClusterRoleBinding dilabeli dengan
<code>kubernetes.io/bootstrapping=rbac-defaults</code>.</p><div class="alert alert-warning caution callout" role=alert><strong>Perhatian:</strong> Berhati-hatilah saat memodifikasi CLusterRole dan ClusterRoleBinding dengan nama yang
memiliki prefiks <code>system:</code>.
Modifikasi sumber daya ini dapat mengakibatkan malfungsi klaster.</div><h3 id=rekonsiliasi-otomatis>Rekonsiliasi otomatis</h3><p>Pada setiap penyalaan (<em>start-up</em>), server API memperbarui ClusterRole bawaan dengan berbagai izin yang hilang,
dan memperbarui ClusterRoleBinding bawaan dengan subjek yang hilang.
Ini memungkinkan klaster untuk memperbaiki modifikasi yang tidak disengaja, dan membantu menjaga Role
dan RoleBinding selalu terkini karena izin dan subjek berubah pada rilis terbaru Kubernetes.</p><p>Untuk menonaktifkan rekonsiliasi ini, atur anotasi <code>rbac.authorization.kubernetes.io/autoupdate</code>
pada ClusterRole bawaan atau RoleBinding bawaan menjadi <code>false</code>.
Ingat bahwa hilangnya izin dan subjek bawaan dapat mengakibatkan malfungsi klaster.</p><p>Rekonsiliasi otomatis diaktifkan secara bawaan jika pemberi otorisasi RBAC aktif.</p><h3 id=discovery-roles>Role diskoveri API</h3><p>RoleBinding bawaan memberi otorisasi kepada pengguna yang tidak terotentikasi untuk membaca informasi API yang dianggap aman
untuk diakses publik (termasuk CustomResourceDefinitions). Untuk menonaktifkan akses anonim, tambahkan <code>--anonymous-auth=false</code> ke konfigurasi server API.</p><p>Untuk melihat konfigurasi Role ini melalui <code>kubectl</code> jalankan perintah:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get clusterroles system:discovery -o yaml
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Jika kamu mengubah ClusterRole tersebut, maka perubahanmu akan ditimpa pada penyalaan ulang server API melalui
<a href=#auto-reconciliation>rekonsiliasi-otomatis</a>. Untuk menghindari penulisan ulang tersebut, hindari mengubah Role secara manual,
atau nonaktifkan rekonsiliasi otomatis</div><table><caption>Role diskoveri API Kubernetes RBAC</caption><col width=25%><col width=25%><col><tr><th>ClusterRole Bawaan</th><th>ClusterRoleBinding Bawaan</th><th>Deskripsi</th></tr><tr><td><b>system:basic-user</b></td><td>Grup <b>system:authenticated</b></td><td>Mengizinkan pengguna hanya dengan akses baca untuk mengakses informasi dasar tentang diri mereka sendiri. Sebelum v1.14, Role ini juga terikat pada <tt>system:unauthenticated</tt> secara bawaan.</td></tr><tr><td><b>system:discovery</b></td><td>Grup <b>system:authenticated</b></td><td>Mengizinkan akses baca pada berbagai <i>endpoint</i> diskoveri API yang dibutuhkan untuk menemukan dan melakukan negosiasi pada tingkat API. Sebelum v1.14, Role ini juga terikat pada <tt>system:unauthenticated</tt> secara bawaan.</td></tr><tr><td><b>system:public-info-viewer</b></td><td>Grup <b>system:authenticated</b> dan <b>system:unauthenticated</b></td><td>Mengizinkan akses baca pada informasi yang tidak sensitif tentang klaster. Diperkenalkan pada Kubernetes v1.14.</td></tr></table><h3 id=role-pengguna>Role pengguna</h3><p>Beberapa ClusterRole bawaan tidak diawali dengan <code>system:</code>. Ini dimaksudkan untuk Role pengguna.
Ini termasuk Role <em>super-user</em> (<code>cluster-admin</code>), Role yang dimaksudkan untuk diberikan akses seluruh klaster dengan
menggunakan ClusterRoleBinding, dan Role yang dimaksudkan untuk diberikan pada Namespace tertentu
dengan menggunakan RoleBinding (<code>admin</code>, <code>edit</code>, <code>view</code>).</p><p>ClusterRole menggunakan <a href=#clusterrole-gabungan>ClusterRole gabungan</a> untuk mengizinkan administrator untuk memasukan peraturan untuk sumber daya khusus pada ClusterRole ini. Untuk menambahkan aturan kepada Role <code>admin</code>, <code>edit</code>, atau <code>view</code>, buatlah sebuah CLusterRole
dengan satu atau lebih label berikut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rbac.authorization.k8s.io/aggregate-to-admin</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rbac.authorization.k8s.io/aggregate-to-edit</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rbac.authorization.k8s.io/aggregate-to-view</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><table><col width=25%><col width=25%><col><tr><th>ClusterRole Bawaan</th><th>ClusterRoleBinding Bawaan</th><th>Deskripsi</th></tr><tr><td><b>cluster-admin</b></td><td>Grup <b>system:masters</b></td><td>Mengizinkan akses <i>super-user</i> untuk melakukan berbagai aksi pada berbagai sumber daya.
Ketika digunakan pada <b>ClusterRoleBinding</b>, Role ini akan memberikan kendali penuh terhadap semua sumber daya pada klaster dan seluruh Namespace.
Ketika digunakan pada <b>RoleBinding</b>, Role ini akan memberikan kendali penuh terhadap setiap sumber daya pada Namespace RoleBinding, termasuk Namespace itu sendiri.</td></tr><tr><td><b>admin</b></td><td>Tidak ada</td><td>mengizinkan akses administrator, yang dimaksudkan untuk diberikan dalam sebuah Namespace menggunakan <b>RoleBinding</b>.
Jika digunakan dalam <b>RoleBinding</b>, ini memungkikan akses baca/tulis ke sebagian besar sumber daya di sebuah Namespace,
termasuk kemampuan untuk membuat Role dan RoleBinding dalam Namespace.
Role ini tidak memungkinkan akses tulis pada kuota sumber daya atau ke Namespace itu sendiri.</td></tr><tr><td><b>edit</b></td><td>Tidak ada</td><td>Mengizinkan akses baca/tulis pada seluruh objek dalam Namespace.<p>Role ini tidak memungkinkan untuk melihat dan mengubah Role dan RoleBinding.
Namun, Role ini memungkinkan untuk mengakses Secret dan menjalankan Pod seperti ServiceAccount dalam Namespace,
sehingga dapat digunakan untuk mendapatkan tingkat akses API dari setiap ServiceAccount di Namespace.</p></td></tr><tr><td><b>view</b></td><td>Tidak ada</td><td>Mengizinkan akses baca untuk melihat hampir seluruh objek dalam Namespace.<p>Ini tidak memungkinkan untuk melihat Role dan RoleBinding.</p><p>Role ini tidak memungkikan melihat Secret, karena pembacaan konten Secret memungkinkan
akses ke kredensial ServiceAccount dalam Namespace, yang akan memungkinkan akses API sebagai
ServiceAccount apapun di Namespace (bentuk eskalasi privilese).</p></td></tr></table><h3 id=role-komponen-inti>Role komponen inti</h3><table><col style=width:25%><col style=width:25%><col><thead><tr><th>ClusterRole Bawaan</th><th>ClusterRoleBinding Bawaan</th><th>Deskripsi</th></tr></thead><tbody><tr><td><b>system:kube-scheduler</b></td><td>Pengguna <b>system:kube-scheduler</b></td><td>Mengizinkan akses ke sumber daya yang dibutuhkan oleh komponen <a class=glossary-tooltip title='Komponen control plane yang bertugas mengamati Pod baru yang belum ditempatkan di node manapun dan kemudian memilihkan node di mana Pod baru tersebut akan dijalankan.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-scheduler/ target=_blank aria-label=kube-scheduler>kube-scheduler</a>.</td></tr><tr><td><b>system:volume-scheduler</b></td><td>Pengguna <b>system:kube-scheduler</b></td><td>Mengizinkan akses ke sumber daya volume yang dibutuhkan oleh komponen kube-scheduler.</td></tr><tr><td><b>system:kube-controller-manager</b></td><td>Pengguna <b>system:kube-controller-manager</b></td><td>Mengizinkan akses ke sumber daya yang dibutuhkan oleh komponen <a class=glossary-tooltip title='Komponen control plane yang menjalankan pengontrol.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-controller-manager/ target=_blank aria-label=kube-controller-manager>kube-controller-manager</a>.
Izin yang diperlukan oleh masing-masing pengontrol dirincikan di <a href=#controller-roles>Role pengontrol</a>.</td></tr><tr><td><b>system:node</b></td><td>Tidak ada</td><td>Mengizinkan akses ke sumber daya yang dibutuhkan oleh kubelet, <b>termasuk akses baca ke semua Secret, dan akses rulis ke semua objek status Pod</b>.<p>Kamu dapat menggunakan <a href=/docs/reference/access-authn-authz/node/>pemberi otorisasi Node</a> dan <a href=/docs/reference/access-authn-authz/admission-controllers/#noderestriction>pugasan admisi NodeRestriction</a> daripada Role <tt>system:node</tt>, dan mengizinkan pemberian akses API ke kubelet berdasarkan Pod yang dijadwalkan untuk berjalan di atasnya.</p><p>Role <tt>system:node</tt> hanya ada untuk kompatibilitas dengan klaster Kubernetes yang ditingkatkan dari versi sebelum v1.8.</p></td></tr><tr><td><b>system:node-proxier</b></td><td>Pengguna <b>system:kube-proxy</b></td><td>Mengizinkan akses ke sumber daya yang dibutuhkan oleh komponen <a class=glossary-tooltip title='kube-proxy merupakan proksi jaringan yang berjalan pada setiap node di dalam klaster.' data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-proxy/ target=_blank aria-label=kube-proxy>kube-proxy</a>.</td></tr></tbody></table><h3 id=role-komponen-lainnya>Role komponen lainnya</h3><table><col style=width:25%><col style=width:25%><col><thead><tr><th>ClusterRole Bawaan</th><th>ClusterRoleBinding Bawaan</th><th>Deskripsi</th></tr></thead><tbody><tr><td><b>system:auth-delegator</b></td><td>Tidak ada</td><td>Mengizinkan pemeriksaan otentikasi dan otorisasi yang didelegasikan.
Hal ini umumnya digunakan oleh pugasan server API untuk otentikasi dan otorisasi terpadu.</td></tr><tr><td><b>system:heapster</b></td><td>Tidak ada</td><td>Role untuk komponen <a href=https://github.com/kubernetes/heapster>Heapster</a> (usang).</td></tr><tr><td><b>system:kube-aggregator</b></td><td>Tidak ada</td><td>Role untuk komponen <a href=https://github.com/kubernetes/kube-aggregator>kube-aggregator</a>.</td></tr><tr><td><b>system:kube-dns</b></td><td>ServiceAccount <b>kube-dns</b> dalam Namespace <b>kube-system</b></td><td>Role untuk komponen <a href=/docs/concepts/services-networking/dns-pod-service/>kube-dns</a>.</td></tr><tr><td><b>system:kubelet-api-admin</b></td><td>Tidak ada</td><td>Mengizinkan akses penuh ke API kubelet.</td></tr><tr><td><b>system:node-bootstrapper</b></td><td>Tidak ada</td><td>Mengizinkan akses ke sumber daya yang dibutuhkan untuk melakukan <a href=/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/><i>bootstrapping</i> TLS kubelet</a>.</td></tr><tr><td><b>system:node-problem-detector</b></td><td>Tidak ada</td><td>Role untuk komponen <a href=https://github.com/kubernetes/node-problem-detector>node-problem-detector</a>.</td></tr><tr><td><b>system:persistent-volume-provisioner</b></td><td>Tidak ada</td><td>Mengizinkan akses ke sumber daya yang dibutuhkan oleh kebanyakan <a href=/id/docs/concepts/storage/persistent-volumes/#dinamis>penyedia volume dinamis</a>.</td></tr><tbody></table><h3 id=controller-roles>Role untuk pengontrol bawaan</h3><p><a class=glossary-tooltip title='Komponen control plane yang menjalankan pengontrol.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-controller-manager/ target=_blank aria-label=kube-controller-manager>kube-controller-manager</a>
pada Kubernetes menjalankan <a class=glossary-tooltip title='Kontrol tertutup yang mengawasi kondisi bersama dari klaster melalui apiserver dan membuat perubahan yang mencoba untuk membawa kondisi saat ini ke kondisi yang diinginkan.' data-toggle=tooltip data-placement=top href=/id/docs/concepts/architecture/controller/ target=_blank aria-label=pengontrol>pengontrol</a>
yang merupakan bawaan dari <em>control plane</em> Kubernetes. Ketika dijalankan dengan
<code>--use-service-account-credentials</code>, kube-controller-manager memulai setiap pengontrol
menggunakan ServiceAccount yang terpisah. Role yang sesuai tersedia untuk setiap
pengontrol bawaan, dengan prefiks <code>system:controller:</code>. Jika manajer pengontrol tidak
dimulai dengan <code>--use-service-account-credentials</code>, maka manajer pengontrol akan menjalankan
semua kontrol tertutup (<em>control loop</em>) menggunakan kredensialnya sendiri, yang harus
diberikan semua Role yang relevan. Role yang dimaksud termasuk:</p><ul><li><code>system:controller:attachdetach-controller</code></li><li><code>system:controller:certificate-controller</code></li><li><code>system:controller:clusterrole-aggregation-controller</code></li><li><code>system:controller:cronjob-controller</code></li><li><code>system:controller:daemon-set-controller</code></li><li><code>system:controller:deployment-controller</code></li><li><code>system:controller:disruption-controller</code></li><li><code>system:controller:endpoint-controller</code></li><li><code>system:controller:expand-controller</code></li><li><code>system:controller:generic-garbage-collector</code></li><li><code>system:controller:horizontal-pod-autoscaler</code></li><li><code>system:controller:job-controller</code></li><li><code>system:controller:namespace-controller</code></li><li><code>system:controller:node-controller</code></li><li><code>system:controller:persistent-volume-binder</code></li><li><code>system:controller:pod-garbage-collector</code></li><li><code>system:controller:pv-protection-controller</code></li><li><code>system:controller:pvc-protection-controller</code></li><li><code>system:controller:replicaset-controller</code></li><li><code>system:controller:replication-controller</code></li><li><code>system:controller:resourcequota-controller</code></li><li><code>system:controller:root-ca-cert-publisher</code></li><li><code>system:controller:route-controller</code></li><li><code>system:controller:service-account-controller</code></li><li><code>system:controller:service-controller</code></li><li><code>system:controller:statefulset-controller</code></li><li><code>system:controller:ttl-controller</code></li></ul><h2 id=pencegahan-eskalasi-privilese-dan-bootstrapping>Pencegahan eskalasi privilese dan <em>bootstrapping</em></h2><p>API RBAC mencegah pengguna dari mengeskalasikan privilese dengan mengubah Role atau RoleBinding.
Karena hal ini diberlakukan pada level API, maka hal ini berlaku bahkan ketika pemberi otorisasi
RBAC tidak digunakan.</p><h3 id=pembatasan-pada-pembuatan-dan-pembaruan-role>Pembatasan pada pembuatan dan pembaruan Role</h3><p>Kamu hanya bisa membuat/memperbaru suatu Role jika setidaknya satu dari beberapa
hal di bawah ini terpenuhi:</p><ol><li>Kamu telah mempunyai semua izin yang termuat dalam Role tersebut, pada lingkup yang sama
dengan objek yang diubah
(di seluruh klaster untuk sebuah ClusterRole, di dalam Namespace yang sama atau keseluruhan
klaster untuk sebuah Role).</li><li>Kamu diberikan izin eksplisit untuk melakukan <code>escalate</code> pada sumber daya <code>roles</code> atau
<code>clusterroles</code> di dalam grup API <code>rbac.authorization.k8s.io</code>.</li></ol><p>Sebagai contoh, jika <code>user-1</code> tidak memiliki kemampuan untuk mendaftar Secret di seluruh klaster,
maka <code>user-1</code> tidak akan bisa membuat suatu ClusterRole yang memuat izin tersebut. Agar pengguna
bisa membuat/memperbaru Role:</p><ol><li>Berikan sebuah Role yang memungkinkan mereka untuk membuat/memperbarui objek Role atau CLusterRole, sesuai keinginan.</li><li>Berikan mereka izin untuk menyertakan izin tertentu dalam Role yang mereka buat/perbarui:<ul><li>secara implisit, dengan memberikan mereka izin tersebut (jika mereka mencoba untuk membuat atau mengubah sebuah Role atau ClusterRole dengan izin yang tidak mereka miliki, permintaan API akan dilarang)</li><li>atau secara eksplisit mengizinkan penentuan izin apa pun dalam sebuah <code>Role</code> atau <code>ClusterRole</code> dengan memberikan mereka izin untuk melakukan <code>escalate</code> pada sumber daya <code>roles</code> atau <code>clusterroles</code> di dalam grup API <code>rbac.authorization.k8s.io</code></li></ul></li></ol><h3 id=pembatasan-pada-pembuatan-dan-pembaruan-rolebinding>Pembatasan pada pembuatan dan pembaruan RoleBinding</h3><p>Kamu hanya bisa membuat/memperbarui suatu RoleBinding jika kamu telah mempunyai semua izin yang
terdapat pada Role yang diacu (di dalam lingkup yang sama dengan RoleBinding) <em>atau</em> jika
kamu telah terotorisasi untuk melakukan <code>bind</code> pada role yang diacu.
Sebagai contoh, jika <code>user-1</code> tidak mempunyai kemampuan untuk mendaftar Secret di seluruh klaster,
maka <code>user-1</code> tidak akan bisa membuat sebuah ClusterRoleBinding dengan Role yang memberikan
izin tersebut. Agar pengguna bisa membuat/memperbarui RoleBinding:</p><ol><li>Berikan sebuah Role yang mengizinkan mereka untuk membuat/memperbarui objek RoleBinding atau ClusterRoleBinding, sesuai keinginan.</li><li>Berikan mereka izin yang dibutuhkan untuk RoleBinding tertentu:<ul><li>secara implisit, dengan memberikan mereka izin yang yang termuat pada Role yang dimaksud</li><li>secara eksplisit, dengan memberikan mereka izin untuk melakukan <code>bind</code> pada Role (atau ClusterRole) tertentu</li></ul></li></ol><p>Sebagai contoh, ClusterRole dan RoleBinding berikut akan memungkinkan <code>user-1</code> untuk memberikan Role <code>admin</code>, <code>edit</code>, dan <code>view</code> kepada pengguna lain di dalam Namespace <code>user-1-namespace</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>role-grantor<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;rbac.authorization.k8s.io&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;rolebindings&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;create&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;rbac.authorization.k8s.io&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;clusterroles&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;bind&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceNames</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;admin&#34;</span>,<span style=color:#b44>&#34;edit&#34;</span>,<span style=color:#b44>&#34;view&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>RoleBinding<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>role-grantor-binding<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>user-1-namespace<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>roleRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>role-grantor<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>User<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>user-1<span style=color:#bbb>
</span></span></span></code></pre></div><p>Ketika melakukan <em>bootstrapping</em> Role dan RoleBinding yang pertama, pengguna awal perlu memberikan
izin yang belum mereka miliki.
Untuk melakukan <em>bootstrapping</em> Role dan RoleBinding awal:</p><ul><li>Gunakan kredensial dengan grup "system:masters" yang terikat ke Role <em>super-user</em> "cluster-admin" oleh RoleBinding bawaan.</li><li>Jika server API dijalankan dengan porta tidak aman diaktifkan (<code>--insecure-port</code>), kamu juga bisa membuat panggilan API via porta tersebut, yang tidak memberlakukan otentikasi atau otorisasi.</li></ul><h2 id=utilitas-baris-perintah>Utilitas baris perintah</h2><h3 id=kubectl-create-role><code>kubectl create role</code></h3><p>Membuat sebuah objek Role yang mendefinisikan izin di dalam sebuah Namespace. Contoh:</p><ul><li><p>Membuat sebuah Role bernama "pod-reader" yang memungkinkan pengguna untuk melakukan <code>get</code>, <code>watch</code> dan <code>list</code> pada Pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create role pod-reader --verb<span style=color:#666>=</span>get --verb<span style=color:#666>=</span>list --verb<span style=color:#666>=</span>watch --resource<span style=color:#666>=</span>pods
</span></span></code></pre></div></li><li><p>Membuat sebuah Role bernama "pod-reader" dengan resourceNames yang ditentukan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create role pod-reader --verb<span style=color:#666>=</span>get --resource<span style=color:#666>=</span>pods --resource-name<span style=color:#666>=</span>readablepod --resource-name<span style=color:#666>=</span>anotherpod
</span></span></code></pre></div></li><li><p>Membuat sebuah Role bernama "foo" dengan apiGroups yang ditentukan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create role foo --verb<span style=color:#666>=</span>get,list,watch --resource<span style=color:#666>=</span>replicasets.apps
</span></span></code></pre></div></li><li><p>Membuat sebuah Role bernama "foo" dengan izin sub-sumber daya:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create role foo --verb<span style=color:#666>=</span>get,list,watch --resource<span style=color:#666>=</span>pods,pods/status
</span></span></code></pre></div></li><li><p>Membuat sebuah Role bernama "my-component-lease-holder" dengan izin untuk mendapatkan/memperbarui suatu sumber daya dengan nama tertentu:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create role my-component-lease-holder --verb<span style=color:#666>=</span>get,list,watch,update --resource<span style=color:#666>=</span>lease --resource-name<span style=color:#666>=</span>my-component
</span></span></code></pre></div></li></ul><h3 id=kubectl-create-clusterrole><code>kubectl create clusterrole</code></h3><p>Membuat sebuah ClusterRole. Contoh:</p><ul><li><p>Membuat sebuah ClusterRole bernama "pod-reader" yang memungkinkan pengguna untuk merlakukan <code>get</code>, <code>watch</code> dan <code>list</code> pada Pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create clusterrole pod-reader --verb<span style=color:#666>=</span>get,list,watch --resource<span style=color:#666>=</span>pods
</span></span></code></pre></div></li><li><p>Membuat sebuah ClusterRole bernama "pod-reader" dengan recourceNames yang ditentukan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create clusterrole pod-reader --verb<span style=color:#666>=</span>get --resource<span style=color:#666>=</span>pods --resource-name<span style=color:#666>=</span>readablepod --resource-name<span style=color:#666>=</span>anotherpod
</span></span></code></pre></div></li><li><p>Membuat sebuah ClusterRole bernama "foo" dengan apiGroups yang ditentukan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create clusterrole foo --verb<span style=color:#666>=</span>get,list,watch --resource<span style=color:#666>=</span>replicasets.apps
</span></span></code></pre></div></li><li><p>Membuat sebuah ClusterRole bernama "foo" dengan izin sub-sumber daya:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create clusterrole foo --verb<span style=color:#666>=</span>get,list,watch --resource<span style=color:#666>=</span>pods,pods/status
</span></span></code></pre></div></li><li><p>Membuat sebuah ClusterRole bernama "foo" dengan nonResourceURL yang ditentukan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create clusterrole <span style=color:#b44>&#34;foo&#34;</span> --verb<span style=color:#666>=</span>get --non-resource-url<span style=color:#666>=</span>/logs/*
</span></span></code></pre></div></li><li><p>Membuat sebuah ClusterRole bernama "monitoring" dengan aggregationRule yang ditentukan:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create clusterrole monitoring --aggregation-rule<span style=color:#666>=</span><span style=color:#b44>&#34;rbac.example.com/aggregate-to-monitoring=true&#34;</span>
</span></span></code></pre></div></li></ul><h3 id=kubectl-create-rolebinding><code>kubectl create rolebinding</code></h3><p>Memberikan sebuah Role atau ClusterRole di dalam Namespace tertentu. Contoh:</p><ul><li><p>Di dalam Namespace "acme", memberikan izin dalam ClusterRole "admin" kepada pengguna bernama "bob":</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create rolebinding bob-admin-binding --clusterrole<span style=color:#666>=</span>admin --user<span style=color:#666>=</span>bob --namespace<span style=color:#666>=</span>acme
</span></span></code></pre></div></li><li><p>Di dalam Namespace "acme", memberikan izin dalam ClusterRole "view" ke ServiceAccount di dalam Namespace "acme" yang bernama "myapp":</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create rolebinding myapp-view-binding --clusterrole<span style=color:#666>=</span>view --serviceaccount<span style=color:#666>=</span>acme:myapp --namespace<span style=color:#666>=</span>acme
</span></span></code></pre></div></li><li><p>Di dalam Namespace "acme", memberikan izin dalam ClusterRole "view" ke ServiceAccount di dalam Namespace "myappnamespace" yang bernama "myapp":</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create rolebinding myappnamespace-myapp-view-binding --clusterrole<span style=color:#666>=</span>view --serviceaccount<span style=color:#666>=</span>myappnamespace:myapp --namespace<span style=color:#666>=</span>acme
</span></span></code></pre></div></li></ul><h3 id=kubectl-create-clusterrolebinding><code>kubectl create clusterrolebinding</code></h3><p>Memberikan sebuah ClusterRole di seluruh klaster (semua Namespace). Contoh:</p><ul><li><p>Di seluruh klaster, memberikan izin dalam ClusterRole "cluster-admin" kepada pengguna bernama "root":</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create clusterrolebinding root-cluster-admin-binding --clusterrole<span style=color:#666>=</span>cluster-admin --user<span style=color:#666>=</span>root
</span></span></code></pre></div></li><li><p>Di seluruh klaster, memberikan izin dalam ClusterRole "system:node-proxier" kepada user bernama "system:kube-proxy":</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create clusterrolebinding kube-proxy-binding --clusterrole<span style=color:#666>=</span>system:node-proxier --user<span style=color:#666>=</span>system:kube-proxy
</span></span></code></pre></div></li><li><p>Di seluruh klaster, memberikan izin dalam ClusterRole "view" ke ServiceAccount bernama "myapp" di dalam Namespace "acme":</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create clusterrolebinding myapp-view-binding --clusterrole<span style=color:#666>=</span>view --serviceaccount<span style=color:#666>=</span>acme:myapp
</span></span></code></pre></div></li></ul><h3 id=kubectl-auth-reconcile><code>kubectl auth reconcile</code></h3><p>Membuat atau memperbarui objek API <code>rbac.authorization.k8s.io/v1</code> dari suatu berkas manifes.</p><p>Objek yang hilang dibuat, dan Namespace dibuat untuk objek dengan Namespace jika diperlukan.</p><p>Role yang sudah ada diperbarui untuk menyertakan izin pada objek masukan,
dan menghilangkan izin tambahan jika <code>--remove-extra-permissions</code> ditetapkan.</p><p>RoleBinding yang sudah ada diperbarui untuk menyertakan subjek pada objek masukan,
dan menghapus subjek tambahan jika <code>--remove-extra-subjects</code> ditetapkan.</p><p>Contoh:</p><ul><li><p>Mencoba menerapkan sebuah berkas manifes dari objek RBAC, menampilkan perubahan yang akan dibuat:</p><pre tabindex=0><code>kubectl auth reconcile -f my-rbac-rules.yaml --dry-run=client
</code></pre></li><li><p>Menerapkan sebuah berkas manifes dari objek RBAC, mempertahankan izin tambahan (dalam Role) dan subjek tambahan (dalam RoleBinding):</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl auth reconcile -f my-rbac-rules.yaml
</span></span></code></pre></div></li><li><p>Menerapkan sebuah berkas manifes dari objek RBAC, menghapus izin tambahan (dalam Role) dan subjek tambahan (dalam RoleBinding):</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl auth reconcile -f my-rbac-rules.yaml --remove-extra-subjects --remove-extra-permissions
</span></span></code></pre></div></li></ul><h2 id=service-account-permissions>Izin ServiceAccount</h2><p>Kebijakan RBAC bawaan memberikan izin terbatas ke komponen <em>control plane</em>, Node, dan pengontrol,
akan tetapi <em>tidak memberikan izin</em> ke ServiceAccount di luar Namespace <code>kube-system</code>
(di luar izin diskoveri yang diberikan kepada semua pengguna terotentikasi).</p><p>Hal ini memungkinkan kamu untuk memberika Role tertentu ke ServiceAccount tertentu sesuai
kebutuhan. RoleBinding yang sangat detail memberikan keamanan yang lebih baik,
akan tetapi membutuhkan lebih banyak usaha untuk pengaturannya. Pemberian izin
yang lebih luas dapat memberikan akses API yang tidak perlu (dan berpotensi tereskalasi)
ke ServiceAccount, akan tetapi pengaturannya lebih mudah.</p><p>Dalam urutan dari yang paling aman ke yang paling tidak aman, pendekatannya adalah:</p><ol><li><p>Memberikan sebuah Role ke ServiceAccount aplikasi tertentu (praktik terbaik)</p><p>Hal ini membutuhkan aplikasi untuk menentukan sebuah <code>serviceAccountName</code>
di dalam spesifikasi Pod-nya, dan untuk ServiceAccount yang akan dibuat (via
API, manifes aplikasi, <code>kubectl create serviceaccount</code>, dan lain-lain).</p><p>Sebagai contoh, untuk memberikan izin hanya baca (<em>read-only</em>) di dalam "my-namespace"
ke ServiceAccount "my-sa":</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create rolebinding my-sa-view <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --clusterrole<span style=color:#666>=</span>view <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --serviceaccount<span style=color:#666>=</span>my-namespace:my-sa <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --namespace<span style=color:#666>=</span>my-namespace
</span></span></code></pre></div></li><li><p>Memberikan sebuah Role ke ServiceAccount "default" di dalam suatu Namespace</p><p>Jika sebuah aplikasi tidak menetapkan <code>serviceAccountName</code>, aplikasi
tersebut akan menggunakan ServiceAccount "default".</p><div class="alert alert-info note callout" role=alert><strong>Catatan:</strong> Izin yang diberikan ke ServiceAccount "default" tersedia ke Pod apa pun di dalam
Namespace yang tidak menetapkan <code>serviceAccountName</code>.</div><p>Sebagai contoh, untuk memberikan izin hanya baca di dalam "my-namespace" ke ServiceAccount
"default":</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create rolebinding default-view <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --clusterrole<span style=color:#666>=</span>view <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --serviceaccount<span style=color:#666>=</span>my-namespace:default <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --namespace<span style=color:#666>=</span>my-namespace
</span></span></code></pre></div><p>Banyak <a href=/id/docs/concepts/cluster-administration/addons/>pugasan</a> berjalan sebagai
ServiceAccount "default" di dalam Namespace <code>kube-system</code>. Untuk mengizinkan pugasan
tersebut berjalan dengan akses <em>super-user</em>, berikan izin <code>cluster-admin</code> kepada
ServiceAccount "default" di dalam Namespace <code>kube-system</code>.</p><div class="alert alert-warning caution callout" role=alert><strong>Perhatian:</strong> Mengaktifkan ini berarti Namespace <code>kube-system</code> memuat Secret yang
memberikan akses <em>super-user</em> ke API klastermu.</div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create clusterrolebinding add-on-cluster-admin <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --clusterrole<span style=color:#666>=</span>cluster-admin <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --serviceaccount<span style=color:#666>=</span>kube-system:default
</span></span></code></pre></div></li><li><p>Memberikan Role ke semua ServiceAccount dalam suatu Namespace</p><p>Jika kamu ingin semua aplikasi di dalam satu Namespace untuk memiliki Role, apa pun
ServiceAccount yang digunakan, maka kamu dapat memberikan Role ke grup ServiceAccount
untuk Namespace tersebut.</p><p>Sebagai contoh, untuk memberikan izin hanya baca di dalam "my-namespace" ke semua
ServiceAccount di dalam Namespace tersebut:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create rolebinding serviceaccounts-view <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --clusterrole<span style=color:#666>=</span>view <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --group<span style=color:#666>=</span>system:serviceaccounts:my-namespace <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --namespace<span style=color:#666>=</span>my-namespace
</span></span></code></pre></div></li><li><p>Memberikan Role terbatas ke semua ServiceAccount di seluruh klaster (tidak disarankan)</p><p>Jika kamu tidak ingin untuk mengelola izin per Namespace, kamu bisa memberikan
Role yang berlaku di seluruh klaster kepada semua ServiceAccount.</p><p>Sebagai contoh, untuk memberikan akses hanya baca di semua Namespace untuk
semua ServiceAccount yang ada di klaster:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create clusterrolebinding serviceaccounts-view <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --clusterrole<span style=color:#666>=</span>view <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span> --group<span style=color:#666>=</span>system:serviceaccounts
</span></span></code></pre></div></li><li><p>Memberikan akses <em>super-user</em> ke semua ServiceAccount di seluruh klaster (sangat tidak disarankan)</p><p>Jika kamu tidak peduli untuk melakukan partisi terhadap izin sama sekali, maka kamu bisa
memberikan akses <em>super-user</em> ke semua ServiceAccount.</p><div class="alert alert-danger warning callout" role=alert><strong>Peringatan:</strong> Hal ini akan memberikan akses penuh untuk aplikasi apapun ke klastermu, dan juga
memberikan pengguna manapun dengan akses baca ke Secret (atau kemampuan untuk membuat
Pod apa pun) akses penuh ke klastermu.</div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create clusterrolebinding serviceaccounts-cluster-admin <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --clusterrole<span style=color:#666>=</span>cluster-admin <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --group<span style=color:#666>=</span>system:serviceaccounts
</span></span></code></pre></div></li></ol><h2 id=melakukan-peningkatan-dari-abac>Melakukan peningkatan dari ABAC</h2><p>Klaster yang awalnya menjalankan versi Kubernetes lawas sering kali menggunakan
kebijakan ABAC yang permisif, termasuk memberikan akses API penuh ke semua
ServiceAccount.</p><p>Kebijakan RBAC bawaan memberikan izin yang terbatas ke komponen <em>control plane</em>, Node,
dan pengontrol, akan tetapi <em>tidak memberikan izin</em> ke ServiceAccount di luar Namespace
<code>kube-system</code> (di luar izin diskoveri yang diberikan kepada semua pengguna terotentikasi).</p><p>Meskipun jauh lebih aman, hal ini dapat mengganggu beban kerja yang sudah ada yang
mengharapkan untuk menerima izin API secara otomatis.
Berikut adalah dua pendekatan untuk mengelola transisi ini:</p><h3 id=pemberi-otorisasi-paralel>Pemberi otorisasi paralel</h3><p>Jalankan pemberi otorisasi RBAC dan ABAC bersamaan, dan tentukan berkas kebijakan yang
memuat <a href=/docs/reference/access-authn-authz/abac/#policy-file-format>kebijakan ABAC lama</a>:</p><pre tabindex=0><code>--authorization-mode=...,RBAC,ABAC --authorization-policy-file=mypolicy.json
</code></pre><p>Untuk menjelaskan opsi baris perintah yang pertama secara detail: jika pemberi otorisasi
sebelumnya, seperti Node, menolak permintaan, maka pemberi otorisasi RBAC mencoba untuk
mengotorisasi permintaan API tersebut. Jika RBAC juga menolak permintaan API tersebut,
maka pemberi otorisasi ABAC akan dijalankan. Hal ini berarti permintaan apa pun yang
diizinkan oleh <em>salah satu</em> kebijakan RBAC atau ABAC akan diizinkan.</p><p>Ketika kube-apiserver dijalankan dengan level log 5 atau lebih tinggi untuk komponen
RBAC (<code>--vmodule=rbac*=5</code> atau <code>--v=5</code>), kamu dapat melihat penolakan RBAC di log
server API (dengan prefiks <code>RBAC</code>). Kamu dapat menggunakan informasi tersebut untuk
menentukan Role mana yang perlu diberikan ke pengguna, grup, atau ServiceAccount yang mana.</p><p>Jika kamu telah <a href=#service-account-permissions>memberikan Role ke ServiceAccount</a> dan
beban kerja sedang berjalan tanpa pesan penolakan RBAC dalam log server, maka kamu
dapat menghapus pemberi otorisasi ABAC.</p><h3 id=izin-rbac-permisif>Izin RBAC permisif</h3><p>Kamu dapat mereplikasi kebijakan ABAC yang permisif dengan menggunakan RoleBinding
RBAC.</p><div class="alert alert-danger warning callout" role=alert><strong>Peringatan:</strong><p>Kebijakan berikut mengizinkan <strong>SEMUA</strong> ServiceAccount bentindak sebagai administrator
klaster. Aplikasi apa pun yang berjalan di dalam Container akan menerima kredensial
ServiceAccount secara otomatis, dan dapat melakukan tindakan apa pun terhadap API,
termasuk menampilkan Secret dan mengubah izin. Hal ini bukan kebijakan
yang direkomendasikan.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create clusterrolebinding permissive-binding <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --clusterrole<span style=color:#666>=</span>cluster-admin <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --user<span style=color:#666>=</span>admin <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --user<span style=color:#666>=</span>kubelet <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --group<span style=color:#666>=</span>system:serviceaccounts
</span></span></code></pre></div></div><p>Setelah kamu beralih menggunakan RBAC, kamu harus menyesuaikan kontrol akses untuk
klastermu untuk memastikan bahwa kesemuanya memenuhi kebutuhanmu terkait keamanan
informasi.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-03460a7254c6c73eb2a1bb3dd7d25910>6.3 - Baris Perintah kubectl</h1></div><div class=td-content><h1 id=pg-8aba901ac13f124e5782b90ddb166ee2>6.3.1 - Contekan kubectl</h1><p>Lihat juga: <a href=/docs/reference/kubectl/overview/>Ikhitsar Kubectl</a> dan <a href=/docs/reference/kubectl/jsonpath>Panduan JsonPath</a>.</p><p>Laman ini merupakan ikhitisar dari perintah <code>kubectl</code>.</p><h1 id=kubectl-contekan>kubectl - Contekan</h1><h2 id=autocomplete-kubectl>Autocomplete Kubectl</h2><h3 id=bash>BASH</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#a2f>source</span> &lt;<span style=color:#666>(</span>kubectl completion bash<span style=color:#666>)</span> <span style=color:#080;font-style:italic># menyiapkan autocomplete untuk bash ke dalam shell saat ini, paket bash-completion harus diinstal terlebih dahulu.</span>
</span></span><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b44>&#34;source &lt;(kubectl completion bash)&#34;</span> &gt;&gt; ~/.bashrc <span style=color:#080;font-style:italic># menambahkan autocomplete secara permanen ke dalam bash shell kamu.</span>
</span></span></code></pre></div><p>Kamu juga dapat menggunakan alias singkatan untuk <code>kubectl</code> yang juga bisa berfungsi dengan <em>completion</em>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#a2f>alias</span> <span style=color:#b8860b>k</span><span style=color:#666>=</span>kubectl
</span></span><span style=display:flex><span><span style=color:#a2f>complete</span> -F __start_kubectl k
</span></span></code></pre></div><h3 id=zsh>ZSH</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#a2f>source</span> &lt;<span style=color:#666>(</span>kubectl completion zsh<span style=color:#666>)</span>  <span style=color:#080;font-style:italic># menyiapkan autocomplete untuk zsh ke dalam shell saat ini.</span>
</span></span><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b44>&#34;[[ </span><span style=color:#b8860b>$commands</span><span style=color:#b44>[kubectl] ]] &amp;&amp; source &lt;(kubectl completion zsh)&#34;</span> &gt;&gt; ~/.zshrc <span style=color:#080;font-style:italic># menambahkan autocomplete secara permanen ke dalam zsh shell kamu.</span>
</span></span></code></pre></div><h2 id=konteks-kubectl-dan-konfigurasinya>Konteks Kubectl dan Konfigurasinya</h2><p>Memilih klaster Kubernetes yang mana yang ditembak oleh <code>kubectl</code> untuk berkomunikasi dan
diubah konfigurasinya. Lihat dokumentasi <a href=/id/docs/tasks/access-application-cluster/configure-access-multiple-clusters/>Otentikasi ke berbagai Klaster dengan kubeconfig</a> untuk mengetahui informasi tentang berkas konfigurasi ini secara detail.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl config view <span style=color:#080;font-style:italic># memperlihatkan setelan kubeconfig yang sudah digabung (merged)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># menggunakan beberapa berkas kubeconfig sekaligus dan melihat semua konfigurasinya sekaligus (merged)</span>
</span></span><span style=display:flex><span><span style=color:#b8860b>KUBECONFIG</span><span style=color:#666>=</span>~/.kube/config:~/.kube/kubconfig2 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl config view
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># mendapatkan kata sandi untuk pengguna e2e</span>
</span></span><span style=display:flex><span>kubectl config view -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.users[?(@.name == &#34;e2e&#34;)].user.password}&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl config view -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.users[].name}&#39;</span>    <span style=color:#080;font-style:italic># memperlihatkan pengguna pertama</span>
</span></span><span style=display:flex><span>kubectl config view -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.users[*].name}&#39;</span>   <span style=color:#080;font-style:italic># mendapatkan daftar pengguna</span>
</span></span><span style=display:flex><span>kubectl config get-contexts                          <span style=color:#080;font-style:italic># memperlihatkan daftar konteks</span>
</span></span><span style=display:flex><span>kubectl config current-context                       <span style=color:#080;font-style:italic># memperlihatkan konteks saat ini</span>
</span></span><span style=display:flex><span>kubectl config use-context my-cluster-name           <span style=color:#080;font-style:italic># menyetel konteks bawaan menjadi my-cluster-name</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># menambahkan seorang pengguna baru ke dalam kubeconf kamu yang mendukung basic auth</span>
</span></span><span style=display:flex><span>kubectl config set-credentials kubeuser/foo.kubernetes.com --username<span style=color:#666>=</span>kubeuser --password<span style=color:#666>=</span>kubepassword
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># menyimpan Namespace secara permanen untuk semua perintah kubectl pada konteks tersebut</span>
</span></span><span style=display:flex><span>kubectl config set-context --current --namespace<span style=color:#666>=</span>ggckad-s2
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># menyetel konteks yang menggunakan pengguna dan namespace yang spesifik</span>
</span></span><span style=display:flex><span>kubectl config set-context gce --user<span style=color:#666>=</span>cluster-admin --namespace<span style=color:#666>=</span>foo <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  <span style=color:#666>&amp;&amp;</span> kubectl config use-context gce
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>kubectl config <span style=color:#a2f>unset</span> users.foo                       <span style=color:#080;font-style:italic># menghapus pengguna foo</span>
</span></span></code></pre></div><h2 id=menerapkan>Menerapkan</h2><p><code>apply</code> (menerapkan) mengelola aplikasi melalui berkas-berkas yang berisi definisi tentang sumber daya Kubernetes. Perintah ini membuat dan memperbarui
sumber daya di dalam sebuah klaster dengan menjalankan <code>kubectl apply</code>. Ini merupakan cara yang disarankan untuk mengelola aplikasi di dalam <em>production</em>.
Lihat <a href=https://kubectl.docs.kubernetes.io>Buku Kubectl</a>.</p><h2 id=membuat-objek>Membuat Objek</h2><p>Manifes Kubernetes dapat didefinisikan ke dalam YAML atau JSON. Gunakan berkas dengan ekstensi <code>.yaml</code>,
<code>.yml</code>, dan <code>.json</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl apply -f ./my-manifest.yaml            <span style=color:#080;font-style:italic># membuat sumber daya</span>
</span></span><span style=display:flex><span>kubectl apply -f ./my1.yaml -f ./my2.yaml      <span style=color:#080;font-style:italic># membuat sumber daya dari beberapa berkas</span>
</span></span><span style=display:flex><span>kubectl apply -f ./dir                         <span style=color:#080;font-style:italic># membuat sumber daya dari berbagai berkas manifes yang ada di dalam direktori</span>
</span></span><span style=display:flex><span>kubectl apply -f https://git.io/vPieo          <span style=color:#080;font-style:italic># membuat sumber daya dari sebuah tautan</span>
</span></span><span style=display:flex><span>kubectl create deployment nginx --image<span style=color:#666>=</span>nginx  <span style=color:#080;font-style:italic># memulai sebuah instans tunggal nginx</span>
</span></span><span style=display:flex><span>kubectl explain pods                           <span style=color:#080;font-style:italic># mendapatkan dokumentasi untuk manifes Pod</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># membuat beberapa objek YAML dari masukan (stdin)</span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF | kubectl apply -f -
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: Pod
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: busybox-sleep
</span></span></span><span style=display:flex><span><span style=color:#b44>spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>  containers:
</span></span></span><span style=display:flex><span><span style=color:#b44>  - name: busybox
</span></span></span><span style=display:flex><span><span style=color:#b44>    image: busybox
</span></span></span><span style=display:flex><span><span style=color:#b44>    args:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - sleep
</span></span></span><span style=display:flex><span><span style=color:#b44>    - &#34;1000000&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44>---
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: Pod
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: busybox-sleep-less
</span></span></span><span style=display:flex><span><span style=color:#b44>spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>  containers:
</span></span></span><span style=display:flex><span><span style=color:#b44>  - name: busybox
</span></span></span><span style=display:flex><span><span style=color:#b44>    image: busybox
</span></span></span><span style=display:flex><span><span style=color:#b44>    args:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - sleep
</span></span></span><span style=display:flex><span><span style=color:#b44>    - &#34;1000&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># membuat sebuah Secret dengan beberapa kunci (key)</span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF | kubectl apply -f -
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: Secret
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: mysecret
</span></span></span><span style=display:flex><span><span style=color:#b44>type: Opaque
</span></span></span><span style=display:flex><span><span style=color:#b44>data:
</span></span></span><span style=display:flex><span><span style=color:#b44>  password: $(echo -n &#34;s33msi4&#34; | base64 -w0)
</span></span></span><span style=display:flex><span><span style=color:#b44>  username: $(echo -n &#34;jane&#34; | base64 -w0)
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><h2 id=melihat-mencari-sumber-daya>Melihat, Mencari Sumber Daya</h2><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#080;font-style:italic># mendapatkan berbagai perintah dengan keluaran dasar</span>
</span></span><span style=display:flex><span>kubectl get services                          <span style=color:#080;font-style:italic># mendapatkan semua Service di dalam Namespace saat ini</span>
</span></span><span style=display:flex><span>kubectl get pods --all-namespaces             <span style=color:#080;font-style:italic># mendapatkan semua Pod di dalam semua Namespace</span>
</span></span><span style=display:flex><span>kubectl get pods -o wide                      <span style=color:#080;font-style:italic># mendapatkan semua Pod di dalam Namespace saat ini, dengan informasi tambahan</span>
</span></span><span style=display:flex><span>kubectl get deployment my-dep                 <span style=color:#080;font-style:italic># mendapatkan Deployment tertentu</span>
</span></span><span style=display:flex><span>kubectl get pods                              <span style=color:#080;font-style:italic># mendapatkan semua Pod di dalam Namespace saat ini</span>
</span></span><span style=display:flex><span>kubectl get pod my-pod -o yaml                <span style=color:#080;font-style:italic># mendapatkan spesifikasi YAML dari Pod tertentu</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># menggambarkan berbagai perintah dengan keluaran yang lengkap (verbose)</span>
</span></span><span style=display:flex><span>kubectl describe nodes my-node
</span></span><span style=display:flex><span>kubectl describe pods my-pod
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># mendapatkan semua Service yang diurutkan berdasar nama</span>
</span></span><span style=display:flex><span>kubectl get services --sort-by<span style=color:#666>=</span>.metadata.name
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># mendapatkan semua Pod yang diurut berdasarkan jumlah restart</span>
</span></span><span style=display:flex><span>kubectl get pods --sort-by<span style=color:#666>=</span><span style=color:#b44>&#39;.status.containerStatuses[0].restartCount&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># mendapatkan PersistentVolume yang diurut berdasarkan kapasitas</span>
</span></span><span style=display:flex><span>kubectl get pv --sort-by<span style=color:#666>=</span>.spec.capacity.storage
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># mendapatkan label versi dari semua Pod dengan label app=cassandra</span>
</span></span><span style=display:flex><span>kubectl get pods --selector<span style=color:#666>=</span><span style=color:#b8860b>app</span><span style=color:#666>=</span>cassandra -o <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.items[*].metadata.labels.version}&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># mendapatkan semua Node pekerja (worker) (selektor digunakan untuk tidak memasukkan</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Node yang memiliki label &#39;node-role.kubernetes.io/master&#39; ke dalam keluaran)</span>
</span></span><span style=display:flex><span>kubectl get node --selector<span style=color:#666>=</span><span style=color:#b44>&#39;!node-role.kubernetes.io/master&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># mendapatkan semua Pod yang sedang berjalan di dalam Namespace saat ini</span>
</span></span><span style=display:flex><span>kubectl get pods --field-selector<span style=color:#666>=</span>status.phase<span style=color:#666>=</span>Running
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># mendapatkan ExternalIP dari semua Node</span>
</span></span><span style=display:flex><span>kubectl get nodes -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.items[*].status.addresses[?(@.type==&#34;ExternalIP&#34;)].address}&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># mendapatkan nama dari semua Pod yang termasuk ke dalam RC tertentu</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># perintah &#34;jq&#34; berguna untuk mentransformasi keluaran yang terlalu rumit untuk diproses oleh jsonpath, lihat https://stedolan.github.io/jq/</span>
</span></span><span style=display:flex><span><span style=color:#b8860b>sel</span><span style=color:#666>=</span><span style=color:#b68;font-weight:700>${</span><span style=color:#a2f;font-weight:700>$(</span>kubectl get rc my-rc --output<span style=color:#666>=</span>json | jq -j <span style=color:#b44>&#39;.spec.selector | to_entries | .[] | &#34;\(.key)=\(.value),&#34;&#39;</span><span style=color:#a2f;font-weight:700>)</span>%?<span style=color:#b68;font-weight:700>}</span>
</span></span><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#a2f;font-weight:700>$(</span>kubectl get pods --selector<span style=color:#666>=</span><span style=color:#b8860b>$sel</span> --output<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>={</span>.items..metadata.name<span style=color:#666>}</span><span style=color:#a2f;font-weight:700>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># memperlihatkan label yang dimiliki semua Pod (atau objek Kubernetes lainnya yang mendukung label)</span>
</span></span><span style=display:flex><span>kubectl get pods --show-labels
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># memeriksa Node mana yang sudah dalam kondisi siap (ready)</span>
</span></span><span style=display:flex><span><span style=color:#b8860b>JSONPATH</span><span style=color:#666>=</span><span style=color:#b44>&#39;{range .items[*]}{@.metadata.name}:{range @.status.conditions[*]}{@.type}={@.status};{end}{end}&#39;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span> <span style=color:#666>&amp;&amp;</span> kubectl get nodes -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#34;</span><span style=color:#b8860b>$JSONPATH</span><span style=color:#b44>&#34;</span> | grep <span style=color:#b44>&#34;Ready=True&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># mendapatkan semua Secret yang sedang digunakan oleh Pod</span>
</span></span><span style=display:flex><span>kubectl get pods -o json | jq <span style=color:#b44>&#39;.items[].spec.containers[].env[]?.valueFrom.secretKeyRef.name&#39;</span> | grep -v null | sort | uniq
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># mendapatkan semua containerID dari initContainer yang ada di semua Pod,</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># berguna untuk membersihkan kontainer yang telah berhenti, tetapi menghindari terhapusnya initContainer</span>
</span></span><span style=display:flex><span>kubectl get pods --all-namespaces -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{range .items[*].status.initContainerStatuses[*]}{.containerID}{&#34;\n&#34;}{end}&#39;</span> | cut -d/ -f3
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># mendapatkan Event yang diurut berdasarkan cap waktu (timestamp)</span>
</span></span><span style=display:flex><span>kubectl get events --sort-by<span style=color:#666>=</span>.metadata.creationTimestamp
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># membandingkan antara keadaan saat ini dengan keadaan yang diinginkan pada klaster, jika manifes diterpakan</span>
</span></span><span style=display:flex><span>kubectl diff -f ./my-manifest.yaml
</span></span></code></pre></div><h2 id=memperbarui-sumber-daya>Memperbarui Sumber Daya</h2><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl <span style=color:#a2f>set</span> image deployment/frontend <span style=color:#b8860b>www</span><span style=color:#666>=</span>image:v2               <span style=color:#080;font-style:italic># memperbarui kontainer &#34;www&#34; secara bergilir dari sebuah Deployment &#34;frontend&#34;, memperbarui image-nya</span>
</span></span><span style=display:flex><span>kubectl rollout <span style=color:#a2f>history</span> deployment/frontend                      <span style=color:#080;font-style:italic># memeriksa sejarah (history) Deployment, termasuk revisinya</span>
</span></span><span style=display:flex><span>kubectl rollout undo deployment/frontend                         <span style=color:#080;font-style:italic># mengembalikan (rollback) ke Deployment sebelumnya</span>
</span></span><span style=display:flex><span>kubectl rollout undo deployment/frontend --to-revision<span style=color:#666>=</span><span style=color:#666>2</span>         <span style=color:#080;font-style:italic># mengembalikan (rollback) ke revisi tertentu</span>
</span></span><span style=display:flex><span>kubectl rollout status -w deployment/frontend                    <span style=color:#080;font-style:italic># melakukan watch terhadap status pembaruan bergilir dari Deployment &#34;frontend&#34; sampai selesai</span>
</span></span><span style=display:flex><span>kubectl rollout restart deployment/frontend                      <span style=color:#080;font-style:italic># melakukan restart secara bergilir untuk Deployment &#34;frontend&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>cat pod.json | kubectl replace -f -                              <span style=color:#080;font-style:italic># menggantikan sebuah Pod berdasarkan JSON yang dilewatkan melalui std</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># menggantikan, menghapus, dan membuat ulang sumber daya secara paksa, dapat menyebabkan gagalnya layanan</span>
</span></span><span style=display:flex><span>kubectl replace --force -f ./pod.json
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># membuat sebuah Service untuk nginx yang terreplikasi, melayani pada porta 80 dan menghubungkan kontainer pada porta 8000</span>
</span></span><span style=display:flex><span>kubectl expose rc nginx --port<span style=color:#666>=</span><span style=color:#666>80</span> --target-port<span style=color:#666>=</span><span style=color:#666>8000</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># memperbarui versi image (tag) yang dimiliki kontainer Pod menjadi versi v4</span>
</span></span><span style=display:flex><span>kubectl get pod mypod -o yaml | sed <span style=color:#b44>&#39;s/\(image: myimage\):.*$/\1:v4/&#39;</span> | kubectl replace -f -
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl label pods my-pod new-label<span style=color:#666>=</span>awesome                      <span style=color:#080;font-style:italic># menambahkan sebuah label</span>
</span></span><span style=display:flex><span>kubectl annotate pods my-pod icon-url<span style=color:#666>=</span>http://goo.gl/XXBTWq       <span style=color:#080;font-style:italic># menambahkan sebuah anotasi</span>
</span></span><span style=display:flex><span>kubectl autoscale deployment foo --min<span style=color:#666>=</span><span style=color:#666>2</span> --max<span style=color:#666>=</span><span style=color:#666>10</span>                <span style=color:#080;font-style:italic># menskalakan sebuah Deployment &#34;foo&#34; secara otomatis</span>
</span></span></code></pre></div><h2 id=menambal-patch-sumber-daya>Menambal (<em>Patch</em>) Sumber Daya</h2><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#080;font-style:italic># memperbarui sebuah Node secara parsial</span>
</span></span><span style=display:flex><span>kubectl patch node k8s-node-1 -p <span style=color:#b44>&#39;{&#34;spec&#34;:{&#34;unschedulable&#34;:true}}&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># memperbarui image dari kontainer; spec.containers[*].name diperlukan karena menggunakan kunci merge</span>
</span></span><span style=display:flex><span>kubectl patch pod valid-pod -p <span style=color:#b44>&#39;{&#34;spec&#34;:{&#34;containers&#34;:[{&#34;name&#34;:&#34;kubernetes-serve-hostname&#34;,&#34;image&#34;:&#34;new image&#34;}]}}&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># memperbarui image dari kontainer menggunakan patch json dengan array posisi</span>
</span></span><span style=display:flex><span>kubectl patch pod valid-pod --type<span style=color:#666>=</span><span style=color:#b44>&#39;json&#39;</span> -p<span style=color:#666>=</span><span style=color:#b44>&#39;[{&#34;op&#34;: &#34;replace&#34;, &#34;path&#34;: &#34;/spec/containers/0/image&#34;, &#34;value&#34;:&#34;new image&#34;}]&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># menonaktifkan sebuah Deployment livenessProbe menggunakan patch json dengan array posisi</span>
</span></span><span style=display:flex><span>kubectl patch deployment valid-deployment  --type json   -p<span style=color:#666>=</span><span style=color:#b44>&#39;[{&#34;op&#34;: &#34;remove&#34;, &#34;path&#34;: &#34;/spec/template/spec/containers/0/livenessProbe&#34;}]&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># menambahkan elemen baru ke dalam array posisi</span>
</span></span><span style=display:flex><span>kubectl patch sa default --type<span style=color:#666>=</span><span style=color:#b44>&#39;json&#39;</span> -p<span style=color:#666>=</span><span style=color:#b44>&#39;[{&#34;op&#34;: &#34;add&#34;, &#34;path&#34;: &#34;/secrets/1&#34;, &#34;value&#34;: {&#34;name&#34;: &#34;whatever&#34; } }]&#39;</span>
</span></span></code></pre></div><h2 id=menyunting-sumber-daya>Menyunting Sumber Daya</h2><p>Menyunting sumber daya API menggunakan penyunting (editor) yang biasa kamu gunakan.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl edit svc/docker-registry                      <span style=color:#080;font-style:italic># menyunting Service yang bernama docker-registry</span>
</span></span><span style=display:flex><span><span style=color:#b8860b>KUBE_EDITOR</span><span style=color:#666>=</span><span style=color:#b44>&#34;nano&#34;</span> kubectl edit svc/docker-registry   <span style=color:#080;font-style:italic># menggunakan penyunting alternatif</span>
</span></span></code></pre></div><h2 id=menskalakan-sumber-daya>Menskalakan Sumber Daya</h2><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl scale --replicas<span style=color:#666>=</span><span style=color:#666>3</span> rs/foo                                 <span style=color:#080;font-style:italic># menskalakan ReplicaSet bernama &#39;foo&#39; menjadi 3</span>
</span></span><span style=display:flex><span>kubectl scale --replicas<span style=color:#666>=</span><span style=color:#666>3</span> -f foo.yaml                            <span style=color:#080;font-style:italic># menskalakan sebuah sumber daya yang dispesifikasikan di dalam &#34;foo.yaml&#34; menjadi 3</span>
</span></span><span style=display:flex><span>kubectl scale --current-replicas<span style=color:#666>=</span><span style=color:#666>2</span> --replicas<span style=color:#666>=</span><span style=color:#666>3</span> deployment/mysql  <span style=color:#080;font-style:italic># jika Deployment bernama mysql saat ini memiliki ukuran 2, skalakan mysql menjadi 3</span>
</span></span><span style=display:flex><span>kubectl scale --replicas<span style=color:#666>=</span><span style=color:#666>5</span> rc/foo rc/bar rc/baz                   <span style=color:#080;font-style:italic># menskalakan beberapa ReplicationController sekaligus</span>
</span></span></code></pre></div><h2 id=menghapus-sumber-daya>Menghapus Sumber Daya</h2><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl delete -f ./pod.json                                              <span style=color:#080;font-style:italic># menghapus Pod menggunakan tipe dan nama yang dispesifikan di dalam pod.json</span>
</span></span><span style=display:flex><span>kubectl delete pod,service baz foo                                        <span style=color:#080;font-style:italic># menghapus Pod dan Service dengan nama yang sama, yaitu &#34;baz&#34; dan &#34;foo&#34;</span>
</span></span><span style=display:flex><span>kubectl delete pods,services -l <span style=color:#b8860b>name</span><span style=color:#666>=</span>myLabel                              <span style=color:#080;font-style:italic># menghapus semua Pod dan Service yang memiliki label name=myLabel</span>
</span></span><span style=display:flex><span>kubectl -n my-ns delete pod,svc --all                                     <span style=color:#080;font-style:italic># menghapus semua Pod dan Service di dalam Namespace my-ns</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># menghapus semua Pod yang sesuai dengan pattern1 atau pattern2 dari awk</span>
</span></span><span style=display:flex><span>kubectl get pods  -n mynamespace --no-headers<span style=color:#666>=</span><span style=color:#a2f>true</span> | awk <span style=color:#b44>&#39;/pattern1|pattern2/{print $1}&#39;</span> | xargs  kubectl delete -n mynamespace pod
</span></span></code></pre></div><h2 id=berinteraksi-dengan-pod-yang-sedang-berjalan>Berinteraksi dengan Pod yang sedang berjalan</h2><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl logs my-pod                                 <span style=color:#080;font-style:italic># memperlihatkan log dari Pod (keluaran stdout)</span>
</span></span><span style=display:flex><span>kubectl logs -l <span style=color:#b8860b>name</span><span style=color:#666>=</span>myLabel                        <span style=color:#080;font-style:italic># memperlihatkan log dari Pod dengan label name=myLabel (keluaran stdout)</span>
</span></span><span style=display:flex><span>kubectl logs my-pod --previous                      <span style=color:#080;font-style:italic># memperlihatkan log dari Pod (keluaran stdout) untuk kontainer yang dijalankan sebelumnya</span>
</span></span><span style=display:flex><span>kubectl logs my-pod -c my-container                 <span style=color:#080;font-style:italic># memperlihatkan log dari kontainer di dalam Pod (keluaran stdout, kasus banyak kontainer)</span>
</span></span><span style=display:flex><span>kubectl logs -l <span style=color:#b8860b>name</span><span style=color:#666>=</span>myLabel -c my-container        <span style=color:#080;font-style:italic># memperlihatkan log dari Pod, dengan label name=myLabel (keluaran stdout)</span>
</span></span><span style=display:flex><span>kubectl logs my-pod -c my-container --previous      <span style=color:#080;font-style:italic># memperlihatkan log dari kontainer di dalam Pod (keluaran stdout, kasus banyak kontainer) untuk kontainer yang dijalankan sebelumnya</span>
</span></span><span style=display:flex><span>kubectl logs -f my-pod                              <span style=color:#080;font-style:italic># memperlihatkan aliran log dari Pod (keluaran stdout)</span>
</span></span><span style=display:flex><span>kubectl logs -f my-pod -c my-container              <span style=color:#080;font-style:italic># memperlihatkan aliran log dari kontainer di dalam Pod (keluaran stdout, kasus banyak kontainer)</span>
</span></span><span style=display:flex><span>kubectl logs -f -l <span style=color:#b8860b>name</span><span style=color:#666>=</span>myLabel --all-containers    <span style=color:#080;font-style:italic># memperlihatkan aliran log dari Pod dengan label name=myLabel (keluaran stdout)</span>
</span></span><span style=display:flex><span>kubectl run -i --tty busybox --image<span style=color:#666>=</span>busybox -- sh  <span style=color:#080;font-style:italic># menjalankan Pod sebagai shell interaktif</span>
</span></span><span style=display:flex><span>kubectl run nginx --image<span style=color:#666>=</span>nginx --restart<span style=color:#666>=</span>Never -n 
</span></span><span style=display:flex><span>mynamespace                                         <span style=color:#080;font-style:italic># menjalankan Pod nginx ke dalam Namespace tertentu</span>
</span></span><span style=display:flex><span>kubectl run nginx --image<span style=color:#666>=</span>nginx --restart<span style=color:#666>=</span>Never     <span style=color:#080;font-style:italic># menjalankan Pod nginx dan menulis spesifikasinya ke dalam sebuah berkas bernama pod.yaml</span>
</span></span><span style=display:flex><span>--dry-run -o yaml &gt; pod.yaml
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl attach my-pod -i                            <span style=color:#080;font-style:italic># melekatkan (meng-attach) ke dalam kontainer yang sedang berjalan</span>
</span></span><span style=display:flex><span>kubectl port-forward my-pod 5000:6000               <span style=color:#080;font-style:italic># mendengar (listen) pada porta 5000 di mesin lokal dan meneruskan ke porta 6000 di Pod my-pod</span>
</span></span><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> my-pod -- ls /                         <span style=color:#080;font-style:italic># menjalankan perintah pada Pod my-pod (kasus 1 kontainer)</span>
</span></span><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> my-pod -c my-container -- ls /         <span style=color:#080;font-style:italic># menjalankan peirntah pada Pod my-pod (kasus banyak kontainer)</span>
</span></span><span style=display:flex><span>kubectl top pod POD_NAME --containers               <span style=color:#080;font-style:italic># memperlihatkan metrik yang dimiliki Pod bersama kontainernya</span>
</span></span></code></pre></div><h2 id=berinteraksi-dengan-node-dan-klaster>Berinteraksi dengan Node dan Klaster</h2><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl cordon my-node                                                <span style=color:#080;font-style:italic># menandai my-node supaya tidak bisa dijadwalkan dengan Pod (unschedulable)</span>
</span></span><span style=display:flex><span>kubectl drain my-node                                                 <span style=color:#080;font-style:italic># mengeringkan (drain) my-node sebagai bagian dari persiapan untuk pemeliharaan</span>
</span></span><span style=display:flex><span>kubectl uncordon my-node                                              <span style=color:#080;font-style:italic># menandai my-node supaya bisa dijadwalkan dengan Pod (schedulable)</span>
</span></span><span style=display:flex><span>kubectl top node my-node                                              <span style=color:#080;font-style:italic># memperlihatkan metrik dari Node my-node</span>
</span></span><span style=display:flex><span>kubectl cluster-info                                                  <span style=color:#080;font-style:italic># memperlihatkan alamaat dari master dan layanan</span>
</span></span><span style=display:flex><span>kubectl cluster-info dump                                             <span style=color:#080;font-style:italic># memperlihatkan state klaster saat ini pada keluaran stdout</span>
</span></span><span style=display:flex><span>kubectl cluster-info dump --output-directory<span style=color:#666>=</span>/path/to/cluster-state   <span style=color:#080;font-style:italic># memperlihatkan state klaster saat ini pada /path/to/cluster-state</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># jika sebuah taint dengan sebuah kunci dan efek di bawah pernah diterapkan, maka nilainya akan tergantikan dengan yang baru</span>
</span></span><span style=display:flex><span>kubectl taint nodes foo <span style=color:#b8860b>dedicated</span><span style=color:#666>=</span>special-user:NoSchedule
</span></span></code></pre></div><h3 id=berbagai-tipe-sumber-daya>Berbagai Tipe Sumber Daya</h3><p>Mendapatkan seluruh daftar tipe sumber daya yang didukung lengkap dengan singkatan pendeknya, <a href=/id/docs/concepts/overview/kubernetes-api/#api-groups>grup API</a>,
apakah sumber daya merupakan sumber daya yang berada di dalam Namespace atau tidak, serta <a href=/id/docs/concepts/overview/working-with-objects/kubernetes-objects>Kind</a>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl api-resources
</span></span></code></pre></div><p>Operasi lainnya yang berkaitan dengan sumber daya API (api-resources):</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl api-resources --namespaced<span style=color:#666>=</span><span style=color:#a2f>true</span>      <span style=color:#080;font-style:italic># semua sumber daya yang berada di dalam Namespace</span>
</span></span><span style=display:flex><span>kubectl api-resources --namespaced<span style=color:#666>=</span><span style=color:#a2f>false</span>     <span style=color:#080;font-style:italic># semua sumber daya yang tidak berada di dalam Namespace</span>
</span></span><span style=display:flex><span>kubectl api-resources -o name                <span style=color:#080;font-style:italic># semua sumber daya dengan keluaran sederhana (hanya nama sumber daya)</span>
</span></span><span style=display:flex><span>kubectl api-resources -o wide                <span style=color:#080;font-style:italic># semua sumber daya dengan keluaran tambahan (&#34;wide&#34;)</span>
</span></span><span style=display:flex><span>kubectl api-resources --verbs<span style=color:#666>=</span>list,get       <span style=color:#080;font-style:italic># semua sumber daya yang mendukung verb permintaan &#34;list&#34; dan &#34;get&#34;</span>
</span></span><span style=display:flex><span>kubectl api-resources --api-group<span style=color:#666>=</span>extensions <span style=color:#080;font-style:italic># semua sumber daya di dalam grup API &#34;extensions&#34;</span>
</span></span></code></pre></div><h3 id=memformat-keluaran>Memformat Keluaran</h3><p>Untuk mengeluarkan detail ke dalam jendela terminal kamu dengan format tertentu, tambahkan <em>flag</em> <code>-o</code> (atau <code>--output</code>)
dengan perintah <code>kubectl</code> yang didukung.</p><table><thead><tr><th>Format keluaran</th><th>Deskripsi</th></tr></thead><tbody><tr><td><code>-o=custom-columns=&lt;spec></code></td><td>Mencetak sebuah tabel dengan daftar kolom khas (<em>custom</em>) yang dipisahkan dengan koma</td></tr><tr><td><code>-o=custom-columns-file=&lt;filename></code></td><td>Mencetak sebuah tabel dengan templat kolom khas pada berkas <code>&lt;filename></code></td></tr><tr><td><code>-o=json</code></td><td>Memberikan keluaran objek API dengan format JSON</td></tr><tr><td><code>-o=jsonpath=&lt;template></code></td><td>Mencetak bagian-bagian yang didefinisikan di dalam sebuah ekspresi <a href=/docs/reference/kubectl/jsonpath>jsonpath</a></td></tr><tr><td><code>-o=jsonpath-file=&lt;filename></code></td><td>Mencetak bagian-bagian yang didefinisikan dengan ekspresi <a href=/docs/reference/kubectl/jsonpath>jsonpath</a> ke dalam berkas <code>&lt;filename></code></td></tr><tr><td><code>-o=name</code></td><td>Mencetak hanya nama dari sumber daya, tidak dengan informasi yang lainnya</td></tr><tr><td><code>-o=wide</code></td><td>Memberikan keluaran dengan format teks polos (<em>plain-text</em>) dengan informasi tambahan, dan nama dari Node akan juga termasuk ke dalam informasi untuk Pod</td></tr><tr><td><code>-o=yaml</code></td><td>Memberikan keluaran objek API dengan format YAML</td></tr></tbody></table><p>Contoh-contoh yang menggunakan <code>-o=custom-columns</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#080;font-style:italic># All images running in a cluster</span>
</span></span><span style=display:flex><span>kubectl get pods -A -o<span style=color:#666>=</span>custom-columns<span style=color:#666>=</span><span style=color:#b44>&#39;DATA:spec.containers[*].image&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> <span style=color:#080;font-style:italic># All images excluding &#34;k8s.gcr.io/coredns:1.6.2&#34;</span>
</span></span><span style=display:flex><span>kubectl get pods -A -o<span style=color:#666>=</span>custom-columns<span style=color:#666>=</span><span style=color:#b44>&#39;DATA:spec.containers[?(@.image!=&#34;k8s.gcr.io/coredns:1.6.2&#34;)].image&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># All fields under metadata regardless of name</span>
</span></span><span style=display:flex><span>kubectl get pods -A -o<span style=color:#666>=</span>custom-columns<span style=color:#666>=</span><span style=color:#b44>&#39;DATA:metadata.*&#39;</span>
</span></span></code></pre></div><p>More examples in the kubectl <a href=/docs/reference/kubectl/overview/#custom-columns>reference documentation</a>.</p><h3 id=tingkat-kelengkapan-keluaran-dan-debugging-kubectl>Tingkat Kelengkapan Keluaran dan Debugging Kubectl</h3><p>Tingkat kelengkapan keluaran (<em>verbosity</em>) dari kubectl dikendalikan oleh <em>flag</em> <code>-v</code> atau <code>--v</code> diikuti dengan bilangan bulat yang merepresentasikan
tingkatan log. Ketentuan <em>logging</em> Kubernetes secara umum dan keterkaitannya dengan tingkatan log dijelaskan <a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-instrumentation/logging.md>di sini</a>.</p><table><thead><tr><th>Tingkat kelengkapan keluaran</th><th>Deskripsi</th></tr></thead><tbody><tr><td><code>--v=0</code></td><td>Umumnya berguna untuk <em>selalu</em> bisa dilihat oleh seorang operator klaster.</td></tr><tr><td><code>--v=1</code></td><td>Tingkatan log bawaan yang layak jika kamu tidak ingin log yang terlalu lengkap.</td></tr><tr><td><code>--v=2</code></td><td>Berisi informasi yang <em>steady state</em> tentang layanan dan berbagai pesan log penting yang berhubungan dengan perubahan besar pada sistem. Tingkat ini yang paling disarankan pada sistem kebanyakan.</td></tr><tr><td><code>--v=3</code></td><td>Informasi tambahan tentang perubahan pada sistem.</td></tr><tr><td><code>--v=4</code></td><td>Tingkat kelengkapan <em>debug</em>.</td></tr><tr><td><code>--v=6</code></td><td>Memperlihatkan sumber daya yang diminta.</td></tr><tr><td><code>--v=7</code></td><td>Memperlihatkan <em>header</em> dari permintaan HTTP.</td></tr><tr><td><code>--v=8</code></td><td>Memperlihatkan konten dari permintan HTTP.</td></tr><tr><td><code>--v=9</code></td><td>Memperlihatkan kontek dari permintaan HTTP tanpa dipotong.</td></tr></tbody></table><h2 id=selanjutnya>Selanjutnya</h2><ul><li><p>Pelajari lebih lanjut tentang <a href=/docs/reference/kubectl/overview/>Ikhitsar kubectl</a>.</p></li><li><p>Lihat berbagai pilihan opsi dari <a href=/docs/reference/kubectl/kubectl/>kubectl</a>.</p></li><li><p>Pelajari juga <a href=/docs/reference/kubectl/conventions/>Ketentuan Penggunaan kubectl</a> untuk mengetahui bagaimana cara memakainya di dalam skrip yang bisa dipergunakan berulangkali (<em>reusable</em>).</p></li><li><p>Pelajari <a href=https://github.com/dennyzhang/cheatsheet-kubernetes-A4>contekan kubectl</a> dari komunitas.</p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-4985cb55ddfb184639d767ec54b9f0f7>7 - Berkontribusi ke Dokumentasi Kubernetes</h1><p>Jika kamu ingin membantu dengan berkontribusi ke dokumentasi atau situs web Kubernetes, kami
dengan senang hati menerima bantuan kamu! Siapapun bisa berkontribusi, baik kamu yang masih
baru atau sudah lama di proyek ini, maupun jika kamu adalah seorang developer, seorang pengguna,
atau bahkan seorang yang tidak tahan melihat saltik (<em>typo</em>)!</p><p>Untuk informasi mengenai isi dan gaya (penulisan)
dokumentasi Kubernetes, lihat <a href=/docs/contribute/style/>ikhtisar gaya penulisan dokumentasi</a>.</p><h2 id=jenis-jenis-kontributor-dokumentasi>Jenis-jenis kontributor dokumentasi</h2><ul><li>Seorang <em>member</em> dari organisasi Kubernetes yang telah <a href=/docs/contribute/start#sign-the-cla>menandatangani CLA</a>
dan berkontribusi waktu dan usahanya untuk proyek ini. Lihat
<a href=https://github.com/kubernetes/community/blob/master/community-membership.md>Keanggotaan komunitas</a>
untuk kriteria spesifik untuk keanggotaan.</li><li>Seorang SIG Docs <em>reviewer</em> adalah seorang anggota organisasi Kubernetes yang telah
menunjukkan ketertarikannya untuk memeriksa <em>pull request</em> dokumentasi dan telah
ditambahkan ke dalam grup GitHub yang sesuai dan berkas-berkas <code>OWNERS</code> di dalam
repositori GitHub, oleh seorang SIG Docs Approver.</li><li>Seorang SIG Docs <em>approver</em> adalah seorang anggota yang memiliki predikat
yang baik dan telah menunjukkan komitmen berkelanjutan terhadap proyek ini.
Seorang <em>approver</em> dapat melakukan <em>merge</em> terhadap <em>pull request</em> dan
mempublikasi konten atas nama organisasi Kubernetes.
Para <em>approver</em> juga dapat mewakili SIG Docs dalam komunitas Kubernetes
yang lebih besar. Beberapa tugas seorang SIG Docs <em>approver</em>, seperti
mengkoordinasi sebuah perilisan, membutuhkan komitmen waktu yang signifikan.</li></ul><h2 id=cara-cara-untuk-berkontribusi-ke-dokumentasi>Cara-cara untuk berkontribusi ke dokumentasi</h2><p>Daftar ini dibagi menjadi hal-hal yang dapat dilakukan oleh siapapun, hal-hal yang
dapat dilakukan oleh anggota-anggota organisasi Kubernetes, dan hal-hal yang
memerlukan tingkat akses yang lebih tinggi serta pengetahuan terhadap proses-proses
SIG Docs. Berkontribusi secara konsisten dari waktu ke waktu dapat membantumu
mengerti beberapa peralatan dan keputusan organisasi yang telah dibuat.</p><p>Daftar ini bukanlah daftar lengkap mengenai cara-cara kamu dapat berkontribusi
terhadap dokumentasi Kubernetes, tetapi daftar ini dapat membantumu memulainya.</p><ul><li><a href=/docs/contribute/start/>Siapapun</a><ul><li>Membuka <em>issue</em> untuk ditindaklanjuti</li></ul></li><li><a href=/docs/contribute/start/>Member</a><ul><li>Memutakhirkan dokumentasi yang sudah ada</li><li>Menyampaikan ide-ide untuk pembaruan di <a href=http://slack.k8s.io/>Slack</a> atau [milis SIG docs]<a href=https://groups.google.com/forum/#!forum/kubernetes-sig-docs>SIG docs mailing list</a></li><li>Meningkatkan aksesibilitas dokumentasi</li><li>Memberikan umpan balik yang tidak memikat terhadap PR-PR</li><li>Menulis blog atau studi kasus</li></ul></li><li><a href=/docs/contribute/intermediate/>Reviewer</a><ul><li>Mendokumentasikan fitur-fitur baru</li><li>Menyortir dan mengkategorisasi masalah-masalah</li><li>Memeriksa PR-PR</li><li>Membuat diagram-diagram, aset grafis, dan <em>screencast</em> atau video yang dapat di-<em>embed</em></li><li>Lokalisasi/penerjemahan</li><li>Berkontribusi pada repositori-repositori lain sebagai seorang wakil dokumentasi</li><li>Menyunting <em>user-facing strings</em> di dalam kode</li><li>Memutakhirkan komentar-komentar pada kode, Godoc</li></ul></li><li><a href=/docs/contribute/advanced/>Approver</a><ul><li>Mempublikasi konten kontributor dengan menyetujui dan melakukan <em>merge</em> terhadap PR-PR</li><li>Berpartisipasi di dalam sebuah tim rilis Kubernetes sebagai seorang wakil dokumentasi</li><li>Mengusulkan pemutakhiran terhadap petunjuk gaya penulisan</li><li>Mengusulkan pemutakhiran terhadap <em>test-test</em> dokumentasi</li><li>Mengusulkan pemutakhiran terhadap situs web Kubernetes atau peralatan lainnya</li></ul></li></ul><h2 id=cara-cara-tambahan-untuk-berkontribusi>Cara-cara tambahan untuk berkontribusi</h2><ul><li>Untuk berkontribusi ke komunitas Kubernetes melalui forum-forum daring seperti Twitter atau Stack Overflow, atau mengetahui tentang pertemuan komunitas (<em>meetup</em>) lokal dan acara-acara Kubernetes, kunjungi <a href=/community/>situs komunitas Kubernetes</a>.</li><li>Untuk mulai berkontribusi ke pengembangan fitur, baca <a href=https://github.com/kubernetes/community/tree/master/contributors/guide/contributor-cheatsheet><em>cheatseet</em> kontributor</a>.</li><li>Untuk kontribusi khusus ke halaman Bahasa Indonesia, baca <a href=/docs/contribute/localization_id.md>Dokumentasi Khusus Untuk Translasi Bahasa Indonesia</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-e5340359b8afe1fe409af06178af8886>7.1 - Menyarankan peningkatan kualitas konten</h1><p>Jika kamu menemukan masalah pada dokumentasi Kubernetes, atau mempunyai ide untuk
konten baru, maka silakan untuk membuat isu pada Github. Kamu hanya membutuhkan
sebuah <a href=https://github.com/join>akun Github</a> dan sebuah <em>web browser</em>.</p><p>Pada kebanyakan kasus, pekerjaan dalam dokumentasi Kubernetes diawali dengan sebuah
isu pada Github. Kontributor Kubernetes akan mengkaji, mengkategorisasi dan menandai isu
sesuai kebutuhan. Selanjutnya, kamu atau anggota lain dari komunitas Kubernetes dapat membuat
<em>pull request</em> dengan perubahan yang akan menyelesaikan masalahnya.</p><h2 id=membuka-sebuah-issue>Membuka sebuah issue</h2><p>Jika kamu mau menyarankan peningkatan kualitas pada konten yang sudah ada, atau menemukan kesalahan,
maka silakan membuka sebuah isu.</p><ol><li>Turun ke bagian bawah dari suatu halaman dan klik pada tombol <strong>Buat Isu</strong>. Ini akan
mengantarmu pada halaman Github isu dengan beberapa tajuk yang telah diisi.</li><li>Deskripsikan isu atau saran untuk peningkatan kualitas. Sediakan detail sebanyak mungkin yang kamu bisa.</li><li>Klik <strong>Submit new issue</strong></li></ol><p>Setelah dikirim, cek isu yang kamu buat secara berkala atau hidupkan notifikasi Github.
Pengulas (<em>reviewer</em>) atau anggota komunitas lainnya mungkin akan menanyakan pertanyaan
sebelum mereka mengambil suatu tindakan terhadap isumu.</p><h2 id=menyarankan-konten-baru>Menyarankan konten baru</h2><p>Jika kamu memiliki ide untuk konten baru, tapi kamu tidak yakin dimana mengutarakannya,
kamu tetap dapat membuat sebuah isu. Antara lain:</p><ul><li>Pilih halaman pada bagian yang menurutmu konten tersebut berhubungan dan klik <strong>Buat Isu</strong>.</li><li>Pergi ke <a href=https://github.com/kubernetes/website/issues/new/>Github</a> dan langsung membuat isu.</li></ul><h2 id=bagaimana-cara-membuat-isu-yang-bagus>Bagaimana cara membuat isu yang bagus</h2><p>Perhatikan hal berikut ketika membuat sebuah isu:</p><ul><li>Memberikan deskripsi isu yang jelas. Deskripsikan apa yang memang kurang, tertinggal,
salah atau konten mana yang memerlukan peningkatan kualitas.</li><li>Jelaskan dampak spesifik dari isu terhadap pengguna.</li><li>Batasi cakupan dari sebuah isu menjadi ukuran pekerjaan yang masuk akal.
Untuk masalah dengan cakupan yang besar, pecah isu itu menjadi beberapa isu lebih kecil.
Misal, "Membenahi dokumentasi keamanan" masih sangat luas cakupannya, tapi "Penambahan
detail pada topik 'Pembatasan akses jaringan'" adalah lebih spesifik untuk dikerjakan.</li><li>Mencari isu yang sudah ada untuk melihat apakah ada sesuatu yang berhubungan atau
mirip dengan isu yang baru.</li><li>Jika isu yang baru berhubungan dengan isu lain atau <em>pull request</em>, tambahkan rujukan
dengan menuliskan URL lengkap atau dengan nomor isu atau <em>pull request</em> yang diawali dengan
karakter <code>#</code>. Contohnya, <code>Diajukan oleh #987654</code>.</li><li>Mengikuti <a href=/id/community/code-of-conduct/>Kode Etik Komunitas</a>. Menghargai kontributor lain.
Misalnya, "Dokumentasi ini sangat jelek" adalah contoh yang tidak membantu dan juga bukan
masukan yang sopan.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-8b9b22280711800788333c1a4d129735>7.2 - Berpartisipasi dalam SIG Docs</h1><p>SIG Docs merupakan salah satu
<a href=https://github.com/kubernetes/community/blob/master/sig-list.md>kelompok peminatan khusus (<em>special interest groups</em>)</a>
dalam proyek Kubernetes, yang berfokus pada penulisan, pembaruan, dan pemeliharaan
dokumentasi untuk Kubernetes secara keseluruhan. Lihatlah
<a href=https://github.com/kubernetes/community/tree/master/sig-docs>SIG Docs dari repositori github komunitas</a>
untuk informasi lebih lanjut tentang SIG.</p><p>SIG Docs menerima konten dan ulasan dari semua kontributor. Siapa pun dapat membuka
<em>pull request</em> (PR), dan siapa pun boleh mengajukan isu tentang konten atau komen
pada <em>pull request</em> yang sedang berjalan.</p><p>Kamu juga bisa menjadi <a href=/id/docs/contribute/participating/roles-and-responsibilities/#anggota>anggota (<em>member</em>)</a>,
<a href=/id/docs/contribute/participating/roles-and-responsibilities/#pengulas>pengulas (<em>reviewer</em></a>, atau <a href=/id/docs/contribute/participating/roles-and-responsibilities/#approvers>pemberi persetujuan (<em>approver</em>)</a>. Peran tersebut membutuhkan
akses dan mensyaratkan tanggung jawab tertentu untuk menyetujui dan melakukan perubahan.
Lihatlah <a href=https://github.com/kubernetes/community/blob/master/community-membership.md>keanggotaan-komunitas (<em>community-membership</em>)</a>
untuk informasi lebih lanjut tentang cara kerja keanggotaan dalam komunitas Kubernetes.</p><p>Selebihnya dari dokumen ini akan menguraikan beberapa cara unik dari fungsi peranan tersebut dalam
SIG Docs, yang bertanggung jawab untuk memelihara salah satu aspek yang paling berhadapan dengan publik
dalam Kubernetes - situs web dan dokumentasi dari Kubernetes.</p><h2 id=ketua-umum-sig-docs>Ketua umum (<em>chairperson</em>) SIG Docs</h2><p>Setiap SIG, termasuk SIG Docs, memilih satu atau lebih anggota SIG untuk bertindak sebagai
ketua umum. Mereka merupakan kontak utama antara SIG Docs dan bagian lain dari
organisasi Kubernetes. Mereka membutuhkan pengetahuan yang luas tentang struktur
proyek Kubernetes secara keseluruhan dan bagaimana SIG Docs bekerja di dalamnya. Lihatlah
<a href=https://github.com/kubernetes/community/tree/master/sig-docs#leadership>Kepemimpinan (<em>leadership</em>)</a>
untuk daftar ketua umum yang sekarang.</p><h2 id=tim-dan-automasi-dalam-sig-docs>Tim dan automasi dalam SIG Docs</h2><p>Automasi dalam SIG Docs bergantung pada dua mekanisme berbeda:
Tim GitHub dan berkas OWNERS.</p><h3 id=tim-github>Tim GitHub</h3><p>Terdapat dua kategori tim dalam SIG Docs <a href="https://github.com/orgs/kubernetes/teams?query=sig-docs">tim (<em>teams</em>)</a> dalam GitHub:</p><ul><li><code>@sig-docs-{language}-owners</code> merupakan pemberi persetujuan (<em>approver</em>) dan pemimpin (<em>lead</em>)</li><li><code>@sig-docs-{language}-reviews</code> merupakan pengulas (<em>reviewer</em>)</li></ul><p>Setiap tim dapat direferensikan dengan <code>@name</code> mereka dalam komen GitHub untuk berkomunikasi dengan setiap orang di dalam grup.</p><p>Terkadang tim Prow dan GitHub tumpang tindih (<em>overlap</em>) tanpa kecocokan sama persis. Untuk penugasan masalah, <em>pull request</em>, dan untuk mendukung persetujuan PR,
otomatisasi menggunakan informasi dari berkas <code>OWNERS</code>.</p><h3 id=berkas-owners-dan-bagian-yang-utama-front-matter>Berkas OWNERS dan bagian yang utama (<em>front-matter</em>)</h3><p>Proyek Kubernetes menggunakan perangkat otomatisasi yang disebut prow untuk melakukan automatisasi
yang terkait dengan isu dan <em>pull request</em> dalam GitHub.
<a href=https://github.com/kubernetes/website>Repositori situs web Kubernetes</a> menggunakan
dua buah <a href=https://github.com/kubernetes/test-infra/tree/master/prow/plugins>prow <em>plugin</em></a>:</p><ul><li>blunderbuss</li><li>approve</li></ul><p>Kedua <em>plugin</em> menggunakan berkas
<a href=https://github.com/kubernetes/website/blob/main/OWNERS>OWNERS</a> dan
<a href=https://github.com/kubernetes/website/blob/main/OWNERS_ALIASES>OWNERS_ALIASES</a>
dalam level teratas dari repositori GitHub <code>kubernetes/website</code> untuk mengontrol
bagaimana prow bekerja di dalam repositori.</p><p>Berkas OWNERS berisi daftar orang-orang yang menjadi pengulas dan pemberi persetujuan di dalam SIG Docs.
Berkas OWNERS juga bisa terdapat di dalam subdirektori, dan dapat menimpa peranan karena
dapat bertindak sebagai pengulas atau pemberi persetujuan berkas untuk subdirektori itu dan
apa saja yang ada di dalamnya. Untuk informasi lebih lanjut tentang berkas OWNERS pada umumnya, lihatlah
<a href=https://github.com/kubernetes/community/blob/master/contributors/guide/owners.md>OWNERS</a>.</p><p>Selanjutnya, berkas <em>markdown</em> individu dapat menyimpan daftar pengulas dan pemberi persetujuan
pada bagian yang utama, baik dengan menyimpan daftar nama pengguna individu GitHub atau grup GitHub.</p><p>Kombinasi dari berkas OWNERS dan bagian yang utama dalam berkas <em>markdown</em> menentukan
saran kepada pemilik PR yang didapat dari sistem otomatis tentang siapa yang akan meminta ulasan teknis
dan ulasan editorial untuk PR mereka.</p><h2 id=cara-menggabungkan-pekerjaan>Cara menggabungkan pekerjaan</h2><p>Ketika <em>pull request</em> digabungkan ke cabang (<em>branch</em>) yang digunakan untuk mempublikasikan konten, konten itu dipublikasikan di <a href=http://kubernetes.io>http://kubernetes.io</a>. Untuk memastikan bahwa
kualitas konten yang kita terbitkan bermutu tinggi, kita membatasi penggabungan <em>pull request</em> bagi para pemberi persetujuan
SIG Docs. Beginilah cara kerjanya.</p><ul><li>Ketika <em>pull request</em> memiliki label <code>lgtm</code> dan <code>approve</code>, tidak memiliki label <code>hold</code>,
dan telah lulus semua tes, <em>pull request</em> akan digabungkan secara otomatis.</li><li>Anggota organisasi Kubernetes dan pemberi persetujuan SIG Docs dapat menambahkan komen
untuk mencegah penggabungan otomatis dari <em>pull request</em> yang diberikan (dengan menambahkan komen <code>/hold</code>
atau menahan komen <code>/lgtm</code>).</li><li>Setiap anggota Kubernetes dapat menambahkan label <code>lgtm</code> dengan menambahkan komen <code>lgtm</code></li><li>Hanya pemberi persetujuan SIG Docs yang bisa menggabungkan <em>pull request</em>
dengan menambahkan komen <code>/approve</code>. Beberapa pemberi persetujuan juga dapat melakukan
tugas tambahan seperti <a href=/id/docs/contribute/advanced#menjadi-pr-wrangler-untuk-seminggu>PR <em>Wrangler</em></a> atau
<a href=#ketua-umum-sig-docs>Ketua Umum SIG Docs</a>.</li></ul><h2 id=selanjutnya>Selanjutnya</h2><p>Untuk informasi lebih lanjut tentang cara berkontribusi pada dokumentasi Kubernetes, lihatlah:</p><ul><li><a href=/id/docs/contribute/overview/>Berkontribusi konten baru</a></li><li><a href=/id/docs/contribute/review/reviewing-prs>Mengulas konten</a></li><li><a href=/id/docs/contribute/style/>Panduan gaya dokumentasi</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-9d388974115458abb65431d0a8610843>7.3 - Dokumentasi Khusus Untuk Translasi Bahasa Indonesia</h1><p>Panduan khusus untuk bergabung ke komunitas SIG DOC Indonesia dan melakukan
kontribusi untuk mentranslasikan dokumentasi Kubernetes ke dalam Bahasa
Indonesia.</p><h2 id=manajemen-milestone-tim>Manajemen <em>Milestone</em> Tim</h2><p>Secara umum siklus translasi dokumentasi ke Bahasa Indonesia akan dilakukan
3 kali dalam setahun (sekitar setiap 4 bulan). Untuk menentukan dan mengevaluasi
pencapaian atau <em>milestone</em> dalam kurun waktu tersebut <a href=https://zoom.us/j/6072809193>jadwal rapat daring
reguler tim Bahasa Indonesia</a> dilakukan secara
konsisten setiap dua minggu sekali. Dalam <a href=https://docs.google.com/document/d/1Qrj-WUAMA11V6KmcfxJsXcPeWwMbFsyBGV4RGbrSRXY>agenda rapat ini</a>
juga dilakukan pemilihan PR <em>Wrangler</em> untuk dua minggu ke depan. Tugas PR
<em>Wrangler</em> tim Bahasa Indonesia serupa dengan PR <em>Wrangler</em> dari proyek
<em>upstream</em>.</p><p>Target pencapaian atau <em>milestone</em> tim akan dirilis sebagai
<a href=https://github.com/kubernetes/website/issues/22296><em>issue tracking</em> seperti ini</a>
pada Kubernetes GitHub Website setiap 4 bulan. Dan bersama dengan informasi
PR <em>Wrangler</em> yang dipilih setiap dua minggu, keduanya akan diumumkan di Slack
<em>channel</em> <a href=https://kubernetes.slack.com/archives/CJ1LUCUHM>#kubernetes-docs-id</a>
dari Komunitas Kubernetes.</p><h2 id=cara-memulai-translasi>Cara Memulai Translasi</h2><p>Untuk menerjemahkan satu halaman Bahasa Inggris ke Bahasa Indonesia, lakukan
langkah-langkah berikut ini:</p><ul><li>Check halaman <em>issue</em> di GitHub dan pastikan tidak ada orang lain yang sudah
mengklaim halaman kamu dalam daftar periksa atau komentar-komentar sebelumnya.</li><li>Klaim halaman kamu pada <em>issue</em> di GitHub dengan memberikan komentar di bawah
dengan nama halaman yang ingin kamu terjemahkan dan ambillah hanya satu halaman
dalam satu waktu.</li><li><em>Fork</em> <a href=https://github.com/kubernetes/website>repo ini</a>, buat terjemahan
kamu, dan kirimkan PR (<em>pull request</em>) dengan label <code>language/id</code></li><li>Setelah dikirim, pengulas akan memberikan komentar dalam beberapa hari, dan
tolong untuk menjawab semua komentar. Direkomendasikan juga untuk melakukan
<a href=https://github.com/wprig/wprig/wiki/How-to-squash-commits><em>squash</em></a> <em>commit</em>
kamu dengan pesan <em>commit</em> yang baik.</li></ul><h2 id=informasi-acuan-untuk-translasi>Informasi Acuan Untuk Translasi</h2><p>Tidak ada panduan gaya khusus untuk menulis translasi ke bahasa Indonesia.
Namun, secara umum kita dapat mengikuti panduan gaya bahasa Inggris dengan
beberapa tambahan untuk kata-kata impor yang dicetak miring.</p><p>Harap berkomitmen dengan terjemahan kamu dan pada saat kamu mendapatkan komentar
dari pengulas, silahkan atasi sebaik-baiknya. Kami berharap halaman yang
diklaim akan diterjemahkan dalam waktu kurang lebih dua minggu. Jika ternyata
kamu tidak dapat berkomitmen lagi, beri tahu para pengulas agar mereka dapat
meberikan halaman tersebut ke orang lain.</p><p>Beberapa acuan tambahan dalam melakukan translasi silahkan lihat informasi
berikut ini:</p><h3 id=daftara-glosarium-translasi-dari-tim-sig-doc-indonesia>Daftara Glosarium Translasi dari tim SIG DOC Indonesia</h3><p>Untuk kata-kata selengkapnya silahkan baca glosariumnya
<a href=#glosarium-indonesia>disini</a></p><h3 id=kbbi>KBBI</h3><p>Konsultasikan dengan KBBI (Kamus Besar Bahasa Indonesia)
<a href=https://kbbi.web.id/>disini</a> dari
<a href=https://kbbi.kemdikbud.go.id/>Kemendikbud</a>.</p><h3 id=rsni-glosarium-dari-ivan-lanin>RSNI Glosarium dari Ivan Lanin</h3><p><a href=https://github.com/jk8s/sig-docs-id-localization-how-tos/blob/master/resources/RSNI-glossarium.pdf>RSNI Glosarium</a>
dapat digunakan untuk memahami bagaimana menerjemahkan berbagai istilah teknis
dan khusus Kubernetes.</p><h2 id=panduan-penulisan-source-code>Panduan Penulisan <em>Source Code</em></h2><h3 id=mengikuti-kode-asli-dari-dokumentasi-bahasa-inggris>Mengikuti kode asli dari dokumentasi bahasa Inggris</h3><p>Untuk kenyamanan pemeliharaan, ikuti lebar teks asli dalam kode bahasa Inggris.
Dengan kata lain, jika teks asli ditulis dalam baris yang panjang tanpa putus
atu baris, maka teks tersebut ditulis panjang dalam satu baris meskipun dalam
bahasa Indonesia. Jagalah agar tetap serupa.</p><h3 id=hapus-nama-reviewer-di-kode-asli-bahasa-inggris>Hapus nama reviewer di kode asli bahasa Inggris</h3><p>Terkadang <em>reviewer</em> ditentukan di bagian atas kode di teks asli Bahasa Inggris.
Secara umum, <em>reviewer-reviewer</em> halaman aslinya akan kesulitan untuk meninjau
halaman dalam bahasa Indonesia, jadi hapus kode yang terkait dengan informasi
<em>reviewer</em> dari metadata kode tersebut.</p><h2 id=panduan-penulisan-kata-kata-translasi>Panduan Penulisan Kata-kata Translasi</h2><h3 id=panduan-umum>Panduan umum</h3><ul><li>Gunakan "kamu" daripada "Anda" sebagai subyek agar lebih bersahabat dengan
para pembaca dokumentasi.</li><li>Tulislah miring untuk kata-kata bahasa Inggris yang diimpor jika kamu tidak
dapat menemukan kata-kata tersebut dalam bahasa Indonesia.
<em>Benar</em>: <em>controller</em>. <em>Salah</em>: controller, <code>controller</code></li></ul><h3 id=panduan-untuk-kata-kata-api-objek-kubernetes>Panduan untuk kata-kata API Objek Kubernetes</h3><p>Gunakan gaya "CamelCase" untuk menulis objek API Kubernetes, lihat daftar
lengkapnya <a href=/docs/reference/kubernetes-api/>di sini</a>.
Sebagai contoh:</p><ul><li><em>Benar</em>: PersistentVolume. <em>Salah</em>: volume persisten, <code>PersistentVolume</code>,
persistentVolume</li><li><em>Benar</em>: Pod. <em>Salah</em>: pod, <code>pod</code>, "pod"</li></ul><p><em>Tips</em> : Biasanya API objek sudah ditulis dalam huruf kapital pada halaman asli
bahasa Inggris.</p><h3 id=panduan-untuk-kata-kata-yang-sama-dengan-api-objek-kubernetes>Panduan untuk kata-kata yang sama dengan API Objek Kubernetes</h3><p>Ada beberapa kata-kata yang serupa dengan nama API objek dari Kubernetes dan
dapat mengacu ke arti yang lebih umum (tidak selalu dalam konteks Kubernetes).
Sebagai contoh: <em>service</em>, <em>container</em>, <em>node</em> , dan lain sebagainya. Kata-kata
sebaiknya ditranslasikan ke Bahasa Indonesia sebagai contoh <em>service</em> menjadi
layanan, <em>container</em> menjadi kontainer.</p><p><em>Tips</em> : Biasanya kata-kata yang mengacu ke arti yang lebih umum sudah <em>tidak</em>
ditulis dalam huruf kapital pada halaman asli bahasa Inggris.</p><h3 id=panduan-untuk-feature-gate-kubernetes>Panduan untuk "Feature Gate" Kubernetes</h3><p>Istilah <a href=/docs/reference/command-line-tools-reference/feature-gates/><em>feature gate</em></a>
Kubernetes tidak perlu diterjemahkan ke dalam bahasa Indonesia dan tetap
dipertahankan dalam bentuk aslinya.</p><p>Contoh dari <em>functional gate</em> adalah sebagai berikut:</p><ul><li>Akselerator</li><li>AdvancedAuditing</li><li>AffinityInAnnotations</li><li>AllowExtTrafficLocalEndpoints</li><li>...</li></ul><h3 id=glosarium-indonesia>Glosarium Indonesia</h3><table><thead><tr><th>Inggris</th><th>Tipe Kata</th><th>Indonesia</th><th>Sumber</th><th>Contoh Kalimat</th></tr></thead><tbody><tr><td>cluster</td><td></td><td>klaster</td><td></td><td></td></tr><tr><td>container</td><td></td><td>kontainer</td><td></td><td></td></tr><tr><td>node</td><td>kata benda</td><td>node</td><td></td><td></td></tr><tr><td>file</td><td></td><td>berkas</td><td></td><td></td></tr><tr><td>service</td><td>kata benda</td><td>layanan</td><td></td><td></td></tr><tr><td>set</td><td></td><td>sekumpulan</td><td></td><td></td></tr><tr><td>resource</td><td></td><td>sumber daya</td><td></td><td></td></tr><tr><td>default</td><td></td><td>bawaan atau standar (tergantung context)</td><td></td><td>Secara bawaan, ...; Pada konfigurasi dan instalasi standar, ...</td></tr><tr><td>deploy</td><td></td><td>menggelar</td><td></td><td></td></tr><tr><td>image</td><td></td><td><em>image</em></td><td></td><td></td></tr><tr><td>request</td><td></td><td>permintaan</td><td></td><td></td></tr><tr><td>object</td><td>kata benda</td><td>objek</td><td><a href=https://kbbi.web.id/objek>https://kbbi.web.id/objek</a></td><td></td></tr><tr><td>command</td><td></td><td>perintah</td><td><a href=https://kbbi.web.id/perintah>https://kbbi.web.id/perintah</a></td><td></td></tr><tr><td>view</td><td></td><td>tampilan</td><td></td><td></td></tr><tr><td>support</td><td></td><td>tersedia atau dukungan (tergantung konteks)</td><td>"This feature is supported on version X; Fitur ini tersedia pada versi X; Supported by community; Didukung oleh komunitas"</td><td></td></tr><tr><td>release</td><td>kata benda</td><td>rilis</td><td><a href=https://kbbi.web.id/rilis>https://kbbi.web.id/rilis</a></td><td></td></tr><tr><td>tool</td><td></td><td>perangkat</td><td></td><td></td></tr><tr><td>deployment</td><td></td><td>penggelaran</td><td></td><td></td></tr><tr><td>client</td><td></td><td>klien</td><td></td><td></td></tr><tr><td>reference</td><td></td><td>rujukan</td><td></td><td></td></tr><tr><td>update</td><td></td><td>pembaruan</td><td></td><td>The latest update... ; Pembaruan terkini...</td></tr><tr><td>state</td><td></td><td><em>state</em></td><td></td><td></td></tr><tr><td>task</td><td></td><td><em>task</em></td><td></td><td></td></tr><tr><td>certificate</td><td></td><td>sertifikat</td><td></td><td></td></tr><tr><td>install</td><td></td><td>instalasi</td><td><a href=https://kbbi.web.id/instalasi>https://kbbi.web.id/instalasi</a></td><td></td></tr><tr><td>scale</td><td></td><td>skala</td><td></td><td></td></tr><tr><td>process</td><td>kata kerja</td><td>memproses</td><td><a href=https://kbbi.web.id/proses>https://kbbi.web.id/proses</a></td><td></td></tr><tr><td>replica</td><td>kata benda</td><td>replika</td><td><a href=https://kbbi.web.id/replika>https://kbbi.web.id/replika</a></td><td></td></tr><tr><td>flag</td><td></td><td>tanda, parameter, argumen</td><td></td><td></td></tr><tr><td>event</td><td></td><td><em>event</em></td><td></td><td></td></tr></tbody></table></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/id/docs/home/>Home</a>
<a class=text-white href=/id/community/>Komunitas</a>
<a class=text-white href=/id/case-studies/>Studi kasus</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 Para Pencipta Kubernetes | Dokumentasi didistribusikan di bawah <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small><br><small class=text-white>Copyright &copy; 2023 Linux Foundation &reg;. Hak cipta dilindungi. Linux Foundation telah mendaftarkan merek dagang dan pengunaannya. Perinciannya bisa dilihat pada <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>halaman penggunaan merek dagang</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>