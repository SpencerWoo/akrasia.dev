<!doctype html><html lang=pt-br class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=en href=https://kubernetes.io/docs/concepts/configuration/><link rel=alternate hreflang=zh-cn href=https://kubernetes.io/zh-cn/docs/concepts/configuration/><link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/concepts/configuration/><link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/concepts/configuration/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/concepts/configuration/><link rel=alternate hreflang=it href=https://kubernetes.io/it/docs/concepts/configuration/><link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/concepts/configuration/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/concepts/configuration/><link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/concepts/configuration/><link rel=alternate hreflang=uk href=https://kubernetes.io/uk/docs/concepts/configuration/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/pt-br/docs/concepts/configuration/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>Configuração | Kubernetes</title><meta property="og:title" content="Configuração"><meta property="og:description" content="Orquestração de contêineres em nível de produção"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/pt-br/docs/concepts/configuration/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="Configuração"><meta itemprop=description content="Orquestração de contêineres em nível de produção"><meta name=twitter:card content="summary"><meta name=twitter:title content="Configuração"><meta name=twitter:description content="Orquestração de contêineres em nível de produção"><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content><meta property="og:description" content><meta name=twitter:description content><meta property="og:url" content="https://kubernetes.io/pt-br/docs/concepts/configuration/"><meta property="og:title" content="Configuração"><meta name=twitter:title content="Configuração"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/pt-br/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/pt-br/docs/>Documentação</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/pt-br/blog/>Kubernetes Blog</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/pt-br/partners/>Parceiros</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/pt-br/community/>Comunidade</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/pt-br/case-studies/>Casos de estudo</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Versões</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/pt-br/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/pt-br/docs/concepts/configuration/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/pt-br/docs/concepts/configuration/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/pt-br/docs/concepts/configuration/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/pt-br/docs/concepts/configuration/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/pt-br/docs/concepts/configuration/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Português (Portuguese)</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/docs/concepts/configuration/>English</a>
<a class=dropdown-item href=/zh-cn/docs/concepts/configuration/>中文 (Chinese)</a>
<a class=dropdown-item href=/ko/docs/concepts/configuration/>한국어 (Korean)</a>
<a class=dropdown-item href=/ja/docs/concepts/configuration/>日本語 (Japanese)</a>
<a class=dropdown-item href=/fr/docs/concepts/configuration/>Français (French)</a>
<a class=dropdown-item href=/it/docs/concepts/configuration/>Italiano (Italian)</a>
<a class=dropdown-item href=/de/docs/concepts/configuration/>Deutsch (German)</a>
<a class=dropdown-item href=/es/docs/concepts/configuration/>Español (Spanish)</a>
<a class=dropdown-item href=/id/docs/concepts/configuration/>Bahasa Indonesia</a>
<a class=dropdown-item href=/uk/docs/concepts/configuration/>Українська (Ukrainian)</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>Essa é a versão completa de impressão dessa seção
<a href=# onclick="return print(),!1">Clique aqui para imprimir</a>.</p><p><a href=/pt-br/docs/concepts/configuration/>Retornar à visualização normal</a>.</p></div><h1 class=title>Configuração</h1><ul><li>1: <a href=#pg-ddef6fd0e47bb51c6f05e8e7fb11d2dd>Melhores Práticas de Configuração</a></li><li>2: <a href=#pg-6b5ccadd699df0904e8e9917c5450c4b>ConfigMaps</a></li><li>3: <a href=#pg-e511ed821ada65d0053341dbd8ad2bb5>Secrets</a></li><li>4: <a href=#pg-436057b96151ecb8a4a9a9f456b5d0fc>Gerenciamento de recursos em Pods e contêineres</a></li><li>5: <a href=#pg-ab6d20f33ad930a67ee7ef57bff6c75e>Organizando o acesso ao cluster usando arquivos kubeconfig</a></li></ul><div class=content></div></div><div class=td-content><h1 id=pg-ddef6fd0e47bb51c6f05e8e7fb11d2dd>1 - Melhores Práticas de Configuração</h1><p>Esse documento destaca e consolida as melhores práticas de configuração apresentadas em todo o guia de usuário,
na documentação de introdução e nos exemplos.</p><p>Este é um documento vivo. Se você pensar em algo que não está nesta lista, mas pode ser útil para outras pessoas,
não hesite em criar uma <em>issue</em> ou submeter um PR.</p><h2 id=dicas-gerais-de-configuração>Dicas Gerais de Configuração</h2><ul><li><p>Ao definir configurações, especifique a versão mais recente estável da API.</p></li><li><p>Os arquivos de configuração devem ser armazenados em um sistema de controle antes de serem enviados ao cluster.
Isso permite que você reverta rapidamente uma alteração de configuração, caso necessário. Isso também auxilia na recriação e restauração do cluster.</p></li><li><p>Escreva seus arquivos de configuração usando YAML ao invés de JSON. Embora esses formatos possam ser usados alternadamente em quase todos os cenários, YAML tende a ser mais amigável.</p></li><li><p>Agrupe objetos relacionados em um único arquivo sempre que fizer sentido. Geralmente, um arquivo é mais fácil de
gerenciar do que vários. Veja o <a href=https://github.com/kubernetes/examples/tree/master/guestbook/all-in-one/guestbook-all-in-one.yaml>guestbook-all-in-one.yaml</a> como exemplo dessa sintaxe.</p></li><li><p>Observe também que vários comandos <code>kubectl</code> podem ser chamados em um diretório. Por exemplo, você pode chamar
<code>kubectl apply</code> em um diretório de arquivos de configuração.</p></li><li><p>Não especifique valores padrões desnecessariamente: configurações simples e mínimas diminuem a possibilidade de erros.</p></li><li><p>Coloque descrições de objetos nas anotações para permitir uma melhor análise.</p></li></ul><h2 id=naked-pods-vs-replicasets-deployments-and-jobs>"Naked" Pods comparados a ReplicaSets, Deployments, e Jobs</h2><ul><li><p>Se você puder evitar, não use "naked" Pods (ou seja, se você puder evitar, pods não vinculados a um <a href=/docs/concepts/workloads/controllers/replicaset/>ReplicaSet</a> ou <a href=/docs/concepts/workloads/controllers/deployment/>Deployment</a>).
Os "naked" pods não serão reconfigurados em caso de falha de um nó.</p><p>Criar um Deployment, que cria um ReplicaSet para garantir que o número desejado de Pods esteja disponível e especifica uma estratégia para substituir os Pods (como <a href=/docs/concepts/workloads/controllers/deployment/#rolling-update-deployment>RollingUpdate</a>), é quase sempre preferível do que criar Pods diretamente, exceto para alguns cenários explícitos de restartPolicy:Never. Um Job também pode ser apropriado.</p></li></ul><h2 id=services>Services</h2><ul><li><p>Crie o <a href=/docs/concepts/services-networking/service/>Service</a> antes de suas cargas de trabalho de backend correspondentes (Deployments ou ReplicaSets) e antes de quaisquer cargas de trabalho que precisem acessá-lo. Quando o
Kubernetes inicia um contêiner, ele fornece variáveis de ambiente apontando para todos os Services que estavam em execução quando o contêiner foi iniciado. Por exemplo, se um Service chamado <code>foo</code> existe, todos os contêineres vão
receber as seguintes variáveis em seu ambiente inicial:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#b8860b>FOO_SERVICE_HOST</span><span style=color:#666>=</span>&lt;o host em que o Service está executando&gt;
</span></span><span style=display:flex><span><span style=color:#b8860b>FOO_SERVICE_PORT</span><span style=color:#666>=</span>&lt;a porta em que o Service está executando&gt;
</span></span></code></pre></div></li></ul><p><em>Isso implica em um requisito de pedido</em> - qualquer <code>Service</code> que um <code>Pod</code> quer acessar precisa ser criado antes do <code>Pod</code> em si, ou então as variáveis de ambiente não serão populadas. O DNS não possui essa restrição.</p><ul><li><p>Um <a href=/docs/concepts/cluster-administration/addons/>cluster add-on</a> opcional (embora fortemente recomendado) é um servidor DNS. O
servidor DNS monitora a API do Kubernetes buscando novos <code>Services</code> e cria um conjunto de DNS para cada um. Se o DNS foi habilitado em todo o cluster, então todos os <code>Pods</code> devem ser capazes de fazer a resolução de <code>Services</code> automaticamente.</p></li><li><p>Não especifique um <code>hostPort</code> para um Pod a menos que isso seja absolutamente necessário. Quando você vincula um Pod a um <code>hostPort</code>, isso limita o número de lugares em que o Pod pode ser agendado, porque cada
combinação de &lt;<code>hostIP</code>, <code>hostPort</code>, <code>protocol</code>> deve ser única. Se você não especificar o <code>hostIP</code> e <code>protocol</code> explicitamente, o Kubernetes vai usar <code>0.0.0.0</code> como o <code>hostIP</code> padrão e <code>TCP</code> como <code>protocol</code> padrão.</p><p>Se você precisa de acesso a porta apenas para fins de depuração, pode usar o <a href=/docs/tasks/access-application-cluster/access-cluster/#manually-constructing-apiserver-proxy-urls>apiserver proxy</a> ou o <a href=/docs/tasks/access-application-cluster/port-forward-access-application-cluster/><code>kubectl port-forward</code></a>.</p><p>Se você precisa expor explicitamente a porta de um Pod no nó, considere usar um Service do tipo <a href=/docs/concepts/services-networking/service/#nodeport>NodePort</a> antes de recorrer a <code>hostPort</code>.</p></li><li><p>Evite usar <code>hostNetwork</code> pelos mesmos motivos do <code>hostPort</code>.</p></li><li><p>Use <a href=/docs/concepts/services-networking/service/#headless-services>headless Services</a> (que tem um <code>ClusterIP</code> ou <code>None</code>) para descoberta de serviço quando você não precisar de um balanceador de carga <code>kube-proxy</code>.</p></li></ul><h2 id=usando-labels>Usando Labels</h2><ul><li>Defina e use <a href=/docs/concepts/overview/working-with-objects/labels/>labels</a> que identifiquem <em>atributos semânticos</em> da sua aplicação ou Deployment, como <code>{ app: myapp, tier: frontend, phase: test, deployment: v3 }</code>. Você pode usar essas labels para selecionar os Pods apropriados para outros recursos; por exemplo, um Service que seleciona todos os Pods <code>tier: frontend</code>, ou todos
os componentes de <code>app: myapp</code>. Veja o app <a href=https://github.com/kubernetes/examples/tree/master/guestbook/>guestbook</a> para exemplos dessa abordagem.</li></ul><p>Um Service pode ser feito para abranger vários Deployments, omitindo labels específicas de lançamento de seu seletor. Quando você
precisar atualizar um serviço em execução sem <em>downtime</em>, use um <a href=/docs/concepts/workloads/controllers/deployment/>Deployment</a>.</p><p>Um estado desejado de um objeto é descrito por um Deployment, e se as alterações nesse <em>spec</em> forem <em>aplicadas</em> o controlador
do Deployment altera o estado real para o estado desejado em uma taxa controlada.</p><ul><li><p>Use as <a href=/docs/concepts/overview/working-with-objects/common-labels/>labels comuns do Kubernetes</a> para casos de uso comuns.
Essas labels padronizadas enriquecem os metadados de uma forma que permite que ferramentas, incluindo <code>kubectl</code> e a <a href=/docs/tasks/access-application-cluster/web-ui-dashboard>dashboard</a>, funcionem de uma forma interoperável.</p></li><li><p>Você pode manipular labels para depuração. Como os controladores do Kubernetes (como ReplicaSet) e Services se relacionam com os Pods usando seletor de labels, remover as labels relevantes de um Pod impedirá que ele seja considerado por um controlador ou que
seja atendido pelo tráfego de um Service. Se você remover as labels de um Pod existente, seu controlador criará um novo Pod para
substituí-lo. Essa é uma maneira útil de depurar um Pod anteriormente "ativo" em um ambiente de "quarentena". Para remover ou
alterar labels interativamente, use <a href=/docs/reference/generated/kubectl/kubectl-commands#label><code>kubectl label</code></a>.</p></li></ul><h2 id=imagens-de-contêiner>Imagens de Contêiner</h2><p>A <a href=/docs/concepts/containers/images/#updating-images>imagePullPolicy</a> e tag da imagem afetam quando o <a href=/docs/reference/command-line-tools-reference/kubelet/>kubelet</a> tenta puxar a imagem especificada.</p><ul><li><p><code>imagePullPolicy: IfNotPresent</code>: a imagem é puxada apenas se ainda não estiver presente localmente.</p></li><li><p><code>imagePullPolicy: Always</code>: sempre que o kubelet inicia um contêiner, ele consulta o <em>registry</em> da imagem do contêiner para verificar o resumo de assinatura da imagem. Se o kubelet tiver uma imagem do contêiner com o mesmo resumo de assinatura
armazenado em cache localmente, o kubelet usará a imagem em cache, caso contrário, o kubelet baixa(<em>pulls</em>) a imagem com o resumo de assinatura resolvido, e usa essa imagem para iniciar o contêiner.</p></li><li><p><code>imagePullPolicy</code> é omitido se a tag da imagem é <code>:latest</code> ou se <code>imagePullPolicy</code> é omitido é automaticamente definido como <code>Always</code>. Observe que <em>não</em> será utilizado para <code>ifNotPresent</code>se o valor da tag mudar.</p></li><li><p><code>imagePullPolicy</code> é omitido se uma tag da imagem existe mas não <code>:latest</code>: <code>imagePullPolicy</code> é automaticamente definido como <code>ifNotPresent</code>. Observe que isto <em>não</em> será atualizado para <code>Always</code> se a tag for removida ou alterada para <code>:latest</code>.</p></li><li><p><code>imagePullPolicy: Never</code>: presume-se que a imagem exista localmente. Não é feita nenhuma tentativa de puxar a imagem.</p></li></ul><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Para garantir que seu contêiner sempre use a mesma versão de uma imagem, você pode especificar seu <a href=https://docs.docker.com/engine/reference/commandline/pull/#pull-an-image-by-digest-immutable-identifier>resumo de assinatura</a>;
substitua <code>&lt;nome-da-imagem>:&lt;tag></code> por <code>&lt;nome-da-imagem>@&lt;hash></code> (por exemplo, <code>image@sha256:45b23dee08af5e43a7fea6c4cf9c25ccf269ee113168c19722f87876677c5cb2</code>). Esse resumo de assinatura identifica exclusivamente uma versão
específica de uma imagem, então isso nunca vai ser atualizado pelo Kubernetes a menos que você mude o valor do resumo de assinatura da imagem.</div><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Você deve evitar o uso da tag <code>:latest</code> em produção, pois é mais difícil rastrear qual versão da imagem está sendo executada e mais difícil reverter adequadamente.</div><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> A semântica de cache do provedor de imagem subjacente torna até mesmo <code>imagePullPolicy: Always</code> eficiente, contanto que o registro esteja acessível de forma confiável. Com o Docker, por exemplo, se a imagem já existe, a tentativa de baixar(pull) é rápida porque todas as camadas da imagem são armazenadas em cache e nenhum download de imagem é necessário.</div><h2 id=usando-kubectl>Usando kubectl</h2><ul><li><p>Use <code>kubectl apply -f &lt;directory></code>. Isso procura por configurações do Kubernetes em todos os arquivos <code>.yaml</code>, <code>.yml</code> em <code>&lt;directory></code> e passa isso para <code>apply</code>.</p></li><li><p>Use <em>labels selectors</em> para operações <code>get</code> e <code>delete</code> em vez de nomes de objetos específicos. Consulte as seções sobre <a href=/docs/concepts/overview/working-with-objects/labels/#label-selectors>label selectors</a>
e <a href=/docs/concepts/cluster-administration/manage-deployment/#using-labels-effectively>usando Labels efetivamente</a>.</p></li><li><p>Use <code>kubectl create deployment</code> e <code>kubectl expose</code> para criar rapidamente Deployments e Services de um único contêiner. Consulte <a href=/docs/tasks/access-application-cluster/service-access-application-cluster/>Use um Service para acessar uma aplicação em um cluster</a> para obter um exemplo.</p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-6b5ccadd699df0904e8e9917c5450c4b>2 - ConfigMaps</h1><p><p>Um ConfigMap é um objeto da API usado para armazenar dados não-confidenciais em pares chave-valor.
<a class=glossary-tooltip title='O menor e mais simples objeto Kubernetes. Um Pod representa um conjunto de contêineres em execução no seu cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/ target=_blank aria-label=Pods>Pods</a> podem consumir ConfigMaps como variáveis de ambiente, argumentos de linha de comando ou como arquivos de configuração em um <a class=glossary-tooltip title='Um diretório contendo dados, accessível aos contêineres em um pod.' data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/ target=_blank aria-label=volume>volume</a>.</p></p><p>Um ConfigMap ajuda a desacoplar configurações vinculadas ao ambiente das <a class=glossary-tooltip title='Instância armazenada de um contêiner que contém o conjunto de softwares necessários para rodar uma aplicação.' data-toggle=tooltip data-placement=top href='/pt-br/docs/reference/glossary/?all=true#term-image' target=_blank aria-label='imagens de contêiner'>imagens de contêiner</a>, de modo a tornar aplicações mais facilmente portáveis.</p><div class="alert alert-warning caution callout" role=alert><strong>Cuidado:</strong> O ConfigMap não oferece confidencialidade ou encriptação.
Se os dados que você deseja armazenar são confidenciais, utilize
<a class=glossary-tooltip title='Armazena dados sensíveis, como senhas, tokens OAuth e chaves SSH.' data-toggle=tooltip data-placement=top href=/pt-br/docs/concepts/configuration/secret/ target=_blank aria-label=Secret>Secret</a> ao invés de um ConfigMap,
ou utilize ferramentas adicionais (de terceiros) para manter seus dados privados.</div><h2 id=motivação>Motivação</h2><p>Utilize um ConfigMap para manter a configuração separada do código da aplicação.</p><p>Por exemplo, imagine que você esteja desenvolvendo uma aplicação que pode ser executada
no seu computador local (para desenvolvimento) e na nuvem (para manipular tráfego real).
Você escreve código para ler a variável de ambiente chamada <code>DATABASE_HOST</code>.
No seu ambiente local, você configura essa variável com o valor <code>localhost</code>. Na nuvem, você
configura essa variável para referenciar um <a class=glossary-tooltip title='Uma forma abstrata de expor uma aplicação que está executando em um conjunto de Pods como um serviço de rede.' data-toggle=tooltip data-placement=top href=/docs/concepts/services-networking/service/ target=_blank aria-label=serviço>serviço</a>
do Kubernetes que expõe o componente do banco de dados ao seu cluster.
Isto permite que você baixe uma imagem de contêiner que roda na nuvem e depure exatamente
o mesmo código localmente se necessário.</p><p>Um ConfigMap não foi planejado para conter grandes quantidades de dados. Os dados armazenados
em um ConfigMap não podem exceder 1 MiB. Se você precisa armazenar configurações que são maiores
que este limite, considere montar um volume ou utilizar um serviço separado de banco de dados
ou de arquivamento de dados.</p><h2 id=objeto-configmap>Objeto ConfigMap</h2><p>Um ConfigMap é um <a href=/docs/concepts/overview/working-with-objects/kubernetes-objects/>objeto</a>
da API que permite o armazenamento de configurações para consumo por outros objetos. Diferentemente
de outros objetos do Kubernetes que contém um campo <code>spec</code>, o ConfigMap contém os campos <code>data</code> e
<code>binaryData</code>. Estes campos aceitam pares chave-valor como valores. Ambos os campos <code>data</code> e <code>binaryData</code>
são opcionais. O campo <code>data</code> foi pensado para conter sequências de bytes UTF-8, enquanto o campo <code>binaryData</code>
foi planejado para conter dados binários em forma de strings codificadas em base64.</p><p>É obrigatório que o nome de um ConfigMap seja um
<a href=/pt-br/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>subdomínio DNS válido</a>.</p><p>Cada chave sob as seções <code>data</code> ou <code>binaryData</code> pode conter quaisquer caracteres alfanuméricos,
<code>-</code>, <code>_</code> e <code>.</code>. As chaves armazenadas na seção <code>data</code> não podem colidir com as chaves armazenadas
na seção <code>binaryData</code>.</p><p>A partir da versão v1.19 do Kubernetes, é possível adicionar o campo <code>immutable</code> a uma definição de ConfigMap
para criar um <a href=#configmap-immutable>ConfigMap imutável</a>.</p><h2 id=configmaps-e-pods>ConfigMaps e Pods</h2><p>Você pode escrever uma <code>spec</code> para um Pod que se refere a um ConfigMap e configurar o(s) contêiner(es)
neste Pod baseados em dados do ConfigMap. O Pod e o ConfigMap devem estar no mesmo
<a class=glossary-tooltip title='Uma abstração utilizada pelo Kubernetes para suportar múltiplos clusters virtuais no mesmo cluster físico.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/namespaces target=_blank aria-label=namespace>namespace</a>.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> A <code>spec</code> de um <a class=glossary-tooltip title='Um pod gerenciado diretamente pelo daemon do kubelet em um nó específico.' data-toggle=tooltip data-placement=top href=/docs/tasks/configure-pod-container/static-pod/ target=_blank aria-label='Pod estático'>Pod estático</a> não pode se referir a um
ConfigMap ou a quaisquer outros objetos da API.</div><p>Exemplo de um ConfigMap que contém algumas chaves com valores avulsos e outras chaves com valores semelhantes
a fragmentos de arquivos de configuração:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>game-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># chaves com valores de propriedades; cada chave mapeia para um valor avulso</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>player_initial_lives</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;3&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ui_properties_file_name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;user-interface.properties&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># chaves semelhantes a fragmentos de arquivos</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>game.properties</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    enemy.types=aliens,monsters
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    player.maximum-lives=5</span><span style=color:#bbb>    
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>user-interface.properties</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    color.good=purple
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    color.bad=yellow
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    allow.textmode=true</span><span style=color:#bbb>    
</span></span></span></code></pre></div><p>Existem quatro formas diferentes para consumo de um ConfigMap na configuração de um
contêiner dentro de um Pod:</p><ol><li>Dentro de um comando de contêiner e seus argumentos.</li><li>Variáveis de ambiente para um contêiner.</li><li>Criando um arquivo em um volume somente leitura, para consumo pela aplicação.</li><li>Escrevendo código para execução dentro do Pod que utilize a API do Kubernetes para ler um ConfigMap.</li></ol><p>Os diferentes métodos de consumo oferecem diferentes formas de modelar os dados sendo consumidos.
Para os três primeiros métodos, o <a class=glossary-tooltip title='Um agente que é executado em cada node no cluster. Ele garante que os contêineres estejam sendo executados em um pod.' data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kubelet target=_blank aria-label=kubelet>kubelet</a> utiliza
os dados de um ConfigMap quando o(s) contêiner(es) do Pod são inicializados.</p><p>O quarto método envolve escrita de código para leitura do ConfigMap e dos seus dados. No entanto,
como a API do Kubernetes está sendo utilizada diretamente, a aplicação pode solicitar atualizações
sempre que o ConfigMap for alterado e reagir quando isso ocorre. Acessar a API do Kubernetes
diretamente também permite ler ConfigMaps em outros namespaces.</p><p>Exemplo de um Pod que utiliza valores do ConfigMap <code>game-demo</code> para configurar um Pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>configmap-demo-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>alpine<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;sleep&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;3600&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># Define as variáveis de ambiente</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>PLAYER_INITIAL_LIVES<span style=color:#bbb> </span><span style=color:#080;font-style:italic># Note que aqui a variável está definida em caixa alta,</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                                     </span><span style=color:#080;font-style:italic># diferente da chave no ConfigMap.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>configMapKeyRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>game-demo          <span style=color:#bbb> </span><span style=color:#080;font-style:italic># O ConfigMap de onde esse valor vem.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>player_initial_lives<span style=color:#bbb> </span><span style=color:#080;font-style:italic># A chave que deve ser buscada.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>UI_PROPERTIES_FILE_NAME<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>configMapKeyRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>game-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>ui_properties_file_name<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/config&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># Volumes são definidos no escopo do Pod, e os pontos de montagem são definidos</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># nos contêineres dentro dos pods.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>configMap</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># Informe o nome do ConfigMap que deseja montar.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>game-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># Uma lista de chaves do ConfigMap para serem criadas como arquivos.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;game.properties&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;game.properties&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;user-interface.properties&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;user-interface.properties&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>ConfigMaps não diferenciam entre propriedades com valores simples ou valores complexos,
que ocupam várias linhas. O importante é a forma que Pods e outros objetos consomem tais valores.</p><p>Neste exemplo, definir um volume e montar ele dentro do contêiner <code>demo</code> no caminho <code>/config</code>
cria dois arquivos: <code>/config/game.properties</code> e <code>/config/user-interface.properties</code>, embora existam
quatro chaves distintas no ConfigMap. Isso se deve ao fato de que a definição do Pod contém uma lista
<code>items</code> na seção <code>volumes</code>.
Se a lista <code>items</code> for omitida, cada chave do ConfigMap torna-se um arquivo cujo nome é a sua chave
correspondente, e quatro arquivos serão criados.</p><h2 id=usando-configmaps>Usando ConfigMaps</h2><p>ConfigMaps podem ser montados como volumes de dados. ConfigMaps também podem ser utilizados
por outras partes do sistema sem serem diretamente expostos ao Pod. Por exemplo, ConfigMaps
podem conter dados que outras partes do sistema devem usar para configuração.</p><p>A forma mais comum de utilização de ConfigMaps é a configuração de contêineres executando em
Pods no mesmo namespace. Você também pode utilizar um ConfigMap separadamente.</p><p>Por exemplo, existem <a class=glossary-tooltip title='Recursos que estendem a funcionalidade do Kubernetes.' data-toggle=tooltip data-placement=top href=/pt-br/docs/concepts/cluster-administration/addons/ target=_blank aria-label=complementos>complementos</a> ou
<a class=glossary-tooltip title='Um controlador especializado que gerencia um recurso personalizado.' data-toggle=tooltip data-placement=top href=/pt-br/docs/concepts/extend-kubernetes/operator/ target=_blank aria-label=operadores>operadores</a> que adaptam seus comportamentos
de acordo com dados de um ConfigMap.</p><h3 id=utilizando-configmaps-como-arquivos-em-um-pod>Utilizando ConfigMaps como arquivos em um Pod</h3><p>Para consumir um ConfigMap em um volume em um Pod:</p><ol><li>Crie um ConfigMap ou utilize um ConfigMap existente. Múltiplos Pods
podem referenciar o mesmo ConfigMap.</li><li>Modifique sua definição de Pod para adicionar um volume em
<code>.spec.volumes[]</code>. Escolha um nome qualquer para o seu volume, e
referencie o seu objeto ConfigMap no campo
<code>.spec.volumes[].configMap.name</code>.</li><li>Adicione um campo <code>.spec.containers[].volumeMounts[]</code> a cada um dos
contêineres que precisam do ConfigMap. Especifique
<code>.spec.containers[].volumeMounts[].readOnly = true</code> e informe no campo
<code>.spec.containers[].volumeMounts[].mountPath</code> um caminho de um diretório
não utilizado onde você deseja que este ConfigMap apareça.</li><li>Modifique sua imagem ou linha de comando de modo que o programa procure
por arquivos no diretório especificado no passo anterior. Cada chave no
campo <code>data</code> do ConfigMap será transformado em um nome de arquivo no
diretório especificado por <code>mountPath</code>.</li></ol><p>Exemplo de um Pod que monta um ConfigMap em um volume:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/foo&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>configMap</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myconfigmap<span style=color:#bbb>
</span></span></span></code></pre></div><p>Cada ConfigMap que você deseja utilizar precisa ser referenciado em
<code>.spec.volumes</code>.</p><p>Se houver múltiplos contêineres no Pod, cada contêiner deve ter seu
próprio bloco <code>volumeMounts</code>, mas somente uma instância de <code>.spec.volumes</code>
é necessária por ConfigMap.</p><h3 id=configmaps-montados-são-atualizados-automaticamente>ConfigMaps montados são atualizados automaticamente</h3><p>Quando um ConfigMap que está sendo consumido em um volume é atualizado, as chaves projetadas são
eventualmente atualizadas também. O Kubelet checa se o ConfigMap montado está atualizado em cada
sincronização periódica.
No entanto, o kubelet utiliza o cache local para buscar o valor atual do ConfigMap.
O tipo de cache é configurável utilizando o campo <code>ConfigMapAndSecretChangeDetectionStrategy</code> na
<a href=/docs/reference/config-api/kubelet-config.v1beta1/>configuração do Kubelet (KubeletConfiguration)</a>.
Um ConfigMap pode ter sua propagação baseada em um <em>watch</em> (comportamento padrão), que é o sistema
de propagação de mudanças incrementais em objetos do Kubernetes; baseado em TTL (<em>time to live</em>,
ou tempo de expiração); ou redirecionando todas as requisições diretamente para o servidor da API.
Como resultado, o tempo decorrido total entre o momento em que o ConfigMap foi atualizado até o momento
quando as novas chaves são projetadas nos Pods pode ser tão longo quanto o tempo de sincronização
do kubelet somado ao tempo de propagação do cache, onde o tempo de propagação do cache depende do
tipo de cache escolhido: o tempo de propagação pode ser igual ao tempo de propagação do <em>watch</em>,
TTL do cache, ou zero, de acordo com cada um dos tipos de cache.</p><p>ConfigMaps que são consumidos como variáveis de ambiente não atualizam automaticamente e requerem uma
reinicialização do pod.</p><h2 id=configmap-immutable>ConfigMaps imutáveis</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.21 [stable]</code></div><p>A funcionalidade <em>Secrets e ConfigMaps imutáveis</em> do Kubernetes fornece uma opção
para marcar Secrets e ConfigMaps individuais como imutáveis. Para clusters que utilizam
ConfigMaps extensivamente (ao menos centenas de milhares de mapeamentos únicos de
ConfigMaps para Pods), prevenir alterações dos seus dados traz as seguintes vantagens:</p><ul><li>protege de atualizações acidentais ou indesejadas que podem causar disrupção na execução
de aplicações</li><li>melhora o desempenho do cluster através do fechamento de <em>watches</em> de ConfigMaps marcados
como imutáveis, diminuindo significativamente a carga no kube-apiserver</li></ul><p>Essa funcionalidade é controlada pelo <a href=/docs/reference/command-line-tools-reference/feature-gates/>feature gate</a>
<code>ImmutableEphemeralVolumes</code>. É possível criar um ConfigMap imutável adicionando o campo
<code>immutable</code> e marcando seu valor com <code>true</code>.
Por exemplo:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>immutable</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Após um ConfigMap ser marcado como imutável, <em>não</em> é possível reverter a alteração, nem
alterar o conteúdo dos campos <code>data</code> ou <code>binaryData</code>. É possível apenas apagar e recriar
o ConfigMap. Como Pods existentes que consomem o ConfigMap em questão mantém um ponto de
montagem que continuará referenciando este objeto após a remoção, é recomendado recriar
estes pods.</p><h2 id=próximos-passos>Próximos passos</h2><ul><li>Leia sobre <a href=/docs/concepts/configuration/secret/>Secrets</a> (em inglês).</li><li>Leia <a href=/docs/tasks/configure-pod-container/configure-pod-configmap/>Configure a Pod to Use a ConfigMap</a> (em inglês).</li><li>Leia <a href=https://12factor.net/>The Twelve-Factor App</a> (em inglês) para entender a motivação da separação de código
e configuração.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-e511ed821ada65d0053341dbd8ad2bb5>3 - Secrets</h1><p>Um Secret é um objeto que contém uma pequena quantidade de informação sensível,
como senhas, tokens ou chaves. Este tipo de informação poderia, em outras
circunstâncias, ser colocada diretamente em uma configuração de
<a class=glossary-tooltip title='O menor e mais simples objeto Kubernetes. Um Pod representa um conjunto de contêineres em execução no seu cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/ target=_blank aria-label=Pod>Pod</a> ou em uma
<a class=glossary-tooltip title='Instância armazenada de um contêiner que contém o conjunto de softwares necessários para rodar uma aplicação.' data-toggle=tooltip data-placement=top href='/pt-br/docs/reference/glossary/?all=true#term-image' target=_blank aria-label='imagem de contêiner'>imagem de contêiner</a>. O uso de
Secrets evita que você tenha de incluir dados confidenciais no seu código.</p><p>Secrets podem ser criados de forma independente dos Pods que os consomem. Isto
reduz o risco de que o Secret e seus dados sejam expostos durante o processo de
criação, visualização e edição ou atualização de Pods. O Kubernetes e as
aplicações que rodam no seu cluster podem também tomar outras precauções com
Secrets, como por exemplo evitar a escrita de dados confidenciais em local de
armazenamento persistente (não-volátil).</p><p>Secrets são semelhantes a
<a class=glossary-tooltip title='Um objeto da API usado para armazenar dados não-confidenciais em pares chave-valor. Pode ser consumido como variáveis de ambiente, argumentos de linha de comando, ou arquivos de configuração em um volume.' data-toggle=tooltip data-placement=top href=/pt-br/docs/concepts/configuration/configmap target=_blank aria-label=ConfigMaps>ConfigMaps</a>, mas foram
especificamente projetados para conter dados confidenciais.</p><div class="alert alert-warning caution callout" role=alert><strong>Cuidado:</strong><p>Os Secrets do Kubernetes são, por padrão, gravados não-encriptados no sistema
de armazenamento de dados utilizado pelo servidor da API (etcd). Qualquer pessoa
com acesso à API ou ao etcd consegue obter ou modificar um Secret.
Além disso, qualquer pessoa que possui autorização para criar Pods em um namespace
consegue utilizar este privilégio para ler qualquer Secret naquele namespace. Isso
inclui acesso indireto, como por exemplo a permissão para criar Deployments.</p><p>Para utilizar Secrets de forma segura, siga pelo menos as instruções abaixo:</p><ol><li><a href=/docs/tasks/administer-cluster/encrypt-data/>Habilite encriptação em disco</a> para Secrets.</li><li>Habilite ou configure <a href=/docs/reference/access-authn-authz/authorization/>regras de RBAC</a>
que restrinjam o acesso de leitura a Secrets (incluindo acesso indireto).</li><li>Quando apropriado, utilize mecanismos como RBAC para limitar quais perfis e
usuários possuem permissão para criar novos Secrets ou substituir Secrets
existentes.</li></ol></div><p>Consulte <a href=#information-security-for-secrets>Segurança da informação para Secrets</a>
para mais detalhes.</p><h2 id=usos-para-secrets>Usos para Secrets</h2><p>Existem três formas principais para um Pod utilizar um Secret:</p><ul><li>Como <a href=#using-secrets-as-files-from-a-pod>arquivos</a> em um
<a class=glossary-tooltip title='Um diretório contendo dados, accessível aos contêineres em um pod.' data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/ target=_blank aria-label=volume>volume</a> montado em um ou mais de
seus contêineres.</li><li>Como uma <a href=#using-secrets-as-environment-variables>variável de ambiente</a> de um
contêiner.</li><li>Pelo <a href=#using-imagepullsecrets>kubelet ao baixar imagens de contêiner</a> para o
Pod.</li></ul><p>A camada de gerenciamento do Kubernetes também utiliza Secrets. Por exemplo,
os <a href=#bootstrap-token-secrets>Secrets de tokens de autoinicialização</a> são um
mecanismo que auxilia a automação do registro de nós.</p><h3 id=alternativas-a-secrets>Alternativas a Secrets</h3><p>Ao invés de utilizar um Secret para proteger dados confidenciais, você pode
escolher uma maneira alternativa. Algumas das opções são:</p><ul><li>se o seu componente cloud native precisa autenticar-se a outra aplicação que
está rodando no mesmo cluster Kubernetes, você pode utilizar uma
<a href=/pt-br/docs/reference/access-authn-authz/authentication/#tokens-de-contas-de-servi%C3%A7o>ServiceAccount</a>
e seus tokens para identificar seu cliente.</li><li>existem ferramentas fornecidas por terceiros que você pode rodar, no seu
cluster ou externamente, que providenciam gerenciamento de Secrets. Por exemplo,
um serviço que Pods accessam via HTTPS, que revelam um Secret se o cliente
autenticar-se corretamente (por exemplo, utilizando um token de ServiceAccount).</li><li>para autenticação, você pode implementar um serviço de assinatura de
certificados X.509 personalizado, e utilizar
<a href=/docs/reference/access-authn-authz/certificate-signing-requests/>CertificateSigningRequests</a>
para permitir ao serviço personalizado emitir certificados a pods que os
necessitam.</li><li>você pode utilizar um <a href=/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/>plugin de dispositivo</a>
para expor a um Pod específico um hardware de encriptação conectado a um nó. Por
exemplo, você pode agendar Pods confiáveis em nós que oferecem um <em>Trusted
Platform Module</em>, configurado em um fluxo de dados independente.</li></ul><p>Você pode também combinar duas ou mais destas opções, incluindo a opção de
utilizar objetos do tipo Secret.</p><p>Por exemplo: implemente (ou instale) um
<a class=glossary-tooltip title='Um controlador especializado que gerencia um recurso personalizado.' data-toggle=tooltip data-placement=top href=/pt-br/docs/concepts/extend-kubernetes/operator/ target=_blank aria-label=operador>operador</a>
que solicite tokens de sessão de curta duração a um serviço externo, e crie
Secrets baseado nestes tokens. Pods rodando no seu cluster podem fazer uso de
tokens de sessão, e o operador garante que estes permanecem válidos. Esta
separação significa que você pode rodar Pods que não precisam ter conhecimento
do mecanismo exato para geração e atualização de tais tokens de sessão.</p><h2 id=trabalhando-com-secrets>Trabalhando com Secrets</h2><h3 id=criando-um-secret>Criando um Secret</h3><p>Existem diversas formas de criar um Secret:</p><ul><li><a href=/pt-br/docs/tasks/configmap-secret/managing-secret-using-kubectl/>crie um Secret utilizando o comando <code>kubectl</code></a></li><li><a href=/pt-br/docs/tasks/configmap-secret/managing-secret-using-config-file/>crie um Secret a partir de um arquivo de configuração</a></li><li><a href=/pt-br/docs/tasks/configmap-secret/managing-secret-using-kustomize/>crie um Secret utilizando a ferramenta kustomize</a></li></ul><h4 id=restriction-names-data>Restrições de nomes de Secret e dados</h4><p>O nome de um Secret deve ser um <a href=/pt-br/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>subdomínio DNS válido</a>.</p><p>Você pode especificar o campo <code>data</code> e/ou o campo <code>stringData</code> na criação de um
arquivo de configuração de um Secret. Ambos os campos <code>data</code> e <code>stringData</code> são
opcionais. Os valores das chaves no campo <code>data</code> devem ser strings codificadas
no formato base64. Se a conversão para base64 não for desejável, você pode
optar por informar os dados no campo <code>stringData</code>, que aceita strings arbitrárias
como valores.</p><p>As chaves dos campos <code>data</code> e <code>stringData</code> devem consistir de caracteres
alfanuméricos, <code>-</code>, <code>_</code>, ou <code>.</code>. Todos os pares chave-valor no campo <code>stringData</code>
são internamente combinados com os dados do campo <code>data</code>. Se uma chave aparece
em ambos os campos, o valor informado no campo <code>stringData</code> tem a precedência.</p><h4 id=restriction-data-size>Limite de tamanho</h4><p>Secrets individuais são limitados a 1MiB em tamanho. Esta limitação tem por
objetivo desencorajar a criação de Secrets muito grandes que possam exaurir a
memória do servidor da API e do kubelet. No entanto, a criação de vários Secrets
pequenos também pode exaurir a memória. Você pode utilizar uma
<a href=/pt-br/docs/concepts/policy/resource-quotas/>cota de recurso</a> a fim de limitar
o número de Secrets (ou outros recursos) em um namespace.</p><h3 id=editando-um-secret>Editando um Secret</h3><p>Você pode editar um Secret existente utilizando kubectl:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl edit secrets mysecret
</span></span></code></pre></div><p>Este comando abre o seu editor padrão configurado e permite a modificação dos
valores do Secret codificados em base64 no campo <code>data</code>. Por exemplo:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#080;font-style:italic># Please edit the object below. Lines beginning with a &#39;#&#39; will be ignored,</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># and an empty file will abort the edit. If an error occurs while saving this file, it will be</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># reopened with the relevant failures.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>username</span>:<span style=color:#bbb> </span>YWRtaW4=<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>password</span>:<span style=color:#bbb> </span>MWYyZDFlMmU2N2Rm<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubectl.kubernetes.io/last-applied-configuration</span>:<span style=color:#bbb> </span>{<span style=color:#bbb> </span>... }<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2016-01-22T18:41:56Z<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;164619&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>cfee02d6-c137-11e5-8d73-42010af00002<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Opaque<span style=color:#bbb>
</span></span></span></code></pre></div><p>Este manifesto de exemplo define um Secret com duas chaves no campo <code>data</code>:
<code>username</code> and <code>password</code>.
Os valores são strings codificadas em formato base64. No entanto, quando um
Secret é utilizado em um Pod, o kubelet fornece os dados <em>decodificados</em> ao Pod
e seus contêineres.</p><p>Você pode especificar muitas chaves e valores em um Secret só, ou utilizar
muitos Secrets. Escolha a opção que for mais conveniente para o caso de uso.</p><h3 id=utilizando-secrets>Utilizando Secrets</h3><p>Secrets podem ser montados como volumes de dados ou expostos como
<a class=glossary-tooltip title='Variáveis de ambiente de contêineres são pares nome=valor que trazem informações úteis para os contêineres rodando dentro de um Pod.' data-toggle=tooltip data-placement=top href=/pt-br/docs/concepts/containers/container-environment/ target=_blank aria-label='variáveis de ambiente'>variáveis de ambiente</a>
para serem utilizados num container de um Pod. Secrets também podem ser
utilizados por outras partes do sistema, sem serem diretamente expostos ao Pod.
Por exemplo, Secrets podem conter credenciais que outras partes do sistema devem
utilizar para interagir com sistemas externos no lugar do usuário.</p><p>Secrets montados como volumes são verificados para garantir que o nome
referenciado realmente é um objeto do tipo Secret. Portanto, um Secret deve ser
criado antes de quaisquer Pods que dependem deste Secret.</p><p>Se um Secret não puder ser encontrado (porque não existe, ou devido a um problema
de conectividade com o servidor da API) o kubelet tenta periodicamente reiniciar
aquele Pod. O kubelet também relata um evento para aquele Pod, incluindo detalhes
do problema ao buscar o Secret.</p><h4 id=restriction-secret-must-exist>Secrets Opcionais</h4><p>Quando você define uma variável de ambiente em um contêiner baseada em um Secret,
você pode especificar que o Secret em questão será <em>opcional</em>. O padrão é o
Secret ser requerido.</p><p>Nenhum dos contêineres de um Pod irão inicializar até que todos os Secrets
requeridos estejam disponíveis.</p><p>Se um Pod referencia uma chave específica em um Secret e o Secret existe, mas
não possui a chave com o nome referenciado, o Pod falha durante a inicialização.</p><h3 id=using-secrets-as-files-from-a-pod>Utilizando Secrets como arquivos em um Pod</h3><p>Se você deseja acessar dados de um Secret em um Pod, uma das formas de consumir
esta informação é fazer com que o Kubernetes deixe o valor daquele Secret
disponível como um arquivo dentro do sistema de arquivos de um ou mais dos
contêineres daquele Pod.</p><p>Para configurar isso:</p><ol><li>Crie um Secret ou utilize um previamente existente. Múltiplos Pods podem
referenciar o mesmo secret.</li><li>Modifique sua definição de Pod para adicionar um volume na lista
<code>.spec.volumes[]</code>. Escolha um nome qualquer para o seu volume e adicione um
campo <code>.spec.volumes[].secret.secretName</code> com o mesmo valor do seu objeto
Secret.</li><li>Adicione um ponto de montagem de volume à lista
<code>.spec.containers[].volumeMounts[]</code> de cada contêiner que requer o Secret.
Especifique <code>.spec.containers[].volumeMounts[].readOnly = true</code> e especifique o
valor do campo <code>.spec.containers[].volumeMounts[].mountPath</code> com o nome de um
diretório não utilizado onde você deseja que os Secrets apareçam.</li><li>Modifique sua imagem ou linha de comando de modo que o programa procure por
arquivos naquele diretório. Cada chave no campo <code>data</code> se torna um nome de
arquivo no diretório especificado em <code>mountPath</code>.</li></ol><p>Este é um exemplo de Pod que monta um Secret de nome <code>mysecret</code> em um volume:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/foo&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb> </span><span style=color:#080;font-style:italic># configuração padrão; &#34;mysecret&#34; precisa existir</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Cada Secret que você deseja utilizar deve ser referenciado na lista
<code>.spec.volumes</code>.</p><p>Se existirem múltiplos contêineres em um Pod, cada um dos contêineres
necessitará seu próprio bloco <code>volumeMounts</code>, mas somente um volume na lista
<code>.spec.volumes</code> é necessário por Secret.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong><p>Versões do Kubernetes anteriores a v1.22 criavam automaticamente credenciais
para acesso à API do Kubernetes. Este mecanismo antigo era baseado na criação de
Secrets com tokens que podiam então ser montados em Pods em execução.
Em versões mais recentes, incluindo o Kubernetes v1.25,
credenciais para acesso à API são obtidas diretamente através da API
<a href=/docs/reference/kubernetes-api/authentication-resources/token-request-v1/>TokenRequest</a>
e são montadas em Pods utilizando um
<a href=/docs/reference/access-authn-authz/service-accounts-admin/#bound-service-account-token-volume>volume projetado</a>.
Os tokens obtidos através deste método possuem tempo de vida limitado e são
automaticamente invalidados quando o Pod em que estão montados é removido.</p><p>Você ainda pode
<a href=/docs/tasks/configure-pod-container/configure-service-account/#manually-create-a-service-account-api-token>criar manualmente</a>
um Secret de token de service account se você precisa de um token que não expire,
por exemplo. No entanto, o uso do subrecurso
<a href=/docs/reference/kubernetes-api/authentication-resources/token-request-v1/>TokenRequest</a>
é recomendado para obtenção de um token para acesso à API ao invés do uso de
Secrets de token de service account.</p></div><h4 id=projeção-de-chaves-de-secrets-em-caminhos-específicos>Projeção de chaves de Secrets em caminhos específicos</h4><p>Você pode também controlar os caminhos dentro do volume onde as chaves do Secret
são projetadas. Você pode utilizar o campo <code>.spec.volumes[].secret.items</code> para
mudar o caminho de destino de cada chave:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/foo&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>username<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>my-group/my-username<span style=color:#bbb>
</span></span></span></code></pre></div><p>Neste caso:</p><ul><li>O valor da chave <code>username</code> é armazenado no arquivo
<code>/etc/foo/my-group/my-username</code> ao invés de <code>/etc/foo/username</code>.</li><li>O valor da chave <code>password</code> não é projetado no sistema de arquivos.</li></ul><p>Se <code>.spec.volumes[].secret.items</code> for utilizado, somente chaves especificadas
na lista <code>items</code> são projetadas. Para consumir todas as chaves do Secret, deve
haver um item para cada chave no campo <code>items</code>.</p><p>Se você listar as chaves explicitamente, então todas as chaves listadas precisam
existir no Secret correspondente. Caso contrário, o volume não é criado.</p><h4 id=permissões-de-arquivos-de-secret>Permissões de arquivos de Secret</h4><p>Você pode trocar os bits de permissão POSIX de uma chave avulsa de Secret.
Se nenhuma permissão for especificada, <code>0644</code> é utilizado por padrão.
Você pode também especificar uma permissão padrão para o volume inteiro de
Secret e sobrescrever esta permissão por chave, se necessário.</p><p>Por exemplo, você pode especificar uma permissão padrão da seguinte maneira:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/foo&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>defaultMode</span>:<span style=color:#bbb> </span><span style=color:#666>0400</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Dessa forma, o Secret será montado em <code>/etc/foo</code> e todos os arquivos criados
no volume terão a permissão <code>0400</code>.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Se você estiver definindo um Pod ou um template de Pod utilizando JSON, observe
que a especificação JSON não suporta a notação octal. Você pode utilizar o valor
decimal para o campo <code>defaultMode</code> (por exemplo, 0400 em base octal equivale a
256 na base decimal).<br>Se você estiver escrevendo YAML, você pode escrever o valor para <code>defaultMode</code>
em octal.</div><h4 id=consumindo-valores-de-secrets-em-volumes>Consumindo valores de Secrets em volumes</h4><p>Dentro do contêiner que monta um volume de Secret, as chaves deste Secret
aparecem como arquivos e os valores dos Secrets são decodificados do formato
base64 e armazenados dentro destes arquivos.</p><p>Ao executar comandos dentro do contêiner do exemplo anterior, obteremos os
seguintes resultados:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>ls /etc/foo
</span></span></code></pre></div><p>O resultado é semelhante a:</p><pre tabindex=0><code>username
password
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat /etc/foo/username
</span></span></code></pre></div><p>O resultado é semelhante a:</p><pre tabindex=0><code>admin
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat /etc/foo/password
</span></span></code></pre></div><p>O resultado é semelhante a:</p><pre tabindex=0><code>1f2d1e2e67df
</code></pre><p>A aplicação rodando dentro do contêiner é responsável pela leitura dos Secrets
dentro dos arquivos.</p><h4 id=secrets-montados-são-atualizados-automaticamente>Secrets montados são atualizados automaticamente</h4><p>Quando um volume contém dados de um Secret, e o Secret referenciado é atualizado,
o Kubernetes rastreia a atualização e atualiza os dados no volume, utilizando
uma abordagem de consistência eventual.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Um contêiner que utiliza Secrets através de um volume montado com a propriedade
<a href=/docs/concepts/storage/volumes#using-subpath><code>subPath</code></a> não recebe
atualizações automatizadas para este Secret.</div><p>O kubelet mantém um cache das chaves e valores atuais dos Secrets que são
utilizados em volumes de Pods daquele nó. Você pode configurar a forma que o
kubelet detecta diferenças dos valores armazenados em cache. O campo
<code>configMapAndSecretDetectionStrategy</code> na
<a href=/docs/reference/config-api/kubelet-config.v1beta1/>configuração do kubelet</a>
controla qual estratégia o kubelet usa. A estratégia padrão é <code>Watch</code>.</p><p>Atualizações em Secrets podem ser propagadas por um mecanismo de observação da
API (estratégia padrão), baseado em cache com um tempo de expiração definido
(<em>time-to-live</em>), ou solicitado diretamente ao servidor da API do cluster a cada
iteração do ciclo de sincronização do kubelet.</p><p>Como resultado, o atraso total entre o momento em que o Secret foi atualizado
até o momento em que as novas chaves são projetadas no Pod pode ser tão longo
quanto a soma do tempo de sincronização do kubelet somado ao tempo de atraso de
propagação do cache, onde o atraso de propagação do cache depende do tipo de
cache escolhido. Seguindo a mesma ordem listada no parágrafo anterior, estes
valores são: atraso de propagação via <em>watch</em>, tempo de expiração configurado no
cache (<em>time-to-live</em>, ou TTL), ou zero para solicitação direta ao servidor da
API.</p><h3 id=using-secrets-as-environment-variables>Utilizando Secrets como variáveis de ambiente</h3><p>Para utilizar um secret em uma <a class=glossary-tooltip title='Variáveis de ambiente de contêineres são pares nome=valor que trazem informações úteis para os contêineres rodando dentro de um Pod.' data-toggle=tooltip data-placement=top href=/pt-br/docs/concepts/containers/container-environment/ target=_blank aria-label='variável de ambiente'>variável de ambiente</a>
em um Pod:</p><ol><li>Crie um Secret ou utilize um já existente. Múltiplos Pods podem referenciar o
mesmo Secret.</li><li>Modifique a definição de cada contêiner do Pod em que desejar consumir o
Secret, adicionando uma variável de ambiente para cada uma das chaves que
deseja consumir.
A variável de ambiente que consumir o valor da chave em questão deverá
popular o nome do Secret e a sua chave correspondente no campo
<code>env[].valueFrom.secretKeyRef</code>.</li><li>Modifique sua imagem de contêiner ou linha de comando de forma que o programa
busque os valores nas variáveis de ambiente especificadas.</li></ol><p>Este é um exemplo de um Pod que utiliza Secrets em variáveis de ambiente:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-env-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mycontainer<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>SECRET_USERNAME<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>secretKeyRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>username<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>optional</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># valor padrão; &#34;mysecret&#34; deve existir</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                          </span><span style=color:#080;font-style:italic># e incluir uma chave com o nome &#34;username&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>SECRET_PASSWORD<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>secretKeyRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>password<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>optional</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># valor padrão; &#34;mysecret&#34; deve existir</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                          </span><span style=color:#080;font-style:italic># e incluir uma chave com o nome &#34;password&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></span></span></code></pre></div><h4 id=restriction-env-from-invalid>Variáveis de ambiente inválidas</h4><p>Secrets utilizados para popular variáveis de ambiente através do campo <code>envFrom</code>
que possuem chaves consideradas inválidas para nomes de variáveis de ambiente
têm tais chaves ignoradas. O Pod irá iniciar normalmente.</p><p>Se você definir um Pod contendo um nome de variável de ambiente inválido, os
eventos de inicialização do Pod incluirão um evento com a razão
<code>InvalidVariableNames</code> e uma mensagem que lista as chaves inválidas ignoradas.
O exemplo abaixo demonstra um Pod que referencia um Secret chamado <code>mysecret</code>,
onde <code>mysecret</code> contém duas chaves inválidas: <code>1badkey</code> and <code>2alsobad</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get events
</span></span></code></pre></div><p>O resultado é semelhante a:</p><pre tabindex=0><code>LASTSEEN   FIRSTSEEN   COUNT     NAME            KIND      SUBOBJECT                         TYPE      REASON
0s         0s          1         dapi-test-pod   Pod                                         Warning   InvalidEnvironmentVariableNames   kubelet, 127.0.0.1      Keys [1badkey, 2alsobad] from the EnvFrom secret default/mysecret were skipped since they are considered invalid environment variable names.
</code></pre><h4 id=consumindo-valores-de-secret-em-variáveis-de-ambiente>Consumindo valores de Secret em variáveis de ambiente</h4><p>Dentro de um contêiner que consome um Secret em variáveis de ambiente, as chaves
do Secret aparecem como variáveis de ambiente comuns, contendo os dados do
Secret decodificados do formato base64. Ao executar comandos no contêiner do
exemplo anterior, obteremos os resultados abaixo:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b8860b>$SECRET_USERNAME</span>
</span></span></code></pre></div><p>O resultado é semelhante a:</p><pre tabindex=0><code>admin
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b8860b>$SECRET_PASSWORD</span>
</span></span></code></pre></div><p>O resultado é semelhante a:</p><pre tabindex=0><code>1f2d1e2e67df
</code></pre><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Se um contêiner já consome um Secret em uma variável de ambiente, uma
atualização do Secret não será detectada pelo contêiner a menos que este seja
reiniciado. Há soluções de terceiros que fornecem a funcionalidade de
reinicialização automática de Pods quando o valor dos Secrets mudam.</div><h3 id=using-imagepullsecrets>Secrets para obtenção de imagens de contêiner</h3><p>Se você deseja obter imagens de contêiner de um repositório privado, você
precisa fornecer ao kubelet uma maneira de se autenticar a este repositório.
Você pode configurar o campo <code>imagePullSecrets</code> para esta finalidade. Estes
Secrets são configurados a nível de Pod.</p><p>O campo <code>imagePullSecrets</code> de um Pod é uma lista de referências a Secrets
no mesmo namespace que o Pod.
Você pode utilizar <code>imagePullSecrets</code> para enviar credenciais para acesso a um
registro de contêineres ao kubelet. O kubelet utiliza essa informação para
baixar uma imagem privada no lugar do seu Pod.
Veja o campo <code>PodSpec</code> na
<a href=/docs/reference/kubernetes-api/workload-resources/pod-v1/#PodSpec>referência da API de Pods</a>
para maiores detalhes sobre o campo <code>imagePullSecrets</code>.</p><h4 id=usando-imagepullsecrets>Usando <code>imagePullSecrets</code></h4><p>O campo <code>imagePullSecrets</code> é uma lista de referências a Secrets no mesmo
namespace.
Você pode utilizar o campo <code>imagePullSecrets</code> para enviar um Secret que contém
uma senha para um registro de imagens de contêiner do Docker (ou outro registro
de imagens de contêiner). O kubelet utiliza essa informação para baixar uma
imagem privada no lugar do seu Pod.
Veja a <a href=/docs/reference/generated/kubernetes-api/v1.25/#podspec-v1-core>API <code>PodSpec</code></a>
para mais informações sobre o campo <code>imagePullSecrets</code>.</p><h5 id=especificando-imagepullsecrets-manualmente>Especificando <code>imagePullSecrets</code> manualmente</h5><p>Você pode ler sobre como especificar <code>imagePullSecrets</code> em um Pod na
<a href=/pt-br/docs/concepts/containers/images/#especificando-imagepullsecrets-em-um-pod>documentação de imagens de contêiner</a>.</p><h5 id=configurando-imagepullsecrets-para-serem-adicionados-automaticamente>Configurando <code>imagePullSecrets</code> para serem adicionados automaticamente</h5><p>Você pode criar manualmente <code>imagePullSecrets</code> e referenciá-los em uma
ServiceAccount. Quaisquer Pods criados com esta ServiceAccount, especificada
explicitamente ou por padrão, têm o campo <code>imagePullSecrets</code> populado com os
mesmos valores existentes na service account.
Veja <a href=/docs/tasks/configure-pod-container/configure-service-account/#add-imagepullsecrets-to-a-service-account>adicionando <code>imagePullSecrets</code> a uma service account</a>
para uma explicação detalhada do processo.</p><h3 id=restriction-static-pod>Utilizando Secrets com pods estáticos</h3><p>Você não pode utilizar ConfigMaps ou Secrets em
<a class=glossary-tooltip title='Um pod gerenciado diretamente pelo daemon do kubelet em um nó específico.' data-toggle=tooltip data-placement=top href=/docs/tasks/configure-pod-container/static-pod/ target=_blank aria-label='Pods estáticos'>Pods estáticos</a>.</p><h2 id=casos-de-uso>Casos de uso</h2><h3 id=caso-de-uso-como-variáveis-de-ambiente-em-um-contêiner>Caso de uso: Como variáveis de ambiente em um contêiner</h3><p>Crie um manifesto de Secret</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Opaque<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>USER_NAME</span>:<span style=color:#bbb> </span>YWRtaW4=<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>PASSWORD</span>:<span style=color:#bbb> </span>MWYyZDFlMmU2N2Rm<span style=color:#bbb>
</span></span></span></code></pre></div><p>Crie o Secret no seu cluster:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f mysecret.yaml
</span></span></code></pre></div><p>Utilize <code>envFrom</code> para definir todos os dados do Secret como variáveis de
ambiente do contêiner. Cada chave do Secret se torna o nome de uma variável de
ambiente no Pod.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-test-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;/bin/sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;env&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>envFrom</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>secretRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=caso-de-uso-pod-com-chaves-ssh>Caso de uso: Pod com chaves SSH</h3><p>Crie um Secret contendo chaves SSH:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret generic ssh-key-secret --from-file<span style=color:#666>=</span>ssh-privatekey<span style=color:#666>=</span>/path/to/.ssh/id_rsa --from-file<span style=color:#666>=</span>ssh-publickey<span style=color:#666>=</span>/path/to/.ssh/id_rsa.pub
</span></span></code></pre></div><p>O resultado é semelhante a:</p><pre tabindex=0><code>secret &#34;ssh-key-secret&#34; created
</code></pre><p>Você também pode criar um manifesto <code>kustomization.yaml</code> com um campo
<code>secretGenerator</code> contendo chaves SSH.</p><div class="alert alert-warning caution callout" role=alert><strong>Cuidado:</strong><p>Analise cuidadosamente antes de enviar suas próprias chaves SSH: outros usuários
do cluster podem ter acesso a este Secret.</p><p>Como alternativa, você pode criar uma chave SSH privada representando a
identidade de um serviço que você deseja que seja acessível a todos os usuários
com os quais você compartilha o cluster do Kubernetes em questão. Desse modo,
você pode revogar esta credencial em caso de comprometimento.</p></div><p>Agora você pode criar um Pod que referencia o Secret com a chave SSH e consome-o
em um volume:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-test-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>ssh-key-secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>ssh-test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>mySshImage<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/secret-volume&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Ao rodar o comando do contêiner, as partes da chave estarão disponíveis em:</p><pre tabindex=0><code>/etc/secret-volume/ssh-publickey
/etc/secret-volume/ssh-privatekey
</code></pre><p>O contêiner então pode utilizar os dados do secret para estabelecer uma conexão
SSH.</p><h3 id=caso-de-uso-pods-com-credenciais-de-ambientes-de-produção-ou-testes>Caso de uso: Pods com credenciais de ambientes de produção ou testes</h3><p>Este exemplo ilustra um Pod que consome um Secret contendo credenciais de um
ambiente de produção e outro Pod que consome um Secret contendo credenciais de
um ambiente de testes.</p><p>Você pode criar um manifesto <code>kustomization.yaml</code> com um <code>secretGenerator</code> ou
rodar <code>kubectl create secret</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret generic prod-db-secret --from-literal<span style=color:#666>=</span><span style=color:#b8860b>username</span><span style=color:#666>=</span>produser --from-literal<span style=color:#666>=</span><span style=color:#b8860b>password</span><span style=color:#666>=</span>Y4nys7f11
</span></span></code></pre></div><p>O resultado é semelhante a:</p><pre tabindex=0><code>secret &#34;prod-db-secret&#34; created
</code></pre><p>Você pode também criar um Secret com credenciais para o ambiente de testes.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret generic test-db-secret --from-literal<span style=color:#666>=</span><span style=color:#b8860b>username</span><span style=color:#666>=</span>testuser --from-literal<span style=color:#666>=</span><span style=color:#b8860b>password</span><span style=color:#666>=</span>iluvtests
</span></span></code></pre></div><p>O resultado é semelhante a:</p><pre tabindex=0><code>secret &#34;test-db-secret&#34; created
</code></pre><div class="alert alert-info note callout" role=alert><strong>Nota:</strong><p>Caracteres especiais como <code>$</code>, <code>\</code>, <code>*</code>, <code>+</code> e <code>!</code> serão interpretados pelo seu
<a href=https://pt.wikipedia.org/wiki/Shell_(computa%C3%A7%C3%A3o)>shell</a> e precisam
de sequências de escape.</p><p>Na maioria dos shells, a forma mais fácil de gerar sequências de escape para
suas senhas é escrevê-las entre aspas simples (<code>'</code>). Por exemplo, se a sua senha
for <code>S!B\*d$zDsb=</code>, você deve executar o comando da seguinte forma:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret generic dev-db-secret --from-literal<span style=color:#666>=</span><span style=color:#b8860b>username</span><span style=color:#666>=</span>devuser --from-literal<span style=color:#666>=</span><span style=color:#b8860b>password</span><span style=color:#666>=</span><span style=color:#b44>&#39;S!B\*d$zDsb=&#39;</span>
</span></span></code></pre></div><p>Não é necessário gerar sequências de escape para caracteres especiais em arquivos
(utilizados com a opção <code>--from-file</code>).</p></div><p>Agora, crie os Pods:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt; pod.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: List
</span></span></span><span style=display:flex><span><span style=color:#b44>items:
</span></span></span><span style=display:flex><span><span style=color:#b44>- kind: Pod
</span></span></span><span style=display:flex><span><span style=color:#b44>  apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>  metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>    name: prod-db-client-pod
</span></span></span><span style=display:flex><span><span style=color:#b44>    labels:
</span></span></span><span style=display:flex><span><span style=color:#b44>      name: prod-db-client
</span></span></span><span style=display:flex><span><span style=color:#b44>  spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>    volumes:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - name: secret-volume
</span></span></span><span style=display:flex><span><span style=color:#b44>      secret:
</span></span></span><span style=display:flex><span><span style=color:#b44>        secretName: prod-db-secret
</span></span></span><span style=display:flex><span><span style=color:#b44>    containers:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - name: db-client-container
</span></span></span><span style=display:flex><span><span style=color:#b44>      image: myClientImage
</span></span></span><span style=display:flex><span><span style=color:#b44>      volumeMounts:
</span></span></span><span style=display:flex><span><span style=color:#b44>      - name: secret-volume
</span></span></span><span style=display:flex><span><span style=color:#b44>        readOnly: true
</span></span></span><span style=display:flex><span><span style=color:#b44>        mountPath: &#34;/etc/secret-volume&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44>- kind: Pod
</span></span></span><span style=display:flex><span><span style=color:#b44>  apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>  metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>    name: test-db-client-pod
</span></span></span><span style=display:flex><span><span style=color:#b44>    labels:
</span></span></span><span style=display:flex><span><span style=color:#b44>      name: test-db-client
</span></span></span><span style=display:flex><span><span style=color:#b44>  spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>    volumes:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - name: secret-volume
</span></span></span><span style=display:flex><span><span style=color:#b44>      secret:
</span></span></span><span style=display:flex><span><span style=color:#b44>        secretName: test-db-secret
</span></span></span><span style=display:flex><span><span style=color:#b44>    containers:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - name: db-client-container
</span></span></span><span style=display:flex><span><span style=color:#b44>      image: myClientImage
</span></span></span><span style=display:flex><span><span style=color:#b44>      volumeMounts:
</span></span></span><span style=display:flex><span><span style=color:#b44>      - name: secret-volume
</span></span></span><span style=display:flex><span><span style=color:#b44>        readOnly: true
</span></span></span><span style=display:flex><span><span style=color:#b44>        mountPath: &#34;/etc/secret-volume&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>Adicione os Pods a um manifesto <code>kustomization.yaml</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt;&gt; kustomization.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>resources:
</span></span></span><span style=display:flex><span><span style=color:#b44>- pod.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>Crie todos estes objetos no servidor da API rodando o comando:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -k .
</span></span></code></pre></div><p>Ambos os contêineres terão os seguintes arquivos presentes nos seus sistemas de
arquivos, com valores para cada um dos ambientes dos contêineres:</p><pre tabindex=0><code>/etc/secret-volume/username
/etc/secret-volume/password
</code></pre><p>Observe como as <code>spec</code>s para cada um dos Pods diverge somente em um campo. Isso
facilita a criação de Pods com capacidades diferentes a partir de um template
mais genérico.</p><p>Você pode simplificar ainda mais a definição básica do Pod através da utilização
de duas service accounts diferentes:</p><ol><li><code>prod-user</code> com o Secret <code>prod-db-secret</code></li><li><code>test-user</code> com o Secret <code>test-db-secret</code></li></ol><p>A especificação do Pod é reduzida para:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>prod-db-client-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>prod-db-client<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>serviceAccount</span>:<span style=color:#bbb> </span>prod-db-client<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>db-client-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>myClientImage<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=caso-de-uso-dotfiles-em-um-volume-de-secret>Caso de uso: <em>dotfiles</em> em um volume de Secret</h3><p>Você pode fazer com que seus dados fiquem "ocultos" definindo uma chave que se
inicia com um ponto (<code>.</code>). Este tipo de chave representa um <em>dotfile</em>, ou
arquivo "oculto". Por exemplo, quando o Secret abaixo é montado em um volume,
<code>secret-volume</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dotfile-secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>.secret-file</span>:<span style=color:#bbb> </span>dmFsdWUtMg0KDQo=<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-dotfiles-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>dotfile-secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dotfile-test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- ls<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;-l&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;/etc/secret-volume&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/secret-volume&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Este volume irá conter um único arquivo, chamado <code>.secret-file</code>, e o contêiner
<code>dotfile-test-container</code> terá este arquivo presente no caminho
<code>/etc/secret-volume/.secret-file</code>.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Arquivos com nomes iniciados por um caractere de ponto são ocultados do
resultado do comando <code>ls -l</code>. Você precisa utilizar <code>ls -la</code> para vê-los ao
listar o conteúdo de um diretório.</div><h3 id=use-case-secret-visible-to-one-container-in-a-pod>Caso de uso: Secret visível somente em um dos contêineres de um pod</h3><p>Suponha que um programa necessita manipular requisições HTTP, executar regras
de negócio complexas e então assinar mensagens com HMAC. Devido à natureza
complexa da aplicação, pode haver um <em>exploit</em> despercebido que lê arquivos
remotos no servidor e que poderia expor a chave privada para um invasor.</p><p>Esta aplicação poderia ser dividida em dois processos, separados em dois
contêineres distintos: um contêiner de <em>front-end</em>, que manipula as interações
com o usuário e a lógica de negócio, mas não consegue ver a chave privada; e
um contêiner assinador, que vê a chave privada e responde a requisições simples
de assinatura do <em>front-end</em> (por exemplo, através de rede local).</p><p>Com essa abordagem particionada, um invasor agora precisa forçar o servidor de
aplicação a rodar comandos arbitrários, o que é mais difícil de ser feito do que
apenas ler um arquivo presente no disco.</p><h2 id=secret-types>Tipos de Secrets</h2><p>Ao criar um Secret, você pode especificar o seu tipo utilizando o campo <code>type</code>
do objeto Secret, ou algumas opções de linha de comando equivalentes no comando
<code>kubectl</code>, quando disponíveis. O campo <code>type</code> de um Secret é utilizado para
facilitar a manipulação programática de diferentes tipos de dados confidenciais.</p><p>O Kubernetes oferece vários tipos embutidos de Secret para casos de uso comuns.
Estes tipos variam em termos de validações efetuadas e limitações que o
Kubernetes impõe neles.</p><table><thead><tr><th>Tipo embutido</th><th>Caso de uso</th></tr></thead><tbody><tr><td><code>Opaque</code></td><td>dados arbitrários definidos pelo usuário</td></tr><tr><td><code>kubernetes.io/service-account-token</code></td><td>token de service account (conta de serviço)</td></tr><tr><td><code>kubernetes.io/dockercfg</code></td><td>arquivo <code>~/.dockercfg</code> serializado</td></tr><tr><td><code>kubernetes.io/dockerconfigjson</code></td><td>arquivo <code>~/.docker/config.json</code> serializado</td></tr><tr><td><code>kubernetes.io/basic-auth</code></td><td>credenciais para autenticação básica (basic auth)</td></tr><tr><td><code>kubernetes.io/ssh-auth</code></td><td>credenciais para autenticação SSH</td></tr><tr><td><code>kubernetes.io/tls</code></td><td>dados para um cliente ou servidor TLS</td></tr><tr><td><code>bootstrap.kubernetes.io/token</code></td><td>dados de token de autoinicialização</td></tr></tbody></table><p>Você pode definir e utilizar seu próprio tipo de Secret definindo o valor do
campo <code>type</code> como uma string não-nula em um objeto Secret (uma string em branco
é tratada como o tipo <code>Opaque</code>).</p><p>O Kubernetes não restringe nomes de tipos. No entanto, quando tipos embutidos
são utilizados, você precisa atender a todos os requisitos daquele tipo.</p><p>Se você estiver definindo um tipo de Secret que seja para uso público, siga a
convenção e estruture o tipo de Secret para conter o seu domínio antes do nome,
separado por uma barra (<code>/</code>).
Por exemplo: <code>cloud-hosting.example.net/cloud-api-credentials</code>.</p><p>Para melhor desempenho em uma requisição <code>get</code> repetitiva, clientes podem criar
objetos que referenciam o Secret e então utilizar a requisição <code>watch</code> neste
novo objeto, requisitando o Secret novamente quando a referência mudar.
Além disso, uma <a href=https://git.k8s.io/design-proposals-archive/api-machinery/bulk_watch.md>API de "observação em lotes"</a>
para permitir a clientes observar recursos individuais também foi proposta e
provavelmente estará disponível em versões futuras do Kubernetes.</p><p><code>Opaque</code> é o tipo predefinido de Secret quando o campo <code>type</code> é omitido em um
arquivo de configuração de Secret. Quando um Secret é criado usando o comando
<code>kubectl</code>, você deve usar o subcomando <code>generic</code> para indicar que um Secret é
do tipo <code>Opaque</code>. Por exemplo, o comando a seguir cria um Secret vazio do tipo
<code>Opaque</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret generic empty-secret
</span></span><span style=display:flex><span>kubectl get secret empty-secret
</span></span></code></pre></div><p>O resultado será semelhante ao abaixo:</p><pre tabindex=0><code>NAME           TYPE     DATA   AGE
empty-secret   Opaque   0      2m6s
</code></pre><p>A coluna <code>DATA</code> demonstra a quantidade de dados armazenados no Secret. Neste
caso, <code>0</code> significa que este objeto Secret está vazio.</p><h3 id=secrets-de-token-de-service-account-conta-de-serviço>Secrets de token de service account (conta de serviço)</h3><p>Secrets do tipo <code>kubernetes.io/service-account-token</code> são utilizados para
armazenar um token que identifica uma service account (conta de serviço). Ao
utilizar este tipo de Secret, você deve garantir que a anotação
<code>kubernetes.io/service-account.name</code> contém um nome de uma service account
existente. Um controlador do Kubernetes preenche outros campos, como por exemplo
a anotação <code>kubernetes.io/service-account.uid</code> e a chave <code>token</code> no campo <code>data</code>
com o conteúdo do token.</p><p>O exemplo de configuração abaixo declara um Secret de token de service account:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-sa-sample<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/service-account-name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;sa-name&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>kubernetes.io/service-account-token<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># Você pode incluir pares chave-valor adicionais, da mesma forma que faria com</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># Secrets do tipo Opaque</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>extra</span>:<span style=color:#bbb> </span>YmFyCg==<span style=color:#bbb>
</span></span></span></code></pre></div><p>Ao criar um <a class=glossary-tooltip title='O menor e mais simples objeto Kubernetes. Um Pod representa um conjunto de contêineres em execução no seu cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/ target=_blank aria-label=Pod>Pod</a>, o Kubernetes
automaticamente cria um Secret de service account e automaticamente atualiza o
seu Pod para utilizar este Secret. O Secret de token de service account contém
credenciais para acessar a API.</p><p>A criação automática e o uso de credenciais de API podem ser desativados ou
substituídos se desejado. Porém, se tudo que você necessita é poder acessar o
servidor da API de forma segura, este é o processo recomendado.</p><p>Veja a documentação de
<a href=/docs/tasks/configure-pod-container/configure-service-account/>ServiceAccount</a>
para mais informações sobre o funcionamento de service accounts. Você pode
verificar também os campos <code>automountServiceAccountToken</code> e <code>serviceAccountName</code>
do <a href=/docs/reference/generated/kubernetes-api/v1.25/#pod-v1-core><code>Pod</code></a>
para mais informações sobre como referenciar service accounts em Pods.</p><h3 id=secrets-de-configuração-do-docker>Secrets de configuração do Docker</h3><p>Você pode utilizar um dos tipos abaixo para criar um Secret que armazena
credenciais para accesso a um registro de contêineres para busca de imagens:</p><ul><li><code>kubernetes.io/dockercfg</code></li><li><code>kubernetes.io/dockerconfigjson</code></li></ul><p>O tipo <code>kubernetes.io/dockercfg</code> é reservado para armazenamento de um arquivo
<code>~/.dockercfg</code> serializado. Este arquivo é o formato legado para configuração
do utilitário de linha de comando do Docker. Ao utilizar este tipo de Secret,
é preciso garantir que o campo <code>data</code> contém uma chave <code>.dockercfg</code> cujo valor
é o conteúdo do arquivo <code>~/.dockercfg</code> codificado no formato base64.</p><p>O tipo <code>kubernetes.io/dockerconfigjson</code> foi projetado para armazenamento de um
conteúdo JSON serializado que obedece às mesmas regras de formato que o arquivo
<code>~/.docker/config.json</code>. Este arquivo é um formato mais moderno para o conteúdo
do arquivo <code>~/.dockercfg</code>. Ao utilizar este tipo de Secret, o conteúdo do campo
<code>data</code> deve conter uma chave <code>.dockerconfigjson</code> em que o conteúdo do arquivo
<code>~/.docker/config.json</code> é fornecido codificado no formato base64.</p><p>Um exemplo de um Secret do tipo <code>kubernetes.io/dockercfg</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-dockercfg<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>kubernetes.io/dockercfg<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>.dockercfg</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    </span><span style=color:#bbb>    </span><span style=color:#b44>&#34;&lt;base64 encoded ~/.dockercfg file&gt;&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Se você não desejar fazer a codificação em formato base64, você pode utilizar o
campo <code>stringData</code> como alternativa.</div><p>Ao criar estes tipos de Secret utilizando um manifesto (arquivo YAML), o
servidor da API verifica se a chave esperada existe no campo <code>data</code> e se o valor
fornecido pode ser interpretado como um conteúdo JSON válido. O servidor da API
não verifica se o conteúdo informado é realmente um arquivo de configuração do
Docker.</p><p>Quando você não tem um arquivo de configuração do Docker, ou quer utilizar o
comando <code>kubectl</code> para criar um Secret de registro de contêineres, você pode
rodar o comando:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret docker-registry secret-tiger-docker <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --docker-email<span style=color:#666>=</span>tiger@acme.example <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --docker-username<span style=color:#666>=</span>tiger <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --docker-password<span style=color:#666>=</span>pass1234 <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --docker-server<span style=color:#666>=</span>my-registry.example:5000
</span></span></code></pre></div><p>Esse comando cria um secret do tipo <code>kubernetes.io/dockerconfigjson</code>. Se você
obtiver o conteúdo do campo <code>.data.dockerconfigjson</code> deste novo Secret e
decodificá-lo do formato base64:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get secret secret-tiger-docker -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.data.*}&#39;</span> | base64 -d
</span></span></code></pre></div><p>o resultado será equivalente a este documento JSON (que também é um arquivo de
configuração válido do Docker):</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;auths&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;my-registry.example:5000&#34;</span>: {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;username&#34;</span>: <span style=color:#b44>&#34;tiger&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;password&#34;</span>: <span style=color:#b44>&#34;pass1234&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;email&#34;</span>: <span style=color:#b44>&#34;tiger@acme.example&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;auth&#34;</span>: <span style=color:#b44>&#34;dGlnZXI6cGFzczEyMzQ=&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> O valor do campo <code>auth</code> no exemplo acima é codificado em base64; ele está
ofuscado mas não criptografado. Qualquer pessoa com acesso a este Secret pode
ler o conteúdo do token <em>bearer</em>.</div><h3 id=secret-de-autenticação-básica>Secret de autenticação básica</h3><p>O tipo <code>kubernetes.io/basic-auth</code> é fornecido para armazenar credenciais
necessárias para autenticação básica. Ao utilizar este tipo de Secret, o campo
<code>data</code> do Secret deve conter as duas chaves abaixo:</p><ul><li><code>username</code>: o usuário utilizado para autenticação;</li><li><code>password</code>: a senha ou token para autenticação.</li></ul><p>Ambos os valores para estas duas chaves são textos codificados em formato base64.
Você pode fornecer os valores como texto simples utilizando o campo <code>stringData</code>
na criação do Secret.</p><p>O arquivo YAML abaixo é um exemplo de configuração para um Secret de autenticação
básica:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-basic-auth<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>kubernetes.io/basic-auth<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>stringData</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>username</span>:<span style=color:#bbb> </span>admin     <span style=color:#bbb> </span><span style=color:#080;font-style:italic># required field for kubernetes.io/basic-auth</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>password</span>:<span style=color:#bbb> </span>t0p-Secret<span style=color:#bbb> </span><span style=color:#080;font-style:italic># required field for kubernetes.io/basic-auth</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>O tipo de autenticação básica é fornecido unicamente por conveniência. Você pode
criar um Secret do tipo <code>Opaque</code> utilizado para autenticação básica. No entanto,
utilizar o tipo embutido e público de Secret (<code>kubernetes.io/basic-auth</code>)
auxilia outras pessoas a compreenderem o propósito do seu Secret, e define uma
convenção de expectativa de nomes de chaves
O tipo embutido também fornece verificação dos campos requeridos pelo servidor
da API.</p><h3 id=secret-de-autenticação-ssh>Secret de autenticação SSH</h3><p>O tipo embutido <code>kubernetes.io/ssh-auth</code> é fornecido para armazenamento de dados
utilizados em autenticação SSH. Ao utilizar este tipo de Secret, você deve
especificar um par de chave-valor <code>ssh-privatekey</code> no campo <code>data</code> (ou no campo
<code>stringData</code>) com a credencial SSH a ser utilizada.</p><p>O manifesto abaixo é um exemplo de configuração para um Secret de autenticação
SSH com um par de chaves pública/privada:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-ssh-auth<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>kubernetes.io/ssh-auth<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># os dados estão abreviados neste exemplo</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ssh-privatekey</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>     </span><span style=color:#bbb>     </span>MIIEpQIBAAKCAQEAulqb/Y ...<span style=color:#bbb>
</span></span></span></code></pre></div><p>O Secret de autenticação SSH é fornecido apenas para a conveniência do usuário.
Você pode criar um Secret do tipo <code>Opaque</code> para credentials utilizadas para
autenticação SSH. No entanto, a utilização do tipo embutido e público de Secret
(<code>kubernetes.io/ssh-auth</code>) auxilia outras pessoas a compreenderem o propósito do
seu Secret, e define uma convenção de quais chaves podem ser esperadas.
O tipo embutido também fornece verificação dos campos requeridos em uma
configuração de Secret.</p><div class="alert alert-warning caution callout" role=alert><strong>Cuidado:</strong> Chaves privadas SSH não estabelecem, por si só, uma comunicação confiável
entre um cliente SSH e um servidor. Uma forma secundária de estabelecer
confiança é necessária para mitigar ataques <em>man-in-the-middle</em> (MITM), como por
exemplo um arquivo <code>known_hosts</code> adicionado a um ConfigMap.</div><h3 id=secrets-tls>Secrets TLS</h3><p>O Kubernetes fornece o tipo embutido de Secret <code>kubernetes.io/tls</code> para
armazenamento de um certificado e sua chave associada que são tipicamente
utilizados para TLS.</p><p>Uma utilização comum de Secrets TLS é a configuração de encriptação em trânsito
para um recurso <a href=/docs/concepts/services-networking/ingress/>Ingress</a>, mas
este tipo de secret pode também ser utilizado com outros recursos ou diretamente
por uma carga de trabalho.</p><p>Ao utilizar este tipo de Secret, as chaves <code>tls.key</code> e <code>tls.crt</code> devem ser
informadas no campo <code>data</code> (ou <code>stringData</code>) da configuração do Secret, embora o
servidor da API não valide o conteúdo de cada uma destas chaves.</p><p>O YAML a seguir tem um exemplo de configuração para um Secret TLS:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-tls<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>kubernetes.io/tls<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># os dados estão abreviados neste exemplo</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>tls.crt</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    </span><span style=color:#bbb>    </span>MIIC2DCCAcCgAwIBAgIBATANBgkqh ...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>tls.key</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    </span><span style=color:#bbb>    </span>MIIEpgIBAAKCAQEA7yn3bRHQ5FHMQ ...<span style=color:#bbb>
</span></span></span></code></pre></div><p>O tipo TLS é fornecido para a conveniência do usuário. Você pode criar um
Secret do tipo <code>Opaque</code> para credenciais utilizadas para o servidor e/ou
cliente TLS. No entanto, a utilização do tipo embutido auxilia a manter a
consistência dos formatos de Secret no seu projeto; o servidor da API
valida se os campos requeridos estão presentes na configuração do Secret.</p><p>Ao criar um Secret TLS utilizando a ferramenta de linha de comando <code>kubectl</code>,
você pode utilizar o subcomando <code>tls</code> conforme demonstrado no exemplo abaixo:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret tls my-tls-secret <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --cert<span style=color:#666>=</span>path/to/cert/file  <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --key<span style=color:#666>=</span>path/to/key/file
</span></span></code></pre></div><p>O par de chaves pública/privada deve ser criado previamente. O certificado
de chave pública a ser utilizado no argumento <code>--cert</code> deve ser codificado em
formato DER conforme especificado na
<a href=https://datatracker.ietf.org/doc/html/rfc7468#section-5.1>seção 5.1 da RFC 7468</a>
e deve corresponder à chave privada fornecida no argumento <code>--key</code>
(PKCS #8 no formato DER;
<a href=https://datatracker.ietf.org/doc/html/rfc7468#section-11>seção 11 da RFC 7468</a>).</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong><p>Um Secret kubernetes.io/tls armazena o conteúdo de chaves e certificados em
formato DER codificado em base64. Se você tem familiaridade com o formato PEM
para chaves privadas e certificados, o conteúdo é o mesmo do formato PEM,
excluindo-se a primeira e a última linhas.</p><p>Por exemplo, para um certificado, você <strong>não</strong> inclui as linhas
<code>--------BEGIN CERTIFICATE-----</code> e <code>-------END CERTIFICATE----</code>.</p></div><h3 id=bootstrap-token-secrets>Secret de token de autoinicialização</h3><p>Um Secret de token de autoinicialização pode ser criado especificando o tipo de
um Secret explicitamente com o valor <code>bootstrap.kubernetes.io/token</code>. Este tipo
de Secret é projetado para tokens utilizados durante o processo de inicialização
de nós. Este tipo de Secret armazena tokens utilizados para assinar ConfigMaps
conhecidos.</p><p>Um Secret de token de autoinicialização é normalmente criado no namespace
<code>kube-system</code> e nomeado na forma <code>bootstrap-token-&lt;id-do-token></code>, onde
<code>&lt;id-do-token></code> é um texto com 6 caracteres contendo a identificação do token.</p><p>No formato de manifesto do Kubernetes, um Secret de token de autoinicialização
se assemelha ao exemplo abaixo:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>bootstrap-token-5emitj<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>bootstrap.kubernetes.io/token<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>auth-extra-groups</span>:<span style=color:#bbb> </span>c3lzdGVtOmJvb3RzdHJhcHBlcnM6a3ViZWFkbTpkZWZhdWx0LW5vZGUtdG9rZW4=<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>expiration</span>:<span style=color:#bbb> </span>MjAyMC0wOS0xM1QwNDozOToxMFo=<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>token-id</span>:<span style=color:#bbb> </span>NWVtaXRq<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>token-secret</span>:<span style=color:#bbb> </span>a3E0Z2lodnN6emduMXAwcg==<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>usage-bootstrap-authentication</span>:<span style=color:#bbb> </span>dHJ1ZQ==<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>usage-bootstrap-signing</span>:<span style=color:#bbb> </span>dHJ1ZQ==<span style=color:#bbb>
</span></span></span></code></pre></div><p>Um Secret do tipo token de autoinicialização possui as seguintes chaves no campo
<code>data</code>:</p><ul><li><code>token-id</code>: Uma string com 6 caracteres aleatórios como identificador do
token. Requerido.</li><li><code>token-secret</code>: Uma string de 16 caracteres aleatórios como o conteúdo secreto
do token. Requerido.</li><li><code>description</code>: Uma string contendo uma descrição do propósito para o qual este
token é utilizado. Opcional.</li><li><code>expiration</code>: Um horário absoluto UTC no formato RFC3339 especificando quando
o token deve expirar. Opcional.</li><li><code>usage-bootstrap-&lt;usage></code>: Um conjunto de flags booleanas indicando outros
usos para este token de autoinicialização.</li><li><code>auth-extra-groups</code>: Uma lista separada por vírgulas de nomes de grupos que
serão autenticados adicionalmente, além do grupo <code>system:bootstrappers</code>.</li></ul><p>O YAML acima pode parecer confuso, já que os valores estão todos codificados em
formato base64. Você pode criar o mesmo Secret utilizando este YAML:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># Observe como o Secret é nomeado</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>bootstrap-token-5emitj<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># Um Secret de token de inicialização geralmente fica armazenado no namespace</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># kube-system</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>bootstrap.kubernetes.io/token<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>stringData</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>auth-extra-groups</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;system:bootstrappers:kubeadm:default-node-token&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>expiration</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2020-09-13T04:39:10Z&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># Esta identificação de token é utilizada no nome</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>token-id</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;5emitj&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>token-secret</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;kq4gihvszzgn1p0r&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># Este token pode ser utilizado para autenticação</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>usage-bootstrap-authentication</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># e pode ser utilizado para assinaturas</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>usage-bootstrap-signing</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=secret-immutable>Secrets imutáveis</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.21 [stable]</code></div><p>O Kubernetes permite que você marque Secrets (e ConfigMaps) específicos como
<em>imutáveis</em>. Prevenir mudanças nos dados de um Secret existente tem os seguintes
benefícios:</p><ul><li>protege você de alterações acidentais (ou indesejadas) que poderiam provocar
disrupções em aplicações.</li><li>em clusters com uso extensivo de Secrets (pelo menos dezenas de milhares de
montagens únicas de Secrets a Pods), utilizar Secrets imutáveis melhora o
desempenho do seu cluster através da redução significativa de carga no
kube-apiserver. O kubelet não precisa manter um <em>watch</em> em Secrets que são
marcados como imutáveis.</li></ul><h3 id=secret-immutable-create>Marcando um Secret como imutável</h3><p>Você pode criar um Secret imutável adicionando o campo <code>immutable</code> com o valor
<code>true</code> ao manifesto do Secret. Por exemplo:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>immutable</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Você pode também atualizar qualquer Secret mutável existente para torná-lo
imutável.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Uma vez que um Secret ou ConfigMap seja marcado como imutável, <em>não</em> é mais
possível reverter esta mudança, nem alterar os conteúdos do campo <code>data</code>. Você
pode somente apagar e recriar o Secret. Pods existentes mantém um ponto de
montagem referenciando o Secret removido - é recomendado recriar tais Pods.</div><h2 id=information-security-for-secrets>Informações de segurança sobre Secrets</h2><p>Embora ConfigMaps e Secrets funcionem de formas similares, o Kubernetes aplica
proteções extras aos objetos Secret.</p><p>Secrets frequentemente contém valores dentro de um espectro de importância,
muitos dos quais podem provocar escalações de privilégios dentro do Kubernetes
(por exemplo, um token de service account) e em sistemas externos. Mesmo que uma
aplicação individual possa avaliar o poder dos Secrets com os quais espera
interagir, outras aplicações dentro do mesmo namespace podem tornar tais
suposições inválidas.</p><p>Um Secret só é enviado a um nó se um Pod naquele nó precisa do Secret em questão.
Para montar Secrets em Pods, o kubelet armazena uma cópia dos dados dentro de um
sistema de arquivos <code>tmpfs</code>, de modo que os dados confidenciais não sejam
escritos em armazenamento durável. Uma vez que o Pod que dependia do Secret seja
removido, o kubelet apaga sua cópia local dos dados confidenciais do Secret.</p><p>Um Pod pode possuir vários contêineres. Por padrão, contêineres que você define
têm acesso somente à ServiceAccount padrão e seu Secret relacionado. Você deve
explicitamente definir variáveis de ambiente ou mapear um volume dentro de um
contêiner para ter acesso a qualquer outro Secret.</p><p>Podem haver Secrets para vários Pods no mesmo nó. No entanto, somente os Secrets
que um Pod requisitou estão potencialmente visíveis dentro de seus contêineres.
Portanto, um Pod não tem acesso aos Secrets de outro Pod.</p><div class="alert alert-danger warning callout" role=alert><strong>Aviso:</strong> Quaisquer contêineres privilegiados em um nó são passíveis de acesso a todos os
Secrets naquele nó.</div><h3 id=recomendações-de-segurança-para-desenvolvedores>Recomendações de segurança para desenvolvedores</h3><ul><li>Aplicações ainda devem proteger o valor da informação confidencial após lê-la
de uma variável de ambiente ou volume. Por exemplo, sua aplicação deve evitar
imprimir os dados do Secret sem encriptação ou transmitir esta informação para
aplicações terceiras de confiabilidade não-estabelecida.</li><li>Se você estiver definindo múltiplos contêineres em um Pod, e somente um destes
contêineres necessita acesso a um Secret, defina o volume ou variável de
ambiente de maneira que os demais contêineres não tenham acesso àquele Secret.</li><li>Se você configurar um Secret através de um <a class=glossary-tooltip title='A serialized specification of one or more Kubernetes API objects.' data-toggle=tooltip data-placement=top href='/pt-br/docs/reference/glossary/?all=true#term-manifest' target=_blank aria-label=manifesto>manifesto</a>,
com os dados codificados em formato base64, compartilhar este arquivo ou
salvá-lo em um sistema de controle de versão de código-fonte significa que o
Secret está disponível para qualquer pessoa que pode ler o manifesto. O formato
base64 <em>não é</em> um método de encriptação e não fornece nenhuma confidencialidade
adicional em comparação com texto puro.</li><li>Ao instalar aplicações que interagem com a API de Secrets, você deve limitar
o acesso utilizando
<a href=/docs/reference/access-authn-authz/authorization/>políticas de autorização</a>,
como por exemplo <a href=/docs/reference/access-authn-authz/rbac/>RBAC</a>.</li><li>Na API do Kubernetes, requisições <code>watch</code> e <code>list</code> em Secrets dentro de um
namespace são extremamente poderosas. Evite fornecer este acesso quando
possível, já que listar Secrets permite aos clientes inspecionar os valores de
todos os Secrets naquele namespace.</li></ul><h3 id=recomendações-de-segurança-para-administradores-de-cluster>Recomendações de segurança para administradores de cluster</h3><div class="alert alert-warning caution callout" role=alert><strong>Cuidado:</strong> Um usuário que pode criar um Pod que utiliza um Secret pode também ver o valor
daquele Secret. Mesmo que as permissões do cluster não permitam ao usuário ler
o Secret diretamente, o mesmo usuário poderia ter acesso a criar um Pod que
então expõe o Secret.</div><ul><li>Restrinja a habilidade de usar as requisições <code>watch</code> e <code>list</code> para listar todos
os Secrets em um cluster (utilizando a API do Kubernetes) de modo que somente
os componentes mais privilegiados e de nível de sistema possam realizar esta
ação.</li><li>Ao instalar aplicações que interajam com a API de Secrets, você deve limitar o
acesso utilizando
<a href=/docs/reference/access-authn-authz/authorization/>políticas de autorização</a>,
como por exemplo <a href=/docs/reference/access-authn-authz/rbac/>RBAC</a>.</li><li>No servidor da API, objetos (incluindo Secrets) são persistidos no
<a class=glossary-tooltip title='Armazenamento do tipo Chave-Valor consistente e em alta-disponibilidade usado como repositório de apoio do Kubernetes para todos os dados do cluster.' data-toggle=tooltip data-placement=top href=/docs/tasks/administer-cluster/configure-upgrade-etcd/ target=_blank aria-label=etcd>etcd</a>; portanto:<ul><li>somente permita a administradores do sistema o acesso ao etcd (incluindo
acesso somente-leitura);</li><li>habilite <a href=/docs/tasks/administer-cluster/encrypt-data/>encriptação em disco</a>
para objetos Secret, de modo que os dados de tais Secrets não sejam
armazenados em texto plano no <a class=glossary-tooltip title='Armazenamento do tipo Chave-Valor consistente e em alta-disponibilidade usado como repositório de apoio do Kubernetes para todos os dados do cluster.' data-toggle=tooltip data-placement=top href=/docs/tasks/administer-cluster/configure-upgrade-etcd/ target=_blank aria-label=etcd>etcd</a>;</li><li>considere a destruição do armazenamento durável previamente utilizado pelo
etcd quando não estiver mais em uso;</li><li>se houverem múltiplas instâncias do etcd em uso, garanta que o etcd esteja
configurado para utilizar SSL/TLS para comunicação entre instâncias.</li></ul></li></ul><h2 id=próximos-passos>Próximos passos</h2><ul><li>Aprenda a <a href=/pt-br/docs/tasks/configmap-secret/managing-secret-using-kubectl/>gerenciar Secrets utilizando <code>kubectl</code></a></li><li>Aprenda a <a href=/pt-br/docs/tasks/configmap-secret/managing-secret-using-config-file/>gerenciar Secrets utilizando arquivos de configuração</a></li><li>Aprenda a <a href=/pt-br/docs/tasks/configmap-secret/managing-secret-using-kustomize/>gerenciar Secrets utilizando kustomize</a></li><li>Leia a <a href=/docs/reference/kubernetes-api/config-and-storage-resources/secret-v1/>documentação de referência da API</a> de Secrets</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-436057b96151ecb8a4a9a9f456b5d0fc>4 - Gerenciamento de recursos em Pods e contêineres</h1><p>Ao criar a especificação de um <a class=glossary-tooltip title='O menor e mais simples objeto Kubernetes. Um Pod representa um conjunto de contêineres em execução no seu cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/ target=_blank aria-label=Pod>Pod</a>, você pode
opcionalmente especificar quanto de cada recurso um <a class=glossary-tooltip title='Uma imagem executável leve e portável que contém software e todas as suas dependências.' data-toggle=tooltip data-placement=top href=/docs/concepts/containers/ target=_blank aria-label=contêiner>contêiner</a>
precisa. Os recursos mais comuns a serem especificados são CPU e memória (RAM);
há outros recursos que podem ser especificados.</p><p>Quando você especifica o <em>requerimento</em> de recursos em um Pod, o
<a class=glossary-tooltip title='Componente da camada de gerenciamento que observa os pods recém-criados sem nenhum nó atribuído, e seleciona um nó para executá-los.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-scheduler/ target=_blank aria-label=kube-scheduler>kube-scheduler</a> utiliza
esta informação para decidir a qual nó o Pod será atribuído. Quando você
especifica um <em>limite</em> de recurso para um contêiner, o kubelet garante o
cumprimento de tais limites, de modo que o contêiner em execução não consiga
utilizar uma quantidade de tal recurso além do limite especificado. O kubelet
também reserva pelo menos o <em>requerimento</em> daquele recurso de sistema
especificamente para que este contêiner utilize.</p><h2 id=requerimentos-e-limites>Requerimentos e limites</h2><p>Se o nó em que um Pod está rodando tem o suficiente de um recurso específico
disponível, é possível (e permitido) a um contêiner utilizar mais do que o seu
<code>request</code> para aquele recurso especifica. No entanto, não é permitido a um
contêiner consumir mais do que o seu <code>limit</code> para um recurso.</p><p>Por exemplo, se você especificar um requerimento de <code>memory</code> de 256 MiB para um
contêiner, e aquele contêiner está em um Pod atribuído a um nó com 8GiB de
memória, sem outros Pods, então este contêiner pode tentar consumir mais memória
RAM.</p><p>Se você especificar um limite de <code>memory</code> de 4GiB para aquele contêiner, o
kubelet (e o
<a class=glossary-tooltip title='O agente de execução de contêiner é o software responsável por executar os contêineres.' data-toggle=tooltip data-placement=top href=/docs/setup/production-environment/container-runtimes target=_blank aria-label='agente de execução de contêiner'>agente de execução de contêiner</a>)
vão garantir o cumprimento do limite. O agente de execução impede que o contêiner
utilize mais de um recurso do que seu limite configurado. Por exemplo, quando
um processo no contêiner tenta consumir mais que o limite permitido de memória,
o núcleo do sistema encerra o processo que tentou efetuar a alocação de memória
com um erro de memória esgotada (<em>out of memory (OOM) error</em>).</p><p>Limites podem ser implementados de forma reativa (o sistema intervém quando
uma violação ocorre) ou por garantia (o sistema previne o contêiner de exceder
o limite). Diferentes agentes de execução implementam as mesmas restrições de
maneiras diferentes.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Se um contêiner especifica seu próprio limite de memória, mas não especifica seu
requerimento de memória, o Kubernetes automaticamente cria um requerimento de
memória com o mesmo valor do limite. A mesma regra vale para o limite de CPU:
quando não há requerimento de CPU, o Kubernetes automaticamente cria um
requerimento de CPU idêntico ao limite.</div><h2 id=tipos-de-recursos>Tipos de recursos</h2><p><em>CPU</em> e <em>memória</em> são <em>tipos de recursos</em>. Um tipo de recurso possui uma unidade
básica. CPU representa processamento computacional e é especificada em unidades
de <a href=#meaning-of-cpu>CPU do Kubernetes</a>.
Memória é especificada em bytes. Em cargas de trabalho Linux, você pode
especificar o recurso <em>huge pages</em>. <em>Huge pages</em> são uma funcionalidade
específica do Linux que permite ao núcleo do sistema operacional alocar
blocos de memória muito maiores que o tamanho de página de memória padrão.</p><p>Por exemplo, em um sistema onde o tamanho da página de memória padrão é de 4 KiB,
você pode especificar um limite <code>hugepages-2Mi: 80Mi</code>. Se o contêiner tentar
alocar mais de 40 <em>huge pages</em> de 2 MiB cada, ou um total de 80 MiB, essa
alocação irá falhar.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Você não pode superdimensionar (ou solicitar acima do limite físico) recursos do
tipo <code>hugepages-*</code>.
O recurso <code>hugepages-*</code> difere dos recursos <code>memory</code> e <code>cpu</code> neste aspecto.</div><p>CPU e memória são chamados coletivamente de <em>recursos computacionais</em>, ou apenas
<em>recursos</em>. Recursos computacionais são quantidades mensuráveis que podem ser
requisitadas, alocadas, e consumidas. Estes recursos diferem dos
<a href=/docs/concepts/overview/kubernetes-api/>recursos de API</a>. Recursos de API,
como Pods e <a href=/docs/concepts/services-networking/service/>Services</a> são objetos
que podem ser lidos e modificados através do servidor da API do Kubernetes.</p><h2 id=requerimentos-de-recursos-e-limites-de-pod-e-contêiner>Requerimentos de recursos e limites de Pod e contêiner</h2><p>Para cada contêiner, você pode especificar limites e requerimentos de recursos,
incluindo os seguintes recursos:</p><ul><li><code>spec.containers[].resources.limits.cpu</code></li><li><code>spec.containers[].resources.limits.memory</code></li><li><code>spec.containers[].resources.limits.hugepages-&lt;size></code></li><li><code>spec.containers[].resources.requests.cpu</code></li><li><code>spec.containers[].resources.requests.memory</code></li><li><code>spec.containers[].resources.requests.hugepages-&lt;size></code></li></ul><p>Embora você possa especificar apenas requerimentos e limites para contêineres
individuais, é útil também pensar sobre os requerimentos e limites gerais de um
Pod.
Para um recurso em particular, um <em>requerimento ou limite de recurso de um Pod</em>
é a soma de todos os valores dos requerimentos ou limites de um recurso daquele
tipo, especificados em cada um dos contêineres daquele Pod.</p><h2 id=unidades-de-recursos-no-kubernetes>Unidades de recursos no Kubernetes</h2><h3 id=meaning-of-cpu>Unidades de recurso de CPU</h3><p>Limites e requerimentos de recursos de CPU são mensurados em unidades de <em>cpu</em>.
No Kubernetes, uma unidade de CPU é equivalente a <strong>um núcleo físico de CPU</strong>,
ou <strong>um núcleo virtual</strong>, dependendo se o nó é uma máquina física ou uma máquina
virtual rodando em uma máquina física.</p><p>Requerimentos fracionários são permitidos. Quando você define um contêiner cujo
valor do campo <code>spec.containers[].resources.requests.cpu</code> é <code>0.5</code>, você está
solicitando metade da quantidade de CPU que teria sido solicitada caso o valor
fosse <code>1.0</code>.
No caso de unidades de recurso de CPU, a expressão de
<a href=/docs/reference/kubernetes-api/common-definitions/quantity/>quantidade</a> <code>0.1</code>
é equivalente à expressão <code>100m</code>, que pode ser lida como "cem milicpus", ou
"cem milinúcleos". "Milicpu" ou "milinúcleo" equivalem à milésima parte de um
núcleo ou CPU, de modo que "100m" equivalem a 10% do tempo computacional de um
processador.</p><p>Recursos de CPU são sempre especificados como uma quantidade absoluta de recurso,
nunca como uma quantidade relativa. Por exemplo, <code>500m</code> de CPU representam
grosseiramente a mesma quantidade de poder computacional, independentemente do
contêiner rodar em uma máquina com processador de núcleo único, de dois núcleos
ou de 48 núcleos.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> O Kubernetes não permite que você especifique recursos de CPU com uma precisão
maior que <code>1m</code>. Devido a isso, é útil especificar unidades de CPU menores do que
<code>1.0</code> ou <code>1000m</code> utilizando a notação de milicpu. Por exemplo, <code>5m</code> ao invés de
<code>0.005</code>.</div><h3 id=meaning-of-memory>Unidades de recurso de memória</h3><p>Limites e requerimentos de <code>memory</code> são medidos em bytes. Você pode expressar
memória como um número inteiro ou como um número de ponto fixo, utilizando um
destes sufixos de
<a href=/docs/reference/kubernetes-api/common-definitions/quantity/>quantidade</a>:
E, P, T, G, M, k. Você também pode utilizar os equivalentes de potência de dois:
Ei, Pi, Ti, Gi, Mi, Ki. Por exemplo, as quantidades abaixo representam, a grosso
modo, o mesmo valor:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>128974848, 129e6, 129M, 128974848000m, 123Mi
</span></span></code></pre></div><p>Tome cuidado com os sufixos. Se você solicitar <code>400m</code> de memória, esta
quantidade estará de fato requerendo o equivalente a 0,4 byte de memória. A
intenção da pessoa que fez esta requisição provavelmente era solictar 400
mebibytes (<code>400Mi</code>) ou 400 megabytes (<code>400M</code>).</p><h2 id=example-1>Exemplo de recursos de contêiner</h2><p>O Pod seguinte tem dois contêineres. Ambos os contêineres têm um requerimento de
0,25 CPU e 64 MiB (ou 2<sup>26</sup> bytes) de memória. Cada contêiner tem um
limite de 0,5 CPU e 128 MiB de memória. Você pode dizer que o Pod tem um
requerimento de 0,5 CPU e 128 MiB de memória, e um limite de 1 CPU e 256 MiB de
memória.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>app<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>images.my-company.example/app:v4<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;64Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;250m&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;128Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;500m&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>log-aggregator<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>images.my-company.example/log-aggregator:v6<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;64Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;250m&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;128Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;500m&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=como-pods-com-requerimentos-de-recursos-são-agendados>Como Pods com requerimentos de recursos são agendados</h2><p>Quando você cria um Pod, o escalonador do Kubernetes seleciona um nó para que o
Pod rode. Cada nó possui uma capacidade máxima para cada um dos tipos de recurso:
a quantidade de CPU e memória que o nó pode fornecer aos Pods. O escalonador
garante que, para cada tipo de recurso, a soma dos requerimentos de recursos dos
contêineres agendados seja menor que a capacidade do nó.
Note que, embora o consumo de memória ou CPU real nos nós seja muito baixo, o
escalonador ainda irá se recusar a agendar um Pod em um nó se a verificação de
capacidade falhar. Isso protege contra a falta de um recurso em um nó quando o
consumo de recursos aumenta com o passar do tempo, como por exemplo durante o
pico diário de requisições a um serviço.</p><h2 id=how-pods-with-resource-limits-are-run>Como o Kubernetes aplica requisições e limites de recursos</h2><p>Quando o kubelet inicia um contêiner como parte de um Pod, o kubelet envia as
requisições e limites de memória e de CPU ao agente de execução de contêiner.</p><p>No Linux, o agente de execução de contêiner normalmente configura os
<a class=glossary-tooltip title='Um grupo de processos do Linux com isolamento de recursos opcional, contagem e limites.' data-toggle=tooltip data-placement=top href='/pt-br/docs/reference/glossary/?all=true#term-cgroup' target=_blank aria-label=cgroups>cgroups</a> que aplicam e garantem
os limites que você definiu.</p><ul><li>O limite de CPU determina um teto de quanto tempo de CPU o contêiner pode
utilizar. A cada intervalo de agendamento, o núcleo do sistema operacional do
Linux verifica se este limite foi excedido; se este for o caso, o núcleo
aguarda antes de permitir que aquele cgroup continue sua execução.</li><li>O requerimento de CPU normalmente define um método de balanceamento. Se vários
contêineres diferentes (cgroups) querem rodar em um sistema disputado, cargas
de trabalho com requerimentos maiores de CPU têm mais tempo de CPU alocado
para si do que cargas de trabalho com pequenos requerimentos.</li><li>O requerimento de memória é usado principalmente durante o agendamento de um
Pod. Em um nó que utiliza cgroups v2, o agente de execução de contêiner pode
utilizar o requerimento de memória como uma dica para definir valores para
<code>memory.min</code> e <code>memory.low</code>.</li><li>O limite de memória define um limite de memória para aquele cgroup. Se o
contêiner tenta alocar mais memória que aquele limite, o subsistema
<em>out-of-memory</em> do núcleo do sistema operacional Linux é ativado e,
normalmente, intervém encerrando um dos processos do contêiner que tentou
alocar mais memória. Se o processo em questão for o PID 1 do contêiner, e o
contêiner estiver marcado como reinicializável, então o Kubernetes irá
reiniciar o contêiner.</li><li>O limite de memória para um Pod ou contêiner é também aplicado a páginas em
volumes armazenados em memória, como um <code>emptyDir</code>. O kubelet considera
sistemas de arquivos <code>tmpfs</code> em volumes do tipo <code>emptyDir</code> como uso de memória
em um contêiner, ao invés de armazenamento efêmero local.</li></ul><p>Se um contêiner exceder seu requerimento de memória e o nó em que esse contêiner
está rodando ficar com pouca memória no total, é provável que o Pod a que este
contêiner pertence seja <a class=glossary-tooltip title='Processo de encerramento de um ou mais Pods em Nós' data-toggle=tooltip data-placement=top href=/pt-br/docs/concepts/scheduling-eviction/ target=_blank aria-label=removido>removido</a>.</p><p>A um contêiner pode ou não ser permitido exceder seu limite de CPU por períodos
de tempo estendidos. No entanto, agentes de execução de contêiner não encerram
Pods por uso excessivo de CPU.</p><p>A fim de determinar se um contêiner não pode ser agendado ou está sendo
encerrado devido a limites de recursos, consulte a seção de
<a href=#troubleshooting>solução de problemas</a>.</p><h3 id=monitorando-utilização-de-recursos-computacionais-e-de-memória>Monitorando utilização de recursos computacionais e de memória</h3><p>O kubelet relata a utilização de recursos de um Pod como parte do
<a href=/docs/concepts/overview/working-with-objects/kubernetes-objects/#object-spec-and-status><code>status</code></a>
do Pod.</p><p>Se ferramentas opcionais para
<a href=/docs/tasks/debug-application-cluster/resource-usage-monitoring/>monitoramento de recursos</a>
estiverem disponíveis em seu cluster, a utilização de recursos de um Pod pode
ser verificada diretamente através de
<a href=/docs/tasks/debug-application-cluster/resource-metrics-pipeline/#the-metrics-api>API de métricas</a>
ou através das suas ferramentas de monitoramento</p><h2 id=armazenamento-efêmero-local>Armazenamento efêmero local</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.10 [beta]</code></div><p>Nós possuem armazenamento efêmero local, através de dispositivos de escrita
conectados localmente ou através de RAM. "Efêmero" significa que não há garantia
de longo termo com relação a durabilidade.</p><p>Pods utilizam armazenamento local efêmero para dados temporários, cache e logs.
O kubelet pode fornecer armazenamento temporário a Pods que utilizam
armazenamento local efêmero para montar <a class=glossary-tooltip title='Um diretório contendo dados, accessível aos contêineres em um pod.' data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/ target=_blank aria-label=volumes>volumes</a>
do tipo <a href=/docs/concepts/storage/volumes/#emptydir><code>emptyDir</code></a> em contêineres.</p><p>O kubelet também utiliza este tipo de armazenamento para
<a href=/pt-br/docs/concepts/cluster-administration/logging/#logs-no-n%C3%ADvel-do-n%C3%B3>logs de contêineres a nível de nó</a>,
imagens de contêiner e camadas graváveis de contêineres em execução.</p><div class="alert alert-warning caution callout" role=alert><strong>Cuidado:</strong> Se um nó falhar, os dados em seu armazenamento efêmero podem ser perdidos.
Suas aplicações não devem ter expectativas de cumprimento de SLAs de desempenho
(como quantidade de operações de entrada e saída de disco por segundo (IOPS),
por exemplo) pelo armazenamento local efêmero.</div><p>Com esta funcionalidade em fase beta, o Kubernetes permite que você rastreie,
reserve e limite quanto armazenamento local efêmero um Pod pode consumir.</p><h3 id=configurations-for-local-ephemeral-storage>Configurações para armazenamento local efêmero</h3><p>O Kubernetes suporta duas formas de configuração para o armazenamento local
efêmero em um nó:</p><ul class="nav nav-tabs" id=local-storage-configurations role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#local-storage-configurations-0 role=tab aria-controls=local-storage-configurations-0 aria-selected=true>Sistema de arquivos único</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#local-storage-configurations-1 role=tab aria-controls=local-storage-configurations-1>Dois sistemas de arquivos</a></li></ul><div class=tab-content id=local-storage-configurations><div id=local-storage-configurations-0 class="tab-pane show active" role=tabpanel aria-labelledby=local-storage-configurations-0><p><p>Nesta configuração, você armazena todos os tipos diferentes de dados locais
efêmeros (volumes do tipo <code>emptyDir</code>, camadas graváveis, imagens de contêiner,
logs) em um sistema de arquivos único. A forma mais efetiva de configurar o
kubelet é dedicar este sistema de arquivos aos dados do Kubernetes (kubelet).</p><p>O kubelet também escreve
<a href=/pt-br/docs/concepts/cluster-administration/logging/#logs-no-n%C3%ADvel-do-n%C3%B3>logs de contêiner a nível de nó</a>
e trata estes logs de maneira semelhante ao armazenamento efêmero local.</p><p>O kubelet escreve logs em arquivos dentro do seu diretório de log configurado
(<code>/var/log</code> por padrão) e possui um diretório base para outros dados armazenados
localmente (<code>/var/lib/kubelet</code> por padrão).</p><p>Normalmente, ambos os diretórios <code>/var/lib/kubelet</code> e <code>/var/log</code> encontram-se no
sistema de arquivos raiz, e o kubelet é projetado com este desenho em mente.</p><p>Seu nó pode ter tantos outros sistemas de arquivos não utilizados pelo Kubernetes
quantos você desejar.</p></div><div id=local-storage-configurations-1 class=tab-pane role=tabpanel aria-labelledby=local-storage-configurations-1><p><p>Você tem um sistema de arquivos no nó que você utiliza para dados efêmeros que
vêm de Pods em execução: logs e volumes do tipo <code>emptyDir</code>. Você pode utilizar
este sistema de arquivos para outros dados (por exemplo, logs de sistema não
relacionados ao Kubernetes); este sistema de arquivos pode até mesmo ser o
sistema de arquivos raiz.</p><p>O kubelet também escreve
<a href=/pt-br/docs/concepts/cluster-administration/logging/#logs-no-n%C3%ADvel-do-n%C3%B3>logs de contêiner a nível de nó</a>
no primeiro sistema de arquivos e os trata de forma semelhante ao armazenamento
local efêmero.</p><p>Você também tem um segundo sistema de arquivos, separado, conectado a um
dispositivo lógico de armazenamento distinto. Nesta configuração, o diretório
que você configurou o kubelet para armazenar as camadas de imagens de contêiner
e as camadas graváveis de contêineres em execução estará neste segundo sistema
de arquivos.</p><p>O primeiro sistema de arquivos não armazena nenhuma camada de imagens de
contêiner ou camada gravável.</p><p>Seu nó pode ter tantos outros sistemas de arquivos não utilizados pelo Kubernetes
quantos você desejar.</p></div></div><p>O kubelet consegue medir quanto armazenamento local está sendo utilizado. O
kubelet faz isso desde que:</p><ul><li>o <a href=/docs/reference/command-line-tools-reference/feature-gates/><em>feature gate</em></a>
<code>LocalStorageCapacityIsolation</code> esteja habilitado (a funcionalidade está
ligada por padrão), e</li><li>você tenha configurado o nó utilizando uma das configurações suportadas para
o armazenamento local efêmero.</li></ul><p>Se você tiver uma configuração diferente, o kubelet não irá aplicar limites de
recursos para o armazenamento local efêmero.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> O kubelet rastreia volumes <code>emptyDir</code> que utilizem o sistema de arquivos <code>tmpfs</code>
como uso de memória de contêiner, ao invés de consumo de armazenamento local
efêmero.</div><h3 id=configurando-requerimentos-e-limites-para-armazenamento-local-efêmero>Configurando requerimentos e limites para armazenamento local efêmero</h3><p>Você pode especificar o recurso <code>ephemeral-storage</code> para gerenciar o
armazenamento local efêmero. Cada contêiner de um Pod pode especificar um dos
valores abaixo, ou ambos:</p><ul><li><code>spec.containers[].resources.limits.ephemeral-storage</code></li><li><code>spec.containers[].resources.requests.ephemeral-storage</code></li></ul><p>Limites e requerimentos de <code>ephemeral-storage</code> são medidos em quantidades de
bytes. Você pode expressar armazenamento como um inteiro ou como um valor de
ponto fixo utilizando um dos seguintes sufixos: E, P, T, G, M, k. Você pode
também utilizar os equivalentes de potência de dois: Ei, Pi, Ti, Gi, Mi, Ki.
Por exemplo, as quantidades abaixo representam grosseiramente o mesmo valor:</p><ul><li><code>128974848</code></li><li><code>129e6</code></li><li><code>129M</code></li><li><code>123Mi</code></li></ul><p>No exemplo a seguir, o Pod tem dois contêineres. Cada contêiner tem um
requerimento de 2GiB de armazenamento efêmero local. Cada contêiner tem um
limite de 4GiB de armazenamento efêmero local. Portanto, o Pod tem um
requerimento de 4GiB e um limite de 8GiB de armazenamento efêmero local.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>app<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>images.my-company.example/app:v4<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ephemeral-storage</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2Gi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ephemeral-storage</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;4Gi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>ephemeral<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/tmp&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>log-aggregator<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>images.my-company.example/log-aggregator:v6<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ephemeral-storage</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2Gi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ephemeral-storage</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;4Gi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>ephemeral<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/tmp&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>ephemeral<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=como-pods-com-requerimentos-de-ephemeral-storage-são-agendados>Como Pods com requerimentos de <code>ephemeral-storage</code> são agendados</h3><p>Quando você cria um Pod, o Kubernetes seleciona um nó para o Pod rodar. Cada nó
tem uma quantidade máxima de armazenamento efêmero local que pode ser fornecida
aos Pods. Para mais informações, consulte
<a href=/docs/tasks/administer-cluster/reserve-compute-resources/#node-allocatable><em>Node Allocatable</em></a>.</p><p>O escalonador garante que a soma dos requerimentos de recursos dos contêineres
agendados é menor que a capacidade do nó.</p><h3 id=resource-emphemeralstorage-consumption>Gerenciamento do consumo do armazenamento efêmero</h3><p>Se o kubelet estiver gerenciando armazenamento local efêmero como um recurso,
o kubelet irá medir o consumo de armazenamento em:</p><ul><li>volumes <code>emptyDir</code>, com exceção dos volumes do tipo <code>tmpfs</code></li><li>diretórios que armazenem logs a nível de nó</li><li>camadas de contêiner graváveis</li></ul><p>Se um Pod estiver utilizando mais armazenamento efêmero do que o permitido, o
kubelet irá gerar um sinal de remoção para aquele Pod.</p><p>Para isolamento a nível de contêiner, se o consumo de armazenamento de um
contêiner em camadas graváveis e logs exceder seu limite de armazenamento, o
kubelet irá marcar o Pod para remoção.</p><p>Para isolamento a nível de Pod, o kubelet calcula um limite de armazenamento
total para um Pod somando os limites de cada contêiner naquele Pod. Neste caso,
se a soma do consumo de armazenamento efêmero local de todas os contêineres e
também dos volumes <code>emptyDir</code> de um Pod exceder o limite de armazenamento total
do Pod, então o kubelet marca o Pod para remoção.</p><div class="alert alert-warning caution callout" role=alert><strong>Cuidado:</strong><p>Se o kubelet não estiver medindo armazenamento efêmero local, um Pod que exeder
seu limite de armazenamento local não será removido por exceder os limites de
recurso de armazenamento local.</p><p>No entanto, se o espaço de um sistema de arquivos para camadas de contêiner
graváveis, logs a nível de nó, ou volumes <code>emptyDir</code> ficar reduzido, o nó irá
marcar a si próprio com um <a class=glossary-tooltip title='A core object consisting of three required properties: key, value, and effect. Taints prevent the scheduling of pods on nodes or node groups.' data-toggle=tooltip data-placement=top href=/docs/concepts/scheduling-eviction/taint-and-toleration/ target=_blank aria-label=_taint_><em>taint</em></a>
indicando que está com armazenamento local reduzido, e esse <em>taint</em> dispara a
remoção de Pods que não toleram o <em>taint</em> em questão.</p><p>Veja as <a href=#configurations-for-local-ephemeral-storage>configurações</a> suportadas
para armazenamento efêmero local.</p></div><p>O kubelet suporta formas diferentes de medir o uso de armazenamento dos Pods:</p><ul class="nav nav-tabs" id=resource-emphemeralstorage-measurement role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#resource-emphemeralstorage-measurement-0 role=tab aria-controls=resource-emphemeralstorage-measurement-0 aria-selected=true>Varredura periódica</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#resource-emphemeralstorage-measurement-1 role=tab aria-controls=resource-emphemeralstorage-measurement-1>Quota de projeto do sistema de arquivos</a></li></ul><div class=tab-content id=resource-emphemeralstorage-measurement><div id=resource-emphemeralstorage-measurement-0 class="tab-pane show active" role=tabpanel aria-labelledby=resource-emphemeralstorage-measurement-0><p><p>O kubelet executa verificações agendadas, em intervalos regulares, que varrem
cada volume do tipo <code>emptyDir</code>, diretório de log de contêiner, e camada gravável
de contêiner.</p><p>A varredura mede quanto espaço está sendo utilizado.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong><p>Neste modo, o kubelet não rastreia descritores de arquivos abertos para arquivos
removidos.</p><p>Se você (ou um contêiner) criar um arquivo dentro de um volume <code>emptyDir</code>, um
processo ou usuário abrir tal arquivo, e você apagar o arquivo enquanto ele
ainda estiver aberto, o nó de índice para o arquivo apagado será mantido até que
o arquivo seja fechado novamente. O kubelet, no entanto, não computa este espaço
como espaço em uso.</p></div></div><div id=resource-emphemeralstorage-measurement-1 class=tab-pane role=tabpanel aria-labelledby=resource-emphemeralstorage-measurement-1><p><p>Quotas de projeto são uma funcionalidade a nível de sistema operacional para
gerenciamento de uso do armazenamento em sistemas de arquivos. Com o Kubernetes,
você pode habilitar quotas de projeto para o monitoramento de armazenamento em
uso. Tenha certeza que o sistema de arquivos do nó que esteja sendo utilizado em
volumes do tipo <code>emptyDir</code> possui suporte a quotas de projeto. Por exemplo,
os sistemas de arquivos XFS e ext4fs oferecem suporte a quotas de projeto.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Quotas de projeto permitem o monitoramento do uso de armazenamento, mas não
garantem limites.</div><p>O Kubernetes utiliza IDs de projeto iniciando em <code>1048576</code>. Os IDs em uso estão
registrados nos diretórios <code>/etc/projects</code> e <code>/etc/projid</code>. Se os IDs de projeto
nestes intervalos forem utilizados para outros propósitos no sistema, estes IDs
de projeto deverão estar registrados nos diretórios especificados acima para que
o Kubernetes não os tente utilizar.</p><p>Quotas fornecem melhor desempenho e mais precisão do que varredura de diretórios.
Quando um diretório é atribuído a um projeto, todos os arquivos criados no
diretório são também criados no projeto, e o núcleo do sistema pode simplesmente
manter controle de quantos blocos estão em uso por arquivos daquele projeto. Se
um arquivo é criado e apagado, mas possui um descritor de arquivo aberto, ele
continua a consumir espaço. O rastreio de quotas registra este espaço de forma
precisa, enquanto varreduras de diretório ignoram o uso de espaço de
armazenamento por arquivos apagados.</p><p>Se você deseja utilizar quotas de projeto, você deve:</p><ul><li><p>Habilitar o <a href=/docs/reference/command-line-tools-reference/feature-gates/><em>feature gate</em></a>
<code>LocalStorageCapacityIsolationFSQuotaMonitoring=true</code> utilizando o campo
<code>featureGates</code> na <a href=/docs/reference/config-api/kubelet-config.v1beta1/>configuração do kubelet</a>
ou a opção de linha de comando <code>--feature-gates</code>.</p></li><li><p>Garantir que o sistema de arquivos raiz (ou o sistema de arquivos opcional de
tempo de execução) tem quotas de projeto habilitadas. Todos os sistemas de
arquivos XFS suportam quotas de projeto. Em sistemas de arquivos ext4, você
precisa habilitar a funcionalidade de rastreio de quotas de projeto enquanto
o sistema de arquivos ainda não está montado.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#080;font-style:italic># Para sistema de arquivos ext4, com o volume /dev/block-device não montado</span>
</span></span><span style=display:flex><span>sudo tune2fs -O project -Q prjquota /dev/block-device
</span></span></code></pre></div></li><li><p>Garanta que o sistema de arquivos raiz (ou sistema de arquivos opcional de
tempo de execução) esteja montado com quotas de projeto habilitadas. Em ambos
os sistemas XFS e ext4fs, a opção de montagem é chamada <code>prjquota</code>.</p></li></ul></div></div><h2 id=recursos-estendidos>Recursos estendidos</h2><p>Recursos estendidos são nomes de recursos absolutos fora do domínio
<code>kubernetes.io</code>. Estes recursos permitem a operadores de cluster anunciar e a
usuários consumir recursos que não são embutidos pelo Kubernetes.</p><p>Dois passos são necessários para a utilização de recursos estendidos.
Primeiramente, o operador do cluster deve anunciar um recurso estendido. Em
segundo lugar, os usuários devem solicitar o recurso estendido em Pods.</p><h3 id=gerenciando-recursos-estendidos>Gerenciando recursos estendidos</h3><h4 id=recursos-estendidos-a-nível-de-nó>Recursos estendidos a nível de nó</h4><p>Recursos estendidos a nível de nó são recursos ligados ao nó.</p><h5 id=recursos-gerenciados-por-dispositivos-conectados>Recursos gerenciados por dispositivos conectados</h5><p>Veja <a href=/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/>Device Plugin</a>
para mais informações sobre como anunciar recursos gerenciados por dispositivos
conectados em cada nó.</p><h5 id=outros-recursos>Outros recursos</h5><p>A fim de anunciar um novo recurso estendido a nível de nó, o operador do cluster
pode enviar uma requisição HTTP com o método <code>PATCH</code> para o servidor da API do
Kubernetes para especificar a quantidade disponível em um nó no cluster, através
do campo <code>status.capacity</code>. Após a realização desta operação, o campo
<code>status.capacity</code> do nó irá conter um novo recurso. O campo <code>status.allocatable</code>
é atualizado automaticamente pelo kubelet, de forma assíncrona, com o novo
recurso.</p><p>Como o escalonador utiliza o valor do campo <code>status.allocatable</code> do nó ao
verificar a saúde do Pod, o escalonador somente considerará o novo valor do
campo após esta atualização assíncrona. Pode haver um pequeno atraso entre a
atualização da capacidade do nó com um novo recurso e o momento em que o
primeiro Pod que requer o recurso poderá ser agendado naquele nó.</p><p><strong>Exemplo</strong>:</p><p>Este exemplo demonstra como utilizar a ferramenta <code>curl</code> para criar uma
requisição HTTP que anuncia cinco recursos "example.com/foo" no nó <code>k8s-node-1</code>,
cujo nó da camada de gerenciamento é <code>k8s-master</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl --header <span style=color:#b44>&#34;Content-Type: application/json-patch+json&#34;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --request PATCH <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --data <span style=color:#b44>&#39;[{&#34;op&#34;: &#34;add&#34;, &#34;path&#34;: &#34;/status/capacity/example.com~1foo&#34;, &#34;value&#34;: &#34;5&#34;}]&#39;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  http://k8s-master:8080/api/v1/nodes/k8s-node-1/status
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Na requisição anterior, a notação <code>~1</code> é a codificação do caractere <code>/</code> no campo
<code>path</code> para a operação de atualização. O valor do campo <code>path</code> em JSON-Patch é
interpretado como um JSON-Pointer. Para maiores detalhes, veja
<a href=https://tools.ietf.org/html/rfc6901#section-3>a seção 3 da IETF RFC 6901</a>.</div><h4 id=recursos-estendidos-a-nível-de-cluster>Recursos estendidos a nível de cluster</h4><p>Recursos estendidos a nível de cluster não são vinculados aos nós. Estes
recursos são normalmente gerenciados por extensões do escalonador, que manipulam
o consumo e as quotas de recursos.</p><p>Você pode especificar os recursos estendidos que são manipulados por extensões
do escalonador nas <a href=/docs/reference/config-api/kube-scheduler-config.v1beta3/>configurações do kube-scheduler</a>.</p><p><strong>Exemplo</strong>:</p><p>A configuração abaixo para uma política do escalonador indica que o recurso
estendido a nível de cluster "example.com/foo" é manipulado pelas extensões do
escalonador.</p><ul><li>O escalonador envia um Pod para a extensão do escalonador somente se o Pod
solicitar "example.com/foo".</li><li>O campo <code>ignoredByScheduler</code> especifica que o escalonador não verifica o
recurso "example.com/foo" em seu predicado <code>PodFitsResources</code>.</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;Policy&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;v1&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;extenders&#34;</span>: [
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;urlPrefix&#34;</span>:<span style=color:#b44>&#34;&lt;extender-endpoint&gt;&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;bindVerb&#34;</span>: <span style=color:#b44>&#34;bind&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;managedResources&#34;</span>: [
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>          <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;example.com/foo&#34;</span>,
</span></span><span style=display:flex><span>          <span style=color:green;font-weight:700>&#34;ignoredByScheduler&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>      ]
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  ]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=consumindo-recursos-estendidos>Consumindo recursos estendidos</h3><p>Usuários podem consumir recursos estendidos em especificações de Pods como CPU
e memória. O escalonador controla a contagem de recursos de modo que a
quantidade alocada simultaneamente a Pods não seja maior que a quantidade
disponível.</p><p>O servidor da API limita as quantidades de recursos estendidos a números inteiros.
Exemplos de quantidades <em>válidas</em> são <code>3</code>, <code>3000m</code> e <code>3Ki</code>. Exemplos de
quantidades <em>inválidas</em> são <code>0.5</code> e <code>1500m</code>.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Recursos estendidos substituem os Recursos Inteiros Opacos.
Usuários podem escolher qualquer prefixo de nome de domínio, com exceção do
domínio <code>kubernetes.io</code>, que é reservado.</div><p>Para consumir um recurso estendido em um Pod, inclua o nome do recurso como uma
chave no mapa <code>spec.containers[].resources.limits</code> na especificação do contêiner.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Recursos estendidos não podem ser superdimensionados. Portanto, <code>request</code> e
<code>limit</code> devem ser iguais se ambos estiverem presentes na especificação de um
contêiner.</div><p>Um Pod só é agendado se todos os seus requerimentos de recursos forem
satisfeitos, incluindo CPU, memória e quaisquer recursos estendidos. O Pod
permanece no estado <code>PENDING</code> enquanto seus requerimentos de recursos não puderem
ser satisfeitos.</p><p><strong>Exemplo</strong>:</p><p>O Pod abaixo requisita duas CPUs e um "example.com/foo" (um recurso estendido).</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>myimage<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>example.com/foo</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>example.com/foo</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=limitação-de-pid>Limitação de PID</h2><p>Limites de ID de processo (PID) permitem à configuração de um kubelet limitar o
número de PIDs que um dado Pod pode consumir. Consulte
<a href=/docs/concepts/policy/pid-limiting/>PID Limiting</a> para mais informações.</p><h2 id=troubleshooting>Solução de problemas</h2><h3 id=meus-pods-estão-pendentes-com-um-evento-failedscheduling>Meus pods estão pendentes com um evento <code>FailedScheduling</code></h3><p>Se o escalonador não conseguir encontrar nenhum nó que atenda aos requisitos de
recursos do Pod, este Pod permanecerá não-agendado até que um local destino
possa ser encontrado. Um <a href=/docs/reference/kubernetes-api/cluster-resources/event-v1/>Evento</a>
é produzido cada vez que o escalonador falhar em encontrar um local para agendar
o Pod. Você pode utilizar o utilitário <code>kubectl</code> para ver os eventos de um Pod.
Por exemplo:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe pod frontend | grep -A <span style=color:#666>9999999999</span> Events
</span></span></code></pre></div><pre tabindex=0><code>Events:
  Type     Reason            Age   From               Message
  ----     ------            ----  ----               -------
  Warning  FailedScheduling  23s   default-scheduler  0/42 nodes available: insufficient cpu
</code></pre><p>No exemplo acima, o Pod de nome "frontend" não pôde ser agendado devido à nenhum
nó possuir CPU suficiente para suprir seu requerimento de CPU. Mensagens de erro
semelhantes a essa podem sugerir falha devido a falta de memória
(<code>PodExceedsFreeMemory</code>). De maneira geral, se um Pod estiver pendente com uma
mensagem deste tipo, há diversas possibilidades de solução a serem tentadas:</p><ul><li>Adicione mais nós ao cluster.</li><li>Encerre Pods desnecessários para liberar espaço para Pods pendentes.</li><li>Verifique se o Pod não é maior que todos os nós. Por exemplo, se todos os nós
têm uma capacidade de <code>cpu: 1</code>, um Pod que requisita <code>cpu: 1.1</code> nunca será
agendado.</li><li>Verifique se os nós não possuem <em>taints</em>. Se a maioria dos seus nós possuem
<em>taints</em>, e o novo Pod não tolera tal <em>taint</em>, o escalonador somente considera
agendar o Pod nos nós que não possuem aquele <em>taint</em>.</li></ul><p>Você pode verificar capacidades de nós e quantidades alocadas com o comando
<code>kubectl describe nodes</code>. Por exemplo:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe nodes e2e-test-node-pool-4lw4
</span></span></code></pre></div><pre tabindex=0><code>Name:            e2e-test-node-pool-4lw4
[ ... linhas abreviadas para simplificação ...]
Capacity:
 cpu:                               2
 memory:                            7679792Ki
 pods:                              110
Allocatable:
 cpu:                               1800m
 memory:                            7474992Ki
 pods:                              110
[ ... linhas abreviadas para simplificação ...]
Non-terminated Pods:        (5 in total)
  Namespace    Name                                  CPU Requests  CPU Limits  Memory Requests  Memory Limits
  ---------    ----                                  ------------  ----------  ---------------  -------------
  kube-system  fluentd-gcp-v1.38-28bv1               100m (5%)     0 (0%)      200Mi (2%)       200Mi (2%)
  kube-system  kube-dns-3297075139-61lj3             260m (13%)    0 (0%)      100Mi (1%)       170Mi (2%)
  kube-system  kube-proxy-e2e-test-...               100m (5%)     0 (0%)      0 (0%)           0 (0%)
  kube-system  monitoring-influxdb-grafana-v4-z1m12  200m (10%)    200m (10%)  600Mi (8%)       600Mi (8%)
  kube-system  node-problem-detector-v0.1-fj7m3      20m (1%)      200m (10%)  20Mi (0%)        100Mi (1%)
Allocated resources:
  (Total limits may be over 100 percent, i.e., overcommitted.)
  CPU Requests    CPU Limits    Memory Requests    Memory Limits
  ------------    ----------    ---------------    -------------
  680m (34%)      400m (20%)    920Mi (11%)        1070Mi (13%)
</code></pre><p>No exemplo anterior, você pode verificar que se um Pod requisitar mais que 1,120
CPUs ou mais que 6,23Gi de memória, tal Pod não caberá neste nó.</p><p>Ao verificar a seção "Pods", você pode observar quais Pods estão consumindo
espaço neste nó.</p><p>A quantidade de recursos disponível aos Pods é menor que a capacidade do nó, pois
daemons do sistema utilizam uma parcela dos recursos disponíveis. Dentro da API
do Kubernetes, cada nó tem um campo <code>.status.allocatable</code>
(consulte <a href=/docs/reference/kubernetes-api/cluster-resources/node-v1/#NodeStatus>NodeStatus</a>
para mais detalhes).</p><p>O campo <code>.status.allocatable</code> descreve a quantidade de recursos que está
disponível a Pods naquele nó (por exemplo: 15 CPUs virtuais e 7538 MiB de
memória). Para mais informações sobre recursos alocáveis do nó no Kubernetes,
veja <a href=/docs/tasks/administer-cluster/reserve-compute-resources/>Reserve Compute Resources for System Daemons</a>.</p><p>Você pode configurar <a href=/docs/concepts/policy/resource-quotas/>quotas de recursos</a>
para limitar a quantidade total de recursos que um namespace pode consumir.
O Kubernetes garante quotas para objetos em um namespace específico quando há
uma <code>ResourceQuota</code> naquele namespace. Por exemplo, se você atribuir namespaces
específicos a times diferentes, você pode adicionar <code>ResourceQuota</code>s nestes
namespaces. Criar quotas de recursos ajuda a evitar que um time utilize tanto de
um recurso que chegue a afetar outros times utilizando o mesmo cluster.</p><p>Você deve também considerar o nível de acesso fornecido aos usuários de qualquer
namespace: acesso <strong>completo</strong> para escrita permite a alguém com este acesso
remover <strong>qualquer</strong> recurso, incluindo uma configuração de <code>ResourceQuota</code>.</p><h3 id=meu-contêiner-foi-terminado>Meu contêiner foi terminado</h3><p>Seu contêiner pode ser terminado se faltar recursos para que este rode. Para
verificar se um contêiner está sendo terminado por chegar no limite de algum
recurso, utilize o comando <code>kubectl describe pod</code> no Pod em questão:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe pod simmemleak-hra99
</span></span></code></pre></div><p>A saída será semelhante a:</p><pre tabindex=0><code>Name:                           simmemleak-hra99
Namespace:                      default
Image(s):                       saadali/simmemleak
Node:                           kubernetes-node-tf0f/10.240.216.66
Labels:                         name=simmemleak
Status:                         Running
Reason:
Message:
IP:                             10.244.2.75
Containers:
  simmemleak:
    Image:  saadali/simmemleak:latest
    Limits:
      cpu:          100m
      memory:       50Mi
    State:          Running
      Started:      Tue, 07 Jul 2019 12:54:41 -0700
    Last State:     Terminated
      Reason:       OOMKilled
      Exit Code:    137
      Started:      Fri, 07 Jul 2019 12:54:30 -0700
      Finished:     Fri, 07 Jul 2019 12:54:33 -0700
    Ready:          False
    Restart Count:  5
Conditions:
  Type      Status
  Ready     False
Events:
  Type    Reason     Age   From               Message
  ----    ------     ----  ----               -------
  Normal  Scheduled  42s   default-scheduler  Successfully assigned simmemleak-hra99 to kubernetes-node-tf0f
  Normal  Pulled     41s   kubelet            Container image &#34;saadali/simmemleak:latest&#34; already present on machine
  Normal  Created    41s   kubelet            Created container simmemleak
  Normal  Started    40s   kubelet            Started container simmemleak
  Normal  Killing    32s   kubelet            Killing container with id ead3fb35-5cf5-44ed-9ae1-488115be66c6: Need to kill Pod
</code></pre><p>No exemplo acima, o campo <code>Restart Count: 5</code> indica que o contêiner <code>simmemleak</code>
deste Pod foi terminado e reiniciado cinco vezes até o momento. A razão
<code>OOMKilled</code> demonstra que o contêiner tentou consumir mais memória do que o seu
limite.</p><p>O próximo passo neste cenário seria vasculhar e depurar o código da aplicação,
procurando por vazamentos de memória. Se você determinar que a aplicação está se
comportando conforme o esperado, considere aumentar o limite (e possivelmente
o requerimento) de memória para aquele contêiner.</p><h2 id=próximos-passos>Próximos passos</h2><ul><li>Pratique <a href=/docs/tasks/configure-pod-container/assign-memory-resource/>a criação de requerimentos de recursos de memória em contêineres e Pods</a>.</li><li>Pratique <a href=/docs/tasks/configure-pod-container/assign-cpu-resource/>a criação de requerimentos de CPU em contêineres and Pods</a>.</li><li>Leia como a referência da API define um <a href=/docs/reference/kubernetes-api/workload-resources/pod-v1/#Container>contêiner</a>
e seus <a href=/docs/reference/kubernetes-api/workload-resources/pod-v1/#resources>requerimentos de recursos</a>.</li><li>Leia sobre <a href=https://xfs.org/index.php/XFS_FAQ#Q:_Quota:_Do_quotas_work_on_XFS.3F>quotas de projeto</a> no XFS.</li><li>Leia mais sobre a <a href=/docs/reference/config-api/kube-scheduler-config.v1beta3/>referência de configuração do kube-scheduler (v1beta3)</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-ab6d20f33ad930a67ee7ef57bff6c75e>5 - Organizando o acesso ao cluster usando arquivos kubeconfig</h1><p>Utilize arquivos kubeconfig para organizar informações sobre clusters, usuários, namespaces e mecanismos de autenticação. A ferramenta de linha de comando <code>kubectl</code> faz uso dos arquivos kubeconfig para encontrar as informações necessárias para escolher e se comunicar com o serviço de API de um cluster.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Um arquivo que é utilizado para configurar o acesso aos clusters é chamado de <em>kubeconfig</em>. Esta á uma forma genérica de referenciamento para um arquivo de configuração desta natureza. Isso não significa que existe um arquivo com o nome <code>kubeconfig</code>.</div><p>Por padrão, o <code>kubectl</code> procura por um arquivo de nome <code>config</code> no diretório <code>$HOME/.kube</code></p><p>Você pode especificar outros arquivos kubeconfig através da variável de ambiente <code>KUBECONFIG</code> ou adicionando a opção <a href=/docs/reference/generated/kubectl/kubectl/><code>--kubeconfig</code></a>.</p><p>Para maiores detalhes na criação e especificação de um kubeconfig, veja o passo a passo em <a href=/docs/tasks/access-application-cluster/configure-access-multiple-clusters>Configurar Acesso para Múltiplos Clusters</a>.</p><h2 id=suportando-múltiplos-clusters-usuários-e-mecanismos-de-autenticação>Suportando múltiplos clusters, usuários e mecanismos de autenticação</h2><p>Imagine que você possua inúmeros clusters, e seus usuários e componentes se autenticam de várias formas. Por exemplo:</p><ul><li>Um kubelet ativo pode se autenticar utilizando certificados</li><li>Um usuário pode se autenticar através de tokens</li><li>Administradores podem possuir conjuntos de certificados os quais provém acesso aos usuários de forma individual.</li></ul><p>Através de arquivos kubeconfig, você pode organizar os seus clusters, usuários, e namespaces. Você também pode definir contextos para uma fácil troca entre clusters e namespaces.</p><h2 id=contexto>Contexto</h2><p>Um elemento de <em>contexto</em> em um kubeconfig é utilizado para agrupar parâmetros de acesso em um nome conveniente. Cada contexto possui três parâmetros: cluster, namespace, e usuário.</p><p>Por padrão, a ferramenta de linha de comando <code>kubectl</code> utiliza os parâmetros do <em>contexto atual</em> para se comunicar com o cluster.</p><p>Para escolher o contexto atual:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config use-context
</span></span></code></pre></div><h2 id=a-variável-de-ambiente-kubeconfig>A variável de ambiente KUBECONFIG</h2><p>A variável de ambiente <code>KUBECONFIG</code> possui uma lista dos arquivos kubeconfig. Para Linux e Mac, esta lista é delimitada por vírgula. No Windows, a lista é delimitada por ponto e vírgula. A variável de ambiente <code>KUBECONFIG</code> não é um requisito obrigatório - caso ela não exista o <code>kubectl</code> utilizará o arquivo kubeconfig padrão localizado no caminho <code>$HOME/.kube/config</code>.</p><p>Se a variável de ambiente <code>KUBECONFIG</code> existir, o <code>kubectl</code> utilizará uma configuração que é o resultado da combinação dos arquivos listados na variável de ambiente <code>KUBECONFIG</code>.</p><h2 id=combinando-arquivos-kubeconfig>Combinando arquivos kubeconfig</h2><p>Para inspecionar a sua configuração atual, execute o seguinte comando:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config view
</span></span></code></pre></div><p>Como descrito anteriormente, a saída poderá ser resultado de um único arquivo kubeconfig, ou poderá ser o resultado da junção de vários arquivos kubeconfig.</p><p>Aqui estão as regras que o <code>kubectl</code> utiliza quando realiza a combinação de arquivos kubeconfig:</p><ol><li><p>Se o argumento <code>--kubeconfig</code> está definido, apenas o arquivo especificado será utilizado. Apenas uma instância desta flag é permitida.</p><p>Caso contrário, se a variável de ambiente <code>KUBECONFIG</code> estiver definida, esta deverá ser utilizada como uma lista de arquivos a serem combinados, seguindo o fluxo a seguir:</p><ul><li>Ignorar arquivos vazios.</li><li>Produzir erros para aquivos cujo conteúdo não for possível desserializar.</li><li>O primeiro arquivo que definir um valor ou mapear uma chave determinada, será o escolhido.</li><li>Nunca modificar um valor ou mapear uma chave.
Exemplo: Preservar o contexto do primeiro arquivo que definir <code>current-context</code>.
Exemplo: Se dois arquivos especificarem um <code>red-user</code>, use apenas os valores do primeiro <code>red-user</code>. Mesmo se um segundo arquivo possuir entradas não conflitantes sobre a mesma entrada <code>red-user</code>, estas deverão ser descartadas.</li></ul><p>Para um exemplo de definição da variável de ambiente <code>KUBECONFIG</code> veja <a href=/docs/tasks/access-application-cluster/configure-access-multiple-clusters/#set-the-kubeconfig-environment-variable>Definido a variável de ambiente KUBECONFIG</a>.</p><p>Caso contrário, utilize o arquivo kubeconfig padrão encontrado no diretório <code>$HOME/.kube/config</code>, sem qualquer tipo de combinação.</p></li><li><p>Determine o contexto a ser utilizado baseado no primeiro padrão encontrado, nesta ordem:</p><ol><li>Usar o conteúdo da flag <code>--context</code> caso ela existir.</li><li>Usar o <code>current-context</code> a partir da combinação dos arquivos kubeconfig.</li></ol><p>Um contexto vazio é permitido neste momento.</p></li><li><p>Determinar o cluster e o usuário. Neste ponto, poderá ou não existir um contexto.
Determinar o cluster e o usuário no primeiro padrão encontrado de acordo com a ordem à seguir. Este procedimento deverá executado duas vezes: uma para definir o usuário a outra para definir o cluster.</p><ol><li>Utilizar a flag caso ela existir: <code>--user</code> ou <code>--cluster</code>.</li><li>Se o contexto não estiver vazio, utilizar o cluster ou usuário deste contexto.</li></ol><p>O usuário e o cluster poderão estar vazios neste ponto.</p></li><li><p>Determinar as informações do cluster atual a serem utilizadas. Neste ponto, poderá ou não existir informações de um cluster.</p><p>Construir cada peça de informação do cluster baseado nas opções à seguir; a primeira ocorrência encontrada será a opção vencedora:</p><ol><li>Usar as flags de linha de comando caso existirem: <code>--server</code>, <code>--certificate-authority</code>, <code>--insecure-skip-tls-verify</code>.</li><li>Se algum atributo do cluster existir a partir da combinação de kubeconfigs, estes deverão ser utilizados.</li><li>Se não existir informação de localização do servidor falhar.</li></ol></li><li><p>Determinar a informação atual de usuário a ser utilizada. Construir a informação de usuário utilizando as mesmas regras utilizadas para o caso de informações de cluster, exceto para a regra de técnica de autenticação que deverá ser única por usuário:</p><ol><li>Usar as flags, caso existirem: <code>--client-certificate</code>, <code>--client-key</code>, <code>--username</code>, <code>--password</code>, <code>--token</code>.</li><li>Usar os campos <code>user</code> resultado da combinação de arquivos kubeconfig.</li><li>Se existirem duas técnicas conflitantes, falhar.</li></ol></li><li><p>Para qualquer informação que ainda estiver ausente, utilizar os valores padrão e potencialmente solicitar informações de autenticação a partir do prompt de comando.</p></li></ol><h2 id=referências-de-arquivos>Referências de arquivos</h2><p>Arquivos e caminhos referenciados em um arquivo kubeconfig são relativos à localização do arquivo kubeconfig.</p><p>Referências de arquivos na linha de comando são relativas ao diretório de trabalho vigente.</p><p>No arquivo <code>$HOME/.kube/config</code>, caminhos relativos são armazenados de forma relativa, e caminhos absolutos são armazenados de forma absoluta.</p><h2 id=próximos-passos>Próximos passos</h2><ul><li><a href=/docs/tasks/access-application-cluster/configure-access-multiple-clusters/>Configurar Accesso para Multiplos Clusters</a></li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#config><code>kubectl config</code></a></li></ul></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/pt-br/docs/home/>Home</a>
<a class=text-white href=/pt-br/blog/>Blog</a>
<a class=text-white href=/pt-br/partners/>Parceiros</a>
<a class=text-white href=/pt-br/community/>Comunidade</a>
<a class=text-white href=/pt-br/case-studies/>Casos de estudo</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 Os autores do Kubernetes | Documentação Distribuída sob <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small><br><small class=text-white>Copyright &copy; 2023 A Fundação Linux &reg;. Todos os direitos reservados. A Linux Foundation tem marcas registradas e usa marcas registradas. Para uma lista de marcas registradas da The Linux Foundation, por favor, veja nossa <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>Página de uso de marca registrada</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>