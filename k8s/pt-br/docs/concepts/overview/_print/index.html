<!doctype html><html lang=pt-br class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=en href=https://kubernetes.io/docs/concepts/overview/><link rel=alternate hreflang=zh-cn href=https://kubernetes.io/zh-cn/docs/concepts/overview/><link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/concepts/overview/><link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/concepts/overview/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/concepts/overview/><link rel=alternate hreflang=it href=https://kubernetes.io/it/docs/concepts/overview/><link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/concepts/overview/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/concepts/overview/><link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/concepts/overview/><link rel=alternate hreflang=vi href=https://kubernetes.io/vi/docs/concepts/overview/><link rel=alternate hreflang=ru href=https://kubernetes.io/ru/docs/concepts/overview/><link rel=alternate hreflang=pl href=https://kubernetes.io/pl/docs/concepts/overview/><link rel=alternate hreflang=uk href=https://kubernetes.io/uk/docs/concepts/overview/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/pt-br/docs/concepts/overview/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>Visão Geral | Kubernetes</title><meta property="og:title" content="Visão Geral"><meta property="og:description" content="Obtenha uma visão em alto-nível do Kubernetes e dos componentes a partir dos quais ele é construído."><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/pt-br/docs/concepts/overview/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="Visão Geral"><meta itemprop=description content="Obtenha uma visão em alto-nível do Kubernetes e dos componentes a partir dos quais ele é construído."><meta name=twitter:card content="summary"><meta name=twitter:title content="Visão Geral"><meta name=twitter:description content="Obtenha uma visão em alto-nível do Kubernetes e dos componentes a partir dos quais ele é construído."><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content="Obtenha uma visão em alto-nível do Kubernetes e dos componentes a partir dos quais ele é construído."><meta property="og:description" content="Obtenha uma visão em alto-nível do Kubernetes e dos componentes a partir dos quais ele é construído."><meta name=twitter:description content="Obtenha uma visão em alto-nível do Kubernetes e dos componentes a partir dos quais ele é construído."><meta property="og:url" content="https://kubernetes.io/pt-br/docs/concepts/overview/"><meta property="og:title" content="Visão Geral"><meta name=twitter:title content="Visão Geral"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/pt-br/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/pt-br/docs/>Documentação</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/pt-br/blog/>Kubernetes Blog</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/pt-br/partners/>Parceiros</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/pt-br/community/>Comunidade</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/pt-br/case-studies/>Casos de estudo</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Versões</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/pt-br/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/pt-br/docs/concepts/overview/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/pt-br/docs/concepts/overview/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/pt-br/docs/concepts/overview/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/pt-br/docs/concepts/overview/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/pt-br/docs/concepts/overview/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Português (Portuguese)</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/docs/concepts/overview/>English</a>
<a class=dropdown-item href=/zh-cn/docs/concepts/overview/>中文 (Chinese)</a>
<a class=dropdown-item href=/ko/docs/concepts/overview/>한국어 (Korean)</a>
<a class=dropdown-item href=/ja/docs/concepts/overview/>日本語 (Japanese)</a>
<a class=dropdown-item href=/fr/docs/concepts/overview/>Français (French)</a>
<a class=dropdown-item href=/it/docs/concepts/overview/>Italiano (Italian)</a>
<a class=dropdown-item href=/de/docs/concepts/overview/>Deutsch (German)</a>
<a class=dropdown-item href=/es/docs/concepts/overview/>Español (Spanish)</a>
<a class=dropdown-item href=/id/docs/concepts/overview/>Bahasa Indonesia</a>
<a class=dropdown-item href=/vi/docs/concepts/overview/>Tiếng Việt (Vietnamese)</a>
<a class=dropdown-item href=/ru/docs/concepts/overview/>Русский (Russian)</a>
<a class=dropdown-item href=/pl/docs/concepts/overview/>Polski (Polish)</a>
<a class=dropdown-item href=/uk/docs/concepts/overview/>Українська (Ukrainian)</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>Essa é a versão completa de impressão dessa seção
<a href=# onclick="return print(),!1">Clique aqui para imprimir</a>.</p><p><a href=/pt-br/docs/concepts/overview/>Retornar à visualização normal</a>.</p></div><h1 class=title>Visão Geral</h1><div class=lead>Obtenha uma visão em alto-nível do Kubernetes e dos componentes a partir dos quais ele é construído.</div><ul><li>1: <a href=#pg-45bdca6129cf540121623e903c18ba46>O que é Kubernetes?</a></li><li>2: <a href=#pg-13b0f1dbe89228e3d76d2ac231e245f1>Componentes do Kubernetes</a></li><li>3: <a href=#pg-110f33530cf761140cb1dab536baef04>Objetos do Kubernetes</a></li><ul><li>3.1: <a href=#pg-9f5adfa77f48c50d5cc81155a3cecb98>Entendendo os objetos do Kubernetes</a></li><li>3.2: <a href=#pg-f37749a83c2916b63279ea60f3cfe53e>Nomes de objetos e IDs</a></li><li>3.3: <a href=#pg-1127165f472b7181b9c1d5a0b187d620>Namespaces</a></li><li>3.4: <a href=#pg-046c03090d47bc4b89b818dc645c3865>Seletores de Campos</a></li></ul></ul><div class=content></div></div><div class=td-content><h1 id=pg-45bdca6129cf540121623e903c18ba46>1 - O que é Kubernetes?</h1><div class=lead>Kubernetes é um plataforma de código aberto, portável e extensiva para o gerenciamento de cargas de trabalho e serviços distribuídos em contêineres, que facilita tanto a configuração declarativa quanto a automação. Ele possui um ecossistema grande, e de rápido crescimento. Serviços, suporte, e ferramentas para Kubernetes estão amplamente disponíveis.</div><p>Essa página é uma visão geral do Kubernetes.</p><p>Kubernetes é um plataforma de código aberto, portável e extensiva para o gerenciamento de cargas de trabalho e serviços distribuídos em contêineres, que facilita tanto a configuração declarativa quanto a automação. Ele possui um ecossistema grande, e de rápido crescimento. Serviços, suporte, e ferramentas para Kubernetes estão amplamente disponíveis.</p><p>O Google tornou Kubernetes um projeto de código-aberto em 2014. O Kubernetes combina <a href=/blog/2015/04/borg-predecessor-to-kubernetes/>mais de 15 anos de experiência do Google</a> executando cargas de trabalho produtivas em escala, com as melhores idéias e práticas da comunidade.</p><p>O nome <strong>Kubernetes</strong> tem origem no Grego, significando <em>timoneiro</em> ou <em>piloto</em>. <strong>K8s</strong> é a abreviação derivada pela troca das oito letras "ubernete" por "8", se tornado <em>K"8"s</em>.</p><h2 id=voltando-no-tempo>Voltando no tempo</h2><p>Vamos dar uma olhada no porque o Kubernetes é tão útil, voltando no tempo.</p><p><img src=/images/docs/Container_Evolution.svg alt="Evolução das implantações"></p><p><strong>Era da implantação tradicional:</strong> No início, as organizações executavam aplicações em servidores físicos. Não havia como definir limites de recursos para aplicações em um mesmo servidor físico, e isso causava problemas de alocação de recursos. Por exemplo, se várias aplicações fossem executadas em um mesmo servidor físico, poderia haver situações em que uma aplicação ocupasse a maior parte dos recursos e, como resultado, o desempenho das outras aplicações seria inferior. Uma solução para isso seria executar cada aplicação em um servidor físico diferente. Mas isso não escalava, pois os recursos eram subutilizados, e se tornava custoso para as organizações manter muitos servidores físicos.</p><p><strong>Era da implantação virtualizada:</strong> Como solução, a virtualização foi introduzida. Esse modelo permite que você execute várias máquinas virtuais (VMs) em uma única CPU de um servidor físico. A virtualização permite que as aplicações sejam isoladas entre as VMs, e ainda fornece um nível de segurança, pois as informações de uma aplicação não podem ser acessadas livremente por outras aplicações.</p><p>A virtualização permite melhor utilização de recursos em um servidor físico, e permite melhor escalabilidade porque uma aplicação pode ser adicionada ou atualizada facilmente, reduz os custos de hardware e muito mais. Com a virtualização, você pode apresentar um conjunto de recursos físicos como um cluster de máquinas virtuais descartáveis.</p><p>Cada VM é uma máquina completa que executa todos os componentes, incluindo seu próprio sistema operacional, além do hardware virtualizado.</p><p><strong>Era da implantação em contêineres:</strong> Contêineres são semelhantes às VMs, mas têm propriedades de isolamento flexibilizados para compartilhar o sistema operacional (SO) entre as aplicações. Portanto, os contêineres são considerados leves. Semelhante a uma VM, um contêiner tem seu próprio sistema de arquivos, compartilhamento de CPU, memória, espaço de processo e muito mais. Como eles estão separados da infraestrutura subjacente, eles são portáveis entre nuvens e distribuições de sistema operacional.</p><p>Contêineres se tornaram populares porque eles fornecem benefícios extra, tais como:</p><ul><li>Criação e implantação ágil de aplicações: aumento da facilidade e eficiência na criação de imagem de contêiner comparado ao uso de imagem de VM.</li><li>Desenvolvimento, integração e implantação contínuos: fornece capacidade de criação e de implantação de imagens de contêiner de forma confiável e frequente, com a funcionalidade de efetuar reversões rápidas e eficientes (devido à imutabilidade da imagem).</li><li>Separação de interesses entre Desenvolvimento e Operações: crie imagens de contêineres de aplicações no momento de construção/liberação em vez de no momento de implantação, desacoplando as aplicações da infraestrutura.</li><li>A capacidade de observação (Observabilidade) não apenas apresenta informações e métricas no nível do sistema operacional, mas também a integridade da aplicação e outros sinais.</li><li>Consistência ambiental entre desenvolvimento, teste e produção: funciona da mesma forma em um laptop e na nuvem.</li><li>Portabilidade de distribuição de nuvem e sistema operacional: executa no Ubuntu, RHEL, CoreOS, localmente, nas principais nuvens públicas e em qualquer outro lugar.</li><li>Gerenciamento centrado em aplicações: eleva o nível de abstração da execução em um sistema operacional em hardware virtualizado à execução de uma aplicação em um sistema operacional usando recursos lógicos.</li><li>Microserviços fracamente acoplados, distribuídos, elásticos e livres: as aplicações são divididas em partes menores e independentes e podem ser implantados e gerenciados dinamicamente - não uma pilha monolítica em execução em uma grande máquina de propósito único.</li><li>Isolamento de recursos: desempenho previsível de aplicações.</li><li>Utilização de recursos: alta eficiência e densidade.</li></ul><h2 id=why-you-need-kubernetes-and-what-can-it-do>Por que você precisa do Kubernetes e o que ele pode fazer</h2><p>Os contêineres são uma boa maneira de agrupar e executar suas aplicações. Em um ambiente de produção, você precisa gerenciar os contêineres que executam as aplicações e garantir que não haja tempo de inatividade. Por exemplo, se um contêiner cair, outro contêiner precisa ser iniciado. Não seria mais fácil se esse comportamento fosse controlado por um sistema?</p><p>É assim que o Kubernetes vem ao resgate! O Kubernetes oferece uma estrutura para executar sistemas distribuídos de forma resiliente. Ele cuida do escalonamento e do recuperação à falha de sua aplicação, fornece padrões de implantação e muito mais. Por exemplo, o Kubernetes pode gerenciar facilmente uma implantação no método canário para seu sistema.</p><p>O Kubernetes oferece a você:</p><ul><li><strong>Descoberta de serviço e balanceamento de carga</strong>
O Kubernetes pode expor um contêiner usando o nome DNS ou seu próprio endereço IP. Se o tráfego para um contêiner for alto, o Kubernetes pode balancear a carga e distribuir o tráfego de rede para que a implantação seja estável.</li><li><strong>Orquestração de armazenamento</strong>
O Kubernetes permite que você monte automaticamente um sistema de armazenamento de sua escolha, como armazenamentos locais, provedores de nuvem pública e muito mais.</li><li><strong>Lançamentos e reversões automatizadas</strong>
Você pode descrever o estado desejado para seus contêineres implantados usando o Kubernetes, e ele pode alterar o estado real para o estado desejado em um ritmo controlada. Por exemplo, você pode automatizar o Kubernetes para criar novos contêineres para sua implantação, remover os contêineres existentes e adotar todos os seus recursos para o novo contêiner.</li><li><strong>Empacotamento binário automático</strong>
Você fornece ao Kubernetes um cluster de nós que pode ser usado para executar tarefas nos contêineres. Você informa ao Kubernetes de quanta CPU e memória (RAM) cada contêiner precisa. O Kubernetes pode encaixar contêineres em seus nós para fazer o melhor uso de seus recursos.</li><li><strong>Autocorreção</strong>
O Kubernetes reinicia os contêineres que falham, substitui os contêineres, elimina os contêineres que não respondem à verificação de integridade definida pelo usuário e não os anuncia aos clientes até que estejam prontos para servir.</li><li><strong>Gerenciamento de configuração e de segredos</strong>
O Kubernetes permite armazenar e gerenciar informações confidenciais, como senhas, tokens OAuth e chaves SSH. Você pode implantar e atualizar segredos e configuração de aplicações sem reconstruir suas imagens de contêiner e sem expor segredos em sua pilha de configuração.</li></ul><h2 id=o-que-o-kubernetes-não-é>O que o Kubernetes não é</h2><p>O Kubernetes não é um sistema PaaS (plataforma como serviço) tradicional e completo. Como o Kubernetes opera no nível do contêiner, e não no nível do hardware, ele fornece alguns recursos geralmente aplicáveis comuns às ofertas de PaaS, como implantação, escalonamento, balanceamento de carga, e permite que os usuários integrem suas soluções de <em>logging</em>, monitoramento e alerta. No entanto, o Kubernetes não é monolítico, e essas soluções padrão são opcionais e conectáveis. O Kubernetes fornece os blocos de construção para a construção de plataformas de desenvolvimento, mas preserva a escolha e flexibilidade do usuário onde é importante.</p><p>Kubernetes:</p><ul><li>Não limita os tipos de aplicações suportadas. O Kubernetes visa oferecer suporte a uma variedade extremamente diversa de cargas de trabalho, incluindo cargas de trabalho sem estado, com estado e de processamento de dados. Se uma aplicação puder ser executada em um contêiner, ele deve ser executado perfeitamente no Kubernetes.</li><li>Não implanta código-fonte e não constrói sua aplicação. Os fluxos de trabalho de integração contínua, entrega e implantação (CI/CD) são determinados pelas culturas e preferências da organização, bem como pelos requisitos técnicos.</li><li>Não fornece serviços em nível de aplicação, tais como middleware (por exemplo, barramentos de mensagem), estruturas de processamento de dados (por exemplo, Spark), bancos de dados (por exemplo, MySQL), caches, nem sistemas de armazenamento em cluster (por exemplo, Ceph), como serviços integrados. Esses componentes podem ser executados no Kubernetes e/ou podem ser acessados por aplicações executadas no Kubernetes por meio de mecanismos portáteis, como o <a href=https://openservicebrokerapi.org/>Open Service Broker</a>.</li><li>Não dita soluções de <em>logging</em>, monitoramento ou alerta. Ele fornece algumas integrações como prova de conceito e mecanismos para coletar e exportar métricas.</li><li>Não fornece nem exige um sistema/idioma de configuração (por exemplo, Jsonnet). Ele fornece uma API declarativa que pode ser direcionada por formas arbitrárias de especificações declarativas.</li><li>Não fornece nem adota sistemas abrangentes de configuração de máquinas, manutenção, gerenciamento ou autocorreção.</li><li>Adicionalmente, o Kubernetes não é um mero sistema de orquestração. Na verdade, ele elimina a necessidade de orquestração. A definição técnica de orquestração é a execução de um fluxo de trabalho definido: primeiro faça A, depois B e depois C. Em contraste, o Kubernetes compreende um conjunto de processos de controle independentes e combináveis que conduzem continuamente o estado atual em direção ao estado desejado fornecido. Não importa como você vai de A para C. O controle centralizado também não é necessário. Isso resulta em um sistema que é mais fácil de usar e mais poderoso, robusto, resiliente e extensível.</li></ul><h2 id=próximos-passos>Próximos passos</h2><ul><li>Dê uma olhada em <a href=/pt-br/docs/concepts/overview/components/>Componentes do Kubernetes</a>.</li><li>Pronto para <a href=/docs/setup/>Iniciar</a>?</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-13b0f1dbe89228e3d76d2ac231e245f1>2 - Componentes do Kubernetes</h1><div class=lead>Um cluster Kubernetes consiste de componentes que representam a camada de gerenciamento, e um conjunto de máquinas chamadas nós.</div><p>Ao implantar o Kubernetes, você obtém um cluster.<p><p>Um cluster Kubernetes consiste em um conjunto de servidores de processamento, chamados <a class=glossary-tooltip title='Um Nó é uma máquina de trabalho no Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/nodes/ target=_blank aria-label=nós>nós</a>, que executam aplicações containerizadas. Todo cluster possui ao menos um servidor de processamento (<em>worker node</em>).</p></p><p>O servidor de processamento hospeda os <a class=glossary-tooltip title='O menor e mais simples objeto Kubernetes. Um Pod representa um conjunto de contêineres em execução no seu cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/ target=_blank aria-label=Pods>Pods</a> que são componentes de uma aplicação. O <a class=glossary-tooltip title='A camada de gerenciamento de contêiner que expõe a API e as interfaces para definir, implantar e gerenciar o ciclo de vida dos contêineres.' data-toggle=tooltip data-placement=top href='/pt-br/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='ambiente de gerenciamento'>ambiente de gerenciamento</a> gerencia os nós de processamento e os Pods no cluster. Em ambientes de produção, o ambiente de gerenciamento geralmente executa em múltiplos computadores e um cluster geralmente executa em múltiplos nós (<em>nodes</em>) , provendo tolerância a falhas e alta disponibilidade.</p></p><p>Este documento descreve os vários componentes que você precisa ter para implantar um cluster Kubernetes completo e funcional.</p><p>Esse é o diagrama de um cluster Kubernetes com todos os componentes interligados.</p><p><img src=/images/docs/components-of-kubernetes.svg alt="Componentes do Kubernetes"></p><h2 id=componentes-da-camada-de-gerenciamento>Componentes da camada de gerenciamento</h2><p>Os componentes da camada de gerenciamento tomam decisões globais sobre o cluster (por exemplo, agendamento de <em>pods</em>), bem como detectam e respondem aos eventos do cluster (por exemplo, iniciando um novo <em><a class=glossary-tooltip title='O menor e mais simples objeto Kubernetes. Um Pod representa um conjunto de contêineres em execução no seu cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/ target=_blank aria-label=pod>pod</a></em> quando o campo <code>replicas</code> de um <em>Deployment</em> não está atendido).</p><p>Os componentes da camada de gerenciamento podem ser executados em qualquer máquina do cluster. Contudo, para simplificar, os <em>scripts</em> de configuração normalmente iniciam todos os componentes da camada de gerenciamento na mesma máquina, e não executa contêineres de usuário nesta máquina. Veja <a href=/docs/admin/high-availability/>Construindo clusters de alta disponibilidade</a> para um exemplo de configuração de múltiplas VMs para camada de gerenciamento (<em>multi-main-VM</em>).</p><h3 id=kube-apiserver>kube-apiserver</h3><p>O servidor de API é um componente da <a class=glossary-tooltip title='A camada de gerenciamento de contêiner que expõe a API e as interfaces para definir, implantar e gerenciar o ciclo de vida dos contêineres.' data-toggle=tooltip data-placement=top href='/pt-br/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='Camada de gerenciamento'>Camada de gerenciamento</a> do Kubernetes que expõe a API do Kubernetes.
O servidor de API é o <em>front end</em> para a camada de gerenciamento do Kubernetes.</p><p>A principal implementação de um servidor de API do Kubernetes é <a href=/docs/reference/generated/kube-apiserver/>kube-apiserver</a>.
O kube-apiserver foi projetado para ser escalonado horizontalmente — ou seja, ele pode ser escalado com a implantação de mais instâncias.
Você pode executar várias instâncias do kube-apiserver e balancear (balanceamento de carga, etc) o tráfego entre essas instâncias.</p><h3 id=etcd>etcd</h3><p>Armazenamento do tipo Chave-Valor consistente e em alta-disponibilidade usado como repositório de apoio do Kubernetes para todos os dados do cluster.</p><p>Se o seu cluster Kubernetes usa <strong>etcd</strong> como seu armazenamento de apoio, certifique-se de ter um plano de <a href=/docs/tasks/administer-cluster/configure-upgrade-etcd/#backing-up-an-etcd-cluster>back up</a> para seus dados.</p><p>Você pode encontrar informações detalhadas sobre o etcd na seção oficial da <a href=https://etcd.io/docs/>documentação</a>.</p><h3 id=kube-scheduler>kube-scheduler</h3><p>Componente da camada de gerenciamento que observa os <em><a class=glossary-tooltip title='O menor e mais simples objeto Kubernetes. Um Pod representa um conjunto de contêineres em execução no seu cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/ target=_blank aria-label=pods>pods</a></em> recém-criados sem nenhum <a class=glossary-tooltip title='Um Nó é uma máquina de trabalho no Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/nodes/ target=_blank aria-label=nó>nó</a> atribuído, e seleciona um nó para executá-los.</p><p>Os fatores levados em consideração para as decisões de agendamento incluem:
requisitos de recursos individuais e coletivos, hardware/software/política de restrições, especificações de afinidade e antiafinidade, localidade de dados, interferência entre cargas de trabalho, e prazos.</p><h3 id=kube-controller-manager>kube-controller-manager</h3><p>Componente da camada de gerenciamento que executa os processos de <a class=glossary-tooltip title='Um ciclo de controle que observa o estado partilhado do cluster através do API Server e efetua mudanças tentando mover o estado atual em direção ao estado desejado.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=controlador>controlador</a>.</p><p>Logicamente, cada <em><a class=glossary-tooltip title='Um ciclo de controle que observa o estado partilhado do cluster através do API Server e efetua mudanças tentando mover o estado atual em direção ao estado desejado.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=controlador>controlador</a></em> está em um processo separado, mas para reduzir a complexidade, eles todos são compilados num único binário e executam em um processo único.</p><p>Alguns tipos desses controladores são:</p><ul><li>Controlador de nó: responsável por perceber e responder quando os nós caem.</li><li>Controlador de <em>Job</em>: Observa os objetos <em>Job</em> que representam tarefas únicas e, em seguida, cria <em>pods</em> para executar essas tarefas até a conclusão.</li><li>Controlador de <em>endpoints</em>: preenche o objeto <em>Endpoints</em> (ou seja, junta os Serviços e os <em>pods</em>).</li><li>Controladores de conta de serviço e de <em>token</em>: crie contas padrão e <em>tokens</em> de acesso de API para novos <em>namespaces</em>.</li></ul><h3 id=cloud-controller-manager>cloud-controller-manager</h3>Um componente da <a class=glossary-tooltip title='A camada de gerenciamento de contêiner que expõe a API e as interfaces para definir, implantar e gerenciar o ciclo de vida dos contêineres.' data-toggle=tooltip data-placement=top href='/pt-br/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='camada de gerenciamento'>camada de gerenciamento</a> do Kubernetes
que incorpora a lógica de controle específica da nuvem. O gerenciador de controle de nuvem permite que você vincule seu
<em>cluster</em> na API do seu provedor de nuvem, e separar os componentes que interagem com essa plataforma de nuvem a partir de componentes que apenas interagem com seu cluster.<p>O cloud-controller-manager executa apenas controladores que são específicos para seu provedor de nuvem.
Se você estiver executando o Kubernetes em suas próprias instalações ou em um ambiente de aprendizagem dentro de seu
próprio PC, o cluster não possui um gerenciador de controlador de nuvem.</p><p>Tal como acontece com o kube-controller-manager, o cloud-controller-manager combina vários ciclos de controle logicamente independentes em um binário único que você executa como um processo único. Você pode escalar horizontalmente (executar mais de uma cópia) para melhorar o desempenho ou para auxiliar na tolerância a falhas.</p><p>Os seguintes controladores podem ter dependências de provedor de nuvem:</p><ul><li>Controlador de nó: para verificar junto ao provedor de nuvem para determinar se um nó foi excluído da nuvem após parar de responder.</li><li>Controlador de rota: para configurar rotas na infraestrutura de nuvem subjacente.</li><li>Controlador de serviço: Para criar, atualizar e excluir balanceadores de carga do provedor de nuvem.</li></ul><h2 id=node-components>Node Components</h2><p>Os componentes de nó são executados em todos os nós, mantendo os <em>pods</em> em execução e fornecendo o ambiente de execução do Kubernetes.</p><h3 id=kubelet>kubelet</h3><p>Um agente que é executado em cada <a class=glossary-tooltip title='Um Nó é uma máquina de trabalho no Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/nodes/ target=_blank aria-label=node>node</a> no cluster. Ele garante que os <a class=glossary-tooltip title='Uma imagem executável leve e portável que contém software e todas as suas dependências.' data-toggle=tooltip data-placement=top href=/docs/concepts/containers/ target=_blank aria-label=contêineres>contêineres</a> estejam sendo executados em um <a class=glossary-tooltip title='O menor e mais simples objeto Kubernetes. Um Pod representa um conjunto de contêineres em execução no seu cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/ target=_blank aria-label=Pod>Pod</a>.</p><p>O kubelet utiliza um conjunto de PodSpecs que são fornecidos por vários mecanismos e garante que os contêineres descritos nesses PodSpecs estejam funcionando corretamente. O kubelet não gerencia contêineres que não foram criados pelo Kubernetes.</p><h3 id=kube-proxy>kube-proxy</h3><p>kube-proxy é um <em>proxy</em> de rede executado em cada <a class=glossary-tooltip title='Um Nó é uma máquina de trabalho no Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/nodes/ target=_blank aria-label=nó>nó</a> no seu <em>cluster</em>,
implementando parte do conceito de <a class=glossary-tooltip title='Uma forma abstrata de expor uma aplicação que está executando em um conjunto de Pods como um serviço de rede.' data-toggle=tooltip data-placement=top href=/docs/concepts/services-networking/service/ target=_blank aria-label=serviço>serviço</a> do Kubernetes.</p><p><a href=/docs/reference/command-line-tools-reference/kube-proxy/>kube-proxy</a>
mantém regras de rede nos nós. Estas regras de rede permitem a comunicação de rede com seus <em>pods</em> a partir de sessões de rede dentro ou fora de seu <em>cluster</em>.</p><p>kube-proxy usa a camada de filtragem de pacotes do sistema operacional se houver uma e estiver disponível. Caso contrário, o kube-proxy encaminha o tráfego ele mesmo.</p><h3 id=container-runtime>Container runtime</h3><p>O agente de execução (<em>runtime</em>) de contêiner é o software responsável por executar os contêineres.</p><p>O Kubernetes suporta diversos agentes de execução de contêineres: <a class=glossary-tooltip title='Docker é uma tecnologia utilizada para prover virtualização a nível do sistema operacional também conhecidoa como containers.' data-toggle=tooltip data-placement=top href=https://docs.docker.com/engine/ target=_blank aria-label=Docker>Docker</a>, <a class=glossary-tooltip title='Um agente de execução de contêiner com enfase em simplicidade, robustez e portabilidade' data-toggle=tooltip data-placement=top href=https://containerd.io/docs/ target=_blank aria-label=containerd>containerd</a>, <a class=glossary-tooltip title='Um agente de execução leve de contêineres criado especificamente para o Kubernetes' data-toggle=tooltip data-placement=top href=https://cri-o.io/#what-is-cri-o target=_blank aria-label=CRI-O>CRI-O</a>, e qualquer implementação do <a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-node/container-runtime-interface.md>Kubernetes CRI (Container Runtime Interface)</a>.</p><h2 id=addons>Addons</h2><p>Complementos (<em>addons</em>) usam recursos do Kubernetes (<a class=glossary-tooltip title='Ensures a copy of a Pod is running across a set of nodes in a cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/daemonset target=_blank aria-label=DaemonSet>DaemonSet</a>, <a class=glossary-tooltip title='Manages a replicated application on your cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Deployment>Deployment</a>, etc) para implementar funcionalidades do cluster. Como fornecem funcionalidades em nível do cluster, recursos de <em>addons</em> que necessitem ser criados dentro de um <em>namespace</em> pertencem ao <em>namespace</em> <code>kube-system</code>.</p><p>Alguns <em>addons</em> selecionados são descritos abaixo; para uma lista estendida dos <em>addons</em> disponíveis, por favor consulte <a href=/docs/concepts/cluster-administration/addons/>Addons</a>.</p><h3 id=dns>DNS</h3><p>Embora os outros complementos não sejam estritamente necessários, todos os clusters do Kubernetes devem ter um <a href=/docs/concepts/services-networking/dns-pod-service/>DNS do cluster</a>, já que muitos exemplos dependem disso.</p><p>O DNS do cluster é um servidor DNS, além de outros servidores DNS em seu ambiente, que fornece registros DNS para serviços do Kubernetes.</p><p>Os contêineres iniciados pelo Kubernetes incluem automaticamente esse servidor DNS em suas pesquisas DNS.</p><h3 id=web-ui-dashboard>Web UI (Dashboard)</h3><p><a href=/docs/tasks/access-application-cluster/web-ui-dashboard/>Dashboard</a> é uma interface de usuário Web, de uso geral, para clusters do Kubernetes. Ele permite que os usuários gerenciem e solucionem problemas de aplicações em execução no cluster, bem como o próprio cluster.</p><h3 id=monitoramento-de-recursos-do-contêiner>Monitoramento de recursos do contêiner</h3><p><a href=/docs/tasks/debug-application-cluster/resource-usage-monitoring/>Monitoramento de recursos do contêiner</a> registra métricas de série temporal genéricas sobre os contêineres em um banco de dados central e fornece uma interface de usuário para navegar por esses dados.</p><h3 id=logging-a-nivel-do-cluster>Logging a nivel do cluster</h3><p>Um mecanismo de <a href=/docs/concepts/cluster-administration/logging/><em>logging</em> a nível do cluster</a> é responsável por guardar os <em>logs</em> dos contêineres em um armazenamento central de <em>logs</em> com um interface para navegação/pesquisa.</p><h2 id=próximos-passos>Próximos passos</h2><ul><li>Aprenda sobre <a href=/docs/concepts/architecture/nodes/>Nós</a>.</li><li>Aprenda sobre <a href=/docs/concepts/architecture/controller/>Controladores</a>.</li><li>Aprenda sobre <a href=/docs/concepts/scheduling-eviction/kube-scheduler/>kube-scheduler</a>.</li><li>Leia a <a href=https://etcd.io/docs/>documentação</a> oficial do <strong>etcd</strong>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-110f33530cf761140cb1dab536baef04>3 - Objetos do Kubernetes</h1></div><div class=td-content><h1 id=pg-9f5adfa77f48c50d5cc81155a3cecb98>3.1 - Entendendo os objetos do Kubernetes</h1><p>Esta página explica como os objetos do Kubernetes são representados na API do Kubernetes e como você pode expressá-los no formato <code>.yaml</code>.</p><h2 id=kubernetes-objects>Entendendo os objetos do Kubernetes</h2><p><em>Os objetos do Kubernetes</em> são entidades persistentes no Kubernetes. Kubernetes utiliza estas entidades para representar o estado do cluster. Especificamente, eles podem descrever:</p><ul><li>Quais aplicativos estão sendo executados (e em quais nós).</li><li>Os recursos disponíveis para esses aplicativos</li><li>As políticas acerca de como esses aplicativos se comportam, como políticas de reinicialização e tolerâncias a falhas.</li></ul><p>Um objeto do Kubernetes é um “registro de intenção”-uma vez criado o objeto, o sistema do Kubernetes trabalha constantemente para garantir que este objeto existe. Ao criar um objeto, você está efetivamente falando para o sistema do Kubernetes como você quer que a carga do seu cluster seja. Este é o <em>estado desejado</em> do seu cluster.</p><p>Para trabalhar com objetos do Kubernetes seja para criar, modificar ou deletar eles, você precisará usar a <a href=/docs/concepts/overview/kubernetes-api/>API do Kubernetes</a>. Quando você usa a interface de linha de comando do <code>kubectl</code>, por exemplo, o CLI faz as chamadas necessárias na API do Kubernetes para você. Você também pode usar a API do Kubernetes diretamente no seu próprio programa usando uma das <a href=/docs/reference/using-api/client-libraries/>Bibliotecas</a>.</p><h3 id=especificação-e-status-do-objeto>Especificação e status do objeto</h3><p>Quase todos os objetos do Kubernetes incluem dois campos de objetos aninhados que governam a configuração do objeto: a <em><code>especificação</code></em> do objeto e o <em><code>status</code></em> do objeto. Para objetos que têm especificação, você tem que definir isso quando você cria o objeto, fornecendo uma descrição das características que você quer que o recurso tenha: o seu <em>estado desejado</em>.</p><p>O <code>status</code> descreve o <em>estado atual</em> do objeto, fornecido e atualizado pelo Kubernetes e seus componentes. A <a class=glossary-tooltip title='A camada de gerenciamento de contêiner que expõe a API e as interfaces para definir, implantar e gerenciar o ciclo de vida dos contêineres.' data-toggle=tooltip data-placement=top href='/pt-br/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='camada de gerenciamento'>camada de gerenciamento</a> do Kubernetes gerêncai continuamente e ativamente o real estado para corresponder ao estado desejado que você forneceu.</p><p>Por exemplo, no Kubernetes, o <a class=glossary-tooltip title='Manages a replicated application on your cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Deployment>Deployment</a> é um objeto que pode representar uma aplicação executando no seu cluster. Quando você cria o Deployment, você pode alterar a <code>especificação</code>para definir que você quer três réplicas da aplicação em execução simultânea. O Kubernetes lê as especificações do Deployment e inicia três instâncias do seu aplicativo desejado, atualizando o status para corresponder às suas especificações. Se uma dessas instâncias falhar (um status mudar), o Kubernetes responde as diferenças entre as especificações e o status fazendo uma correção-neste caso, iniciando uma instância de substituição.</p><p>Para mais informações sobre especificações do objeto, status e metadados, veja <a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md>Kubernetes API Conventions</a>.</p><h3 id=descrevendo-um-objeto-kubernetes>Descrevendo um objeto Kubernetes</h3><p>Quando se cria um objeto do Kubernetes, deve-se fornecer a especificação do objeto que descreve seu estado desejado, bem como algumas informações básicas sobre o objeto (como um nome, por exemplo). Quando utiliza a API Kubernetes para criar o objeto (diretamente ou via <code>kubectl</code>), essa solicitação de API deve incluir essa informação como JSON no corpo da solicitação. <strong>Na maioria das vezes, você fornece as informações ao comando <code>kubectl</code> em um arquivo .yaml</strong>. O comando<code>kubectl</code> converte a informação para JSON ao fazer a requisição para a API.</p><p>Aqui está um exemplo de arquivo <code>.yaml</code> que mostra os campos necessários e as especificações de objeto para uma implatação Kubernetes:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/pt-br/examples/application/deployment.yaml download=application/deployment.yaml><code>application/deployment.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("application-deployment-yaml")' title="Copy application/deployment.yaml to clipboard"></img></div><div class=includecode id=application-deployment-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># diz ao deployment para executar 2 pods que correspondam ao modelo</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Uma maneira de criar um Deployment usando um arquivo <code>.yaml</code> como o representado acima é usar o comando <a href=/docs/reference/generated/kubectl/kubectl-commands#apply><code>kubectl apply</code></a> na interface de linha de comando <code>kubectl</code>, passando o arquivo <code>.yaml</code> como argumento. Aqui está um exemplo:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/application/deployment.yaml
</span></span></code></pre></div><p>A saída será similar a esta:</p><pre tabindex=0><code>deployment.apps/nginx-deployment created
</code></pre><h3 id=campos-obrigatórios>Campos obrigatórios</h3><p>No arquivo <code>.yaml</code> para o objeto Kubernetes que pretende criar, você precisará definir valores para os seguintes campos:</p><ul><li><code>apiVersion</code> - Qual a versão de API do objeto que será usado no Kubernetes para criar esse objeto.</li><li><code>kind</code> - Qual tipo de objeto pretende criar.</li><li><code>metadata</code> - Dados que ajudam a identificar de forma única o objeto, incluindo uma string <code>nome</code>, <code>UID</code> e um <code>namespace</code>.</li><li><code>spec</code> - Que estado deseja para o objeto.</li></ul><p>O formato preciso do objeto <code>spec</code> é diferente para cada objeto Kubernetes, e contém campos aninhados específicos para aquele objeto. A documentação de <a href=/docs/reference/kubernetes-api/>referência da API do Kubernetes</a> pode ajudar a encontrar o formato de especificação para todos os objetos que você pode criar usando Kubernetes.</p><p>Por exemplo, veja o campo de <a href=/docs/reference/kubernetes-api/workload-resources/pod-v1/#PodSpec><code>spec</code> field</a> para a referência Pod API.
Para cada Pod, o campo <code>.spec</code> especifica o pod e seu estado desejado (como o nome da imagem do contêiner para cada recipiente dentro daquela cápsula).
Outro exemplo de especificação de um objeto é o
<a href=/docs/reference/kubernetes-api/workload-resources/stateful-set-v1/#StatefulSetSpec>campo <code>spec</code> </a>.
Para o StatefulSet, o campo <code>.spec</code> especifica o StatefulSet e seu estado desejado.
Dentro do <code>.spec</code> de um StatefulSet está um <a href=/docs/concepts/workloads/pods/#pod-templates>template</a>
para objetos de Pod. Esse modelo descreve os Pods que o controlador StatefulSet criará para
satisfazer a especificação do StatefulSet. Diferentes tipos de objetos também podem ter diferentes
<code>.status</code>; novamente, as páginas de referência API detalham a estrutura daquele campo <code>.status</code>,
e seu conteúdo para cada tipo diferente de objeto.</p><h2 id=próximos-passos>Próximos passos</h2><p>Aprenda sobre os mais importantes objetos básicos Kubernetes, como o <a href=/docs/concepts/workloads/pods>Pod</a>.
Aprenda sobre as <a href=/docs/concepts/architecture/controller/>controladoras</a> do Kubernetes.
<a href=/docs/reference/using-api>Usando a API Kubernetes</a> explica mais alguns conceitos da API.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-f37749a83c2916b63279ea60f3cfe53e>3.2 - Nomes de objetos e IDs</h1><p>Cada objeto em seu cluster possui um <a href=#names><em>Nome</em></a> que é único para aquele
tipo de recurso.
Todo objeto do Kubernetes também possui um <a href=#uids><em>UID</em></a> que é único para todo
o cluster.</p><p>Por exemplo, você pode ter apenas um Pod chamado <code>myapp-1234</code> dentro de um
<a href=/pt-br/docs/concepts/overview/working-with-objects/namespaces/>namespace</a>, porém
você pode ter um Pod e um Deployment ambos com o nome <code>myapp-1234</code>.</p><p>Para atributos não-únicos definidos pelo usuário, o Kubernetes fornece
<a href=/docs/concepts/overview/working-with-objects/labels/>labels</a> e
<a href=/docs/concepts/overview/working-with-objects/annotations/>annotations</a>.</p><h2 id=names>Nomes</h2><p>Uma string fornecida pelo cliente que referencia um objeto em uma URL de
recurso, como por exemplo <code>/api/v1/pods/qualquer-nome</code>.</p><p>Somente um objeto de um dado tipo pode ter um certo nome por vez. No entanto,
se você remover o objeto, você poderá criar um novo objeto com o mesmo nome.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Em casos em que objetos representam uma entidade física, como no caso de um Nó
representando um host físico, caso o host seja recriado com o mesmo nome mas o
objeto Nó não seja recriado, o Kubernetes trata o novo host como o host antigo,
o que pode causar inconsistências.</div><p>Abaixo estão descritos quatro tipos de restrições de nomes comumente utilizadas
para recursos.</p><h3 id=dns-subdomain-names>Nomes de subdomínio DNS</h3><p>A maior parte dos recursos do Kubernetes requerem um nome que possa ser
utilizado como um nome de subdomínio DNS, conforme definido na
<a href=https://tools.ietf.org/html/rfc1123>RFC 1123</a>.
Isso significa que o nome deve:</p><ul><li>conter no máximo 253 caracteres</li><li>conter somente caracteres alfanuméricos em caixa baixa, traço ('-') ou ponto
('.').</li><li>iniciar com um caractere alfanumérico</li><li>terminar com um caractere alfanumérico</li></ul><h3 id=dns-label-names>Nomes de rótulos da RFC 1123</h3><p>Alguns tipos de recurso requerem que seus nomes sigam o padrão de rótulos DNS
definido na <a href=https://tools.ietf.org/html/rfc1123>RFC 1123</a>.
Isso significa que o nome deve:</p><ul><li>conter no máximo 63 caracteres</li><li>conter somente caracteres alfanuméricos em caixa baixa ou traço ('-')</li><li>iniciar com um caractere alfanumérico</li><li>terminar com um caractere alfanumérico</li></ul><h3 id=nomes-de-rótulo-da-rfc-1035>Nomes de rótulo da RFC 1035</h3><p>Alguns tipos de recurso requerem que seus nomes sigam o padrão de rótulos DNS
definido na <a href=https://tools.ietf.org/html/rfc1035>RFC 1035</a>.
Isso significa que o nome deve:</p><ul><li>conter no máximo 63 caracteres</li><li>conter somente caracteres alfanuméricos em caixa baixa ou traço ('-')</li><li>iniciar com um caractere alfanumérico</li><li>terminar com um caractere alfanumérico</li></ul><h3 id=nomes-de-segmentos-de-caminhos>Nomes de segmentos de caminhos</h3><p>Alguns tipos de recurso requerem que seus nomes possam ser seguramente
codificados como um segmento de caminho, ou seja, o nome não pode ser "." ou
".." e não pode conter "/" ou "%".</p><p>Exemplo de um manifesto para um Pod chamado <code>nginx-demo</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.7.9<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Alguns tipos de recursos possuem restrições adicionais em seus nomes.</div><h2 id=uids>UIDs</h2><p>Uma string gerada pelos sistemas do Kubernetes para identificar objetos de
forma única.</p><p>Cada objeto criado durante todo o ciclo de vida do cluster do Kubernetes possui
um UID distinto. O objetivo deste identificador é distinguir ocorrências
históricas de entidades semelhantes.</p><p>UIDs no Kubernetes são identificadores únicos universais (também conhecidos como
UUIDs).
UUIDs seguem os padrões ISO/IEC 9834-8 e ITU-T X.667.</p><h2 id=próximos-passos>Próximos passos</h2><ul><li>Leia sobre <a href=/docs/concepts/overview/working-with-objects/labels/>labels</a> no Kubernetes.</li><li>Consulte o documento de design <a href=https://git.k8s.io/design-proposals-archive/architecture/identifiers.md>Identifiers and Names in Kubernetes</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-1127165f472b7181b9c1d5a0b187d620>3.3 - Namespaces</h1><p>No Kubernetes, <em>namespaces</em> disponibilizam um mecanismo para isolar grupos de recursos dentro de um único cluster. Nomes de recursos precisam ser únicos dentro de um namespace, porém podem se repetir em diferentes namespaces. Escopos baseados em namespaces são aplicáveis apenas para objetos com namespace <em>(como: Deployments, Services, etc)</em> e não em objetos que abrangem todo o cluster <em>(como: StorageClass, Nodes, PersistentVolumes, etc)</em>.</p><h2 id=quando-utilizar-múltiplos-namespaces>Quando Utilizar Múltiplos Namespaces</h2><p>Namespaces devem ser utilizados em ambientes com múltiplos usuários espalhados por diversos times ou projetos. Para clusters com poucos ou até algumas dezenas de usuários, você não deveria precisar criar ou pensar a respeito de namespaces. Comece a utilizar namespaces quando você precisar das funcionalidades que eles oferecem.</p><p>Namespaces oferecem escopo para nomes. Nomes de recursos precisam ser únicos dentro de um namespace, porém não em diferentes namespaces. Namespaces não podem ser aninhados dentro de outros namespaces e cada recurso Kubernetes pode pertencer à apenas um namespace.</p><p>Namespaces nos permitem dividir os recursos do cluster entre diferentes usuários (via <a href=/docs/concepts/policy/resource-quotas/>resource quota</a>).</p><p>Não é necessário utilizar múltiplos namespaces para separar recursos levemente diferentes, como diferentes versões de um mesmo software: use <a class=glossary-tooltip title='Tags objects with identifying attributes that are meaningful and relevant to users.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/labels target=_blank aria-label=labels>labels</a> para distinguir recursos dentro de um mesmo namespace.</p><h2 id=trabalhando-com-namespaces>Trabalhando com Namespaces</h2><p>Criação e eliminação de namespaces estão descritas na
<a href=/docs/tasks/administer-cluster/namespaces>documentação de namespaces do guia de administradores</a>.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Evite criar namespaces com o prefixo <code>kube-</code>, já que este prefixo é reservado para namespaces do sistema Kubernetes.</div><h3 id=visualizando-namespaces>Visualizando namespaces</h3><p>Você pode obter uma lista dos namespaces atuais dentro de um cluster com:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get namespace
</span></span></code></pre></div><pre tabindex=0><code>NAME              STATUS   AGE
default           Active   1d
kube-node-lease   Active   1d
kube-public       Active   1d
kube-system       Active   1d
</code></pre><p>O Kubernetes é inicializado com quatro namespaces:</p><ul><li><code>default</code> O namespace padrão para objetos sem namespace</li><li><code>kube-system</code> O namespace para objetos criados pelo sistema Kubernetes</li><li><code>kube-public</code> Este namespace é criado automaticamente e é legível por todos os usuários (incluindo usuários não autenticados). Este namespace é reservado principalmente para uso do cluster, no caso de alguns recursos que precisem ser visíveis e legíveis publicamente por todo o cluster. O aspecto público deste namespace é apenas uma convenção, não um requisito.</li><li><code>kube-node-lease</code> Este namespace contém os objetos de <a href=/docs/reference/kubernetes-api/cluster-resources/lease-v1/>Lease</a> associados com cada node. Node leases permitem que o kubelet envie <a href=/docs/concepts/architecture/nodes/#heartbeats>heartbeats</a> para que a camada de gerenciamento detecte falhas nos nodes.</li></ul><h3 id=preparando-o-namespace-para-uma-requisição>Preparando o namespace para uma requisição</h3><p>Para preparar o namespace para a requisição atual, utilize o parâmetro <code>--namespace</code>. Por exemplo:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl run nginx --image<span style=color:#666>=</span>nginx --namespace<span style=color:#666>=</span>&lt;insert-namespace-name-here&gt;
</span></span><span style=display:flex><span>kubectl get pods --namespace<span style=color:#666>=</span>&lt;insert-namespace-name-here&gt;
</span></span></code></pre></div><h3 id=configurando-a-preferência-de-namespaces>Configurando a preferência de namespaces</h3><p>Você pode salvar permanentemente o namespace para todos os comandos <code>kubectl</code> subsequentes no mesmo contexto:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config set-context --current --namespace<span style=color:#666>=</span>&lt;insert-namespace-name-here&gt;
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Validando</span>
</span></span><span style=display:flex><span>kubectl config view --minify | grep namespace:
</span></span></code></pre></div><h2 id=namespaces-e-dns>Namespaces e DNS</h2><p>Quando você cria um <a href=/docs/concepts/services-networking/service/>Serviço</a>, ele cria uma
<a href=/docs/concepts/services-networking/dns-pod-service/>entrada DNS</a> correspondente.
Esta entrada possui o formato: <code>&lt;service-name>.&lt;namespace-name>.svc.cluster.local</code>, de forma que se um contêiner utilizar apenas <code>&lt;service-name></code> ele será resolvido para um serviço que é local ao namespace.
Isso é útil para utilizar a mesma configuração em vários namespaces, por exemplo em Desenvolvimento, <code>Staging</code> e Produção. Se você quiser acessar múltiplos namespaces, precisará utilizar um <em>Fully Qualified Domain Name</em> (FQDN).</p><h2 id=nem-todos-os-objetos-pertencem-a-algum-namespace>Nem todos os objetos pertencem a algum Namespace</h2><p>A maior parte dos recursos Kubernetes (como Pods, Services, controladores de replicação e outros) pertencem a algum namespace. Entretanto, recursos de namespaces não pertencem a nenhum namespace. Além deles, recursos de baixo nível, como <a href=/docs/concepts/architecture/nodes/>nodes</a> e persistentVolumes, também não pertencem a nenhum namespace.</p><p>Para visualizar quais recursos Kubernetes pertencem ou não a algum namespace, utilize:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Em um namespace</span>
</span></span><span style=display:flex><span>kubectl api-resources --namespaced<span style=color:#666>=</span><span style=color:#a2f>true</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Sem namespace</span>
</span></span><span style=display:flex><span>kubectl api-resources --namespaced<span style=color:#666>=</span><span style=color:#a2f>false</span>
</span></span></code></pre></div><h2 id=rotulamento-automático>Rotulamento Automático</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes 1.21 [beta]</code></div><p>A camada de gerenciamento Kubernetes configura um <a class=glossary-tooltip title='Tags objects with identifying attributes that are meaningful and relevant to users.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/labels target=_blank aria-label=label>label</a> imutável <code>kubernetes.io/metadata.name</code> em todos os namespaces se a
<a href=/docs/reference/command-line-tools-reference/feature-gates/>feature gate</a>
<code>NamespaceDefaultLabelName</code> estiver habilitada. O valor do label é o nome do namespace.</p><h2 id=próximos-passos>Próximos passos</h2><ul><li>Leia sobre <a href=/docs/tasks/administer-cluster/namespaces/#creating-a-new-namespace>a criação de um novo namespace</a>.</li><li>Leia sobre <a href=/docs/tasks/administer-cluster/namespaces/#deleting-a-namespace>a eliminação de um namespace</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-046c03090d47bc4b89b818dc645c3865>3.4 - Seletores de Campos</h1><p>Os <em>Seletores de Campos</em> permitem que você <a href=/docs/concepts/overview/working-with-objects/kubernetes-objects>selecione recursos do Kubernetes</a> baseado no valor de um ou mais campos de um recurso. Seguem alguns exemplos de buscas utilizando seletores de campos:</p><ul><li><code>metadata.name=my-service</code></li><li><code>metadata.namespace!=default</code></li><li><code>status.phase=Pending</code></li></ul><p>O comando <code>kubectl</code>, mostrado a seguir, seleciona todos os Pods nos quais o valor do campo <a href=/docs/concepts/workloads/pods/pod-lifecycle/#pod-phase><code>status.phase</code></a> é <code>Running</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods --field-selector status.phase<span style=color:#666>=</span>Running
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Seletores de campos são essencialmente <em>filtros</em> de recursos. Por padrão, nenhum seletor/filtro é aplicado, de forma que todos os recursos do tipo especificado são selecionados. Isso faz com que as seguintes pesquisas utilizando <code>kubectl</code> sejam equivalentes: <code>kubectl get pods</code> e <code>kubectl get pods --field-selector ""</code></div><h2 id=campos-suportados>Campos suportados</h2><p>Os campos de seleção suportados variam dependendo do tipo de recurso Kubernetes. Todos os tipos de recursos suportam os campos <code>metadata.name</code> e <code>metadata.namespace</code>. Utilizar campos não suportados produz um erro. Como por exemplo:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get ingress --field-selector foo.bar<span style=color:#666>=</span>baz
</span></span></code></pre></div><pre tabindex=0><code>Error from server (BadRequest): Unable to find &#34;ingresses&#34; that match label selector &#34;&#34;, field selector &#34;foo.bar=baz&#34;: &#34;foo.bar&#34; is not a known field selector: only &#34;metadata.name&#34;, &#34;metadata.namespace&#34;
</code></pre><h2 id=operadores-suportados>Operadores suportados</h2><p>Você pode utilizar os operadores <code>=</code>, <code>==</code> e <code>!=</code> com seletores de campos (<code>=</code> e <code>==</code> significam a mesma coisa). Por exemplo, o comando <code>kubectl</code> a seguir seleciona todos os Kubernetes Services que não estão no namespace <code>default</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get services  --all-namespaces --field-selector metadata.namespace!<span style=color:#666>=</span>default
</span></span></code></pre></div><h2 id=seletores-em-cadeia>Seletores em cadeia</h2><p>Assim como <a href=/docs/concepts/overview/working-with-objects/labels>label</a> e outros tipos de seletores, podem ser utilizados em cadeia através de uma lista separada por vírgula. O comando <code>kubectl</code> a seguir seleciona todos os Pods nos quais <code>status.phase</code> não é igual a <code>Running</code> e <code>spec.restartPolicy</code> é igual a <code>Always</code></p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods --field-selector<span style=color:#666>=</span>status.phase!<span style=color:#666>=</span>Running,spec.restartPolicy<span style=color:#666>=</span>Always
</span></span></code></pre></div><h2 id=múltiplos-tipos-de-recursos>Múltiplos tipos de recursos</h2><p>Você pode utilizar seletores de campos através de múltiplos tipos de recursos. Por exemplo, o comando <code>kubectl</code> a seguir seleciona todos Statefulsets e Services que não estão presentes no namespace <code>default</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get statefulsets,services --all-namespaces --field-selector metadata.namespace!<span style=color:#666>=</span>default
</span></span></code></pre></div></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/pt-br/docs/home/>Home</a>
<a class=text-white href=/pt-br/blog/>Blog</a>
<a class=text-white href=/pt-br/partners/>Parceiros</a>
<a class=text-white href=/pt-br/community/>Comunidade</a>
<a class=text-white href=/pt-br/case-studies/>Casos de estudo</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 Os autores do Kubernetes | Documentação Distribuída sob <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small><br><small class=text-white>Copyright &copy; 2023 A Fundação Linux &reg;. Todos os direitos reservados. A Linux Foundation tem marcas registradas e usa marcas registradas. Para uma lista de marcas registradas da The Linux Foundation, por favor, veja nossa <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>Página de uso de marca registrada</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>