<!doctype html><html lang=pt-br class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=en href=https://kubernetes.io/docs/concepts/containers/><link rel=alternate hreflang=zh-cn href=https://kubernetes.io/zh-cn/docs/concepts/containers/><link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/concepts/containers/><link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/concepts/containers/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/concepts/containers/><link rel=alternate hreflang=it href=https://kubernetes.io/it/docs/concepts/containers/><link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/concepts/containers/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/concepts/containers/><link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/concepts/containers/><link rel=alternate hreflang=vi href=https://kubernetes.io/vi/docs/concepts/containers/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/pt-br/docs/concepts/containers/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>Contêineres | Kubernetes</title><meta property="og:title" content="Contêineres"><meta property="og:description" content="Tecnologia para empacotar aplicações com suas dependências em tempo de execução"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/pt-br/docs/concepts/containers/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="Contêineres"><meta itemprop=description content="Tecnologia para empacotar aplicações com suas dependências em tempo de execução"><meta name=twitter:card content="summary"><meta name=twitter:title content="Contêineres"><meta name=twitter:description content="Tecnologia para empacotar aplicações com suas dependências em tempo de execução"><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content="Tecnologia para empacotar aplicações com suas dependências em tempo de execução"><meta property="og:description" content="Tecnologia para empacotar aplicações com suas dependências em tempo de execução"><meta name=twitter:description content="Tecnologia para empacotar aplicações com suas dependências em tempo de execução"><meta property="og:url" content="https://kubernetes.io/pt-br/docs/concepts/containers/"><meta property="og:title" content="Contêineres"><meta name=twitter:title content="Contêineres"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/pt-br/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/pt-br/docs/>Documentação</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/pt-br/blog/>Kubernetes Blog</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/pt-br/partners/>Parceiros</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/pt-br/community/>Comunidade</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/pt-br/case-studies/>Casos de estudo</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Versões</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/pt-br/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/pt-br/docs/concepts/containers/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/pt-br/docs/concepts/containers/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/pt-br/docs/concepts/containers/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/pt-br/docs/concepts/containers/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/pt-br/docs/concepts/containers/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Português (Portuguese)</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/docs/concepts/containers/>English</a>
<a class=dropdown-item href=/zh-cn/docs/concepts/containers/>中文 (Chinese)</a>
<a class=dropdown-item href=/ko/docs/concepts/containers/>한국어 (Korean)</a>
<a class=dropdown-item href=/ja/docs/concepts/containers/>日本語 (Japanese)</a>
<a class=dropdown-item href=/fr/docs/concepts/containers/>Français (French)</a>
<a class=dropdown-item href=/it/docs/concepts/containers/>Italiano (Italian)</a>
<a class=dropdown-item href=/de/docs/concepts/containers/>Deutsch (German)</a>
<a class=dropdown-item href=/es/docs/concepts/containers/>Español (Spanish)</a>
<a class=dropdown-item href=/id/docs/concepts/containers/>Bahasa Indonesia</a>
<a class=dropdown-item href=/vi/docs/concepts/containers/>Tiếng Việt (Vietnamese)</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>Essa é a versão completa de impressão dessa seção
<a href=# onclick="return print(),!1">Clique aqui para imprimir</a>.</p><p><a href=/pt-br/docs/concepts/containers/>Retornar à visualização normal</a>.</p></div><h1 class=title>Contêineres</h1><div class=lead>Tecnologia para empacotar aplicações com suas dependências em tempo de execução</div><ul><li>1: <a href=#pg-16042b4652ad19e565c7263824029a43>Imagens</a></li><li>2: <a href=#pg-643212488f778acf04bebed65ba34441>Ambiente de Contêiner</a></li><li>3: <a href=#pg-a858027489648786a3b16264e451272b>Classes de execução</a></li><li>4: <a href=#pg-e6941d969d81540208a3e78bc56f43bc>Hooks de Ciclo de Vida do Contêiner</a></li></ul><div class=content><p>Cada contêiner executado é repetível; a padronização de ter
dependências incluídas significa que você obtém o mesmo comportamento onde quer que você execute.</p><p>Os contêineres separam os aplicativos da infraestrutura de <em>host</em> subjacente.
Isso torna a implantação mais fácil em diferentes ambientes de nuvem ou sistema operacional.</p><h2 id=imagem-de-contêiner>Imagem de contêiner</h2><p>Uma <a href=/docs/concepts/containers/images/>imagem de contêiner</a> é um pacote de software pronto para executar, contendo tudo que é preciso para executar uma aplicação:
o código e o agente de execução necessário, aplicação, bibliotecas do sistema e valores padrões para qualquer configuração essencial.</p><p>Por <em>design</em>, um contêiner é imutável: você não pode mudar o código de um contêiner que já está executando. Se você tem uma aplicação conteinerizada e quer fazer mudanças, você precisa construir uma nova imagem que inclui a mudança, e recriar o contêiner para iniciar a partir da imagem atualizada.</p><h2 id=agente-de-execução-de-contêiner>Agente de execução de contêiner</h2><p>O agente de execução (<em>runtime</em>) de contêiner é o software responsável por executar os contêineres.</p><p>O Kubernetes suporta diversos agentes de execução de contêineres: <a class=glossary-tooltip title='Docker é uma tecnologia utilizada para prover virtualização a nível do sistema operacional também conhecidoa como containers.' data-toggle=tooltip data-placement=top href=https://docs.docker.com/engine/ target=_blank aria-label=Docker>Docker</a>, <a class=glossary-tooltip title='Um agente de execução de contêiner com enfase em simplicidade, robustez e portabilidade' data-toggle=tooltip data-placement=top href=https://containerd.io/docs/ target=_blank aria-label=containerd>containerd</a>, <a class=glossary-tooltip title='Um agente de execução leve de contêineres criado especificamente para o Kubernetes' data-toggle=tooltip data-placement=top href=https://cri-o.io/#what-is-cri-o target=_blank aria-label=CRI-O>CRI-O</a>, e qualquer implementação do <a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-node/container-runtime-interface.md>Kubernetes CRI (Container Runtime Interface)</a>.</p><h2 id=próximos-passos>Próximos passos</h2><ul><li><a href=/docs/concepts/containers/images/>Imagens de contêineres</a></li><li><a href=/docs/concepts/workloads/pods/>Pods</a></li></ul></div></div><div class=td-content style=page-break-before:always><h1 id=pg-16042b4652ad19e565c7263824029a43>1 - Imagens</h1><p>Uma imagem de contêiner representa dados binários que encapsulam uma aplicação e todas as suas dependências de software. As imagens de contêiner são pacotes de software executáveis que podem ser executados de forma autônoma e que fazem suposições muito bem definidas sobre seu agente de execução do ambiente.</p><p>Normalmente, você cria uma imagem de contêiner da sua aplicação e a envia para um registro antes de fazer referência a ela em um <a class=glossary-tooltip title='O menor e mais simples objeto Kubernetes. Um Pod representa um conjunto de contêineres em execução no seu cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/ target=_blank aria-label=Pod>Pod</a></p><p>Esta página fornece um resumo sobre o conceito de imagem de contêiner.</p><h2 id=nomes-das-imagens>Nomes das imagens</h2><p>As imagens de contêiner geralmente recebem um nome como <code>pause</code>, <code>exemplo/meuconteiner</code>, ou <code>kube-apiserver</code>.
As imagens também podem incluir um hostname de algum registro; por exemplo: <code>exemplo.registro.ficticio/nomeimagem</code>,
e um possível número de porta; por exemplo: <code>exemplo.registro.ficticio:10443/nomeimagem</code>.</p><p>Se você não especificar um hostname de registro, o Kubernetes presumirá que você se refere ao registro público do Docker.</p><p>Após a parte do nome da imagem, você pode adicionar uma <em>tag</em> (como também usar com comandos como <code>docker</code> e<code> podman</code>).
As tags permitem identificar diferentes versões da mesma série de imagens.</p><p>Tags de imagem consistem em letras maiúsculas e minúsculas, dígitos, sublinhados (<code>_</code>),
pontos (<code>.</code>) e travessões (<code> -</code>).
Existem regras adicionais sobre onde você pode colocar o separador
caracteres (<code>_</code>,<code>-</code> e <code>.</code>) dentro de uma tag de imagem.
Se você não especificar uma tag, o Kubernetes presumirá que você se refere à tag <code>latest</code> (mais recente).</p><div class="alert alert-warning caution callout" role=alert><strong>Cuidado:</strong><p>Você deve evitar usar a tag <code>latest</code> quando estiver realizando o deploy de contêineres em produção,
pois é mais difícil rastrear qual versão da imagem está sendo executada, além de tornar mais difícil o processo de reversão para uma versão funcional.</p><p>Em vez disso, especifique uma tag significativa, como <code>v1.42.0</code>.</p></div><h2 id=atualizando-imagens>Atualizando imagens</h2><p>A política padrão de pull é <code>IfNotPresent</code> a qual faz com que o
<a class=glossary-tooltip title='Um agente que é executado em cada node no cluster. Ele garante que os contêineres estejam sendo executados em um pod.' data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kubelet target=_blank aria-label=kubelet>kubelet</a> ignore
o processo de <em>pull</em> da imagem, caso a mesma já exista. Se você prefere sempre forçar o processo de <em>pull</em>,
você pode seguir uma das opções abaixo:</p><ul><li>defina a <code>imagePullPolicy</code> do contêiner para<code> Always</code>.</li><li>omita <code>imagePullPolicy</code> e use<code>: latest</code> como a tag para a imagem a ser usada.</li><li>omita o <code>imagePullPolicy</code> e a tag da imagem a ser usada.</li><li>habilite o <a href=/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages>AlwaysPullImages</a> controlador de admissão.</li></ul><p>Quando <code>imagePullPolicy</code> é definido sem um valor específico, ele também é definido como<code> Always</code>.</p><h2 id=multiarquitetura-de-imagens-com-índice-de-imagens>Multiarquitetura de imagens com índice de imagens</h2><p>Além de fornecer o binário das imagens, um registro de contêiner também pode servir um <a href=https://github.com/opencontainers/image-spec/blob/master/image-index.md>índice de imagem do contêiner</a>. Um índice de imagem pode apontar para múltiplos <a href=https://github.com/opencontainers/image-spec/blob/master/manifest.md>manifestos da imagem</a> para versões específicas de arquitetura de um contêiner. A ideia é que você possa ter um nome para uma imagem (por exemplo: <code>pause</code>, <code>exemple/meuconteiner</code>, <code>kube-apiserver</code>) e permitir que diferentes sistemas busquem o binário da imagem correta para a arquitetura de máquina que estão usando.</p><p>O próprio Kubernetes normalmente nomeia as imagens de contêiner com o sufixo <code>-$(ARCH)</code>. Para retrocompatibilidade, gere as imagens mais antigas com sufixos. A ideia é gerar a imagem <code>pause</code> que tem o manifesto para todas as arquiteturas e <code>pause-amd64</code> que é retrocompatível com as configurações anteriores ou arquivos YAML que podem ter codificado as imagens com sufixos.</p><h2 id=usando-um-registro-privado>Usando um registro privado</h2><p>Os registros privados podem exigir chaves para acessar as imagens deles.
As credenciais podem ser fornecidas de várias maneiras:</p><ul><li>Configurando nós para autenticação em um registro privado<ul><li>todos os pods podem ler qualquer registro privado configurado</li><li>requer configuração de nó pelo administrador do cluster</li></ul></li><li>Imagens pré-obtidas<ul><li>todos os pods podem usar qualquer imagem armazenada em cache em um nó</li><li>requer acesso root a todos os nós para configurar</li></ul></li><li>Especificando ImagePullSecrets em um Pod<ul><li>apenas pods que fornecem chaves próprias podem acessar o registro privado</li></ul></li><li>Extensões locais ou específicas do fornecedor<ul><li>se estiver usando uma configuração de nó personalizado, você (ou seu provedor de nuvem) pode implementar seu mecanismo para autenticar o nó ao registro do contêiner.</li></ul></li></ul><p>Essas opções são explicadas com mais detalhes abaixo.</p><h3 id=configurando-nós-para-autenticação-em-um-registro-privado>Configurando nós para autenticação em um registro privado</h3><p>Se você executar o Docker em seus nós, poderá configurar o contêiner runtime do Docker
para autenticação em um registro de contêiner privado.</p><p>Essa abordagem é adequada se você puder controlar a configuração do nó.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> O Kubernetes padrão é compatível apenas com as seções <code>auths</code> e<code> HttpHeaders</code> na configuração do Docker.
Auxiliares de credencial do Docker (<code>credHelpers</code> ou <code>credsStore</code>) não são suportados.</div><p>Docker armazena chaves de registros privados no arquivo <code>$HOME/.dockercfg</code> ou <code>$HOME/.docker/config.json</code>. Se você colocar o mesmo arquivo na lista de caminhos de pesquisa abaixo, o kubelet o usa como provedor de credenciais ao obter imagens.</p><ul><li><code>{--root-dir:-/var/lib/kubelet}/config.json</code></li><li><code>{cwd of kubelet}/config.json</code></li><li><code>${HOME}/.docker/config.json</code></li><li><code>/.docker/config.json</code></li><li><code>{--root-dir:-/var/lib/kubelet}/.dockercfg</code></li><li><code>{cwd of kubelet}/.dockercfg</code></li><li><code>${HOME}/.dockercfg</code></li><li><code>/.dockercfg</code></li></ul><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Você talvez tenha que definir <code>HOME=/root</code> explicitamente no ambiente do processo kubelet.</div><p>Aqui estão as etapas recomendadas para configurar seus nós para usar um registro privado. Neste
exemplo, execute-os em seu desktop/laptop:</p><ol><li>Execute <code>docker login [servidor]</code> para cada conjunto de credenciais que deseja usar. Isso atualiza o <code>$HOME/.docker/config.json</code> em seu PC.</li><li>Visualize <code>$HOME/.docker/config.json</code> em um editor para garantir que contém apenas as credenciais que você deseja usar.</li><li>Obtenha uma lista de seus nós; por exemplo:<ul><li>se você quiser os nomes: <code>nodes=$( kubectl get nodes -o jsonpath='{range.items[*].metadata}{.name} {end}' )</code></li><li>se você deseja obter os endereços IP: <code>nodes=$( kubectl get nodes -o jsonpath='{range .items[*].status.addresses[?(@.type=="ExternalIP")]}{.address} {end}' )</code></li></ul></li><li>Copie seu <code>.docker/config.json</code> local para uma das listas de caminhos de busca acima.<ul><li>por exemplo, para testar isso: <code>for n in $nodes; do scp ~/.docker/config.json root@"$n":/var/lib/kubelet/config.json; done</code></li></ul></li></ol><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Para clusters de produção, use uma ferramenta de gerenciamento de configuração para que você possa aplicar esta
configuração em todos os nós que você precisar.</div><p>Verifique se está funcionando criando um pod que usa uma imagem privada; por exemplo:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f - <span style=color:#b44>&lt;&lt;EOF
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: Pod
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: private-image-test-1
</span></span></span><span style=display:flex><span><span style=color:#b44>spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>  containers:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - name: uses-private-image
</span></span></span><span style=display:flex><span><span style=color:#b44>      image: $PRIVATE_IMAGE_NAME
</span></span></span><span style=display:flex><span><span style=color:#b44>      imagePullPolicy: Always
</span></span></span><span style=display:flex><span><span style=color:#b44>      command: [ &#34;echo&#34;, &#34;SUCCESS&#34; ]
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><pre tabindex=0><code>pod/private-image-test-1 created
</code></pre><p>Se tudo estiver funcionando, então, após algum tempo, você pode executar:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl logs private-image-test-1
</span></span></code></pre></div><p>e veja o resultado do comando:</p><pre tabindex=0><code>SUCCESS
</code></pre><p>Se você suspeitar que o comando falhou, você pode executar:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe pods/private-image-test-1 | grep <span style=color:#b44>&#39;Failed&#39;</span>
</span></span></code></pre></div><p>Em caso de falha, a saída é semelhante a:</p><pre tabindex=0><code>  Fri, 26 Jun 2015 15:36:13 -0700    Fri, 26 Jun 2015 15:39:13 -0700    19    {kubelet node-i2hq}    spec.containers{uses-private-image}    failed        Failed to pull image &#34;user/privaterepo:v1&#34;: Error: image user/privaterepo:v1 not found
</code></pre><p>Você deve garantir que todos os nós no cluster tenham o mesmo <code>.docker/config.json</code>. Caso contrário, os pods serão executados com sucesso em alguns nós e falharão em outros. Por exemplo, se você usar o escalonamento automático de nós, cada modelo de instância precisa incluir o <code>.docker/config.json</code> ou montar um drive que o contenha.</p><p>Todos os pods terão premissão de leitura às imagens em qualquer registro privado, uma vez que
as chaves privadas do registro são adicionadas ao <code>.docker/config.json</code>.</p><h3 id=imagens-pré-obtidas>Imagens pré-obtidas</h3><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Essa abordagem é adequada se você puder controlar a configuração do nó. Isto
não funcionará de forma confiável se o seu provedor de nuvem for responsável pelo gerenciamento de nós e os substituir
automaticamente.</div><p>Por padrão, o kubelet tenta realizar um "pull" para cada imagem do registro especificado.
No entanto, se a propriedade <code>imagePullPolicy</code> do contêiner for definida como<code> IfNotPresent</code> ou <code>Never</code>,
em seguida, uma imagem local é usada (preferencial ou exclusivamente, respectivamente).</p><p>Se você quiser usar imagens pré-obtidas como um substituto para a autenticação do registro,
você deve garantir que todos os nós no cluster tenham as mesmas imagens pré-obtidas.</p><p>Isso pode ser usado para pré-carregar certas imagens com o intuíto de aumentar a velocidade ou como uma alternativa para autenticação em um registro privado.</p><p>Todos os pods terão permissão de leitura a quaisquer imagens pré-obtidas.</p><h3 id=especificando-imagepullsecrets-em-um-pod>Especificando imagePullSecrets em um pod</h3><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Esta é a abordagem recomendada para executar contêineres com base em imagens
de registros privados.</div><p>O Kubernetes oferece suporte à especificação de chaves de registro de imagem de contêiner em um pod.</p><h4 id=criando-um-segredo-com-docker-config>Criando um segredo com Docker config</h4><p>Execute o seguinte comando, substituindo as palavras em maiúsculas com os valores apropriados:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret docker-registry &lt;name&gt; --docker-server<span style=color:#666>=</span>DOCKER_REGISTRY_SERVER --docker-username<span style=color:#666>=</span>DOCKER_USER --docker-password<span style=color:#666>=</span>DOCKER_PASSWORD --docker-email<span style=color:#666>=</span>DOCKER_EMAIL
</span></span></code></pre></div><p>Se você já tem um arquivo de credenciais do Docker, em vez de usar o
comando acima, você pode importar o arquivo de credenciais como um Kubernetes
<a class=glossary-tooltip title='Armazena dados sensíveis, como senhas, tokens OAuth e chaves SSH.' data-toggle=tooltip data-placement=top href=/pt-br/docs/concepts/configuration/secret/ target=_blank aria-label=Secrets>Secrets</a>.
<a href=/docs/tasks/configure-pod-container/pull-image-private-registry/#registry-secret-existing-credentials>Criar um segredo com base nas credenciais Docker existentes</a> explica como configurar isso.</p><p>Isso é particularmente útil se você estiver usando vários registros privados de contêineres, como <code>kubectl create secret docker-registry</code> cria um Segredo que
só funciona com um único registro privado.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Os pods só podem fazer referência a <em>pull secrets</em> de imagem em seu próprio namespace,
portanto, esse processo precisa ser feito uma vez por namespace.</div><h4 id=referenciando-um-imagepullsecrets-em-um-pod>Referenciando um imagePullSecrets em um pod</h4><p>Agora, você pode criar pods que fazem referência a esse segredo adicionando uma seção <code>imagePullSecrets</code>
na definição de Pod.</p><p>Por exemplo:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt; pod.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: Pod
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: foo
</span></span></span><span style=display:flex><span><span style=color:#b44>  namespace: awesomeapps
</span></span></span><span style=display:flex><span><span style=color:#b44>spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>  containers:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - name: foo
</span></span></span><span style=display:flex><span><span style=color:#b44>      image: janedoe/awesomeapp:v1
</span></span></span><span style=display:flex><span><span style=color:#b44>  imagePullSecrets:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - name: myregistrykey
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt;&gt; ./kustomization.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>resources:
</span></span></span><span style=display:flex><span><span style=color:#b44>- pod.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>Isso precisa ser feito para cada pod que está usando um registro privado.</p><p>No entanto, a configuração deste campo pode ser automatizada definindo o imagePullSecrets
em um recurso de <a href=/docs/tasks/configure-pod-container/configure-service-account/>ServiceAccount</a>.</p><p>Verifique <a href=/docs/tasks/configure-pod-container/configure-service-account/#add-imagepullsecrets-to-a-service-account>Adicionar ImagePullSecrets a uma conta de serviço</a> para obter instruções detalhadas.</p><p>Você pode usar isso em conjunto com um <code>.docker / config.json</code> por nó. As credenciais
serão mescladas.</p><h2 id=casos-de-uso>Casos de uso</h2><p>Existem várias soluções para configurar registros privados. Aqui estão alguns
casos de uso comuns e soluções sugeridas.</p><ol><li>Cluster executando apenas imagens não proprietárias (por exemplo, código aberto). Não há necessidade de ocultar imagens.<ul><li>Use imagens públicas no Docker hub.<ul><li>Nenhuma configuração necessária.</li><li>Alguns provedores de nuvem armazenam em cache ou espelham automaticamente imagens públicas, o que melhora a disponibilidade e reduz o tempo para extrair imagens.</li></ul></li></ul></li><li>Cluster executando algumas imagens proprietárias que devem ser ocultadas para quem está fora da empresa, mas
visível para todos os usuários do cluster.<ul><li>Use um <a href=https://docs.docker.com/registry/>registro Docker</a> privado hospedado.<ul><li>Pode ser hospedado no <a href=https://hub.docker.com/signup>Docker Hub</a> ou em outro lugar.</li><li>Configure manualmente .docker/config.json em cada nó conforme descrito acima.</li></ul></li><li>Ou execute um registro privado interno atrás de seu firewall com permissão de leitura.<ul><li>Nenhuma configuração do Kubernetes é necessária.</li></ul></li><li>Use um serviço de registro de imagem de contêiner que controla o acesso à imagem<ul><li>Funcionará melhor com o escalonamento automático do cluster do que com a configuração manual de nós.</li></ul></li><li>Ou, em um cluster onde alterar a configuração do nó é inconveniente, use <code>imagePullSecrets</code>.</li></ul></li><li>Cluster com imagens proprietárias, algumas das quais requerem controle de acesso mais rígido.<ul><li>Certifique-se de que o <a href=/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages>controlador de admissão AlwaysPullImages</a> está ativo. Caso contrário, todos os pods têm potencialmente acesso a todas as imagens.</li><li>Mova dados confidenciais para um recurso "secreto", em vez de empacotá-los em uma imagem.</li></ul></li><li>Um cluster multilocatário em que cada locatário precisa de seu próprio registro privado.<ul><li>Certifique-se de que o <a href=/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages>controlador de admissão AlwaysPullImages</a> está ativo. Caso contrário, todos os Pods de todos os locatários terão potencialmente acesso a todas as imagens.</li><li>Execute um registro privado com autorização necessária.</li><li>Gere credenciais de registro para cada locatário, coloque em segredo e preencha o segredo para cada namespace de locatário.</li><li>O locatário adiciona esse segredo a imagePullSecrets de cada namespace.</li></ul></li></ol><p>Se precisar de acesso a vários registros, você pode criar um segredo para cada registro.
O Kubelet mesclará qualquer <code>imagePullSecrets</code> em um único <code>.docker/config.json</code> virtual</p><h2 id=próximos-passos>Próximos passos</h2><ul><li>Leia a <a href=https://github.com/opencontainers/image-spec/blob/master/manifest.md>OCI Image Manifest Specification</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-643212488f778acf04bebed65ba34441>2 - Ambiente de Contêiner</h1><p>Essa página descreve os recursos disponíveis para contêineres no ambiente de contêiner.</p><h2 id=ambiente-de-contêiner>Ambiente de contêiner</h2><p>O ambiente de contêiner do Kubernetes fornece recursos importantes para contêineres:</p><ul><li>Um sistema de arquivos, que é a combinação de uma <a href=/docs/concepts/containers/images/>imagem</a> e um ou mais <a href=/docs/concepts/storage/volumes/>volumes</a>.</li><li>Informação sobre o contêiner propriamente.</li><li>Informação sobre outros objetos no cluster.</li></ul><h3 id=informação-de-contêiner>Informação de contêiner</h3><p>O <em>hostname</em> de um contêiner é o nome do Pod em que o contêiner está executando.
Isso é disponibilizado através do comando <code>hostname</code> ou da função <a href=https://man7.org/linux/man-pages/man2/gethostname.2.html><code>gethostname</code></a> chamada na libc.</p><p>O nome do Pod e o Namespace são expostos como variáveis de ambiente através de um mecanismo chamado <a href=/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information/>downward API</a>.</p><p>Variáveis de ambiente definidas pelo usuário a partir da definição do Pod também são disponíveis para o contêiner, assim como qualquer variável de ambiente especificada estáticamente na imagem Docker.</p><h3 id=informação-do-cluster>Informação do cluster</h3><p>Uma lista de todos os serviços que estão executando quando um contêiner foi criado é disponibilizada para o contêiner como variáveis de ambiente.
Essas variáveis de ambiente são compatíveis com a funcionalidade <em>docker link</em> do Docker.</p><p>Para um serviço nomeado <em>foo</em> que mapeia para um contêiner nomeado <em>bar</em>, as seguintes variáveis são definidas:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#b8860b>FOO_SERVICE_HOST</span><span style=color:#666>=</span>&lt;o host em que o serviço está executando&gt;
</span></span><span style=display:flex><span><span style=color:#b8860b>FOO_SERVICE_PORT</span><span style=color:#666>=</span>&lt;a porta em que o serviço está executando&gt;
</span></span></code></pre></div><p>Serviços possuem endereço IP dedicado e são disponibilizados para o contêiner via DNS,
se possuírem <a href=https://releases.k8s.io/v1.25.0/cluster/addons/dns/>DNS addon</a> habilitado.</p><h2 id=próximos-passos>Próximos passos</h2><ul><li>Aprenda mais sobre <a href=/docs/concepts/containers/container-lifecycle-hooks/>hooks de ciclo de vida do contêiner</a>.</li><li>Obtenha experiência prática
<a href=/docs/tasks/configure-pod-container/attach-handler-lifecycle-event/>anexando manipuladores a eventos de ciclo de vida do contêiner</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-a858027489648786a3b16264e451272b>3 - Classes de execução</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.20 [stable]</code></div><p>Essa página descreve o recurso <em>RuntimeClass</em> e a seleção do mecanismo do agente de execução.</p><p>RuntimeClass é uma funcionalidade para selecionar as configurações do agente de execução do contêiner.
A configuração do agente de execução de contêineres é usada para executar os contêineres de um Pod.</p><h2 id=motivação>Motivação</h2><p>Você pode configurar um <em>RuntimeClass</em> diferente entre os diferentes Pods para prover
um equilíbrio entre performance versus segurança. Por exemplo, se parte de sua carga de
trabalho necessita de um alto nível de garantia de segurança da informação, você pode
optar em executar esses Pods em um agente de execução que usa virtualização de hardware.
Você então terá o benefício do isolamento extra de um agente de execução alternativo, ao
custo de uma latência adicional.</p><p>Você pode ainda usar um <em>RuntimeClass</em> para executar diferentes Pods com o mesmo agente
de execução de contêineres mas com diferentes configurações.</p><h2 id=configuração>Configuração</h2><ol><li>Configure a implementação do CRI nos nós (depende do agente de execução)</li><li>Crie o recurso RuntimeClass correspondente.</li></ol><h3 id=1-configure-a-implementação-do-cri-nos-nós>1. Configure a implementação do CRI nos nós</h3><p>As configurações disponíveis através do RuntimeClass sáo dependentes da implementação do
<em>Container Runtime Interface</em> (<a class=glossary-tooltip title='Uma API para agentes de execução de contêineres se integrarem com o kubelet' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/components/#container-runtime target=_blank aria-label='Container runtime interface (CRI)'>Container runtime interface (CRI)</a>). Veja a documentação correspondente <a href=#configura%C3%A7%C3%A3o-do-cri>abaixo</a> para a
sua implementação CRI para verificar como configurar.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> RuntimeClass assume uma configuração homogênea de nós entre todo o cluster por padrão
(o que significa que todos os nós estão configurados do mesmo jeito referente aos agentes de
execução). Para suportar configurações heterogêneas, veja <a href=#associa%C3%A7%C3%A3o>Associação</a> abaixo.</div><p>As configurações possuem um nome <code>handler</code> correspondente, referenciado pelo RuntimeClass.
Esse nome deve ser um valor DNS 1123 válido (letras, números e o carácter <code>-</code>).</p><h3 id=2-crie-o-recurso-runtimeclass-correspondente>2. Crie o recurso RuntimeClass correspondente</h3><p>As etapas de configuração no passo 1 devem todas estar associadas a um nome para o campo <code>handler</code>
que identifica a configuração. Para cada um, crie o objeto RuntimeClass correspondente.</p><p>O recurso RuntimeClass atualmente possui apenas 2 campos significativos: o nome do RuntimeClass
(<code>metadata.name</code>) e o agente (<code>handler</code>). A definição do objeto se parece conforme a seguir:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>node.k8s.io/v1 <span style=color:#bbb> </span><span style=color:#080;font-style:italic># RuntimeClass é definido no grupo de API node.k8s.io</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>RuntimeClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myclass <span style=color:#bbb> </span><span style=color:#080;font-style:italic># O nome que o RuntimeClass será chamado como</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># RuntimeClass é um recurso global, e não possui namespace.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>handler</span>:<span style=color:#bbb> </span>myconfiguration <span style=color:#bbb> </span><span style=color:#080;font-style:italic># Nome da configuração CRI correspondente</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>O nome de um objeto RuntimeClass deve ser um
<a href=/pt-br/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>nome de subdomínio DNS</a> válido.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> É recomendado que operações de escrita no objeto RuntimeClass (criar/atualizar/patch/apagar)
sejam restritas a administradores do cluster. Isso geralmente é o padrão. Veja <a href=/docs/reference/access-authn-authz/authorization/>Visão Geral
de autorizações</a> para maiores detalhes.</div><h2 id=uso>Uso</h2><p>Uma vez que as classes de execução estão configuradas no cluster, usar elas é relativamente
simples. Especifique um <code>runtimeClassName</code> na especificação do Pod. Por exemplo:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>runtimeClassName</span>:<span style=color:#bbb> </span>myclass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Isso irá instruir o kubelet a usar o RuntimeClass nomeado acima (myclass) para esse Pod. Se
o nome do RuntimeClass não existir, ou o CRI não puder executar a solicitação, o Pod entrará na <a href=/docs/concepts/workloads/pods/pod-lifecycle/#pod-phase>fase
final</a> <code>Failed</code>. Procure por um
<a href=/docs/tasks/debug-application-cluster/debug-application-introspection/>evento</a> correspondente
para uma mensagem de erro.</p><p>Se nenhum <code>runtimeClassName</code> for especificado, o RuntimeHandler padrão será utilizado, que é equivalente
ao comportamento quando a funcionalidade de RuntimeClass está desativada.</p><h3 id=configuração-do-cri>Configuração do CRI</h3><p>Para maiores detalhes de configuração dos agentes de execução CRI, veja <a href=/docs/setup/production-environment/container-runtimes/>instalação do CRI</a>.</p><h4 id=dockershim>dockershim</h4><p>O CRI dockershim embutido no Kubernetes não suporta outros agentes de execução.</p><h4 id=hahahugoshortcode-s4-hbhb><a class=glossary-tooltip title='Um agente de execução de contêiner com enfase em simplicidade, robustez e portabilidade' data-toggle=tooltip data-placement=top href=https://containerd.io/docs/ target=_blank aria-label=containerd>containerd</a></h4><p>Agentes de execução são configurados através da configuração do containerd em
<code>/etc/containerd/config.toml</code>. Agentes válidos são configurados sob a seção de <code>runtimes</code>:</p><pre tabindex=0><code>[plugins.&#34;io.containerd.grpc.v1.cri&#34;.containerd.runtimes.${HANDLER_NAME}]
</code></pre><p>Veja a documentação de configuração do containerd para maiores detalhes:
<a href=https://github.com/containerd/containerd/blob/main/docs/cri/config.md>https://github.com/containerd/containerd/blob/main/docs/cri/config.md</a></p><h4 id=hahahugoshortcode-s5-hbhb><a class=glossary-tooltip title='Um agente de execução leve de contêineres criado especificamente para o Kubernetes' data-toggle=tooltip data-placement=top href=https://cri-o.io/#what-is-cri-o target=_blank aria-label=CRI-O>CRI-O</a></h4><p>Agentes de execução são configurados através da configuração do CRI-O em <code>/etc/crio/crio.conf</code>.
Agentes válidos são configurados na seção <a href=https://github.com/cri-o/cri-o/blob/master/docs/crio.conf.5.md#crioruntime-table>crio.runtime
table</a>:</p><pre tabindex=0><code>[crio.runtime.runtimes.${HANDLER_NAME}]
  runtime_path = &#34;${PATH_TO_BINARY}&#34;
</code></pre><p>Veja a <a href=https://raw.githubusercontent.com/cri-o/cri-o/9f11d1d/docs/crio.conf.5.md>documentação de configuração</a> do CRI-O para maiores detalhes.</p><h2 id=associação>Associação</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.16 [beta]</code></div><p>Ao especificar o campo <code>scheduling</code> para um RuntimeClass, você pode colocar limites e
garantir que os Pods executando dentro de uma RuntimeClass sejam associados a nós que
suportem eles. Se o <code>scheduling</code> não estiver configurado, assume-se que esse RuntimeClass
é suportado por todos os nós.</p><p>Para garantir que os Pods sejam executados em um nó que suporte um RuntimeClass específico,
aquele conjunto de nós deve possuir uma marca/label padrão que é selecionado pelo campo
<code>runtimeclass.scheduling.nodeSelector</code>. O nodeSelector do RuntimeClass é combinado com o
nodeSelector do Pod em tempo de admissão, obtendo a intersecção do conjunto de nós selecionado
por cada. Se existir um conflito, o pod será rejeitado.</p><p>Se os nós suportados possuírem marcação de restrição para prevenir outros Pods com uma
classe de execução diferente de executar no nó, você pode adicionar o campo <code>tolerations</code>
ao objeto RuntimeClass. Assim como com o <code>nodeSelector</code>, o <code>tolerations</code> é combinado com
o campo <code>tolerations</code> do Pod em tempo de admissão, efetivamente pegando a intersecção do
conjunto de nós aplicáveis para cada.</p><p>Para saber mais sobre a configuração de seleção de nós e tolerâncias, veja <a href=/docs/concepts/scheduling-eviction/assign-pod-node/>Associando Pods a
Nós</a>.</p><h3 id=sobrecarga-de-pods>Sobrecarga de Pods</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.18 [beta]</code></div><p>Você pode especificar os recursos extra que estão associados à execução de um Pod. Declarar esses
recursos extra permite ao cluster (incluindo o agendador/scheduler de pods) contabilizar por
esses recursos quando estiver decidindo sobre Pods e recursos. Para usar a contabilização
desses recursos extras, você deve estar com o <a href=/docs/reference/command-line-tools-reference/feature-gates/>feature gate</a>
PodOverhead habilitado (ele já está habilitado por padrão).</p><p>Os recursos extras utilizados são especificados no objeto RuntimeClass através do campo <code>overhead</code>.
Ao usar esses campos, você especifica o uso extra de recursos necessários para executar
Pods utilizando-se desse Runtimeclass e assim contabilizar esses recursos para o Kubernetes.</p><h2 id=próximos-passos>Próximos passos</h2><ul><li><a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/585-runtime-class/README.md>RuntimeClass Design</a></li><li><a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/585-runtime-class/README.md#runtimeclass-scheduling>RuntimeClass Scheduling Design</a></li><li>Leia mais sobre <a href=/docs/concepts/scheduling-eviction/pod-overhead/>Sobrecarga de Pods</a></li><li><a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-node/688-pod-overhead>PodOverhead Feature Design</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-e6941d969d81540208a3e78bc56f43bc>4 - Hooks de Ciclo de Vida do Contêiner</h1><p>Essa página descreve como os contêineres gerenciados pelo <em>kubelet</em> podem usar a estrutura de <em>hook</em> de ciclo de vida do contêiner para executar código acionado por eventos durante seu ciclo de vida de gerenciamento.</p><h2 id=visão-geral>Visão Geral</h2><p>Análogo a muitas estruturas de linguagem de programação que tem <em>hooks</em> de ciclo de vida de componentes, como angular,
o Kubernetes fornece aos contêineres <em>hooks</em> de ciclo de vida.
Os <em>hooks</em> permitem que os contêineres estejam cientes dos eventos em seu ciclo de vida de gerenciamento
e executem código implementado em um manipulador quando o <em>hook</em> de ciclo de vida correspondente é executado.</p><h2 id=hooks-do-contêiner>Hooks do contêiner</h2><p>Existem dois <em>hooks</em> que são expostos para os contêiners:</p><p><code>PostStart</code></p><p>Este <em>hook</em> é executado imediatamente após um contêiner ser criado.
Entretanto, não há garantia que o <em>hook</em> será executado antes do ENTRYPOINT do contêiner.
Nenhum parâmetro é passado para o manipulador.</p><p><code>PreStop</code></p><p>Esse <em>hook</em> é chamado imediatamente antes de um contêiner ser encerrado devido a uma solicitação de API ou um gerenciamento de evento como liveness/startup probe failure, preemption, resource contention e outros.
Uma chamada ao <em>hook</em> <code>PreStop</code> falha se o contêiner já está em um estado finalizado ou concluído e o <em>hook</em> deve ser concluído antes que o sinal TERM seja enviado para parar o contêiner. A contagem regressiva do período de tolerância de término do Pod começa antes que o <em>hook</em> <code>PreStop</code> seja executado, portanto, independentemente do resultado do manipulador, o contêiner será encerrado dentro do período de tolerância de encerramento do Pod. Nenhum parâmetro é passado para o manipulador.</p><p>Uma descrição mais detalhada do comportamento de término pode ser encontrada em <a href=/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination>Término de Pods</a>.</p><h3 id=implementações-de-manipulador-de-hook>Implementações de manipulador de hook</h3><p>Os contêineres podem acessar um <em>hook</em> implementando e registrando um manipulador para esse <em>hook</em>.
Existem dois tipos de manipuladores de <em>hooks</em> que podem ser implementados para contêineres:</p><ul><li>Exec - Executa um comando específico, como <code>pre-stop.sh</code>, dentro dos cgroups e Namespaces do contêiner.</li><li>HTTP - Executa uma requisição HTTP em um endpoint específico do contêiner.</li></ul><h3 id=execução-do-manipulador-de-hook>Execução do manipulador de hook</h3><p>Quando um <em>hook</em> de gerenciamento de ciclo de vida do contêiner é chamado, o sistema de gerenciamento do Kubernetes executa o manipulador de acordo com a ação do <em>hook</em>, <code>httpGet</code> e <code>tcpSocket</code> são executados pelo processo kubelet e <code>exec</code> é executado pelo contêiner.</p><p>As chamadas do manipulador do <em>hook</em> são síncronas no contexto do Pod que contém o contêiner.
Isso significa que para um <em>hook</em> <code>PostStart</code>, o ENTRYPOINT do contêiner e o <em>hook</em> disparam de forma assíncrona.
No entanto, se o <em>hook</em> demorar muito para ser executado ou travar, o contêiner não consegue atingir o estado <code>running</code>.</p><p>Os <em>hooks</em> <code>PreStop</code> não são executados de forma assíncrona a partir do sinal para parar o contêiner, o <em>hook</em> precisa finalizar a sua execução antes que o sinal TERM possa ser enviado.
Se um <em>hook</em> <code>PreStop</code> travar durante a execução, a fase do Pod será <code>Terminating</code> e permanecerá até que o Pod seja morto após seu <code>terminationGracePeriodSeconds</code> expirar. Esse período de tolerância se aplica ao tempo total necessário
para o <em>hook</em> <code>PreStop</code>executar e para o contêiner parar normalmente.
Se por exemplo, o <code>terminationGracePeriodSeconds</code> é 60, e o <em>hook</em> leva 55 segundos para ser concluído, e o contêiner leva 10 segundos para parar normalmente após receber o sinal, então o contêiner será morto antes que possa parar
normalmente, uma vez que o <code>terminationGracePeriodSeconds</code> é menor que o tempo total (55 + 10) que é necessário para que essas duas coisas aconteçam.</p><p>Se um <em>hook</em> <code>PostStart</code> ou <code>PreStop</code> falhar, ele mata o contêiner.</p><p>Os usuários devem tornar seus <em>hooks</em> o mais leve possíveis.
Há casos, no entanto, em que comandos de longa duração fazem sentido, como ao salvar o estado
antes de parar um contêiner.</p><h3 id=garantias-de-entrega-de-hooks>Garantias de entrega de <em>hooks</em></h3><p>A entrega do <em>hook</em> é destinada a acontecer <em>pelo menos uma vez</em>,
o que quer dizer que um <em>hook</em> pode ser chamado várias vezes para qualquer evento,
como para <code>PostStart</code> ou <code>PreStop</code>.
Depende da implementação do <em>hook</em> lidar com isso corretamente.</p><p>Geralmente, apenas entregas únicas são feitas.
Se, por exemplo, um receptor de <em>hook</em> HTTP estiver inativo e não puder receber tráfego,
não há tentativa de reenviar.
Em alguns casos raros, no entanto, pode ocorrer uma entrega dupla.
Por exemplo, se um kubelet reiniciar no meio do envio de um <em>hook</em>, o <em>hook</em> pode ser
reenviado depois que o kubelet voltar a funcionar.</p><h3 id=depurando-manipuladores-de-hooks>Depurando manipuladores de <em>hooks</em></h3><p>Os logs para um manipulador de <em>hook</em> não são expostos em eventos de Pod.
Se um manipulador falhar por algum motivo, ele transmitirá um evento.
Para <code>PostStart</code> é o evento <code>FailedPostStartHook</code> e para <code>PreStop</code> é o evento
<code>FailedPreStopHook</code>.
Você pode ver esses eventos executando <code>kubectl describe pod &lt;nome_do_pod></code>.
Aqui está um exemplo de saída de eventos da execução deste comando:</p><pre tabindex=0><code>Events:
  FirstSeen  LastSeen  Count  From                                                   SubObjectPath          Type      Reason               Message
  ---------  --------  -----  ----                                                   -------------          --------  ------               -------
  1m         1m        1      {default-scheduler }                                                          Normal    Scheduled            Successfully assigned test-1730497541-cq1d2 to gke-test-cluster-default-pool-a07e5d30-siqd
  1m         1m        1      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}  spec.containers{main}  Normal    Pulling              pulling image &#34;test:1.0&#34;
  1m         1m        1      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}  spec.containers{main}  Normal    Created              Created container with docker id 5c6a256a2567; Security:[seccomp=unconfined]
  1m         1m        1      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}  spec.containers{main}  Normal    Pulled               Successfully pulled image &#34;test:1.0&#34;
  1m         1m        1      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}  spec.containers{main}  Normal    Started              Started container with docker id 5c6a256a2567
  38s        38s       1      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}  spec.containers{main}  Normal    Killing              Killing container with docker id 5c6a256a2567: PostStart handler: Error executing in Docker Container: 1
  37s        37s       1      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}  spec.containers{main}  Normal    Killing              Killing container with docker id 8df9fdfd7054: PostStart handler: Error executing in Docker Container: 1
  38s        37s       2      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}                         Warning   FailedSync           Error syncing pod, skipping: failed to &#34;StartContainer&#34; for &#34;main&#34; with RunContainerError: &#34;PostStart handler: Error executing in Docker Container: 1&#34;
  1m         22s       2      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}  spec.containers{main}  Warning   FailedPostStartHook
</code></pre><h2 id=próximos-passos>Próximos passos</h2><ul><li>Saiba mais sobre o <a href=/docs/concepts/containers/container-environment/>Ambiente de contêiner</a>.</li><li>Obtenha experiência prática
<a href=/docs/tasks/configure-pod-container/attach-handler-lifecycle-event/>anexando manipuladores a eventos de ciclo de vida do contêiner</a>.</li></ul></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/pt-br/docs/home/>Home</a>
<a class=text-white href=/pt-br/blog/>Blog</a>
<a class=text-white href=/pt-br/partners/>Parceiros</a>
<a class=text-white href=/pt-br/community/>Comunidade</a>
<a class=text-white href=/pt-br/case-studies/>Casos de estudo</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 Os autores do Kubernetes | Documentação Distribuída sob <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small><br><small class=text-white>Copyright &copy; 2023 A Fundação Linux &reg;. Todos os direitos reservados. A Linux Foundation tem marcas registradas e usa marcas registradas. Para uma lista de marcas registradas da The Linux Foundation, por favor, veja nossa <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>Página de uso de marca registrada</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>