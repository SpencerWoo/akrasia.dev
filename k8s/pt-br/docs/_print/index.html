<!doctype html><html lang=pt-br class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=en href=https://kubernetes.io/docs/><link rel=alternate hreflang=zh-cn href=https://kubernetes.io/zh-cn/docs/><link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/><link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/><link rel=alternate hreflang=it href=https://kubernetes.io/it/docs/><link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/><link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/><link rel=alternate hreflang=hi href=https://kubernetes.io/hi/docs/><link rel=alternate hreflang=vi href=https://kubernetes.io/vi/docs/><link rel=alternate hreflang=ru href=https://kubernetes.io/ru/docs/><link rel=alternate hreflang=pl href=https://kubernetes.io/pl/docs/><link rel=alternate hreflang=uk href=https://kubernetes.io/uk/docs/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/pt-br/docs/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>Documentação | Kubernetes</title><meta property="og:title" content="Documentação"><meta property="og:description" content="Orquestração de contêineres em nível de produção"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/pt-br/docs/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="Documentação"><meta itemprop=description content="Orquestração de contêineres em nível de produção"><meta name=twitter:card content="summary"><meta name=twitter:title content="Documentação"><meta name=twitter:description content="Orquestração de contêineres em nível de produção"><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content="Bem-vindo à documentação do Kubernetes em Português
Como você pode ver, a maior parte da documentação ainda está disponível apenas em inglês, mas não se preocupe, há uma equipe trabalhando na tradução para o português.
Se você quiser participar, você pode entrar no canal Slack #kubernetes-docs-pt e fazer parte da equipe por trás da tradução.
Você também pode acessar o canal para solicitar a tradução de uma página específica ou relatar qualquer erro que possa ter sido encontrado."><meta property="og:description" content="Bem-vindo à documentação do Kubernetes em Português
Como você pode ver, a maior parte da documentação ainda está disponível apenas em inglês, mas não se preocupe, há uma equipe trabalhando na tradução para o português.
Se você quiser participar, você pode entrar no canal Slack #kubernetes-docs-pt e fazer parte da equipe por trás da tradução.
Você também pode acessar o canal para solicitar a tradução de uma página específica ou relatar qualquer erro que possa ter sido encontrado."><meta name=twitter:description content="Bem-vindo à documentação do Kubernetes em Português
Como você pode ver, a maior parte da documentação ainda está disponível apenas em inglês, mas não se preocupe, há uma equipe trabalhando na tradução para o português.
Se você quiser participar, você pode entrar no canal Slack #kubernetes-docs-pt e fazer parte da equipe por trás da tradução.
Você também pode acessar o canal para solicitar a tradução de uma página específica ou relatar qualquer erro que possa ter sido encontrado."><meta property="og:url" content="https://kubernetes.io/pt-br/docs/"><meta property="og:title" content="Documentação"><meta name=twitter:title content="Documentação"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/pt-br/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/pt-br/docs/>Documentação</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/pt-br/blog/>Kubernetes Blog</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/pt-br/partners/>Parceiros</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/pt-br/community/>Comunidade</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/pt-br/case-studies/>Casos de estudo</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Versões</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/pt-br/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/pt-br/docs/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/pt-br/docs/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/pt-br/docs/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/pt-br/docs/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/pt-br/docs/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Português (Portuguese)</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/docs/>English</a>
<a class=dropdown-item href=/zh-cn/docs/>中文 (Chinese)</a>
<a class=dropdown-item href=/ko/docs/>한국어 (Korean)</a>
<a class=dropdown-item href=/ja/docs/>日本語 (Japanese)</a>
<a class=dropdown-item href=/fr/docs/>Français (French)</a>
<a class=dropdown-item href=/it/docs/>Italiano (Italian)</a>
<a class=dropdown-item href=/de/docs/>Deutsch (German)</a>
<a class=dropdown-item href=/es/docs/>Español (Spanish)</a>
<a class=dropdown-item href=/id/docs/>Bahasa Indonesia</a>
<a class=dropdown-item href=/hi/docs/>हिन्दी (Hindi)</a>
<a class=dropdown-item href=/vi/docs/>Tiếng Việt (Vietnamese)</a>
<a class=dropdown-item href=/ru/docs/>Русский (Russian)</a>
<a class=dropdown-item href=/pl/docs/>Polski (Polish)</a>
<a class=dropdown-item href=/uk/docs/>Українська (Ukrainian)</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>Essa é a versão completa de impressão dessa seção
<a href=# onclick="return print(),!1">Clique aqui para imprimir</a>.</p><p><a href=/pt-br/docs/>Retornar à visualização normal</a>.</p></div><h1 class=title>Documentação</h1><ul><li>1: <a href=#pg-e735cee7e913aa88bc0aa10594d12966>Kubernetes</a></li><ul><li>1.1: <a href=#pg-92dfff0ca612d0bff40171aa9df6c4ae>Versões Suportadas da Documentação do Kubernetes</a></li></ul><li>2: <a href=#pg-66b565805ca1061be35ff2c0165f13c1>Instalação</a></li><ul><li>2.1: <a href=#pg-29e59491dd6118b23072dfe9ebb93323>Instalando a ferramenta kubeadm</a></li><li>2.2: <a href=#pg-478acca1934b6d89a0bc00fb25bfe5b6>Instalando Kubernetes com kOps</a></li><li>2.3: <a href=#pg-d2f55eefe7222b7c637875af9c3ec199>Soluções de Nuvem Prontas para uso</a></li></ul><li>3: <a href=#pg-dd948255948d6b59b32c471abcb62997>Conceitos</a></li><ul><li>3.1: <a href=#pg-0554ac387412eaf4e6e89b2f847dacde>Visão Geral</a></li><ul><li>3.1.1: <a href=#pg-45bdca6129cf540121623e903c18ba46>O que é Kubernetes?</a></li><li>3.1.2: <a href=#pg-13b0f1dbe89228e3d76d2ac231e245f1>Componentes do Kubernetes</a></li><li>3.1.3: <a href=#pg-110f33530cf761140cb1dab536baef04>Objetos do Kubernetes</a></li><ul><li>3.1.3.1: <a href=#pg-9f5adfa77f48c50d5cc81155a3cecb98>Entendendo os objetos do Kubernetes</a></li><li>3.1.3.2: <a href=#pg-f37749a83c2916b63279ea60f3cfe53e>Nomes de objetos e IDs</a></li><li>3.1.3.3: <a href=#pg-1127165f472b7181b9c1d5a0b187d620>Namespaces</a></li><li>3.1.3.4: <a href=#pg-046c03090d47bc4b89b818dc645c3865>Seletores de Campos</a></li></ul></ul><li>3.2: <a href=#pg-2bf36ccd6b3dbeafecf87c39761b07c7>Arquitetura do Kubernetes</a></li><ul><li>3.2.1: <a href=#pg-9ef2890698e773b6c0d24fd2c20146f5>Nós</a></li><li>3.2.2: <a href=#pg-c0251def6da29b30afebfb04549f1703>Comunicação entre Nó e Control Plane</a></li><li>3.2.3: <a href=#pg-bc804b02614d67025b4c788f1ca87fbc>Conceitos sobre Cloud Controller Manager</a></li><li>3.2.4: <a href=#pg-ca8819042a505291540e831283da66df>Controladores</a></li></ul><li>3.3: <a href=#pg-a5f7383c83ab9eb9cd0e3c4c020b3ae6>Contêineres</a></li><ul><li>3.3.1: <a href=#pg-16042b4652ad19e565c7263824029a43>Imagens</a></li><li>3.3.2: <a href=#pg-643212488f778acf04bebed65ba34441>Ambiente de Contêiner</a></li><li>3.3.3: <a href=#pg-a858027489648786a3b16264e451272b>Classes de execução</a></li><li>3.3.4: <a href=#pg-e6941d969d81540208a3e78bc56f43bc>Hooks de Ciclo de Vida do Contêiner</a></li></ul><li>3.4: <a href=#pg-0a0a7eca3e302a3c08f8c85e15d337fd>Serviços, balanceamento de carga e conectividade</a></li><ul><li>3.4.1: <a href=#pg-ded1daafdcd293023ee333728007ca61>Políticas de rede</a></li></ul><li>3.5: <a href=#pg-f018f568c6723865753f150c3c59bdda>Armazenamento</a></li><ul><li>3.5.1: <a href=#pg-27795584640a03bd2024f1fe3b3ab754>Volumes</a></li><li>3.5.2: <a href=#pg-ffd12528a12882b282e1bd19e29f9e75>Volumes Persistentes</a></li></ul><li>3.6: <a href=#pg-275bea454e1cf4c5adeca4058b5af988>Configuração</a></li><ul><li>3.6.1: <a href=#pg-ddef6fd0e47bb51c6f05e8e7fb11d2dd>Melhores Práticas de Configuração</a></li><li>3.6.2: <a href=#pg-6b5ccadd699df0904e8e9917c5450c4b>ConfigMaps</a></li><li>3.6.3: <a href=#pg-e511ed821ada65d0053341dbd8ad2bb5>Secrets</a></li><li>3.6.4: <a href=#pg-436057b96151ecb8a4a9a9f456b5d0fc>Gerenciamento de recursos em Pods e contêineres</a></li><li>3.6.5: <a href=#pg-ab6d20f33ad930a67ee7ef57bff6c75e>Organizando o acesso ao cluster usando arquivos kubeconfig</a></li></ul><li>3.7: <a href=#pg-712cb3c03ff14a39e5a83a6d9b71d203>Segurança</a></li><ul><li>3.7.1: <a href=#pg-04eeb110d75afc8acb2cf7a3db743985>Visão Geral da Segurança Cloud Native</a></li><li>3.7.2: <a href=#pg-4d77d1ae4c06aa14f54b385191627881>Controlando Acesso à API do Kubernetes</a></li></ul><li>3.8: <a href=#pg-c21d05f31057c5bcd2ebdd01f4e62a0e>Escalonamento</a></li><ul><li>3.8.1: <a href=#pg-ede4960b56a3529ee0bfe7c8fe2d09a5>Taints e Tolerâncias</a></li><li>3.8.2: <a href=#pg-598f36d691ab197f9d995784574b0a12>Escalonador do Kubernetes</a></li><li>3.8.3: <a href=#pg-da22fe2278df236f71efbe672f392677>Sobrecarga de Pod</a></li></ul><li>3.9: <a href=#pg-ac9161c6d952925b083ad9602b4e8e7f>Políticas</a></li><ul><li>3.9.1: <a href=#pg-a935ff8c59eb116b43494255cc67f69a>Intervalos de limite</a></li><li>3.9.2: <a href=#pg-94ddc6e901c30f256138db11d09f05a3>Cotas de Recursos</a></li></ul><li>3.10: <a href=#pg-285a3785fd3d20f437c28d87ca4dadca>Administração de Cluster</a></li><ul><li>3.10.1: <a href=#pg-fb494ea3b1874bd753dcd11c3f35c2dc>Visão Geral da Administração de Cluster</a></li><li>3.10.2: <a href=#pg-2bf9a93ab5ba014fb6ff70b22c29d432>Certificates</a></li><li>3.10.3: <a href=#pg-d649067a69d8d5c7e71564b42b96909e>Conectividade do Cluster</a></li><li>3.10.4: <a href=#pg-c4b1e87a84441f8a90699a345ce48d68>Arquitetura de Log</a></li><li>3.10.5: <a href=#pg-5cc31ecfba86467f8884856412cfb6b2>Logs de Sistema</a></li><li>3.10.6: <a href=#pg-cbfd3654996eae9fcdef009f70fa83f0>Métricas para componentes do sistema Kubernetes</a></li><li>3.10.7: <a href=#pg-2e05a56491965ae320c2662590b2ca18>Configurando o Garbage Collection do kubelet</a></li><li>3.10.8: <a href=#pg-08e94e6a480e0d6b2de72d84a1b97617>Proxies no Kubernetes</a></li><li>3.10.9: <a href=#pg-85d633ae590aa20ec024f1b7af1d74fc>Instalando Complementos</a></li><li>3.10.10: <a href=#pg-31c9327d2332c585341b64ddafa19cdd>Prioridade e imparcialidade da API</a></li></ul><li>3.11: <a href=#pg-7e0d97616b15e2c383c6a0a96ec442cb>Extendendo o Kubernetes</a></li><ul><li>3.11.1: <a href=#pg-0af41d3bd7c785621b58b7564793396a>Extendendo a API do Kubernetes</a></li><ul><li>3.11.1.1: <a href=#pg-1ea4977c0ebf97569bf54a477faa7fa5>Extendendo a API do Kubernetes com a camada de agregação</a></li></ul><li>3.11.2: <a href=#pg-c8937cdc9df96f3328becf04f8211292>Extensões de Computação, armazenamento e redes</a></li><ul><li>3.11.2.1: <a href=#pg-1ac2260db9ecccbf0303a899bc27ce6d>Plugins de rede</a></li></ul><li>3.11.3: <a href=#pg-3131452556176159fb269593c1a52012>Padrão Operador</a></li></ul></ul><li>4: <a href=#pg-f8918f697450c2009b75913f9e9317a5>Tarefas</a></li><ul><li>4.1: <a href=#pg-94f49ece137035764368f22a98942872>Gerenciando Secrets</a></li><ul><li>4.1.1: <a href=#pg-0ed63ce3c9665aed7ff5a560ff1da843>Gerenciando Secret usando kubectl</a></li><li>4.1.2: <a href=#pg-e841cf91fd3566db1e86143ed7a9e13c>Gerenciando Secret usando Arquivo de Configuração</a></li><li>4.1.3: <a href=#pg-a0ff2e3ba8af5670d5dc3d94c4bd0a68>Gerenciando Secret usando Kustomize</a></li></ul><li>4.2: <a href=#pg-904cea8c8efd5c0d33adbfe579ec2dd2>Configurando Qualidade do Serviço Para Pods</a></li><li>4.3: <a href=#pg-bbc17480da6d051c696489654c64064a>Atribuindo Pods aos Nós</a></li></ul><li>5: <a href=#pg-68ec2370d0409cc27325be36693f9368>Tutoriais</a></li><ul><li>5.1: <a href=#pg-5e3051fff9e84735871d9fb5e7b93f33>Olá, Minikube!</a></li><li>5.2: <a href=#pg-3c83f53a74233ace9b289ac5e24c3e62>Aprenda as noções básicas do Kubernetes</a></li><ul><li>5.2.1: <a href=#pg-7df66040311338d6098ebeab43ba9afb>Crie um Cluster</a></li><ul><li>5.2.1.1: <a href=#pg-de49316920e97a82e36763cb66781ada>Usando Minikube para criar um cluster</a></li><li>5.2.1.2: <a href=#pg-323b75976001e8dfe35d67d61bc74f1a>Tutorial interativo - Criando um cluster</a></li></ul><li>5.2.2: <a href=#pg-76d78b3fba507f7ed33cef14a35b631d>Implantar um aplicativo</a></li><ul><li>5.2.2.1: <a href=#pg-2b1bba431989008c7493109a0f049ece>Usando kubectl para criar uma implantação</a></li><li>5.2.2.2: <a href=#pg-f8997ec143b382fa6c9621941ea62ca3>Tutorial interativo - implantando um aplicativo</a></li></ul><li>5.2.3: <a href=#pg-250d620a73ec8be7e1f7d835574c4596>Explore seu aplicativo</a></li><ul><li>5.2.3.1: <a href=#pg-2771f4e8c45321b17cb0114a2d266453>Visualizando Pods e Nós (Nodes)</a></li><li>5.2.3.2: <a href=#pg-4b01eab98a9844ad91131079654199dd>Tutorial Interativo - Explorando seu aplicativo</a></li></ul><li>5.2.4: <a href=#pg-4b0e31c9e0eae68bbb0a358b4042ada9>Exponha publicamente seu aplicativo</a></li><ul><li>5.2.4.1: <a href=#pg-8ef4dad8f743b191a9e8c6f891cb191a>Utilizando um serviço para expor seu aplicativo</a></li><li>5.2.4.2: <a href=#pg-352241d22effe0714772d21c7d1b512d>Tutorial Interativo - Expondo seu aplicativo</a></li></ul><li>5.2.5: <a href=#pg-be4996c93fb39c459a30b6669569d423>Escale seu aplicativo</a></li><ul><li>5.2.5.1: <a href=#pg-d1c15c9bd4f625adbc13149b1475287c>Executando múltiplas instâncias de seu aplicativo</a></li><li>5.2.5.2: <a href=#pg-7bdb3fbaa1177ff5dfa3fe86bd35ef59>Tutorial Interativo - Escalando seu aplicativo</a></li></ul></ul></ul><li>6: <a href=#pg-b00a88a07ceb21b1a83e5822e0c86c1d>Referência</a></li><ul><li>6.1: <a href=#pg-2b03679960950df772fb4fe7d78427b9>Glossário</a></li><li>6.2: <a href=#pg-a6264859a5ad6e2f4a6e4cff9ce4fa8b>Autenticação</a></li><li>6.3: <a href=#pg-de45b6ca7419a0e308044425b2ac52bb>Autenticando com Tokens de Inicialização</a></li><li>6.4: <a href=#pg-82b2fcf985bae77dcb754387a9fcc64f>kubeadm init</a></li><li>6.5: <a href=#pg-5042dc49c5348b3674d3878f37f7670b>kubeadm config</a></li><li>6.6: <a href=#pg-df8ff2190764e70c3de2015e2cb46b14>Portas e protocolos</a></li><li>6.7: <a href=#pg-6eb5bc1e7114609930a76c683cc27c2b>kubeadm reset</a></li><li>6.8: <a href=#pg-03460a7254c6c73eb2a1bb3dd7d25910>kubectl CLI</a></li><ul><li>6.8.1: <a href=#pg-8aba901ac13f124e5782b90ddb166ee2>kubectl Cheat Sheet</a></li></ul><li>6.9: <a href=#pg-342be69d36f174f762c36f4fe11fcb20>Visão Geral de Autorização</a></li><li>6.10: <a href=#pg-516f4705fb2f5f62c76c7742772726a3>kubeadm token</a></li><li>6.11: <a href=#pg-af7c1f9168ec67f957edc504f43faf9a>Problemas e Alertas de Segurança do Kubernetes</a></li><ul></ul><li>6.12: <a href=#pg-34c4af6f36d969ed08ba840e7fb64c6d>kubeadm version</a></li><li>6.13: <a href=#pg-92a39c69c3689119dd5fa12886cb73a3>kubeadm alpha</a></li><li>6.14: <a href=#pg-6a1fed09235bbf3644c804339928f10e>kubeadm certs</a></li><li>6.15: <a href=#pg-1ab2d643d770ca684548de4ddbc7d8c4>kubeadm kubeconfig</a></li><li>6.16: <a href=#pg-dfd085b5ab706bd84dda15847dd27f1b>kubeadm upgrade phase</a></li><li>6.17: <a href=#pg-8df9aba508b2736a6712ef46227eea7d></a></li><li>6.18: <a href=#pg-018648dfc6f28bc9b969f45af0563cae></a></li><li>6.19: <a href=#pg-4a1ff27cdf01c1c47d034278048e776b></a></li><li>6.20: <a href=#pg-5d6b2999153cd86f56329534249fc4ec></a></li><li>6.21: <a href=#pg-adb5eecdc351074cc2e0cc2b1b4f04a8></a></li><li>6.22: <a href=#pg-df4c2dc6cba0be90d8d7de2fca9b87f7></a></li><li>6.23: <a href=#pg-6d6746e8ac1f1602f7dab1056b27e5c2></a></li><li>6.24: <a href=#pg-7449c7fa06f25b967cf531e937b0f4b2></a></li><li>6.25: <a href=#pg-b5c6ae77d3be9bd358c68667006cfc18></a></li><li>6.26: <a href=#pg-4f804e59ec1739e733807d2b591d771f></a></li><li>6.27: <a href=#pg-f5cf8caa95834803b133d53c321ab4a9></a></li><li>6.28: <a href=#pg-ee770858e2bb767b79d572b4882af656></a></li><li>6.29: <a href=#pg-7484bf11b6183f4c329b1f66734cc886></a></li><li>6.30: <a href=#pg-bf444d915ab856dba693c36294c5427b></a></li><li>6.31: <a href=#pg-f5c087e087714c5290b4967dd7924b3b></a></li><li>6.32: <a href=#pg-20703ce1c236264ad78cb1ad7244723e></a></li><li>6.33: <a href=#pg-8f73e208cc67d221165f6294393881a7></a></li><li>6.34: <a href=#pg-9aec3477159c105a46f4479de1c21418></a></li><li>6.35: <a href=#pg-045e41c28798930e21f77a90c3a90263></a></li><li>6.36: <a href=#pg-e7d83478123771ad14f475ee44440303></a></li><li>6.37: <a href=#pg-57a6b20d9571220989a7a445d4459468></a></li><li>6.38: <a href=#pg-92a2c11eef37937af846b55d9b87a544></a></li><li>6.39: <a href=#pg-dcfffcaafb438cd650475945ddc129ee></a></li><li>6.40: <a href=#pg-257824537b4c6c6b33249aa786461156></a></li><li>6.41: <a href=#pg-e10faf6f940de61052258af59e036518></a></li><li>6.42: <a href=#pg-a46a193f2322aa88cb3b2de2447b0461></a></li><li>6.43: <a href=#pg-bdd9680ec894593d17f782d5e5665fd4></a></li><li>6.44: <a href=#pg-1d005baad1a1e217d7ae0210fec96c3f></a></li><li>6.45: <a href=#pg-c79d11d27bed54caac743c93e0b2fb24></a></li><li>6.46: <a href=#pg-ba78e64c325e4131dd741235e2a1b2c0></a></li><li>6.47: <a href=#pg-19a94d2f7649959b218952cef00729f4></a></li><li>6.48: <a href=#pg-b22d3ed181fb7f926ae2081f8fc8c14d></a></li><li>6.49: <a href=#pg-ae1ea74c2c21b25a3c1eacdaf549274b></a></li><li>6.50: <a href=#pg-633020ef232bc34f60c82153578a6c9b></a></li><li>6.51: <a href=#pg-aa9f718186487df2ab6885cae45f5d37></a></li><li>6.52: <a href=#pg-4f002b9458521ca7afd32176fd590646>Ferramentas</a></li></ul><li>7: <a href=#pg-4985cb55ddfb184639d767ec54b9f0f7>Contribua com a documentação do Kubernetes</a></li><ul><li>7.1: <a href=#pg-ed3187078744c086d64f3d804a926218>Visualizando Analytics do Site</a></li></ul><li>8: <a href=#pg-91737b3265a3e3f407fbeeb86a8973ab></a></li><li>9: <a href=#pg-8ce5371351476b7b76c7eb723eac4417>Resultados da pesquisa</a></li></ul><div class=content><p><strong>Bem-vindo à documentação do Kubernetes em Português</strong></p><p>Como você pode ver, a maior parte da documentação ainda está disponível apenas em inglês, mas não se preocupe, há uma equipe trabalhando na tradução para o português.</p><p>Se você quiser participar, você pode entrar no canal Slack <a href=http://slack.kubernetes.io/>#kubernetes-docs-pt</a> e fazer parte da equipe por trás da tradução.</p><p>Você também pode acessar o canal para solicitar a tradução de uma página específica ou relatar qualquer erro que possa ter sido encontrado. Qualquer contribuição será bem recebida!</p><p>Para mais informações sobre como contribuir, dê uma olhada <a href=https://github.com/kubernetes/website/>github.com/kubernetes/website</a>.</p></div></div><div class=td-content style=page-break-before:always><h1 id=pg-e735cee7e913aa88bc0aa10594d12966>1 - Kubernetes</h1></div><div class=td-content><h1 id=pg-92dfff0ca612d0bff40171aa9df6c4ae>1.1 - Versões Suportadas da Documentação do Kubernetes</h1><p>Este site contém documentação para a versão atual do Kubernetes
e as quatro versões anteriores do Kubernetes.</p><h2 id=versão-atual>Versão Atual</h2><p>A versão atual é
<a href=/>v1.25</a>.</p><h2 id=versões-anteriores>Versões anteriores</h2><ul><li><a href=https://v1-24.docs.kubernetes.io>v1.24</a></li><li><a href=https://v1-23.docs.kubernetes.io>v1.23</a></li><li><a href=https://v1-22.docs.kubernetes.io>v1.22</a></li><li><a href=https://v1-21.docs.kubernetes.io>v1.21</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-66b565805ca1061be35ff2c0165f13c1>2 - Instalação</h1><p>Essa seção lista as diferentes formas de instalar e executar o Kubernetes. Quando você realiza a instalação de um cluster Kubernetes, deve decidir o tipo de instalação baseado em critérios como facilidade de manutenção, segurança, controle, quantidade de recursos disponíveis e a experiência necessária para gerenciar e operar o cluster.</p><p>Você pode criar um cluster Kubernetes em uma máquina local, na nuvem, em um datacenter on-premises ou ainda escolher uma oferta de um cluster Kubernetes gerenciado pelo seu provedor de computação em nuvem.</p><p>Existem ainda diversos outros tipos de soluções customizadas, que você pode se deparar ao buscar formas de instalação e gerenciamento de seu cluster.</p><h2 id=ambientes-de-aprendizado>Ambientes de aprendizado</h2><p>Se você está aprendendo ou pretende aprender mais sobre o Kubernetes, use ferramentas suportadas pela comunidade, ou ferramentas no ecossistema que te permitam criar um cluster Kubernetes em sua máquina virtual.</p><p>Temos como exemplo aqui o <a href=/docs/tasks/tools/install-minikube/>Minikube</a> e o <a href=https://kind.sigs.k8s.io/docs/user/quick-start/>KinD</a></p><h2 id=ambientes-de-produção>Ambientes de produção</h2><p>Ao analisar uma solução para um ambiente de produção, devem ser considerados quais aspectos de operação de um cluster Kubernetes você deseja gerenciar, ou então delegar ao seu provedor.</p><p>Temos diversas opções para esse provisionamento, desde o uso de uma ferramenta de deployment de um cluster tal qual o <a href=/docs/setup/production-environment/tools/kubeadm/install-kubeadm/>Kubeadm</a> ou o <a href=/docs/setup/production-environment/tools/kubespray/>Kubespray</a> quando se trata de um cluster local, ou ainda o uso de um cluster gerenciado por seu provedor de nuvem.</p><p>Para a escolha do melhor ambiente e da melhor forma para fazer essa instalação, você deve considerar:</p><ul><li>Se você deseja se preocupar com a gestão de backup da sua estrutura do ambiente de gerenciamento</li><li>Se você deseja ter um cluster mais atualizado, com novas funcionalidades, ou se deseja seguir a versão suportada pelo fornecedor</li><li>Se você deseja ter um cluster com um alto nível de serviço, ou com auto provisionamento de alta disponibilidade</li><li>Quanto você deseja pagar por essa produção</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-29e59491dd6118b23072dfe9ebb93323>2.1 - Instalando a ferramenta kubeadm</h1><p><img src=https://raw.githubusercontent.com/kubernetes/kubeadm/master/logos/stacked/color/kubeadm-stacked-color.png align=right width=150px>Essa página mostra o processo de instalação do conjunto de ferramentas <code>kubeadm</code>.
Para mais informações sobre como criar um cluster com o kubeadm após efetuar a instalação, veja a página <a href=/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/>Utilizando kubeadm para criar um cluster</a>.</p><h2 id=antes-de-você-começar>Antes de você começar</h2><ul><li>Uma máquina com sistema operacional Linux compatível. O projeto Kubernetes provê instruções para distribuições Linux baseadas em Debian e Red Hat, bem como para distribuições sem um gerenciador de pacotes.</li><li>2 GB ou mais de RAM por máquina (menos que isso deixará pouca memória para as suas aplicações).</li><li>2 CPUs ou mais.</li><li>Conexão de rede entre todas as máquinas no cluster. Seja essa pública ou privada.</li><li>Nome da máquina na rede, endereço MAC e producy_uuid únicos para cada nó. Mais detalhes podem ser lidos <a href=#veficiar-endereco-mac>aqui</a>.</li><li>Portas específicas abertas nas suas máquinas. Você poderá ler quais são <a href=#verificar-portas-necessarias>aqui</a>.</li><li>Swap desabilitado. Você <em>precisa</em> desabilitar a funcionalidade de swap para que o kubelet funcione de forma correta.</li></ul><h2 id=veficiar-endereco-mac>Verificando se o endereço MAC e o product_uiid são únicos para cada nó</h2><ul><li>Você pode verificar o endereço MAC da interface de rede utilizando o comando <code>ip link</code> ou o comando <code>ipconfig -a</code>.</li><li>O product_uuid pode ser verificado utilizando o comando <code>sudo cat /sys/class/dmi/id/product_uuid</code>.</li></ul><p>É provável que dispositivos físicos possuam endereços únicos. No entanto, é possível que algumas máquinas virtuais possuam endereços iguais. O Kubernetes utiliza esses valores para identificar unicamente os nós em um cluster. Se esses valores não forem únicos para cada nó, o processo de instalação pode <a href=https://github.com/kubernetes/kubeadm/issues/31>falhar</a>.</p><h2 id=verificando-os-adaptadores-de-rede>Verificando os adaptadores de rede</h2><p>Se você possuir mais de um adaptador de rede, e seus componentes Kubernetes não forem acessíveis através da rota padrão, recomendamos adicionar o IP das rotas para que os endereços do cluster Kubernetes passem pelo adaptador correto.</p><h2 id=fazendo-com-que-o-iptables-enxergue-o-tráfego-agregado>Fazendo com que o iptables enxergue o tráfego agregado</h2><p>Assegure-se de que o módulo <code>br_netfilter</code> está carregado. Isso pode ser feito executando o comando <code>lsmod | grep br_netfilter</code>. Para carrega-lo explicitamente execute <code>sudo modprobe br_netfilter</code>.</p><p>Como um requisito para que seus nós Linux enxerguem corretamente o tráfego agregado de rede, você deve garantir que a configuração <code>net.bridge.bridge-nf-call-iptables</code> do seu <code>sysctl</code> está configurada com valor 1. Como no exemplo abaixo:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF | sudo tee /etc/modules-load.d/k8s.conf
</span></span></span><span style=display:flex><span><span style=color:#b44>br_netfilter
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF | sudo tee /etc/sysctl.d/k8s.conf
</span></span></span><span style=display:flex><span><span style=color:#b44>net.bridge.bridge-nf-call-ip6tables = 1
</span></span></span><span style=display:flex><span><span style=color:#b44>net.bridge.bridge-nf-call-iptables = 1
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span><span style=display:flex><span>sudo sysctl --system
</span></span></code></pre></div><p>Para mais detalhes veja a página <a href=/pt-br/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/#network-plugin-requirements>Requisitos do plugin de rede</a>.</p><h2 id=verificando-as-portas-necessárias>Verificando as portas necessárias</h2><p>As portas listadas <a href=https://kubernetes.io/docs/reference/ports-and-protocols/>aqui</a> precisam estar abertas para que os componentes do Kubernetes se comuniquem uns com os outros.</p><p>O plugin de rede dos pods que você utiliza também pode requer que algumas portas estejam abertas. Dito que essas portas podem diferir dependendo do plugin, por favor leia a documentação dos plugins sobre quais portas serão necessárias abrir.</p><h2 id=instalando-agente-de-execucao>Instalando o agente de execução de contêineres</h2><p>Para executar os contêineres nos Pods, o Kubernetes utiliza um
<a class=glossary-tooltip title='O agente de execução de contêiner é o software responsável por executar os contêineres.' data-toggle=tooltip data-placement=top href=/docs/setup/production-environment/container-runtimes target=_blank aria-label='agente de execução'>agente de execução</a>.</p><ul class="nav nav-tabs" id=container-runtime role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#container-runtime-0 role=tab aria-controls=container-runtime-0 aria-selected=true>Nós Linux</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#container-runtime-1 role=tab aria-controls=container-runtime-1>Outros sistemas operacionais</a></li></ul><div class=tab-content id=container-runtime><div id=container-runtime-0 class="tab-pane show active" role=tabpanel aria-labelledby=container-runtime-0><p><p>Por padrão, o Kubernetes utiliza a <a class=glossary-tooltip title='Uma API para agentes de execução de contêineres se integrarem com o kubelet' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/components/#container-runtime target=_blank aria-label='interface do agente de execução'>interface do agente de execução</a> (CRI) para interagir com o seu agente de execução de contêiner escolhido.</p><p>Se você não especificar nenhum agente de execução, o kubeadm irá tentar identifica-lo automaticamente através de uma lista dos sockets Unix mais utilizados. A tabela a seguir lista os agentes de execução e os caminhos dos sockets a eles associados.</p><table><caption style=display:none>Agentes de execução e seus caminhos de socket</caption><thead><tr><th>Agente de execução</th><th>Caminho do socket Unix</th></tr></thead><tbody><tr><td>Docker</td><td><code>/var/run/dockershim.sock</code></td></tr><tr><td>containerd</td><td><code>/run/containerd/containerd.sock</code></td></tr><tr><td>CRI-O</td><td><code>/var/run/crio/crio.sock</code></td></tr></tbody></table><br>Se tanto o Docker quanto o containerd forem detectados no sistema, o Docker terá precedência. Isso acontece porque o Docker, desde a versão 18.09, já incluí o containerd e ambos são detectaveis mesmo que você só tenha instalado o Docker. Se outros dois ou mais agentes de execução forem detectados, o kubeadm é encerrado com um erro.<p>O kubelet se integra com o Docker através da implementação CRI <code>dockershim</code> já inclusa.</p><p>Veja a página dos <a href=/docs/setup/production-environment/container-runtimes/>agentes de execução</a>
para mais detalhes.</p></div><div id=container-runtime-1 class=tab-pane role=tabpanel aria-labelledby=container-runtime-1><p><p>Por padrão, o kubeadm utiliza o <a class=glossary-tooltip title='Docker é uma tecnologia utilizada para prover virtualização a nível do sistema operacional também conhecidoa como containers.' data-toggle=tooltip data-placement=top href=https://docs.docker.com/engine/ target=_blank aria-label=Docker>Docker</a> como agente de execução.
O kubelet se integra com o Docker através da implementação CRI <code>dockershim</code> já inclusa.</p><p>Veja a página dos <a href=/docs/setup/production-environment/container-runtimes/>agentes de execução</a>
para mais detalhes.</p></div></div><h2 id=instalando-o-kubeadm-kubelet-e-o-kubectl>Instalando o kubeadm, kubelet e o kubectl</h2><p>Você instalará esses pacotes em todas as suas máquinas:</p><ul><li><p><code>kubeadm</code>: o comando para criar o cluster.</p></li><li><p><code>kubelet</code>: o componente que executa em todas as máquinas no seu cluster e cuida de tarefas como a inicialização de pods e contêineres.</p></li><li><p><code>kubectl</code>: a ferramenta de linha de comando para interação com o cluster.</p></li></ul><p>O kubeadm <strong>não irá</strong> instalar ou gerenciar o <code>kubelet</code> ou o <code>kubectl</code> para você, então você
precisará garantir que as versões deles são as mesmas da versão da camada de gerenciamento do Kubernetes
que você quer que o kubeadm instale. Caso isso não seja feito, surge o risco de que uma diferença nas versões
leve a bugs e comportamentos inesperados. Dito isso, <em>uma</em> diferença de menor grandeza nas versões entre o kubelet e a
camada de gerenciamento é suportada, mas a versão do kubelet nunca poderá ser superior à versão do servidor da API.
Por exemplo, um kubelet com a versão 1.7.0 será totalmente compatível com a versão 1.8.0 do servidor da API, mas o contrário não será verdadeiro.</p><p>Para mais informações acerca da instalação do <code>kubectl</code>, veja <a href=/docs/tasks/tools/>Instale e configure o kubectl</a>.</p><div class="alert alert-danger warning callout" role=alert><strong>Aviso:</strong> Essas instruções removem todos os pacotes Kubernetes de quaisquer atualizações de sistema.
Isso ocorre porque o kubeadm e o Kubernetes requerem alguns <a href=/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade/>cuidados especiais para serem atualizados</a>.</div><p>Para mais detalhes sobre compatibilidade entre as versões, veja:</p><ul><li><a href=/docs/setup/release/version-skew-policy/>Políticas de versão e compatibilidade entre versões</a> do Kubernetes.</li><li><a href=/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/#version-skew-policy>Compatibilidade entre versões</a> do Kubeadm.</li></ul><ul class="nav nav-tabs" id=k8s-install role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#k8s-install-0 role=tab aria-controls=k8s-install-0 aria-selected=true>Distribuições Debian</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#k8s-install-1 role=tab aria-controls=k8s-install-1>Distribuições Red Hat</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#k8s-install-2 role=tab aria-controls=k8s-install-2>Sem um gerenciador de pacotes</a></li></ul><div class=tab-content id=k8s-install><div id=k8s-install-0 class="tab-pane show active" role=tabpanel aria-labelledby=k8s-install-0><p><ol><li><p>Atualize o índice de pacotes <code>apt</code> e instale os pacotes necessários para utilizar o repositório <code>apt</code> do Kubernetes:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sudo apt-get update
</span></span><span style=display:flex><span>sudo apt-get install -y apt-transport-https ca-certificates curl
</span></span></code></pre></div></li><li><p>Faça o download da chave de assinatura pública da Google Cloud:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sudo curl -fsSLo /usr/share/keyrings/kubernetes-archive-keyring.gpg https://packages.cloud.google.com/apt/doc/apt-key.gpg
</span></span></code></pre></div></li><li><p>Adicione o repositório <code>apt</code> do Kubernetes:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b44>&#34;deb [signed-by=/usr/share/keyrings/kubernetes-archive-keyring.gpg] https://apt.kubernetes.io/ kubernetes-xenial main&#34;</span> | sudo tee /etc/apt/sources.list.d/kubernetes.list
</span></span></code></pre></div></li><li><p>Atualize o índice de pacotes <code>apt</code>, instale o kubelet, o kubeadm e o kubectl, e fixe suas versões:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sudo apt-get update
</span></span><span style=display:flex><span>sudo apt-get install -y kubelet kubeadm kubectl
</span></span><span style=display:flex><span>sudo apt-mark hold kubelet kubeadm kubectl
</span></span></code></pre></div></li></ol></div><div id=k8s-install-1 class=tab-pane role=tabpanel aria-labelledby=k8s-install-1><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF | sudo tee /etc/yum.repos.d/kubernetes.repo
</span></span></span><span style=display:flex><span><span style=color:#b44>[kubernetes]
</span></span></span><span style=display:flex><span><span style=color:#b44>name=Kubernetes
</span></span></span><span style=display:flex><span><span style=color:#b44>baseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-\$basearch
</span></span></span><span style=display:flex><span><span style=color:#b44>enabled=1
</span></span></span><span style=display:flex><span><span style=color:#b44>gpgcheck=1
</span></span></span><span style=display:flex><span><span style=color:#b44>repo_gpgcheck=1
</span></span></span><span style=display:flex><span><span style=color:#b44>gpgkey=https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg
</span></span></span><span style=display:flex><span><span style=color:#b44>exclude=kubelet kubeadm kubectl
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Set SELinux in permissive mode (effectively disabling it)</span>
</span></span><span style=display:flex><span>sudo setenforce <span style=color:#666>0</span>
</span></span><span style=display:flex><span>sudo sed -i <span style=color:#b44>&#39;s/^SELINUX=enforcing$/SELINUX=permissive/&#39;</span> /etc/selinux/config
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>sudo yum install -y kubelet kubeadm kubectl --disableexcludes<span style=color:#666>=</span>kubernetes
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>sudo systemctl <span style=color:#a2f>enable</span> --now kubelet
</span></span></code></pre></div><p><strong>Avisos:</strong></p><ul><li><p>Colocar o SELinux em modo permissivo ao executar <code>setenforce 0</code> e <code>sed ...</code> efetivamente o desabilita.
Isso é necessário para permitir que os contêineres acessem o sistema de arquivos do hospedeiro, que é utilizado pelas redes dos pods por exemplo.
Você precisará disso até que o suporte ao SELinux seja melhorado no kubelet.</p></li><li><p>Você pode deixar o SELinux habilitado se você souber como configura-lo, mas isso pode exegir configurações que não são suportadas pelo kubeadm.</p></li></ul></div><div id=k8s-install-2 class=tab-pane role=tabpanel aria-labelledby=k8s-install-2><p><p>Instale os plugins CNI (utilizados por grande parte das redes de pods):</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#b8860b>CNI_VERSION</span><span style=color:#666>=</span><span style=color:#b44>&#34;v0.8.2&#34;</span>
</span></span><span style=display:flex><span><span style=color:#b8860b>ARCH</span><span style=color:#666>=</span><span style=color:#b44>&#34;amd64&#34;</span>
</span></span><span style=display:flex><span>sudo mkdir -p /opt/cni/bin
</span></span><span style=display:flex><span>curl -L <span style=color:#b44>&#34;https://github.com/containernetworking/plugins/releases/download/</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>CNI_VERSION</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>/cni-plugins-linux-</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>ARCH</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>-</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>CNI_VERSION</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>.tgz&#34;</span> | sudo tar -C /opt/cni/bin -xz
</span></span></code></pre></div><p>Escolha o diretório para baixar os arquivos de comandos.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> A variável <code>DOWNLOAD_DIR</code> precisa estar configurada para um diretório que permita escrita.
Se você estiver utilizando o Flatcar Container Linux, configure a váriavel de ambiente <code>DOWNLOAD_DIR=/opt/bin</code>.</div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#b8860b>DOWNLOAD_DIR</span><span style=color:#666>=</span>/usr/local/bin
</span></span><span style=display:flex><span>sudo mkdir -p <span style=color:#b8860b>$DOWNLOAD_DIR</span>
</span></span></code></pre></div><p>Instale o crictl (utilizado pelo kubeadm e pela Interface do Agente de execução do Kubelet (CRI))</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#b8860b>CRICTL_VERSION</span><span style=color:#666>=</span><span style=color:#b44>&#34;v1.22.0&#34;</span>
</span></span><span style=display:flex><span><span style=color:#b8860b>ARCH</span><span style=color:#666>=</span><span style=color:#b44>&#34;amd64&#34;</span>
</span></span><span style=display:flex><span>curl -L <span style=color:#b44>&#34;https://github.com/kubernetes-sigs/cri-tools/releases/download/</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>CRICTL_VERSION</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>/crictl-</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>CRICTL_VERSION</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>-linux-</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>ARCH</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>.tar.gz&#34;</span> | sudo tar -C <span style=color:#b8860b>$DOWNLOAD_DIR</span> -xz
</span></span></code></pre></div><p>Instale o <code>kubeadm</code>, o <code>kubelet</code>, e o <code>kubectl</code> e adicione o serviço systemd <code>kubelet</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#b8860b>RELEASE</span><span style=color:#666>=</span><span style=color:#b44>&#34;</span><span style=color:#a2f;font-weight:700>$(</span>curl -sSL https://dl.k8s.io/release/stable.txt<span style=color:#a2f;font-weight:700>)</span><span style=color:#b44>&#34;</span>
</span></span><span style=display:flex><span><span style=color:#b8860b>ARCH</span><span style=color:#666>=</span><span style=color:#b44>&#34;amd64&#34;</span>
</span></span><span style=display:flex><span><span style=color:#a2f>cd</span> <span style=color:#b8860b>$DOWNLOAD_DIR</span>
</span></span><span style=display:flex><span>sudo curl -L --remote-name-all https://storage.googleapis.com/kubernetes-release/release/<span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>RELEASE</span><span style=color:#b68;font-weight:700>}</span>/bin/linux/<span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>ARCH</span><span style=color:#b68;font-weight:700>}</span>/<span style=color:#666>{</span>kubeadm,kubelet,kubectl<span style=color:#666>}</span>
</span></span><span style=display:flex><span>sudo chmod +x <span style=color:#666>{</span>kubeadm,kubelet,kubectl<span style=color:#666>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#b8860b>RELEASE_VERSION</span><span style=color:#666>=</span><span style=color:#b44>&#34;v0.4.0&#34;</span>
</span></span><span style=display:flex><span>curl -sSL <span style=color:#b44>&#34;https://raw.githubusercontent.com/kubernetes/release/</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>RELEASE_VERSION</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>/cmd/kubepkg/templates/latest/deb/kubelet/lib/systemd/system/kubelet.service&#34;</span> | sed <span style=color:#b44>&#34;s:/usr/bin:</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>DOWNLOAD_DIR</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>:g&#34;</span> | sudo tee /etc/systemd/system/kubelet.service
</span></span><span style=display:flex><span>sudo mkdir -p /etc/systemd/system/kubelet.service.d
</span></span><span style=display:flex><span>curl -sSL <span style=color:#b44>&#34;https://raw.githubusercontent.com/kubernetes/release/</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>RELEASE_VERSION</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>/cmd/kubepkg/templates/latest/deb/kubeadm/10-kubeadm.conf&#34;</span> | sed <span style=color:#b44>&#34;s:/usr/bin:</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>DOWNLOAD_DIR</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>:g&#34;</span> | sudo tee /etc/systemd/system/kubelet.service.d/10-kubeadm.conf
</span></span></code></pre></div><p>Habilite e inicie o <code>kubelet</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>systemctl <span style=color:#a2f>enable</span> --now kubelet
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> A distribuição Flatcar Container Linux instala o diretório <code>/usr</code> como um sistema de arquivos apenas para leitura.
Antes de inicializar o seu cluster, você precisa de alguns passos adicionais para configurar um diretório com escrita.
Veja o <a href=/docs/setup/production-environment/tools/kubeadm/troubleshooting-kubeadm/#usr-mounted-read-only/>Guia de solução de problemas do Kubeadm</a> para aprender como configurar um diretório com escrita.</div></div></div><p>O kubelet agora ficará reiniciando de alguns em alguns segundos, enquanto espera por instruções vindas do kubeadm.</p><h2 id=configurando-um-driver-cgroup>Configurando um driver cgroup</h2><p>Tanto o agente de execução quanto o kubelet possuem uma propriedade chamada
<a href=/docs/setup/production-environment/container-runtimes/>"driver cgroup"</a>, que é importante
para o gerenciamento dos cgroups em máquinas Linux.</p><div class="alert alert-danger warning callout" role=alert><strong>Aviso:</strong><p>A compatibilidade entre os drivers cgroup e o agente de execução é necessária. Sem ela o processo do kubelet irá falhar.</p><p>Veja <a href=/docs/tasks/administer-cluster/kubeadm/configure-cgroup-driver/>configurando um driver cgroup</a> para mais detalhes.</p></div><h2 id=solucionando-problemas>Solucionando problemas</h2><p>Se você encontrar problemas com o kubeadm, por favor consulte a nossa <a href=/docs/setup/production-environment/tools/kubeadm/troubleshooting-kubeadm/>documentação de solução de problemas</a>.</p><h2 id=próximos-passos>Próximos passos</h2><ul><li><a href=/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/>Utilizando o kubeadm para criar um cluster</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-478acca1934b6d89a0bc00fb25bfe5b6>2.2 - Instalando Kubernetes com kOps</h1><p>Este início rápido mostra como instalar facilmente um cluster Kubernetes na AWS usando uma ferramenta chamada <a href=https://github.com/kubernetes/kops><code>kOps</code></a>.</p><p><code>kOps</code> é um sistema de provisionamento automatizado:</p><ul><li>Instalação totalmente automatizada</li><li>Usa DNS para identificar clusters</li><li>Auto-recuperação: tudo é executado em grupos de Auto-Scaling</li><li>Suporte de vários sistemas operacionais (Amazon Linux, Debian, Flatcar, RHEL, Rocky e Ubuntu) - veja em <a href=https://github.com/kubernetes/kops/blob/master/docs/operations/images.md>imagens</a></li><li>Suporte a alta disponibilidade - consulte a <a href=https://github.com/kubernetes/kops/blob/master/docs/operations/high_availability.md>documentação sobre alta disponibilidade</a></li><li>Pode provisionar diretamente ou gerar manifestos do terraform - veja a <a href=https://github.com/kubernetes/kops/blob/master/docs/terraform.md>documentação sobre como fazer isso com Terraform</a></li></ul><h2 id=antes-de-você-começar>Antes de você começar</h2><ul><li><p>Você deve ter o <a href=/docs/tasks/tools/>kubectl</a> instalado.</p></li><li><p>Você deve <a href=https://github.com/kubernetes/kops#installing>instalar</a> <code>kops</code> em uma arquitetura de dispositivo de 64 bits (AMD64 e Intel 64).</p></li><li><p>Você deve ter uma <a href=https://docs.aws.amazon.com/polly/latest/dg/setting-up.html>conta da AWS</a>, gerar as <a href=https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys>chaves do IAM</a> e <a href=https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-configure.html#cli-quick-configuration>configurá-las</a>. O usuário do IAM precisará de <a href=https://github.com/kubernetes/kops/blob/master/docs/getting_started/aws.md#setup-iam-user>permissões adequadas</a>.</p></li></ul><h2 id=como-criar-um-cluster>Como criar um cluster</h2><h3 id=1-5-instalar-kops>(1/5) Instalar kops</h3><h4 id=instalação>Instalação</h4><p>Faça o download do kops na <a href=https://github.com/kubernetes/kops/releases>página de downloads</a> (também é conveniente gerar um binário a partir do código-fonte):</p><ul class="nav nav-tabs" id=kops-installation role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#kops-installation-0 role=tab aria-controls=kops-installation-0 aria-selected=true>macOS</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#kops-installation-1 role=tab aria-controls=kops-installation-1>Linux</a></li></ul><div class=tab-content id=kops-installation><div id=kops-installation-0 class="tab-pane show active" role=tabpanel aria-labelledby=kops-installation-0><p><p>Baixe a versão mais recente com o comando:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -LO https://github.com/kubernetes/kops/releases/download/<span style=color:#a2f;font-weight:700>$(</span>curl -s https://api.github.com/repos/kubernetes/kops/releases/latest | grep tag_name | cut -d <span style=color:#b44>&#39;&#34;&#39;</span> -f 4<span style=color:#a2f;font-weight:700>)</span>/kops-darwin-amd64
</span></span></code></pre></div><p>Para baixar uma versão específica, substitua a seguinte parte do comando pela versão específica do kops.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f;font-weight:700>$(</span>curl -s https://api.github.com/repos/kubernetes/kops/releases/latest | grep tag_name | cut -d <span style=color:#b44>&#39;&#34;&#39;</span> -f 4<span style=color:#a2f;font-weight:700>)</span>
</span></span></code></pre></div><p>Por exemplo, para baixar kops versão v1.20.0 digite:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -LO https://github.com/kubernetes/kops/releases/download/v1.20.0/kops-darwin-amd64
</span></span></code></pre></div><p>Dê a permissão de execução ao binário do kops.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>chmod +x kops-darwin-amd64
</span></span></code></pre></div><p>Mova o binário do kops para o seu PATH.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sudo mv kops-darwin-amd64 /usr/local/bin/kops
</span></span></code></pre></div><p>Você também pode instalar kops usando <a href=https://brew.sh/>Homebrew</a>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>brew update <span style=color:#666>&amp;&amp;</span> brew install kops
</span></span></code></pre></div></div><div id=kops-installation-1 class=tab-pane role=tabpanel aria-labelledby=kops-installation-1><p><p>Baixe a versão mais recente com o comando:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -LO https://github.com/kubernetes/kops/releases/download/<span style=color:#a2f;font-weight:700>$(</span>curl -s https://api.github.com/repos/kubernetes/kops/releases/latest | grep tag_name | cut -d <span style=color:#b44>&#39;&#34;&#39;</span> -f 4<span style=color:#a2f;font-weight:700>)</span>/kops-linux-amd64
</span></span></code></pre></div><p>Para baixar uma versão específica do kops, substitua a seguinte parte do comando pela versão específica do kops.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f;font-weight:700>$(</span>curl -s https://api.github.com/repos/kubernetes/kops/releases/latest | grep tag_name | cut -d <span style=color:#b44>&#39;&#34;&#39;</span> -f 4<span style=color:#a2f;font-weight:700>)</span>
</span></span></code></pre></div><p>Por exemplo, para baixar kops versão v1.20.0 digite:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -LO https://github.com/kubernetes/kops/releases/download/v1.20.0/kops-linux-amd64
</span></span></code></pre></div><p>Dê a permissão de execução ao binário do kops</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>chmod +x kops-linux-amd64
</span></span></code></pre></div><p>Mova o binário do kops para o seu PATH.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sudo mv kops-linux-amd64 /usr/local/bin/kops
</span></span></code></pre></div><p>Você também pode instalar kops usando <a href=https://docs.brew.sh/Homebrew-on-Linux>Homebrew</a>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>brew update <span style=color:#666>&amp;&amp;</span> brew install kops
</span></span></code></pre></div></div></div><h3 id=2-5-crie-um-domínio-route53-para-seu-cluster>(2/5) Crie um domínio route53 para seu cluster</h3><p>O kops usa DNS para descoberta, tanto dentro do cluster quanto fora, para que você possa acessar o servidor da API do kubernetes a partir dos clientes.</p><p>kops tem uma opinião forte sobre o nome do cluster: deve ser um nome DNS válido. Ao fazer isso, você não confundirá mais seus clusters, poderá compartilhar clusters com seus colegas de forma inequívoca e alcançá-los sem ter de lembrar de um endereço IP.</p><p>Você pode e provavelmente deve usar subdomínios para dividir seus clusters. Como nosso exemplo usaremos
<code>useast1.dev.example.com</code>. O endpoint do servidor de API será então <code>api.useast1.dev.example.com</code>.</p><p>Uma zona hospedada do Route53 pode servir subdomínios. Sua zona hospedada pode ser <code>useast1.dev.example.com</code>,
mas também <code>dev.example.com</code> ou até <code>example.com</code>. kops funciona com qualquer um deles, então normalmente você escolhe por motivos de organização (por exemplo, você tem permissão para criar registros em <code>dev.example.com</code>,
mas não em <code>example.com</code>).</p><p>Vamos supor que você esteja usando <code>dev.example.com</code> como sua zona hospedada. Você cria essa zona hospedada usando o <a href=https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/CreatingNewSubdomain.html>processo normal</a>, ou
com um comando como <code>aws route53 create-hosted-zone --name dev.example.com --caller-reference 1</code>.</p><p>Você deve então configurar seus registros NS no domínio principal, para que os registros no domínio sejam resolvidos. Aqui, você criaria registros NS no <code>example.com</code> para <code>dev</code>. Se for um nome de domínio raiz, você configuraria os registros NS em seu registrador de domínio (por exemplo <code>example.com</code>, precisaria ser configurado onde você comprou <code>example.com</code>).</p><p>Verifique a configuração do seu domínio route53 (é a causa número 1 de problemas!). Você pode verificar novamente se seu cluster está configurado corretamente se tiver a ferramenta dig executando:</p><p><code>dig NS dev.example.com</code></p><p>Você deve ver os 4 registros NS que o Route53 atribuiu à sua zona hospedada.</p><h3 id=3-5-crie-um-bucket-do-s3-para-armazenar-o-estado-dos-clusters>(3/5) Crie um bucket do S3 para armazenar o estado dos clusters</h3><p>O kops permite que você gerencie seus clusters mesmo após a instalação. Para fazer isso, ele deve acompanhar os clusters que você criou, juntamente com suas configurações, as chaves que estão usando etc. Essas informações são armazenadas em um bucket do S3. As permissões do S3 são usadas para controlar o acesso ao bucket.</p><p>Vários clusters podem usar o mesmo bucket do S3 e você pode compartilhar um bucket do S3 entre seus colegas que administram os mesmos clusters - isso é muito mais fácil do que transmitir arquivos kubecfg. Mas qualquer pessoa com acesso ao bucket do S3 terá acesso administrativo a todos os seus clusters, portanto, você não deseja compartilhá-lo além da equipe de operações.</p><p>Portanto, normalmente você tem um bucket do S3 para cada equipe de operações (e geralmente o nome corresponderá ao nome da zona hospedada acima!)</p><p>Em nosso exemplo, escolhemos <code>dev.example.com</code> como nossa zona hospedada, então vamos escolher <code>clusters.dev.example.com</code> como o nome do bucket do S3.</p><ul><li><p>Exporte <code>AWS_PROFILE</code> (se precisar selecione um perfil para que a AWS CLI funcione)</p></li><li><p>Crie o bucket do S3 usando <code>aws s3 mb s3://clusters.dev.example.com</code></p></li><li><p>Você pode rodar <code>export KOPS_STATE_STORE=s3://clusters.dev.example.com</code> e, em seguida, o kops usará esse local por padrão. Sugerimos colocar isso em seu perfil bash ou similar.</p></li></ul><h3 id=4-5-crie-sua-configuração-de-cluster>(4/5) Crie sua configuração de cluster</h3><p>Execute <code>kops create cluster</code> para criar sua configuração de cluster:</p><p><code>kops create cluster --zones=us-east-1c useast1.dev.example.com</code></p><p>kops criará a configuração para seu cluster. Observe que ele <em>apenas</em> cria a configuração, na verdade não cria os recursos de nuvem - você fará isso na próxima etapa com um arquivo <code>kops update cluster</code>. Isso lhe dá a oportunidade de revisar a configuração ou alterá-la.</p><p>Ele exibe comandos que você pode usar para explorar mais:</p><ul><li>Liste seus clusters com: <code>kops get cluster</code></li><li>Edite este cluster com: <code>kops edit cluster useast1.dev.example.com</code></li><li>Edite seu grupo de instâncias de nós: <code>kops edit ig --name=useast1.dev.example.com nodes</code></li><li>Edite seu grupo de instâncias principal: <code>kops edit ig --name=useast1.dev.example.com master-us-east-1c</code></li></ul><p>Se esta é sua primeira vez usando kops, gaste alguns minutos para experimentá-los! Um grupo de instâncias é um conjunto de instâncias que serão registradas como nós do kubernetes. Na AWS, isso é implementado por meio de grupos de auto-scaling.
Você pode ter vários grupos de instâncias, por exemplo, se quiser nós que sejam uma combinação de instâncias spot e sob demanda ou instâncias de GPU e não GPU.</p><h3 id=5-5-crie-o-cluster-na-aws>(5/5) Crie o cluster na AWS</h3><p>Execute <code>kops update cluster</code> para criar seu cluster na AWS:</p><p><code>kops update cluster useast1.dev.example.com --yes</code></p><p>Isso leva alguns segundos para ser executado, mas seu cluster provavelmente levará alguns minutos para estar realmente pronto.
<code>kops update cluster</code> será a ferramenta que você usará sempre que alterar a configuração do seu cluster; ele aplica as alterações que você fez na configuração ao seu cluster - reconfigurando AWS ou kubernetes conforme necessário.</p><p>Por exemplo, depois de você executar <code>kops edit ig nodes</code>, em seguida execute <code>kops update cluster --yes</code> para aplicar sua configuração e, às vezes, você também precisará <code>kops rolling-update cluster</code> para implementar a configuração imediatamente.</p><p>Sem <code>--yes</code>, <code>kops update cluster</code> mostrará uma prévia do que ele fará. Isso é útil para clusters de produção!</p><h3 id=explore-outros-complementos>Explore outros complementos</h3><p>Consulte a <a href=/pt-br/docs/concepts/cluster-administration/addons/>lista de complementos</a> para explorar outros complementos, incluindo ferramentas para registro, monitoramento, política de rede, visualização e controle de seu cluster Kubernetes.</p><h2 id=limpeza>Limpeza</h2><ul><li>Para excluir seu cluster: <code>kops delete cluster useast1.dev.example.com --yes</code></li></ul><h2 id=próximos-passos>Próximos passos</h2><ul><li>Saiba mais sobre os <a href=/pt-br/docs/concepts/>conceitos do Kubernetes</a> e o <a href=/docs/reference/kubectl/><code>kubectl</code></a>.</li><li>Saiba mais sobre o <a href=https://kops.sigs.k8s.io/>uso avançado</a> do <code>kOps</code> para tutoriais, práticas recomendadas e opções de configuração avançada.</li><li>Siga as discussões da comunidade do <code>kOps</code> no Slack: <a href=https://github.com/kubernetes/kops#other-ways-to-communicate-with-the-contributors>discussões da comunidade</a>.</li><li>Contribua para o <code>kOps</code> endereçando ou levantando um problema <a href=https://github.com/kubernetes/kops/issues>GitHub Issues</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-d2f55eefe7222b7c637875af9c3ec199>2.3 - Soluções de Nuvem Prontas para uso</h1><p>Essa página fornece uma lista de provedores de soluções certificadas do Kubernetes. Na página de cada provedor, você pode aprender como instalar e configurar clusters prontos para produção.</p><script>function updateLandscapeSource(e,t){console.log({button:e,shouldUpdateFragment:t});try{if(t)window.location.hash="#"+e.id;else{var n=document.querySelectorAll("#landscape");let t=e.dataset.landscapeTypes,s="https://landscape.cncf.io/card-mode?category="+encodeURIComponent(t)+"&grouping=category&embed=yes";n[0].src=s}}catch(e){console.log({message:"error handling Landscape switch",error:e})}}document.addEventListener("DOMContentLoaded",function(){let t=()=>{if(window.location.hash){let e=document.querySelectorAll(".landscape-trigger"+window.location.hash);e.length==1&&(landscapeSource=e[0],console.log("Updating Landscape source based on fragment:",window.location.hash.substring(1)),updateLandscapeSource(landscapeSource,!1))}};var e,n=document.querySelectorAll(".landscape-trigger");if(n.forEach(e=>{e.onclick=function(){updateLandscapeSource(e,!0)}}),e=document.querySelectorAll(".landscape-trigger.landscape-default"),e.length==1){let t=e[0];updateLandscapeSource(t,!1)}window.addEventListener("hashchange",t,!1),t()})</script><div id=frameHolder><iframe frameborder=0 id=landscape scrolling=no src="https://landscape.cncf.io/card-mode?category=certified-kubernetes-hosted&grouping=category&embed=yes" style=width:1px;min-width:100%></iframe>
<script src=https://landscape.cncf.io/iframeResizer.js></script></div></div><div class=td-content style=page-break-before:always><h1 id=pg-dd948255948d6b59b32c471abcb62997>3 - Conceitos</h1><p>A seção de Conceitos irá te ajudar a aprender mais sobre as partes do ecossistema Kubernetes e as abstrações que o Kubernetes usa para representar seu <a class=glossary-tooltip title='Um conjunto de servidores de processamento, também chamados de nós, que executam aplicações containerizadas. Todo cluster possui ao menos um servidor de processamento (worker node).' data-toggle=tooltip data-placement=top href='/pt-br/docs/reference/glossary/?all=true#term-cluster' target=_blank aria-label=cluster>cluster</a>.</p><p>Ela irá lhe ajudar a obter um entendimento mais profundo sobre como o Kubernetes funciona.</p></div><div class=td-content><h1 id=pg-0554ac387412eaf4e6e89b2f847dacde>3.1 - Visão Geral</h1><div class=lead>Obtenha uma visão em alto-nível do Kubernetes e dos componentes a partir dos quais ele é construído.</div></div><div class=td-content><h1 id=pg-45bdca6129cf540121623e903c18ba46>3.1.1 - O que é Kubernetes?</h1><div class=lead>Kubernetes é um plataforma de código aberto, portável e extensiva para o gerenciamento de cargas de trabalho e serviços distribuídos em contêineres, que facilita tanto a configuração declarativa quanto a automação. Ele possui um ecossistema grande, e de rápido crescimento. Serviços, suporte, e ferramentas para Kubernetes estão amplamente disponíveis.</div><p>Essa página é uma visão geral do Kubernetes.</p><p>Kubernetes é um plataforma de código aberto, portável e extensiva para o gerenciamento de cargas de trabalho e serviços distribuídos em contêineres, que facilita tanto a configuração declarativa quanto a automação. Ele possui um ecossistema grande, e de rápido crescimento. Serviços, suporte, e ferramentas para Kubernetes estão amplamente disponíveis.</p><p>O Google tornou Kubernetes um projeto de código-aberto em 2014. O Kubernetes combina <a href=/blog/2015/04/borg-predecessor-to-kubernetes/>mais de 15 anos de experiência do Google</a> executando cargas de trabalho produtivas em escala, com as melhores idéias e práticas da comunidade.</p><p>O nome <strong>Kubernetes</strong> tem origem no Grego, significando <em>timoneiro</em> ou <em>piloto</em>. <strong>K8s</strong> é a abreviação derivada pela troca das oito letras "ubernete" por "8", se tornado <em>K"8"s</em>.</p><h2 id=voltando-no-tempo>Voltando no tempo</h2><p>Vamos dar uma olhada no porque o Kubernetes é tão útil, voltando no tempo.</p><p><img src=/images/docs/Container_Evolution.svg alt="Evolução das implantações"></p><p><strong>Era da implantação tradicional:</strong> No início, as organizações executavam aplicações em servidores físicos. Não havia como definir limites de recursos para aplicações em um mesmo servidor físico, e isso causava problemas de alocação de recursos. Por exemplo, se várias aplicações fossem executadas em um mesmo servidor físico, poderia haver situações em que uma aplicação ocupasse a maior parte dos recursos e, como resultado, o desempenho das outras aplicações seria inferior. Uma solução para isso seria executar cada aplicação em um servidor físico diferente. Mas isso não escalava, pois os recursos eram subutilizados, e se tornava custoso para as organizações manter muitos servidores físicos.</p><p><strong>Era da implantação virtualizada:</strong> Como solução, a virtualização foi introduzida. Esse modelo permite que você execute várias máquinas virtuais (VMs) em uma única CPU de um servidor físico. A virtualização permite que as aplicações sejam isoladas entre as VMs, e ainda fornece um nível de segurança, pois as informações de uma aplicação não podem ser acessadas livremente por outras aplicações.</p><p>A virtualização permite melhor utilização de recursos em um servidor físico, e permite melhor escalabilidade porque uma aplicação pode ser adicionada ou atualizada facilmente, reduz os custos de hardware e muito mais. Com a virtualização, você pode apresentar um conjunto de recursos físicos como um cluster de máquinas virtuais descartáveis.</p><p>Cada VM é uma máquina completa que executa todos os componentes, incluindo seu próprio sistema operacional, além do hardware virtualizado.</p><p><strong>Era da implantação em contêineres:</strong> Contêineres são semelhantes às VMs, mas têm propriedades de isolamento flexibilizados para compartilhar o sistema operacional (SO) entre as aplicações. Portanto, os contêineres são considerados leves. Semelhante a uma VM, um contêiner tem seu próprio sistema de arquivos, compartilhamento de CPU, memória, espaço de processo e muito mais. Como eles estão separados da infraestrutura subjacente, eles são portáveis entre nuvens e distribuições de sistema operacional.</p><p>Contêineres se tornaram populares porque eles fornecem benefícios extra, tais como:</p><ul><li>Criação e implantação ágil de aplicações: aumento da facilidade e eficiência na criação de imagem de contêiner comparado ao uso de imagem de VM.</li><li>Desenvolvimento, integração e implantação contínuos: fornece capacidade de criação e de implantação de imagens de contêiner de forma confiável e frequente, com a funcionalidade de efetuar reversões rápidas e eficientes (devido à imutabilidade da imagem).</li><li>Separação de interesses entre Desenvolvimento e Operações: crie imagens de contêineres de aplicações no momento de construção/liberação em vez de no momento de implantação, desacoplando as aplicações da infraestrutura.</li><li>A capacidade de observação (Observabilidade) não apenas apresenta informações e métricas no nível do sistema operacional, mas também a integridade da aplicação e outros sinais.</li><li>Consistência ambiental entre desenvolvimento, teste e produção: funciona da mesma forma em um laptop e na nuvem.</li><li>Portabilidade de distribuição de nuvem e sistema operacional: executa no Ubuntu, RHEL, CoreOS, localmente, nas principais nuvens públicas e em qualquer outro lugar.</li><li>Gerenciamento centrado em aplicações: eleva o nível de abstração da execução em um sistema operacional em hardware virtualizado à execução de uma aplicação em um sistema operacional usando recursos lógicos.</li><li>Microserviços fracamente acoplados, distribuídos, elásticos e livres: as aplicações são divididas em partes menores e independentes e podem ser implantados e gerenciados dinamicamente - não uma pilha monolítica em execução em uma grande máquina de propósito único.</li><li>Isolamento de recursos: desempenho previsível de aplicações.</li><li>Utilização de recursos: alta eficiência e densidade.</li></ul><h2 id=why-you-need-kubernetes-and-what-can-it-do>Por que você precisa do Kubernetes e o que ele pode fazer</h2><p>Os contêineres são uma boa maneira de agrupar e executar suas aplicações. Em um ambiente de produção, você precisa gerenciar os contêineres que executam as aplicações e garantir que não haja tempo de inatividade. Por exemplo, se um contêiner cair, outro contêiner precisa ser iniciado. Não seria mais fácil se esse comportamento fosse controlado por um sistema?</p><p>É assim que o Kubernetes vem ao resgate! O Kubernetes oferece uma estrutura para executar sistemas distribuídos de forma resiliente. Ele cuida do escalonamento e do recuperação à falha de sua aplicação, fornece padrões de implantação e muito mais. Por exemplo, o Kubernetes pode gerenciar facilmente uma implantação no método canário para seu sistema.</p><p>O Kubernetes oferece a você:</p><ul><li><strong>Descoberta de serviço e balanceamento de carga</strong>
O Kubernetes pode expor um contêiner usando o nome DNS ou seu próprio endereço IP. Se o tráfego para um contêiner for alto, o Kubernetes pode balancear a carga e distribuir o tráfego de rede para que a implantação seja estável.</li><li><strong>Orquestração de armazenamento</strong>
O Kubernetes permite que você monte automaticamente um sistema de armazenamento de sua escolha, como armazenamentos locais, provedores de nuvem pública e muito mais.</li><li><strong>Lançamentos e reversões automatizadas</strong>
Você pode descrever o estado desejado para seus contêineres implantados usando o Kubernetes, e ele pode alterar o estado real para o estado desejado em um ritmo controlada. Por exemplo, você pode automatizar o Kubernetes para criar novos contêineres para sua implantação, remover os contêineres existentes e adotar todos os seus recursos para o novo contêiner.</li><li><strong>Empacotamento binário automático</strong>
Você fornece ao Kubernetes um cluster de nós que pode ser usado para executar tarefas nos contêineres. Você informa ao Kubernetes de quanta CPU e memória (RAM) cada contêiner precisa. O Kubernetes pode encaixar contêineres em seus nós para fazer o melhor uso de seus recursos.</li><li><strong>Autocorreção</strong>
O Kubernetes reinicia os contêineres que falham, substitui os contêineres, elimina os contêineres que não respondem à verificação de integridade definida pelo usuário e não os anuncia aos clientes até que estejam prontos para servir.</li><li><strong>Gerenciamento de configuração e de segredos</strong>
O Kubernetes permite armazenar e gerenciar informações confidenciais, como senhas, tokens OAuth e chaves SSH. Você pode implantar e atualizar segredos e configuração de aplicações sem reconstruir suas imagens de contêiner e sem expor segredos em sua pilha de configuração.</li></ul><h2 id=o-que-o-kubernetes-não-é>O que o Kubernetes não é</h2><p>O Kubernetes não é um sistema PaaS (plataforma como serviço) tradicional e completo. Como o Kubernetes opera no nível do contêiner, e não no nível do hardware, ele fornece alguns recursos geralmente aplicáveis comuns às ofertas de PaaS, como implantação, escalonamento, balanceamento de carga, e permite que os usuários integrem suas soluções de <em>logging</em>, monitoramento e alerta. No entanto, o Kubernetes não é monolítico, e essas soluções padrão são opcionais e conectáveis. O Kubernetes fornece os blocos de construção para a construção de plataformas de desenvolvimento, mas preserva a escolha e flexibilidade do usuário onde é importante.</p><p>Kubernetes:</p><ul><li>Não limita os tipos de aplicações suportadas. O Kubernetes visa oferecer suporte a uma variedade extremamente diversa de cargas de trabalho, incluindo cargas de trabalho sem estado, com estado e de processamento de dados. Se uma aplicação puder ser executada em um contêiner, ele deve ser executado perfeitamente no Kubernetes.</li><li>Não implanta código-fonte e não constrói sua aplicação. Os fluxos de trabalho de integração contínua, entrega e implantação (CI/CD) são determinados pelas culturas e preferências da organização, bem como pelos requisitos técnicos.</li><li>Não fornece serviços em nível de aplicação, tais como middleware (por exemplo, barramentos de mensagem), estruturas de processamento de dados (por exemplo, Spark), bancos de dados (por exemplo, MySQL), caches, nem sistemas de armazenamento em cluster (por exemplo, Ceph), como serviços integrados. Esses componentes podem ser executados no Kubernetes e/ou podem ser acessados por aplicações executadas no Kubernetes por meio de mecanismos portáteis, como o <a href=https://openservicebrokerapi.org/>Open Service Broker</a>.</li><li>Não dita soluções de <em>logging</em>, monitoramento ou alerta. Ele fornece algumas integrações como prova de conceito e mecanismos para coletar e exportar métricas.</li><li>Não fornece nem exige um sistema/idioma de configuração (por exemplo, Jsonnet). Ele fornece uma API declarativa que pode ser direcionada por formas arbitrárias de especificações declarativas.</li><li>Não fornece nem adota sistemas abrangentes de configuração de máquinas, manutenção, gerenciamento ou autocorreção.</li><li>Adicionalmente, o Kubernetes não é um mero sistema de orquestração. Na verdade, ele elimina a necessidade de orquestração. A definição técnica de orquestração é a execução de um fluxo de trabalho definido: primeiro faça A, depois B e depois C. Em contraste, o Kubernetes compreende um conjunto de processos de controle independentes e combináveis que conduzem continuamente o estado atual em direção ao estado desejado fornecido. Não importa como você vai de A para C. O controle centralizado também não é necessário. Isso resulta em um sistema que é mais fácil de usar e mais poderoso, robusto, resiliente e extensível.</li></ul><h2 id=próximos-passos>Próximos passos</h2><ul><li>Dê uma olhada em <a href=/pt-br/docs/concepts/overview/components/>Componentes do Kubernetes</a>.</li><li>Pronto para <a href=/docs/setup/>Iniciar</a>?</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-13b0f1dbe89228e3d76d2ac231e245f1>3.1.2 - Componentes do Kubernetes</h1><div class=lead>Um cluster Kubernetes consiste de componentes que representam a camada de gerenciamento, e um conjunto de máquinas chamadas nós.</div><p>Ao implantar o Kubernetes, você obtém um cluster.<p><p>Um cluster Kubernetes consiste em um conjunto de servidores de processamento, chamados <a class=glossary-tooltip title='Um Nó é uma máquina de trabalho no Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/nodes/ target=_blank aria-label=nós>nós</a>, que executam aplicações containerizadas. Todo cluster possui ao menos um servidor de processamento (<em>worker node</em>).</p></p><p>O servidor de processamento hospeda os <a class=glossary-tooltip title='O menor e mais simples objeto Kubernetes. Um Pod representa um conjunto de contêineres em execução no seu cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/ target=_blank aria-label=Pods>Pods</a> que são componentes de uma aplicação. O <a class=glossary-tooltip title='A camada de gerenciamento de contêiner que expõe a API e as interfaces para definir, implantar e gerenciar o ciclo de vida dos contêineres.' data-toggle=tooltip data-placement=top href='/pt-br/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='ambiente de gerenciamento'>ambiente de gerenciamento</a> gerencia os nós de processamento e os Pods no cluster. Em ambientes de produção, o ambiente de gerenciamento geralmente executa em múltiplos computadores e um cluster geralmente executa em múltiplos nós (<em>nodes</em>) , provendo tolerância a falhas e alta disponibilidade.</p></p><p>Este documento descreve os vários componentes que você precisa ter para implantar um cluster Kubernetes completo e funcional.</p><p>Esse é o diagrama de um cluster Kubernetes com todos os componentes interligados.</p><p><img src=/images/docs/components-of-kubernetes.svg alt="Componentes do Kubernetes"></p><h2 id=componentes-da-camada-de-gerenciamento>Componentes da camada de gerenciamento</h2><p>Os componentes da camada de gerenciamento tomam decisões globais sobre o cluster (por exemplo, agendamento de <em>pods</em>), bem como detectam e respondem aos eventos do cluster (por exemplo, iniciando um novo <em><a class=glossary-tooltip title='O menor e mais simples objeto Kubernetes. Um Pod representa um conjunto de contêineres em execução no seu cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/ target=_blank aria-label=pod>pod</a></em> quando o campo <code>replicas</code> de um <em>Deployment</em> não está atendido).</p><p>Os componentes da camada de gerenciamento podem ser executados em qualquer máquina do cluster. Contudo, para simplificar, os <em>scripts</em> de configuração normalmente iniciam todos os componentes da camada de gerenciamento na mesma máquina, e não executa contêineres de usuário nesta máquina. Veja <a href=/docs/admin/high-availability/>Construindo clusters de alta disponibilidade</a> para um exemplo de configuração de múltiplas VMs para camada de gerenciamento (<em>multi-main-VM</em>).</p><h3 id=kube-apiserver>kube-apiserver</h3><p>O servidor de API é um componente da <a class=glossary-tooltip title='A camada de gerenciamento de contêiner que expõe a API e as interfaces para definir, implantar e gerenciar o ciclo de vida dos contêineres.' data-toggle=tooltip data-placement=top href='/pt-br/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='Camada de gerenciamento'>Camada de gerenciamento</a> do Kubernetes que expõe a API do Kubernetes.
O servidor de API é o <em>front end</em> para a camada de gerenciamento do Kubernetes.</p><p>A principal implementação de um servidor de API do Kubernetes é <a href=/docs/reference/generated/kube-apiserver/>kube-apiserver</a>.
O kube-apiserver foi projetado para ser escalonado horizontalmente — ou seja, ele pode ser escalado com a implantação de mais instâncias.
Você pode executar várias instâncias do kube-apiserver e balancear (balanceamento de carga, etc) o tráfego entre essas instâncias.</p><h3 id=etcd>etcd</h3><p>Armazenamento do tipo Chave-Valor consistente e em alta-disponibilidade usado como repositório de apoio do Kubernetes para todos os dados do cluster.</p><p>Se o seu cluster Kubernetes usa <strong>etcd</strong> como seu armazenamento de apoio, certifique-se de ter um plano de <a href=/docs/tasks/administer-cluster/configure-upgrade-etcd/#backing-up-an-etcd-cluster>back up</a> para seus dados.</p><p>Você pode encontrar informações detalhadas sobre o etcd na seção oficial da <a href=https://etcd.io/docs/>documentação</a>.</p><h3 id=kube-scheduler>kube-scheduler</h3><p>Componente da camada de gerenciamento que observa os <em><a class=glossary-tooltip title='O menor e mais simples objeto Kubernetes. Um Pod representa um conjunto de contêineres em execução no seu cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/ target=_blank aria-label=pods>pods</a></em> recém-criados sem nenhum <a class=glossary-tooltip title='Um Nó é uma máquina de trabalho no Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/nodes/ target=_blank aria-label=nó>nó</a> atribuído, e seleciona um nó para executá-los.</p><p>Os fatores levados em consideração para as decisões de agendamento incluem:
requisitos de recursos individuais e coletivos, hardware/software/política de restrições, especificações de afinidade e antiafinidade, localidade de dados, interferência entre cargas de trabalho, e prazos.</p><h3 id=kube-controller-manager>kube-controller-manager</h3><p>Componente da camada de gerenciamento que executa os processos de <a class=glossary-tooltip title='Um ciclo de controle que observa o estado partilhado do cluster através do API Server e efetua mudanças tentando mover o estado atual em direção ao estado desejado.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=controlador>controlador</a>.</p><p>Logicamente, cada <em><a class=glossary-tooltip title='Um ciclo de controle que observa o estado partilhado do cluster através do API Server e efetua mudanças tentando mover o estado atual em direção ao estado desejado.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=controlador>controlador</a></em> está em um processo separado, mas para reduzir a complexidade, eles todos são compilados num único binário e executam em um processo único.</p><p>Alguns tipos desses controladores são:</p><ul><li>Controlador de nó: responsável por perceber e responder quando os nós caem.</li><li>Controlador de <em>Job</em>: Observa os objetos <em>Job</em> que representam tarefas únicas e, em seguida, cria <em>pods</em> para executar essas tarefas até a conclusão.</li><li>Controlador de <em>endpoints</em>: preenche o objeto <em>Endpoints</em> (ou seja, junta os Serviços e os <em>pods</em>).</li><li>Controladores de conta de serviço e de <em>token</em>: crie contas padrão e <em>tokens</em> de acesso de API para novos <em>namespaces</em>.</li></ul><h3 id=cloud-controller-manager>cloud-controller-manager</h3>Um componente da <a class=glossary-tooltip title='A camada de gerenciamento de contêiner que expõe a API e as interfaces para definir, implantar e gerenciar o ciclo de vida dos contêineres.' data-toggle=tooltip data-placement=top href='/pt-br/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='camada de gerenciamento'>camada de gerenciamento</a> do Kubernetes
que incorpora a lógica de controle específica da nuvem. O gerenciador de controle de nuvem permite que você vincule seu
<em>cluster</em> na API do seu provedor de nuvem, e separar os componentes que interagem com essa plataforma de nuvem a partir de componentes que apenas interagem com seu cluster.<p>O cloud-controller-manager executa apenas controladores que são específicos para seu provedor de nuvem.
Se você estiver executando o Kubernetes em suas próprias instalações ou em um ambiente de aprendizagem dentro de seu
próprio PC, o cluster não possui um gerenciador de controlador de nuvem.</p><p>Tal como acontece com o kube-controller-manager, o cloud-controller-manager combina vários ciclos de controle logicamente independentes em um binário único que você executa como um processo único. Você pode escalar horizontalmente (executar mais de uma cópia) para melhorar o desempenho ou para auxiliar na tolerância a falhas.</p><p>Os seguintes controladores podem ter dependências de provedor de nuvem:</p><ul><li>Controlador de nó: para verificar junto ao provedor de nuvem para determinar se um nó foi excluído da nuvem após parar de responder.</li><li>Controlador de rota: para configurar rotas na infraestrutura de nuvem subjacente.</li><li>Controlador de serviço: Para criar, atualizar e excluir balanceadores de carga do provedor de nuvem.</li></ul><h2 id=node-components>Node Components</h2><p>Os componentes de nó são executados em todos os nós, mantendo os <em>pods</em> em execução e fornecendo o ambiente de execução do Kubernetes.</p><h3 id=kubelet>kubelet</h3><p>Um agente que é executado em cada <a class=glossary-tooltip title='Um Nó é uma máquina de trabalho no Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/nodes/ target=_blank aria-label=node>node</a> no cluster. Ele garante que os <a class=glossary-tooltip title='Uma imagem executável leve e portável que contém software e todas as suas dependências.' data-toggle=tooltip data-placement=top href=/docs/concepts/containers/ target=_blank aria-label=contêineres>contêineres</a> estejam sendo executados em um <a class=glossary-tooltip title='O menor e mais simples objeto Kubernetes. Um Pod representa um conjunto de contêineres em execução no seu cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/ target=_blank aria-label=Pod>Pod</a>.</p><p>O kubelet utiliza um conjunto de PodSpecs que são fornecidos por vários mecanismos e garante que os contêineres descritos nesses PodSpecs estejam funcionando corretamente. O kubelet não gerencia contêineres que não foram criados pelo Kubernetes.</p><h3 id=kube-proxy>kube-proxy</h3><p>kube-proxy é um <em>proxy</em> de rede executado em cada <a class=glossary-tooltip title='Um Nó é uma máquina de trabalho no Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/nodes/ target=_blank aria-label=nó>nó</a> no seu <em>cluster</em>,
implementando parte do conceito de <a class=glossary-tooltip title='Uma forma abstrata de expor uma aplicação que está executando em um conjunto de Pods como um serviço de rede.' data-toggle=tooltip data-placement=top href=/docs/concepts/services-networking/service/ target=_blank aria-label=serviço>serviço</a> do Kubernetes.</p><p><a href=/docs/reference/command-line-tools-reference/kube-proxy/>kube-proxy</a>
mantém regras de rede nos nós. Estas regras de rede permitem a comunicação de rede com seus <em>pods</em> a partir de sessões de rede dentro ou fora de seu <em>cluster</em>.</p><p>kube-proxy usa a camada de filtragem de pacotes do sistema operacional se houver uma e estiver disponível. Caso contrário, o kube-proxy encaminha o tráfego ele mesmo.</p><h3 id=container-runtime>Container runtime</h3><p>O agente de execução (<em>runtime</em>) de contêiner é o software responsável por executar os contêineres.</p><p>O Kubernetes suporta diversos agentes de execução de contêineres: <a class=glossary-tooltip title='Docker é uma tecnologia utilizada para prover virtualização a nível do sistema operacional também conhecidoa como containers.' data-toggle=tooltip data-placement=top href=https://docs.docker.com/engine/ target=_blank aria-label=Docker>Docker</a>, <a class=glossary-tooltip title='Um agente de execução de contêiner com enfase em simplicidade, robustez e portabilidade' data-toggle=tooltip data-placement=top href=https://containerd.io/docs/ target=_blank aria-label=containerd>containerd</a>, <a class=glossary-tooltip title='Um agente de execução leve de contêineres criado especificamente para o Kubernetes' data-toggle=tooltip data-placement=top href=https://cri-o.io/#what-is-cri-o target=_blank aria-label=CRI-O>CRI-O</a>, e qualquer implementação do <a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-node/container-runtime-interface.md>Kubernetes CRI (Container Runtime Interface)</a>.</p><h2 id=addons>Addons</h2><p>Complementos (<em>addons</em>) usam recursos do Kubernetes (<a class=glossary-tooltip title='Ensures a copy of a Pod is running across a set of nodes in a cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/daemonset target=_blank aria-label=DaemonSet>DaemonSet</a>, <a class=glossary-tooltip title='Manages a replicated application on your cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Deployment>Deployment</a>, etc) para implementar funcionalidades do cluster. Como fornecem funcionalidades em nível do cluster, recursos de <em>addons</em> que necessitem ser criados dentro de um <em>namespace</em> pertencem ao <em>namespace</em> <code>kube-system</code>.</p><p>Alguns <em>addons</em> selecionados são descritos abaixo; para uma lista estendida dos <em>addons</em> disponíveis, por favor consulte <a href=/docs/concepts/cluster-administration/addons/>Addons</a>.</p><h3 id=dns>DNS</h3><p>Embora os outros complementos não sejam estritamente necessários, todos os clusters do Kubernetes devem ter um <a href=/docs/concepts/services-networking/dns-pod-service/>DNS do cluster</a>, já que muitos exemplos dependem disso.</p><p>O DNS do cluster é um servidor DNS, além de outros servidores DNS em seu ambiente, que fornece registros DNS para serviços do Kubernetes.</p><p>Os contêineres iniciados pelo Kubernetes incluem automaticamente esse servidor DNS em suas pesquisas DNS.</p><h3 id=web-ui-dashboard>Web UI (Dashboard)</h3><p><a href=/docs/tasks/access-application-cluster/web-ui-dashboard/>Dashboard</a> é uma interface de usuário Web, de uso geral, para clusters do Kubernetes. Ele permite que os usuários gerenciem e solucionem problemas de aplicações em execução no cluster, bem como o próprio cluster.</p><h3 id=monitoramento-de-recursos-do-contêiner>Monitoramento de recursos do contêiner</h3><p><a href=/docs/tasks/debug-application-cluster/resource-usage-monitoring/>Monitoramento de recursos do contêiner</a> registra métricas de série temporal genéricas sobre os contêineres em um banco de dados central e fornece uma interface de usuário para navegar por esses dados.</p><h3 id=logging-a-nivel-do-cluster>Logging a nivel do cluster</h3><p>Um mecanismo de <a href=/docs/concepts/cluster-administration/logging/><em>logging</em> a nível do cluster</a> é responsável por guardar os <em>logs</em> dos contêineres em um armazenamento central de <em>logs</em> com um interface para navegação/pesquisa.</p><h2 id=próximos-passos>Próximos passos</h2><ul><li>Aprenda sobre <a href=/docs/concepts/architecture/nodes/>Nós</a>.</li><li>Aprenda sobre <a href=/docs/concepts/architecture/controller/>Controladores</a>.</li><li>Aprenda sobre <a href=/docs/concepts/scheduling-eviction/kube-scheduler/>kube-scheduler</a>.</li><li>Leia a <a href=https://etcd.io/docs/>documentação</a> oficial do <strong>etcd</strong>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-110f33530cf761140cb1dab536baef04>3.1.3 - Objetos do Kubernetes</h1></div><div class=td-content><h1 id=pg-9f5adfa77f48c50d5cc81155a3cecb98>3.1.3.1 - Entendendo os objetos do Kubernetes</h1><p>Esta página explica como os objetos do Kubernetes são representados na API do Kubernetes e como você pode expressá-los no formato <code>.yaml</code>.</p><h2 id=kubernetes-objects>Entendendo os objetos do Kubernetes</h2><p><em>Os objetos do Kubernetes</em> são entidades persistentes no Kubernetes. Kubernetes utiliza estas entidades para representar o estado do cluster. Especificamente, eles podem descrever:</p><ul><li>Quais aplicativos estão sendo executados (e em quais nós).</li><li>Os recursos disponíveis para esses aplicativos</li><li>As políticas acerca de como esses aplicativos se comportam, como políticas de reinicialização e tolerâncias a falhas.</li></ul><p>Um objeto do Kubernetes é um “registro de intenção”-uma vez criado o objeto, o sistema do Kubernetes trabalha constantemente para garantir que este objeto existe. Ao criar um objeto, você está efetivamente falando para o sistema do Kubernetes como você quer que a carga do seu cluster seja. Este é o <em>estado desejado</em> do seu cluster.</p><p>Para trabalhar com objetos do Kubernetes seja para criar, modificar ou deletar eles, você precisará usar a <a href=/docs/concepts/overview/kubernetes-api/>API do Kubernetes</a>. Quando você usa a interface de linha de comando do <code>kubectl</code>, por exemplo, o CLI faz as chamadas necessárias na API do Kubernetes para você. Você também pode usar a API do Kubernetes diretamente no seu próprio programa usando uma das <a href=/docs/reference/using-api/client-libraries/>Bibliotecas</a>.</p><h3 id=especificação-e-status-do-objeto>Especificação e status do objeto</h3><p>Quase todos os objetos do Kubernetes incluem dois campos de objetos aninhados que governam a configuração do objeto: a <em><code>especificação</code></em> do objeto e o <em><code>status</code></em> do objeto. Para objetos que têm especificação, você tem que definir isso quando você cria o objeto, fornecendo uma descrição das características que você quer que o recurso tenha: o seu <em>estado desejado</em>.</p><p>O <code>status</code> descreve o <em>estado atual</em> do objeto, fornecido e atualizado pelo Kubernetes e seus componentes. A <a class=glossary-tooltip title='A camada de gerenciamento de contêiner que expõe a API e as interfaces para definir, implantar e gerenciar o ciclo de vida dos contêineres.' data-toggle=tooltip data-placement=top href='/pt-br/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='camada de gerenciamento'>camada de gerenciamento</a> do Kubernetes gerêncai continuamente e ativamente o real estado para corresponder ao estado desejado que você forneceu.</p><p>Por exemplo, no Kubernetes, o <a class=glossary-tooltip title='Manages a replicated application on your cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Deployment>Deployment</a> é um objeto que pode representar uma aplicação executando no seu cluster. Quando você cria o Deployment, você pode alterar a <code>especificação</code>para definir que você quer três réplicas da aplicação em execução simultânea. O Kubernetes lê as especificações do Deployment e inicia três instâncias do seu aplicativo desejado, atualizando o status para corresponder às suas especificações. Se uma dessas instâncias falhar (um status mudar), o Kubernetes responde as diferenças entre as especificações e o status fazendo uma correção-neste caso, iniciando uma instância de substituição.</p><p>Para mais informações sobre especificações do objeto, status e metadados, veja <a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md>Kubernetes API Conventions</a>.</p><h3 id=descrevendo-um-objeto-kubernetes>Descrevendo um objeto Kubernetes</h3><p>Quando se cria um objeto do Kubernetes, deve-se fornecer a especificação do objeto que descreve seu estado desejado, bem como algumas informações básicas sobre o objeto (como um nome, por exemplo). Quando utiliza a API Kubernetes para criar o objeto (diretamente ou via <code>kubectl</code>), essa solicitação de API deve incluir essa informação como JSON no corpo da solicitação. <strong>Na maioria das vezes, você fornece as informações ao comando <code>kubectl</code> em um arquivo .yaml</strong>. O comando<code>kubectl</code> converte a informação para JSON ao fazer a requisição para a API.</p><p>Aqui está um exemplo de arquivo <code>.yaml</code> que mostra os campos necessários e as especificações de objeto para uma implatação Kubernetes:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/pt-br/examples/application/deployment.yaml download=application/deployment.yaml><code>application/deployment.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("application-deployment-yaml")' title="Copy application/deployment.yaml to clipboard"></img></div><div class=includecode id=application-deployment-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># diz ao deployment para executar 2 pods que correspondam ao modelo</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Uma maneira de criar um Deployment usando um arquivo <code>.yaml</code> como o representado acima é usar o comando <a href=/docs/reference/generated/kubectl/kubectl-commands#apply><code>kubectl apply</code></a> na interface de linha de comando <code>kubectl</code>, passando o arquivo <code>.yaml</code> como argumento. Aqui está um exemplo:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/application/deployment.yaml
</span></span></code></pre></div><p>A saída será similar a esta:</p><pre tabindex=0><code>deployment.apps/nginx-deployment created
</code></pre><h3 id=campos-obrigatórios>Campos obrigatórios</h3><p>No arquivo <code>.yaml</code> para o objeto Kubernetes que pretende criar, você precisará definir valores para os seguintes campos:</p><ul><li><code>apiVersion</code> - Qual a versão de API do objeto que será usado no Kubernetes para criar esse objeto.</li><li><code>kind</code> - Qual tipo de objeto pretende criar.</li><li><code>metadata</code> - Dados que ajudam a identificar de forma única o objeto, incluindo uma string <code>nome</code>, <code>UID</code> e um <code>namespace</code>.</li><li><code>spec</code> - Que estado deseja para o objeto.</li></ul><p>O formato preciso do objeto <code>spec</code> é diferente para cada objeto Kubernetes, e contém campos aninhados específicos para aquele objeto. A documentação de <a href=/docs/reference/kubernetes-api/>referência da API do Kubernetes</a> pode ajudar a encontrar o formato de especificação para todos os objetos que você pode criar usando Kubernetes.</p><p>Por exemplo, veja o campo de <a href=/docs/reference/kubernetes-api/workload-resources/pod-v1/#PodSpec><code>spec</code> field</a> para a referência Pod API.
Para cada Pod, o campo <code>.spec</code> especifica o pod e seu estado desejado (como o nome da imagem do contêiner para cada recipiente dentro daquela cápsula).
Outro exemplo de especificação de um objeto é o
<a href=/docs/reference/kubernetes-api/workload-resources/stateful-set-v1/#StatefulSetSpec>campo <code>spec</code> </a>.
Para o StatefulSet, o campo <code>.spec</code> especifica o StatefulSet e seu estado desejado.
Dentro do <code>.spec</code> de um StatefulSet está um <a href=/docs/concepts/workloads/pods/#pod-templates>template</a>
para objetos de Pod. Esse modelo descreve os Pods que o controlador StatefulSet criará para
satisfazer a especificação do StatefulSet. Diferentes tipos de objetos também podem ter diferentes
<code>.status</code>; novamente, as páginas de referência API detalham a estrutura daquele campo <code>.status</code>,
e seu conteúdo para cada tipo diferente de objeto.</p><h2 id=próximos-passos>Próximos passos</h2><p>Aprenda sobre os mais importantes objetos básicos Kubernetes, como o <a href=/docs/concepts/workloads/pods>Pod</a>.
Aprenda sobre as <a href=/docs/concepts/architecture/controller/>controladoras</a> do Kubernetes.
<a href=/docs/reference/using-api>Usando a API Kubernetes</a> explica mais alguns conceitos da API.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-f37749a83c2916b63279ea60f3cfe53e>3.1.3.2 - Nomes de objetos e IDs</h1><p>Cada objeto em seu cluster possui um <a href=#names><em>Nome</em></a> que é único para aquele
tipo de recurso.
Todo objeto do Kubernetes também possui um <a href=#uids><em>UID</em></a> que é único para todo
o cluster.</p><p>Por exemplo, você pode ter apenas um Pod chamado <code>myapp-1234</code> dentro de um
<a href=/pt-br/docs/concepts/overview/working-with-objects/namespaces/>namespace</a>, porém
você pode ter um Pod e um Deployment ambos com o nome <code>myapp-1234</code>.</p><p>Para atributos não-únicos definidos pelo usuário, o Kubernetes fornece
<a href=/docs/concepts/overview/working-with-objects/labels/>labels</a> e
<a href=/docs/concepts/overview/working-with-objects/annotations/>annotations</a>.</p><h2 id=names>Nomes</h2><p>Uma string fornecida pelo cliente que referencia um objeto em uma URL de
recurso, como por exemplo <code>/api/v1/pods/qualquer-nome</code>.</p><p>Somente um objeto de um dado tipo pode ter um certo nome por vez. No entanto,
se você remover o objeto, você poderá criar um novo objeto com o mesmo nome.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Em casos em que objetos representam uma entidade física, como no caso de um Nó
representando um host físico, caso o host seja recriado com o mesmo nome mas o
objeto Nó não seja recriado, o Kubernetes trata o novo host como o host antigo,
o que pode causar inconsistências.</div><p>Abaixo estão descritos quatro tipos de restrições de nomes comumente utilizadas
para recursos.</p><h3 id=dns-subdomain-names>Nomes de subdomínio DNS</h3><p>A maior parte dos recursos do Kubernetes requerem um nome que possa ser
utilizado como um nome de subdomínio DNS, conforme definido na
<a href=https://tools.ietf.org/html/rfc1123>RFC 1123</a>.
Isso significa que o nome deve:</p><ul><li>conter no máximo 253 caracteres</li><li>conter somente caracteres alfanuméricos em caixa baixa, traço ('-') ou ponto
('.').</li><li>iniciar com um caractere alfanumérico</li><li>terminar com um caractere alfanumérico</li></ul><h3 id=dns-label-names>Nomes de rótulos da RFC 1123</h3><p>Alguns tipos de recurso requerem que seus nomes sigam o padrão de rótulos DNS
definido na <a href=https://tools.ietf.org/html/rfc1123>RFC 1123</a>.
Isso significa que o nome deve:</p><ul><li>conter no máximo 63 caracteres</li><li>conter somente caracteres alfanuméricos em caixa baixa ou traço ('-')</li><li>iniciar com um caractere alfanumérico</li><li>terminar com um caractere alfanumérico</li></ul><h3 id=nomes-de-rótulo-da-rfc-1035>Nomes de rótulo da RFC 1035</h3><p>Alguns tipos de recurso requerem que seus nomes sigam o padrão de rótulos DNS
definido na <a href=https://tools.ietf.org/html/rfc1035>RFC 1035</a>.
Isso significa que o nome deve:</p><ul><li>conter no máximo 63 caracteres</li><li>conter somente caracteres alfanuméricos em caixa baixa ou traço ('-')</li><li>iniciar com um caractere alfanumérico</li><li>terminar com um caractere alfanumérico</li></ul><h3 id=nomes-de-segmentos-de-caminhos>Nomes de segmentos de caminhos</h3><p>Alguns tipos de recurso requerem que seus nomes possam ser seguramente
codificados como um segmento de caminho, ou seja, o nome não pode ser "." ou
".." e não pode conter "/" ou "%".</p><p>Exemplo de um manifesto para um Pod chamado <code>nginx-demo</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.7.9<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Alguns tipos de recursos possuem restrições adicionais em seus nomes.</div><h2 id=uids>UIDs</h2><p>Uma string gerada pelos sistemas do Kubernetes para identificar objetos de
forma única.</p><p>Cada objeto criado durante todo o ciclo de vida do cluster do Kubernetes possui
um UID distinto. O objetivo deste identificador é distinguir ocorrências
históricas de entidades semelhantes.</p><p>UIDs no Kubernetes são identificadores únicos universais (também conhecidos como
UUIDs).
UUIDs seguem os padrões ISO/IEC 9834-8 e ITU-T X.667.</p><h2 id=próximos-passos>Próximos passos</h2><ul><li>Leia sobre <a href=/docs/concepts/overview/working-with-objects/labels/>labels</a> no Kubernetes.</li><li>Consulte o documento de design <a href=https://git.k8s.io/design-proposals-archive/architecture/identifiers.md>Identifiers and Names in Kubernetes</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-1127165f472b7181b9c1d5a0b187d620>3.1.3.3 - Namespaces</h1><p>No Kubernetes, <em>namespaces</em> disponibilizam um mecanismo para isolar grupos de recursos dentro de um único cluster. Nomes de recursos precisam ser únicos dentro de um namespace, porém podem se repetir em diferentes namespaces. Escopos baseados em namespaces são aplicáveis apenas para objetos com namespace <em>(como: Deployments, Services, etc)</em> e não em objetos que abrangem todo o cluster <em>(como: StorageClass, Nodes, PersistentVolumes, etc)</em>.</p><h2 id=quando-utilizar-múltiplos-namespaces>Quando Utilizar Múltiplos Namespaces</h2><p>Namespaces devem ser utilizados em ambientes com múltiplos usuários espalhados por diversos times ou projetos. Para clusters com poucos ou até algumas dezenas de usuários, você não deveria precisar criar ou pensar a respeito de namespaces. Comece a utilizar namespaces quando você precisar das funcionalidades que eles oferecem.</p><p>Namespaces oferecem escopo para nomes. Nomes de recursos precisam ser únicos dentro de um namespace, porém não em diferentes namespaces. Namespaces não podem ser aninhados dentro de outros namespaces e cada recurso Kubernetes pode pertencer à apenas um namespace.</p><p>Namespaces nos permitem dividir os recursos do cluster entre diferentes usuários (via <a href=/docs/concepts/policy/resource-quotas/>resource quota</a>).</p><p>Não é necessário utilizar múltiplos namespaces para separar recursos levemente diferentes, como diferentes versões de um mesmo software: use <a class=glossary-tooltip title='Tags objects with identifying attributes that are meaningful and relevant to users.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/labels target=_blank aria-label=labels>labels</a> para distinguir recursos dentro de um mesmo namespace.</p><h2 id=trabalhando-com-namespaces>Trabalhando com Namespaces</h2><p>Criação e eliminação de namespaces estão descritas na
<a href=/docs/tasks/administer-cluster/namespaces>documentação de namespaces do guia de administradores</a>.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Evite criar namespaces com o prefixo <code>kube-</code>, já que este prefixo é reservado para namespaces do sistema Kubernetes.</div><h3 id=visualizando-namespaces>Visualizando namespaces</h3><p>Você pode obter uma lista dos namespaces atuais dentro de um cluster com:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get namespace
</span></span></code></pre></div><pre tabindex=0><code>NAME              STATUS   AGE
default           Active   1d
kube-node-lease   Active   1d
kube-public       Active   1d
kube-system       Active   1d
</code></pre><p>O Kubernetes é inicializado com quatro namespaces:</p><ul><li><code>default</code> O namespace padrão para objetos sem namespace</li><li><code>kube-system</code> O namespace para objetos criados pelo sistema Kubernetes</li><li><code>kube-public</code> Este namespace é criado automaticamente e é legível por todos os usuários (incluindo usuários não autenticados). Este namespace é reservado principalmente para uso do cluster, no caso de alguns recursos que precisem ser visíveis e legíveis publicamente por todo o cluster. O aspecto público deste namespace é apenas uma convenção, não um requisito.</li><li><code>kube-node-lease</code> Este namespace contém os objetos de <a href=/docs/reference/kubernetes-api/cluster-resources/lease-v1/>Lease</a> associados com cada node. Node leases permitem que o kubelet envie <a href=/docs/concepts/architecture/nodes/#heartbeats>heartbeats</a> para que a camada de gerenciamento detecte falhas nos nodes.</li></ul><h3 id=preparando-o-namespace-para-uma-requisição>Preparando o namespace para uma requisição</h3><p>Para preparar o namespace para a requisição atual, utilize o parâmetro <code>--namespace</code>. Por exemplo:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl run nginx --image<span style=color:#666>=</span>nginx --namespace<span style=color:#666>=</span>&lt;insert-namespace-name-here&gt;
</span></span><span style=display:flex><span>kubectl get pods --namespace<span style=color:#666>=</span>&lt;insert-namespace-name-here&gt;
</span></span></code></pre></div><h3 id=configurando-a-preferência-de-namespaces>Configurando a preferência de namespaces</h3><p>Você pode salvar permanentemente o namespace para todos os comandos <code>kubectl</code> subsequentes no mesmo contexto:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config set-context --current --namespace<span style=color:#666>=</span>&lt;insert-namespace-name-here&gt;
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Validando</span>
</span></span><span style=display:flex><span>kubectl config view --minify | grep namespace:
</span></span></code></pre></div><h2 id=namespaces-e-dns>Namespaces e DNS</h2><p>Quando você cria um <a href=/docs/concepts/services-networking/service/>Serviço</a>, ele cria uma
<a href=/docs/concepts/services-networking/dns-pod-service/>entrada DNS</a> correspondente.
Esta entrada possui o formato: <code>&lt;service-name>.&lt;namespace-name>.svc.cluster.local</code>, de forma que se um contêiner utilizar apenas <code>&lt;service-name></code> ele será resolvido para um serviço que é local ao namespace.
Isso é útil para utilizar a mesma configuração em vários namespaces, por exemplo em Desenvolvimento, <code>Staging</code> e Produção. Se você quiser acessar múltiplos namespaces, precisará utilizar um <em>Fully Qualified Domain Name</em> (FQDN).</p><h2 id=nem-todos-os-objetos-pertencem-a-algum-namespace>Nem todos os objetos pertencem a algum Namespace</h2><p>A maior parte dos recursos Kubernetes (como Pods, Services, controladores de replicação e outros) pertencem a algum namespace. Entretanto, recursos de namespaces não pertencem a nenhum namespace. Além deles, recursos de baixo nível, como <a href=/docs/concepts/architecture/nodes/>nodes</a> e persistentVolumes, também não pertencem a nenhum namespace.</p><p>Para visualizar quais recursos Kubernetes pertencem ou não a algum namespace, utilize:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Em um namespace</span>
</span></span><span style=display:flex><span>kubectl api-resources --namespaced<span style=color:#666>=</span><span style=color:#a2f>true</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Sem namespace</span>
</span></span><span style=display:flex><span>kubectl api-resources --namespaced<span style=color:#666>=</span><span style=color:#a2f>false</span>
</span></span></code></pre></div><h2 id=rotulamento-automático>Rotulamento Automático</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes 1.21 [beta]</code></div><p>A camada de gerenciamento Kubernetes configura um <a class=glossary-tooltip title='Tags objects with identifying attributes that are meaningful and relevant to users.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/labels target=_blank aria-label=label>label</a> imutável <code>kubernetes.io/metadata.name</code> em todos os namespaces se a
<a href=/docs/reference/command-line-tools-reference/feature-gates/>feature gate</a>
<code>NamespaceDefaultLabelName</code> estiver habilitada. O valor do label é o nome do namespace.</p><h2 id=próximos-passos>Próximos passos</h2><ul><li>Leia sobre <a href=/docs/tasks/administer-cluster/namespaces/#creating-a-new-namespace>a criação de um novo namespace</a>.</li><li>Leia sobre <a href=/docs/tasks/administer-cluster/namespaces/#deleting-a-namespace>a eliminação de um namespace</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-046c03090d47bc4b89b818dc645c3865>3.1.3.4 - Seletores de Campos</h1><p>Os <em>Seletores de Campos</em> permitem que você <a href=/docs/concepts/overview/working-with-objects/kubernetes-objects>selecione recursos do Kubernetes</a> baseado no valor de um ou mais campos de um recurso. Seguem alguns exemplos de buscas utilizando seletores de campos:</p><ul><li><code>metadata.name=my-service</code></li><li><code>metadata.namespace!=default</code></li><li><code>status.phase=Pending</code></li></ul><p>O comando <code>kubectl</code>, mostrado a seguir, seleciona todos os Pods nos quais o valor do campo <a href=/docs/concepts/workloads/pods/pod-lifecycle/#pod-phase><code>status.phase</code></a> é <code>Running</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods --field-selector status.phase<span style=color:#666>=</span>Running
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Seletores de campos são essencialmente <em>filtros</em> de recursos. Por padrão, nenhum seletor/filtro é aplicado, de forma que todos os recursos do tipo especificado são selecionados. Isso faz com que as seguintes pesquisas utilizando <code>kubectl</code> sejam equivalentes: <code>kubectl get pods</code> e <code>kubectl get pods --field-selector ""</code></div><h2 id=campos-suportados>Campos suportados</h2><p>Os campos de seleção suportados variam dependendo do tipo de recurso Kubernetes. Todos os tipos de recursos suportam os campos <code>metadata.name</code> e <code>metadata.namespace</code>. Utilizar campos não suportados produz um erro. Como por exemplo:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get ingress --field-selector foo.bar<span style=color:#666>=</span>baz
</span></span></code></pre></div><pre tabindex=0><code>Error from server (BadRequest): Unable to find &#34;ingresses&#34; that match label selector &#34;&#34;, field selector &#34;foo.bar=baz&#34;: &#34;foo.bar&#34; is not a known field selector: only &#34;metadata.name&#34;, &#34;metadata.namespace&#34;
</code></pre><h2 id=operadores-suportados>Operadores suportados</h2><p>Você pode utilizar os operadores <code>=</code>, <code>==</code> e <code>!=</code> com seletores de campos (<code>=</code> e <code>==</code> significam a mesma coisa). Por exemplo, o comando <code>kubectl</code> a seguir seleciona todos os Kubernetes Services que não estão no namespace <code>default</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get services  --all-namespaces --field-selector metadata.namespace!<span style=color:#666>=</span>default
</span></span></code></pre></div><h2 id=seletores-em-cadeia>Seletores em cadeia</h2><p>Assim como <a href=/docs/concepts/overview/working-with-objects/labels>label</a> e outros tipos de seletores, podem ser utilizados em cadeia através de uma lista separada por vírgula. O comando <code>kubectl</code> a seguir seleciona todos os Pods nos quais <code>status.phase</code> não é igual a <code>Running</code> e <code>spec.restartPolicy</code> é igual a <code>Always</code></p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods --field-selector<span style=color:#666>=</span>status.phase!<span style=color:#666>=</span>Running,spec.restartPolicy<span style=color:#666>=</span>Always
</span></span></code></pre></div><h2 id=múltiplos-tipos-de-recursos>Múltiplos tipos de recursos</h2><p>Você pode utilizar seletores de campos através de múltiplos tipos de recursos. Por exemplo, o comando <code>kubectl</code> a seguir seleciona todos Statefulsets e Services que não estão presentes no namespace <code>default</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get statefulsets,services --all-namespaces --field-selector metadata.namespace!<span style=color:#666>=</span>default
</span></span></code></pre></div></div><div class=td-content style=page-break-before:always><h1 id=pg-2bf36ccd6b3dbeafecf87c39761b07c7>3.2 - Arquitetura do Kubernetes</h1></div><div class=td-content><h1 id=pg-9ef2890698e773b6c0d24fd2c20146f5>3.2.1 - Nós</h1><p>O Kubernetes executa sua carga de trabalho colocando contêineres em Pods para serem executados em <em>Nós</em>. Um nó pode ser uma máquina virtual ou física, dependendo do cluster. Cada nó é gerenciado pela <a class=glossary-tooltip title='A camada de gerenciamento de contêiner que expõe a API e as interfaces para definir, implantar e gerenciar o ciclo de vida dos contêineres.' data-toggle=tooltip data-placement=top href='/pt-br/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='camada de gerenciamento'>camada de gerenciamento</a> e contém os serviços necessários para executar <a class=glossary-tooltip title='O menor e mais simples objeto Kubernetes. Um Pod representa um conjunto de contêineres em execução no seu cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/ target=_blank aria-label=Pods>Pods</a>.</p><p>Normalmente, você tem vários nós em um cluster; em um ambiente de aprendizado ou limitado por recursos, você pode ter apenas um nó.</p><p>Os <a href=/docs/concepts/overview/components/#node-components>componentes</a> em um nó incluem o <a class=glossary-tooltip title='Um agente que é executado em cada node no cluster. Ele garante que os contêineres estejam sendo executados em um pod.' data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kubelet target=_blank aria-label=kubelet>kubelet</a>, um <a class=glossary-tooltip title='O agente de execução de contêiner é o software responsável por executar os contêineres.' data-toggle=tooltip data-placement=top href=/docs/setup/production-environment/container-runtimes target=_blank aria-label='agente de execução de contêiner'>agente de execução de contêiner</a>, e o <a class=glossary-tooltip title='kube-proxy é um proxy de rede executado em cada nó do cluster.' data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-proxy/ target=_blank aria-label=kube-proxy>kube-proxy</a>.</p><h2 id=administração>Administração</h2><p>Existem duas maneiras principais de adicionar Nós ao <a class=glossary-tooltip title='O componente da camada de gerenciamento que serve a API do Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label='Servidor da API'>Servidor da API</a>:</p><ol><li>O kubelet em um nó se registra automaticamente na camada de gerenciamento</li><li>Você (ou outro usuário humano) adiciona manualmente um objeto Nó</li></ol><p>Depois de criar um <a class=glossary-tooltip title='A entity in the Kubernetes system, representing part of the state of your cluster.' data-toggle=tooltip data-placement=top href=https://kubernetes.io/docs/concepts/overview/working-with-objects/kubernetes-objects/#kubernetes-objects target=_blank aria-label=objeto>objeto</a> Nó, ou o kubelet em um nó se registra automaticamente, a camada de gerenciamento verifica se o novo objeto Nó é válido. Por exemplo, se você tentar criar um nó a partir do seguinte manifesto JSON:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;Node&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;v1&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;metadata&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;10.240.79.157&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;labels&#34;</span>: {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;my-first-k8s-node&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>O Kubernetes cria um objeto nó internamente (a representação). O Kubernetes verifica se um kubelet se registrou no servidor da API que corresponde ao campo <code>metadata.name</code> do Nó. Se o nó estiver íntegro (ou seja, todos os serviços necessários estiverem em execução), ele será elegível para executar um Pod. Caso contrário, esse nó é ignorado para qualquer atividade de cluster até que se torne íntegro.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong><p>O Kubernetes mantém o objeto nó inválido e continua verificando se ele se torna íntegro.</p><p>Você, ou um <a class=glossary-tooltip title='Um ciclo de controle que observa o estado partilhado do cluster através do API Server e efetua mudanças tentando mover o estado atual em direção ao estado desejado.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=controlador>controlador</a>, deve excluir explicitamente o objeto Nó para interromper essa verificação de integridade.</p></div><p>O nome de um objeto nó deve ser um nome de <a href=/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>subdomínio válido de DNS</a>.</p><h3 id=singularidade-de-nome-do-nó>Singularidade de nome do nó</h3><p>O <a href=/docs/concepts/overview/working-with-objects/names#names>nome</a> identifica um nó. Dois nós não podem ter o mesmo nome ao mesmo tempo. O Kubernetes também assume que um recurso com o mesmo nome é o mesmo objeto. No caso de um nó, assume-se implicitamente que uma instância usando o mesmo nome terá o mesmo estado (por exemplo, configurações de rede, conteúdo do disco raiz) e atributos como label de nó. Isso pode levar a inconsistências se uma instância for modificada sem alterar seu nome. Se o nó precisar ser substituído ou atualizado significativamente, o objeto Nó existente precisa ser removido do servidor da API primeiro e adicionado novamente após a atualização.</p><h3 id=auto-registro-de-nós>Auto-registro de Nós</h3><p>Quando a opção <code>--register-node</code> do kubelet for verdadeira (padrão), o kubelet tentará se registrar no servidor da API. Este é o padrão preferido, usado pela maioria das distribuições.</p><p>Para auto-registro, o kubelet é iniciado com as seguintes opções:</p><ul><li><code>--kubeconfig</code> - O caminho das credenciais para se autenticar no servidor da API.</li><li><code>--cloud-provider</code> - Como comunicar com um <a class=glossary-tooltip title='Uma organização que oferece uma plataforma de computação em nuvem.' data-toggle=tooltip data-placement=top href='/pt-br/docs/reference/glossary/?all=true#term-cloud-provider' target=_blank aria-label='provedor de nuvem'>provedor de nuvem</a>
para ler metadados sobre si mesmo.</li><li><code>--register-node</code> - Registrar automaticamente no servidor da API.</li><li><code>--register-with-taints</code> - Registra o nó com a lista fornecida de <a class=glossary-tooltip title='A core object consisting of three required properties: key, value, and effect. Taints prevent the scheduling of pods on nodes or node groups.' data-toggle=tooltip data-placement=top href=/docs/concepts/scheduling-eviction/taint-and-toleration/ target=_blank aria-label=taints>taints</a> (separadas por vírgula <code>&lt;key>=&lt;value>:&lt;effect></code>).</li></ul><p>Não funciona se o <code>register-node</code> for falso.</p><ul><li><code>--node-ip</code> - endereço IP do nó.</li><li><code>--node-labels</code> - <a class=glossary-tooltip title='Tags objects with identifying attributes that are meaningful and relevant to users.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/labels target=_blank aria-label=Labels>Labels</a> a serem adicionados ao registrar o nó
no cluster (consulte as restrições de label impostas pelo <a href=/docs/reference/access-authn-authz/admission-controllers/#noderestriction>plug-in de admissão NodeRestriction</a>).</li><li><code>--node-status-update-frequency</code> - Especifica com que frequência o kubelet publica o status do nó no servidor da API.</li></ul><p>Quando o <a href=/docs/reference/access-authn-authz/node/>modo de autorização do nó</a> e o <a href=/docs/reference/access-authn-authz/admission-controllers/#noderestriction>plug-in de admissão NodeRestriction</a> estão ativados, os kubelets somente estarão autorizados a criar/modificar seu próprio recurso do nó.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong><p>Como mencionado na seção de <a href=#singularidade-de-nome-do-no>singularidade do nome do nó</a>, quando a configuração do nó precisa ser atualizada, é uma boa prática registrar novamente o nó no servidor da API. Por exemplo, se o kubelet estiver sendo reiniciado com o novo conjunto de <code>--node-labels</code>, mas o mesmo nome de nó for usado, a alteração não entrará em vigor, pois os labels estão sendo definidos no registro do Nó.</p><p>Pods já agendados no Nó podem ter um comportamento anormal ou causar problemas se a configuração do Nó for alterada na reinicialização do kubelet. Por exemplo, o Pod já em execução pode estar marcado diferente dos labels atribuídos ao Nó, enquanto outros Pods, que são incompatíveis com esse Pod, serão agendados com base nesse novo label. O novo registro do nó garante que todos os Pods sejam drenados e devidamente reiniciados.</p></div><h3 id=administração-manual-de-nós>Administração manual de nós</h3><p>Você pode criar e modificar objetos Nó usando o <a class=glossary-tooltip title='Uma ferramenta de linha de comando para se comunicar com um cluster Kubernetes.' data-toggle=tooltip data-placement=top href=/pt-br/docs/user-guide/kubectl-overview/ target=_blank aria-label=kubectl>kubectl</a>.</p><p>Quando você quiser manualmente criar objetos Nó, defina a opção do kubelet <code>--register-node=false</code>.</p><p>Você pode modificar os objetos Nó, independentemente da configuração de <code>--register-node</code>. Por exemplo, você pode definir labels em um nó existente ou marcá-lo como não disponível.</p><p>Você pode usar labels nos Nós em conjunto com seletores de nós nos Pods para controlar a disponibilidade. Por exemplo, você pode restringir um Pod a ser elegível apenas para ser executado em um subconjunto dos nós disponíveis.</p><p>Marcar um nó como não disponível impede que o escalonador coloque novos pods nesse nó, mas não afeta os Pods existentes no nó. Isso é útil como uma etapa preparatória antes da reinicialização de um nó ou outra manutenção.</p><p>Para marcar um nó como não disponível, execute:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl cordon <span style=color:#b8860b>$NODENAME</span>
</span></span></code></pre></div><p>Consulte <a href=/docs/tasks/administer-cluster/safely-drain-node/>Drenar um nó com segurança</a> para obter mais detalhes.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Os Pods que fazem parte de um <a class=glossary-tooltip title='Ensures a copy of a Pod is running across a set of nodes in a cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/daemonset target=_blank aria-label=DaemonSet>DaemonSet</a> toleram ser executados em um nó não disponível. Os DaemonSets geralmente fornecem serviços locais de nós que devem ser executados em um Nó, mesmo que ele esteja sendo drenado de aplicativos de carga de trabalho.</div><h2 id=status-do-nó>Status do Nó</h2><p>O status de um nó contém as seguintes informações:</p><ul><li><a href=#addresses>Endereços</a></li><li><a href=#condition>Condições</a></li><li><a href=#capacity>Capacidade</a></li><li><a href=#info>Informação</a></li></ul><p>Você pode usar o <code>kubectl</code> para visualizar o status de um nó e outros detalhes:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe node &lt;insira-nome-do-nó-aqui&gt;
</span></span></code></pre></div><p>Cada seção da saída está descrita abaixo.</p><h3 id=endereços>Endereços</h3><p>O uso desses campos pode mudar dependendo do seu provedor de nuvem ou configuração dedicada.</p><ul><li>HostName: O nome do host relatado pelo <code>kernel</code> do nó. Pode ser substituído através do parâmetro kubelet <code>--hostname-override</code>.</li><li>ExternalIP: Geralmente, o endereço IP do nó que é roteável externamente (disponível fora do <code>cluster</code>).</li><li>InternalIP: Geralmente, o endereço IP do nó que é roteável somente dentro do <code>cluster</code>.</li></ul><h3 id=conditions>Condições</h3><p>O campo <code>conditions</code> descreve o status de todos os nós em execução. Exemplos de condições incluem:</p><table><caption style=display:none>Condições do nó e uma descrição de quando cada condição se aplica.</caption><thead><tr><th>Condições do nó</th><th>Descrição</th></tr></thead><tbody><tr><td><code>Ready</code></td><td><code>True</code> Se o nó estiver íntegro e pronto para aceitar pods, <code>False</code> se o nó não estiver íntegro e não estiver aceitando pods, e desconhecido <code>Unknown</code> se o controlador do nó tiver sem notícias do nó no último <code>node-monitor-grace-period</code> (o padrão é de 40 segundos)</td></tr><tr><td><code>DiskPressure</code></td><td><code>True</code> Se houver pressão sobre o tamanho do disco, ou seja, se a capacidade do disco for baixa; caso contrário <code>False</code></td></tr><tr><td><code>MemoryPressure</code></td><td><code>True</code> Se houver pressão na memória do nó, ou seja, se a memória do nó estiver baixa; caso contrário <code>False</code></td></tr><tr><td><code>PIDPressure</code></td><td><code>True</code> Se houver pressão sobre os processos, ou seja, se houver muitos processos no nó; caso contrário <code>False</code></td></tr><tr><td><code>NetworkUnavailable</code></td><td><code>True</code> Se a rede do nó não estiver configurada corretamente, caso contrário <code>False</code></td></tr></tbody></table><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Se você usar as ferramentas de linha de comando para mostrar os detalhes de um nó isolado, a <code>Condition</code> inclui <code>SchedulingDisabled</code>. <code>SchedulingDisabled</code> não é uma condição na API do Kubernetes; em vez disso, os nós isolados são marcados como <code>Unschedulable</code> em suas especificações.</div><p>Na API do Kubernetes, a condição de um nó é representada como parte do <code>.status</code> do recurso do nó. Por exemplo, a seguinte estrutura JSON descreve um nó íntegro:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#b44>&#34;conditions&#34;</span><span>:</span> [
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;Ready&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;status&#34;</span>: <span style=color:#b44>&#34;True&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;reason&#34;</span>: <span style=color:#b44>&#34;KubeletReady&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;message&#34;</span>: <span style=color:#b44>&#34;kubelet is posting ready status&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;lastHeartbeatTime&#34;</span>: <span style=color:#b44>&#34;2019-06-05T18:38:35Z&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;lastTransitionTime&#34;</span>: <span style=color:#b44>&#34;2019-06-05T11:41:27Z&#34;</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>]
</span></span></code></pre></div><p>Se o status da condição <code>Ready</code> permanecer desconhecido (<code>Unknown</code>) ou falso (<code>False</code>) por mais tempo do que o limite da remoção do pod (<code>pod-eviction-timeout</code>) (um argumento passado para o <a class=glossary-tooltip title='Componente da camada de gerenciamento que executa os processos de controle.' data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-controller-manager/ target=_blank aria-label=kube-controller-manager>kube-controller-manager</a>), o <a href=#node-controller>controlador de nó</a> acionará o <a class=glossary-tooltip title='API-initiated eviction is the process by which you use the Eviction API to create an Eviction object that triggers graceful pod termination.' data-toggle=tooltip data-placement=top href=/docs/concepts/scheduling-eviction/api-eviction/ target=_blank aria-label='remoção iniciado pela API'>remoção iniciado pela API</a> para todos os Pods atribuídos a esse nó. A duração padrão do tempo limite da remoção é de <strong>cinco minutos</strong>. Em alguns casos, quando o nó está inacessível, o servidor da API não consegue se comunicar com o kubelet no nó. A decisão de excluir os pods não pode ser comunicada ao kubelet até que a comunicação com o servidor da API seja restabelecida. Enquanto isso, os pods agendados para exclusão podem continuar a ser executados no nó particionado.</p><p>O controlador de nós não força a exclusão dos pods até que seja confirmado que eles pararam de ser executados no cluster. Você pode ver os pods que podem estar sendo executados em um nó inacessível como estando no estado de terminando (<code>Terminating</code>) ou desconhecido (<code>Unknown</code>). Nos casos em que o Kubernetes não retirar da infraestrutura subjacente se um nó tiver deixado permanentemente um cluster, o administrador do cluster pode precisar excluir o objeto do nó manualmente. Excluir o objeto do nó do Kubernetes faz com que todos os objetos Pod em execução no nó sejam excluídos do servidor da API e libera seus nomes.</p><p>Quando ocorrem problemas nos nós, a camada de gerenciamento do Kubernetes cria automaticamente <a href=/docs/concepts/scheduling-eviction/taint-and-toleration/><code>taints</code></a> que correspondem às condições que afetam o nó. O escalonador leva em consideração as <code>taints</code> do Nó ao atribuir um Pod a um Nó. Os Pods também podem ter <a class=glossary-tooltip title='A core object consisting of three required properties: key, value, and effect. Tolerations enable the scheduling of pods on nodes or node groups that have a matching taint.' data-toggle=tooltip data-placement=top href=/docs/concepts/scheduling-eviction/taint-and-toleration/ target=_blank aria-label=tolerations>tolerations</a> que os permitem funcionar em um nó, mesmo que tenha uma <code>taint</code> específica.</p><p>Consulte <a href=/pt-br/docs/concepts/scheduling-eviction/taint-and-toleration/#taints-por-condi%C3%A7%C3%B5es-de-n%C3%B3>Nó Taint por Condição</a>
para mais detalhes.</p><h3 id=capacity>Capacidade e Alocável</h3><p>Descreve os recursos disponíveis no nó: CPU, memória e o número máximo de pods que podem ser agendados no nó.</p><p>Os campos no bloco de capacidade indicam a quantidade total de recursos que um nó possui. O bloco alocado indica a quantidade de recursos em um nó que está disponível para ser consumido por Pods normais.</p><p>Você pode ler mais sobre capacidade e recursos alocados enquanto aprende a <a href=/docs/tasks/administer-cluster/reserve-compute-resources/#node-allocatable>reservar recursos de computação</a> em um nó.</p><h3 id=info>Info</h3><p>Descreve informações gerais sobre o nó, como a versão do kernel, a versão do Kubernetes (versão do kubelet e kube-proxy), detalhes do tempo de execução do contêiner e qual sistema operacional o nó usa. O kubelet coleta essas informações do nó e as publica na API do Kubernetes.</p><h2 id=heartbeats>Heartbeats</h2><p>Os <code>Heartbeats</code>, enviados pelos nós do Kubernetes, ajudam seu cluster a determinar a disponibilidade de cada nó e a agir quando as falhas forem detectadas.</p><p>Para nós, existem duas formas de <code>heartbeats</code>:</p><ul><li>atualizações para o <code>.status</code> de um Nó</li><li>Objetos <a href=/docs/reference/kubernetes-api/cluster-resources/lease-v1/>Lease</a> dentro do <a class=glossary-tooltip title='Uma abstração utilizada pelo Kubernetes para suportar múltiplos clusters virtuais no mesmo cluster físico.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/namespaces target=_blank aria-label=namespace>namespace</a> <code>kube-node-lease</code>. Cada nó tem um objeto de <code>Lease</code> associado.</li></ul><p>Em comparação com as atualizações no <code>.status</code> de um nó, um Lease é um recurso mais leve. O uso de Leases para <code>heartbeats</code> reduz o impacto no desempenho dessas atualizações para grandes clusters.</p><p>O kubelet é responsável por criar e atualizar o <code>.status</code> dos Nós e por atualizar suas Leases relacionadas.</p><ul><li>O kubelet atualiza o .status do nó quando há mudança de status ou se não houve atualização para um intervalo configurado. O intervalo padrão para atualizações .status para Nós é de 5 minutos, o que é muito maior do que o tempo limite padrão de 40 segundos para nós inacessíveis.</li><li>O kubelet cria e atualiza seu objeto <code>Lease</code> a cada 10 segundos (o intervalo de atualização padrão). As atualizações de Lease ocorrem independentemente das atualizações no <code>.status</code> do Nó. Se a atualização do <code>Lease</code> falhar, o kubelet voltará a tentativas, usando um recuo exponencial que começa em 200 milissegundos e limitado a 7 segundos.</li></ul><h2 id=controlador-de-nós>Controlador de Nós</h2><p>O <a class=glossary-tooltip title='Um ciclo de controle que observa o estado partilhado do cluster através do API Server e efetua mudanças tentando mover o estado atual em direção ao estado desejado.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=controlador>controlador</a> de nós é um componente da camada de gerenciamento do Kubernetes que gerencia vários aspectos dos nós.</p><p>O controlador de nó tem várias funções na vida útil de um nó. O primeiro é atribuir um bloco CIDR ao nó quando ele é registrado (se a atribuição CIDR estiver ativada).</p><p>O segundo é manter a lista interna de nós do controlador de nós atualizada com a lista de máquinas disponíveis do provedor de nuvem. Ao ser executado em um ambiente de nuvem e sempre que um nó não é íntegro, o controlador de nó pergunta ao provedor de nuvem se a VM desse nó ainda está disponível. Caso contrário, o controlador de nós exclui o nó de sua lista de nós.</p><p>O terceiro é monitorar a saúde dos nós. O controlador do nó é responsável por:</p><ul><li>No caso de um nó se tornar inacessível, atualizar a condição NodeReady dentro do campo <code>.status</code> do nó. Nesse caso, o controlador do nó define a condição de pronto (<code>NodeReady</code>) como condição desconhecida (<code>ConditionUnknown</code>).</li><li>Se um nó permanecer inacessível: será iniciado a <a href=/docs/concepts/scheduling-eviction/api-eviction/>remoção pela API</a> para todos os Pods no nó inacessível. Por padrão, o controlador do nó espera 5 minutos entre marcar o nó como condição desconhecida (<code>ConditionUnknown</code>) e enviar a primeira solicitação de remoção.</li></ul><p>O controlador de nó verifica o estado de cada nó a cada <code>--node-monitor-period</code> segundos.</p><h3 id=limites-de-taxa-de-remoção>Limites de taxa de remoção</h3><p>Na maioria dos casos, o controlador de nós limita a taxa de remoção a <code>--node-eviction-rate</code> (0,1 por padrão) por segundo, o que significa que ele não removerá pods de mais de 1 nó por 10 segundos.</p><p>O comportamento de remoção do nó muda quando um nó em uma determinada zona de disponibilidade se torna não íntegro. O controlador de nós verifica qual porcentagem de nós na zona não são íntegras (a condição <code>NodeReady</code> é desconhecida <code>ConditionUnknown</code> ou falsa <code>ConditionFalse</code>) ao mesmo tempo:</p><ul><li>Se a fração de nós não íntegros for ao menos <code>--unhealthy-zone-threshold</code> (padrão 0,55), então a taxa de remoção será reduzida.</li><li>Se o cluster for pequeno (ou seja, tiver número de nós menor ou igual ao valor da opção <code>--large-cluster-size-threshold</code> - padrão 50), então as remoções serão interrompidas.</li><li>Caso contrário, a taxa de remoção é reduzida para <code>--secondary-node-eviction-rate</code> de nós secundários (padrão 0,01) por segundo.</li></ul><p>A razão pela qual essas políticas são implementadas por zona de disponibilidade é porque a camada de gerenciamento pode perder conexão com uma zona de disponibilidade, enquanto as outras permanecem conectadas. Se o seu cluster não abranger várias zonas de disponibilidade de provedores de nuvem, o mecanismo de remoção não levará em conta a indisponibilidade por zona.</p><p>Uma das principais razões para espalhar seus nós pelas zonas de disponibilidade é para que a carga de trabalho possa ser transferida para zonas íntegras quando uma zona inteira cair. Portanto, se todos os nós em uma zona não estiverem íntegros, o controlador do nó removerá na taxa normal de <code>--node-eviction-rate</code>. O caso especial é quando todas as zonas estiverem completamente insalubres (nenhum dos nós do cluster será íntegro). Nesse caso, o controlador do nó assume que há algum problema com a conectividade entre a camada de gerenciamento e os nós e não realizará nenhuma remoção. (Se houver uma interrupção e alguns nós reaparecerem, o controlador do nó expulsará os pods dos nós restantes que estiverem insalubres ou inacessíveis).</p><p>O controlador de nós também é responsável por remover pods em execução nos nós com <code>NoExecute</code> taints, a menos que esses pods tolerem essa taint. O controlador de nó também adiciona as <a class=glossary-tooltip title='A core object consisting of three required properties: key, value, and effect. Taints prevent the scheduling of pods on nodes or node groups.' data-toggle=tooltip data-placement=top href=/docs/concepts/scheduling-eviction/taint-and-toleration/ target=_blank aria-label=taints>taints</a> correspondentes aos problemas de nó, como nó inacessível ou não pronto. Isso significa que o escalonador não colocará Pods em nós não íntegros.</p><h2 id=node-capacity>Rastreamento de capacidade de recursos</h2><p>Os objetos do nó rastreiam informações sobre a capacidade de recursos do nó: por exemplo, a quantidade de memória disponível e o número de CPUs. Os nós que se <a href=#self-registration-of-nodes>auto-registram</a> relatam sua capacidade durante o registro. Se você adicionar <a href=#manual-node-administration>manualmente</a> um nó, precisará definir as informações de capacidade do nó ao adicioná-lo.</p><p>O <a class=glossary-tooltip title='Componente da camada de gerenciamento que observa os pods recém-criados sem nenhum nó atribuído, e seleciona um nó para executá-los.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-scheduler/ target=_blank aria-label=escalonador>escalonador</a> do Kubernetes garante que haja recursos suficientes para todos os Pods em um nó. O escalonador verifica se a soma das solicitações de contêineres no nó não é maior do que a capacidade do nó. Essa soma de solicitações inclui todos os contêineres gerenciados pelo kubelet, mas exclui quaisquer contêineres iniciados diretamente pelo agente de execução de contêiner e também exclui quaisquer processos executados fora do controle do kubelet.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Se você quiser reservar explicitamente recursos para processos que não sejam do Pod, consulte <a href=/docs/tasks/administer-cluster/reserve-compute-resources/#system-reserved>reserva de recursos para daemons do sistema</a>.</div><h2 id=topologia-do-nó>Topologia do Nó</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.16 [alpha]</code></div><p>Se você ativou os [recursos]](/docs/reference/command-line-tools-reference/feature-gates/) de <code>TopologyManager</code>, o kubelet pode usar dicas da topologia ao tomar decisões de atribuição de recursos. Consulte <a href=/docs/tasks/administer-cluster/topology-manager/>Controle das Políticas de Gerenciamento de Topologia em um Nó</a> para obter mais informações.</p><h2 id=graceful-node-shutdown>Desligamento gracioso do nó</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.21 [beta]</code></div><p>O kubelet tenta detectar o desligamento do sistema do nó e encerra os pods em execução no nó.</p><p>O Kubelet garante que os pods sigam o processo normal de <a href=/docs/concepts/workloads/pods/>término do pod</a>pod-lifecycle/#pod-termination) durante o desligamento do nó.</p><p>O recurso de desligamento gradual do nó depende do systemd, pois aproveita os <a href=https://www.freedesktop.org/wiki/Software/systemd/inhibit/>bloqueios do inibidor do systemd</a> para atrasar o desligamento do nó com uma determinada duração.</p><p>O desligamento gradual do nó é controlado com <a href=/docs/reference/command-line-tools-reference/feature-gates/>recursos</a> <code>GracefulNodeShutdown</code>, que é ativado por padrão na versão 1.21.</p><p>Observe que, por padrão, ambas as opções de configuração descritas abaixo, <code>shutdownGracePeriod</code> and <code>shutdownGracePeriodCriticalPods</code> estão definidas como zero, não ativando assim a funcionalidade de desligamento gradual do nó. Para ativar o recurso, as duas configurações do kubelet devem ser configuradas adequadamente e definidas como valores diferentes de zero.</p><p>Durante um desligamento gradual, o kubelet encerra os pods em duas fases:</p><ol><li>Encerra os pods regulares em execução no nó.</li><li>Encerra os <a href=/docs/tasks/administer-cluster/guaranteed-scheduling-critical-addon-pods/#marking-pod-as-critical>pods críticos</a> em execução no nó.</li></ol><p>O recurso de desligamento gradual do nó é configurado com duas opções <a href=/docs/tasks/administer-cluster/kubelet-config-file/><code>KubeletConfiguration</code></a>:</p><ul><li><p><code>shutdownGracePeriod</code>:</p><ul><li>Especifica a duração total pela qual o nó deve atrasar o desligamento. Este é o período de carência total para o término dos pods regulares e os <a href=/docs/tasks/administer-cluster/guaranteed-scheduling-critical-addon-pods/#marking-pod-as-critical>críticos</a>.</li></ul></li><li><p><code>shutdownGracePeriodCriticalPods</code>:</p><ul><li>Especifica a duração utlizada para encerrar <a href=/docs/tasks/administer-cluster/guaranteed-scheduling-critical-addon-pods/#marking-pod-as-critical>pods críticos</a> durante um desligamento de nó. Este valor deve ser menor que <code>shutdownGracePeriod</code>.</li></ul></li></ul><p>Por exemplo, se <code>shutdownGracePeriod=30s</code> e <code>shutdownGracePeriodCriticalPods=10s</code>, o kubelet atrasará o desligamento do nó em 30 segundos. Durante o desligamento, os primeiros 20 (30-10) segundos seriam reservados para encerrar gradualmente os pods normais, e os últimos 10 segundos seriam reservados para encerrar <a href=/docs/tasks/administer-cluster/guaranteed-scheduling-critical-addon-pods/#marking-pod-as-critical>pods críticos</a>.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong><p>Quando os pods forem removidos durante o desligamento gradual do nó, eles serão marcados como desligados. Executar o <code>kubectl get pods</code> para mostrar o status dos pods removidos como <code>Terminated</code>. E o <code>kubectl describe pod</code> indica que o pod foi removido por causa do desligamento do nó:</p><pre tabindex=0><code>Reason:         Terminated
Message:        Pod was terminated in response to imminent node shutdown.
</code></pre></div><h3 id=pod-priority-graceful-node-shutdown>Desligamento gradual do nó baseado em prioridade do Pod</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.23 [alpha]</code></div><p>Para fornecer mais flexibilidade durante o desligamento gradual do nó em torno da ordem de pods durante o desligamento, o desligamento gradual do nó respeita a PriorityClass dos Pods, desde que você tenha ativado esse recurso em seu cluster. O recurso permite que o cluster defina explicitamente a ordem dos pods durante o desligamento gradual do nó com base em <a href=/docs/concepts/scheduling-eviction/pod-priority-preemption/#priorityclass>classes de prioridade</a>.</p><p>O recurso <a href=#graceful-node-shutdown>Desligamento Gradual do Nó</a>, conforme descrito acima, desliga pods em duas fases, pods não críticos, seguidos por pods críticos. Se for necessária flexibilidade adicional para definir explicitamente a ordem dos pods durante o desligamento de uma maneira mais granular, o desligamento gradual baseado na prioridade do pod pode ser usado.</p><p>Quando o desligamento gradual do nó respeita as prioridades do pod, isso torna possível fazer o desligamento gradual do nó em várias fases, cada fase encerrando uma classe de prioridade específica de pods. O kubelet pode ser configurado com as fases exatas e o tempo de desligamento por fase.</p><p>Assumindo as seguintes classes de prioridade de pod personalizadas em um cluster,</p><table><thead><tr><th>Nome das classes de prioridade</th><th>Valor das classes de prioridade</th></tr></thead><tbody><tr><td><code>custom-class-a</code></td><td>100000</td></tr><tr><td><code>custom-class-b</code></td><td>10000</td></tr><tr><td><code>custom-class-c</code></td><td>1000</td></tr><tr><td><code>regular/unset</code></td><td>0</td></tr></tbody></table><p>Na <a href=/docs/reference/config-api/kubelet-config.v1beta1/#kubelet-config-k8s-io-v1beta1-KubeletConfiguration>configuração do kubelet</a>, as configurações para <code>shutdownGracePeriodByPodPriority</code> são semelhantes a:</p><table><thead><tr><th>Valor das classes de prioridade</th><th>Tempo de desligamento</th></tr></thead><tbody><tr><td>100000</td><td>10 segundos</td></tr><tr><td>10000</td><td>180 segundos</td></tr><tr><td>1000</td><td>120 segundos</td></tr><tr><td>0</td><td>60 segundos</td></tr></tbody></table><p>A configuração correspondente do YAML do kubelet seria:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>shutdownGracePeriodByPodPriority</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>priority</span>:<span style=color:#bbb> </span><span style=color:#666>100000</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>shutdownGracePeriodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>priority</span>:<span style=color:#bbb> </span><span style=color:#666>10000</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>shutdownGracePeriodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>180</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>priority</span>:<span style=color:#bbb> </span><span style=color:#666>1000</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>shutdownGracePeriodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>120</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>priority</span>:<span style=color:#bbb> </span><span style=color:#666>0</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>shutdownGracePeriodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>60</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>A tabela acima implica que qualquer pod com valor <code>priority</code> >= 100000 terá apenas 10 segundos para parar qualquer pod com valor >= 10000 e &lt; 100000 e terá 180 segundos para parar, qualquer pod com valor >= 1000 e &lt; 10000 terá 120 segundos para parar. Finalmente, todos os outros pods terão 60 segundos para parar.</p><p>Não é preciso especificar valores correspondentes para todas as classes. Por exemplo, você pode usar estas configurações:</p><table><thead><tr><th>Valor das classes de prioridade</th><th>Tempo de desligamento</th></tr></thead><tbody><tr><td>100000</td><td>300 segundos</td></tr><tr><td>1000</td><td>120 segundos</td></tr><tr><td>0</td><td>60 segundos</td></tr></tbody></table><p>No caso acima, os pods com <code>custom-class-b</code> irão para o mesmo bucket que <code>custom-class-c</code> para desligamento.</p><p>Se não houver pods em um intervalo específico, o kubelet não irá espera por pods nesse intervalo de prioridades. Em vez disso, o kubelet pula imediatamente para o próximo intervalo de valores da classe de prioridade.</p><p>Se esse recurso estiver ativado e nenhuma configuração for fornecida, nenhuma ação de pedido será tomada.</p><p>O uso desse recurso requer ativar os recursos <code>GracefulNodeShutdownBasedOnPodPriority</code> e definir o <code>ShutdownGracePeriodByPodPriority</code> da configuração do kubelet para a configuração desejada, contendo os valores da classe de prioridade do pod e seus respectivos períodos de desligamento.</p><h2 id=swap-memory>Gerenciamento da memória swap</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.22 [alpha]</code></div><p>Antes do Kubernetes 1.22, os nós não suportavam o uso de memória swap, e um kubelet, por padrão, não iniciaria se a troca fosse detectada em um nó. A partir de 1.22, o suporte a memória swap pode ser ativado por nó.</p><p>Para ativar a troca em um nó, o recursos <code>NodeSwap</code> deve estar ativado no kubelet, e a <a href=/docs/reference/config-api/kubelet-config.v1beta1/#kubelet-config-k8s-io-v1beta1-KubeletConfiguration>configuração</a> de comando de linha <code>--fail-swap-on</code> ou <code>failSwapOn</code> deve ser definida como falsa.</p><div class="alert alert-danger warning callout" role=alert><strong>Aviso:</strong> Quando o recurso de memória swap está ativado, os dados do Kubernetes, como o conteúdo de objetos <code>Secret</code> que foram gravados no <code>tmpfs</code>, agora podem ser trocados para o disco.</div><p>Opcionalmente, um usuário também pode configurar <code>memorySwap.swapBehavior</code> para especificar como um nó usará memória swap. Por exemplo,</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>memorySwap</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>swapBehavior</span>:<span style=color:#bbb> </span>LimitedSwap<span style=color:#bbb>
</span></span></span></code></pre></div><p>As opções de configuração disponíveis para <code>swapBehavior</code> são:</p><ul><li><code>LimitedSwap</code>: As cargas de trabalho do Kubernetes são limitadas na quantidade de troca que podem usar. Cargas de trabalho no nó não gerenciadas pelo Kubernetes ainda podem ser trocadas.</li><li><code>UnlimitedSwap</code>: As cargas de trabalho do Kubernetes podem usar tanta memória de swap quanto solicitarem, até o limite do sistema.</li></ul><p>Se a configuração do <code>memorySwap</code> não for especificada e o recurso estiver ativado, por padrão, o kubelet aplicará o mesmo comportamento que a configuração <code>LimitedSwap</code>.</p><p>O comportamento da configuração <code>LimitedSwap</code> depende se o nó estiver sendo executado com v1 ou v2 de grupos de controle (também conhecidos como "cgroups"):</p><ul><li><strong>cgroupsv1</strong>: As cargas de trabalho do Kubernetes podem usar qualquer combinação de memória e swap, até o limite de memória do pod, se definido.</li><li><strong>cgroupsv2</strong>: As cargas de trabalho do Kubernetes não podem usar memória swap.</li></ul><p>Para obter mais informações e para ajudar nos testes e fornecer feedback, consulte <a href=https://github.com/kubernetes/enhancements/issues/2400>KEP-2400</a> e sua <a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/2400-node-swap/README.md>proposta de design</a>.</p><h2 id=próximos-passos>Próximos passos</h2><ul><li>Saiba mais sobre <a href=/docs/concepts/overview/components/#node-components>componentes</a> que compõem um nó.</li><li>Leia a <a href=/docs/reference/generated/kubernetes-api/v1.25/#node-v1-core>definição da API para um Nó</a>.</li><li>Leia a seção <a href=https://git.k8s.io/community/contributors/design-proposals/architecture/architecture.md#the-kubernetes-node>Nó</a> do documento de design de arquitetura.</li><li>Leia sobre <a href=/docs/concepts/scheduling-eviction/taint-and-toleration/>taints e tolerâncias</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-c0251def6da29b30afebfb04549f1703>3.2.2 - Comunicação entre Nó e Control Plane</h1><p>Este documento cataloga os caminhos de comunicação entre o control plane (o
apiserver) e o cluster Kubernetes. A intenção é permitir que os usuários
personalizem sua instalação para proteger a configuração de rede
então o cluster pode ser executado em uma rede não confiável (ou em IPs totalmente públicos em um
provedor de nuvem).</p><h2 id=nó-para-o-control-plane>Nó para o Control Plane</h2><p>Todos os caminhos de comunicação do cluster para o control plane terminam no
apiserver (nenhum dos outros componentes do control plane são projetados para expor
Serviços remotos). Em uma implantação típica, o apiserver é configurado para escutar
conexões remotas em uma porta HTTPS segura (443) com uma ou mais clientes <a href=/docs/reference/access-authn-authz/authentication/>autenticação</a> habilitado.
Uma ou mais formas de <a href=/docs/reference/access-authn-authz/authorization/>autorização</a>
deve ser habilitado, especialmente se <a href=/docs/reference/access-authn-authz/authentication/#anonymous-requests>requisições anônimas</a>
ou <a href=/docs/reference/access-authn-authz/authentication/#service-account-tokens>tokens da conta de serviço</a>
são autorizados.</p><p>Os nós devem ser provisionados com o certificado root público para o cluster
de tal forma que eles podem se conectar de forma segura ao apiserver junto com o cliente válido
credenciais. Por exemplo, em uma implantação padrão do GKE, as credenciais do cliente
fornecidos para o kubelet estão na forma de um certificado de cliente. Vejo
<a href=/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/>bootstrapping TLS do kubelet</a>
para provisionamento automatizado de certificados de cliente kubelet.</p><p>Os pods que desejam se conectar ao apiserver podem fazê-lo com segurança, aproveitando
conta de serviço para que o Kubernetes injetará automaticamente o certificado raiz público
certificado e um token de portador válido no pod quando ele é instanciado.
O serviço <code>kubernetes</code> (no namespace <code>default</code>) é configurado com um IP virtual
endereço que é redirecionado (via kube-proxy) para o endpoint com HTTPS no
apiserver.</p><p>Os componentes do control plane também se comunicam com o apiserver do cluster através da porta segura.</p><p>Como resultado, o modo de operação padrão para conexões do cluster
(nodes e pods em execução nos Nodes) para o control plane é protegido por padrão
e pode passar por redes não confiáveis ​​e/ou públicas.</p><h2 id=control-plane-para-o-nó>Control Plane para o nó</h2><p>Existem dois caminhos de comunicação primários do control plane (apiserver) para os nós.
O primeiro é do apiserver para o processo do kubelet que é executado em
cada nó no cluster. O segundo é do apiserver para qualquer nó, pod,
ou serviço através da funcionalidade de proxy do apiserver.</p><h3 id=apiserver-para-o-kubelet>apiserver para o kubelet</h3><p>As conexões do apiserver ao kubelet são usadas para:</p><ul><li>Buscar logs para pods.</li><li>Anexar (através de kubectl) pods em execução.</li><li>Fornecer a funcionalidade de encaminhamento de porta do kubelet.</li></ul><p>Essas conexões terminam no endpoint HTTPS do kubelet. Por padrão,
o apiserver não verifica o certificado de serviço do kubelet,
o que torna a conexão sujeita a ataques man-in-the-middle, o que o torna
<strong>inseguro</strong> para passar por redes não confiáveis ​​e / ou públicas.</p><p>Para verificar essa conexão, use a flag <code>--kubelet-certificate-authority</code> para
fornecer o apiserver com um pacote de certificado raiz para usar e verificar o
certificado de serviço da kubelet.</p><p>Se isso não for possível, use o <a href=/docs/concepts/architecture/master-node-communication/#ssh-tunnels>SSH túnel</a>
entre o apiserver e kubelet se necessário para evitar a conexão ao longo de um
rede não confiável ou pública.</p><p>Finalmente, <a href=/docs/admin/kubelet-authentication-authorization/>Autenticação e/ou autorização do Kubelet</a>
deve ser ativado para proteger a API do kubelet.</p><h3 id=apiserver-para-nós-pods-e-serviços>apiserver para nós, pods e serviços</h3><p>As conexões a partir do apiserver para um nó, pod ou serviço padrão para simples
conexões HTTP não são autenticadas nem criptografadas. Eles
podem ser executados em uma conexão HTTPS segura prefixando <code>https:</code> no nó,
pod, ou nome do serviço no URL da API, mas eles não validarão o certificado
fornecido pelo ponto de extremidade HTTPS, nem fornece credenciais de cliente, enquanto
a conexão será criptografada, não fornecerá nenhuma garantia de integridade.
Estas conexões <strong>não são atualmente seguras</strong> para serem usados por redes não confiáveis ​​e/ou públicas.</p><h3 id=ssh-túnel>SSH Túnel</h3><p>O Kubernetes suporta túneis SSH para proteger os caminhos de comunicação do control plane para os nós. Nesta configuração, o apiserver inicia um túnel SSH para cada nó
no cluster (conectando ao servidor ssh escutando na porta 22) e passa
todo o tráfego destinado a um kubelet, nó, pod ou serviço através do túnel.
Este túnel garante que o tráfego não seja exposto fora da rede aos quais
os nós estão sendo executados.</p><p>Atualmente, os túneis SSH estão obsoletos, portanto, você não deve optar por usá-los, a menos que saiba o que está fazendo. O serviço Konnectivity é um substituto para este canal de comunicação.</p><h3 id=konnectivity-service>Konnectivity service</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.18 [beta]</code></div><p>Como uma substituição aos túneis SSH, o serviço Konnectivity fornece proxy de nível TCP para a comunicação do control plane para o cluster. O serviço Konnectivity consiste em duas partes: o servidor Konnectivity na rede control plane e os agentes Konnectivity na rede dos nós. Os agentes Konnectivity iniciam conexões com o servidor Konnectivity e mantêm as conexões de rede. Depois de habilitar o serviço Konnectivity, todo o tráfego do control plane para os nós passa por essas conexões.</p><p>Veja a <a href=docs/tasks/extend-kubernetes/setup-konnectivity/>tarefa do Konnectivity</a> para configurar o serviço Konnectivity no seu cluster.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-bc804b02614d67025b4c788f1ca87fbc>3.2.3 - Conceitos sobre Cloud Controller Manager</h1><p>O conceito do Cloud Controller Manager (CCM) (não confundir com o binário) foi originalmente criado para permitir que o código específico de provedor de nuvem e o núcleo do Kubernetes evoluíssem independentemente um do outro. O Cloud Controller Manager é executado junto com outros componentes principais, como o Kubernetes controller manager, o servidor de API e o scheduler. Também pode ser iniciado como um addon do Kubernetes, caso em que é executado em cima do Kubernetes.</p><p>O design do Cloud Controller Manager é baseado em um mecanismo de plug-in que permite que novos provedores de nuvem se integrem facilmente ao Kubernetes usando plug-ins. Existem planos para integrar novos provedores de nuvem no Kubernetes e para migrar provedores de nuvem que estão utilizando o modelo antigo para o novo modelo de CCM.</p><p>Este documento discute os conceitos por trás do Cloud Controller Manager e fornece detalhes sobre suas funções associadas.</p><p>Aqui está a arquitetura de um cluster Kubernetes sem o Cloud Controller Manager:</p><p><img src=/images/docs/pre-ccm-arch.png alt="Pre CCM Kube Arch"></p><h2 id=projeto-de-arquitetura-design>Projeto de Arquitetura (Design)</h2><p>No diagrama anterior, o Kubernetes e o provedor de nuvem são integrados através de vários componentes diferentes:</p><ul><li>Kubelet</li><li>Kubernetes controller manager</li><li>Kubernetes API server</li></ul><p>O CCM consolida toda a lógica que depende da nuvem dos três componentes anteriores para criar um único ponto de integração com a nuvem. A nova arquitetura com o CCM se parece com isso:</p><p><img src=/images/docs/post-ccm-arch.png alt="CCM Kube Arch"></p><h2 id=componentes-do-ccm>Componentes do CCM</h2><p>O CCM separa algumas das funcionalidades do KCM (Kubernetes Controller Manager) e o executa como um processo separado. Especificamente, isso elimina os controladores no KCM que dependem da nuvem. O KCM tem os seguintes loops de controlador dependentes de nuvem:</p><ul><li>Node controller</li><li>Volume controller</li><li>Route controller</li><li>Service controller</li></ul><p>Na versão 1.9, o CCM executa os seguintes controladores da lista anterior:</p><ul><li>Node controller</li><li>Route controller</li><li>Service controller</li></ul><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> O Volume Controller foi deliberadamente escolhido para não fazer parte do CCM. Devido à complexidade envolvida e devido aos esforços existentes para abstrair a lógica de volume específica do fornecedor, foi decidido que o Volume Controller não será movido para o CCM.</div><p>O plano original para suportar volumes usando o CCM era usar volumes Flex para suportar volumes plugáveis. No entanto, um esforço concorrente conhecido como CSI está sendo planejado para substituir o Flex.</p><p>Considerando essas dinâmicas, decidimos ter uma medida de intervalo intermediário até que o CSI esteja pronto.</p><h2 id=funções-do-ccm>Funções do CCM</h2><p>O CCM herda suas funções de componentes do Kubernetes que são dependentes de um provedor de nuvem. Esta seção é estruturada com base nesses componentes.</p><h3 id=1-kubernetes-controller-manager>1. Kubernetes Controller Manager</h3><p>A maioria das funções do CCM é derivada do KCM. Conforme mencionado na seção anterior, o CCM executa os seguintes ciclos de controle:</p><ul><li>Node Controller</li><li>Route Controller</li><li>Service Controller</li></ul><h4 id=node-controller>Node Controller</h4><p>O Node Controller é responsável por inicializar um nó obtendo informações sobre os nós em execução no cluster do provedor de nuvem. O Node Controller executa as seguintes funções:</p><ol><li>Inicializar um node com labels de região/zona específicos para a nuvem.</li><li>Inicialize um node com detalhes de instância específicos da nuvem, por exemplo, tipo e tamanho.</li><li>Obtenha os endereços de rede e o nome do host do node.</li><li>No caso de um node não responder, verifique a nuvem para ver se o node foi excluído da nuvem.
Se o node foi excluído da nuvem, exclua o objeto Node do Kubernetes.</li></ol><h4 id=route-controller>Route Controller</h4><p>O Route Controller é responsável por configurar as rotas na nuvem apropriadamente, de modo que os contêineres em diferentes nodes no cluster do Kubernetes possam se comunicar entre si. O Route Controller é aplicável apenas para clusters do Google Compute Engine.</p><h4 id=service-controller>Service controller</h4><p>O Service controller é responsável por ouvir os eventos de criação, atualização e exclusão do serviço. Com base no estado atual dos serviços no Kubernetes, ele configura os balanceadores de carga da nuvem (como o ELB, o Google LB ou o Oracle Cloud Infrastrucutre LB) para refletir o estado dos serviços no Kubernetes. Além disso, garante que os back-ends de serviço para balanceadores de carga da nuvem estejam atualizados.</p><h3 id=2-kubelet>2. Kubelet</h3><p>O Node Controller contém a funcionalidade dependente da nuvem do kubelet. Antes da introdução do CCM, o kubelet era responsável por inicializar um nó com detalhes específicos da nuvem, como endereços IP, rótulos de região / zona e informações de tipo de instância. A introdução do CCM mudou esta operação de inicialização do kubelet para o CCM.</p><p>Nesse novo modelo, o kubelet inicializa um nó sem informações específicas da nuvem. No entanto, ele adiciona uma marca (taint) ao nó recém-criado que torna o nó não programável até que o CCM inicialize o nó com informações específicas da nuvem. Em seguida, remove essa mancha (taint).</p><h2 id=mecanismo-de-plugins>Mecanismo de plugins</h2><p>O Cloud Controller Manager usa interfaces Go para permitir implementações de qualquer nuvem a ser conectada. Especificamente, ele usa a Interface CloudProvider definida<a href=https://github.com/kubernetes/cloud-provider/blob/9b77dc1c384685cb732b3025ed5689dd597a5971/cloud.go#L42-L62>aqui</a>.</p><p>A implementação dos quatro controladores compartilhados destacados acima, e algumas estruturas que ficam junto com a interface compartilhada do provedor de nuvem, permanecerão no núcleo do Kubernetes. Implementações específicas para provedores de nuvem serão construídas fora do núcleo e implementarão interfaces definidas no núcleo.</p><p>Para obter mais informações sobre o desenvolvimento de plug-ins, consulte<a href=/docs/tasks/administer-cluster/developing-cloud-controller-manager/>Desenvolvendo o Cloud Controller Manager</a>.</p><h2 id=autorização>Autorização</h2><p>Esta seção divide o acesso necessário em vários objetos da API pelo CCM para executar suas operações.</p><h3 id=node-controller-1>Node Controller</h3><p>O Node Controller só funciona com objetos Node. Ele requer acesso total para obter, listar, criar, atualizar, corrigir, assistir e excluir objetos Node.</p><p>v1/Node:</p><ul><li>Get</li><li>List</li><li>Create</li><li>Update</li><li>Patch</li><li>Watch</li><li>Delete</li></ul><h3 id=rote-controller>Rote Controller</h3><p>O Rote Controller escuta a criação do objeto Node e configura as rotas apropriadamente. Isso requer acesso a objetos Node.</p><p>v1/Node:</p><ul><li>Get</li></ul><h3 id=service-controller-1>Service Controller</h3><p>O Service Controller escuta eventos de criação, atualização e exclusão de objeto de serviço e, em seguida, configura pontos de extremidade para esses serviços de forma apropriada.</p><p>Para acessar os Serviços, é necessário listar e monitorar o acesso. Para atualizar os Serviços, ele requer patch e atualização de acesso.</p><p>Para configurar endpoints para os Serviços, é necessário acesso para criar, listar, obter, assistir e atualizar.</p><p>v1/Service:</p><ul><li>List</li><li>Get</li><li>Watch</li><li>Patch</li><li>Update</li></ul><h3 id=outros>Outros</h3><p>A implementação do núcleo do CCM requer acesso para criar eventos e, para garantir a operação segura, requer acesso para criar ServiceAccounts.</p><p>v1/Event:</p><ul><li>Create</li><li>Patch</li><li>Update</li></ul><p>v1/ServiceAccount:</p><ul><li>Create</li></ul><p>O RBAC ClusterRole para o CCM se parece com isso:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cloud-controller-manager<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- events<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- create<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- patch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- nodes<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#39;*&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- nodes/status<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- patch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- services<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- list<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- patch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- watch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- serviceaccounts<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- create<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- persistentvolumes<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- get<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- list<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- watch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- endpoints<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- create<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- get<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- list<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- watch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=implementações-de-provedores-de-nuvem>Implementações de Provedores de Nuvem</h2><p>Os seguintes provedores de nuvem implementaram CCMs:</p><ul><li><a href=https://github.com/digitalocean/digitalocean-cloud-controller-manager>Digital Ocean</a></li><li><a href=https://github.com/oracle/oci-cloud-controller-manager>Oracle</a></li><li><a href=https://github.com/kubernetes/cloud-provider-azure>Azure</a></li><li><a href=https://github.com/kubernetes/cloud-provider-gcp>GCP</a></li><li><a href=https://github.com/kubernetes/cloud-provider-aws>AWS</a></li><li><a href=https://github.com/baidu/cloud-provider-baiducloud>BaiduCloud</a></li><li><a href=https://github.com/linode/linode-cloud-controller-manager>Linode</a></li></ul><h2 id=administração-de-cluster>Administração de Cluster</h2><p>Voce vai encontrar instruções completas para configurar e executar o CCM
<a href=/docs/tasks/administer-cluster/running-cloud-controller/#cloud-controller-manager>aqui</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-ca8819042a505291540e831283da66df>3.2.4 - Controladores</h1><p>Em robótica e automação um <em>control loop</em>, ou em português <em>ciclo de controle</em>, é
um ciclo não terminado que regula o estado de um sistema.</p><p>Um exemplo de ciclo de controle é um termostato de uma sala.</p><p>Quando você define a temperatura, isso indica ao termostato
sobre o seu <em>estado desejado</em>. A temperatura ambiente real é o
<em>estado atual</em>. O termostato atua de forma a trazer o estado atual
mais perto do estado desejado, ligando ou desligando o equipamento.</p>No Kubernetes, controladores são ciclos de controle que observam o estado do seu
<a class=glossary-tooltip title='Um conjunto de servidores de processamento, também chamados de nós, que executam aplicações containerizadas. Todo cluster possui ao menos um servidor de processamento (worker node).' data-toggle=tooltip data-placement=top href='/pt-br/docs/reference/glossary/?all=true#term-cluster' target=_blank aria-label=cluster>cluster</a>, e então fazer ou requisitar
mudanças onde necessário.
Cada controlador tenta mover o estado atual do cluster mais perto do estado desejado.<h2 id=padrão-controlador-controller-pattern>Padrão Controlador (Controller pattern)</h2><p>Um controlador rastreia pelo menos um tipo de recurso Kubernetes.
Estes <a href=/docs/concepts/overview/working-with-objects/kubernetes-objects/#kubernetes-objects>objetos</a>
têm um campo <em>spec</em> que representa o <em>estado desejado</em>.
O(s) controlador(es) para aquele recurso são responsáveis por trazer o <em>estado atual</em>
mais perto do <em>estado desejado</em>.</p><p>O controlador pode executar uma ação ele próprio, ou,
o que é mais comum, no Kubernetes, o controlador envia uma mensagem para o
<a class=glossary-tooltip title='O componente da camada de gerenciamento que serve a API do Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label='API server'>API server</a> (servidor de API) que tem
efeitos colaterais úteis. Você vai ver exemplos disto abaixo.</p><h3 id=controlador-via-api-server>Controlador via API server</h3><p>O controlador <a class=glossary-tooltip title='Uma tarefa finita ou em lotes que executa até finalizar.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/job target=_blank aria-label=Job>Job</a> é um exemplo de um
controlador Kubernetes embutido. Controladores embutidos gerem estados através da
interação com o <em>cluster API server</em>.</p><p><em>Job</em> é um recurso do Kubernetes que é executado em um
<em><a class=glossary-tooltip title='O menor e mais simples objeto Kubernetes. Um Pod representa um conjunto de contêineres em execução no seu cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/ target=_blank aria-label=Pod>Pod</a></em>, ou talvez vários <em>Pods</em>, com o objetivo de
executar uma tarefa e depois parar.</p><p>(Uma vez <a href=/docs/concepts/scheduling/>agendado</a>, objetos <em>Pod</em> passam a fazer parte
do <em>estado desejado</em> para um kubelet.</p><p>Quando o controlador <em>Job</em> observa uma nova tarefa ele garante que,
algures no seu <em>cluster</em>, os kubelets num conjunto de nós (<em>Nodes</em>) estão correndo o número
correto de <em>Pods</em> para completar o trabalho.
O controlador <em>Job</em> não corre <em>Pods</em> ou <em>containers</em> ele próprio.
Em vez disso, o controlador <em>Job</em> informa o <em>API server</em> para criar ou remover <em>Pods</em>.
Outros componentes do plano de controle
(<a class=glossary-tooltip title='A camada de gerenciamento de contêiner que expõe a API e as interfaces para definir, implantar e gerenciar o ciclo de vida dos contêineres.' data-toggle=tooltip data-placement=top href='/pt-br/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='control plane'>control plane</a>)
atuam na nova informação (existem novos <em>Pods</em> para serem agendados e executados),
e eventualmente o trabalho é feito.</p><p>Após ter criado um novo <em>Job</em>, o <em>estado desejado</em> é que esse Job seja completado.
O controlador <em>Job</em> faz com que o <em>estado atual</em> para esse <em>Job</em> esteja mais perto do seu
<em>estado desejado</em>: criando <em>Pods</em> que fazem o trabalho desejado para esse <em>Job</em> para que
o <em>Job</em> fique mais perto de ser completado.</p><p>Controladores também atualizam os objetos que os configuram.
Por exemplo: assim que o trabalho de um <em>Job</em> está completo,
o controlador <em>Job</em> atualiza esse objeto <em>Job</em> para o marcar como <code>Finished</code> (terminado).</p><p>(Isto é um pouco como alguns termostatos desligam uma luz para
indicar que a temperatura da sala está agora na temperatura que foi introduzida).</p><h3 id=controle-direto>Controle direto</h3><p>Em contraste com <em>Job</em>, alguns controladores necessitam de efetuar
mudanças fora do <em>cluster</em>.</p><p>Por exemplo, se usar um ciclo de controle para garantir que existem
<em><a class=glossary-tooltip title='Um Nó é uma máquina de trabalho no Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/nodes/ target=_blank aria-label=Nodes>Nodes</a></em> suficientes
no seu <em>cluster</em>, então esse controlador necessita de algo exterior ao
<em>cluster</em> atual para configurar novos <em>Nodes</em> quando necessário.</p><p>Controladores que interagem com estados externos encontram o seu estado desejado
a partir do <em>API server</em>, e então comunicam diretamente com o sistema externo para
trazer o <em>estado atual</em> mais próximo do desejado.</p><p>(Existe um controlador que escala horizontalmente nós no seu <em>cluster</em>.
Veja <a href=/docs/tasks/administer-cluster/cluster-management/#cluster-autoscaling>Escalamento automático do cluster</a>)</p><h2 id=desired-vs-current>Estado desejado versus atual</h2><p>Kubernetes tem uma visão <em>cloud-native</em> de sistemas e é capaz de manipular
mudanças constantes.</p><p>O seu <em>cluster</em> pode mudar em qualquer momento à medida que as ações acontecem e
os ciclos de controle corrigem falhas automaticamente. Isto significa que,
potencialmente, o seu <em>cluster</em> nunca atinge um estado estável.</p><p>Enquanto os controladores no seu <em>cluster</em> estiverem rodando e forem capazes de
fazer alterações úteis, não importa se o estado é estável ou se é instável.</p><h2 id=design>Design</h2><p>Como um princípio do seu desenho, o Kubernetes usa muitos controladores onde cada
um gerencia um aspecto particular do estado do <em>cluster</em>. Comumente, um particular
ciclo de controle (controlador) usa uma espécie de recurso como o seu <em>estado desejado</em>,
e tem uma espécie diferente de recurso que o mesmo gere para garantir que esse <em>estado desejado</em>
é cumprido.</p><p>É útil que haja controladores simples em vez de um conjunto monolítico de ciclos de controle
que estão interligados. Controladores podem falhar, então o Kubernetes foi desenhado para
permitir isso.</p><p>Por exemplo: um controlador de <em>Jobs</em> rastreia objetos <em>Job</em> (para
descobrir novos trabalhos) e objetos <em>Pod</em> (para correr o <em>Jobs</em>, e então
ver quando o trabalho termina). Neste caso outra coisa cria os <em>Jobs</em>,
enquanto o controlador <em>Job</em> cria <em>Pods</em>.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong><p>Podem existir vários controladores que criam ou atualizam a mesma espécie (kind) de objeto.
Atrás das cortinas, os controladores do Kubernetes garantem que eles apenas tomam
atenção aos recursos ligados aos seus recursos controladores.</p><p>Por exemplo, você pode ter <em>Deployments</em> e <em>Jobs</em>; ambos criam <em>Pods</em>.
O controlador de <em>Job</em> não apaga os <em>Pods</em> que o seu <em>Deployment</em> criou,
porque existe informação (<a class=glossary-tooltip title='Tags objects with identifying attributes that are meaningful and relevant to users.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/labels target=_blank aria-label=labels>labels</a>)
que os controladores podem usar para diferenciar esses <em>Pods</em>.</p></div><h2 id=running-controllers>Formas de rodar controladores</h2><p>O Kubernetes vem com um conjunto de controladores embutidos que correm
dentro do <a class=glossary-tooltip title='Componente da camada de gerenciamento que executa os processos de controle.' data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-controller-manager/ target=_blank aria-label=kube-controller-manager>kube-controller-manager</a>.
Estes controladores embutidos providenciam comportamentos centrais importantes.</p><p>O controlador <em>Deployment</em> e o controlador <em>Job</em> são exemplos de controladores
que veem como parte do próprio Kubernetes (controladores "embutidos").
O Kubernetes deixa você correr o plano de controle resiliente, para que se qualquer
um dos controladores embutidos falhar, outra parte do plano de controle assume
o trabalho.</p><p>Pode encontrar controladores fora do plano de controle, para extender o Kubernetes.
Ou, se quiser, pode escrever um novo controlador você mesmo.
Pode correr o seu próprio controlador como um conjunto de <em>Pods</em>,
ou externo ao Kubernetes. O que encaixa melhor vai depender no que esse
controlador faz em particular.</p><h2 id=próximos-passos>Próximos passos</h2><ul><li>Leia mais sobre o <a href=/docs/concepts/#kubernetes-control-plane>plano de controle do Kubernetes</a></li><li>Descubra alguns dos <a href=/docs/concepts/#kubernetes-objects>objetos Kubernetes</a> básicos.</li><li>Aprenda mais sobre <a href=/docs/concepts/overview/kubernetes-api/>API do Kubernetes</a></li><li>Se pretender escrever o seu próprio controlador, veja <a href=/docs/concepts/extend-kubernetes/extend-cluster/#extension-patterns>Padrões de Extensão</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-a5f7383c83ab9eb9cd0e3c4c020b3ae6>3.3 - Contêineres</h1><div class=lead>Tecnologia para empacotar aplicações com suas dependências em tempo de execução</div><p>Cada contêiner executado é repetível; a padronização de ter
dependências incluídas significa que você obtém o mesmo comportamento onde quer que você execute.</p><p>Os contêineres separam os aplicativos da infraestrutura de <em>host</em> subjacente.
Isso torna a implantação mais fácil em diferentes ambientes de nuvem ou sistema operacional.</p><h2 id=imagem-de-contêiner>Imagem de contêiner</h2><p>Uma <a href=/docs/concepts/containers/images/>imagem de contêiner</a> é um pacote de software pronto para executar, contendo tudo que é preciso para executar uma aplicação:
o código e o agente de execução necessário, aplicação, bibliotecas do sistema e valores padrões para qualquer configuração essencial.</p><p>Por <em>design</em>, um contêiner é imutável: você não pode mudar o código de um contêiner que já está executando. Se você tem uma aplicação conteinerizada e quer fazer mudanças, você precisa construir uma nova imagem que inclui a mudança, e recriar o contêiner para iniciar a partir da imagem atualizada.</p><h2 id=agente-de-execução-de-contêiner>Agente de execução de contêiner</h2><p>O agente de execução (<em>runtime</em>) de contêiner é o software responsável por executar os contêineres.</p><p>O Kubernetes suporta diversos agentes de execução de contêineres: <a class=glossary-tooltip title='Docker é uma tecnologia utilizada para prover virtualização a nível do sistema operacional também conhecidoa como containers.' data-toggle=tooltip data-placement=top href=https://docs.docker.com/engine/ target=_blank aria-label=Docker>Docker</a>, <a class=glossary-tooltip title='Um agente de execução de contêiner com enfase em simplicidade, robustez e portabilidade' data-toggle=tooltip data-placement=top href=https://containerd.io/docs/ target=_blank aria-label=containerd>containerd</a>, <a class=glossary-tooltip title='Um agente de execução leve de contêineres criado especificamente para o Kubernetes' data-toggle=tooltip data-placement=top href=https://cri-o.io/#what-is-cri-o target=_blank aria-label=CRI-O>CRI-O</a>, e qualquer implementação do <a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-node/container-runtime-interface.md>Kubernetes CRI (Container Runtime Interface)</a>.</p><h2 id=próximos-passos>Próximos passos</h2><ul><li><a href=/docs/concepts/containers/images/>Imagens de contêineres</a></li><li><a href=/docs/concepts/workloads/pods/>Pods</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-16042b4652ad19e565c7263824029a43>3.3.1 - Imagens</h1><p>Uma imagem de contêiner representa dados binários que encapsulam uma aplicação e todas as suas dependências de software. As imagens de contêiner são pacotes de software executáveis que podem ser executados de forma autônoma e que fazem suposições muito bem definidas sobre seu agente de execução do ambiente.</p><p>Normalmente, você cria uma imagem de contêiner da sua aplicação e a envia para um registro antes de fazer referência a ela em um <a class=glossary-tooltip title='O menor e mais simples objeto Kubernetes. Um Pod representa um conjunto de contêineres em execução no seu cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/ target=_blank aria-label=Pod>Pod</a></p><p>Esta página fornece um resumo sobre o conceito de imagem de contêiner.</p><h2 id=nomes-das-imagens>Nomes das imagens</h2><p>As imagens de contêiner geralmente recebem um nome como <code>pause</code>, <code>exemplo/meuconteiner</code>, ou <code>kube-apiserver</code>.
As imagens também podem incluir um hostname de algum registro; por exemplo: <code>exemplo.registro.ficticio/nomeimagem</code>,
e um possível número de porta; por exemplo: <code>exemplo.registro.ficticio:10443/nomeimagem</code>.</p><p>Se você não especificar um hostname de registro, o Kubernetes presumirá que você se refere ao registro público do Docker.</p><p>Após a parte do nome da imagem, você pode adicionar uma <em>tag</em> (como também usar com comandos como <code>docker</code> e<code> podman</code>).
As tags permitem identificar diferentes versões da mesma série de imagens.</p><p>Tags de imagem consistem em letras maiúsculas e minúsculas, dígitos, sublinhados (<code>_</code>),
pontos (<code>.</code>) e travessões (<code> -</code>).
Existem regras adicionais sobre onde você pode colocar o separador
caracteres (<code>_</code>,<code>-</code> e <code>.</code>) dentro de uma tag de imagem.
Se você não especificar uma tag, o Kubernetes presumirá que você se refere à tag <code>latest</code> (mais recente).</p><div class="alert alert-warning caution callout" role=alert><strong>Cuidado:</strong><p>Você deve evitar usar a tag <code>latest</code> quando estiver realizando o deploy de contêineres em produção,
pois é mais difícil rastrear qual versão da imagem está sendo executada, além de tornar mais difícil o processo de reversão para uma versão funcional.</p><p>Em vez disso, especifique uma tag significativa, como <code>v1.42.0</code>.</p></div><h2 id=atualizando-imagens>Atualizando imagens</h2><p>A política padrão de pull é <code>IfNotPresent</code> a qual faz com que o
<a class=glossary-tooltip title='Um agente que é executado em cada node no cluster. Ele garante que os contêineres estejam sendo executados em um pod.' data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kubelet target=_blank aria-label=kubelet>kubelet</a> ignore
o processo de <em>pull</em> da imagem, caso a mesma já exista. Se você prefere sempre forçar o processo de <em>pull</em>,
você pode seguir uma das opções abaixo:</p><ul><li>defina a <code>imagePullPolicy</code> do contêiner para<code> Always</code>.</li><li>omita <code>imagePullPolicy</code> e use<code>: latest</code> como a tag para a imagem a ser usada.</li><li>omita o <code>imagePullPolicy</code> e a tag da imagem a ser usada.</li><li>habilite o <a href=/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages>AlwaysPullImages</a> controlador de admissão.</li></ul><p>Quando <code>imagePullPolicy</code> é definido sem um valor específico, ele também é definido como<code> Always</code>.</p><h2 id=multiarquitetura-de-imagens-com-índice-de-imagens>Multiarquitetura de imagens com índice de imagens</h2><p>Além de fornecer o binário das imagens, um registro de contêiner também pode servir um <a href=https://github.com/opencontainers/image-spec/blob/master/image-index.md>índice de imagem do contêiner</a>. Um índice de imagem pode apontar para múltiplos <a href=https://github.com/opencontainers/image-spec/blob/master/manifest.md>manifestos da imagem</a> para versões específicas de arquitetura de um contêiner. A ideia é que você possa ter um nome para uma imagem (por exemplo: <code>pause</code>, <code>exemple/meuconteiner</code>, <code>kube-apiserver</code>) e permitir que diferentes sistemas busquem o binário da imagem correta para a arquitetura de máquina que estão usando.</p><p>O próprio Kubernetes normalmente nomeia as imagens de contêiner com o sufixo <code>-$(ARCH)</code>. Para retrocompatibilidade, gere as imagens mais antigas com sufixos. A ideia é gerar a imagem <code>pause</code> que tem o manifesto para todas as arquiteturas e <code>pause-amd64</code> que é retrocompatível com as configurações anteriores ou arquivos YAML que podem ter codificado as imagens com sufixos.</p><h2 id=usando-um-registro-privado>Usando um registro privado</h2><p>Os registros privados podem exigir chaves para acessar as imagens deles.
As credenciais podem ser fornecidas de várias maneiras:</p><ul><li>Configurando nós para autenticação em um registro privado<ul><li>todos os pods podem ler qualquer registro privado configurado</li><li>requer configuração de nó pelo administrador do cluster</li></ul></li><li>Imagens pré-obtidas<ul><li>todos os pods podem usar qualquer imagem armazenada em cache em um nó</li><li>requer acesso root a todos os nós para configurar</li></ul></li><li>Especificando ImagePullSecrets em um Pod<ul><li>apenas pods que fornecem chaves próprias podem acessar o registro privado</li></ul></li><li>Extensões locais ou específicas do fornecedor<ul><li>se estiver usando uma configuração de nó personalizado, você (ou seu provedor de nuvem) pode implementar seu mecanismo para autenticar o nó ao registro do contêiner.</li></ul></li></ul><p>Essas opções são explicadas com mais detalhes abaixo.</p><h3 id=configurando-nós-para-autenticação-em-um-registro-privado>Configurando nós para autenticação em um registro privado</h3><p>Se você executar o Docker em seus nós, poderá configurar o contêiner runtime do Docker
para autenticação em um registro de contêiner privado.</p><p>Essa abordagem é adequada se você puder controlar a configuração do nó.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> O Kubernetes padrão é compatível apenas com as seções <code>auths</code> e<code> HttpHeaders</code> na configuração do Docker.
Auxiliares de credencial do Docker (<code>credHelpers</code> ou <code>credsStore</code>) não são suportados.</div><p>Docker armazena chaves de registros privados no arquivo <code>$HOME/.dockercfg</code> ou <code>$HOME/.docker/config.json</code>. Se você colocar o mesmo arquivo na lista de caminhos de pesquisa abaixo, o kubelet o usa como provedor de credenciais ao obter imagens.</p><ul><li><code>{--root-dir:-/var/lib/kubelet}/config.json</code></li><li><code>{cwd of kubelet}/config.json</code></li><li><code>${HOME}/.docker/config.json</code></li><li><code>/.docker/config.json</code></li><li><code>{--root-dir:-/var/lib/kubelet}/.dockercfg</code></li><li><code>{cwd of kubelet}/.dockercfg</code></li><li><code>${HOME}/.dockercfg</code></li><li><code>/.dockercfg</code></li></ul><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Você talvez tenha que definir <code>HOME=/root</code> explicitamente no ambiente do processo kubelet.</div><p>Aqui estão as etapas recomendadas para configurar seus nós para usar um registro privado. Neste
exemplo, execute-os em seu desktop/laptop:</p><ol><li>Execute <code>docker login [servidor]</code> para cada conjunto de credenciais que deseja usar. Isso atualiza o <code>$HOME/.docker/config.json</code> em seu PC.</li><li>Visualize <code>$HOME/.docker/config.json</code> em um editor para garantir que contém apenas as credenciais que você deseja usar.</li><li>Obtenha uma lista de seus nós; por exemplo:<ul><li>se você quiser os nomes: <code>nodes=$( kubectl get nodes -o jsonpath='{range.items[*].metadata}{.name} {end}' )</code></li><li>se você deseja obter os endereços IP: <code>nodes=$( kubectl get nodes -o jsonpath='{range .items[*].status.addresses[?(@.type=="ExternalIP")]}{.address} {end}' )</code></li></ul></li><li>Copie seu <code>.docker/config.json</code> local para uma das listas de caminhos de busca acima.<ul><li>por exemplo, para testar isso: <code>for n in $nodes; do scp ~/.docker/config.json root@"$n":/var/lib/kubelet/config.json; done</code></li></ul></li></ol><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Para clusters de produção, use uma ferramenta de gerenciamento de configuração para que você possa aplicar esta
configuração em todos os nós que você precisar.</div><p>Verifique se está funcionando criando um pod que usa uma imagem privada; por exemplo:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f - <span style=color:#b44>&lt;&lt;EOF
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: Pod
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: private-image-test-1
</span></span></span><span style=display:flex><span><span style=color:#b44>spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>  containers:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - name: uses-private-image
</span></span></span><span style=display:flex><span><span style=color:#b44>      image: $PRIVATE_IMAGE_NAME
</span></span></span><span style=display:flex><span><span style=color:#b44>      imagePullPolicy: Always
</span></span></span><span style=display:flex><span><span style=color:#b44>      command: [ &#34;echo&#34;, &#34;SUCCESS&#34; ]
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><pre tabindex=0><code>pod/private-image-test-1 created
</code></pre><p>Se tudo estiver funcionando, então, após algum tempo, você pode executar:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl logs private-image-test-1
</span></span></code></pre></div><p>e veja o resultado do comando:</p><pre tabindex=0><code>SUCCESS
</code></pre><p>Se você suspeitar que o comando falhou, você pode executar:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe pods/private-image-test-1 | grep <span style=color:#b44>&#39;Failed&#39;</span>
</span></span></code></pre></div><p>Em caso de falha, a saída é semelhante a:</p><pre tabindex=0><code>  Fri, 26 Jun 2015 15:36:13 -0700    Fri, 26 Jun 2015 15:39:13 -0700    19    {kubelet node-i2hq}    spec.containers{uses-private-image}    failed        Failed to pull image &#34;user/privaterepo:v1&#34;: Error: image user/privaterepo:v1 not found
</code></pre><p>Você deve garantir que todos os nós no cluster tenham o mesmo <code>.docker/config.json</code>. Caso contrário, os pods serão executados com sucesso em alguns nós e falharão em outros. Por exemplo, se você usar o escalonamento automático de nós, cada modelo de instância precisa incluir o <code>.docker/config.json</code> ou montar um drive que o contenha.</p><p>Todos os pods terão premissão de leitura às imagens em qualquer registro privado, uma vez que
as chaves privadas do registro são adicionadas ao <code>.docker/config.json</code>.</p><h3 id=imagens-pré-obtidas>Imagens pré-obtidas</h3><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Essa abordagem é adequada se você puder controlar a configuração do nó. Isto
não funcionará de forma confiável se o seu provedor de nuvem for responsável pelo gerenciamento de nós e os substituir
automaticamente.</div><p>Por padrão, o kubelet tenta realizar um "pull" para cada imagem do registro especificado.
No entanto, se a propriedade <code>imagePullPolicy</code> do contêiner for definida como<code> IfNotPresent</code> ou <code>Never</code>,
em seguida, uma imagem local é usada (preferencial ou exclusivamente, respectivamente).</p><p>Se você quiser usar imagens pré-obtidas como um substituto para a autenticação do registro,
você deve garantir que todos os nós no cluster tenham as mesmas imagens pré-obtidas.</p><p>Isso pode ser usado para pré-carregar certas imagens com o intuíto de aumentar a velocidade ou como uma alternativa para autenticação em um registro privado.</p><p>Todos os pods terão permissão de leitura a quaisquer imagens pré-obtidas.</p><h3 id=especificando-imagepullsecrets-em-um-pod>Especificando imagePullSecrets em um pod</h3><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Esta é a abordagem recomendada para executar contêineres com base em imagens
de registros privados.</div><p>O Kubernetes oferece suporte à especificação de chaves de registro de imagem de contêiner em um pod.</p><h4 id=criando-um-segredo-com-docker-config>Criando um segredo com Docker config</h4><p>Execute o seguinte comando, substituindo as palavras em maiúsculas com os valores apropriados:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret docker-registry &lt;name&gt; --docker-server<span style=color:#666>=</span>DOCKER_REGISTRY_SERVER --docker-username<span style=color:#666>=</span>DOCKER_USER --docker-password<span style=color:#666>=</span>DOCKER_PASSWORD --docker-email<span style=color:#666>=</span>DOCKER_EMAIL
</span></span></code></pre></div><p>Se você já tem um arquivo de credenciais do Docker, em vez de usar o
comando acima, você pode importar o arquivo de credenciais como um Kubernetes
<a class=glossary-tooltip title='Armazena dados sensíveis, como senhas, tokens OAuth e chaves SSH.' data-toggle=tooltip data-placement=top href=/pt-br/docs/concepts/configuration/secret/ target=_blank aria-label=Secrets>Secrets</a>.
<a href=/docs/tasks/configure-pod-container/pull-image-private-registry/#registry-secret-existing-credentials>Criar um segredo com base nas credenciais Docker existentes</a> explica como configurar isso.</p><p>Isso é particularmente útil se você estiver usando vários registros privados de contêineres, como <code>kubectl create secret docker-registry</code> cria um Segredo que
só funciona com um único registro privado.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Os pods só podem fazer referência a <em>pull secrets</em> de imagem em seu próprio namespace,
portanto, esse processo precisa ser feito uma vez por namespace.</div><h4 id=referenciando-um-imagepullsecrets-em-um-pod>Referenciando um imagePullSecrets em um pod</h4><p>Agora, você pode criar pods que fazem referência a esse segredo adicionando uma seção <code>imagePullSecrets</code>
na definição de Pod.</p><p>Por exemplo:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt; pod.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: Pod
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: foo
</span></span></span><span style=display:flex><span><span style=color:#b44>  namespace: awesomeapps
</span></span></span><span style=display:flex><span><span style=color:#b44>spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>  containers:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - name: foo
</span></span></span><span style=display:flex><span><span style=color:#b44>      image: janedoe/awesomeapp:v1
</span></span></span><span style=display:flex><span><span style=color:#b44>  imagePullSecrets:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - name: myregistrykey
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt;&gt; ./kustomization.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>resources:
</span></span></span><span style=display:flex><span><span style=color:#b44>- pod.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>Isso precisa ser feito para cada pod que está usando um registro privado.</p><p>No entanto, a configuração deste campo pode ser automatizada definindo o imagePullSecrets
em um recurso de <a href=/docs/tasks/configure-pod-container/configure-service-account/>ServiceAccount</a>.</p><p>Verifique <a href=/docs/tasks/configure-pod-container/configure-service-account/#add-imagepullsecrets-to-a-service-account>Adicionar ImagePullSecrets a uma conta de serviço</a> para obter instruções detalhadas.</p><p>Você pode usar isso em conjunto com um <code>.docker / config.json</code> por nó. As credenciais
serão mescladas.</p><h2 id=casos-de-uso>Casos de uso</h2><p>Existem várias soluções para configurar registros privados. Aqui estão alguns
casos de uso comuns e soluções sugeridas.</p><ol><li>Cluster executando apenas imagens não proprietárias (por exemplo, código aberto). Não há necessidade de ocultar imagens.<ul><li>Use imagens públicas no Docker hub.<ul><li>Nenhuma configuração necessária.</li><li>Alguns provedores de nuvem armazenam em cache ou espelham automaticamente imagens públicas, o que melhora a disponibilidade e reduz o tempo para extrair imagens.</li></ul></li></ul></li><li>Cluster executando algumas imagens proprietárias que devem ser ocultadas para quem está fora da empresa, mas
visível para todos os usuários do cluster.<ul><li>Use um <a href=https://docs.docker.com/registry/>registro Docker</a> privado hospedado.<ul><li>Pode ser hospedado no <a href=https://hub.docker.com/signup>Docker Hub</a> ou em outro lugar.</li><li>Configure manualmente .docker/config.json em cada nó conforme descrito acima.</li></ul></li><li>Ou execute um registro privado interno atrás de seu firewall com permissão de leitura.<ul><li>Nenhuma configuração do Kubernetes é necessária.</li></ul></li><li>Use um serviço de registro de imagem de contêiner que controla o acesso à imagem<ul><li>Funcionará melhor com o escalonamento automático do cluster do que com a configuração manual de nós.</li></ul></li><li>Ou, em um cluster onde alterar a configuração do nó é inconveniente, use <code>imagePullSecrets</code>.</li></ul></li><li>Cluster com imagens proprietárias, algumas das quais requerem controle de acesso mais rígido.<ul><li>Certifique-se de que o <a href=/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages>controlador de admissão AlwaysPullImages</a> está ativo. Caso contrário, todos os pods têm potencialmente acesso a todas as imagens.</li><li>Mova dados confidenciais para um recurso "secreto", em vez de empacotá-los em uma imagem.</li></ul></li><li>Um cluster multilocatário em que cada locatário precisa de seu próprio registro privado.<ul><li>Certifique-se de que o <a href=/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages>controlador de admissão AlwaysPullImages</a> está ativo. Caso contrário, todos os Pods de todos os locatários terão potencialmente acesso a todas as imagens.</li><li>Execute um registro privado com autorização necessária.</li><li>Gere credenciais de registro para cada locatário, coloque em segredo e preencha o segredo para cada namespace de locatário.</li><li>O locatário adiciona esse segredo a imagePullSecrets de cada namespace.</li></ul></li></ol><p>Se precisar de acesso a vários registros, você pode criar um segredo para cada registro.
O Kubelet mesclará qualquer <code>imagePullSecrets</code> em um único <code>.docker/config.json</code> virtual</p><h2 id=próximos-passos>Próximos passos</h2><ul><li>Leia a <a href=https://github.com/opencontainers/image-spec/blob/master/manifest.md>OCI Image Manifest Specification</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-643212488f778acf04bebed65ba34441>3.3.2 - Ambiente de Contêiner</h1><p>Essa página descreve os recursos disponíveis para contêineres no ambiente de contêiner.</p><h2 id=ambiente-de-contêiner>Ambiente de contêiner</h2><p>O ambiente de contêiner do Kubernetes fornece recursos importantes para contêineres:</p><ul><li>Um sistema de arquivos, que é a combinação de uma <a href=/docs/concepts/containers/images/>imagem</a> e um ou mais <a href=/docs/concepts/storage/volumes/>volumes</a>.</li><li>Informação sobre o contêiner propriamente.</li><li>Informação sobre outros objetos no cluster.</li></ul><h3 id=informação-de-contêiner>Informação de contêiner</h3><p>O <em>hostname</em> de um contêiner é o nome do Pod em que o contêiner está executando.
Isso é disponibilizado através do comando <code>hostname</code> ou da função <a href=https://man7.org/linux/man-pages/man2/gethostname.2.html><code>gethostname</code></a> chamada na libc.</p><p>O nome do Pod e o Namespace são expostos como variáveis de ambiente através de um mecanismo chamado <a href=/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information/>downward API</a>.</p><p>Variáveis de ambiente definidas pelo usuário a partir da definição do Pod também são disponíveis para o contêiner, assim como qualquer variável de ambiente especificada estáticamente na imagem Docker.</p><h3 id=informação-do-cluster>Informação do cluster</h3><p>Uma lista de todos os serviços que estão executando quando um contêiner foi criado é disponibilizada para o contêiner como variáveis de ambiente.
Essas variáveis de ambiente são compatíveis com a funcionalidade <em>docker link</em> do Docker.</p><p>Para um serviço nomeado <em>foo</em> que mapeia para um contêiner nomeado <em>bar</em>, as seguintes variáveis são definidas:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#b8860b>FOO_SERVICE_HOST</span><span style=color:#666>=</span>&lt;o host em que o serviço está executando&gt;
</span></span><span style=display:flex><span><span style=color:#b8860b>FOO_SERVICE_PORT</span><span style=color:#666>=</span>&lt;a porta em que o serviço está executando&gt;
</span></span></code></pre></div><p>Serviços possuem endereço IP dedicado e são disponibilizados para o contêiner via DNS,
se possuírem <a href=https://releases.k8s.io/v1.25.0/cluster/addons/dns/>DNS addon</a> habilitado.</p><h2 id=próximos-passos>Próximos passos</h2><ul><li>Aprenda mais sobre <a href=/docs/concepts/containers/container-lifecycle-hooks/>hooks de ciclo de vida do contêiner</a>.</li><li>Obtenha experiência prática
<a href=/docs/tasks/configure-pod-container/attach-handler-lifecycle-event/>anexando manipuladores a eventos de ciclo de vida do contêiner</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-a858027489648786a3b16264e451272b>3.3.3 - Classes de execução</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.20 [stable]</code></div><p>Essa página descreve o recurso <em>RuntimeClass</em> e a seleção do mecanismo do agente de execução.</p><p>RuntimeClass é uma funcionalidade para selecionar as configurações do agente de execução do contêiner.
A configuração do agente de execução de contêineres é usada para executar os contêineres de um Pod.</p><h2 id=motivação>Motivação</h2><p>Você pode configurar um <em>RuntimeClass</em> diferente entre os diferentes Pods para prover
um equilíbrio entre performance versus segurança. Por exemplo, se parte de sua carga de
trabalho necessita de um alto nível de garantia de segurança da informação, você pode
optar em executar esses Pods em um agente de execução que usa virtualização de hardware.
Você então terá o benefício do isolamento extra de um agente de execução alternativo, ao
custo de uma latência adicional.</p><p>Você pode ainda usar um <em>RuntimeClass</em> para executar diferentes Pods com o mesmo agente
de execução de contêineres mas com diferentes configurações.</p><h2 id=configuração>Configuração</h2><ol><li>Configure a implementação do CRI nos nós (depende do agente de execução)</li><li>Crie o recurso RuntimeClass correspondente.</li></ol><h3 id=1-configure-a-implementação-do-cri-nos-nós>1. Configure a implementação do CRI nos nós</h3><p>As configurações disponíveis através do RuntimeClass sáo dependentes da implementação do
<em>Container Runtime Interface</em> (<a class=glossary-tooltip title='Uma API para agentes de execução de contêineres se integrarem com o kubelet' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/components/#container-runtime target=_blank aria-label='Container runtime interface (CRI)'>Container runtime interface (CRI)</a>). Veja a documentação correspondente <a href=#configura%C3%A7%C3%A3o-do-cri>abaixo</a> para a
sua implementação CRI para verificar como configurar.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> RuntimeClass assume uma configuração homogênea de nós entre todo o cluster por padrão
(o que significa que todos os nós estão configurados do mesmo jeito referente aos agentes de
execução). Para suportar configurações heterogêneas, veja <a href=#associa%C3%A7%C3%A3o>Associação</a> abaixo.</div><p>As configurações possuem um nome <code>handler</code> correspondente, referenciado pelo RuntimeClass.
Esse nome deve ser um valor DNS 1123 válido (letras, números e o carácter <code>-</code>).</p><h3 id=2-crie-o-recurso-runtimeclass-correspondente>2. Crie o recurso RuntimeClass correspondente</h3><p>As etapas de configuração no passo 1 devem todas estar associadas a um nome para o campo <code>handler</code>
que identifica a configuração. Para cada um, crie o objeto RuntimeClass correspondente.</p><p>O recurso RuntimeClass atualmente possui apenas 2 campos significativos: o nome do RuntimeClass
(<code>metadata.name</code>) e o agente (<code>handler</code>). A definição do objeto se parece conforme a seguir:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>node.k8s.io/v1 <span style=color:#bbb> </span><span style=color:#080;font-style:italic># RuntimeClass é definido no grupo de API node.k8s.io</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>RuntimeClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myclass <span style=color:#bbb> </span><span style=color:#080;font-style:italic># O nome que o RuntimeClass será chamado como</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># RuntimeClass é um recurso global, e não possui namespace.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>handler</span>:<span style=color:#bbb> </span>myconfiguration <span style=color:#bbb> </span><span style=color:#080;font-style:italic># Nome da configuração CRI correspondente</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>O nome de um objeto RuntimeClass deve ser um
<a href=/pt-br/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>nome de subdomínio DNS</a> válido.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> É recomendado que operações de escrita no objeto RuntimeClass (criar/atualizar/patch/apagar)
sejam restritas a administradores do cluster. Isso geralmente é o padrão. Veja <a href=/docs/reference/access-authn-authz/authorization/>Visão Geral
de autorizações</a> para maiores detalhes.</div><h2 id=uso>Uso</h2><p>Uma vez que as classes de execução estão configuradas no cluster, usar elas é relativamente
simples. Especifique um <code>runtimeClassName</code> na especificação do Pod. Por exemplo:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>runtimeClassName</span>:<span style=color:#bbb> </span>myclass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Isso irá instruir o kubelet a usar o RuntimeClass nomeado acima (myclass) para esse Pod. Se
o nome do RuntimeClass não existir, ou o CRI não puder executar a solicitação, o Pod entrará na <a href=/docs/concepts/workloads/pods/pod-lifecycle/#pod-phase>fase
final</a> <code>Failed</code>. Procure por um
<a href=/docs/tasks/debug-application-cluster/debug-application-introspection/>evento</a> correspondente
para uma mensagem de erro.</p><p>Se nenhum <code>runtimeClassName</code> for especificado, o RuntimeHandler padrão será utilizado, que é equivalente
ao comportamento quando a funcionalidade de RuntimeClass está desativada.</p><h3 id=configuração-do-cri>Configuração do CRI</h3><p>Para maiores detalhes de configuração dos agentes de execução CRI, veja <a href=/docs/setup/production-environment/container-runtimes/>instalação do CRI</a>.</p><h4 id=dockershim>dockershim</h4><p>O CRI dockershim embutido no Kubernetes não suporta outros agentes de execução.</p><h4 id=hahahugoshortcode-s4-hbhb><a class=glossary-tooltip title='Um agente de execução de contêiner com enfase em simplicidade, robustez e portabilidade' data-toggle=tooltip data-placement=top href=https://containerd.io/docs/ target=_blank aria-label=containerd>containerd</a></h4><p>Agentes de execução são configurados através da configuração do containerd em
<code>/etc/containerd/config.toml</code>. Agentes válidos são configurados sob a seção de <code>runtimes</code>:</p><pre tabindex=0><code>[plugins.&#34;io.containerd.grpc.v1.cri&#34;.containerd.runtimes.${HANDLER_NAME}]
</code></pre><p>Veja a documentação de configuração do containerd para maiores detalhes:
<a href=https://github.com/containerd/containerd/blob/main/docs/cri/config.md>https://github.com/containerd/containerd/blob/main/docs/cri/config.md</a></p><h4 id=hahahugoshortcode-s5-hbhb><a class=glossary-tooltip title='Um agente de execução leve de contêineres criado especificamente para o Kubernetes' data-toggle=tooltip data-placement=top href=https://cri-o.io/#what-is-cri-o target=_blank aria-label=CRI-O>CRI-O</a></h4><p>Agentes de execução são configurados através da configuração do CRI-O em <code>/etc/crio/crio.conf</code>.
Agentes válidos são configurados na seção <a href=https://github.com/cri-o/cri-o/blob/master/docs/crio.conf.5.md#crioruntime-table>crio.runtime
table</a>:</p><pre tabindex=0><code>[crio.runtime.runtimes.${HANDLER_NAME}]
  runtime_path = &#34;${PATH_TO_BINARY}&#34;
</code></pre><p>Veja a <a href=https://raw.githubusercontent.com/cri-o/cri-o/9f11d1d/docs/crio.conf.5.md>documentação de configuração</a> do CRI-O para maiores detalhes.</p><h2 id=associação>Associação</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.16 [beta]</code></div><p>Ao especificar o campo <code>scheduling</code> para um RuntimeClass, você pode colocar limites e
garantir que os Pods executando dentro de uma RuntimeClass sejam associados a nós que
suportem eles. Se o <code>scheduling</code> não estiver configurado, assume-se que esse RuntimeClass
é suportado por todos os nós.</p><p>Para garantir que os Pods sejam executados em um nó que suporte um RuntimeClass específico,
aquele conjunto de nós deve possuir uma marca/label padrão que é selecionado pelo campo
<code>runtimeclass.scheduling.nodeSelector</code>. O nodeSelector do RuntimeClass é combinado com o
nodeSelector do Pod em tempo de admissão, obtendo a intersecção do conjunto de nós selecionado
por cada. Se existir um conflito, o pod será rejeitado.</p><p>Se os nós suportados possuírem marcação de restrição para prevenir outros Pods com uma
classe de execução diferente de executar no nó, você pode adicionar o campo <code>tolerations</code>
ao objeto RuntimeClass. Assim como com o <code>nodeSelector</code>, o <code>tolerations</code> é combinado com
o campo <code>tolerations</code> do Pod em tempo de admissão, efetivamente pegando a intersecção do
conjunto de nós aplicáveis para cada.</p><p>Para saber mais sobre a configuração de seleção de nós e tolerâncias, veja <a href=/docs/concepts/scheduling-eviction/assign-pod-node/>Associando Pods a
Nós</a>.</p><h3 id=sobrecarga-de-pods>Sobrecarga de Pods</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.18 [beta]</code></div><p>Você pode especificar os recursos extra que estão associados à execução de um Pod. Declarar esses
recursos extra permite ao cluster (incluindo o agendador/scheduler de pods) contabilizar por
esses recursos quando estiver decidindo sobre Pods e recursos. Para usar a contabilização
desses recursos extras, você deve estar com o <a href=/docs/reference/command-line-tools-reference/feature-gates/>feature gate</a>
PodOverhead habilitado (ele já está habilitado por padrão).</p><p>Os recursos extras utilizados são especificados no objeto RuntimeClass através do campo <code>overhead</code>.
Ao usar esses campos, você especifica o uso extra de recursos necessários para executar
Pods utilizando-se desse Runtimeclass e assim contabilizar esses recursos para o Kubernetes.</p><h2 id=próximos-passos>Próximos passos</h2><ul><li><a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/585-runtime-class/README.md>RuntimeClass Design</a></li><li><a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/585-runtime-class/README.md#runtimeclass-scheduling>RuntimeClass Scheduling Design</a></li><li>Leia mais sobre <a href=/docs/concepts/scheduling-eviction/pod-overhead/>Sobrecarga de Pods</a></li><li><a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-node/688-pod-overhead>PodOverhead Feature Design</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-e6941d969d81540208a3e78bc56f43bc>3.3.4 - Hooks de Ciclo de Vida do Contêiner</h1><p>Essa página descreve como os contêineres gerenciados pelo <em>kubelet</em> podem usar a estrutura de <em>hook</em> de ciclo de vida do contêiner para executar código acionado por eventos durante seu ciclo de vida de gerenciamento.</p><h2 id=visão-geral>Visão Geral</h2><p>Análogo a muitas estruturas de linguagem de programação que tem <em>hooks</em> de ciclo de vida de componentes, como angular,
o Kubernetes fornece aos contêineres <em>hooks</em> de ciclo de vida.
Os <em>hooks</em> permitem que os contêineres estejam cientes dos eventos em seu ciclo de vida de gerenciamento
e executem código implementado em um manipulador quando o <em>hook</em> de ciclo de vida correspondente é executado.</p><h2 id=hooks-do-contêiner>Hooks do contêiner</h2><p>Existem dois <em>hooks</em> que são expostos para os contêiners:</p><p><code>PostStart</code></p><p>Este <em>hook</em> é executado imediatamente após um contêiner ser criado.
Entretanto, não há garantia que o <em>hook</em> será executado antes do ENTRYPOINT do contêiner.
Nenhum parâmetro é passado para o manipulador.</p><p><code>PreStop</code></p><p>Esse <em>hook</em> é chamado imediatamente antes de um contêiner ser encerrado devido a uma solicitação de API ou um gerenciamento de evento como liveness/startup probe failure, preemption, resource contention e outros.
Uma chamada ao <em>hook</em> <code>PreStop</code> falha se o contêiner já está em um estado finalizado ou concluído e o <em>hook</em> deve ser concluído antes que o sinal TERM seja enviado para parar o contêiner. A contagem regressiva do período de tolerância de término do Pod começa antes que o <em>hook</em> <code>PreStop</code> seja executado, portanto, independentemente do resultado do manipulador, o contêiner será encerrado dentro do período de tolerância de encerramento do Pod. Nenhum parâmetro é passado para o manipulador.</p><p>Uma descrição mais detalhada do comportamento de término pode ser encontrada em <a href=/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination>Término de Pods</a>.</p><h3 id=implementações-de-manipulador-de-hook>Implementações de manipulador de hook</h3><p>Os contêineres podem acessar um <em>hook</em> implementando e registrando um manipulador para esse <em>hook</em>.
Existem dois tipos de manipuladores de <em>hooks</em> que podem ser implementados para contêineres:</p><ul><li>Exec - Executa um comando específico, como <code>pre-stop.sh</code>, dentro dos cgroups e Namespaces do contêiner.</li><li>HTTP - Executa uma requisição HTTP em um endpoint específico do contêiner.</li></ul><h3 id=execução-do-manipulador-de-hook>Execução do manipulador de hook</h3><p>Quando um <em>hook</em> de gerenciamento de ciclo de vida do contêiner é chamado, o sistema de gerenciamento do Kubernetes executa o manipulador de acordo com a ação do <em>hook</em>, <code>httpGet</code> e <code>tcpSocket</code> são executados pelo processo kubelet e <code>exec</code> é executado pelo contêiner.</p><p>As chamadas do manipulador do <em>hook</em> são síncronas no contexto do Pod que contém o contêiner.
Isso significa que para um <em>hook</em> <code>PostStart</code>, o ENTRYPOINT do contêiner e o <em>hook</em> disparam de forma assíncrona.
No entanto, se o <em>hook</em> demorar muito para ser executado ou travar, o contêiner não consegue atingir o estado <code>running</code>.</p><p>Os <em>hooks</em> <code>PreStop</code> não são executados de forma assíncrona a partir do sinal para parar o contêiner, o <em>hook</em> precisa finalizar a sua execução antes que o sinal TERM possa ser enviado.
Se um <em>hook</em> <code>PreStop</code> travar durante a execução, a fase do Pod será <code>Terminating</code> e permanecerá até que o Pod seja morto após seu <code>terminationGracePeriodSeconds</code> expirar. Esse período de tolerância se aplica ao tempo total necessário
para o <em>hook</em> <code>PreStop</code>executar e para o contêiner parar normalmente.
Se por exemplo, o <code>terminationGracePeriodSeconds</code> é 60, e o <em>hook</em> leva 55 segundos para ser concluído, e o contêiner leva 10 segundos para parar normalmente após receber o sinal, então o contêiner será morto antes que possa parar
normalmente, uma vez que o <code>terminationGracePeriodSeconds</code> é menor que o tempo total (55 + 10) que é necessário para que essas duas coisas aconteçam.</p><p>Se um <em>hook</em> <code>PostStart</code> ou <code>PreStop</code> falhar, ele mata o contêiner.</p><p>Os usuários devem tornar seus <em>hooks</em> o mais leve possíveis.
Há casos, no entanto, em que comandos de longa duração fazem sentido, como ao salvar o estado
antes de parar um contêiner.</p><h3 id=garantias-de-entrega-de-hooks>Garantias de entrega de <em>hooks</em></h3><p>A entrega do <em>hook</em> é destinada a acontecer <em>pelo menos uma vez</em>,
o que quer dizer que um <em>hook</em> pode ser chamado várias vezes para qualquer evento,
como para <code>PostStart</code> ou <code>PreStop</code>.
Depende da implementação do <em>hook</em> lidar com isso corretamente.</p><p>Geralmente, apenas entregas únicas são feitas.
Se, por exemplo, um receptor de <em>hook</em> HTTP estiver inativo e não puder receber tráfego,
não há tentativa de reenviar.
Em alguns casos raros, no entanto, pode ocorrer uma entrega dupla.
Por exemplo, se um kubelet reiniciar no meio do envio de um <em>hook</em>, o <em>hook</em> pode ser
reenviado depois que o kubelet voltar a funcionar.</p><h3 id=depurando-manipuladores-de-hooks>Depurando manipuladores de <em>hooks</em></h3><p>Os logs para um manipulador de <em>hook</em> não são expostos em eventos de Pod.
Se um manipulador falhar por algum motivo, ele transmitirá um evento.
Para <code>PostStart</code> é o evento <code>FailedPostStartHook</code> e para <code>PreStop</code> é o evento
<code>FailedPreStopHook</code>.
Você pode ver esses eventos executando <code>kubectl describe pod &lt;nome_do_pod></code>.
Aqui está um exemplo de saída de eventos da execução deste comando:</p><pre tabindex=0><code>Events:
  FirstSeen  LastSeen  Count  From                                                   SubObjectPath          Type      Reason               Message
  ---------  --------  -----  ----                                                   -------------          --------  ------               -------
  1m         1m        1      {default-scheduler }                                                          Normal    Scheduled            Successfully assigned test-1730497541-cq1d2 to gke-test-cluster-default-pool-a07e5d30-siqd
  1m         1m        1      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}  spec.containers{main}  Normal    Pulling              pulling image &#34;test:1.0&#34;
  1m         1m        1      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}  spec.containers{main}  Normal    Created              Created container with docker id 5c6a256a2567; Security:[seccomp=unconfined]
  1m         1m        1      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}  spec.containers{main}  Normal    Pulled               Successfully pulled image &#34;test:1.0&#34;
  1m         1m        1      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}  spec.containers{main}  Normal    Started              Started container with docker id 5c6a256a2567
  38s        38s       1      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}  spec.containers{main}  Normal    Killing              Killing container with docker id 5c6a256a2567: PostStart handler: Error executing in Docker Container: 1
  37s        37s       1      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}  spec.containers{main}  Normal    Killing              Killing container with docker id 8df9fdfd7054: PostStart handler: Error executing in Docker Container: 1
  38s        37s       2      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}                         Warning   FailedSync           Error syncing pod, skipping: failed to &#34;StartContainer&#34; for &#34;main&#34; with RunContainerError: &#34;PostStart handler: Error executing in Docker Container: 1&#34;
  1m         22s       2      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}  spec.containers{main}  Warning   FailedPostStartHook
</code></pre><h2 id=próximos-passos>Próximos passos</h2><ul><li>Saiba mais sobre o <a href=/docs/concepts/containers/container-environment/>Ambiente de contêiner</a>.</li><li>Obtenha experiência prática
<a href=/docs/tasks/configure-pod-container/attach-handler-lifecycle-event/>anexando manipuladores a eventos de ciclo de vida do contêiner</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-0a0a7eca3e302a3c08f8c85e15d337fd>3.4 - Serviços, balanceamento de carga e conectividade</h1><div class=lead>Conceitos e recursos por trás da conectividade no Kubernetes.</div><p>A conectividade do Kubernetes trata quatro preocupações:</p><ul><li>Contêineres em um Pod se comunicam via interface <em>loopback</em>.</li><li>A conectividade do cluster provê a comunicação entre diferentes Pods.</li><li>O recurso de <em>Service</em> permite a você expor uma aplicação executando em um Pod,
de forma a ser alcançável de fora de seu cluster.</li><li>Você também pode usar os <em>Services</em> para publicar serviços de consumo interno do
seu cluster.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-ded1daafdcd293023ee333728007ca61>3.4.1 - Políticas de rede</h1><p>Se você deseja controlar o fluxo do tráfego de rede no nível do endereço IP ou de portas TCP e UDP
(camadas OSI 3 e 4) então você deve considerar usar Políticas de rede (<code>NetworkPolicies</code>) do Kubernetes para aplicações
no seu cluster. <code>NetworkPolicy</code> é um objeto focado em aplicações/experiência do desenvolvedor
que permite especificar como é permitido a um <a class=glossary-tooltip title='O menor e mais simples objeto Kubernetes. Um Pod representa um conjunto de contêineres em execução no seu cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/ target=_blank aria-label=pod>pod</a>
comunicar-se com várias "entidades" de rede.</p><p>As entidades que um Pod pode se comunicar são identificadas através de uma combinação dos 3
identificadores à seguir:</p><ol><li>Outros pods que são permitidos (exceção: um pod não pode bloquear a si próprio)</li><li>Namespaces que são permitidos</li><li>Blocos de IP (exceção: o tráfego de e para o nó que um Pod está executando sempre é permitido,
independentemente do endereço IP do Pod ou do Nó)</li></ol><p>Quando definimos uma política de rede baseada em pod ou namespace, utiliza-se um <a class=glossary-tooltip title='Permite ao usuário filtrar uma lista de recursos com base em rótulos (labels).' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/labels/ target=_blank aria-label=selector>selector</a>
para especificar qual tráfego é permitido de e para o(s) Pod(s) que correspondem ao seletor.</p><p>Quando uma política de redes baseada em IP é criada, nós definimos a política baseada em blocos de IP (faixas CIDR).</p><h2 id=pré-requisitos>Pré requisitos</h2><p>As políticas de rede são implementadas pelo <a href=/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/>plugin de redes</a>. Para usar
uma política de redes, você deve usar uma solução de redes que suporte o objeto <code>NetworkPolicy</code>.
A criação de um objeto <code>NetworkPolicy</code> sem um controlador que implemente essas regras não tem efeito.</p><h2 id=pods-isolados-e-não-isolados>Pods isolados e não isolados</h2><p>Por padrão, pods não são isolados; eles aceitam tráfego de qualquer origem.</p><p>Os pods tornam-se isolados ao existir uma <code>NetworkPolicy</code> que selecione eles. Uma vez que
exista qualquer <code>NetworkPolicy</code> no namespace selecionando um pod em específico, aquele pod
irá rejeitar qualquer conexão não permitida por qualquer <code>NetworkPolicy</code>. (Outros pod no mesmo
namespace que não são selecionados por nenhuma outra <code>NetworkPolicy</code> irão continuar aceitando
todo tráfego de rede.)</p><p>As políticas de rede não conflitam; elas são aditivas. Se qualquer política selecionar um pod,
o pod torna-se restrito ao que é permitido pela união das regras de entrada/saída de tráfego definidas
nas políticas. Assim, a ordem de avaliação não afeta o resultado da política.</p><p>Para o fluxo de rede entre dois pods ser permitido, tanto a política de saída no pod de origem
e a política de entrada no pod de destino devem permitir o tráfego. Se a política de saída na
origem, ou a política de entrada no destino negar o tráfego, o tráfego será bloqueado.</p><h2 id=networkpolicy-resource>O recurso NetworkPolicy</h2><p>Veja a referência <a href=/docs/reference/generated/kubernetes-api/v1.25/#networkpolicy-v1-networking-k8s-io>NetworkPolicy</a> para uma definição completa do recurso.</p><p>Uma <code>NetworkPolicy</code> de exemplo é similar ao abaixo:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>NetworkPolicy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-network-policy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>podSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>role</span>:<span style=color:#bbb> </span>db<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>policyTypes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- Ingress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- Egress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ingress</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>from</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>ipBlock</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cidr</span>:<span style=color:#bbb> </span><span style=color:#666>172.17.0.0</span>/16<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>except</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:#666>172.17.1.0</span>/24<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>namespaceSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>project</span>:<span style=color:#bbb> </span>myproject<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>podSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>role</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>6379</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>egress</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>to</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>ipBlock</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cidr</span>:<span style=color:#bbb> </span><span style=color:#666>10.0.0.0</span>/24<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>5978</span><span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Criar esse objeto no seu cluster não terá efeito a não ser que você escolha uma
solução de redes que suporte políticas de rede.</div><p><strong>Campos obrigatórios</strong>: Assim como todas as outras configurações do Kubernetes, uma <code>NetworkPolicy</code>
necessita dos campos <code>apiVersion</code>, <code>kind</code> e <code>metadata</code>. Para maiores informações sobre
trabalhar com arquivos de configuração, veja
<a href=/docs/tasks/configure-pod-container/configure-pod-configmap/>Configurando containeres usando ConfigMap</a>,
e <a href=/docs/concepts/overview/working-with-objects/object-management>Gerenciamento de objetos</a>.</p><p><strong>spec</strong>: A <a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-architecture/api-conventions.md#spec-and-status>spec</a> contém todas as informações necessárias
para definir uma política de redes em um namespace.</p><p><strong>podSelector</strong>: Cada <code>NetworkPolicy</code> inclui um <code>podSelector</code> que seleciona o grupo de pods
que a política se aplica. A política acima seleciona os pods com a <em>label</em> "role=db". Um <code>podSelector</code>
vazio seleciona todos os pods no namespace.</p><p><strong>policyTypes</strong>: Cada <code>NetworkPolicy</code> inclui uma lista de <code>policyTypes</code> que pode incluir <code>Ingress</code>,
<code>Egress</code> ou ambos. O campo <code>policyTypes</code> indica se a política se aplica ao tráfego de entrada
com destino aos pods selecionados, o tráfego de saída com origem dos pods selecionados ou ambos.
Se nenhum <code>policyType</code> for definido então por padrão o tipo <code>Ingress</code> será sempre utilizado, e o
tipo <code>Egress</code> será configurado apenas se o objeto contiver alguma regra de saída. (campo <code>egress</code> a seguir).</p><p><strong>ingress</strong>: Cada <code>NetworkPolicy</code> pode incluir uma lista de regras de entrada permitidas através do campo <code>ingress</code>.
Cada regra permite o tráfego que corresponde simultaneamente às sessões <code>from</code> (de) e <code>ports</code> (portas).
A política de exemplo acima contém uma regra simples, que corresponde ao tráfego em uma única porta,
de uma das três origens definidas, sendo a primeira definida via <code>ipBlock</code>, a segunda via <code>namespaceSelector</code> e
a terceira via <code>podSelector</code>.</p><p><strong>egress</strong>: Cada política pode incluir uma lista de regras de regras de saída permitidas através do campo <code>egress</code>.
Cada regra permite o tráfego que corresponde simultaneamente às sessões <code>to</code> (para) e <code>ports</code> (portas).
A política de exemplo acima contém uma regra simples, que corresponde ao tráfego destinado a uma
porta em qualquer destino pertencente à faixa de IPs em <code>10.0.0.0/24</code>.</p><p>Então a <code>NetworkPolicy</code> acima:</p><ol><li><p>Isola os pods no namespace "default" com a <em>label</em> "role=db" para ambos os tráfegos de entrada
e saída (se eles ainda não estavam isolados)</p></li><li><p>(Regras de entrada/ingress) permite conexões para todos os pods no namespace "default" com a <em>label</em> "role=db" na porta TCP 6379 de:</p><ul><li>qualquer pod no namespace "default" com a <em>label</em> "role=frontend"</li><li>qualquer pod em um namespace que tenha a <em>label</em> "project=myproject" (aqui cabe ressaltar que o namespace que deve ter a <em>label</em> e não os pods dentro desse namespace)</li><li>IPs dentro das faixas 172.17.0.0–172.17.0.255 e 172.17.2.0–172.17.255.255 (ex.:, toda 172.17.0.0/16 exceto 172.17.1.0/24)</li></ul></li><li><p>(Regras de saída/egress) permite conexões de qualquer pod no namespace "default" com a <em>label</em>
"role=db" para a faixa de destino 10.0.0.0/24 na porta TCP 5978.</p></li></ol><p>Veja o tutorial <a href=/docs/tasks/administer-cluster/declare-network-policy/>Declarando uma política de redes</a> para mais exemplos.</p><h2 id=comportamento-dos-seletores-to-e-from>Comportamento dos seletores <code>to</code> e <code>from</code></h2><p>Existem quatro tipos de seletores que podem ser especificados nas sessões <code>ingress.from</code> ou
<code>egress.to</code>:</p><p><strong>podSelector</strong>: Seleciona Pods no mesmo namespace que a política de rede foi criada, e que deve
ser permitido origens no tráfego de entrada ou destinos no tráfego de saída.</p><p><strong>namespaceSelector</strong>: Seleciona namespaces para o qual todos os Pods devem ser permitidos como
origens no caso de tráfego de entrada ou destino no tráfego de saída.</p><p><strong>namespaceSelector</strong> <em>e</em> <strong>podSelector</strong>: Uma entrada <code>to</code>/<code>from</code> única que permite especificar
ambos <code>namespaceSelector</code> e <code>podSelector</code> e seleciona um conjunto de Pods dentro de um namespace.
Seja cuidadoso em utilizar a sintaxe YAML correta; essa política:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ingress</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>from</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>namespaceSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb> </span>alice<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>podSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>role</span>:<span style=color:#bbb> </span>client<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span></code></pre></div><p>contém um único elemento <code>from</code> permitindo conexões de Pods com a label <code>role=client</code> em
namespaces com a <em>label</em> <code>user=alice</code>. Mas <em>essa</em> política:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ingress</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>from</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>namespaceSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb> </span>alice<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>podSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>role</span>:<span style=color:#bbb> </span>client<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span></code></pre></div><p>contém dois elementos no conjunto <code>from</code> e permite conexões de Pods no namespace local com
a <em>label</em> <code>role=client</code>, <em>OU</em> de qualquer outro Pod em qualquer outro namespace que tenha
a label <code>user=alice</code>.</p><p>Quando estiver em dúvida, utilize o comando <code>kubectl describe</code> para verificar como o
Kubernetes interpretou a política.</p><p><strong>ipBlock</strong>: Isso seleciona um conjunto particular de faixas de IP a serem permitidos como
origens no caso de entrada ou destinos no caso de saída. Devem ser considerados IPs externos
ao cluster, uma vez que os IPs dos Pods são efêmeros e imprevisíveis.</p><p>Os mecanismos de entrada e saída do cluster geralmente requerem que os IPs de origem ou destino
sejam reescritos. Em casos em que isso aconteça, não é definido se deve acontecer antes ou
depois do processamento da <code>NetworkPolicy</code> que corresponde a esse tráfego, e o comportamento
pode ser diferente para cada plugin de rede, provedor de nuvem, implementação de <code>Service</code>, etc.</p><p>No caso de tráfego de entrada, isso significa que em alguns casos você pode filtrar os pacotes
de entrada baseado no IP de origem atual, enquanto que em outros casos o IP de origem que
a <code>NetworkPolicy</code> atua pode ser o IP de um <code>LoadBalancer</code> ou do Nó em que o Pod está executando.</p><p>No caso de tráfego de saída, isso significa que conexões de Pods para <code>Services</code> que são reescritos
para IPs externos ao cluster podem ou não estar sujeitos a políticas baseadas no campo <code>ipBlock</code>.</p><h2 id=políticas-padrão>Políticas padrão</h2><p>Por padrão, se nenhuma política existir no namespace, então todo o tráfego de entrada e saída é
permitido de e para os pods nesse namespace. Os exemplos a seguir permitem a você mudar o
comportamento padrão nesse namespace.</p><h3 id=bloqueio-padrão-de-todo-tráfego-de-entrada>Bloqueio padrão de todo tráfego de entrada</h3><p>Você pode criar uma política padrão de isolamento para um namespace criando um objeto <code>NetworkPolicy</code>
que seleciona todos os pods mas não permite o tráfego de entrada para esses pods.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/pt-br/examples/service/networking/network-policy-default-deny-ingress.yaml download=service/networking/network-policy-default-deny-ingress.yaml><code>service/networking/network-policy-default-deny-ingress.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("service-networking-network-policy-default-deny-ingress-yaml")' title="Copy service/networking/network-policy-default-deny-ingress.yaml to clipboard"></img></div><div class=includecode id=service-networking-network-policy-default-deny-ingress-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>NetworkPolicy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default-deny-ingress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>podSelector</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>policyTypes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- Ingress<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Isso garante que mesmo pods que não são selecionados por nenhuma outra política de rede ainda
serão isolados. Essa política não muda o comportamento padrão de isolamento de tráfego de saída
nesse namespace.</p><h3 id=permitir-por-padrão-todo-tráfego-de-entrada>Permitir por padrão todo tráfego de entrada</h3><p>Se você deseja permitir todo o tráfego de todos os pods em um namespace (mesmo que políticas que
sejam adicionadas faça com que alguns pods sejam tratados como "isolados"), você pode criar
uma política que permite explicitamente todo o tráfego naquele namespace.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/pt-br/examples/service/networking/network-policy-allow-all-ingress.yaml download=service/networking/network-policy-allow-all-ingress.yaml><code>service/networking/network-policy-allow-all-ingress.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("service-networking-network-policy-allow-all-ingress-yaml")' title="Copy service/networking/network-policy-allow-all-ingress.yaml to clipboard"></img></div><div class=includecode id=service-networking-network-policy-allow-all-ingress-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>NetworkPolicy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>allow-all-ingress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>podSelector</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ingress</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- {}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>policyTypes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- Ingress<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><h3 id=bloqueio-padrão-de-todo-tráfego-de-saída>Bloqueio padrão de todo tráfego de saída</h3><p>Você pode criar uma política de isolamento de saída padrão para um namespace criando uma
política de redes que selecione todos os pods, mas não permita o tráfego de saída a partir
de nenhum desses pods.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/pt-br/examples/service/networking/network-policy-default-deny-egress.yaml download=service/networking/network-policy-default-deny-egress.yaml><code>service/networking/network-policy-default-deny-egress.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("service-networking-network-policy-default-deny-egress-yaml")' title="Copy service/networking/network-policy-default-deny-egress.yaml to clipboard"></img></div><div class=includecode id=service-networking-network-policy-default-deny-egress-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>NetworkPolicy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default-deny-egress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>podSelector</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>policyTypes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- Egress<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Isso garante que mesmo pods que não são selecionados por outra política de rede não seja permitido
tráfego de saída. Essa política não muda o comportamento padrão de tráfego de entrada.</p><h3 id=permitir-por-padrão-todo-tráfego-de-saída>Permitir por padrão todo tráfego de saída</h3><p>Caso você queira permitir todo o tráfego de todos os pods em um namespace (mesmo que políticas sejam
adicionadas e cause com que alguns pods sejam tratados como "isolados"), você pode criar uma
política explicita que permite todo o tráfego de saída no namespace.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/pt-br/examples/service/networking/network-policy-allow-all-egress.yaml download=service/networking/network-policy-allow-all-egress.yaml><code>service/networking/network-policy-allow-all-egress.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("service-networking-network-policy-allow-all-egress-yaml")' title="Copy service/networking/network-policy-allow-all-egress.yaml to clipboard"></img></div><div class=includecode id=service-networking-network-policy-allow-all-egress-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>NetworkPolicy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>allow-all-egress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>podSelector</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>egress</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- {}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>policyTypes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- Egress<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><h3 id=bloqueio-padrão-de-todo-tráfego-de-entrada-e-saída>Bloqueio padrão de todo tráfego de entrada e saída</h3><p>Você pode criar uma política padrão em um namespace que previne todo o tráfego de entrada
E saída criando a política a seguir no namespace.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/pt-br/examples/service/networking/network-policy-default-deny-all.yaml download=service/networking/network-policy-default-deny-all.yaml><code>service/networking/network-policy-default-deny-all.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("service-networking-network-policy-default-deny-all-yaml")' title="Copy service/networking/network-policy-default-deny-all.yaml to clipboard"></img></div><div class=includecode id=service-networking-network-policy-default-deny-all-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>NetworkPolicy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default-deny-all<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>podSelector</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>policyTypes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- Ingress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- Egress<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Isso garante que mesmo pods que não são selecionados por nenhuma outra política de redes não
possuam permissão de tráfego de entrada ou saída.</p><h2 id=selecionando-uma-faixa-de-portas>Selecionando uma faixa de portas</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.21 [alpha]</code></div><p>Ao escrever uma política de redes, você pode selecionar uma faixa de portas ao invés de uma
porta única, utilizando-se do campo <code>endPort</code> conforme a seguir:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>NetworkPolicy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>multi-port-egress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>podSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>role</span>:<span style=color:#bbb> </span>db<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>policyTypes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- Egress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>egress</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>to</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>ipBlock</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cidr</span>:<span style=color:#bbb> </span><span style=color:#666>10.0.0.0</span>/24<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>32000</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>endPort</span>:<span style=color:#bbb> </span><span style=color:#666>32768</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>A regra acima permite a qualquer Pod com a <em>label</em> "role=db" no namespace <code>default</code> de se comunicar
com qualquer IP na faixa <code>10.0.0.0/24</code> através de protocolo TCP, desde que a porta de destino
esteja na faixa entre 32000 e 32768.</p><p>As seguintes restrições aplicam-se ao se utilizar esse campo:</p><ul><li>Por ser uma funcionalidade "alpha", ela é desativada por padrão. Para habilitar o campo <code>endPort</code>
no cluster, você (ou o seu administrador do cluster) deve habilitar o <a href=/docs/reference/command-line-tools-reference/feature-gates/>feature gate</a> <code>NetworkPolicyEndPort</code> no <code>kube-apiserver</code> com a flag <code>--feature-gates=NetworkPolicyEndPort=true,...</code>.</li><li>O valor de <code>endPort</code> deve ser igual ou maior ao valor do campo <code>port</code>.</li><li>O campo <code>endPort</code> só pode ser definido se o campo <code>port</code> também for definido.</li><li>Ambos os campos <code>port</code> e <code>endPort</code> devem ser números.</li></ul><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Seu cluster deve utilizar um plugin <a class=glossary-tooltip title='Plugins Container network interface (CNI) são um tipo de plugin de Rede em conformidade com a especificação appc/CNI.' data-toggle=tooltip data-placement=top href=/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/ target=_blank aria-label=CNI>CNI</a>
que suporte o campo <code>endPort</code> na especificação da política de redes.</div><h2 id=selecionando-um-namespace-pelo-seu-nome>Selecionando um Namespace pelo seu nome</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes 1.21 [beta]</code></div><p>A camada de gerenciamento do Kubernetes configura uma <em>label</em> imutável <code>kubernetes.io/metadata.name</code> em
todos os namespaces, uma vez que o <a href=/docs/reference/command-line-tools-reference/feature-gates/>feature gate</a> esteja habilitado por padrão.
O valor dessa <em>label</em> é o nome do namespace.</p><p>Enquanto que um objeto <code>NetworkPolicy</code> não pode selecionar um namespace pelo seu nome através de
um campo específico, você pode utilizar essa <em>label</em> padrão para selecionar um namespace pelo seu nome.</p><h2 id=o-que-você-não-pode-fazer-com-networkpolicies-ao-menos-por-enquanto>O que você não pode fazer com <code>NetworkPolicies</code> (ao menos por enquanto!)</h2><p>Por enquanto no Kubernetes 1.25 as funcionalidades a seguir não existem
mas você pode conseguir implementar de forma alternativa utilizando componentes do Sistema Operacional
(como SELinux, OpenVSwitch, IPtables, etc) ou tecnologias da camada 7 OSI (Ingress controllers, implementações de service mesh) ou ainda <em>admission controllers</em>.
No caso do assunto "segurança de redes no Kubernetes" ser novo para você, vale notar que as
histórias de usuário a seguir ainda não podem ser implementadas:</p><ul><li>Forçar o tráfego interno do cluster passar por um gateway comum (pode ser implementado via service mesh ou outros proxies)</li><li>Qualquer coisa relacionada a TLS/mTLS (use um service mesh ou ingress controller para isso)</li><li>Políticas específicas a nível do nó kubernetes (você pode utilizar as notações de IP CIDR para isso, mas não pode selecionar nós Kubernetes por suas identidades)</li><li>Selecionar <code>Services</code> pelo seu nome (você pode, contudo, selecionar pods e namespaces por seus <a class=glossary-tooltip title='Tags objects with identifying attributes that are meaningful and relevant to users.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/labels target=_blank aria-label=labels>labels</a> o que torna-se uma solução de contorno viável).</li><li>Criação ou gerenciamento</li><li>Políticas padrão que são aplicadas a todos os namespaces e pods (existem alguns plugins externos do Kubernetes e projetos que podem fazer isso, e a comunidade está trabalhando nessa especificação).</li><li>Ferramental de testes para validação de políticas de redes.</li><li>Possibilidade de logar eventos de segurança de redes (conexões bloqueadas, aceitas). Existem plugins CNI que conseguem fazer isso à parte.</li><li>Possibilidade de explicitamente negar políticas de rede (o modelo das <code>NetworkPolicies</code> são "negar por padrão e conforme a necessidade, deve-se adicionar regras que permitam o tráfego).</li><li>Bloquear o tráfego que venha da interface de loopback/localhost ou que venham do nó em que o Pod se encontre.</li></ul><h2 id=próximos-passos>Próximos passos</h2><ul><li>Veja o tutorial <a href=/docs/tasks/administer-cluster/declare-network-policy/>Declarando políticas de redes</a> para mais exemplos.</li><li>Veja mais <a href=https://github.com/ahmetb/kubernetes-network-policy-recipes>cenários comuns e exemplos</a> de políticas de redes.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-f018f568c6723865753f150c3c59bdda>3.5 - Armazenamento</h1><div class=lead>Formas de fornecer armazenamento temporário e de longa duração a Pods em seu cluster.</div></div><div class=td-content><h1 id=pg-27795584640a03bd2024f1fe3b3ab754>3.5.1 - Volumes</h1><p>Os arquivos em disco em um contêiner são efêmeros, o que apresenta alguns problemas para
aplicações não triviais quando executadas em contêineres. Um problema é a perda de arquivos
quando um contêiner quebra. O kubelet reinicia o contêiner, mas em um estado limpo. Um segundo
problema ocorre ao compartilhar arquivos entre contêineres que são executados juntos em
um <code>Pod</code>. A abstração de <a class=glossary-tooltip title='Um diretório contendo dados, accessível aos contêineres em um pod.' data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/ target=_blank aria-label=volume>volume</a>
do Kubernetes resolve ambos os problemas. Sugere-se familiaridade com <a href=/docs/concepts/workloads/pods/>Pods</a> .</p><h2 id=contexto>Contexto</h2><p>Docker tem um conceito de <a href=https://docs.docker.com/storage/>volumes</a>, embora seja um pouco mais
simples e menos gerenciado. Um volume Docker é um diretório em disco ou em outro contêiner.
O Docker oferece drivers de volume, mas a funcionalidade é um pouco limitada.</p><p>O Kubernetes suporta muitos tipos de volumes. Um <a class=glossary-tooltip title='O menor e mais simples objeto Kubernetes. Um Pod representa um conjunto de contêineres em execução no seu cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/ target=_blank aria-label=Pod>Pod</a> é capaz de utilizar qualquer quantidade de tipos de volumes simultaneamente. Os tipos de volume efêmeros têm a mesma vida útil do pod, mas os volumes persistentes existem além da vida útil de um pod. Quando um pod deixa de existir, o Kubernetes destrói volumes efêmeros; no entanto, o Kubernetes não destrói volumes persistentes. Para qualquer tipo de volume em um determinado pod, os dados são preservados entre as reinicializações do contêiner.</p><p>Em sua essência, um volume é um diretório, eventualmente com alguns dados dentro dele, que é acessível aos contêineres de um Pod. Como esse diretório vem a ser, o meio que o suporta e o conteúdo do mesmo são determinados pelo tipo particular de volume utilizado.</p><p>Para utilizar um volume, especifique os volumes que serão disponibilizados para o Pod em <code>.spec.volumes</code> e declare onde montar esses volumes dentro dos contêineres em <code>.spec.containers[*].volumeMounts</code>. Um processo em um contêiner enxerga uma visualização do sistema de arquivos composta pelo do conteúdo inicial da <a class=glossary-tooltip title='Instância armazenada de um contêiner que contém o conjunto de softwares necessários para rodar uma aplicação.' data-toggle=tooltip data-placement=top href='/pt-br/docs/reference/glossary/?all=true#term-image' target=_blank aria-label='imagem do contêiner'>imagem do contêiner</a> mais os volumes (se definidos) montados dentro do contêiner. O processo enxerga um sistema de arquivos raiz que inicialmente corresponde ao conteúdo da imagem do contêiner. Qualquer gravação dentro dessa hierarquia do sistema de arquivos, se permitida, afetará o que esse processo enxerga quando ele executa um acesso subsequente ao sistema de arquivos. Os volumes são montados nos <a href=#using-subpath>caminhos especificados</a> dentro da imagem. Para cada contêiner definido em um Pod, você deve especificar independentemente onde montar cada volume utilizado pelo contêiner.</p><p>Volumes não podem ser montados dentro de outros volumes (mas você pode consultar <a href=#using-subpath>Utilizando subPath</a> para um mecanismo relacionado). Além disso, um volume não pode conter um link físico para qualquer outro dado em um volume diferente.</p><h2 id=volume-types>Tipos de Volumes</h2><p>Kubernetes suporta vários tipos de volumes.</p><h3 id=awselasticblockstore>awsElasticBlockStore</h3><p>Um volume <code>awsElasticBlockStore</code> monta um <a href=https://aws.amazon.com/ebs/>volume EBS</a> da Amazon Web Services (AWS) em seu pod. Ao contrário do <code>emptyDir</code>que é apagado quando um pod é removido, o conteúdo de um volume EBS é preservado e o volume é desmontado. Isto significa que um volume EBS pode ser previamente populado com dados e que os dados podem ser compartilhados entre Pods.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Você precisa criar um volume EBS usando <code>aws ec2 create-volume</code> ou pela API da AWS antes que você consiga utilizá-lo.</div><p>Existem algumas restrições ao utilizar um volume <code>awsElasticBlockStore</code>:</p><ul><li>Os nós nos quais os Pods estão sendo executados devem ser instâncias AWS EC2</li><li>Estas instâncias devem estar na mesma região e na mesma zona de disponibilidade que o volume EBS</li><li>O EBS suporta montar um volume em apenas uma única instância EC2</li></ul><h4 id=criando-um-volume-aws-ebs>Criando um volume AWS EBS</h4><p>Antes de poder utilizar um volume EBS com um pod, precisa criá-lo.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>aws ec2 create-volume --availability-zone<span style=color:#666>=</span>eu-west-1a --size<span style=color:#666>=</span><span style=color:#666>10</span> --volume-type<span style=color:#666>=</span>gp2
</span></span></code></pre></div><p>Certifique-se de que a zona corresponde à mesma zona em que criou o cluster. Verifique se o tamanho e o tipo de volume EBS são adequados para a sua utilização.</p><h4 id=exemplo-de-configuração-do-aws-ebs>Exemplo de configuração do AWS EBS</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-ebs<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/test-webserver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/test-ebs<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># Esse volume AWS EBS já deve existir.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>awsElasticBlockStore</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeID</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&lt;volume id&gt;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>fsType</span>:<span style=color:#bbb> </span>ext4<span style=color:#bbb>
</span></span></span></code></pre></div><p>Se o volume EBS estiver particionado, é possível informar o campo opcional <code>partition: "&lt;partition em umber>"</code> para especificar em que partição deve ser montado.</p><h4 id=migração-de-csi-do-aws-ebs>Migração de CSI do AWS EBS</h4><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.17 [beta]</code></div><p>Quando o recurso <code>CSIMigration</code> para <code>awsElasticBlockStore</code> está habilitado, todas as operações de plugin do tipo in-tree são redirecionadas para o driver Cointainer Storage Interface (CSI) <code>ebs.csi.aws.com</code>. Para usar esse recurso, o <a href=https://github.com/kubernetes-sigs/aws-ebs-csi-driver>driver CSI AWS EBS</a> deve estar instalado no cluster e os recursos beta <code>CSIMigration</code> e <code>CSIMigrationAWS</code> devem estar ativados.</p><h4 id=migração-csi-aws-ebs-concluída>Migração CSI AWS EBS concluída</h4><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.17 [alpha]</code></div><p>Para desabilitar o carregamento do plugin de armazenamento <code>awsElasticBlockStore</code> pelo gerenciador de controladores e pelo kubelet, defina a flag <code>InTreePluginAWSUnregister</code> como <code>true</code>.</p><h3 id=azuredisk>azureDisk</h3><p>O tipo de volume <code>azureDisk</code> monta um <a href=https://docs.microsoft.com/en-us/azure/aks/csi-storage-drivers>Disco de Dados</a> Microsoft Azure em um pod.</p><p>Para obter mais detalhes, consulte <a href=https://github.com/kubernetes/examples/tree/master/staging/volumes/azure_disk/README.md>plugin de volume <code>azureDisk</code></a>.</p><h4 id=migração-de-csi-do-azuredisk>Migração de CSI do azureDisk</h4><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.19 [beta]</code></div><p>Quando o recurso <code>CSIMigration</code> para <code>azureDisk</code> está habilitado, todas as operações de plugin do tipo in-tree são redirecionadas para o Driver de Cointêiner Storage Interface (CSI) <code>disk.csi.azure.com</code>. Para utilizar este recurso, o <a href=https://github.com/kubernetes-sigs/azuredisk-csi-driver>Driver CSI Azure Disk</a> deve estar instalado no cluster e os recursos <code>CSIMigration</code> e <code>CSIMigrationAzureDisk</code> devem estar ativados.</p><h4 id=migração-csi-azuredisk-concluída>Migração CSI azureDisk concluída</h4><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.21 [alpha]</code></div><p>Para desabilitar o carregamento do plugin de armazenamento <code>azureDisk</code> pelo gerenciador de controladores e pelo kubelet, defina a flag <code>InTreePluginAzureDiskUnregister</code> como <code>true</code>.</p><h3 id=azurefile>azureFile</h3><p>O tipo de volume <code>azureFile</code> monta um volume de arquivo Microsoft Azure (SMB 2.1 e 3.0) em um pod.</p><p>Para obter mais detalhes, consulte <a href=https://github.com/kubernetes/examples/tree/master/staging/volumes/azure_file/README.md>plugin de volume <code>azureFile</code></a>.</p><h4 id=migração-de-csi-azurefile>Migração de CSI azureFile</h4><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.21 [beta]</code></div><p>Quando o recurso <code>CSIMigration</code> para <code>azureFile</code> está habilitado, todas as operações de plugin do tipo in-tree são redirecionadas para o Driver de Cointainer Storage Interface (CSI) <code>file.csi.azure.com</code>. Para utilizar este recurso, o <a href=https://github.com/kubernetes-sigs/azurefile-csi-driver>Driver CSI do Azure Disk</a> deve estar instalado no cluster e as <a href=/docs/reference/command-line-tools-reference/feature-gates/>feature gates</a> <code>CSIMigration</code> e <code>CSIMigrationAzureFile</code> devem estar habilitadas.</p><p>O driver de CSI do Azure File não oferece suporte ao uso do mesmo volume por fsgroups diferentes, se a migração de CSI Azurefile estiver habilitada, o uso do mesmo volume por fsgroups diferentes não será suportado.</p><h4 id=migração-do-csi-azurefile-concluída>Migração do CSI azureFile concluída</h4><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.21 [alpha]</code></div><p>Para desabilitar o carregamento do plugin de armazenamento <code>azureFile</code> pelo gerenciador de controladores e pelo kubelet, defina a flag <code>InTreePluginAzureFileUnregister</code> como <code>true</code>.</p><h3 id=cephfs>cephfs</h3><p>Um volume <code>cephfs</code> permite que um volume CephFS existente seja montado no seu Pod. Ao contrário do <code>emptyDir</code> que é apagado quando um pod é removido, o conteúdo de um volume <code>cephfs</code> é preservado e o volume é simplesmente desmontado. Isto significa que um volume <code>cephfs</code> pode ser previamente populado com dados e que os dados podem ser compartilhados entre os Pods. O volume <code>cephfs</code> pode ser montado por vários gravadores simultaneamente.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Você deve ter seu próprio servidor Ceph funcionando com o compartilhamento acessível antes de poder utilizá-lo.</div><p>Consulte o <a href=https://github.com/kubernetes/examples/tree/master/volumes/cephfs/>exemplo CephFS</a> para mais detalhes.</p><h3 id=cinder>cinder</h3><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> O Kubernetes deve ser configurado com o provedor de nuvem OpenStack.</div><p>O tipo de volume <code>cinder</code> é utilizado para montar o volume do OpenStack Cinder no seu pod.</p><h4 id=exemplo-de-configuração-de-volume-cinder>Exemplo de configuração de volume Cinder</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-cinder<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/test-webserver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-cinder-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/test-cinder<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># Esse volume OpenStack já deve existir.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cinder</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeID</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&lt;volume id&gt;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>fsType</span>:<span style=color:#bbb> </span>ext4<span style=color:#bbb>
</span></span></span></code></pre></div><h4 id=migração-de-csi-openstack>Migração de CSI OpenStack</h4><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.21 [beta]</code></div><p>O recurso <code>CSIMigration</code> para o Cinder é ativado por padrão no Kubernetes 1.21. Ele redireciona todas as operações de plugin do tipo in-tree para o Driver de Cointainer Storage Interface (CSI) <code>cinder.csi.openstack.org</code>. O <a href=https://github.com/kubernetes/cloud-provider-openstack/blob/master/docs/cinder-csi-plugin/using-cinder-csi-plugin.md>Driver CSI OpenStack Cinder</a> tem de estar instalado no cluster. Você pode desativar a migração Cinder CSI para o seu cluster definindo a <a href=/docs/reference/command-line-tools-reference/feature-gates/>feature gate</a> <code>CSIMigrationOpenStack</code> como <code>false</code>. Se você desativar o recurso <code>CSIMigrationOpenStack</code>, o plugin de volume in-tree do Cinder assume a responsabilidade por todos os aspectos do gerenciamento de armazenamento de volume do Cinder.</p><h3 id=configmap>configMap</h3><p>Um <a href=/docs/tasks/configure-pod-container/configure-pod-configmap/>ConfigMap</a> oferece uma forma de injetar dados de configuração em Pods. Os dados armazenados em um ConfigMap podem ser referenciados em um volume de tipo <code>configMap</code> e depois consumidos por aplicações conteinerizadas executadas em um pod.</p><p>Ao referenciar um ConfigMap, você informa o nome do ConfigMap no volume. Pode personalizar o caminho utilizado para uma entrada específica no ConfigMap. A seguinte configuração mostra como montar o <code>log-config</code> do ConfigMap em um Pod chamado <code>configmap-pod</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>configmap-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config-vol<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config-vol<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>configMap</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>log-config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>log_level<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>log_level<span style=color:#bbb>
</span></span></span></code></pre></div><p>O ConfigMap <code>log-config</code> é montado como um volume e todos os conteúdos armazenados em sua entrada <code>log_level</code> são montados no Pod através do caminho <code>/etc/config/log_level</code>. Observe que esse caminho é derivado do volume <code>mountPath</code>e do <code>path</code> configurado com <code>log_level</code>.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong><ul><li><p>É preciso criar um <a href=/docs/tasks/configure-pod-container/configure-pod-configmap/>ConfigMap</a> antes de usá-lo.</p></li><li><p>Um contêiner que utiliza ConfigMap através de um ponto de montagem com a propriedade <a href=#using-subpath><code>subPath</code></a> não receberá atualizações deste ConfigMap.</p></li><li><p>Os dados de texto são expostos como arquivos utilizando a codificação de caracteres UTF-8. Para outras codificações de caracteres, use <code>binaryData</code>.</p></li></ul></div><h3 id=downwardapi>downwardAPI</h3><p>Um volume <code>downwardAPI</code> disponibiliza dados da downward API para as aplicações. Ele monta um diretório e grava os dados solicitados em arquivos de texto sem formatação.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Um contêiner que utiliza downward API através de um ponto de montagem com a propriedade <a href=#using-subpath><code>subPath</code></a> não receberá atualizações desta downward API.</div><p>Consulte <a href=/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information/>o exemplo de downward API</a> para obter mais detalhes.</p><h3 id=emptydir>emptyDir</h3><p>Um volume <code>emptyDir</code> é criado pela primeira vez quando um Pod é atribuído a um nó e existe enquanto esse Pod estiver sendo executado nesse nó. Como o nome diz, o volume <code>emptyDir</code> está inicialmente vazio. Todos os contêineres no Pod podem ler e gravar os mesmos arquivos no volume <code>emptyDir</code>, embora esse volume possa ser montado no mesmo caminho ou em caminhos diferentes em cada contêiner. Quando um Pod é removido de um nó por qualquer motivo, os dados no <code>emptyDir</code> são eliminados permanentemente.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> A falha de um contêiner <em>não</em> remove um Pod de um nó. Os dados em um volume <code>emptyDir</code> são mantidos em caso de falha do contêiner.</div><p>Alguns usos para um <code>emptyDir</code> são:</p><ul><li>espaço temporário, como para uma merge sort baseado em disco</li><li>ponto de verificação de um processamento longo para recuperação de falhas</li><li>manter arquivos que um contêiner gerenciador de conteúdo busca enquanto um contêiner de webserver entrega os dados</li></ul><p>Dependendo do seu ambiente, os volumes <code>emptyDir</code> são armazenados em qualquer mídia que componha o nó, como disco ou SSD, ou armazenamento de rede. No entanto, se você definir o campo <code>emptyDir.medium</code> como <code>"Memory"</code>, o Kubernetes monta um tmpfs (sistema de arquivos com suporte de RAM) para você. Embora o tmpfs seja muito rápido, tenha em atenção que, ao contrário dos discos, o tmpfs é limpo na reinicialização do nó e quaisquer arquivos que grave consomem o limite de memória do seu contêiner.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Se a <a href=/docs/reference/command-line-tools-reference/feature-gates/>feature gate</a> <code>SizeMemoryBackedVolumes</code> estiver habilitada, é possível especificar um tamanho para volumes mantidos em memória. Se nenhum tamanho for especificado, os volumes mantidos em memória são dimensionados para 50% da memória em um host Linux.</div><h4 id=exemplo-de-configuração-emptydir>Exemplo de configuração emptyDir</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-pd<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/test-webserver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/cache<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cache-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cache-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=fc>fc (fibre channel)</h3><p>Um tipo de volume <code>fc</code> permite que um volume de armazenamento de fibre channel existente seja montado em um Pod. Você pode especificar um ou vários WWNs usando o parâmetro <code>targetWWNs</code> em sua configuração de volume. Se forem especificados vários WWNs, o targetWWNs espera que esses WWNs sejam de conexões multipath.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Para que os hosts Kubernetes possam acessá-los, é necessário configurar o zoneamento FC SAN para alocar e mascarar essas LUNs (volumes) para os WWNs de destino.</div><p>Consulte <a href=https://github.com/kubernetes/examples/tree/master/staging/volumes/fibre_channel>o exemplo de fibre channel</a> para obter mais detalhes.</p><h3 id=flocker>flocker (descontinuado)</h3><p><a href=https://github.com/ClusterHQ/flocker>Flocker</a> é um gerenciador de volumes de dados de contêineres em cluster de código aberto. O Flocker oferece gerenciamento e orquestração de volumes de dados suportados por uma variedade de backends de armazenamento.</p><p>Um volume <code>flocker</code> permite que um conjunto de dados Flocker seja montado em um Pod. Se o conjunto de dados ainda não existir no Flocker, ele precisará ser criado primeiro com o CLI do Flocker ou usando a API do Flocker. Se o conjunto de dados já existir, ele será anexado pelo Flocker ao nó que o pod está escalonado. Isto significa que os dados podem ser compartilhados entre os Pods, conforme necessário.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Antes de poder utilizá-lo, é necessário ter a sua própria instalação do Flocker em execução.</div><p>Consulte <a href=https://github.com/kubernetes/examples/tree/master/staging/volumes/flocker>exemplo do Flocker</a> para obter mais detalhes.</p><h3 id=gcepersistentdisk>gcePersistentDisk</h3><p>Um volume <code>gcePersistentDisk</code> monta um <a href=https://cloud.google.com/compute/docs/disks>disco persistente</a> (PD) do Google Compute Engine (GCE) no seu Pod. Ao contrário do <code>emptyDir</code> que é apagado quando um pod é removido, o conteúdo de um PD é preservado e o volume é simplesmente desmontado. Isto significa que um PD pode ser previamente populado com dados e que os dados podem ser compartilhados entre os Pods.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Você dever criar um PD utilizando <code>gcloud</code>, ou via GCE API ou via UI antes de poder utilizá-lo.</div><p>Existem algumas restrições ao utilizar um <code>gcePersistentDisk</code>:</p><ul><li>Os nós nos quais os Pods estão sendo executados devem ser VMs GCE</li><li>Essas VMs precisam estar no mesmo projeto e zona GCE que o disco persistente</li></ul><p>Uma característica do disco persistente GCE é o acesso simultâneo somente leitura a um disco persistente. Um volume <code>gcePersistentDisk</code> permite que vários consumidores montem simultaneamente um disco persistente como somente leitura. Isto significa que é possível alimentar previamente um PD com o seu conjunto de dados e, em seguida, disponibilizá-lo em paralelo a quantos Pods necessitar. Infelizmente, os PDs só podem ser montados por um único consumidor no modo de leitura e escrita. Não são permitidos gravadores simultâneos.</p><p>O uso de um disco persistente GCE com um Pod controlado por um ReplicaSet falhará, a menos que o PD seja somente leitura ou a contagem de réplica seja 0 ou 1.</p><h4 id=gce-create-persistent-disk>Criando um disco persistente GCE</h4><p>Antes de poder utilizar um disco persistente GCE com um Pod, é necessário criá-lo.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>gcloud compute disks create --size<span style=color:#666>=</span>500GB --zone<span style=color:#666>=</span>us-central1-a my-data-disk
</span></span></code></pre></div><h4 id=exemplo-de-configuração-de-disco-persistente-gce>Exemplo de configuração de disco persistente GCE</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-pd<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/test-webserver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/test-pd<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># Esse Disco Persistente (PD) GCE já deve existir.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>gcePersistentDisk</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>pdName</span>:<span style=color:#bbb> </span>my-data-disk<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>fsType</span>:<span style=color:#bbb> </span>ext4<span style=color:#bbb>
</span></span></span></code></pre></div><h4 id=discos-persistentes-regionais>Discos persistentes regionais</h4><p>O recurso de <a href=https://cloud.google.com/compute/docs/disks/#repds>Discos persistentes regionais</a> permite a criação de discos persistentes que estão disponíveis em duas zonas dentro da mesma região. Para usar esse recurso, o volume deve ser provisionado como PersistentVolume; referenciar o volume diretamente a partir de um pod não é uma configuração suportada.</p><h4 id=provisionar-manualmente-um-persistentvolume-pd-regional>Provisionar manualmente um PersistentVolume PD Regional</h4><p>O provisionamento dinâmico é possível usando <a href=/docs/concepts/storage/storage-classes/#gce-pd>uma StorageClass para GCE PD</a>. Antes de criar um PersistentVolume, você deve criar o disco persistente:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>gcloud compute disks create --size<span style=color:#666>=</span>500GB my-data-disk
</span></span><span style=display:flex><span>  --region us-central1
</span></span><span style=display:flex><span>  --replica-zones us-central1-a,us-central1-b
</span></span></code></pre></div><h4 id=exemplo-de-configuração-de-disco-persistente-regional>Exemplo de configuração de disco persistente regional</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>capacity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>400Gi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- ReadWriteOnce<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>gcePersistentDisk</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>pdName</span>:<span style=color:#bbb> </span>my-data-disk<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>fsType</span>:<span style=color:#bbb> </span>ext4<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodeAffinity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>required</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>nodeSelectorTerms</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># failure-domain.beta.kubernetes.io/zone deve ser usado para versões anteriores à 1.21</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>topology.kubernetes.io/zone<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>- us-central1-a<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>- us-central1-b<span style=color:#bbb>
</span></span></span></code></pre></div><h4 id=migração-do-csi-gce>Migração do CSI GCE</h4><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.17 [beta]</code></div><p>Quando o recurso <code>CSIMigration</code> para o GCE PD é habilitado, todas as operações de plugin do plugin in-tree existente são redirecionadas para o Driver de Cointainer Storage Interface (CSI) <code>pd.csi.storage.gke.io</code>. Para utilizar este recurso, o <a href=https://github.com/kubernetes-sigs/gcp-compute-persistent-disk-csi-driver>Driver CSI GCE PD</a> deve ser instalado no cluster e os recursos beta <code>CSIMigration</code> e <code>CSIMigrationGCE</code> devem estar habilitados.</p><h4 id=migração-de-csi-gce-concluída>Migração de CSI GCE concluída</h4><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.21 [alpha]</code></div><p>Para desabilitar o carregamento do plugin de armazenamento <code>gcePersistentDisk</code> pelo gerenciador de controladores e pelo kubelet, defina a flag <code>InTreePluginGCEUnregister</code> como <code>true</code>.</p><h3 id=gitrepo>gitRepo (descontinuado)</h3><div class="alert alert-danger warning callout" role=alert><strong>Aviso:</strong> O tipo de volume <code>gitRepo</code> foi descontinuado. Para provisionar um contêiner com um repositório git , monte um <a href=#emptydir>EmptyDir</a> em um InitContainer que clone o repositório usando git, depois monte <a href=#emptydir>o EmptyDir</a> no contêiner do Pod.</div><p>Um volume <code>gitRepo</code> é um exemplo de um plugin de volume. Este plugin monta um diretório vazio e clona um repositório git neste diretório para que seu Pod utilize.</p><p>Aqui está um exemplo de um volume <code>gitRepo</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>server<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/mypath<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>git-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>git-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>gitRepo</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>repository</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;git@somewhere:me/my-git-repository.git&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>revision</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;22f1d8406d464b0c0874075539c1f2e96c253775&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=glusterfs>glusterfs</h3><p>Um volume <code>glusterfs</code> permite que um volume <a href=https://www.gluster.org>Glusterfs</a> (um sistema de arquivos em rede de código aberto) seja montado no seu Pod. Ao contrário do <code>emptyDir</code> que é apagado quando um Pod é removido, o conteúdo de um volume <code>glusterfs</code> é preservado e o volume é simplesmente desmontado. Isto significa que um volume glusterfs pode ser previamente populado com dados e que os dados podem ser compartilhados entre Pods. O GlusterFS pode ser montado para escrita por vários pods simultaneamente.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Para poder utilizá-lo, é necessário ter a sua própria instalação do GlusterFS em execução.</div><p>Consulte o <a href=https://github.com/kubernetes/examples/tree/master/volumes/glusterfs>exemplo do GlusterFS</a> para obter mais detalhes.</p><h3 id=hostpath>hostPath</h3><div class="alert alert-danger warning callout" role=alert><strong>Aviso:</strong><p>Os volumes HostPath apresentam muitos riscos de segurança e é uma prática recomendada evitar o uso de HostPaths quando possível. Quando um volume HostPath precisa ser usado, ele deve ser definido com escopo apenas para o arquivo ou diretório necessário e montado como ReadOnly.</p><p>Se você restringir o acesso do HostPath a diretórios específicos através da AdmissionPolicy, a propriedade <code>volumeMounts</code> DEVE obrigatoriamente usar pontos de montagem <code>readOnly</code> para que a política seja eficaz.</p></div><p>Um volume <code>hostPath</code> monta um arquivo ou diretório do sistema de arquivos do nó do host em seu Pod. Isto não é algo de que a maioria dos Pods irá precisar, mas oferece uma poderosa alternativa de escape para algumas aplicações.</p><p>Por exemplo, alguns usos para um <code>hostPath</code> são:</p><ul><li>Executar um contêiner que necessita de acesso aos documentos internos do Docker; utilizar um <code>hostPath</code> apontando para <code>/var/lib/docker</code></li><li>Executando o cAdvisor em um contêiner; use um <code>hostPath</code> apontando para <code>/sys</code></li><li>Permitir que um Pod especifique se um dado <code>hostPath</code> deve existir antes de o Pod ser executado, se deve ser criado e como deve existir</li></ul><p>Além da propriedade obrigatória <code>path</code> , você pode opcionalmente definir um <code>type</code> para um volume <code>hostPath</code>.</p><p>Os valores suportados para o campo <code>type</code> são:</p><table><thead><tr><th style=text-align:left>Valor</th><th style=text-align:left>Comportamento</th></tr></thead><tbody><tr><td style=text-align:left></td><td style=text-align:left>A string vazia (padrão) é para compatibilidade com versões anteriores, o que significa que nenhuma verificação será executada antes de montar o volume hostPath.</td></tr><tr><td style=text-align:left><code>DirectoryOrCreate</code></td><td style=text-align:left>Se nada existir no caminho indicado, um diretório vazio será criado lá, conforme necessário, com permissão definida para 0755, tendo o mesmo grupo e propriedade com a Kubelet.</td></tr><tr><td style=text-align:left><code>Directory</code></td><td style=text-align:left>Um diretório deve existir no caminho indicado</td></tr><tr><td style=text-align:left><code>FileOrCreate</code></td><td style=text-align:left>Se não houver nada no caminho indicado, um arquivo vazio será criado lá, conforme necessário, com permissão definida para 0644, tendo o mesmo grupo e propriedade com Kubelet.</td></tr><tr><td style=text-align:left><code>File</code></td><td style=text-align:left>Um arquivo deve existir no caminho indicado</td></tr><tr><td style=text-align:left><code>Socket</code></td><td style=text-align:left>Um socket UNIX deve existir no caminho indicado</td></tr><tr><td style=text-align:left><code>CharDevice</code></td><td style=text-align:left>Deve existir um dispositivo de caracteres no caminho indicado</td></tr><tr><td style=text-align:left><code>BlockDevice</code></td><td style=text-align:left>Deve existir um dispositivo de bloco no caminho indicado</td></tr></tbody></table><p>Tenha cuidado ao utilizar este tipo de volume, porque:</p><ul><li>Os HostPaths podem expor as credenciais privilegiadas do sistema (como para o Kubelet) ou APIs privilegiadas (como o container runtime socket), que podem ser usadas para o explorar vulnerabilidades de escape do contêiner ou para atacar outras partes do cluster.</li><li>Os Pods com configuração idêntica (como criado a partir de um PodTemplate) podem se comportar de forma diferente em nós diferentes devido a arquivos diferentes nos nós</li><li>Os arquivos ou diretórios criados nos hosts subjacentes são graváveis apenas pelo root. Você precisa executar seu processo como root em um <a href=/docs/tasks/configure-pod-container/security-context/>contêiner privilegiado</a> ou modificar as permissões de arquivo no host para poder gravar em um volume <code>hostPath</code></li></ul><h4 id=exemplo-de-configuração-do-hostpath>Exemplo de configuração do hostPath</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-pd<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/test-webserver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/test-pd<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># localização do diretório no host</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/data<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># este campo é opcional</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Directory<span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-warning caution callout" role=alert><strong>Cuidado:</strong> O modo <code>FileOrCreate</code> não cria o diretório onde ficará arquivo. Se o caminho de diretório do arquivo montado não existir, o pod não será iniciado. Para garantir que esse modo funcione, você pode tentar montar diretórios e arquivos separadamente, como mostrado em <a href=#hostpath-fileorcreate-example>configuração <code>FileOrCreate</code></a>.</div><h4 id=hostpath-fileorcreate-example>Exemplo de configuração FileOrCreate do hostPath</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-webserver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-webserver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/test-webserver:latest<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/local/aaa<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mydir<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/local/aaa/1.txt<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myfile<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mydir<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># Certifique-se de que o diretório foi criado.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/var/local/aaa<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>DirectoryOrCreate<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myfile<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/var/local/aaa/1.txt<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>FileOrCreate<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=iscsi>iscsi</h3><p>Um volume <code>iscsi</code> permite que um volume iSCSI (SCSI sobre IP) existente seja montado no seu Pod. Ao contrário do <code>emptyDir</code> que é apagado quando um Pod é removido, o conteúdo de um volume <code>iscsi</code> é preservado e o volume é simplesmente desmontado. Isto significa que um volume iscsi pode ser previamente populado com dados e que os dados podem ser compartilhados entre os Pods.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Você deve ter seu próprio servidor iSCSI rodando com o volume criado antes de poder utilizá-lo.</div><p>Uma característica do iSCSI é que ele pode ser montado como somente leitura por vários consumidores simultaneamente. Isto significa que um volume pode ser previamente populado com seu conjunto de dados e, em seguida, ser disponibilizado em paralelo para tantos Pods quanto necessitar. Infelizmente, os volumes iSCSI só podem ser montados por um único consumidor no modo de leitura-escrita. Não são permitidos gravadores simultâneos.</p><p>Consulte o <a href=https://github.com/kubernetes/examples/tree/master/volumes/iscsi>exemplo iSCSI</a> para obter mais detalhes.</p><h3 id=local>local</h3><p>Um volume <code>local</code> representa um dispositivo de armazenamento local montado, como um disco, partição ou diretório.</p><p>Os volumes locais só podem ser usados como um PersistentVolume criado estaticamente. O provisionamento dinâmico não é suportado.</p><p>Em comparação com volumes <code>hostPath</code>, os volumes <code>local</code> são usados de forma durável e portátil, sem escalonamento manual dos Pods para os nós. O sistema está ciente das restrições de nós do volume, observando a afinidade do nó com o PersistentVolume.</p><p>No entanto, os volumes <code>local</code> estão sujeitos à disponibilidade do nó que o comporta e não são adequados para todas as aplicações. Se um nó não está íntegro, então o volume <code>local</code> torna-se inacessível pelo pod. O pod que utiliza este volume não consegue ser executado. Os aplicativos que usam volumes <code>local</code> devem ser capazes de tolerar essa disponibilidade reduzida, bem como uma possível perda de dados, dependendo das caraterísticas de durabilidade do disco subjacente.</p><p>O exemplo a seguir mostra um PersistentVolume usando um volume <code>local</code> e <code>nodeAffinity</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example-pv<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>capacity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>100Gi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeMode</span>:<span style=color:#bbb> </span>Filesystem<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- ReadWriteOnce<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>persistentVolumeReclaimPolicy</span>:<span style=color:#bbb> </span>Delete<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>local-storage<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>local</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/mnt/disks/ssd1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodeAffinity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>required</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>nodeSelectorTerms</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>kubernetes.io/hostname<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>- example-node<span style=color:#bbb>
</span></span></span></code></pre></div><p>É preciso definir a propriedade <code>nodeAffinity</code> do PersistentVolume ao utilizar volumes <code>local</code>. O escalonador do Kubernetes usa o PersistentVolume <code>nodeAffinity</code> para escalonar esses pods para o nó correto.</p><p>A propriedade <code>volumeMode</code> do PersistentVolume pode ser definida como "Block" (ao invés do valor padrão "Filesystem") para expor o volume local como um dispositivo de bloco bruto.</p><p>Ao usar volumes locais, é recomendável criar uma StorageClass com a propriedade <code>volumeBindingMode</code> definida como <code>WaitForFirstConsumer</code>. Para obter mais detalhes, consulte o exemplo local <a href=/docs/concepts/storage/storage-classes/#local>StorageClass</a>. A postergação da vinculação do volume garante que a decisão de vinculação da PersistentVolumeClaim também será avaliada com quaisquer outras restrições de nós que o Pod possa ter, tais como requisitos de recursos de nós, seletores de nós, afinidade do Pod e anti afinidade do Pod.</p><p>Um provisionador estático externo pode ser executado separadamente para uma melhor gestão do ciclo de vida do volume local. Observe que este provisionador ainda não suporta o provisionamento dinâmico. Para um exemplo sobre como executar um provisionador local externo, veja o <a href=https://github.com/kubernetes-sigs/sig-storage-local-static-provisioner>manual do usuário do provisionador local do volume</a>.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> O PersistentVolume local exige que o usuário faça limpeza e remoção manual se o provisionador estático externo não for utilizado para gerenciar o ciclo de vida do volume.</div><h3 id=nfs>nfs</h3><p>Um volume <code>nfs</code> permite que um compartilhamento NFS (Network File System) existente seja montado em um Pod. Ao contrário do <code>emptyDir</code> que é apagado quando um Pod é removido, o conteúdo de um volume <code>nfs</code> é preservado e o volume é simplesmente desmontado. Isto significa que um volume NFS pode ser previamente populado com dados e que os dados podem ser compartilhados entre os Pods. O NFS pode ser montado por vários gravadores simultaneamente.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Você deve ter seu próprio servidor NFS rodando com o compartilhamento acessível antes de poder utilizá-lo.</div><p>Consulte o <a href=https://github.com/kubernetes/examples/tree/master/staging/volumes/nfs>exemplo NFS</a> para obter mais detalhes.</p><h3 id=persistentvolumeclaim>persistentVolumeClaim</h3><p>Um volume <code>persistentVolumeClaim</code> é usado para montar um <a href=/pt-br/docs/concepts/storage/persistent-volumes/>PersistentVolume</a> em um Pod. PersistentVolumeClaims são uma forma de os usuários "solicitarem" armazenamento durável (como um GCE PersistentDisk ou um volume iSCSI) sem conhecerem os detalhes do ambiente de nuvem em particular.</p><p>Consulte as informações sobre <a href=/pt-br/docs/concepts/storage/persistent-volumes/>PersistentVolumes</a> para obter mais detalhes.</p><h3 id=portworxvolume>portworxVolume</h3><p>Um <code>portworxVolume</code> é uma camada de armazenamento em bloco extensível que funciona hiperconvergente com Kubernetes. O <a href=https://portworx.com/use-case/kubernetes-storage/>Portworx</a> tira as impressões digitais de um armazenamento em um servidor, organiza com base nas capacidades e agrega capacidade em múltiplos servidores. Portworx funciona em máquinas virtuais ou em nós Linux bare-metal.</p><p>Um <code>portworxVolume</code> pode ser criado dinamicamente através do Kubernetes ou também pode ser previamente provisionado e referenciado dentro de um Pod. Aqui está um exemplo de um Pod referenciando um volume Portworx pré-provisionado:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-portworx-volume-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/test-webserver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/mnt<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pxvol<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pxvol<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># Este volume Portworx já deve existir.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>portworxVolume</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeID</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;pxvol&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>fsType</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&lt;fs-type&gt;&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Certifique-se de ter um PortworxVolume com o nome <code>pxvol</code> antes de usá-lo no Pod.</div><p>Para obter mais detalhes, consulte os exemplos de <a href=https://github.com/kubernetes/examples/tree/master/staging/volumes/portworx/README.md>volume Portworx</a> .</p><h3 id=projetado>projetado</h3><p>Um volume projetado mapeia várias fontes de volume existentes dentro do mesmo diretório. Para obter mais detalhes, consulte <a href=/docs/concepts/storage/projected-volumes/>Volumes projetados</a>.</p><h3 id=quobyte>quobyte (descontinuado)</h3><p>Um Volume <code>quobyte</code> permite que um volume <a href=https://www.quobyte.com>Quobyte</a> existente seja montado no seu Pod.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Você deve ter seu próprio Quobyte configurado e funcionando com os volumes criados antes de poder utilizá-lo.</div><p>Quobyte oferece suporte para o <a class=glossary-tooltip title='A Interface de Armazenamento de Contêiner (Container Storage Interface, CSI) define um padrão de interface para expor sistemas de armazenamento a contêineres.' data-toggle=tooltip data-placement=top href=/pt-br/docs/concepts/storage/volumes/#csi target=_blank aria-label='Container Storage Interface'>Container Storage Interface</a>. CSI é o plugin recomendado para usar volumes Quobyte dentro de Kubernetes. O projeto GitHub da Quobyte tem <a href=https://github.com/quobyte/quobyte-csi#quobyte-csi>instruções</a> para implantar o Quobyte usando o CSI, acompanhado de exemplos.</p><h3 id=rbd>rbd</h3><p>Um volume <code>rbd</code> permite que um volume <a href=https://docs.ceph.com/en/latest/rbd/>Rados Block Device</a> (RBD) seja montado em seu Pod. Ao contrário do <code>emptyDir</code> que é apagado quando um pod é removido, o conteúdo de um volume <code>rbd</code> é preservado e o volume é desmontado. Isto significa que um volume RBD pode ser previamente populado com dados e que os dados podem ser compartilhados entre os Pods.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Você deve ter uma instalação Ceph em funcionamento antes de poder usar o RBD.</div><p>Uma caraterística do RBD é que ele pode ser montado como somente leitura por vários consumidores simultaneamente. Isto significa que um volume pode ser previamente populado com seu conjunto de dados e, em seguida, ser disponibilizado em paralelo para tantos pods quanto necessitar. Infelizmente, os volumes RBD só podem ser montados por um único consumidor no modo de leitura-escrita. Não são permitidos gravadores simultâneos.</p><p>Consulte o <a href=https://github.com/kubernetes/examples/tree/master/volumes/rbd>exemplo RBD</a> para obter mais detalhes.</p><h4 id=rbd-csi-migration>Migração de CSI RBD</h4><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.23 [alpha]</code></div><p>Quando o recurso <code>CSIMigration</code> do <code>RBD</code> está ativado, redireciona todas as operações do plugin in-tree existente para o driver <a class=glossary-tooltip title='A Interface de Armazenamento de Contêiner (Container Storage Interface, CSI) define um padrão de interface para expor sistemas de armazenamento a contêineres.' data-toggle=tooltip data-placement=top href=/pt-br/docs/concepts/storage/volumes/#csi target=_blank aria-label=CSI>CSI</a> <code>rbd.csi.ceph.com</code>. Para utilizar este recurso, o <a href=https://github.com/ceph/ceph-csi>driver Ceph CSI</a> deve estar instalado no cluster e as <a href=/docs/reference/command-line-tools-reference/feature-gates/>feature gates</a> <code>CSIMigration</code> e <code>csiMigrationRBD</code> devem estar habilitadas.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong><p>Como operador do cluster Kubernetes que administra o armazenamento, aqui estão os pré-requisitos que você deve atender antes de tentar a migração para o driver CSI RBD:</p><ul><li>Você deve instalar o driver Ceph CSI (<code>rbd.csi.ceph.com</code>), v3.5.0 ou superior, no cluster Kubernetes.</li><li>Considerando que o campo <code>clusterID</code> é um parâmetro necessário para o driver CSI e sua operação , mas o campo in-tree StorageClass tem o parâmetro obrigatório <code>monitors</code>, um administrador de armazenamento Kubernetes precisa criar um clusterID baseado no hash dos monitores (ex.:<code>#echo -n '&lt;monitors_string>' | md5sum</code>) no mapa de configuração do CSI e manter os monitores sob esta configuração de clusterID.</li><li>Além disso, se o valor de <code>adminId</code> no Storageclass in-tree for diferente de <code>admin</code>, o <code>adminSecretName</code> mencionado no Storageclass in-tree tem que ser corrigido com o valor base64 do valor do parâmetro <code>adminId</code>, caso contrário esta etapa pode ser ignorada.</li></ul></div><h3 id=secret>secret</h3><p>Um volume <code>secret</code> é usado para passar informações sensíveis, tais como senhas, para Pods. Você pode armazenar segredos na API Kubernetes e montá-los como arquivos para serem usados por pods sem necessidade de vinculação direta ao Kubernetes. Volumes <code>secret</code> são mantidos pelo tmpfs (um sistema de arquivos com baseado em memória RAM) para que nunca sejam gravados em armazenamento não volátil.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Você deve criar um Secret na API Kubernetes antes de poder utilizá-lo.</div><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Um contêiner que utiliza um Secret como ponto de montagem para a propriedade <a href=#using-subpath><code>subPath</code></a> não receberá atualizações deste Secret.</div><p>Para obter mais detalhes, consulte <a href=/pt-br/docs/concepts/configuration/secret/>Configurando Secrets</a>.</p><h3 id=storageos>storageOS (descontinuado)</h3><p>Um volume <code>storageos</code> permite que um volume <a href=https://www.storageos.com>StorageOS</a> existente seja montado em seu Pod.</p><p>O StorageOS funciona como um contêiner dentro de seu ambiente Kubernetes, tornando o armazenamento local ou anexado acessível a partir de qualquer nó dentro do cluster Kubernetes. Os dados podem ser replicados para a proteção contra falhas do nó. O provisionamento e a compressão podem melhorar a utilização e reduzir os custos.</p><p>Em sua essência, o StorageOS fornece armazenamento em bloco para containers, acessível a partir de um sistema de arquivo.</p><p>O Conteiner StorageOS requer Linux de 64 bits e não possui dependências adicionais. Uma licença para desenvolvedores está disponível gratuitamente.</p><div class="alert alert-warning caution callout" role=alert><strong>Cuidado:</strong> Você deve executar o container StorageOS em cada nó que deseja acessar os volumes do StorageOS ou que contribuirá com a capacidade de armazenamento para o pool. Para obter instruções de instalação, consulte a <a href=https://docs.storageos.com>documentação do StorageOS</a>.</div><p>O exemplo a seguir é uma configuração do Pod com StorageOS:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>role</span>:<span style=color:#bbb> </span>master<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-storageos-redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>master<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>kubernetes/redis:v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MASTER<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>6379</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/redis-master-data<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>redis-data<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>redis-data<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storageos</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># O volume `redis-vol01` já deve existir dentro do StorageOS no namespace `default`.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeName</span>:<span style=color:#bbb> </span>redis-vol01<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>fsType</span>:<span style=color:#bbb> </span>ext4<span style=color:#bbb>
</span></span></span></code></pre></div><p>Para obter mais informações sobre StorageOS, provisionamento dinâmico e PersistentVolumeClaims, consulte os <a href=https://github.com/kubernetes/examples/blob/master/volumes/storageos>exemplos do StorageOS</a>.</p><h3 id=vspherevolume>vsphereVolume</h3><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Você deve configurar o Kubernetes vSphere Cloud Provider. Para obter informações sobre a configuração do cloudprovider, consulte o <a href=https://vmware.github.io/vsphere-storage-for-kubernetes/documentation/>Guia Introdutório do vSphere</a>.</div><p>Um <code>vsphereVolume</code> é usado para montar um volume VMDK do vSphere em seu Pod. O conteúdo de um volume é preservado quando é desmontado. Ele suporta sistemas de armazenamento de dados tanto do tipo VMFS quanto do tipo VSAN.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Você deve criar o volume do VMDK vSphere usando um dos métodos a seguir antes de usar com um Pod.</div><h4 id=creating-vmdk-volume>Criar um volume VMDK</h4><p>Escolha um dos seguintes métodos para criar um VMDK.</p><ul class="nav nav-tabs" id=tabs-volumes role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tabs-volumes-0 role=tab aria-controls=tabs-volumes-0 aria-selected=true>Criar usando vmkfstools</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tabs-volumes-1 role=tab aria-controls=tabs-volumes-1>Criar usando vmware-vdiskmanager</a></li></ul><div class=tab-content id=tabs-volumes><div id=tabs-volumes-0 class="tab-pane show active" role=tabpanel aria-labelledby=tabs-volumes-0><p><p>Primeiro acesse o ESX via ssh, depois use o seguinte comando para criar um VMDK:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>vmkfstools -c 2G /vmfs/volumes/DatastoreName/volumes/myDisk.vmdk
</span></span></code></pre></div></div><div id=tabs-volumes-1 class=tab-pane role=tabpanel aria-labelledby=tabs-volumes-1><p><p>Utilize o seguinte comando para criar um VMDK:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>vmware-vdiskmanager -c -t <span style=color:#666>0</span> -s 40GB -a lsilogic myDisk.vmdk
</span></span></code></pre></div></div></div><h4 id=vsphere-vmdk-configuration>Exemplo de configuração do VMDK no vSphere</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-vmdk<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/test-webserver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/test-vmdk<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># This VMDK volume must already exist.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>vsphereVolume</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumePath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;[DatastoreName] volumes/myDisk&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>fsType</span>:<span style=color:#bbb> </span>ext4<span style=color:#bbb>
</span></span></span></code></pre></div><p>Para obter mais informações, consulte os exemplos de <a href=https://github.com/kubernetes/examples/tree/master/staging/volumes/vsphere>volume do vSphere</a> .</p><h4 id=vsphere-csi-migration>Migração de CSI vSphere</h4><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.19 [beta]</code></div><p>Quando o recurso <code>CSIMigration</code> do <code>vsphereVolume</code> está ativado, redireciona todas as operações do plugin in-tree existente para o driver <a class=glossary-tooltip title='A Interface de Armazenamento de Contêiner (Container Storage Interface, CSI) define um padrão de interface para expor sistemas de armazenamento a contêineres.' data-toggle=tooltip data-placement=top href=/pt-br/docs/concepts/storage/volumes/#csi target=_blank aria-label=CSI>CSI</a> <code>csi.vsphere.vmware.com</code>. Para usar esse recurso, o <a href=https://github.com/kubernetes-sigs/vsphere-csi-driver>driver CSI do vSphere</a> deve estar instalado no cluster e as <a href=/docs/reference/command-line-tools-reference/feature-gates/>feature gates</a> <code>CSIMigration</code> e <code>CSIMigrationvSphere</code> devem estar habilitadas.</p><p>Isso também requer que a versão mínima do vSphere vCenter/ESXi seja 7.0u1 e a versão mínima do hardware seja a VM versão 15.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong><p>Os seguintes parâmetros da StorageClass do plugin integrado <code>vsphereVolume</code> não são suportados pelo driver CSI do vSphere:</p><ul><li><code>diskformat</code></li><li><code>hostfailurestotolerate</code></li><li><code>forceprovisioning</code></li><li><code>cachereservation</code></li><li><code>diskstripes</code></li><li><code>objectspacereservation</code></li><li><code>iopslimit</code></li></ul><p>Os volumes existentes criados usando esses parâmetros serão migrados para o driver CSI do vSphere, mas novos volumes criados pelo driver de CSI do vSphere não estarão respeitando esses parâmetros.</p></div><h4 id=vsphere-csi-migration-complete>Migração do CSI do vSphere foi concluída</h4><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.19 [beta]</code></div><p>Para desativar o carregamento do plugin de armazenamento <code>vsphereVolume</code> pelo gerenciador de controladores e pelo kubelet, defina a flag <code>InTreePluginvSphereUnregister</code> como <code>true</code>. Você precisa instalar o driver <code>csi.vsphere.vmware.com</code> <a class=glossary-tooltip title='A Interface de Armazenamento de Contêiner (Container Storage Interface, CSI) define um padrão de interface para expor sistemas de armazenamento a contêineres.' data-toggle=tooltip data-placement=top href=/pt-br/docs/concepts/storage/volumes/#csi target=_blank aria-label=CSI>CSI</a> em todos os nós de processamento.</p><h4 id=migração-de-driver-csi-do-portworx>Migração de driver CSI do Portworx</h4><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.23 [alpha]</code></div><p>O recurso <code>CSIMigration</code> para Portworx foi adicionado, mas desativado por padrão no Kubernetes 1.23 visto que está no estado alfa. Ele redireciona todas as operações de plugin do tipo in-tree para o Driver de Cointainer Storage Interface (CSI) <code>pxd.portworx.com</code>. <a href=https://docs.portworx.com/portworx-install-with-kubernetes/storage-operations/csi/>O driver CSI Portworx</a> deve ser instalado no cluster. Para ativar o recurso, defina <code>CSIMigrationPortworx=true</code> no kube-controller-manager e no kubelet.</p><h2 id=using-subpath>Utilizando subPath</h2><p>Às vezes, é útil compartilhar um volume para múltiplos usos em um único pod. A propriedade <code>volumeMounts.subPath</code> especifica um sub caminho dentro do volume referenciado em vez de sua raiz.</p><p>O exemplo a seguir mostra como configurar um Pod com um ambiente LAMP (Linux, Apache, MySQL e PHP) usando um único volume compartilhado. Esta exemplo de configuração <code>subPath</code> não é recomendada para uso em produção.</p><p>O código e os ativos da aplicação PHP mapeiam para a pasta do volume <code>html</code> e o banco de dados MySQL é armazenado na pasta do volume <code>mysql</code> . Por exemplo:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-lamp-site<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MYSQL_ROOT_PASSWORD<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;rootpasswd&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/lib/mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>site-data<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>subPath</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>php<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>php:7.0-apache<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/www/html<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>site-data<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>subPath</span>:<span style=color:#bbb> </span>html<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>site-data<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>persistentVolumeClaim</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>claimName</span>:<span style=color:#bbb> </span>my-lamp-site-data<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=using-subpath-expanded-environment>Usando subPath com variáveis de ambiente expandidas</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.17 [stable]</code></div><p>Use o campo <code>subPathExpr</code> para construir nomes de diretório <code>subPath</code> a partir de variáveis de ambiente da downward API. As propriedades <code>subPath</code> e <code>subPathExpr</code> são mutuamente exclusivas.</p><p>Neste exemplo, um <code>Pod</code> usa <code>subPathExpr</code> para criar um diretório <code>pod1</code> dentro do volume <code>hostPath</code> <code>/var/log/pods</code>. O volume <code>hostPath</code>recebe o nome <code>Pod</code> do <code>downwardAPI</code>. O diretório <code>/var/log/pods/pod1</code> do host é montado em <code>/logs</code> no contêiner.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pod1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>container1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>POD_NAME<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>fieldRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>fieldPath</span>:<span style=color:#bbb> </span>metadata.name<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;while [ true ]; do echo &#39;Hello&#39;; sleep 10; done | tee -a /logs/hello.txt&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>workdir1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/logs<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># A expansão de variáveis usa parênteses (não chaves).</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>subPathExpr</span>:<span style=color:#bbb> </span>$(POD_NAME)<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>workdir1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/var/log/pods<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=recursos>Recursos</h2><p>A mídia de armazenamento(como Disco ou SSD) de um volume <code>emptyDir</code> é determinada por meio do sistema de arquivos que mantém o diretório raiz do kubelet (normalmente <code>/var/lib/kubelet</code>). Não há limite para quanto espaço um volume <code>emptyDir</code> ou <code>hostPath</code> podem consumir, e não há isolamento entre contêineres ou entre pods.</p><p>Para saber mais sobre como solicitar espaço usando uma especificação de recursos, consulte <a href=/pt-br/docs/concepts/configuration/manage-resources-containers/>como gerenciar recursos</a>.</p><h2 id=plugins-de-volume-out-of-tree>Plugins de volume out-of-tree</h2><p>Os plugins de volume out-of-tree incluem o <a class=glossary-tooltip title='A Interface de Armazenamento de Contêiner (Container Storage Interface, CSI) define um padrão de interface para expor sistemas de armazenamento a contêineres.' data-toggle=tooltip data-placement=top href=/pt-br/docs/concepts/storage/volumes/#csi target=_blank aria-label='Container Storage Interface'>Container Storage Interface</a> (CSI) e também o FlexVolume (que foi descontinuado). Esses plugins permitem que os fornecedores de armazenamento criem plugins de armazenamento personalizados sem adicionar seu código-fonte do plugin ao repositório Kubernetes.</p><p>Anteriormente, todos os plugins de volume eram "in-tree". Os plugins "in-tree" eram construídos, vinculados, compilados e distribuídos com o código principal dos binários do Kubernetes. Isto significava que a adição de um novo sistema de armazenamento ao Kubernetes (um plugin de volume) exigia uma validação do código no repositório central de código Kubernetes.</p><p>Tanto o CSI quanto o FlexVolume permitem que os plugins de volume sejam desenvolvidos independentemente da base de código Kubernetes e implantados (instalados) nos clusters Kubernetes como extensões.</p><p>Para fornecedores de armazenamento que procuram criar um plugin de volume out-of-tree, consulte as <a href=https://github.com/kubernetes/community/blob/master/sig-storage/volume-plugin-faq.md>Perguntas mais frequentes sobre plugins de volume</a>.</p><h3 id=csi>csi</h3><p>O <a href=https://github.com/container-storage-interface/spec/blob/master/spec.md>Cointainer Storage Interface</a> (CSI) define uma interface padrão para sistemas de orquestração de contêineres (como Kubernetes) para expor sistemas de armazenamento arbitrários a suas cargas de trabalho de contêiner.</p><p>Leia a <a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/storage/container-storage-interface.md>proposta de design CSI</a> para obter mais informações.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> O suporte para as versões 0.2 e 0.3 da especificação CSI foi descontinuado no Kubernetes v1.13 e será removido em uma versão futura.</div><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Os controladores CSI podem não ser compatíveis em todas as versões do Kubernetes. Consulte a documentação específica do driver CSI para ver as etapas de implantação suportadas para cada versão do Kubernetes e uma matriz de compatibilidade.</div><p>Uma vez que um driver de volume compatível com CSI seja implantado em um cluster Kubernetes, os usuários podem usar o tipo de volume <code>csi</code> para anexar ou montar os volumes expostos pelo driver CSI.</p><p>Um volume <code>csi</code> pode ser utilizado em um Pod de três formas diferentes:</p><ul><li>Através de uma referência a <a href=#persistentvolumeclaim>PersistentVolumeClaim</a></li><li>com um <a href=/docs/concepts/storage/ephemeral-volumes/#generic-ephemeral-volumes>volume efêmero genérico</a> (recurso alfa)</li><li>com <a href=/docs/concepts/storage/ephemeral-volumes/#csi-ephemeral-volumes>volume efêmero de CSI</a> se o driver suportar esse (recurso beta)</li></ul><p>Os seguintes campos estão disponíveis para administradores de armazenamento configurarem um volume persistente de CSI:</p><ul><li><code>driver</code>: Um valor do tipo string que especifica o nome do driver de volume a ser usado. Este valor deve corresponder ao valor retornado no <code>GetPluginInfoResponse</code> pelo driver CSI, conforme definido na <a href=https://github.com/container-storage-interface/spec/blob/master/spec.md#getplugininfo>especificação CSI</a>. Ele é usado pelo Kubernetes para identificar qual driver CSI chamar, e pelos componentes do driver CSI para identificar quais objetos PV pertencem ao driver CSI.</li><li><code>volumeHandle</code>: Um valor do tipo string que identifica exclusivamente o volume. Este valor deve corresponder ao valor retornado no campo <code>volume.id</code> em <code>CreateVolumeResponse</code> pelo driver CSI, conforme definido na <a href=https://github.com/container-storage-interface/spec/blob/master/spec.md#createvolume>especificação CSI</a>. O valor é passado como <code>volume_id</code> em todas as chamadas para o driver de volume CSI quando se faz referência ao volume.</li><li><code>readOnly</code>: Um valor booleano opcional que indica se o volume deve ser "ControllerPublished" (anexado) como somente leitura. O valor padrão é false. Este valor é passado para o driver CSI através do campo <code>readonly</code> em <code>ControllerPublishVolumeRequest</code>.</li><li><code>fsType</code>: Se o <code>VolumeMode</code> do PV for <code>Filesystem</code> então este campo pode ser usado para especificar o sistema de arquivos que deve ser usado para montar o volume. Se o volume não tiver sido formatado e a formatação for suportada, este valor será utilizado para formatar o volume. Este valor é passado para o driver CSI através do campo <code>VolumeCapability</code> nas propriedades <code>ControllerPublishVolumeRequest</code>, <code>NodeStageVolumeRequest</code> e <code>NodePublishVolumeRequest</code>.</li><li><code>volumeAttributes</code>: Um mapa de valores do tipo string para string que especifica propriedades estáticas de um volume. Este mapa deve corresponder ao mapa retornado no campo <code>volume.attributes</code> do <code>CreateVolumeResponse</code> pelo driver CSI, conforme definido na <a href=https://github.com/container-storage-interface/spec/blob/master/spec.md#createvolume>especificação CSI</a>. O mapa é passado para o driver CSI através do campo <code>volume_context</code> nas propriedades <code>ControllerPublishVolumeRequest</code>, <code>NodeStageVolumeRequest</code>, e <code>NodePublishVolumeRequest</code>.</li><li><code>controllerPublishSecretRef</code>: Uma referência ao objeto Secret que contém informações confidenciais para passar ao driver CSI para completar as chamadas CSI <code>ControllerPublishVolume</code> e <code>ControllerUnpublishVolume</code>. Este campo é opcional e pode estar vazio se não for necessário nenhum segredo. Se o Secret contiver mais de um segredo, todos os segredos serão passados.</li><li><code>nodeStageSecretRef</code>: Uma referência ao objeto Secret que contém informações confidenciais para passar ao driver de CSI para completar a chamada de CSI do <code>NodeStageVolume</code>. Este campo é opcional e pode estar vazio se não for necessário nenhum segredo. Se o Secret contiver mais de um segredo, todos os segredos serão passados.</li><li><code>nodePublishSecretRef</code>: Uma referência ao objeto Secret que contém informações confidenciais para passar ao driver de CSI para completar a chamada de CSI do <code>NodePublishVolume</code>. Este campo é opcional e pode estar vazio se não for necessário nenhum segredo. Se o objeto Secret contiver mais de um segredo, todos os segredos serão passados.</li></ul><h4 id=suporte-csi-para-volume-de-bloco-bruto>Suporte CSI para volume de bloco bruto</h4><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.18 [stable]</code></div><p>Os fornecedores com drivers CSI externos podem implementar o suporte de volume de blocos brutos nas cargas de trabalho Kubernetes.</p><p>Você pode configurar o <a href=/pt-br/docs/concepts/storage/persistent-volumes/#suporte-a-volume-de-bloco-bruto>PersistentVolume/PersistentVolumeClaim com suporte de volume de bloco bruto</a> , como habitualmente, sem quaisquer alterações específicas de CSI.</p><h4 id=volumes-efêmeros-de-csi>Volumes efêmeros de CSI</h4><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.16 [beta]</code></div><p>É possível configurar diretamente volumes CSI dentro da especificação do Pod. Os volumes especificados desta forma são efêmeros e não persistem nas reinicializações do pod. Consulte <a href=/docs/concepts/storage/ephemeral-volumes/#csi-ephemeral-volumes>Volumes efêmeros</a> para obter mais informações.</p><p>Para obter mais informações sobre como desenvolver um driver CSI, consulte a <a href=https://kubernetes-csi.github.io/docs/>documentação kubernetes-csi</a></p><h4 id=migrando-para-drivers-csi-a-partir-de-plugins-in-tree>Migrando para drivers CSI a partir de plugins in-tree</h4><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.17 [beta]</code></div><p>Quando o recurso <code>CSIMigration</code> está habilitado, direciona operações relacionadas a plugins in-tree existentes para plugins CSI correspondentes (que devem ser instalados e configurados). Como resultado, os operadores não precisam fazer nenhuma alteração de configuração para Storage Classes, PersistentVolumes ou PersistentVolumeClaims existentes (referindo-se aos plugins in-tree) quando a transição para um driver CSI que substitui um plugin in-tree.</p><p>As operações e características que são suportadas incluem: provisionamento/exclusão, anexação/remoção, montargem/desmontagem e redimensionamento de volumes.</p><p>Plugins in-tree que suportam <code>CSIMigration</code> e têm um driver CSI correspondente implementado são listados <a href=#volume-types>em tipos de volumes</a>.</p><h3 id=flexvolume>flexVolume</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.23 [deprecated]</code></div><p>O FlexVolume é uma interface de plugin out-of-tree que usa um modelo baseado em execução para fazer interface com drivers de armazenamento. Os binários do driver FlexVolume devem ser instalados em um caminho de plugin de volume predefinido em cada nó e, em alguns casos, também nos nós da camada de gerenciamento.</p><p>Os Pods interagem com os drivers do FlexVolume através do plugin de volume in-tree <code>flexVolume</code>. Para obter mais detalhes, consulte o documento <a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-storage/flexvolume.md#readme>README</a> do FlexVolume.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong><p>O FlexVolume foi descontinuado. Usar um driver CSI out-of-tree é a maneira recomendada de integrar o armazenamento externo com Kubernetes.</p><p>Os mantenedores do driver FlexVolume devem implementar um driver CSI e ajudar a migrar usuários de drivers FlexVolume para CSI. Os usuários do FlexVolume devem mover suas cargas de trabalho para usar o driver CSI equivalente.</p></div><h2 id=propagação-de-montagem>Propagação de montagem</h2><p>A propagação de montagem permite compartilhar volumes montados por um contêiner para outros contêineres no mesmo pod, ou mesmo para outros pods no mesmo nó.</p><p>A propagação de montagem de um volume é controlada pelo campo <code>mountPropagation</code> na propriedade <code>Container.volumeMounts</code>. Os seus valores são:</p><ul><li><p><code>None</code> - Este volume de montagem não receberá do host nenhuma montagem posterior que seja montada para este volume ou qualquer um de seus subdiretórios. De forma semelhante, nenhum ponto de montagem criado pelo contêiner será visível no host. Este é o modo padrão.</p><p>Este modo é igual à propagação de montagem <code>private</code> conforme descrito na <a href=https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt>documentação do kernel Linux</a></p></li><li><p><code>HostToContainer</code> - Este volume de montagem receberá todas as montagens posteriores que forem montadas para este volume ou qualquer um de seus subdiretórios.</p><p>Em outras palavras, se o host montar qualquer coisa dentro do volume de montagem, o container o visualizará montado ali.</p><p>Da mesma forma, se qualquer Pod com propagação de montagem <code>Bidirectional</code> para o mesmo volume montar qualquer coisa lá, o contêiner com propagação de montagem <code>HostToContainer</code> o reconhecerá.</p><p>Este modo é igual à propagação de montagem <code>rslave</code> conforme descrito na <a href=https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt>documentação do kernel Linux</a></p></li><li><p><code>Bidirectional</code> - Esta montagem de volume se comporta da mesma forma que a montagem de volume <code>HostToContainer</code>. Além disso, todas as montagens de volume criadas pelo contêiner serão propagadas de volta ao host e a todos os contêineres de todas os pods que utilizam o mesmo volume.</p><p>Um caso de uso típico para este modo é um Pod com um driver FlexVolume ou CSI ou um Pod que precisa montar algo no host utilizando um volume <code>hostPath</code>.</p><p>Este modo é igual à propagação de montagem <code>rshared</code> conforme descrito na <a href=https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt>documentação do kernel Linux</a></p><div class="alert alert-danger warning callout" role=alert><strong>Aviso:</strong> A propagação de montagem <code>Bidirectional</code> pode ser perigosa. Ela pode danificar o sistema operacional do host e, portanto, ela só é permitida em contêineres privilegiados. A familiaridade com o comportamento do kernel Linux é fortemente recomendada. Além disso, quaisquer montagens de volume criadas por contêineres em pods devem ser destruídas ( desmontadas) pelos contêineres ao final.</div></li></ul><h3 id=configuração>Configuração</h3><p>Antes que a propagação da montagem possa funcionar corretamente em algumas distribuições (CoreOS, RedHat/Centos, Ubuntu), o compartilhamento de montagem deve ser configurado corretamente no Docker como mostrado abaixo.</p><p>Edite seu arquivo de serviços <code>systemd</code> do Docker. Configure a propriedade <code>MountFlags</code> da seguinte forma:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#b8860b>MountFlags</span><span style=color:#666>=</span>shared
</span></span></code></pre></div><p>Ou, se a propriedade <code>MountFlags=slave</code>existir, remova-a. Em seguida, reinicie o daemon Docker:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sudo systemctl daemon-reload
</span></span><span style=display:flex><span>sudo systemctl restart docker
</span></span></code></pre></div><h2 id=próximos-passos>Próximos passos</h2><p>Siga um exemplo de <a href=/docs/tutorials/stateful-application/mysql-wordpress-persistent-volume/>implantação do WordPress e MySQL com volumes persistentes</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-ffd12528a12882b282e1bd19e29f9e75>3.5.2 - Volumes Persistentes</h1><p>Esse documento descreve o estado atual dos <em>volumes persistentes</em> no Kubernetes. Sugerimos que esteja familiarizado com <a href=/docs/concepts/storage/volumes/>volumes</a>.</p><h2 id=introdução>Introdução</h2><p>O gerenciamento de armazenamento é uma questão bem diferente do gerenciamento de instâncias computacionais. O subsistema PersistentVolume provê uma API para usuários e administradores que mostra de forma detalhada de como o armazenamento é provido e como ele é consumido. Para isso, nós introduzimos duas novas APIs: PersistentVolume e PersistentVolumeClaim.</p><p>Um <em>PersistentVolume</em> (PV) é uma parte do armazenamento dentro do cluster que tenha sido provisionada por um administrador, ou dinamicamente utilizando <a href=/docs/concepts/storage/storage-classes/>Classes de Armazenamento</a>. Isso é um recurso dentro do cluster da mesma forma que um nó também é. PVs são plugins de volume da mesma forma que Volumes, porém eles têm um ciclo de vida independente de qualquer Pod que utilize um PV. Essa API tem por objetivo mostrar os detalhes da implementação do armazenamento, seja ele NFS, iSCSI, ou um armazenamento específico de um provedor de cloud pública.</p><p>Uma <em>PersistentVolumeClaim</em> (PVC) é uma requisição para armazenamento por um usuário. É similar a um Pod. Pods utilizam recursos do nó e PVCs utilizam recursos do PV. Pods podem solicitar níveis específicos de recursos (CPU e Memória). Claims podem solicitar tamanho e modos de acesso específicos (exemplo: montagem como ReadWriteOnce, ReadOnlyMany ou ReadWriteMany, veja <a href=#modos-de-acesso>Modos de Acesso</a>).</p><p>Enquanto as PersistentVolumeClaims permitem que um usuário utilize recursos de armazenamento de forma limitada, é comum que usuários precisem de PersistentVolumes com diversas propriedades, como desempenho, para problemas diversos. Os administradores de cluster precisam estar aptos a oferecer uma variedade de PersistentVolumes que difiram em tamanho e modo de acesso, sem expor os usuários a detalhes de como esses volumes são implementados. Para necessidades como essas, temos o recurso de <em>StorageClass</em>.</p><p>Veja os <a href=/docs/tasks/configure-pod-container/configure-persistent-volume-storage/>exemplos de passo a passo de forma detalhada</a>.</p><h2 id=requisição-e-ciclo-de-vida-de-um-volume>Requisição e ciclo de vida de um volume</h2><p>PVs são recursos dentro um cluster. PVCs são requisições para esses recursos e também atuam como uma validação da solicitação desses recursos. O ciclo de vida da interação entre PVs e PVCs funcionam da seguinte forma:</p><h3 id=provisionamento>Provisionamento</h3><p>Existem duas formas de provisionar um PV: estaticamente ou dinamicamente.</p><h4 id=estático>Estático</h4><p>O administrador do cluster cria uma determinada quantidade de PVs. Eles possuem todos os detalhes do armazenamento os quais estão atrelados, que neste caso fica disponível para utilização por um usuário dentro do cluster. Eles estão presentes na API do Kubernetes e disponíveis para utilização.</p><h4 id=dinâmico>Dinâmico</h4><p>Quando nenhum dos PVs estáticos, que foram criados anteriormente pelo administrador, satisfazem os critérios de uma PersistentVolumeClaim enviado por um usuário, o cluster pode tentar realizar um provisionamento dinâmico para atender a essa PVC. Esse provisionamento é baseado em StorageClasses: a PVC deve solicitar uma <a href=/docs/concepts/storage/storage-classes/>classe de armazenamento</a> e o administrador deve ter previamente criado e configurado essa classe para que o provisionamento dinâmico possa ocorrer. Requisições que solicitam a classe <code>""</code> efetivamente desabilitam o provisionamento dinâmico para elas mesmas.</p><p>Para habilitar o provisionamento de armazenamento dinâmico baseado em classe de armazenamento, o administrador do cluster precisa habilitar o <a href=/docs/reference/access-authn-authz/admission-controllers/#defaultstorageclass>controle de admissão</a> <code>DefaultStorageClass</code> no servidor da API. Isso pode ser feito, por exemplo, garantindo que <code>DefaultStorageClass</code> esteja entre aspas simples, ordenado por uma lista de valores para a flag <code>--enable-admission-plugins</code>, componente do servidor da API. Para mais informações sobre os comandos das flags do servidor da API, consulte a documentação <a href=/docs/admin/kube-apiserver/>kube-apiserver</a>.</p><h3 id=binding>Binding</h3><p>Um usuário cria, ou em caso de um provisionamento dinâmico já ter criado, uma PersistentVolumeClaim solicitando uma quantidade específica de armazenamento e um determinado modo de acesso. Um controle de loop no master monitora por novas PVCs, encontra um PV (se possível) que satisfaça os requisitos e realiza o bind. Se o PV foi provisionado dinamicamente por uma PVC, o loop sempre vai fazer o bind desse PV com essa PVC em específico. Caso contrário, o usuário vai receber no mínimo o que ele havia solicitado, porém, o volume possa exceder em relação à solicitação inicial. Uma vez realizado esse processo, PersistentVolumeClaim sempre vai ter um bind exclusivo, sem levar em conta como o isso aconteceu. Um bind entre uma PVC e um PV é um mapeamento de um para um, utilizando o ClaimRef que é um bind bidirecional entre o PersistentVolume e o PersistentVolumeClaim.</p><p>As requisições permanecerão sem bind se o volume solicitado não existir. O bind ocorrerá somente se os requisitos forem atendidos exatamente da mesma forma como solicitado. Por exemplo, um bind de uma PVC de 100 GB não ocorrerá num cluster que foi provisionado com vários PVs de 50 GB. O bind ocorrerá somente no momento em que um PV de 100 GB for adicionado.</p><h3 id=utilização>Utilização</h3><p>Pods utilizam requisições como volumes. O cluster inspeciona a requisição para encontrar o volume atrelado a ela e monta esse volume para um Pod. Para volumes que suportam múltiplos modos de acesso, o usuário especifica qual o modo desejado quando utiliza essas requisições.</p><p>Uma vez que o usuário tem a requisição atrelada a um PV, ele pertence ao usuário pelo tempo que ele precisar. Usuários agendam Pods e acessam seus PVs requisitados através da seção <code>persistentVolumeClaim</code> no bloco <code>volumes</code> do Pod. Para mais detalhes sobre isso, veja <a href=#requisi%C3%A7%C3%B5es-como-volumes>Requisições como Volumes</a>.</p><h3 id=proteção-de-uso-de-um-objeto-de-armazenamento>Proteção de Uso de um Objeto de Armazenamento</h3><p>O propósito da funcionalidade do Objeto de Armazenamento em Proteção de Uso é garantir que as PersistentVolumeClaims (PVCs) que estejam sendo utilizadas por um Pod e PersistentVolume (PVs) que pertençam aos PVCs não sejam removidos do sistema, pois isso pode resultar numa perda de dados.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Uma PVC está sendo utilizada por um Pod quando existe um Pod que está usando essa PVC.</div><p>Se um usuário deleta uma PVC que está sendo utilizada por um Pod, esta PVC não é removida imediatamente. A remoção da PVC é adiada até que a PVC não esteja mais sendo utilizado por nenhum Pod. Se um administrador deleta um PV que está atrelado a uma PVC, o PV não é removido imediatamente também. A remoção do PV é adiada até que o PV não esteja mais atrelado à PVC.</p><p>Note que uma PVC é protegida quando o status da PVC é <code>Terminating</code> e a lista <code>Finalizers</code> contém <code>kubernetes.io/pvc-protection</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe pvc hostpath
</span></span><span style=display:flex><span>Name:          hostpath
</span></span><span style=display:flex><span>Namespace:     default
</span></span><span style=display:flex><span>StorageClass:  example-hostpath
</span></span><span style=display:flex><span>Status:        Terminating
</span></span><span style=display:flex><span>Volume:
</span></span><span style=display:flex><span>Labels:        &lt;none&gt;
</span></span><span style=display:flex><span>Annotations:   volume.beta.kubernetes.io/storage-class<span style=color:#666>=</span>example-hostpath
</span></span><span style=display:flex><span>               volume.beta.kubernetes.io/storage-provisioner<span style=color:#666>=</span>example.com/hostpath
</span></span><span style=display:flex><span>Finalizers:    <span style=color:#666>[</span>kubernetes.io/pvc-protection<span style=color:#666>]</span>
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>Note que um PV é protegido quando o status da PVC é <code>Terminating</code> e a lista <code>Finalizers</code> contém <code>kubernetes.io/pv-protection</code> também:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe pv task-pv-volume
</span></span><span style=display:flex><span>Name:            task-pv-volume
</span></span><span style=display:flex><span>Labels:          <span style=color:#b8860b>type</span><span style=color:#666>=</span><span style=color:#a2f>local</span>
</span></span><span style=display:flex><span>Annotations:     &lt;none&gt;
</span></span><span style=display:flex><span>Finalizers:      <span style=color:#666>[</span>kubernetes.io/pv-protection<span style=color:#666>]</span>
</span></span><span style=display:flex><span>StorageClass:    standard
</span></span><span style=display:flex><span>Status:          Terminating
</span></span><span style=display:flex><span>Claim:
</span></span><span style=display:flex><span>Reclaim Policy:  Delete
</span></span><span style=display:flex><span>Access Modes:    RWO
</span></span><span style=display:flex><span>Capacity:        1Gi
</span></span><span style=display:flex><span>Message:
</span></span><span style=display:flex><span>Source:
</span></span><span style=display:flex><span>    Type:          HostPath <span style=color:#666>(</span>bare host directory volume<span style=color:#666>)</span>
</span></span><span style=display:flex><span>    Path:          /tmp/data
</span></span><span style=display:flex><span>    HostPathType:
</span></span><span style=display:flex><span>Events:            &lt;none&gt;
</span></span></code></pre></div><h3 id=recuperação>Recuperação</h3><p>Quando um usuário não precisar mais utilizar um volume, ele pode deletar a PVC pela API, que, permite a recuperação do recurso. A política de recuperação para um PersistentVolume diz ao cluster o que fazer com o volume após ele ter sido liberado da sua requisição. Atualmente, volumes podem ser Retidos, Reciclados ou Deletados.</p><h4 id=retenção>Retenção</h4><p>A política <code>Retain</code> permite a recuperação de forma manual do recurso. Quando a PersistentVolumeClaim é deletada, ela continua existindo e o volume é considerado "livre". Mas ele ainda não está disponível para outra requisição porque os dados da requisição anterior ainda permanecem no volume. Um administrador pode manualmente recuperar o volume executando os seguintes passos:</p><ol><li>Deletar o PersistentVolume. O armazenamento associado à infraestrutura externa (AWS EBS, GCE PD, Azure Disk ou Cinder volume) ainda continuará existindo após o PV ser deletado.</li><li>Limpar os dados de forma manual no armazenamento associado.</li><li>Deletar manualmente o armazenamento associado. Caso você queira utilizar o mesmo armazenamento, crie um novo PersistentVolume com esse armazenamento.</li></ol><h4 id=deletar>Deletar</h4><p>Para plugins de volume que suportam a política de recuperação <code>Delete</code>, a deleção vai remover o tanto o PersistentVolume do Kubernetes, quanto o armazenamento associado à infraestrutura externa, como AWS EBS, GCE PD, Azure Disk, ou Cinder volume. Volumes que foram provisionados dinamicamente herdam a <a href=#pol%C3%ADtica-de-reten%C3%A7%C3%A3o>política de retenção da sua StorageClass</a>, que por padrão é <code>Delete</code>. O administrador precisa configurar a StorageClass de acordo com as necessidades dos usuários. Caso contrário, o PV deve ser editado ou reparado após sua criação. Veja <a href=/docs/tasks/administer-cluster/change-pv-reclaim-policy/>Alterar a política de retenção de um PersistentVolume</a>.</p><h4 id=reciclar>Reciclar</h4><div class="alert alert-danger warning callout" role=alert><strong>Aviso:</strong> A política de retenção <code>Recycle</code> está depreciada. Ao invés disso, recomendamos a utilização de provisionamento dinâmico.</div><p>Em caso do volume plugin ter suporte a essa operação, a política de retenção <code>Recycle</code> faz uma limpeza básica (<code>rm -rf /thevolume/*</code>) no volume e torna ele disponível novamente para outra requisição.</p><p>Contudo, um administrador pode configurar um template personalizado de um Pod reciclador utilizando a linha de comando do gerenciamento de controle do Kubernetes como descrito em <a href=/docs/reference/command-line-tools-reference/kube-controller-manager/>referência</a>.
O Pod reciclador personalizado deve conter a spec <code>volume</code> como é mostrado no exemplo abaixo:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pv-recycler<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>vol<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/any/path/it/will/be/replaced<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pv-recycler<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;k8s.gcr.io/busybox&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;/bin/sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;test -e /scrub &amp;&amp; rm -rf /scrub/..?* /scrub/.[!.]* /scrub/*  &amp;&amp; test -z \&#34;$(ls -A /scrub)\&#34; || exit 1&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>vol<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/scrub<span style=color:#bbb>
</span></span></span></code></pre></div><p>Contudo, o caminho especificado no Pod reciclador personalizado em <code>volumes</code> é substituído pelo caminho do volume que está sendo reciclado.</p><h3 id=reservando-um-persistentvolume>Reservando um PersistentVolume</h3><p>A camada de gerenciamento pode <a href=#binding>fazer o bind de um PersistentVolumeClaims com PersistentVolumes equivalentes</a> no cluster. Contudo, se você quer que uma PVC faça um bind com um PV específico, é preciso fazer o pré-bind deles.</p><p>Especificando um PersistentVolume na PersistentVolumeClaim, você declara um bind entre uma PVC e um PV específico. O bind ocorrerá se o PersistentVolume existir e não estiver reservado por uma PersistentVolumeClaims através do seu campo <code>claimRef</code>.</p><p>O bind ocorre independentemente se algum volume atender ao critério, incluindo afinidade de nó. A camada de gerenciamento verifica se a <a href=/docs/concepts/storage/storage-classes/>classe de armazenamento</a>, modo de acesso e tamanho do armazenamento solicitado ainda são válidos.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo-pvc<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># Empty string must be explicitly set otherwise default StorageClass will be set</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeName</span>:<span style=color:#bbb> </span>foo-pv<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span></code></pre></div><p>Esse método não garante nenhum privilégio de bind no PersistentVolume. Para evitar que alguma outra PersistentVolumeClaims possa usar o PV que você especificar, você precisa primeiro reservar esse volume de armazenamento. Especifique sua PersistentVolumeClaim no campo <code>claimRef</code> do PV para que outras PVCs não façam bind nele.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo-pv<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>claimRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo-pvc<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span></code></pre></div><p>Isso é útil se você deseja utilizar PersistentVolumes que possuem suas <code>claimPolicy</code> configuradas para <code>Retain</code>, incluindo situações onde você estiver reutilizando um PV existente.</p><h3 id=expandindo-requisições-de-volumes-persistentes>Expandindo Requisições de Volumes Persistentes</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.11 [beta]</code></div><p>Agora, o suporte à expansão de PersistentVolumeClaims (PVCs) já é habilitado por padrão. Você pode expandir os tipos de volumes abaixo:</p><ul><li>gcePersistentDisk</li><li>awsElasticBlockStore</li><li>Cinder</li><li>glusterfs</li><li>rbd</li><li>Azure File</li><li>Azure Disk</li><li>Portworx</li><li>FlexVolumes</li><li><a class=glossary-tooltip title='A Interface de Armazenamento de Contêiner (Container Storage Interface, CSI) define um padrão de interface para expor sistemas de armazenamento a contêineres.' data-toggle=tooltip data-placement=top href=/pt-br/docs/concepts/storage/volumes/#csi target=_blank aria-label=CSI>CSI</a></li></ul><p>Você só pode expandir uma PVC se o campo da classe de armazenamento <code>allowVolumeExpansion</code> é <code>true</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>gluster-vol-default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/glusterfs<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resturl</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;http://192.168.10.100:8080&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restusuário</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>secretNamespace</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>allowVolumeExpansion</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Para solicitar um volume maior para uma PVC, edite a PVC e especifique um tamanho maior. Isso irá fazer com o que volume atrelado ao respectivo PersistentVolume seja expandido. Nunca um PersistentVolume é criado para satisfazer a requisição. Ao invés disso, um volume existente é redimensionado.</p><h4 id=expansão-de-volume-csi>Expansão de volume CSI</h4><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.24 [stable]</code></div><p>O suporte à expansão de volumes CSI é habilitada por padrão, porém é necessário um driver CSI específico para suportar a expansão do volume. Verifique a documentação do driver CSI específico para mais informações.</p><h4 id=redimensionando-um-volume-que-contém-um-sistema-de-arquivo>Redimensionando um volume que contém um sistema de arquivo</h4><p>Só podem ser redimensionados os volumes que contém os seguintes sistemas de arquivo: XFS, Ext3 ou Ext4.</p><p>Quando um volume contém um sistema de arquivo, o sistema de arquivo somente é redimensionado quando um novo Pod está utilizando a PersistentVolumeClaim no modo <code>ReadWrite</code>. A expansão de sistema de arquivo é feita quando um Pod estiver inicializando ou quando um Pod estiver em execução e o respectivo sistema de arquivo tenha suporte para expansão a quente.</p><p>FlexVolumes permitem redimensionamento se o <code>RequiresFSResize</code> do drive é configurado como <code>true</code>. O FlexVolume pode ser redimensionado na reinicialização do Pod.</p><h4 id=redimensionamento-de-uma-persistentvolumeclaim-em-uso>Redimensionamento de uma PersistentVolumeClaim em uso</h4><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.15 [beta]</code></div><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> A Expansão de PVCs em uso está disponível como beta desde o Kubernetes 1.15, e como alpha desde a versão 1.11. A funcionalidade <code>ExpandInUsePersistentVolumes</code> precisa ser habilitada, o que já está automático para vários clusters que possuem funcionalidades beta. Verifique a documentação <a href=/docs/reference/command-line-tools-reference/feature-gates/>feature gate</a> para mais informações.</div><p>Neste caso, você não precisa deletar e recriar um Pod ou um deployment que está sendo utilizado por uma PVC existente.
Automaticamente, qualquer PVC em uso fica disponível para o Pod assim que o sistema de arquivo for expandido.
Essa funcionalidade não tem efeito em PVCs que não estão em uso por um Pod ou deployment. Você deve criar um Pod que utilize a PVC antes que a expansão seja completada.</p><p>Da mesma forma que outros tipos de volumes - volumes FlexVolume também podem ser expandidos quando estiverem em uso por um Pod.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Redimensionamento de FlexVolume somente é possível quando o respectivo driver suportar essa operação.</div><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Expandir volumes do tipo EBS é uma operação que toma muito tempo. Além disso, só é possível fazer uma modificação por volume a cada 6 horas.</div><h4 id=recuperação-em-caso-de-falha-na-expansão-de-volumes>Recuperação em caso de falha na expansão de volumes</h4><p>Se a expansão do respectivo armazenamento falhar, o administrador do cluster pode recuperar manualmente o estado da Persistent Volume Claim (PVC) e cancelar as solicitações de redimensionamento. Caso contrário, as tentativas de solicitação de redimensionamento ocorrerão de forma contínua pelo controlador sem nenhuma intervenção do administrador.</p><ol><li>Marque o PersistentVolume(PV) que estiver atrelado à PersistentVolumeClaim(PVC) com a política de recuperação <code>Retain</code>.</li><li>Delete a PVC. Desde que o PV tenha a política de recuperação <code>Retain</code> - nenhum dado será perdido quando a PVC for recriada.</li><li>Delete a entrada <code>claimRef</code> da especificação do PV para que uma PVC possa fazer bind com ele. Isso deve tornar o PV <code>Available</code>.</li><li>Recrie a PVC com um tamanho menor que o PV e configure o campo <code>volumeName</code> da PCV com o nome do PV. Isso deve fazer o bind de uma nova PVC a um PV existente.</li><li>Não esqueça de restaurar a política de recuperação do PV.</li></ol><h2 id=tipos-de-volumes-persistentes>Tipos de volumes persistentes</h2><p>Tipos de PersistentVolume são implementados como plugins. Atualmente o Kubernetes suporta os plugins abaixo:</p><ul><li><a href=/docs/concepts/storage/volumes/#awselasticblockstore><code>awsElasticBlockStore</code></a> - AWS Elastic Block Store (EBS)</li><li><a href=/docs/concepts/storage/volumes/#azuredisk><code>azureDisk</code></a> - Azure Disk</li><li><a href=/docs/concepts/storage/volumes/#azurefile><code>azureFile</code></a> - Azure File</li><li><a href=/docs/concepts/storage/volumes/#cephfs><code>cephfs</code></a> - CephFS volume</li><li><a href=/docs/concepts/storage/volumes/#cinder><code>cinder</code></a> - Cinder (OpenStack block storage)
(<strong>depreciado</strong>)</li><li><a href=/docs/concepts/storage/volumes/#csi><code>csi</code></a> - Container Storage Interface (CSI)</li><li><a href=/docs/concepts/storage/volumes/#fc><code>fc</code></a> - Fibre Channel (FC) storage</li><li><a href=/docs/concepts/storage/volumes/#flexVolume><code>flexVolume</code></a> - FlexVolume</li><li><a href=/docs/concepts/storage/volumes/#flocker><code>flocker</code></a> - Flocker storage</li><li><a href=/docs/concepts/storage/volumes/#gcepersistentdisk><code>gcePersistentDisk</code></a> - GCE Persistent Disk</li><li><a href=/docs/concepts/storage/volumes/#glusterfs><code>glusterfs</code></a> - Glusterfs volume</li><li><a href=/docs/concepts/storage/volumes/#hostpath><code>hostPath</code></a> - HostPath volume
(somente para teste de nó único; ISSO NÃO FUNCIONARÁ num cluster multi-nós; ao invés disso, considere a utilização de volume <code>local</code>.)</li><li><a href=/docs/concepts/storage/volumes/#iscsi><code>iscsi</code></a> - iSCSI (SCSI over IP) storage</li><li><a href=/docs/concepts/storage/volumes/#local><code>local</code></a> - storage local montados nos nós.</li><li><a href=/docs/concepts/storage/volumes/#nfs><code>nfs</code></a> - Network File System (NFS) storage</li><li><code>photonPersistentDisk</code> - Controlador Photon para disco persistente.
(Esse tipo de volume não funciona mais desde a removação do provedor de cloud correspondente.)</li><li><a href=/docs/concepts/storage/volumes/#portworxvolume><code>portworxVolume</code></a> - Volume Portworx</li><li><a href=/docs/concepts/storage/volumes/#quobyte><code>quobyte</code></a> - Volume Quobyte</li><li><a href=/docs/concepts/storage/volumes/#rbd><code>rbd</code></a> - Volume Rados Block Device (RBD)</li><li><a href=/docs/concepts/storage/volumes/#scaleio><code>scaleIO</code></a> - Volume ScaleIO
(<strong>depreciado</strong>)</li><li><a href=/docs/concepts/storage/volumes/#storageos><code>storageos</code></a> - Volume StorageOS</li><li><a href=/docs/concepts/storage/volumes/#vspherevolume><code>vsphereVolume</code></a> - Volume vSphere VMDK</li></ul><h2 id=volumes-persistentes>Volumes Persistentes</h2><p>Cada PV contém uma <code>spec</code> e um status, que é a especificação e o status do volume. O nome do PersistentVolume deve ser um <a href=/pt-br/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNS</a> válido.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pv0003<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>capacity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>5Gi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeMode</span>:<span style=color:#bbb> </span>Filesystem<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>persistentVolumeReclaimPolicy</span>:<span style=color:#bbb> </span>Retain<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>slow<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>mountOptions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- hard<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- nfsvers=4.1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nfs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/tmp<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>server</span>:<span style=color:#bbb> </span><span style=color:#666>172.17.0.2</span><span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Talvez sejam necessários programas auxiliares para um determinado tipo de volume utilizar um PersistentVolume no cluster. Neste exemplo, o PersistentVolume é do tipo NFS e o programa auxiliar <em>/sbin/mount.nfs</em> é necessário para suportar a montagem dos sistemas de arquivos NFS.</div><h3 id=capacidade>Capacidade</h3><p>Geralmente, um PV terá uma capacidade de armazenamento específica. Isso é configurado usando o atributo <code>capacity</code> do PV. Veja o <a href=https://git.k8s.io/community/contributors/design-proposals/scheduling/resources.md>Modelo de Recurso</a> do Kubernetes para entender as unidades aceitas pelo atributo <code>capacity</code>.</p><p>Atualmente, o tamanho do armazenamento é o único recurso que pode ser configurado ou solicitado. Os futuros atributos podem incluir IOPS, throughput, etc.</p><h3 id=modo-do-volume>Modo do Volume</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.18 [stable]</code></div><p>O Kubernetes suporta dois <code>volumeModes</code> de PersistentVolumes: <code>Filesystem</code> e <code>Block</code>.</p><p><code>volumeMode</code> é um parâmetro opcional da API.
<code>Filesystem</code> é o modo padrão utilizado quando o parâmetro <code>volumeMode</code> é omitido.</p><p>Um volume com <code>volumeMode: Filesystem</code> é <em>montado</em> em um diretório nos Pods. Se o volume for de um dispositivo de bloco e ele estiver vazio, o Kubernetes cria o sistema de arquivo no dispositivo antes de fazer a montagem pela primeira vez.</p><p>Você pode configurar o valor do <code>volumeMode</code> para <code>Block</code> para utilizar um disco bruto como volume. Esse volume é apresentado num Pod como um dispositivo de bloco, sem nenhum sistema de arquivo. Esse modo é útil para prover ao Pod a forma mais rápida para acessar um volume, sem nenhuma camada de sistema de arquivo entre o Pod e o volume. Por outro lado, a aplicação que estiver rodando no Pod deverá saber como tratar um dispositivo de bloco. Veja <a href=#raw-block-volume-support>Suporte a Volume de Bloco Bruto</a> para um exemplo de como utilizar o volume como <code>volumeMode: Block</code> num Pod.</p><h3 id=modos-de-acesso>Modos de Acesso</h3><p>Um PersistentVolume pode ser montado num host das mais variadas formas suportadas pelo provedor. Como mostrado na tabela abaixo, os provedores terão diferentes capacidades e cada modo de acesso do PV são configurados nos modos específicos suportados para cada volume em particular. Por exemplo, o NFS pode suportar múltiplos clientes read/write, mas um PV NFS específico pode ser exportado no server como read-only. Cada PV recebe seu próprio modo de acesso que descreve suas capacidades específicas.</p><p>Os modos de acesso são:</p><ul><li>ReadWriteOnce -- o volume pode ser montado como leitura-escrita por um nó único</li><li>ReadOnlyMany -- o volume pode ser montado como somente-leitura por vários nós</li><li>ReadWriteMany -- o volume pode ser montado como leitura-escrita por vários nós</li></ul><p>Na linha de comando, os modos de acesso ficam abreviados:</p><ul><li>RWO - ReadWriteOnce</li><li>ROX - ReadOnlyMany</li><li>RWX - ReadWriteMany</li></ul><blockquote><p><strong>Importante!</strong> Um volume somente pode ser montado utilizando um único modo de acesso por vez, independente se ele suportar mais de um. Por exemplo, um GCEPersistentDisk pode ser montado como ReadWriteOnce por um único nó ou ReadOnlyMany por vários nós, porém não simultaneamente.</p></blockquote><table><thead><tr><th style=text-align:left>Plugin de Volume</th><th style=text-align:center>ReadWriteOnce</th><th style=text-align:center>ReadOnlyMany</th><th style=text-align:center>ReadWriteMany</th></tr></thead><tbody><tr><td style=text-align:left>AWSElasticBlockStore</td><td style=text-align:center>✓</td><td style=text-align:center>-</td><td style=text-align:center>-</td></tr><tr><td style=text-align:left>AzureFile</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td></tr><tr><td style=text-align:left>AzureDisk</td><td style=text-align:center>✓</td><td style=text-align:center>-</td><td style=text-align:center>-</td></tr><tr><td style=text-align:left>CephFS</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td></tr><tr><td style=text-align:left>Cinder</td><td style=text-align:center>✓</td><td style=text-align:center>-</td><td style=text-align:center>-</td></tr><tr><td style=text-align:left>CSI</td><td style=text-align:center>depende do driver</td><td style=text-align:center>depende do driver</td><td style=text-align:center>depende do driver</td></tr><tr><td style=text-align:left>FC</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td style=text-align:center>-</td></tr><tr><td style=text-align:left>FlexVolume</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td style=text-align:center>depende do driver</td></tr><tr><td style=text-align:left>Flocker</td><td style=text-align:center>✓</td><td style=text-align:center>-</td><td style=text-align:center>-</td></tr><tr><td style=text-align:left>GCEPersistentDisk</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td style=text-align:center>-</td></tr><tr><td style=text-align:left>Glusterfs</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td></tr><tr><td style=text-align:left>HostPath</td><td style=text-align:center>✓</td><td style=text-align:center>-</td><td style=text-align:center>-</td></tr><tr><td style=text-align:left>iSCSI</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td style=text-align:center>-</td></tr><tr><td style=text-align:left>Quobyte</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td></tr><tr><td style=text-align:left>NFS</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td></tr><tr><td style=text-align:left>RBD</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td style=text-align:center>-</td></tr><tr><td style=text-align:left>VsphereVolume</td><td style=text-align:center>✓</td><td style=text-align:center>-</td><td style=text-align:center>(funcionam quando os Pods são do tipo collocated)</td></tr><tr><td style=text-align:left>PortworxVolume</td><td style=text-align:center>✓</td><td style=text-align:center>-</td><td style=text-align:center>✓</td></tr><tr><td style=text-align:left>ScaleIO</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td style=text-align:center>-</td></tr><tr><td style=text-align:left>StorageOS</td><td style=text-align:center>✓</td><td style=text-align:center>-</td><td style=text-align:center>-</td></tr></tbody></table><h3 id=classe>Classe</h3><p>Um PV pode ter uma classe, que é especificada na configuração do atributo <code>storageClassName</code> com o nome da <a href=/docs/concepts/storage/storage-classes/>StorageClass</a>. Um PV de uma classe específica só pode ser atrelado a requisições PVCs dessa mesma classe. Um PV sem <code>storageClassName</code> não possui nenhuma classe e pode ser montado somente a PVCs que não solicitem nenhuma classe em específico.</p><p>No passado, a notação <code>volume.beta.kubernetes.io/storage-class</code> era utilizada no lugar do atributo <code>storageClassName</code>. Essa notação ainda funciona. Contudo, ela será totalmente depreciada numa futura versão do Kubernetes.</p><h3 id=política-de-retenção>Política de Retenção</h3><p>Atualmente as políticas de retenção são:</p><ul><li>Retain -- recuperação manual</li><li>Recycle -- limpeza básica (<code>rm -rf /thevolume/*</code>)</li><li>Delete -- o volume de armazenamento associado, como AWS EBS, GCE PD, Azure Disk ou OpenStack Cinder é deletado</li></ul><p>Atualmente, somente NFS e HostPath suportam reciclagem. Volumes AWS EBS, GCE PD, Azure Disk e Cinder suportam delete.</p><h3 id=opções-de-montagem>Opções de Montagem</h3><p>Um administrador do Kubernetes pode especificar opções de montagem adicionais quando um Volume Persistente é montado num nó.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Nem todos os tipos de Volume Persistente suportam opções de montagem.</div><p>Seguem os tipos de volumes que suportam opções de montagem.</p><ul><li>AWSElasticBlockStore</li><li>AzureDisk</li><li>AzureFile</li><li>CephFS</li><li>Cinder (OpenStack block storage)</li><li>GCEPersistentDisk</li><li>Glusterfs</li><li>NFS</li><li>Quobyte Volumes</li><li>RBD (Ceph Block Device)</li><li>StorageOS</li><li>VsphereVolume</li><li>iSCSI</li></ul><p>Não há validação em relação às opções de montagem. A montagem irá falhar se houver alguma opção inválida.</p><p>No passado, a notação <code>volume.beta.kubernetes.io/mount-options</code> era usada no lugar do atributo <code>mountOptions</code>. Essa notação ainda funciona. Contudo, ela será totalmente depreciada numa futura versão do Kubernetes.</p><h3 id=afinidade-de-nó>Afinidade de Nó</h3><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Para a maioria dos tipos de volume, a configuração desse campo não se faz necessária. Isso é automaticamente populado pelos seguintes volumes de bloco do tipo: <a href=/docs/concepts/storage/volumes/#awselasticblockstore>AWS EBS</a>, <a href=/docs/concepts/storage/volumes/#gcepersistentdisk>GCE PD</a> e <a href=/docs/concepts/storage/volumes/#azuredisk>Azure Disk</a>. Você precisa deixar isso configurado para volumes do tipo <a href=/docs/concepts/storage/volumes/#local>local</a>.</div><p>Um PV pode especificar uma <a href=/docs/reference/generated/kubernetes-api/v1.25/#volumenodeaffinity-v1-core>afinidade de nó</a> para definir restrições em relação ao limite de nós que podem acessar esse volume. Pods que utilizam um PV serão somente reservados para nós selecionados pela afinidade de nó.</p><h3 id=estado>Estado</h3><p>Um volume sempre estará em um dos seguintes estados:</p><ul><li>Available -- um recurso que está livre e ainda não foi atrelado a nenhuma requisição</li><li>Bound -- um volume atrelado a uma requisição</li><li>Released -- a requisição foi deletada, mas o curso ainda não foi recuperado pelo cluster</li><li>Failed -- o volume fracassou na sua recuperação automática</li></ul><p>A CLI mostrará o nome do PV que foi atrelado à PVC</p><h2 id=persistentvolumeclaims>PersistentVolumeClaims</h2><p>Cada PVC contém uma <code>spec</code> e um status, que é a especificação e estado de uma requisição. O nome de um objeto PersistentVolumeClaim precisa ser um <a href=/pt-br/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNS</a> válido.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myclaim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeMode</span>:<span style=color:#bbb> </span>Filesystem<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>8Gi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>slow<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>release</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;stable&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- {<span style=color:green;font-weight:700>key: environment, operator: In, values</span>:<span style=color:#bbb> </span>[dev]}<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=modos-de-acesso-1>Modos de Acesso</h3><p>As requisições usam as mesmas convenções que os volumes quando eles solicitam um armazenamento com um modo de acesso específico.</p><h3 id=modos-de-volume>Modos de Volume</h3><p>As requisições usam as mesmas convenções que os volumes quando eles indicam o tipo de volume, seja ele um sistema de arquivo ou dispositivo de bloco.</p><h3 id=recursos>Recursos</h3><p>Assim como Pods, as requisições podem solicitar quantidades específicas de recurso. Neste caso, a solicitação é por armazenamento. O mesmo <a href=https://git.k8s.io/community/contributors/design-proposals/scheduling/resources.md>modelo de recurso</a> vale para volumes e requisições.</p><h3 id=seletor>Seletor</h3><p>Requisições podem especifiar um <a href=/docs/concepts/overview/working-with-objects/labels/#label-selectors>seletor de rótulo</a> para posteriormente filtrar um grupo de volumes. Somente os volumes que possuam rótulos que satisfaçam os critérios do seletor podem ser atrelados à requisição. O seletor pode conter dois campos:</p><ul><li><code>matchLabels</code> - o volume deve ter um rótulo com esse valor</li><li><code>matchExpressions</code> - uma lista de requisitos, como chave, lista de valores e operador relacionado aos valores e chaves. São operadores válidos: In, NotIn, Exists e DoesNotExist.</li></ul><p>Todos os requisitos de <code>matchLabels</code> e <code>matchExpressions</code>, são do tipo AND - todos eles juntos devem ser atendidos.</p><h3 id=classe-1>Classe</h3><p>Uma requisição pode solicitar uma classe específica através da <a href=/docs/concepts/storage/storage-classes/>StorageClass</a> utilizando o atributo <code>storageClassName</code>. Neste caso o bind ocorrerá somente com os PVs que possuírem a mesma classe do <code>storageClassName</code> dos PVCs.</p><p>As PVCs não precisam necessariamente solicitar uma classe. Uma PVC com sua <code>storageClassName</code> configurada como <code>""</code> sempre solicitará um PV sem classe, dessa forma ela sempre será atrelada a um PV sem classe (que não tenha nenhuma notação, ou seja, igual a <code>""</code>). Uma PVC sem <code>storageClassName</code> não é a mesma coisa e será tratada pelo cluster de forma diferente, porém isso dependerá se o <a href=/docs/reference/access-authn-authz/admission-controllers/#defaultstorageclass>puglin de admissão</a> <code>DefaultStorageClass</code> estiver habilitado.</p><ul><li>Se o plugin de admissão estiver habilitado, o administrador poderá especificar a StorageClass padrão. Todas as PVCs que não tiverem <code>storageClassName</code> podem ser atreladas somente a PVs que atendam a esse padrão. A especificação de uma StorageClass padrão é feita através da notação <code>storageclass.kubernetes.io/is-default-class</code> recebendo o valor <code>true</code> no objeto da StorageClass. Se o administrador não especificar nenhum padrão, o cluster vai tratar a criação de uma PVC como se o plugin de admissão estivesse desabilitado. Se mais de um valor padrão for especificado, o plugin de admissão proíbe a criação de todas as PVCs.</li><li>Se o plugin de admissão estiver desabilitado, não haverá nenhuma notação para a StorageClass padrão. Todas as PVCs que não tiverem <code>storageClassName</code> poderão ser atreladas somente aos PVs que não possuem classe. Neste caso, as PVCs que não tiverem <code>storageClassName</code> são tratadas da mesma forma como as PVCs que possuem suas <code>storageClassName</code> configuradas como <code>""</code>.</li></ul><p>Dependendo do modo de instalação, uma StorageClass padrão pode ser implantada num cluster Kubernetes durante a instalação pelo addon manager.</p><p>Quando uma PVC especifica um <code>selector</code> para solicitar uma StorageClass, os requisitos são do tipo AND: somente um PV com a classe solicitada e com o rótulo requisitado pode ser atrelado à PVC.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Atualmente, uma PVC que tenha <code>selector</code> não pode ter um PV dinamicamente provisionado.</div><p>No passado, a notação <code>volume.beta.kubernetes.io/storage-class</code> era usada no lugar do atributo <code>storageClassName</code> Essa notação ainda funciona. Contudo, ela será totalmente depreciada numa futura versão do Kubernetes.</p><h2 id=requisições-como-volumes>Requisições como Volumes</h2><p>Os Pods podem ter acesso ao armazenamento utilizando a requisição como um volume. Para isso, a requisição tem que estar no mesmo namespace que o Pod. Ao localizar a requisição no namespace do Pod, o cluster passa o PersistentVolume para a requisição.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myfrontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/var/www/html&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypd<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypd<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>persistentVolumeClaim</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>claimName</span>:<span style=color:#bbb> </span>myclaim<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=sobre-namespaces>Sobre Namespaces</h3><p>Os binds dos PersistentVolumes são exclusivos e, desde que as PersistentVolumeClaims são objetos do namespace, fazer a montagem das requisições com "Muitos" nós (<code>ROX</code>, <code>RWX</code>) é possível somente para um namespace.</p><h3 id=persistentvolumes-do-tipo-hostpath>PersistentVolumes do tipo <code>hostPath</code></h3><p>Um PersistentVolume do tipo <code>hostPath</code> utiliza um arquivo ou diretório no nó para emular um network-attached storage (NAS). Veja <a href=/docs/tasks/configure-pod-container/configure-persistent-volume-storage/#create-a-persistentvolume>um exemplo de volume do tipo <code>hostPath</code></a>.</p><h2 id=suporte-a-volume-de-bloco-bruto>Suporte a Volume de Bloco Bruto</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.18 [stable]</code></div><p>Os plugins de volume abaixo suportam volumes de bloco bruto, incluindo provisionamento dinâmico onde for aplicável:</p><ul><li>AWSElasticBlockStore</li><li>AzureDisk</li><li>CSI</li><li>FC (Fibre Channel)</li><li>GCEPersistentDisk</li><li>iSCSI</li><li>Local volume</li><li>OpenStack Cinder</li><li>RBD (Ceph Block Device)</li><li>VsphereVolume</li></ul><h3 id=persistent-volume-using-a-raw-block-volume>Utilização de PersistentVolume com Volume de Bloco Bruto</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>block-pv<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>capacity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>10Gi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeMode</span>:<span style=color:#bbb> </span>Block<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>persistentVolumeReclaimPolicy</span>:<span style=color:#bbb> </span>Retain<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>fc</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetWWNs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;50060e801049cfd1&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>lun</span>:<span style=color:#bbb> </span><span style=color:#666>0</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=persistent-volume-claim-requesting-a-raw-block-volume>Requisição de PersistentVolumeClaim com Volume de Bloco Bruto</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>block-pvc<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeMode</span>:<span style=color:#bbb> </span>Block<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>10Gi<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=especificação-de-pod-com-dispositivo-de-bloco-bruto-no-contêiner>Especificação de Pod com Dispositivo de Bloco Bruto no contêiner</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pod-with-block-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fc-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>fedora:26<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;/bin/sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;tail -f /dev/null&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeDevices</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>data<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>devicePath</span>:<span style=color:#bbb> </span>/dev/xvda<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>data<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>persistentVolumeClaim</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>claimName</span>:<span style=color:#bbb> </span>block-pvc<span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Quando adicionar um dispositivo de bloco bruto num Pod, você especifica o caminho do dispositivo no contêiner ao invés de um ponto de montagem.</div><h3 id=bind-de-volumes-de-bloco>Bind de Volumes de Bloco</h3><p>Se um usuário solicita um volume de bloco bruto através do campo <code>volumeMode</code> na <code>spec</code> da PersistentVolumeClaim, as regras de bind agora têm uma pequena diferença em relação às versões anteriores que não consideravam esse modo como parte da <code>spec</code>.
A tabela abaixo mostra as possíveis combinações que um usuário e um administrador pode especificar para requisitar um dispositivo de bloco bruto. A tabela indica se o volume será ou não atrelado com base nas combinações:
Matriz de bind de volume para provisionamento estático de volumes:</p><table><thead><tr><th>PV volumeMode</th><th style=text-align:center>PVC volumeMode</th><th style=text-align:right>Result</th></tr></thead><tbody><tr><td>unspecified</td><td style=text-align:center>unspecified</td><td style=text-align:right>BIND</td></tr><tr><td>unspecified</td><td style=text-align:center>Block</td><td style=text-align:right>NO BIND</td></tr><tr><td>unspecified</td><td style=text-align:center>Filesystem</td><td style=text-align:right>BIND</td></tr><tr><td>Block</td><td style=text-align:center>unspecified</td><td style=text-align:right>NO BIND</td></tr><tr><td>Block</td><td style=text-align:center>Block</td><td style=text-align:right>BIND</td></tr><tr><td>Block</td><td style=text-align:center>Filesystem</td><td style=text-align:right>NO BIND</td></tr><tr><td>Filesystem</td><td style=text-align:center>Filesystem</td><td style=text-align:right>BIND</td></tr><tr><td>Filesystem</td><td style=text-align:center>Block</td><td style=text-align:right>NO BIND</td></tr><tr><td>Filesystem</td><td style=text-align:center>unspecified</td><td style=text-align:right>BIND</td></tr></tbody></table><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> O provisionamento estático de volumes é suportado somente na versão alpha. Os administradores devem tomar cuidado ao considerar esses valores quando estiverem trabalhando com dispositivos de bloco bruto.</div><h2 id=snapshot-de-volume-e-restauração-de-volume-a-partir-de-um-snapshot>Snapshot de Volume e Restauração de Volume a partir de um Snapshot</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.20 [stable]</code></div><p>O snapshot de volume é suportado somente pelo plugin de volume CSI. Veja <a href=/docs/concepts/storage/volume-snapshots/>Snapshot de Volume</a> para mais detalhes.
Plugins de volume in-tree estão depreciados. Você pode consultar sobre os plugins de volume depreciados em <a href=https://github.com/kubernetes/community/blob/master/sig-storage/volume-plugin-faq.md>Perguntas Frequentes sobre Plugins de Volume</a>.</p><h3 id=create-persistent-volume-claim-from-volume-snapshot>Criar uma PersistentVolumeClaim a partir de um Snapshot de Volume</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>restore-pvc<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>csi-hostpath-sc<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>dataSource</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>new-snapshot-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>VolumeSnapshot<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>snapshot.storage.k8s.io<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>10Gi<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=clonagem-de-volume>Clonagem de Volume</h2><p>A <a href=/docs/concepts/storage/volume-pvc-datasource/>Clonagem de Volume</a> é possível somente com plugins de volume CSI.</p><h3 id=create-persistent-volume-claim-from-an-existing-pvc>Criação de PersistentVolumeClaim a partir de uma PVC já existente</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cloned-pvc<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>my-csi-plugin<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>dataSource</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>existing-src-pvc-name<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>10Gi<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=boas-práticas-de-configuração>Boas Práticas de Configuração</h2><p>Se você está criando templates ou exemplos que rodam numa grande quantidade de clusters e que precisam de armazenamento persistente, recomendamos que utilize o padrão abaixo:</p><ul><li><p>Inclua objetos PersistentVolumeClaim em seu pacote de configuração (com Deployments, ConfigMaps, etc.).</p></li><li><p>Não inclua objetos PersistentVolume na configuração, pois o usuário que irá instanciar a configuração talvez não tenha permissão para criar PersistentVolume.</p></li><li><p>Dê ao usuário a opção dele informar o nome de uma classe de armazenamento quando instanciar o template.</p><ul><li>Se o usuário informar o nome de uma classe de armazenamento, coloque esse valor no campo <code>persistentVolumeClaim.storageClassName</code>. Isso fará com que a PVC encontre a classe de armazenamento correta se o cluster tiver a StorageClasses habilitado pelo administrador.</li><li>Se o usuário não informar o nome da classe de armazenamento, deixe o campo <code>persistentVolumeClaim.storageClassName</code> sem nenhum valor (vazio). Isso fará com que o PV seja provisionado automaticamente no cluster para o usuário com o StorageClass padrão. Muitos ambientes de cluster já possuem uma StorageClass padrão, ou então os administradores podem criar suas StorageClass de acordo com seus critérios.</li></ul></li><li><p>Durante suas tarefas de administração, busque por PVCs que após um tempo não estão sendo atreladas, pois, isso talvez indique que o cluster não tem provisionamento dinâmico (onde o usuário deveria criar um PV que satisfaça os critérios da PVC) ou cluster não tem um sistema de armazenamento (onde usuário não pode realizar um deploy solicitando PVCs).</p><h2 id=próximos-passos>Próximos passos</h2></li></ul><ul><li>Saiba mais sobre <a href=/docs/tasks/configure-pod-container/configure-persistent-volume-storage/#create-a-persistentvolume>Criando um PersistentVolume</a>.</li><li>Saiba mais sobre <a href=/docs/tasks/configure-pod-container/configure-persistent-volume-storage/#create-a-persistentvolumeclaim>Criando um PersistentVolumeClaim</a>.</li><li>Leia a <a href=https://git.k8s.io/design-proposals-archive/storage/persistent-storage.md>documentação sobre planejamento de Armazenamento Persistente</a>.</li></ul><h3 id=referência>Referência</h3><ul><li><a href=/docs/reference/generated/kubernetes-api/v1.25/#persistentvolume-v1-core>PersistentVolume</a></li><li><a href=/docs/reference/generated/kubernetes-api/v1.25/#persistentvolumespec-v1-core>PersistentVolumeSpec</a></li><li><a href=/docs/reference/generated/kubernetes-api/v1.25/#persistentvolumeclaim-v1-core>PersistentVolumeClaim</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-275bea454e1cf4c5adeca4058b5af988>3.6 - Configuração</h1></div><div class=td-content><h1 id=pg-ddef6fd0e47bb51c6f05e8e7fb11d2dd>3.6.1 - Melhores Práticas de Configuração</h1><p>Esse documento destaca e consolida as melhores práticas de configuração apresentadas em todo o guia de usuário,
na documentação de introdução e nos exemplos.</p><p>Este é um documento vivo. Se você pensar em algo que não está nesta lista, mas pode ser útil para outras pessoas,
não hesite em criar uma <em>issue</em> ou submeter um PR.</p><h2 id=dicas-gerais-de-configuração>Dicas Gerais de Configuração</h2><ul><li><p>Ao definir configurações, especifique a versão mais recente estável da API.</p></li><li><p>Os arquivos de configuração devem ser armazenados em um sistema de controle antes de serem enviados ao cluster.
Isso permite que você reverta rapidamente uma alteração de configuração, caso necessário. Isso também auxilia na recriação e restauração do cluster.</p></li><li><p>Escreva seus arquivos de configuração usando YAML ao invés de JSON. Embora esses formatos possam ser usados alternadamente em quase todos os cenários, YAML tende a ser mais amigável.</p></li><li><p>Agrupe objetos relacionados em um único arquivo sempre que fizer sentido. Geralmente, um arquivo é mais fácil de
gerenciar do que vários. Veja o <a href=https://github.com/kubernetes/examples/tree/master/guestbook/all-in-one/guestbook-all-in-one.yaml>guestbook-all-in-one.yaml</a> como exemplo dessa sintaxe.</p></li><li><p>Observe também que vários comandos <code>kubectl</code> podem ser chamados em um diretório. Por exemplo, você pode chamar
<code>kubectl apply</code> em um diretório de arquivos de configuração.</p></li><li><p>Não especifique valores padrões desnecessariamente: configurações simples e mínimas diminuem a possibilidade de erros.</p></li><li><p>Coloque descrições de objetos nas anotações para permitir uma melhor análise.</p></li></ul><h2 id=naked-pods-vs-replicasets-deployments-and-jobs>"Naked" Pods comparados a ReplicaSets, Deployments, e Jobs</h2><ul><li><p>Se você puder evitar, não use "naked" Pods (ou seja, se você puder evitar, pods não vinculados a um <a href=/docs/concepts/workloads/controllers/replicaset/>ReplicaSet</a> ou <a href=/docs/concepts/workloads/controllers/deployment/>Deployment</a>).
Os "naked" pods não serão reconfigurados em caso de falha de um nó.</p><p>Criar um Deployment, que cria um ReplicaSet para garantir que o número desejado de Pods esteja disponível e especifica uma estratégia para substituir os Pods (como <a href=/docs/concepts/workloads/controllers/deployment/#rolling-update-deployment>RollingUpdate</a>), é quase sempre preferível do que criar Pods diretamente, exceto para alguns cenários explícitos de restartPolicy:Never. Um Job também pode ser apropriado.</p></li></ul><h2 id=services>Services</h2><ul><li><p>Crie o <a href=/docs/concepts/services-networking/service/>Service</a> antes de suas cargas de trabalho de backend correspondentes (Deployments ou ReplicaSets) e antes de quaisquer cargas de trabalho que precisem acessá-lo. Quando o
Kubernetes inicia um contêiner, ele fornece variáveis de ambiente apontando para todos os Services que estavam em execução quando o contêiner foi iniciado. Por exemplo, se um Service chamado <code>foo</code> existe, todos os contêineres vão
receber as seguintes variáveis em seu ambiente inicial:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#b8860b>FOO_SERVICE_HOST</span><span style=color:#666>=</span>&lt;o host em que o Service está executando&gt;
</span></span><span style=display:flex><span><span style=color:#b8860b>FOO_SERVICE_PORT</span><span style=color:#666>=</span>&lt;a porta em que o Service está executando&gt;
</span></span></code></pre></div></li></ul><p><em>Isso implica em um requisito de pedido</em> - qualquer <code>Service</code> que um <code>Pod</code> quer acessar precisa ser criado antes do <code>Pod</code> em si, ou então as variáveis de ambiente não serão populadas. O DNS não possui essa restrição.</p><ul><li><p>Um <a href=/docs/concepts/cluster-administration/addons/>cluster add-on</a> opcional (embora fortemente recomendado) é um servidor DNS. O
servidor DNS monitora a API do Kubernetes buscando novos <code>Services</code> e cria um conjunto de DNS para cada um. Se o DNS foi habilitado em todo o cluster, então todos os <code>Pods</code> devem ser capazes de fazer a resolução de <code>Services</code> automaticamente.</p></li><li><p>Não especifique um <code>hostPort</code> para um Pod a menos que isso seja absolutamente necessário. Quando você vincula um Pod a um <code>hostPort</code>, isso limita o número de lugares em que o Pod pode ser agendado, porque cada
combinação de &lt;<code>hostIP</code>, <code>hostPort</code>, <code>protocol</code>> deve ser única. Se você não especificar o <code>hostIP</code> e <code>protocol</code> explicitamente, o Kubernetes vai usar <code>0.0.0.0</code> como o <code>hostIP</code> padrão e <code>TCP</code> como <code>protocol</code> padrão.</p><p>Se você precisa de acesso a porta apenas para fins de depuração, pode usar o <a href=/docs/tasks/access-application-cluster/access-cluster/#manually-constructing-apiserver-proxy-urls>apiserver proxy</a> ou o <a href=/docs/tasks/access-application-cluster/port-forward-access-application-cluster/><code>kubectl port-forward</code></a>.</p><p>Se você precisa expor explicitamente a porta de um Pod no nó, considere usar um Service do tipo <a href=/docs/concepts/services-networking/service/#nodeport>NodePort</a> antes de recorrer a <code>hostPort</code>.</p></li><li><p>Evite usar <code>hostNetwork</code> pelos mesmos motivos do <code>hostPort</code>.</p></li><li><p>Use <a href=/docs/concepts/services-networking/service/#headless-services>headless Services</a> (que tem um <code>ClusterIP</code> ou <code>None</code>) para descoberta de serviço quando você não precisar de um balanceador de carga <code>kube-proxy</code>.</p></li></ul><h2 id=usando-labels>Usando Labels</h2><ul><li>Defina e use <a href=/docs/concepts/overview/working-with-objects/labels/>labels</a> que identifiquem <em>atributos semânticos</em> da sua aplicação ou Deployment, como <code>{ app: myapp, tier: frontend, phase: test, deployment: v3 }</code>. Você pode usar essas labels para selecionar os Pods apropriados para outros recursos; por exemplo, um Service que seleciona todos os Pods <code>tier: frontend</code>, ou todos
os componentes de <code>app: myapp</code>. Veja o app <a href=https://github.com/kubernetes/examples/tree/master/guestbook/>guestbook</a> para exemplos dessa abordagem.</li></ul><p>Um Service pode ser feito para abranger vários Deployments, omitindo labels específicas de lançamento de seu seletor. Quando você
precisar atualizar um serviço em execução sem <em>downtime</em>, use um <a href=/docs/concepts/workloads/controllers/deployment/>Deployment</a>.</p><p>Um estado desejado de um objeto é descrito por um Deployment, e se as alterações nesse <em>spec</em> forem <em>aplicadas</em> o controlador
do Deployment altera o estado real para o estado desejado em uma taxa controlada.</p><ul><li><p>Use as <a href=/docs/concepts/overview/working-with-objects/common-labels/>labels comuns do Kubernetes</a> para casos de uso comuns.
Essas labels padronizadas enriquecem os metadados de uma forma que permite que ferramentas, incluindo <code>kubectl</code> e a <a href=/docs/tasks/access-application-cluster/web-ui-dashboard>dashboard</a>, funcionem de uma forma interoperável.</p></li><li><p>Você pode manipular labels para depuração. Como os controladores do Kubernetes (como ReplicaSet) e Services se relacionam com os Pods usando seletor de labels, remover as labels relevantes de um Pod impedirá que ele seja considerado por um controlador ou que
seja atendido pelo tráfego de um Service. Se você remover as labels de um Pod existente, seu controlador criará um novo Pod para
substituí-lo. Essa é uma maneira útil de depurar um Pod anteriormente "ativo" em um ambiente de "quarentena". Para remover ou
alterar labels interativamente, use <a href=/docs/reference/generated/kubectl/kubectl-commands#label><code>kubectl label</code></a>.</p></li></ul><h2 id=imagens-de-contêiner>Imagens de Contêiner</h2><p>A <a href=/docs/concepts/containers/images/#updating-images>imagePullPolicy</a> e tag da imagem afetam quando o <a href=/docs/reference/command-line-tools-reference/kubelet/>kubelet</a> tenta puxar a imagem especificada.</p><ul><li><p><code>imagePullPolicy: IfNotPresent</code>: a imagem é puxada apenas se ainda não estiver presente localmente.</p></li><li><p><code>imagePullPolicy: Always</code>: sempre que o kubelet inicia um contêiner, ele consulta o <em>registry</em> da imagem do contêiner para verificar o resumo de assinatura da imagem. Se o kubelet tiver uma imagem do contêiner com o mesmo resumo de assinatura
armazenado em cache localmente, o kubelet usará a imagem em cache, caso contrário, o kubelet baixa(<em>pulls</em>) a imagem com o resumo de assinatura resolvido, e usa essa imagem para iniciar o contêiner.</p></li><li><p><code>imagePullPolicy</code> é omitido se a tag da imagem é <code>:latest</code> ou se <code>imagePullPolicy</code> é omitido é automaticamente definido como <code>Always</code>. Observe que <em>não</em> será utilizado para <code>ifNotPresent</code>se o valor da tag mudar.</p></li><li><p><code>imagePullPolicy</code> é omitido se uma tag da imagem existe mas não <code>:latest</code>: <code>imagePullPolicy</code> é automaticamente definido como <code>ifNotPresent</code>. Observe que isto <em>não</em> será atualizado para <code>Always</code> se a tag for removida ou alterada para <code>:latest</code>.</p></li><li><p><code>imagePullPolicy: Never</code>: presume-se que a imagem exista localmente. Não é feita nenhuma tentativa de puxar a imagem.</p></li></ul><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Para garantir que seu contêiner sempre use a mesma versão de uma imagem, você pode especificar seu <a href=https://docs.docker.com/engine/reference/commandline/pull/#pull-an-image-by-digest-immutable-identifier>resumo de assinatura</a>;
substitua <code>&lt;nome-da-imagem>:&lt;tag></code> por <code>&lt;nome-da-imagem>@&lt;hash></code> (por exemplo, <code>image@sha256:45b23dee08af5e43a7fea6c4cf9c25ccf269ee113168c19722f87876677c5cb2</code>). Esse resumo de assinatura identifica exclusivamente uma versão
específica de uma imagem, então isso nunca vai ser atualizado pelo Kubernetes a menos que você mude o valor do resumo de assinatura da imagem.</div><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Você deve evitar o uso da tag <code>:latest</code> em produção, pois é mais difícil rastrear qual versão da imagem está sendo executada e mais difícil reverter adequadamente.</div><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> A semântica de cache do provedor de imagem subjacente torna até mesmo <code>imagePullPolicy: Always</code> eficiente, contanto que o registro esteja acessível de forma confiável. Com o Docker, por exemplo, se a imagem já existe, a tentativa de baixar(pull) é rápida porque todas as camadas da imagem são armazenadas em cache e nenhum download de imagem é necessário.</div><h2 id=usando-kubectl>Usando kubectl</h2><ul><li><p>Use <code>kubectl apply -f &lt;directory></code>. Isso procura por configurações do Kubernetes em todos os arquivos <code>.yaml</code>, <code>.yml</code> em <code>&lt;directory></code> e passa isso para <code>apply</code>.</p></li><li><p>Use <em>labels selectors</em> para operações <code>get</code> e <code>delete</code> em vez de nomes de objetos específicos. Consulte as seções sobre <a href=/docs/concepts/overview/working-with-objects/labels/#label-selectors>label selectors</a>
e <a href=/docs/concepts/cluster-administration/manage-deployment/#using-labels-effectively>usando Labels efetivamente</a>.</p></li><li><p>Use <code>kubectl create deployment</code> e <code>kubectl expose</code> para criar rapidamente Deployments e Services de um único contêiner. Consulte <a href=/docs/tasks/access-application-cluster/service-access-application-cluster/>Use um Service para acessar uma aplicação em um cluster</a> para obter um exemplo.</p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-6b5ccadd699df0904e8e9917c5450c4b>3.6.2 - ConfigMaps</h1><p><p>Um ConfigMap é um objeto da API usado para armazenar dados não-confidenciais em pares chave-valor.
<a class=glossary-tooltip title='O menor e mais simples objeto Kubernetes. Um Pod representa um conjunto de contêineres em execução no seu cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/ target=_blank aria-label=Pods>Pods</a> podem consumir ConfigMaps como variáveis de ambiente, argumentos de linha de comando ou como arquivos de configuração em um <a class=glossary-tooltip title='Um diretório contendo dados, accessível aos contêineres em um pod.' data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/ target=_blank aria-label=volume>volume</a>.</p></p><p>Um ConfigMap ajuda a desacoplar configurações vinculadas ao ambiente das <a class=glossary-tooltip title='Instância armazenada de um contêiner que contém o conjunto de softwares necessários para rodar uma aplicação.' data-toggle=tooltip data-placement=top href='/pt-br/docs/reference/glossary/?all=true#term-image' target=_blank aria-label='imagens de contêiner'>imagens de contêiner</a>, de modo a tornar aplicações mais facilmente portáveis.</p><div class="alert alert-warning caution callout" role=alert><strong>Cuidado:</strong> O ConfigMap não oferece confidencialidade ou encriptação.
Se os dados que você deseja armazenar são confidenciais, utilize
<a class=glossary-tooltip title='Armazena dados sensíveis, como senhas, tokens OAuth e chaves SSH.' data-toggle=tooltip data-placement=top href=/pt-br/docs/concepts/configuration/secret/ target=_blank aria-label=Secret>Secret</a> ao invés de um ConfigMap,
ou utilize ferramentas adicionais (de terceiros) para manter seus dados privados.</div><h2 id=motivação>Motivação</h2><p>Utilize um ConfigMap para manter a configuração separada do código da aplicação.</p><p>Por exemplo, imagine que você esteja desenvolvendo uma aplicação que pode ser executada
no seu computador local (para desenvolvimento) e na nuvem (para manipular tráfego real).
Você escreve código para ler a variável de ambiente chamada <code>DATABASE_HOST</code>.
No seu ambiente local, você configura essa variável com o valor <code>localhost</code>. Na nuvem, você
configura essa variável para referenciar um <a class=glossary-tooltip title='Uma forma abstrata de expor uma aplicação que está executando em um conjunto de Pods como um serviço de rede.' data-toggle=tooltip data-placement=top href=/docs/concepts/services-networking/service/ target=_blank aria-label=serviço>serviço</a>
do Kubernetes que expõe o componente do banco de dados ao seu cluster.
Isto permite que você baixe uma imagem de contêiner que roda na nuvem e depure exatamente
o mesmo código localmente se necessário.</p><p>Um ConfigMap não foi planejado para conter grandes quantidades de dados. Os dados armazenados
em um ConfigMap não podem exceder 1 MiB. Se você precisa armazenar configurações que são maiores
que este limite, considere montar um volume ou utilizar um serviço separado de banco de dados
ou de arquivamento de dados.</p><h2 id=objeto-configmap>Objeto ConfigMap</h2><p>Um ConfigMap é um <a href=/docs/concepts/overview/working-with-objects/kubernetes-objects/>objeto</a>
da API que permite o armazenamento de configurações para consumo por outros objetos. Diferentemente
de outros objetos do Kubernetes que contém um campo <code>spec</code>, o ConfigMap contém os campos <code>data</code> e
<code>binaryData</code>. Estes campos aceitam pares chave-valor como valores. Ambos os campos <code>data</code> e <code>binaryData</code>
são opcionais. O campo <code>data</code> foi pensado para conter sequências de bytes UTF-8, enquanto o campo <code>binaryData</code>
foi planejado para conter dados binários em forma de strings codificadas em base64.</p><p>É obrigatório que o nome de um ConfigMap seja um
<a href=/pt-br/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>subdomínio DNS válido</a>.</p><p>Cada chave sob as seções <code>data</code> ou <code>binaryData</code> pode conter quaisquer caracteres alfanuméricos,
<code>-</code>, <code>_</code> e <code>.</code>. As chaves armazenadas na seção <code>data</code> não podem colidir com as chaves armazenadas
na seção <code>binaryData</code>.</p><p>A partir da versão v1.19 do Kubernetes, é possível adicionar o campo <code>immutable</code> a uma definição de ConfigMap
para criar um <a href=#configmap-immutable>ConfigMap imutável</a>.</p><h2 id=configmaps-e-pods>ConfigMaps e Pods</h2><p>Você pode escrever uma <code>spec</code> para um Pod que se refere a um ConfigMap e configurar o(s) contêiner(es)
neste Pod baseados em dados do ConfigMap. O Pod e o ConfigMap devem estar no mesmo
<a class=glossary-tooltip title='Uma abstração utilizada pelo Kubernetes para suportar múltiplos clusters virtuais no mesmo cluster físico.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/namespaces target=_blank aria-label=namespace>namespace</a>.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> A <code>spec</code> de um <a class=glossary-tooltip title='Um pod gerenciado diretamente pelo daemon do kubelet em um nó específico.' data-toggle=tooltip data-placement=top href=/docs/tasks/configure-pod-container/static-pod/ target=_blank aria-label='Pod estático'>Pod estático</a> não pode se referir a um
ConfigMap ou a quaisquer outros objetos da API.</div><p>Exemplo de um ConfigMap que contém algumas chaves com valores avulsos e outras chaves com valores semelhantes
a fragmentos de arquivos de configuração:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>game-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># chaves com valores de propriedades; cada chave mapeia para um valor avulso</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>player_initial_lives</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;3&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ui_properties_file_name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;user-interface.properties&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># chaves semelhantes a fragmentos de arquivos</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>game.properties</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    enemy.types=aliens,monsters
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    player.maximum-lives=5</span><span style=color:#bbb>    
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>user-interface.properties</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    color.good=purple
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    color.bad=yellow
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    allow.textmode=true</span><span style=color:#bbb>    
</span></span></span></code></pre></div><p>Existem quatro formas diferentes para consumo de um ConfigMap na configuração de um
contêiner dentro de um Pod:</p><ol><li>Dentro de um comando de contêiner e seus argumentos.</li><li>Variáveis de ambiente para um contêiner.</li><li>Criando um arquivo em um volume somente leitura, para consumo pela aplicação.</li><li>Escrevendo código para execução dentro do Pod que utilize a API do Kubernetes para ler um ConfigMap.</li></ol><p>Os diferentes métodos de consumo oferecem diferentes formas de modelar os dados sendo consumidos.
Para os três primeiros métodos, o <a class=glossary-tooltip title='Um agente que é executado em cada node no cluster. Ele garante que os contêineres estejam sendo executados em um pod.' data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kubelet target=_blank aria-label=kubelet>kubelet</a> utiliza
os dados de um ConfigMap quando o(s) contêiner(es) do Pod são inicializados.</p><p>O quarto método envolve escrita de código para leitura do ConfigMap e dos seus dados. No entanto,
como a API do Kubernetes está sendo utilizada diretamente, a aplicação pode solicitar atualizações
sempre que o ConfigMap for alterado e reagir quando isso ocorre. Acessar a API do Kubernetes
diretamente também permite ler ConfigMaps em outros namespaces.</p><p>Exemplo de um Pod que utiliza valores do ConfigMap <code>game-demo</code> para configurar um Pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>configmap-demo-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>alpine<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;sleep&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;3600&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># Define as variáveis de ambiente</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>PLAYER_INITIAL_LIVES<span style=color:#bbb> </span><span style=color:#080;font-style:italic># Note que aqui a variável está definida em caixa alta,</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                                     </span><span style=color:#080;font-style:italic># diferente da chave no ConfigMap.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>configMapKeyRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>game-demo          <span style=color:#bbb> </span><span style=color:#080;font-style:italic># O ConfigMap de onde esse valor vem.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>player_initial_lives<span style=color:#bbb> </span><span style=color:#080;font-style:italic># A chave que deve ser buscada.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>UI_PROPERTIES_FILE_NAME<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>configMapKeyRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>game-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>ui_properties_file_name<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/config&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># Volumes são definidos no escopo do Pod, e os pontos de montagem são definidos</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># nos contêineres dentro dos pods.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>configMap</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># Informe o nome do ConfigMap que deseja montar.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>game-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># Uma lista de chaves do ConfigMap para serem criadas como arquivos.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;game.properties&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;game.properties&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;user-interface.properties&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;user-interface.properties&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>ConfigMaps não diferenciam entre propriedades com valores simples ou valores complexos,
que ocupam várias linhas. O importante é a forma que Pods e outros objetos consomem tais valores.</p><p>Neste exemplo, definir um volume e montar ele dentro do contêiner <code>demo</code> no caminho <code>/config</code>
cria dois arquivos: <code>/config/game.properties</code> e <code>/config/user-interface.properties</code>, embora existam
quatro chaves distintas no ConfigMap. Isso se deve ao fato de que a definição do Pod contém uma lista
<code>items</code> na seção <code>volumes</code>.
Se a lista <code>items</code> for omitida, cada chave do ConfigMap torna-se um arquivo cujo nome é a sua chave
correspondente, e quatro arquivos serão criados.</p><h2 id=usando-configmaps>Usando ConfigMaps</h2><p>ConfigMaps podem ser montados como volumes de dados. ConfigMaps também podem ser utilizados
por outras partes do sistema sem serem diretamente expostos ao Pod. Por exemplo, ConfigMaps
podem conter dados que outras partes do sistema devem usar para configuração.</p><p>A forma mais comum de utilização de ConfigMaps é a configuração de contêineres executando em
Pods no mesmo namespace. Você também pode utilizar um ConfigMap separadamente.</p><p>Por exemplo, existem <a class=glossary-tooltip title='Recursos que estendem a funcionalidade do Kubernetes.' data-toggle=tooltip data-placement=top href=/pt-br/docs/concepts/cluster-administration/addons/ target=_blank aria-label=complementos>complementos</a> ou
<a class=glossary-tooltip title='Um controlador especializado que gerencia um recurso personalizado.' data-toggle=tooltip data-placement=top href=/pt-br/docs/concepts/extend-kubernetes/operator/ target=_blank aria-label=operadores>operadores</a> que adaptam seus comportamentos
de acordo com dados de um ConfigMap.</p><h3 id=utilizando-configmaps-como-arquivos-em-um-pod>Utilizando ConfigMaps como arquivos em um Pod</h3><p>Para consumir um ConfigMap em um volume em um Pod:</p><ol><li>Crie um ConfigMap ou utilize um ConfigMap existente. Múltiplos Pods
podem referenciar o mesmo ConfigMap.</li><li>Modifique sua definição de Pod para adicionar um volume em
<code>.spec.volumes[]</code>. Escolha um nome qualquer para o seu volume, e
referencie o seu objeto ConfigMap no campo
<code>.spec.volumes[].configMap.name</code>.</li><li>Adicione um campo <code>.spec.containers[].volumeMounts[]</code> a cada um dos
contêineres que precisam do ConfigMap. Especifique
<code>.spec.containers[].volumeMounts[].readOnly = true</code> e informe no campo
<code>.spec.containers[].volumeMounts[].mountPath</code> um caminho de um diretório
não utilizado onde você deseja que este ConfigMap apareça.</li><li>Modifique sua imagem ou linha de comando de modo que o programa procure
por arquivos no diretório especificado no passo anterior. Cada chave no
campo <code>data</code> do ConfigMap será transformado em um nome de arquivo no
diretório especificado por <code>mountPath</code>.</li></ol><p>Exemplo de um Pod que monta um ConfigMap em um volume:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/foo&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>configMap</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myconfigmap<span style=color:#bbb>
</span></span></span></code></pre></div><p>Cada ConfigMap que você deseja utilizar precisa ser referenciado em
<code>.spec.volumes</code>.</p><p>Se houver múltiplos contêineres no Pod, cada contêiner deve ter seu
próprio bloco <code>volumeMounts</code>, mas somente uma instância de <code>.spec.volumes</code>
é necessária por ConfigMap.</p><h3 id=configmaps-montados-são-atualizados-automaticamente>ConfigMaps montados são atualizados automaticamente</h3><p>Quando um ConfigMap que está sendo consumido em um volume é atualizado, as chaves projetadas são
eventualmente atualizadas também. O Kubelet checa se o ConfigMap montado está atualizado em cada
sincronização periódica.
No entanto, o kubelet utiliza o cache local para buscar o valor atual do ConfigMap.
O tipo de cache é configurável utilizando o campo <code>ConfigMapAndSecretChangeDetectionStrategy</code> na
<a href=/docs/reference/config-api/kubelet-config.v1beta1/>configuração do Kubelet (KubeletConfiguration)</a>.
Um ConfigMap pode ter sua propagação baseada em um <em>watch</em> (comportamento padrão), que é o sistema
de propagação de mudanças incrementais em objetos do Kubernetes; baseado em TTL (<em>time to live</em>,
ou tempo de expiração); ou redirecionando todas as requisições diretamente para o servidor da API.
Como resultado, o tempo decorrido total entre o momento em que o ConfigMap foi atualizado até o momento
quando as novas chaves são projetadas nos Pods pode ser tão longo quanto o tempo de sincronização
do kubelet somado ao tempo de propagação do cache, onde o tempo de propagação do cache depende do
tipo de cache escolhido: o tempo de propagação pode ser igual ao tempo de propagação do <em>watch</em>,
TTL do cache, ou zero, de acordo com cada um dos tipos de cache.</p><p>ConfigMaps que são consumidos como variáveis de ambiente não atualizam automaticamente e requerem uma
reinicialização do pod.</p><h2 id=configmap-immutable>ConfigMaps imutáveis</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.21 [stable]</code></div><p>A funcionalidade <em>Secrets e ConfigMaps imutáveis</em> do Kubernetes fornece uma opção
para marcar Secrets e ConfigMaps individuais como imutáveis. Para clusters que utilizam
ConfigMaps extensivamente (ao menos centenas de milhares de mapeamentos únicos de
ConfigMaps para Pods), prevenir alterações dos seus dados traz as seguintes vantagens:</p><ul><li>protege de atualizações acidentais ou indesejadas que podem causar disrupção na execução
de aplicações</li><li>melhora o desempenho do cluster através do fechamento de <em>watches</em> de ConfigMaps marcados
como imutáveis, diminuindo significativamente a carga no kube-apiserver</li></ul><p>Essa funcionalidade é controlada pelo <a href=/docs/reference/command-line-tools-reference/feature-gates/>feature gate</a>
<code>ImmutableEphemeralVolumes</code>. É possível criar um ConfigMap imutável adicionando o campo
<code>immutable</code> e marcando seu valor com <code>true</code>.
Por exemplo:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>immutable</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Após um ConfigMap ser marcado como imutável, <em>não</em> é possível reverter a alteração, nem
alterar o conteúdo dos campos <code>data</code> ou <code>binaryData</code>. É possível apenas apagar e recriar
o ConfigMap. Como Pods existentes que consomem o ConfigMap em questão mantém um ponto de
montagem que continuará referenciando este objeto após a remoção, é recomendado recriar
estes pods.</p><h2 id=próximos-passos>Próximos passos</h2><ul><li>Leia sobre <a href=/docs/concepts/configuration/secret/>Secrets</a> (em inglês).</li><li>Leia <a href=/docs/tasks/configure-pod-container/configure-pod-configmap/>Configure a Pod to Use a ConfigMap</a> (em inglês).</li><li>Leia <a href=https://12factor.net/>The Twelve-Factor App</a> (em inglês) para entender a motivação da separação de código
e configuração.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-e511ed821ada65d0053341dbd8ad2bb5>3.6.3 - Secrets</h1><p>Um Secret é um objeto que contém uma pequena quantidade de informação sensível,
como senhas, tokens ou chaves. Este tipo de informação poderia, em outras
circunstâncias, ser colocada diretamente em uma configuração de
<a class=glossary-tooltip title='O menor e mais simples objeto Kubernetes. Um Pod representa um conjunto de contêineres em execução no seu cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/ target=_blank aria-label=Pod>Pod</a> ou em uma
<a class=glossary-tooltip title='Instância armazenada de um contêiner que contém o conjunto de softwares necessários para rodar uma aplicação.' data-toggle=tooltip data-placement=top href='/pt-br/docs/reference/glossary/?all=true#term-image' target=_blank aria-label='imagem de contêiner'>imagem de contêiner</a>. O uso de
Secrets evita que você tenha de incluir dados confidenciais no seu código.</p><p>Secrets podem ser criados de forma independente dos Pods que os consomem. Isto
reduz o risco de que o Secret e seus dados sejam expostos durante o processo de
criação, visualização e edição ou atualização de Pods. O Kubernetes e as
aplicações que rodam no seu cluster podem também tomar outras precauções com
Secrets, como por exemplo evitar a escrita de dados confidenciais em local de
armazenamento persistente (não-volátil).</p><p>Secrets são semelhantes a
<a class=glossary-tooltip title='Um objeto da API usado para armazenar dados não-confidenciais em pares chave-valor. Pode ser consumido como variáveis de ambiente, argumentos de linha de comando, ou arquivos de configuração em um volume.' data-toggle=tooltip data-placement=top href=/pt-br/docs/concepts/configuration/configmap target=_blank aria-label=ConfigMaps>ConfigMaps</a>, mas foram
especificamente projetados para conter dados confidenciais.</p><div class="alert alert-warning caution callout" role=alert><strong>Cuidado:</strong><p>Os Secrets do Kubernetes são, por padrão, gravados não-encriptados no sistema
de armazenamento de dados utilizado pelo servidor da API (etcd). Qualquer pessoa
com acesso à API ou ao etcd consegue obter ou modificar um Secret.
Além disso, qualquer pessoa que possui autorização para criar Pods em um namespace
consegue utilizar este privilégio para ler qualquer Secret naquele namespace. Isso
inclui acesso indireto, como por exemplo a permissão para criar Deployments.</p><p>Para utilizar Secrets de forma segura, siga pelo menos as instruções abaixo:</p><ol><li><a href=/docs/tasks/administer-cluster/encrypt-data/>Habilite encriptação em disco</a> para Secrets.</li><li>Habilite ou configure <a href=/docs/reference/access-authn-authz/authorization/>regras de RBAC</a>
que restrinjam o acesso de leitura a Secrets (incluindo acesso indireto).</li><li>Quando apropriado, utilize mecanismos como RBAC para limitar quais perfis e
usuários possuem permissão para criar novos Secrets ou substituir Secrets
existentes.</li></ol></div><p>Consulte <a href=#information-security-for-secrets>Segurança da informação para Secrets</a>
para mais detalhes.</p><h2 id=usos-para-secrets>Usos para Secrets</h2><p>Existem três formas principais para um Pod utilizar um Secret:</p><ul><li>Como <a href=#using-secrets-as-files-from-a-pod>arquivos</a> em um
<a class=glossary-tooltip title='Um diretório contendo dados, accessível aos contêineres em um pod.' data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/ target=_blank aria-label=volume>volume</a> montado em um ou mais de
seus contêineres.</li><li>Como uma <a href=#using-secrets-as-environment-variables>variável de ambiente</a> de um
contêiner.</li><li>Pelo <a href=#using-imagepullsecrets>kubelet ao baixar imagens de contêiner</a> para o
Pod.</li></ul><p>A camada de gerenciamento do Kubernetes também utiliza Secrets. Por exemplo,
os <a href=#bootstrap-token-secrets>Secrets de tokens de autoinicialização</a> são um
mecanismo que auxilia a automação do registro de nós.</p><h3 id=alternativas-a-secrets>Alternativas a Secrets</h3><p>Ao invés de utilizar um Secret para proteger dados confidenciais, você pode
escolher uma maneira alternativa. Algumas das opções são:</p><ul><li>se o seu componente cloud native precisa autenticar-se a outra aplicação que
está rodando no mesmo cluster Kubernetes, você pode utilizar uma
<a href=/pt-br/docs/reference/access-authn-authz/authentication/#tokens-de-contas-de-servi%C3%A7o>ServiceAccount</a>
e seus tokens para identificar seu cliente.</li><li>existem ferramentas fornecidas por terceiros que você pode rodar, no seu
cluster ou externamente, que providenciam gerenciamento de Secrets. Por exemplo,
um serviço que Pods accessam via HTTPS, que revelam um Secret se o cliente
autenticar-se corretamente (por exemplo, utilizando um token de ServiceAccount).</li><li>para autenticação, você pode implementar um serviço de assinatura de
certificados X.509 personalizado, e utilizar
<a href=/docs/reference/access-authn-authz/certificate-signing-requests/>CertificateSigningRequests</a>
para permitir ao serviço personalizado emitir certificados a pods que os
necessitam.</li><li>você pode utilizar um <a href=/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/>plugin de dispositivo</a>
para expor a um Pod específico um hardware de encriptação conectado a um nó. Por
exemplo, você pode agendar Pods confiáveis em nós que oferecem um <em>Trusted
Platform Module</em>, configurado em um fluxo de dados independente.</li></ul><p>Você pode também combinar duas ou mais destas opções, incluindo a opção de
utilizar objetos do tipo Secret.</p><p>Por exemplo: implemente (ou instale) um
<a class=glossary-tooltip title='Um controlador especializado que gerencia um recurso personalizado.' data-toggle=tooltip data-placement=top href=/pt-br/docs/concepts/extend-kubernetes/operator/ target=_blank aria-label=operador>operador</a>
que solicite tokens de sessão de curta duração a um serviço externo, e crie
Secrets baseado nestes tokens. Pods rodando no seu cluster podem fazer uso de
tokens de sessão, e o operador garante que estes permanecem válidos. Esta
separação significa que você pode rodar Pods que não precisam ter conhecimento
do mecanismo exato para geração e atualização de tais tokens de sessão.</p><h2 id=trabalhando-com-secrets>Trabalhando com Secrets</h2><h3 id=criando-um-secret>Criando um Secret</h3><p>Existem diversas formas de criar um Secret:</p><ul><li><a href=/pt-br/docs/tasks/configmap-secret/managing-secret-using-kubectl/>crie um Secret utilizando o comando <code>kubectl</code></a></li><li><a href=/pt-br/docs/tasks/configmap-secret/managing-secret-using-config-file/>crie um Secret a partir de um arquivo de configuração</a></li><li><a href=/pt-br/docs/tasks/configmap-secret/managing-secret-using-kustomize/>crie um Secret utilizando a ferramenta kustomize</a></li></ul><h4 id=restriction-names-data>Restrições de nomes de Secret e dados</h4><p>O nome de um Secret deve ser um <a href=/pt-br/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>subdomínio DNS válido</a>.</p><p>Você pode especificar o campo <code>data</code> e/ou o campo <code>stringData</code> na criação de um
arquivo de configuração de um Secret. Ambos os campos <code>data</code> e <code>stringData</code> são
opcionais. Os valores das chaves no campo <code>data</code> devem ser strings codificadas
no formato base64. Se a conversão para base64 não for desejável, você pode
optar por informar os dados no campo <code>stringData</code>, que aceita strings arbitrárias
como valores.</p><p>As chaves dos campos <code>data</code> e <code>stringData</code> devem consistir de caracteres
alfanuméricos, <code>-</code>, <code>_</code>, ou <code>.</code>. Todos os pares chave-valor no campo <code>stringData</code>
são internamente combinados com os dados do campo <code>data</code>. Se uma chave aparece
em ambos os campos, o valor informado no campo <code>stringData</code> tem a precedência.</p><h4 id=restriction-data-size>Limite de tamanho</h4><p>Secrets individuais são limitados a 1MiB em tamanho. Esta limitação tem por
objetivo desencorajar a criação de Secrets muito grandes que possam exaurir a
memória do servidor da API e do kubelet. No entanto, a criação de vários Secrets
pequenos também pode exaurir a memória. Você pode utilizar uma
<a href=/pt-br/docs/concepts/policy/resource-quotas/>cota de recurso</a> a fim de limitar
o número de Secrets (ou outros recursos) em um namespace.</p><h3 id=editando-um-secret>Editando um Secret</h3><p>Você pode editar um Secret existente utilizando kubectl:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl edit secrets mysecret
</span></span></code></pre></div><p>Este comando abre o seu editor padrão configurado e permite a modificação dos
valores do Secret codificados em base64 no campo <code>data</code>. Por exemplo:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#080;font-style:italic># Please edit the object below. Lines beginning with a &#39;#&#39; will be ignored,</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># and an empty file will abort the edit. If an error occurs while saving this file, it will be</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># reopened with the relevant failures.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>username</span>:<span style=color:#bbb> </span>YWRtaW4=<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>password</span>:<span style=color:#bbb> </span>MWYyZDFlMmU2N2Rm<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubectl.kubernetes.io/last-applied-configuration</span>:<span style=color:#bbb> </span>{<span style=color:#bbb> </span>... }<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2016-01-22T18:41:56Z<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;164619&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>cfee02d6-c137-11e5-8d73-42010af00002<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Opaque<span style=color:#bbb>
</span></span></span></code></pre></div><p>Este manifesto de exemplo define um Secret com duas chaves no campo <code>data</code>:
<code>username</code> and <code>password</code>.
Os valores são strings codificadas em formato base64. No entanto, quando um
Secret é utilizado em um Pod, o kubelet fornece os dados <em>decodificados</em> ao Pod
e seus contêineres.</p><p>Você pode especificar muitas chaves e valores em um Secret só, ou utilizar
muitos Secrets. Escolha a opção que for mais conveniente para o caso de uso.</p><h3 id=utilizando-secrets>Utilizando Secrets</h3><p>Secrets podem ser montados como volumes de dados ou expostos como
<a class=glossary-tooltip title='Variáveis de ambiente de contêineres são pares nome=valor que trazem informações úteis para os contêineres rodando dentro de um Pod.' data-toggle=tooltip data-placement=top href=/pt-br/docs/concepts/containers/container-environment/ target=_blank aria-label='variáveis de ambiente'>variáveis de ambiente</a>
para serem utilizados num container de um Pod. Secrets também podem ser
utilizados por outras partes do sistema, sem serem diretamente expostos ao Pod.
Por exemplo, Secrets podem conter credenciais que outras partes do sistema devem
utilizar para interagir com sistemas externos no lugar do usuário.</p><p>Secrets montados como volumes são verificados para garantir que o nome
referenciado realmente é um objeto do tipo Secret. Portanto, um Secret deve ser
criado antes de quaisquer Pods que dependem deste Secret.</p><p>Se um Secret não puder ser encontrado (porque não existe, ou devido a um problema
de conectividade com o servidor da API) o kubelet tenta periodicamente reiniciar
aquele Pod. O kubelet também relata um evento para aquele Pod, incluindo detalhes
do problema ao buscar o Secret.</p><h4 id=restriction-secret-must-exist>Secrets Opcionais</h4><p>Quando você define uma variável de ambiente em um contêiner baseada em um Secret,
você pode especificar que o Secret em questão será <em>opcional</em>. O padrão é o
Secret ser requerido.</p><p>Nenhum dos contêineres de um Pod irão inicializar até que todos os Secrets
requeridos estejam disponíveis.</p><p>Se um Pod referencia uma chave específica em um Secret e o Secret existe, mas
não possui a chave com o nome referenciado, o Pod falha durante a inicialização.</p><h3 id=using-secrets-as-files-from-a-pod>Utilizando Secrets como arquivos em um Pod</h3><p>Se você deseja acessar dados de um Secret em um Pod, uma das formas de consumir
esta informação é fazer com que o Kubernetes deixe o valor daquele Secret
disponível como um arquivo dentro do sistema de arquivos de um ou mais dos
contêineres daquele Pod.</p><p>Para configurar isso:</p><ol><li>Crie um Secret ou utilize um previamente existente. Múltiplos Pods podem
referenciar o mesmo secret.</li><li>Modifique sua definição de Pod para adicionar um volume na lista
<code>.spec.volumes[]</code>. Escolha um nome qualquer para o seu volume e adicione um
campo <code>.spec.volumes[].secret.secretName</code> com o mesmo valor do seu objeto
Secret.</li><li>Adicione um ponto de montagem de volume à lista
<code>.spec.containers[].volumeMounts[]</code> de cada contêiner que requer o Secret.
Especifique <code>.spec.containers[].volumeMounts[].readOnly = true</code> e especifique o
valor do campo <code>.spec.containers[].volumeMounts[].mountPath</code> com o nome de um
diretório não utilizado onde você deseja que os Secrets apareçam.</li><li>Modifique sua imagem ou linha de comando de modo que o programa procure por
arquivos naquele diretório. Cada chave no campo <code>data</code> se torna um nome de
arquivo no diretório especificado em <code>mountPath</code>.</li></ol><p>Este é um exemplo de Pod que monta um Secret de nome <code>mysecret</code> em um volume:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/foo&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb> </span><span style=color:#080;font-style:italic># configuração padrão; &#34;mysecret&#34; precisa existir</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Cada Secret que você deseja utilizar deve ser referenciado na lista
<code>.spec.volumes</code>.</p><p>Se existirem múltiplos contêineres em um Pod, cada um dos contêineres
necessitará seu próprio bloco <code>volumeMounts</code>, mas somente um volume na lista
<code>.spec.volumes</code> é necessário por Secret.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong><p>Versões do Kubernetes anteriores a v1.22 criavam automaticamente credenciais
para acesso à API do Kubernetes. Este mecanismo antigo era baseado na criação de
Secrets com tokens que podiam então ser montados em Pods em execução.
Em versões mais recentes, incluindo o Kubernetes v1.25,
credenciais para acesso à API são obtidas diretamente através da API
<a href=/docs/reference/kubernetes-api/authentication-resources/token-request-v1/>TokenRequest</a>
e são montadas em Pods utilizando um
<a href=/docs/reference/access-authn-authz/service-accounts-admin/#bound-service-account-token-volume>volume projetado</a>.
Os tokens obtidos através deste método possuem tempo de vida limitado e são
automaticamente invalidados quando o Pod em que estão montados é removido.</p><p>Você ainda pode
<a href=/docs/tasks/configure-pod-container/configure-service-account/#manually-create-a-service-account-api-token>criar manualmente</a>
um Secret de token de service account se você precisa de um token que não expire,
por exemplo. No entanto, o uso do subrecurso
<a href=/docs/reference/kubernetes-api/authentication-resources/token-request-v1/>TokenRequest</a>
é recomendado para obtenção de um token para acesso à API ao invés do uso de
Secrets de token de service account.</p></div><h4 id=projeção-de-chaves-de-secrets-em-caminhos-específicos>Projeção de chaves de Secrets em caminhos específicos</h4><p>Você pode também controlar os caminhos dentro do volume onde as chaves do Secret
são projetadas. Você pode utilizar o campo <code>.spec.volumes[].secret.items</code> para
mudar o caminho de destino de cada chave:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/foo&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>username<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>my-group/my-username<span style=color:#bbb>
</span></span></span></code></pre></div><p>Neste caso:</p><ul><li>O valor da chave <code>username</code> é armazenado no arquivo
<code>/etc/foo/my-group/my-username</code> ao invés de <code>/etc/foo/username</code>.</li><li>O valor da chave <code>password</code> não é projetado no sistema de arquivos.</li></ul><p>Se <code>.spec.volumes[].secret.items</code> for utilizado, somente chaves especificadas
na lista <code>items</code> são projetadas. Para consumir todas as chaves do Secret, deve
haver um item para cada chave no campo <code>items</code>.</p><p>Se você listar as chaves explicitamente, então todas as chaves listadas precisam
existir no Secret correspondente. Caso contrário, o volume não é criado.</p><h4 id=permissões-de-arquivos-de-secret>Permissões de arquivos de Secret</h4><p>Você pode trocar os bits de permissão POSIX de uma chave avulsa de Secret.
Se nenhuma permissão for especificada, <code>0644</code> é utilizado por padrão.
Você pode também especificar uma permissão padrão para o volume inteiro de
Secret e sobrescrever esta permissão por chave, se necessário.</p><p>Por exemplo, você pode especificar uma permissão padrão da seguinte maneira:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/foo&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>defaultMode</span>:<span style=color:#bbb> </span><span style=color:#666>0400</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Dessa forma, o Secret será montado em <code>/etc/foo</code> e todos os arquivos criados
no volume terão a permissão <code>0400</code>.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Se você estiver definindo um Pod ou um template de Pod utilizando JSON, observe
que a especificação JSON não suporta a notação octal. Você pode utilizar o valor
decimal para o campo <code>defaultMode</code> (por exemplo, 0400 em base octal equivale a
256 na base decimal).<br>Se você estiver escrevendo YAML, você pode escrever o valor para <code>defaultMode</code>
em octal.</div><h4 id=consumindo-valores-de-secrets-em-volumes>Consumindo valores de Secrets em volumes</h4><p>Dentro do contêiner que monta um volume de Secret, as chaves deste Secret
aparecem como arquivos e os valores dos Secrets são decodificados do formato
base64 e armazenados dentro destes arquivos.</p><p>Ao executar comandos dentro do contêiner do exemplo anterior, obteremos os
seguintes resultados:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>ls /etc/foo
</span></span></code></pre></div><p>O resultado é semelhante a:</p><pre tabindex=0><code>username
password
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat /etc/foo/username
</span></span></code></pre></div><p>O resultado é semelhante a:</p><pre tabindex=0><code>admin
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat /etc/foo/password
</span></span></code></pre></div><p>O resultado é semelhante a:</p><pre tabindex=0><code>1f2d1e2e67df
</code></pre><p>A aplicação rodando dentro do contêiner é responsável pela leitura dos Secrets
dentro dos arquivos.</p><h4 id=secrets-montados-são-atualizados-automaticamente>Secrets montados são atualizados automaticamente</h4><p>Quando um volume contém dados de um Secret, e o Secret referenciado é atualizado,
o Kubernetes rastreia a atualização e atualiza os dados no volume, utilizando
uma abordagem de consistência eventual.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Um contêiner que utiliza Secrets através de um volume montado com a propriedade
<a href=/docs/concepts/storage/volumes#using-subpath><code>subPath</code></a> não recebe
atualizações automatizadas para este Secret.</div><p>O kubelet mantém um cache das chaves e valores atuais dos Secrets que são
utilizados em volumes de Pods daquele nó. Você pode configurar a forma que o
kubelet detecta diferenças dos valores armazenados em cache. O campo
<code>configMapAndSecretDetectionStrategy</code> na
<a href=/docs/reference/config-api/kubelet-config.v1beta1/>configuração do kubelet</a>
controla qual estratégia o kubelet usa. A estratégia padrão é <code>Watch</code>.</p><p>Atualizações em Secrets podem ser propagadas por um mecanismo de observação da
API (estratégia padrão), baseado em cache com um tempo de expiração definido
(<em>time-to-live</em>), ou solicitado diretamente ao servidor da API do cluster a cada
iteração do ciclo de sincronização do kubelet.</p><p>Como resultado, o atraso total entre o momento em que o Secret foi atualizado
até o momento em que as novas chaves são projetadas no Pod pode ser tão longo
quanto a soma do tempo de sincronização do kubelet somado ao tempo de atraso de
propagação do cache, onde o atraso de propagação do cache depende do tipo de
cache escolhido. Seguindo a mesma ordem listada no parágrafo anterior, estes
valores são: atraso de propagação via <em>watch</em>, tempo de expiração configurado no
cache (<em>time-to-live</em>, ou TTL), ou zero para solicitação direta ao servidor da
API.</p><h3 id=using-secrets-as-environment-variables>Utilizando Secrets como variáveis de ambiente</h3><p>Para utilizar um secret em uma <a class=glossary-tooltip title='Variáveis de ambiente de contêineres são pares nome=valor que trazem informações úteis para os contêineres rodando dentro de um Pod.' data-toggle=tooltip data-placement=top href=/pt-br/docs/concepts/containers/container-environment/ target=_blank aria-label='variável de ambiente'>variável de ambiente</a>
em um Pod:</p><ol><li>Crie um Secret ou utilize um já existente. Múltiplos Pods podem referenciar o
mesmo Secret.</li><li>Modifique a definição de cada contêiner do Pod em que desejar consumir o
Secret, adicionando uma variável de ambiente para cada uma das chaves que
deseja consumir.
A variável de ambiente que consumir o valor da chave em questão deverá
popular o nome do Secret e a sua chave correspondente no campo
<code>env[].valueFrom.secretKeyRef</code>.</li><li>Modifique sua imagem de contêiner ou linha de comando de forma que o programa
busque os valores nas variáveis de ambiente especificadas.</li></ol><p>Este é um exemplo de um Pod que utiliza Secrets em variáveis de ambiente:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-env-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mycontainer<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>SECRET_USERNAME<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>secretKeyRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>username<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>optional</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># valor padrão; &#34;mysecret&#34; deve existir</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                          </span><span style=color:#080;font-style:italic># e incluir uma chave com o nome &#34;username&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>SECRET_PASSWORD<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>secretKeyRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>password<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>optional</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># valor padrão; &#34;mysecret&#34; deve existir</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                          </span><span style=color:#080;font-style:italic># e incluir uma chave com o nome &#34;password&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></span></span></code></pre></div><h4 id=restriction-env-from-invalid>Variáveis de ambiente inválidas</h4><p>Secrets utilizados para popular variáveis de ambiente através do campo <code>envFrom</code>
que possuem chaves consideradas inválidas para nomes de variáveis de ambiente
têm tais chaves ignoradas. O Pod irá iniciar normalmente.</p><p>Se você definir um Pod contendo um nome de variável de ambiente inválido, os
eventos de inicialização do Pod incluirão um evento com a razão
<code>InvalidVariableNames</code> e uma mensagem que lista as chaves inválidas ignoradas.
O exemplo abaixo demonstra um Pod que referencia um Secret chamado <code>mysecret</code>,
onde <code>mysecret</code> contém duas chaves inválidas: <code>1badkey</code> and <code>2alsobad</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get events
</span></span></code></pre></div><p>O resultado é semelhante a:</p><pre tabindex=0><code>LASTSEEN   FIRSTSEEN   COUNT     NAME            KIND      SUBOBJECT                         TYPE      REASON
0s         0s          1         dapi-test-pod   Pod                                         Warning   InvalidEnvironmentVariableNames   kubelet, 127.0.0.1      Keys [1badkey, 2alsobad] from the EnvFrom secret default/mysecret were skipped since they are considered invalid environment variable names.
</code></pre><h4 id=consumindo-valores-de-secret-em-variáveis-de-ambiente>Consumindo valores de Secret em variáveis de ambiente</h4><p>Dentro de um contêiner que consome um Secret em variáveis de ambiente, as chaves
do Secret aparecem como variáveis de ambiente comuns, contendo os dados do
Secret decodificados do formato base64. Ao executar comandos no contêiner do
exemplo anterior, obteremos os resultados abaixo:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b8860b>$SECRET_USERNAME</span>
</span></span></code></pre></div><p>O resultado é semelhante a:</p><pre tabindex=0><code>admin
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b8860b>$SECRET_PASSWORD</span>
</span></span></code></pre></div><p>O resultado é semelhante a:</p><pre tabindex=0><code>1f2d1e2e67df
</code></pre><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Se um contêiner já consome um Secret em uma variável de ambiente, uma
atualização do Secret não será detectada pelo contêiner a menos que este seja
reiniciado. Há soluções de terceiros que fornecem a funcionalidade de
reinicialização automática de Pods quando o valor dos Secrets mudam.</div><h3 id=using-imagepullsecrets>Secrets para obtenção de imagens de contêiner</h3><p>Se você deseja obter imagens de contêiner de um repositório privado, você
precisa fornecer ao kubelet uma maneira de se autenticar a este repositório.
Você pode configurar o campo <code>imagePullSecrets</code> para esta finalidade. Estes
Secrets são configurados a nível de Pod.</p><p>O campo <code>imagePullSecrets</code> de um Pod é uma lista de referências a Secrets
no mesmo namespace que o Pod.
Você pode utilizar <code>imagePullSecrets</code> para enviar credenciais para acesso a um
registro de contêineres ao kubelet. O kubelet utiliza essa informação para
baixar uma imagem privada no lugar do seu Pod.
Veja o campo <code>PodSpec</code> na
<a href=/docs/reference/kubernetes-api/workload-resources/pod-v1/#PodSpec>referência da API de Pods</a>
para maiores detalhes sobre o campo <code>imagePullSecrets</code>.</p><h4 id=usando-imagepullsecrets>Usando <code>imagePullSecrets</code></h4><p>O campo <code>imagePullSecrets</code> é uma lista de referências a Secrets no mesmo
namespace.
Você pode utilizar o campo <code>imagePullSecrets</code> para enviar um Secret que contém
uma senha para um registro de imagens de contêiner do Docker (ou outro registro
de imagens de contêiner). O kubelet utiliza essa informação para baixar uma
imagem privada no lugar do seu Pod.
Veja a <a href=/docs/reference/generated/kubernetes-api/v1.25/#podspec-v1-core>API <code>PodSpec</code></a>
para mais informações sobre o campo <code>imagePullSecrets</code>.</p><h5 id=especificando-imagepullsecrets-manualmente>Especificando <code>imagePullSecrets</code> manualmente</h5><p>Você pode ler sobre como especificar <code>imagePullSecrets</code> em um Pod na
<a href=/pt-br/docs/concepts/containers/images/#especificando-imagepullsecrets-em-um-pod>documentação de imagens de contêiner</a>.</p><h5 id=configurando-imagepullsecrets-para-serem-adicionados-automaticamente>Configurando <code>imagePullSecrets</code> para serem adicionados automaticamente</h5><p>Você pode criar manualmente <code>imagePullSecrets</code> e referenciá-los em uma
ServiceAccount. Quaisquer Pods criados com esta ServiceAccount, especificada
explicitamente ou por padrão, têm o campo <code>imagePullSecrets</code> populado com os
mesmos valores existentes na service account.
Veja <a href=/docs/tasks/configure-pod-container/configure-service-account/#add-imagepullsecrets-to-a-service-account>adicionando <code>imagePullSecrets</code> a uma service account</a>
para uma explicação detalhada do processo.</p><h3 id=restriction-static-pod>Utilizando Secrets com pods estáticos</h3><p>Você não pode utilizar ConfigMaps ou Secrets em
<a class=glossary-tooltip title='Um pod gerenciado diretamente pelo daemon do kubelet em um nó específico.' data-toggle=tooltip data-placement=top href=/docs/tasks/configure-pod-container/static-pod/ target=_blank aria-label='Pods estáticos'>Pods estáticos</a>.</p><h2 id=casos-de-uso>Casos de uso</h2><h3 id=caso-de-uso-como-variáveis-de-ambiente-em-um-contêiner>Caso de uso: Como variáveis de ambiente em um contêiner</h3><p>Crie um manifesto de Secret</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Opaque<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>USER_NAME</span>:<span style=color:#bbb> </span>YWRtaW4=<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>PASSWORD</span>:<span style=color:#bbb> </span>MWYyZDFlMmU2N2Rm<span style=color:#bbb>
</span></span></span></code></pre></div><p>Crie o Secret no seu cluster:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f mysecret.yaml
</span></span></code></pre></div><p>Utilize <code>envFrom</code> para definir todos os dados do Secret como variáveis de
ambiente do contêiner. Cada chave do Secret se torna o nome de uma variável de
ambiente no Pod.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-test-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;/bin/sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;env&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>envFrom</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>secretRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=caso-de-uso-pod-com-chaves-ssh>Caso de uso: Pod com chaves SSH</h3><p>Crie um Secret contendo chaves SSH:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret generic ssh-key-secret --from-file<span style=color:#666>=</span>ssh-privatekey<span style=color:#666>=</span>/path/to/.ssh/id_rsa --from-file<span style=color:#666>=</span>ssh-publickey<span style=color:#666>=</span>/path/to/.ssh/id_rsa.pub
</span></span></code></pre></div><p>O resultado é semelhante a:</p><pre tabindex=0><code>secret &#34;ssh-key-secret&#34; created
</code></pre><p>Você também pode criar um manifesto <code>kustomization.yaml</code> com um campo
<code>secretGenerator</code> contendo chaves SSH.</p><div class="alert alert-warning caution callout" role=alert><strong>Cuidado:</strong><p>Analise cuidadosamente antes de enviar suas próprias chaves SSH: outros usuários
do cluster podem ter acesso a este Secret.</p><p>Como alternativa, você pode criar uma chave SSH privada representando a
identidade de um serviço que você deseja que seja acessível a todos os usuários
com os quais você compartilha o cluster do Kubernetes em questão. Desse modo,
você pode revogar esta credencial em caso de comprometimento.</p></div><p>Agora você pode criar um Pod que referencia o Secret com a chave SSH e consome-o
em um volume:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-test-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>ssh-key-secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>ssh-test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>mySshImage<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/secret-volume&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Ao rodar o comando do contêiner, as partes da chave estarão disponíveis em:</p><pre tabindex=0><code>/etc/secret-volume/ssh-publickey
/etc/secret-volume/ssh-privatekey
</code></pre><p>O contêiner então pode utilizar os dados do secret para estabelecer uma conexão
SSH.</p><h3 id=caso-de-uso-pods-com-credenciais-de-ambientes-de-produção-ou-testes>Caso de uso: Pods com credenciais de ambientes de produção ou testes</h3><p>Este exemplo ilustra um Pod que consome um Secret contendo credenciais de um
ambiente de produção e outro Pod que consome um Secret contendo credenciais de
um ambiente de testes.</p><p>Você pode criar um manifesto <code>kustomization.yaml</code> com um <code>secretGenerator</code> ou
rodar <code>kubectl create secret</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret generic prod-db-secret --from-literal<span style=color:#666>=</span><span style=color:#b8860b>username</span><span style=color:#666>=</span>produser --from-literal<span style=color:#666>=</span><span style=color:#b8860b>password</span><span style=color:#666>=</span>Y4nys7f11
</span></span></code></pre></div><p>O resultado é semelhante a:</p><pre tabindex=0><code>secret &#34;prod-db-secret&#34; created
</code></pre><p>Você pode também criar um Secret com credenciais para o ambiente de testes.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret generic test-db-secret --from-literal<span style=color:#666>=</span><span style=color:#b8860b>username</span><span style=color:#666>=</span>testuser --from-literal<span style=color:#666>=</span><span style=color:#b8860b>password</span><span style=color:#666>=</span>iluvtests
</span></span></code></pre></div><p>O resultado é semelhante a:</p><pre tabindex=0><code>secret &#34;test-db-secret&#34; created
</code></pre><div class="alert alert-info note callout" role=alert><strong>Nota:</strong><p>Caracteres especiais como <code>$</code>, <code>\</code>, <code>*</code>, <code>+</code> e <code>!</code> serão interpretados pelo seu
<a href=https://pt.wikipedia.org/wiki/Shell_(computa%C3%A7%C3%A3o)>shell</a> e precisam
de sequências de escape.</p><p>Na maioria dos shells, a forma mais fácil de gerar sequências de escape para
suas senhas é escrevê-las entre aspas simples (<code>'</code>). Por exemplo, se a sua senha
for <code>S!B\*d$zDsb=</code>, você deve executar o comando da seguinte forma:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret generic dev-db-secret --from-literal<span style=color:#666>=</span><span style=color:#b8860b>username</span><span style=color:#666>=</span>devuser --from-literal<span style=color:#666>=</span><span style=color:#b8860b>password</span><span style=color:#666>=</span><span style=color:#b44>&#39;S!B\*d$zDsb=&#39;</span>
</span></span></code></pre></div><p>Não é necessário gerar sequências de escape para caracteres especiais em arquivos
(utilizados com a opção <code>--from-file</code>).</p></div><p>Agora, crie os Pods:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt; pod.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: List
</span></span></span><span style=display:flex><span><span style=color:#b44>items:
</span></span></span><span style=display:flex><span><span style=color:#b44>- kind: Pod
</span></span></span><span style=display:flex><span><span style=color:#b44>  apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>  metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>    name: prod-db-client-pod
</span></span></span><span style=display:flex><span><span style=color:#b44>    labels:
</span></span></span><span style=display:flex><span><span style=color:#b44>      name: prod-db-client
</span></span></span><span style=display:flex><span><span style=color:#b44>  spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>    volumes:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - name: secret-volume
</span></span></span><span style=display:flex><span><span style=color:#b44>      secret:
</span></span></span><span style=display:flex><span><span style=color:#b44>        secretName: prod-db-secret
</span></span></span><span style=display:flex><span><span style=color:#b44>    containers:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - name: db-client-container
</span></span></span><span style=display:flex><span><span style=color:#b44>      image: myClientImage
</span></span></span><span style=display:flex><span><span style=color:#b44>      volumeMounts:
</span></span></span><span style=display:flex><span><span style=color:#b44>      - name: secret-volume
</span></span></span><span style=display:flex><span><span style=color:#b44>        readOnly: true
</span></span></span><span style=display:flex><span><span style=color:#b44>        mountPath: &#34;/etc/secret-volume&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44>- kind: Pod
</span></span></span><span style=display:flex><span><span style=color:#b44>  apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>  metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>    name: test-db-client-pod
</span></span></span><span style=display:flex><span><span style=color:#b44>    labels:
</span></span></span><span style=display:flex><span><span style=color:#b44>      name: test-db-client
</span></span></span><span style=display:flex><span><span style=color:#b44>  spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>    volumes:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - name: secret-volume
</span></span></span><span style=display:flex><span><span style=color:#b44>      secret:
</span></span></span><span style=display:flex><span><span style=color:#b44>        secretName: test-db-secret
</span></span></span><span style=display:flex><span><span style=color:#b44>    containers:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - name: db-client-container
</span></span></span><span style=display:flex><span><span style=color:#b44>      image: myClientImage
</span></span></span><span style=display:flex><span><span style=color:#b44>      volumeMounts:
</span></span></span><span style=display:flex><span><span style=color:#b44>      - name: secret-volume
</span></span></span><span style=display:flex><span><span style=color:#b44>        readOnly: true
</span></span></span><span style=display:flex><span><span style=color:#b44>        mountPath: &#34;/etc/secret-volume&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>Adicione os Pods a um manifesto <code>kustomization.yaml</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt;&gt; kustomization.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>resources:
</span></span></span><span style=display:flex><span><span style=color:#b44>- pod.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>Crie todos estes objetos no servidor da API rodando o comando:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -k .
</span></span></code></pre></div><p>Ambos os contêineres terão os seguintes arquivos presentes nos seus sistemas de
arquivos, com valores para cada um dos ambientes dos contêineres:</p><pre tabindex=0><code>/etc/secret-volume/username
/etc/secret-volume/password
</code></pre><p>Observe como as <code>spec</code>s para cada um dos Pods diverge somente em um campo. Isso
facilita a criação de Pods com capacidades diferentes a partir de um template
mais genérico.</p><p>Você pode simplificar ainda mais a definição básica do Pod através da utilização
de duas service accounts diferentes:</p><ol><li><code>prod-user</code> com o Secret <code>prod-db-secret</code></li><li><code>test-user</code> com o Secret <code>test-db-secret</code></li></ol><p>A especificação do Pod é reduzida para:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>prod-db-client-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>prod-db-client<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>serviceAccount</span>:<span style=color:#bbb> </span>prod-db-client<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>db-client-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>myClientImage<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=caso-de-uso-dotfiles-em-um-volume-de-secret>Caso de uso: <em>dotfiles</em> em um volume de Secret</h3><p>Você pode fazer com que seus dados fiquem "ocultos" definindo uma chave que se
inicia com um ponto (<code>.</code>). Este tipo de chave representa um <em>dotfile</em>, ou
arquivo "oculto". Por exemplo, quando o Secret abaixo é montado em um volume,
<code>secret-volume</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dotfile-secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>.secret-file</span>:<span style=color:#bbb> </span>dmFsdWUtMg0KDQo=<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-dotfiles-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>dotfile-secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dotfile-test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- ls<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;-l&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;/etc/secret-volume&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/secret-volume&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Este volume irá conter um único arquivo, chamado <code>.secret-file</code>, e o contêiner
<code>dotfile-test-container</code> terá este arquivo presente no caminho
<code>/etc/secret-volume/.secret-file</code>.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Arquivos com nomes iniciados por um caractere de ponto são ocultados do
resultado do comando <code>ls -l</code>. Você precisa utilizar <code>ls -la</code> para vê-los ao
listar o conteúdo de um diretório.</div><h3 id=use-case-secret-visible-to-one-container-in-a-pod>Caso de uso: Secret visível somente em um dos contêineres de um pod</h3><p>Suponha que um programa necessita manipular requisições HTTP, executar regras
de negócio complexas e então assinar mensagens com HMAC. Devido à natureza
complexa da aplicação, pode haver um <em>exploit</em> despercebido que lê arquivos
remotos no servidor e que poderia expor a chave privada para um invasor.</p><p>Esta aplicação poderia ser dividida em dois processos, separados em dois
contêineres distintos: um contêiner de <em>front-end</em>, que manipula as interações
com o usuário e a lógica de negócio, mas não consegue ver a chave privada; e
um contêiner assinador, que vê a chave privada e responde a requisições simples
de assinatura do <em>front-end</em> (por exemplo, através de rede local).</p><p>Com essa abordagem particionada, um invasor agora precisa forçar o servidor de
aplicação a rodar comandos arbitrários, o que é mais difícil de ser feito do que
apenas ler um arquivo presente no disco.</p><h2 id=secret-types>Tipos de Secrets</h2><p>Ao criar um Secret, você pode especificar o seu tipo utilizando o campo <code>type</code>
do objeto Secret, ou algumas opções de linha de comando equivalentes no comando
<code>kubectl</code>, quando disponíveis. O campo <code>type</code> de um Secret é utilizado para
facilitar a manipulação programática de diferentes tipos de dados confidenciais.</p><p>O Kubernetes oferece vários tipos embutidos de Secret para casos de uso comuns.
Estes tipos variam em termos de validações efetuadas e limitações que o
Kubernetes impõe neles.</p><table><thead><tr><th>Tipo embutido</th><th>Caso de uso</th></tr></thead><tbody><tr><td><code>Opaque</code></td><td>dados arbitrários definidos pelo usuário</td></tr><tr><td><code>kubernetes.io/service-account-token</code></td><td>token de service account (conta de serviço)</td></tr><tr><td><code>kubernetes.io/dockercfg</code></td><td>arquivo <code>~/.dockercfg</code> serializado</td></tr><tr><td><code>kubernetes.io/dockerconfigjson</code></td><td>arquivo <code>~/.docker/config.json</code> serializado</td></tr><tr><td><code>kubernetes.io/basic-auth</code></td><td>credenciais para autenticação básica (basic auth)</td></tr><tr><td><code>kubernetes.io/ssh-auth</code></td><td>credenciais para autenticação SSH</td></tr><tr><td><code>kubernetes.io/tls</code></td><td>dados para um cliente ou servidor TLS</td></tr><tr><td><code>bootstrap.kubernetes.io/token</code></td><td>dados de token de autoinicialização</td></tr></tbody></table><p>Você pode definir e utilizar seu próprio tipo de Secret definindo o valor do
campo <code>type</code> como uma string não-nula em um objeto Secret (uma string em branco
é tratada como o tipo <code>Opaque</code>).</p><p>O Kubernetes não restringe nomes de tipos. No entanto, quando tipos embutidos
são utilizados, você precisa atender a todos os requisitos daquele tipo.</p><p>Se você estiver definindo um tipo de Secret que seja para uso público, siga a
convenção e estruture o tipo de Secret para conter o seu domínio antes do nome,
separado por uma barra (<code>/</code>).
Por exemplo: <code>cloud-hosting.example.net/cloud-api-credentials</code>.</p><p>Para melhor desempenho em uma requisição <code>get</code> repetitiva, clientes podem criar
objetos que referenciam o Secret e então utilizar a requisição <code>watch</code> neste
novo objeto, requisitando o Secret novamente quando a referência mudar.
Além disso, uma <a href=https://git.k8s.io/design-proposals-archive/api-machinery/bulk_watch.md>API de "observação em lotes"</a>
para permitir a clientes observar recursos individuais também foi proposta e
provavelmente estará disponível em versões futuras do Kubernetes.</p><p><code>Opaque</code> é o tipo predefinido de Secret quando o campo <code>type</code> é omitido em um
arquivo de configuração de Secret. Quando um Secret é criado usando o comando
<code>kubectl</code>, você deve usar o subcomando <code>generic</code> para indicar que um Secret é
do tipo <code>Opaque</code>. Por exemplo, o comando a seguir cria um Secret vazio do tipo
<code>Opaque</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret generic empty-secret
</span></span><span style=display:flex><span>kubectl get secret empty-secret
</span></span></code></pre></div><p>O resultado será semelhante ao abaixo:</p><pre tabindex=0><code>NAME           TYPE     DATA   AGE
empty-secret   Opaque   0      2m6s
</code></pre><p>A coluna <code>DATA</code> demonstra a quantidade de dados armazenados no Secret. Neste
caso, <code>0</code> significa que este objeto Secret está vazio.</p><h3 id=secrets-de-token-de-service-account-conta-de-serviço>Secrets de token de service account (conta de serviço)</h3><p>Secrets do tipo <code>kubernetes.io/service-account-token</code> são utilizados para
armazenar um token que identifica uma service account (conta de serviço). Ao
utilizar este tipo de Secret, você deve garantir que a anotação
<code>kubernetes.io/service-account.name</code> contém um nome de uma service account
existente. Um controlador do Kubernetes preenche outros campos, como por exemplo
a anotação <code>kubernetes.io/service-account.uid</code> e a chave <code>token</code> no campo <code>data</code>
com o conteúdo do token.</p><p>O exemplo de configuração abaixo declara um Secret de token de service account:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-sa-sample<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/service-account-name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;sa-name&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>kubernetes.io/service-account-token<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># Você pode incluir pares chave-valor adicionais, da mesma forma que faria com</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># Secrets do tipo Opaque</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>extra</span>:<span style=color:#bbb> </span>YmFyCg==<span style=color:#bbb>
</span></span></span></code></pre></div><p>Ao criar um <a class=glossary-tooltip title='O menor e mais simples objeto Kubernetes. Um Pod representa um conjunto de contêineres em execução no seu cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/ target=_blank aria-label=Pod>Pod</a>, o Kubernetes
automaticamente cria um Secret de service account e automaticamente atualiza o
seu Pod para utilizar este Secret. O Secret de token de service account contém
credenciais para acessar a API.</p><p>A criação automática e o uso de credenciais de API podem ser desativados ou
substituídos se desejado. Porém, se tudo que você necessita é poder acessar o
servidor da API de forma segura, este é o processo recomendado.</p><p>Veja a documentação de
<a href=/docs/tasks/configure-pod-container/configure-service-account/>ServiceAccount</a>
para mais informações sobre o funcionamento de service accounts. Você pode
verificar também os campos <code>automountServiceAccountToken</code> e <code>serviceAccountName</code>
do <a href=/docs/reference/generated/kubernetes-api/v1.25/#pod-v1-core><code>Pod</code></a>
para mais informações sobre como referenciar service accounts em Pods.</p><h3 id=secrets-de-configuração-do-docker>Secrets de configuração do Docker</h3><p>Você pode utilizar um dos tipos abaixo para criar um Secret que armazena
credenciais para accesso a um registro de contêineres para busca de imagens:</p><ul><li><code>kubernetes.io/dockercfg</code></li><li><code>kubernetes.io/dockerconfigjson</code></li></ul><p>O tipo <code>kubernetes.io/dockercfg</code> é reservado para armazenamento de um arquivo
<code>~/.dockercfg</code> serializado. Este arquivo é o formato legado para configuração
do utilitário de linha de comando do Docker. Ao utilizar este tipo de Secret,
é preciso garantir que o campo <code>data</code> contém uma chave <code>.dockercfg</code> cujo valor
é o conteúdo do arquivo <code>~/.dockercfg</code> codificado no formato base64.</p><p>O tipo <code>kubernetes.io/dockerconfigjson</code> foi projetado para armazenamento de um
conteúdo JSON serializado que obedece às mesmas regras de formato que o arquivo
<code>~/.docker/config.json</code>. Este arquivo é um formato mais moderno para o conteúdo
do arquivo <code>~/.dockercfg</code>. Ao utilizar este tipo de Secret, o conteúdo do campo
<code>data</code> deve conter uma chave <code>.dockerconfigjson</code> em que o conteúdo do arquivo
<code>~/.docker/config.json</code> é fornecido codificado no formato base64.</p><p>Um exemplo de um Secret do tipo <code>kubernetes.io/dockercfg</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-dockercfg<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>kubernetes.io/dockercfg<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>.dockercfg</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    </span><span style=color:#bbb>    </span><span style=color:#b44>&#34;&lt;base64 encoded ~/.dockercfg file&gt;&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Se você não desejar fazer a codificação em formato base64, você pode utilizar o
campo <code>stringData</code> como alternativa.</div><p>Ao criar estes tipos de Secret utilizando um manifesto (arquivo YAML), o
servidor da API verifica se a chave esperada existe no campo <code>data</code> e se o valor
fornecido pode ser interpretado como um conteúdo JSON válido. O servidor da API
não verifica se o conteúdo informado é realmente um arquivo de configuração do
Docker.</p><p>Quando você não tem um arquivo de configuração do Docker, ou quer utilizar o
comando <code>kubectl</code> para criar um Secret de registro de contêineres, você pode
rodar o comando:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret docker-registry secret-tiger-docker <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --docker-email<span style=color:#666>=</span>tiger@acme.example <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --docker-username<span style=color:#666>=</span>tiger <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --docker-password<span style=color:#666>=</span>pass1234 <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --docker-server<span style=color:#666>=</span>my-registry.example:5000
</span></span></code></pre></div><p>Esse comando cria um secret do tipo <code>kubernetes.io/dockerconfigjson</code>. Se você
obtiver o conteúdo do campo <code>.data.dockerconfigjson</code> deste novo Secret e
decodificá-lo do formato base64:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get secret secret-tiger-docker -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.data.*}&#39;</span> | base64 -d
</span></span></code></pre></div><p>o resultado será equivalente a este documento JSON (que também é um arquivo de
configuração válido do Docker):</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;auths&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;my-registry.example:5000&#34;</span>: {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;username&#34;</span>: <span style=color:#b44>&#34;tiger&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;password&#34;</span>: <span style=color:#b44>&#34;pass1234&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;email&#34;</span>: <span style=color:#b44>&#34;tiger@acme.example&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;auth&#34;</span>: <span style=color:#b44>&#34;dGlnZXI6cGFzczEyMzQ=&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> O valor do campo <code>auth</code> no exemplo acima é codificado em base64; ele está
ofuscado mas não criptografado. Qualquer pessoa com acesso a este Secret pode
ler o conteúdo do token <em>bearer</em>.</div><h3 id=secret-de-autenticação-básica>Secret de autenticação básica</h3><p>O tipo <code>kubernetes.io/basic-auth</code> é fornecido para armazenar credenciais
necessárias para autenticação básica. Ao utilizar este tipo de Secret, o campo
<code>data</code> do Secret deve conter as duas chaves abaixo:</p><ul><li><code>username</code>: o usuário utilizado para autenticação;</li><li><code>password</code>: a senha ou token para autenticação.</li></ul><p>Ambos os valores para estas duas chaves são textos codificados em formato base64.
Você pode fornecer os valores como texto simples utilizando o campo <code>stringData</code>
na criação do Secret.</p><p>O arquivo YAML abaixo é um exemplo de configuração para um Secret de autenticação
básica:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-basic-auth<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>kubernetes.io/basic-auth<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>stringData</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>username</span>:<span style=color:#bbb> </span>admin     <span style=color:#bbb> </span><span style=color:#080;font-style:italic># required field for kubernetes.io/basic-auth</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>password</span>:<span style=color:#bbb> </span>t0p-Secret<span style=color:#bbb> </span><span style=color:#080;font-style:italic># required field for kubernetes.io/basic-auth</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>O tipo de autenticação básica é fornecido unicamente por conveniência. Você pode
criar um Secret do tipo <code>Opaque</code> utilizado para autenticação básica. No entanto,
utilizar o tipo embutido e público de Secret (<code>kubernetes.io/basic-auth</code>)
auxilia outras pessoas a compreenderem o propósito do seu Secret, e define uma
convenção de expectativa de nomes de chaves
O tipo embutido também fornece verificação dos campos requeridos pelo servidor
da API.</p><h3 id=secret-de-autenticação-ssh>Secret de autenticação SSH</h3><p>O tipo embutido <code>kubernetes.io/ssh-auth</code> é fornecido para armazenamento de dados
utilizados em autenticação SSH. Ao utilizar este tipo de Secret, você deve
especificar um par de chave-valor <code>ssh-privatekey</code> no campo <code>data</code> (ou no campo
<code>stringData</code>) com a credencial SSH a ser utilizada.</p><p>O manifesto abaixo é um exemplo de configuração para um Secret de autenticação
SSH com um par de chaves pública/privada:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-ssh-auth<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>kubernetes.io/ssh-auth<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># os dados estão abreviados neste exemplo</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ssh-privatekey</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>     </span><span style=color:#bbb>     </span>MIIEpQIBAAKCAQEAulqb/Y ...<span style=color:#bbb>
</span></span></span></code></pre></div><p>O Secret de autenticação SSH é fornecido apenas para a conveniência do usuário.
Você pode criar um Secret do tipo <code>Opaque</code> para credentials utilizadas para
autenticação SSH. No entanto, a utilização do tipo embutido e público de Secret
(<code>kubernetes.io/ssh-auth</code>) auxilia outras pessoas a compreenderem o propósito do
seu Secret, e define uma convenção de quais chaves podem ser esperadas.
O tipo embutido também fornece verificação dos campos requeridos em uma
configuração de Secret.</p><div class="alert alert-warning caution callout" role=alert><strong>Cuidado:</strong> Chaves privadas SSH não estabelecem, por si só, uma comunicação confiável
entre um cliente SSH e um servidor. Uma forma secundária de estabelecer
confiança é necessária para mitigar ataques <em>man-in-the-middle</em> (MITM), como por
exemplo um arquivo <code>known_hosts</code> adicionado a um ConfigMap.</div><h3 id=secrets-tls>Secrets TLS</h3><p>O Kubernetes fornece o tipo embutido de Secret <code>kubernetes.io/tls</code> para
armazenamento de um certificado e sua chave associada que são tipicamente
utilizados para TLS.</p><p>Uma utilização comum de Secrets TLS é a configuração de encriptação em trânsito
para um recurso <a href=/docs/concepts/services-networking/ingress/>Ingress</a>, mas
este tipo de secret pode também ser utilizado com outros recursos ou diretamente
por uma carga de trabalho.</p><p>Ao utilizar este tipo de Secret, as chaves <code>tls.key</code> e <code>tls.crt</code> devem ser
informadas no campo <code>data</code> (ou <code>stringData</code>) da configuração do Secret, embora o
servidor da API não valide o conteúdo de cada uma destas chaves.</p><p>O YAML a seguir tem um exemplo de configuração para um Secret TLS:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-tls<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>kubernetes.io/tls<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># os dados estão abreviados neste exemplo</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>tls.crt</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    </span><span style=color:#bbb>    </span>MIIC2DCCAcCgAwIBAgIBATANBgkqh ...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>tls.key</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    </span><span style=color:#bbb>    </span>MIIEpgIBAAKCAQEA7yn3bRHQ5FHMQ ...<span style=color:#bbb>
</span></span></span></code></pre></div><p>O tipo TLS é fornecido para a conveniência do usuário. Você pode criar um
Secret do tipo <code>Opaque</code> para credenciais utilizadas para o servidor e/ou
cliente TLS. No entanto, a utilização do tipo embutido auxilia a manter a
consistência dos formatos de Secret no seu projeto; o servidor da API
valida se os campos requeridos estão presentes na configuração do Secret.</p><p>Ao criar um Secret TLS utilizando a ferramenta de linha de comando <code>kubectl</code>,
você pode utilizar o subcomando <code>tls</code> conforme demonstrado no exemplo abaixo:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret tls my-tls-secret <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --cert<span style=color:#666>=</span>path/to/cert/file  <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --key<span style=color:#666>=</span>path/to/key/file
</span></span></code></pre></div><p>O par de chaves pública/privada deve ser criado previamente. O certificado
de chave pública a ser utilizado no argumento <code>--cert</code> deve ser codificado em
formato DER conforme especificado na
<a href=https://datatracker.ietf.org/doc/html/rfc7468#section-5.1>seção 5.1 da RFC 7468</a>
e deve corresponder à chave privada fornecida no argumento <code>--key</code>
(PKCS #8 no formato DER;
<a href=https://datatracker.ietf.org/doc/html/rfc7468#section-11>seção 11 da RFC 7468</a>).</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong><p>Um Secret kubernetes.io/tls armazena o conteúdo de chaves e certificados em
formato DER codificado em base64. Se você tem familiaridade com o formato PEM
para chaves privadas e certificados, o conteúdo é o mesmo do formato PEM,
excluindo-se a primeira e a última linhas.</p><p>Por exemplo, para um certificado, você <strong>não</strong> inclui as linhas
<code>--------BEGIN CERTIFICATE-----</code> e <code>-------END CERTIFICATE----</code>.</p></div><h3 id=bootstrap-token-secrets>Secret de token de autoinicialização</h3><p>Um Secret de token de autoinicialização pode ser criado especificando o tipo de
um Secret explicitamente com o valor <code>bootstrap.kubernetes.io/token</code>. Este tipo
de Secret é projetado para tokens utilizados durante o processo de inicialização
de nós. Este tipo de Secret armazena tokens utilizados para assinar ConfigMaps
conhecidos.</p><p>Um Secret de token de autoinicialização é normalmente criado no namespace
<code>kube-system</code> e nomeado na forma <code>bootstrap-token-&lt;id-do-token></code>, onde
<code>&lt;id-do-token></code> é um texto com 6 caracteres contendo a identificação do token.</p><p>No formato de manifesto do Kubernetes, um Secret de token de autoinicialização
se assemelha ao exemplo abaixo:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>bootstrap-token-5emitj<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>bootstrap.kubernetes.io/token<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>auth-extra-groups</span>:<span style=color:#bbb> </span>c3lzdGVtOmJvb3RzdHJhcHBlcnM6a3ViZWFkbTpkZWZhdWx0LW5vZGUtdG9rZW4=<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>expiration</span>:<span style=color:#bbb> </span>MjAyMC0wOS0xM1QwNDozOToxMFo=<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>token-id</span>:<span style=color:#bbb> </span>NWVtaXRq<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>token-secret</span>:<span style=color:#bbb> </span>a3E0Z2lodnN6emduMXAwcg==<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>usage-bootstrap-authentication</span>:<span style=color:#bbb> </span>dHJ1ZQ==<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>usage-bootstrap-signing</span>:<span style=color:#bbb> </span>dHJ1ZQ==<span style=color:#bbb>
</span></span></span></code></pre></div><p>Um Secret do tipo token de autoinicialização possui as seguintes chaves no campo
<code>data</code>:</p><ul><li><code>token-id</code>: Uma string com 6 caracteres aleatórios como identificador do
token. Requerido.</li><li><code>token-secret</code>: Uma string de 16 caracteres aleatórios como o conteúdo secreto
do token. Requerido.</li><li><code>description</code>: Uma string contendo uma descrição do propósito para o qual este
token é utilizado. Opcional.</li><li><code>expiration</code>: Um horário absoluto UTC no formato RFC3339 especificando quando
o token deve expirar. Opcional.</li><li><code>usage-bootstrap-&lt;usage></code>: Um conjunto de flags booleanas indicando outros
usos para este token de autoinicialização.</li><li><code>auth-extra-groups</code>: Uma lista separada por vírgulas de nomes de grupos que
serão autenticados adicionalmente, além do grupo <code>system:bootstrappers</code>.</li></ul><p>O YAML acima pode parecer confuso, já que os valores estão todos codificados em
formato base64. Você pode criar o mesmo Secret utilizando este YAML:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># Observe como o Secret é nomeado</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>bootstrap-token-5emitj<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># Um Secret de token de inicialização geralmente fica armazenado no namespace</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># kube-system</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>bootstrap.kubernetes.io/token<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>stringData</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>auth-extra-groups</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;system:bootstrappers:kubeadm:default-node-token&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>expiration</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2020-09-13T04:39:10Z&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># Esta identificação de token é utilizada no nome</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>token-id</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;5emitj&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>token-secret</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;kq4gihvszzgn1p0r&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># Este token pode ser utilizado para autenticação</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>usage-bootstrap-authentication</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># e pode ser utilizado para assinaturas</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>usage-bootstrap-signing</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=secret-immutable>Secrets imutáveis</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.21 [stable]</code></div><p>O Kubernetes permite que você marque Secrets (e ConfigMaps) específicos como
<em>imutáveis</em>. Prevenir mudanças nos dados de um Secret existente tem os seguintes
benefícios:</p><ul><li>protege você de alterações acidentais (ou indesejadas) que poderiam provocar
disrupções em aplicações.</li><li>em clusters com uso extensivo de Secrets (pelo menos dezenas de milhares de
montagens únicas de Secrets a Pods), utilizar Secrets imutáveis melhora o
desempenho do seu cluster através da redução significativa de carga no
kube-apiserver. O kubelet não precisa manter um <em>watch</em> em Secrets que são
marcados como imutáveis.</li></ul><h3 id=secret-immutable-create>Marcando um Secret como imutável</h3><p>Você pode criar um Secret imutável adicionando o campo <code>immutable</code> com o valor
<code>true</code> ao manifesto do Secret. Por exemplo:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>immutable</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Você pode também atualizar qualquer Secret mutável existente para torná-lo
imutável.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Uma vez que um Secret ou ConfigMap seja marcado como imutável, <em>não</em> é mais
possível reverter esta mudança, nem alterar os conteúdos do campo <code>data</code>. Você
pode somente apagar e recriar o Secret. Pods existentes mantém um ponto de
montagem referenciando o Secret removido - é recomendado recriar tais Pods.</div><h2 id=information-security-for-secrets>Informações de segurança sobre Secrets</h2><p>Embora ConfigMaps e Secrets funcionem de formas similares, o Kubernetes aplica
proteções extras aos objetos Secret.</p><p>Secrets frequentemente contém valores dentro de um espectro de importância,
muitos dos quais podem provocar escalações de privilégios dentro do Kubernetes
(por exemplo, um token de service account) e em sistemas externos. Mesmo que uma
aplicação individual possa avaliar o poder dos Secrets com os quais espera
interagir, outras aplicações dentro do mesmo namespace podem tornar tais
suposições inválidas.</p><p>Um Secret só é enviado a um nó se um Pod naquele nó precisa do Secret em questão.
Para montar Secrets em Pods, o kubelet armazena uma cópia dos dados dentro de um
sistema de arquivos <code>tmpfs</code>, de modo que os dados confidenciais não sejam
escritos em armazenamento durável. Uma vez que o Pod que dependia do Secret seja
removido, o kubelet apaga sua cópia local dos dados confidenciais do Secret.</p><p>Um Pod pode possuir vários contêineres. Por padrão, contêineres que você define
têm acesso somente à ServiceAccount padrão e seu Secret relacionado. Você deve
explicitamente definir variáveis de ambiente ou mapear um volume dentro de um
contêiner para ter acesso a qualquer outro Secret.</p><p>Podem haver Secrets para vários Pods no mesmo nó. No entanto, somente os Secrets
que um Pod requisitou estão potencialmente visíveis dentro de seus contêineres.
Portanto, um Pod não tem acesso aos Secrets de outro Pod.</p><div class="alert alert-danger warning callout" role=alert><strong>Aviso:</strong> Quaisquer contêineres privilegiados em um nó são passíveis de acesso a todos os
Secrets naquele nó.</div><h3 id=recomendações-de-segurança-para-desenvolvedores>Recomendações de segurança para desenvolvedores</h3><ul><li>Aplicações ainda devem proteger o valor da informação confidencial após lê-la
de uma variável de ambiente ou volume. Por exemplo, sua aplicação deve evitar
imprimir os dados do Secret sem encriptação ou transmitir esta informação para
aplicações terceiras de confiabilidade não-estabelecida.</li><li>Se você estiver definindo múltiplos contêineres em um Pod, e somente um destes
contêineres necessita acesso a um Secret, defina o volume ou variável de
ambiente de maneira que os demais contêineres não tenham acesso àquele Secret.</li><li>Se você configurar um Secret através de um <a class=glossary-tooltip title='A serialized specification of one or more Kubernetes API objects.' data-toggle=tooltip data-placement=top href='/pt-br/docs/reference/glossary/?all=true#term-manifest' target=_blank aria-label=manifesto>manifesto</a>,
com os dados codificados em formato base64, compartilhar este arquivo ou
salvá-lo em um sistema de controle de versão de código-fonte significa que o
Secret está disponível para qualquer pessoa que pode ler o manifesto. O formato
base64 <em>não é</em> um método de encriptação e não fornece nenhuma confidencialidade
adicional em comparação com texto puro.</li><li>Ao instalar aplicações que interagem com a API de Secrets, você deve limitar
o acesso utilizando
<a href=/docs/reference/access-authn-authz/authorization/>políticas de autorização</a>,
como por exemplo <a href=/docs/reference/access-authn-authz/rbac/>RBAC</a>.</li><li>Na API do Kubernetes, requisições <code>watch</code> e <code>list</code> em Secrets dentro de um
namespace são extremamente poderosas. Evite fornecer este acesso quando
possível, já que listar Secrets permite aos clientes inspecionar os valores de
todos os Secrets naquele namespace.</li></ul><h3 id=recomendações-de-segurança-para-administradores-de-cluster>Recomendações de segurança para administradores de cluster</h3><div class="alert alert-warning caution callout" role=alert><strong>Cuidado:</strong> Um usuário que pode criar um Pod que utiliza um Secret pode também ver o valor
daquele Secret. Mesmo que as permissões do cluster não permitam ao usuário ler
o Secret diretamente, o mesmo usuário poderia ter acesso a criar um Pod que
então expõe o Secret.</div><ul><li>Restrinja a habilidade de usar as requisições <code>watch</code> e <code>list</code> para listar todos
os Secrets em um cluster (utilizando a API do Kubernetes) de modo que somente
os componentes mais privilegiados e de nível de sistema possam realizar esta
ação.</li><li>Ao instalar aplicações que interajam com a API de Secrets, você deve limitar o
acesso utilizando
<a href=/docs/reference/access-authn-authz/authorization/>políticas de autorização</a>,
como por exemplo <a href=/docs/reference/access-authn-authz/rbac/>RBAC</a>.</li><li>No servidor da API, objetos (incluindo Secrets) são persistidos no
<a class=glossary-tooltip title='Armazenamento do tipo Chave-Valor consistente e em alta-disponibilidade usado como repositório de apoio do Kubernetes para todos os dados do cluster.' data-toggle=tooltip data-placement=top href=/docs/tasks/administer-cluster/configure-upgrade-etcd/ target=_blank aria-label=etcd>etcd</a>; portanto:<ul><li>somente permita a administradores do sistema o acesso ao etcd (incluindo
acesso somente-leitura);</li><li>habilite <a href=/docs/tasks/administer-cluster/encrypt-data/>encriptação em disco</a>
para objetos Secret, de modo que os dados de tais Secrets não sejam
armazenados em texto plano no <a class=glossary-tooltip title='Armazenamento do tipo Chave-Valor consistente e em alta-disponibilidade usado como repositório de apoio do Kubernetes para todos os dados do cluster.' data-toggle=tooltip data-placement=top href=/docs/tasks/administer-cluster/configure-upgrade-etcd/ target=_blank aria-label=etcd>etcd</a>;</li><li>considere a destruição do armazenamento durável previamente utilizado pelo
etcd quando não estiver mais em uso;</li><li>se houverem múltiplas instâncias do etcd em uso, garanta que o etcd esteja
configurado para utilizar SSL/TLS para comunicação entre instâncias.</li></ul></li></ul><h2 id=próximos-passos>Próximos passos</h2><ul><li>Aprenda a <a href=/pt-br/docs/tasks/configmap-secret/managing-secret-using-kubectl/>gerenciar Secrets utilizando <code>kubectl</code></a></li><li>Aprenda a <a href=/pt-br/docs/tasks/configmap-secret/managing-secret-using-config-file/>gerenciar Secrets utilizando arquivos de configuração</a></li><li>Aprenda a <a href=/pt-br/docs/tasks/configmap-secret/managing-secret-using-kustomize/>gerenciar Secrets utilizando kustomize</a></li><li>Leia a <a href=/docs/reference/kubernetes-api/config-and-storage-resources/secret-v1/>documentação de referência da API</a> de Secrets</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-436057b96151ecb8a4a9a9f456b5d0fc>3.6.4 - Gerenciamento de recursos em Pods e contêineres</h1><p>Ao criar a especificação de um <a class=glossary-tooltip title='O menor e mais simples objeto Kubernetes. Um Pod representa um conjunto de contêineres em execução no seu cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/ target=_blank aria-label=Pod>Pod</a>, você pode
opcionalmente especificar quanto de cada recurso um <a class=glossary-tooltip title='Uma imagem executável leve e portável que contém software e todas as suas dependências.' data-toggle=tooltip data-placement=top href=/docs/concepts/containers/ target=_blank aria-label=contêiner>contêiner</a>
precisa. Os recursos mais comuns a serem especificados são CPU e memória (RAM);
há outros recursos que podem ser especificados.</p><p>Quando você especifica o <em>requerimento</em> de recursos em um Pod, o
<a class=glossary-tooltip title='Componente da camada de gerenciamento que observa os pods recém-criados sem nenhum nó atribuído, e seleciona um nó para executá-los.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-scheduler/ target=_blank aria-label=kube-scheduler>kube-scheduler</a> utiliza
esta informação para decidir a qual nó o Pod será atribuído. Quando você
especifica um <em>limite</em> de recurso para um contêiner, o kubelet garante o
cumprimento de tais limites, de modo que o contêiner em execução não consiga
utilizar uma quantidade de tal recurso além do limite especificado. O kubelet
também reserva pelo menos o <em>requerimento</em> daquele recurso de sistema
especificamente para que este contêiner utilize.</p><h2 id=requerimentos-e-limites>Requerimentos e limites</h2><p>Se o nó em que um Pod está rodando tem o suficiente de um recurso específico
disponível, é possível (e permitido) a um contêiner utilizar mais do que o seu
<code>request</code> para aquele recurso especifica. No entanto, não é permitido a um
contêiner consumir mais do que o seu <code>limit</code> para um recurso.</p><p>Por exemplo, se você especificar um requerimento de <code>memory</code> de 256 MiB para um
contêiner, e aquele contêiner está em um Pod atribuído a um nó com 8GiB de
memória, sem outros Pods, então este contêiner pode tentar consumir mais memória
RAM.</p><p>Se você especificar um limite de <code>memory</code> de 4GiB para aquele contêiner, o
kubelet (e o
<a class=glossary-tooltip title='O agente de execução de contêiner é o software responsável por executar os contêineres.' data-toggle=tooltip data-placement=top href=/docs/setup/production-environment/container-runtimes target=_blank aria-label='agente de execução de contêiner'>agente de execução de contêiner</a>)
vão garantir o cumprimento do limite. O agente de execução impede que o contêiner
utilize mais de um recurso do que seu limite configurado. Por exemplo, quando
um processo no contêiner tenta consumir mais que o limite permitido de memória,
o núcleo do sistema encerra o processo que tentou efetuar a alocação de memória
com um erro de memória esgotada (<em>out of memory (OOM) error</em>).</p><p>Limites podem ser implementados de forma reativa (o sistema intervém quando
uma violação ocorre) ou por garantia (o sistema previne o contêiner de exceder
o limite). Diferentes agentes de execução implementam as mesmas restrições de
maneiras diferentes.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Se um contêiner especifica seu próprio limite de memória, mas não especifica seu
requerimento de memória, o Kubernetes automaticamente cria um requerimento de
memória com o mesmo valor do limite. A mesma regra vale para o limite de CPU:
quando não há requerimento de CPU, o Kubernetes automaticamente cria um
requerimento de CPU idêntico ao limite.</div><h2 id=tipos-de-recursos>Tipos de recursos</h2><p><em>CPU</em> e <em>memória</em> são <em>tipos de recursos</em>. Um tipo de recurso possui uma unidade
básica. CPU representa processamento computacional e é especificada em unidades
de <a href=#meaning-of-cpu>CPU do Kubernetes</a>.
Memória é especificada em bytes. Em cargas de trabalho Linux, você pode
especificar o recurso <em>huge pages</em>. <em>Huge pages</em> são uma funcionalidade
específica do Linux que permite ao núcleo do sistema operacional alocar
blocos de memória muito maiores que o tamanho de página de memória padrão.</p><p>Por exemplo, em um sistema onde o tamanho da página de memória padrão é de 4 KiB,
você pode especificar um limite <code>hugepages-2Mi: 80Mi</code>. Se o contêiner tentar
alocar mais de 40 <em>huge pages</em> de 2 MiB cada, ou um total de 80 MiB, essa
alocação irá falhar.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Você não pode superdimensionar (ou solicitar acima do limite físico) recursos do
tipo <code>hugepages-*</code>.
O recurso <code>hugepages-*</code> difere dos recursos <code>memory</code> e <code>cpu</code> neste aspecto.</div><p>CPU e memória são chamados coletivamente de <em>recursos computacionais</em>, ou apenas
<em>recursos</em>. Recursos computacionais são quantidades mensuráveis que podem ser
requisitadas, alocadas, e consumidas. Estes recursos diferem dos
<a href=/docs/concepts/overview/kubernetes-api/>recursos de API</a>. Recursos de API,
como Pods e <a href=/docs/concepts/services-networking/service/>Services</a> são objetos
que podem ser lidos e modificados através do servidor da API do Kubernetes.</p><h2 id=requerimentos-de-recursos-e-limites-de-pod-e-contêiner>Requerimentos de recursos e limites de Pod e contêiner</h2><p>Para cada contêiner, você pode especificar limites e requerimentos de recursos,
incluindo os seguintes recursos:</p><ul><li><code>spec.containers[].resources.limits.cpu</code></li><li><code>spec.containers[].resources.limits.memory</code></li><li><code>spec.containers[].resources.limits.hugepages-&lt;size></code></li><li><code>spec.containers[].resources.requests.cpu</code></li><li><code>spec.containers[].resources.requests.memory</code></li><li><code>spec.containers[].resources.requests.hugepages-&lt;size></code></li></ul><p>Embora você possa especificar apenas requerimentos e limites para contêineres
individuais, é útil também pensar sobre os requerimentos e limites gerais de um
Pod.
Para um recurso em particular, um <em>requerimento ou limite de recurso de um Pod</em>
é a soma de todos os valores dos requerimentos ou limites de um recurso daquele
tipo, especificados em cada um dos contêineres daquele Pod.</p><h2 id=unidades-de-recursos-no-kubernetes>Unidades de recursos no Kubernetes</h2><h3 id=meaning-of-cpu>Unidades de recurso de CPU</h3><p>Limites e requerimentos de recursos de CPU são mensurados em unidades de <em>cpu</em>.
No Kubernetes, uma unidade de CPU é equivalente a <strong>um núcleo físico de CPU</strong>,
ou <strong>um núcleo virtual</strong>, dependendo se o nó é uma máquina física ou uma máquina
virtual rodando em uma máquina física.</p><p>Requerimentos fracionários são permitidos. Quando você define um contêiner cujo
valor do campo <code>spec.containers[].resources.requests.cpu</code> é <code>0.5</code>, você está
solicitando metade da quantidade de CPU que teria sido solicitada caso o valor
fosse <code>1.0</code>.
No caso de unidades de recurso de CPU, a expressão de
<a href=/docs/reference/kubernetes-api/common-definitions/quantity/>quantidade</a> <code>0.1</code>
é equivalente à expressão <code>100m</code>, que pode ser lida como "cem milicpus", ou
"cem milinúcleos". "Milicpu" ou "milinúcleo" equivalem à milésima parte de um
núcleo ou CPU, de modo que "100m" equivalem a 10% do tempo computacional de um
processador.</p><p>Recursos de CPU são sempre especificados como uma quantidade absoluta de recurso,
nunca como uma quantidade relativa. Por exemplo, <code>500m</code> de CPU representam
grosseiramente a mesma quantidade de poder computacional, independentemente do
contêiner rodar em uma máquina com processador de núcleo único, de dois núcleos
ou de 48 núcleos.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> O Kubernetes não permite que você especifique recursos de CPU com uma precisão
maior que <code>1m</code>. Devido a isso, é útil especificar unidades de CPU menores do que
<code>1.0</code> ou <code>1000m</code> utilizando a notação de milicpu. Por exemplo, <code>5m</code> ao invés de
<code>0.005</code>.</div><h3 id=meaning-of-memory>Unidades de recurso de memória</h3><p>Limites e requerimentos de <code>memory</code> são medidos em bytes. Você pode expressar
memória como um número inteiro ou como um número de ponto fixo, utilizando um
destes sufixos de
<a href=/docs/reference/kubernetes-api/common-definitions/quantity/>quantidade</a>:
E, P, T, G, M, k. Você também pode utilizar os equivalentes de potência de dois:
Ei, Pi, Ti, Gi, Mi, Ki. Por exemplo, as quantidades abaixo representam, a grosso
modo, o mesmo valor:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>128974848, 129e6, 129M, 128974848000m, 123Mi
</span></span></code></pre></div><p>Tome cuidado com os sufixos. Se você solicitar <code>400m</code> de memória, esta
quantidade estará de fato requerendo o equivalente a 0,4 byte de memória. A
intenção da pessoa que fez esta requisição provavelmente era solictar 400
mebibytes (<code>400Mi</code>) ou 400 megabytes (<code>400M</code>).</p><h2 id=example-1>Exemplo de recursos de contêiner</h2><p>O Pod seguinte tem dois contêineres. Ambos os contêineres têm um requerimento de
0,25 CPU e 64 MiB (ou 2<sup>26</sup> bytes) de memória. Cada contêiner tem um
limite de 0,5 CPU e 128 MiB de memória. Você pode dizer que o Pod tem um
requerimento de 0,5 CPU e 128 MiB de memória, e um limite de 1 CPU e 256 MiB de
memória.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>app<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>images.my-company.example/app:v4<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;64Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;250m&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;128Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;500m&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>log-aggregator<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>images.my-company.example/log-aggregator:v6<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;64Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;250m&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;128Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;500m&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=como-pods-com-requerimentos-de-recursos-são-agendados>Como Pods com requerimentos de recursos são agendados</h2><p>Quando você cria um Pod, o escalonador do Kubernetes seleciona um nó para que o
Pod rode. Cada nó possui uma capacidade máxima para cada um dos tipos de recurso:
a quantidade de CPU e memória que o nó pode fornecer aos Pods. O escalonador
garante que, para cada tipo de recurso, a soma dos requerimentos de recursos dos
contêineres agendados seja menor que a capacidade do nó.
Note que, embora o consumo de memória ou CPU real nos nós seja muito baixo, o
escalonador ainda irá se recusar a agendar um Pod em um nó se a verificação de
capacidade falhar. Isso protege contra a falta de um recurso em um nó quando o
consumo de recursos aumenta com o passar do tempo, como por exemplo durante o
pico diário de requisições a um serviço.</p><h2 id=how-pods-with-resource-limits-are-run>Como o Kubernetes aplica requisições e limites de recursos</h2><p>Quando o kubelet inicia um contêiner como parte de um Pod, o kubelet envia as
requisições e limites de memória e de CPU ao agente de execução de contêiner.</p><p>No Linux, o agente de execução de contêiner normalmente configura os
<a class=glossary-tooltip title='Um grupo de processos do Linux com isolamento de recursos opcional, contagem e limites.' data-toggle=tooltip data-placement=top href='/pt-br/docs/reference/glossary/?all=true#term-cgroup' target=_blank aria-label=cgroups>cgroups</a> que aplicam e garantem
os limites que você definiu.</p><ul><li>O limite de CPU determina um teto de quanto tempo de CPU o contêiner pode
utilizar. A cada intervalo de agendamento, o núcleo do sistema operacional do
Linux verifica se este limite foi excedido; se este for o caso, o núcleo
aguarda antes de permitir que aquele cgroup continue sua execução.</li><li>O requerimento de CPU normalmente define um método de balanceamento. Se vários
contêineres diferentes (cgroups) querem rodar em um sistema disputado, cargas
de trabalho com requerimentos maiores de CPU têm mais tempo de CPU alocado
para si do que cargas de trabalho com pequenos requerimentos.</li><li>O requerimento de memória é usado principalmente durante o agendamento de um
Pod. Em um nó que utiliza cgroups v2, o agente de execução de contêiner pode
utilizar o requerimento de memória como uma dica para definir valores para
<code>memory.min</code> e <code>memory.low</code>.</li><li>O limite de memória define um limite de memória para aquele cgroup. Se o
contêiner tenta alocar mais memória que aquele limite, o subsistema
<em>out-of-memory</em> do núcleo do sistema operacional Linux é ativado e,
normalmente, intervém encerrando um dos processos do contêiner que tentou
alocar mais memória. Se o processo em questão for o PID 1 do contêiner, e o
contêiner estiver marcado como reinicializável, então o Kubernetes irá
reiniciar o contêiner.</li><li>O limite de memória para um Pod ou contêiner é também aplicado a páginas em
volumes armazenados em memória, como um <code>emptyDir</code>. O kubelet considera
sistemas de arquivos <code>tmpfs</code> em volumes do tipo <code>emptyDir</code> como uso de memória
em um contêiner, ao invés de armazenamento efêmero local.</li></ul><p>Se um contêiner exceder seu requerimento de memória e o nó em que esse contêiner
está rodando ficar com pouca memória no total, é provável que o Pod a que este
contêiner pertence seja <a class=glossary-tooltip title='Processo de encerramento de um ou mais Pods em Nós' data-toggle=tooltip data-placement=top href=/pt-br/docs/concepts/scheduling-eviction/ target=_blank aria-label=removido>removido</a>.</p><p>A um contêiner pode ou não ser permitido exceder seu limite de CPU por períodos
de tempo estendidos. No entanto, agentes de execução de contêiner não encerram
Pods por uso excessivo de CPU.</p><p>A fim de determinar se um contêiner não pode ser agendado ou está sendo
encerrado devido a limites de recursos, consulte a seção de
<a href=#troubleshooting>solução de problemas</a>.</p><h3 id=monitorando-utilização-de-recursos-computacionais-e-de-memória>Monitorando utilização de recursos computacionais e de memória</h3><p>O kubelet relata a utilização de recursos de um Pod como parte do
<a href=/docs/concepts/overview/working-with-objects/kubernetes-objects/#object-spec-and-status><code>status</code></a>
do Pod.</p><p>Se ferramentas opcionais para
<a href=/docs/tasks/debug-application-cluster/resource-usage-monitoring/>monitoramento de recursos</a>
estiverem disponíveis em seu cluster, a utilização de recursos de um Pod pode
ser verificada diretamente através de
<a href=/docs/tasks/debug-application-cluster/resource-metrics-pipeline/#the-metrics-api>API de métricas</a>
ou através das suas ferramentas de monitoramento</p><h2 id=armazenamento-efêmero-local>Armazenamento efêmero local</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.10 [beta]</code></div><p>Nós possuem armazenamento efêmero local, através de dispositivos de escrita
conectados localmente ou através de RAM. "Efêmero" significa que não há garantia
de longo termo com relação a durabilidade.</p><p>Pods utilizam armazenamento local efêmero para dados temporários, cache e logs.
O kubelet pode fornecer armazenamento temporário a Pods que utilizam
armazenamento local efêmero para montar <a class=glossary-tooltip title='Um diretório contendo dados, accessível aos contêineres em um pod.' data-toggle=tooltip data-placement=top href=/docs/concepts/storage/volumes/ target=_blank aria-label=volumes>volumes</a>
do tipo <a href=/docs/concepts/storage/volumes/#emptydir><code>emptyDir</code></a> em contêineres.</p><p>O kubelet também utiliza este tipo de armazenamento para
<a href=/pt-br/docs/concepts/cluster-administration/logging/#logs-no-n%C3%ADvel-do-n%C3%B3>logs de contêineres a nível de nó</a>,
imagens de contêiner e camadas graváveis de contêineres em execução.</p><div class="alert alert-warning caution callout" role=alert><strong>Cuidado:</strong> Se um nó falhar, os dados em seu armazenamento efêmero podem ser perdidos.
Suas aplicações não devem ter expectativas de cumprimento de SLAs de desempenho
(como quantidade de operações de entrada e saída de disco por segundo (IOPS),
por exemplo) pelo armazenamento local efêmero.</div><p>Com esta funcionalidade em fase beta, o Kubernetes permite que você rastreie,
reserve e limite quanto armazenamento local efêmero um Pod pode consumir.</p><h3 id=configurations-for-local-ephemeral-storage>Configurações para armazenamento local efêmero</h3><p>O Kubernetes suporta duas formas de configuração para o armazenamento local
efêmero em um nó:</p><ul class="nav nav-tabs" id=local-storage-configurations role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#local-storage-configurations-0 role=tab aria-controls=local-storage-configurations-0 aria-selected=true>Sistema de arquivos único</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#local-storage-configurations-1 role=tab aria-controls=local-storage-configurations-1>Dois sistemas de arquivos</a></li></ul><div class=tab-content id=local-storage-configurations><div id=local-storage-configurations-0 class="tab-pane show active" role=tabpanel aria-labelledby=local-storage-configurations-0><p><p>Nesta configuração, você armazena todos os tipos diferentes de dados locais
efêmeros (volumes do tipo <code>emptyDir</code>, camadas graváveis, imagens de contêiner,
logs) em um sistema de arquivos único. A forma mais efetiva de configurar o
kubelet é dedicar este sistema de arquivos aos dados do Kubernetes (kubelet).</p><p>O kubelet também escreve
<a href=/pt-br/docs/concepts/cluster-administration/logging/#logs-no-n%C3%ADvel-do-n%C3%B3>logs de contêiner a nível de nó</a>
e trata estes logs de maneira semelhante ao armazenamento efêmero local.</p><p>O kubelet escreve logs em arquivos dentro do seu diretório de log configurado
(<code>/var/log</code> por padrão) e possui um diretório base para outros dados armazenados
localmente (<code>/var/lib/kubelet</code> por padrão).</p><p>Normalmente, ambos os diretórios <code>/var/lib/kubelet</code> e <code>/var/log</code> encontram-se no
sistema de arquivos raiz, e o kubelet é projetado com este desenho em mente.</p><p>Seu nó pode ter tantos outros sistemas de arquivos não utilizados pelo Kubernetes
quantos você desejar.</p></div><div id=local-storage-configurations-1 class=tab-pane role=tabpanel aria-labelledby=local-storage-configurations-1><p><p>Você tem um sistema de arquivos no nó que você utiliza para dados efêmeros que
vêm de Pods em execução: logs e volumes do tipo <code>emptyDir</code>. Você pode utilizar
este sistema de arquivos para outros dados (por exemplo, logs de sistema não
relacionados ao Kubernetes); este sistema de arquivos pode até mesmo ser o
sistema de arquivos raiz.</p><p>O kubelet também escreve
<a href=/pt-br/docs/concepts/cluster-administration/logging/#logs-no-n%C3%ADvel-do-n%C3%B3>logs de contêiner a nível de nó</a>
no primeiro sistema de arquivos e os trata de forma semelhante ao armazenamento
local efêmero.</p><p>Você também tem um segundo sistema de arquivos, separado, conectado a um
dispositivo lógico de armazenamento distinto. Nesta configuração, o diretório
que você configurou o kubelet para armazenar as camadas de imagens de contêiner
e as camadas graváveis de contêineres em execução estará neste segundo sistema
de arquivos.</p><p>O primeiro sistema de arquivos não armazena nenhuma camada de imagens de
contêiner ou camada gravável.</p><p>Seu nó pode ter tantos outros sistemas de arquivos não utilizados pelo Kubernetes
quantos você desejar.</p></div></div><p>O kubelet consegue medir quanto armazenamento local está sendo utilizado. O
kubelet faz isso desde que:</p><ul><li>o <a href=/docs/reference/command-line-tools-reference/feature-gates/><em>feature gate</em></a>
<code>LocalStorageCapacityIsolation</code> esteja habilitado (a funcionalidade está
ligada por padrão), e</li><li>você tenha configurado o nó utilizando uma das configurações suportadas para
o armazenamento local efêmero.</li></ul><p>Se você tiver uma configuração diferente, o kubelet não irá aplicar limites de
recursos para o armazenamento local efêmero.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> O kubelet rastreia volumes <code>emptyDir</code> que utilizem o sistema de arquivos <code>tmpfs</code>
como uso de memória de contêiner, ao invés de consumo de armazenamento local
efêmero.</div><h3 id=configurando-requerimentos-e-limites-para-armazenamento-local-efêmero>Configurando requerimentos e limites para armazenamento local efêmero</h3><p>Você pode especificar o recurso <code>ephemeral-storage</code> para gerenciar o
armazenamento local efêmero. Cada contêiner de um Pod pode especificar um dos
valores abaixo, ou ambos:</p><ul><li><code>spec.containers[].resources.limits.ephemeral-storage</code></li><li><code>spec.containers[].resources.requests.ephemeral-storage</code></li></ul><p>Limites e requerimentos de <code>ephemeral-storage</code> são medidos em quantidades de
bytes. Você pode expressar armazenamento como um inteiro ou como um valor de
ponto fixo utilizando um dos seguintes sufixos: E, P, T, G, M, k. Você pode
também utilizar os equivalentes de potência de dois: Ei, Pi, Ti, Gi, Mi, Ki.
Por exemplo, as quantidades abaixo representam grosseiramente o mesmo valor:</p><ul><li><code>128974848</code></li><li><code>129e6</code></li><li><code>129M</code></li><li><code>123Mi</code></li></ul><p>No exemplo a seguir, o Pod tem dois contêineres. Cada contêiner tem um
requerimento de 2GiB de armazenamento efêmero local. Cada contêiner tem um
limite de 4GiB de armazenamento efêmero local. Portanto, o Pod tem um
requerimento de 4GiB e um limite de 8GiB de armazenamento efêmero local.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>app<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>images.my-company.example/app:v4<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ephemeral-storage</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2Gi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ephemeral-storage</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;4Gi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>ephemeral<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/tmp&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>log-aggregator<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>images.my-company.example/log-aggregator:v6<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ephemeral-storage</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2Gi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ephemeral-storage</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;4Gi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>ephemeral<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/tmp&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>ephemeral<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=como-pods-com-requerimentos-de-ephemeral-storage-são-agendados>Como Pods com requerimentos de <code>ephemeral-storage</code> são agendados</h3><p>Quando você cria um Pod, o Kubernetes seleciona um nó para o Pod rodar. Cada nó
tem uma quantidade máxima de armazenamento efêmero local que pode ser fornecida
aos Pods. Para mais informações, consulte
<a href=/docs/tasks/administer-cluster/reserve-compute-resources/#node-allocatable><em>Node Allocatable</em></a>.</p><p>O escalonador garante que a soma dos requerimentos de recursos dos contêineres
agendados é menor que a capacidade do nó.</p><h3 id=resource-emphemeralstorage-consumption>Gerenciamento do consumo do armazenamento efêmero</h3><p>Se o kubelet estiver gerenciando armazenamento local efêmero como um recurso,
o kubelet irá medir o consumo de armazenamento em:</p><ul><li>volumes <code>emptyDir</code>, com exceção dos volumes do tipo <code>tmpfs</code></li><li>diretórios que armazenem logs a nível de nó</li><li>camadas de contêiner graváveis</li></ul><p>Se um Pod estiver utilizando mais armazenamento efêmero do que o permitido, o
kubelet irá gerar um sinal de remoção para aquele Pod.</p><p>Para isolamento a nível de contêiner, se o consumo de armazenamento de um
contêiner em camadas graváveis e logs exceder seu limite de armazenamento, o
kubelet irá marcar o Pod para remoção.</p><p>Para isolamento a nível de Pod, o kubelet calcula um limite de armazenamento
total para um Pod somando os limites de cada contêiner naquele Pod. Neste caso,
se a soma do consumo de armazenamento efêmero local de todas os contêineres e
também dos volumes <code>emptyDir</code> de um Pod exceder o limite de armazenamento total
do Pod, então o kubelet marca o Pod para remoção.</p><div class="alert alert-warning caution callout" role=alert><strong>Cuidado:</strong><p>Se o kubelet não estiver medindo armazenamento efêmero local, um Pod que exeder
seu limite de armazenamento local não será removido por exceder os limites de
recurso de armazenamento local.</p><p>No entanto, se o espaço de um sistema de arquivos para camadas de contêiner
graváveis, logs a nível de nó, ou volumes <code>emptyDir</code> ficar reduzido, o nó irá
marcar a si próprio com um <a class=glossary-tooltip title='A core object consisting of three required properties: key, value, and effect. Taints prevent the scheduling of pods on nodes or node groups.' data-toggle=tooltip data-placement=top href=/docs/concepts/scheduling-eviction/taint-and-toleration/ target=_blank aria-label=_taint_><em>taint</em></a>
indicando que está com armazenamento local reduzido, e esse <em>taint</em> dispara a
remoção de Pods que não toleram o <em>taint</em> em questão.</p><p>Veja as <a href=#configurations-for-local-ephemeral-storage>configurações</a> suportadas
para armazenamento efêmero local.</p></div><p>O kubelet suporta formas diferentes de medir o uso de armazenamento dos Pods:</p><ul class="nav nav-tabs" id=resource-emphemeralstorage-measurement role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#resource-emphemeralstorage-measurement-0 role=tab aria-controls=resource-emphemeralstorage-measurement-0 aria-selected=true>Varredura periódica</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#resource-emphemeralstorage-measurement-1 role=tab aria-controls=resource-emphemeralstorage-measurement-1>Quota de projeto do sistema de arquivos</a></li></ul><div class=tab-content id=resource-emphemeralstorage-measurement><div id=resource-emphemeralstorage-measurement-0 class="tab-pane show active" role=tabpanel aria-labelledby=resource-emphemeralstorage-measurement-0><p><p>O kubelet executa verificações agendadas, em intervalos regulares, que varrem
cada volume do tipo <code>emptyDir</code>, diretório de log de contêiner, e camada gravável
de contêiner.</p><p>A varredura mede quanto espaço está sendo utilizado.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong><p>Neste modo, o kubelet não rastreia descritores de arquivos abertos para arquivos
removidos.</p><p>Se você (ou um contêiner) criar um arquivo dentro de um volume <code>emptyDir</code>, um
processo ou usuário abrir tal arquivo, e você apagar o arquivo enquanto ele
ainda estiver aberto, o nó de índice para o arquivo apagado será mantido até que
o arquivo seja fechado novamente. O kubelet, no entanto, não computa este espaço
como espaço em uso.</p></div></div><div id=resource-emphemeralstorage-measurement-1 class=tab-pane role=tabpanel aria-labelledby=resource-emphemeralstorage-measurement-1><p><p>Quotas de projeto são uma funcionalidade a nível de sistema operacional para
gerenciamento de uso do armazenamento em sistemas de arquivos. Com o Kubernetes,
você pode habilitar quotas de projeto para o monitoramento de armazenamento em
uso. Tenha certeza que o sistema de arquivos do nó que esteja sendo utilizado em
volumes do tipo <code>emptyDir</code> possui suporte a quotas de projeto. Por exemplo,
os sistemas de arquivos XFS e ext4fs oferecem suporte a quotas de projeto.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Quotas de projeto permitem o monitoramento do uso de armazenamento, mas não
garantem limites.</div><p>O Kubernetes utiliza IDs de projeto iniciando em <code>1048576</code>. Os IDs em uso estão
registrados nos diretórios <code>/etc/projects</code> e <code>/etc/projid</code>. Se os IDs de projeto
nestes intervalos forem utilizados para outros propósitos no sistema, estes IDs
de projeto deverão estar registrados nos diretórios especificados acima para que
o Kubernetes não os tente utilizar.</p><p>Quotas fornecem melhor desempenho e mais precisão do que varredura de diretórios.
Quando um diretório é atribuído a um projeto, todos os arquivos criados no
diretório são também criados no projeto, e o núcleo do sistema pode simplesmente
manter controle de quantos blocos estão em uso por arquivos daquele projeto. Se
um arquivo é criado e apagado, mas possui um descritor de arquivo aberto, ele
continua a consumir espaço. O rastreio de quotas registra este espaço de forma
precisa, enquanto varreduras de diretório ignoram o uso de espaço de
armazenamento por arquivos apagados.</p><p>Se você deseja utilizar quotas de projeto, você deve:</p><ul><li><p>Habilitar o <a href=/docs/reference/command-line-tools-reference/feature-gates/><em>feature gate</em></a>
<code>LocalStorageCapacityIsolationFSQuotaMonitoring=true</code> utilizando o campo
<code>featureGates</code> na <a href=/docs/reference/config-api/kubelet-config.v1beta1/>configuração do kubelet</a>
ou a opção de linha de comando <code>--feature-gates</code>.</p></li><li><p>Garantir que o sistema de arquivos raiz (ou o sistema de arquivos opcional de
tempo de execução) tem quotas de projeto habilitadas. Todos os sistemas de
arquivos XFS suportam quotas de projeto. Em sistemas de arquivos ext4, você
precisa habilitar a funcionalidade de rastreio de quotas de projeto enquanto
o sistema de arquivos ainda não está montado.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#080;font-style:italic># Para sistema de arquivos ext4, com o volume /dev/block-device não montado</span>
</span></span><span style=display:flex><span>sudo tune2fs -O project -Q prjquota /dev/block-device
</span></span></code></pre></div></li><li><p>Garanta que o sistema de arquivos raiz (ou sistema de arquivos opcional de
tempo de execução) esteja montado com quotas de projeto habilitadas. Em ambos
os sistemas XFS e ext4fs, a opção de montagem é chamada <code>prjquota</code>.</p></li></ul></div></div><h2 id=recursos-estendidos>Recursos estendidos</h2><p>Recursos estendidos são nomes de recursos absolutos fora do domínio
<code>kubernetes.io</code>. Estes recursos permitem a operadores de cluster anunciar e a
usuários consumir recursos que não são embutidos pelo Kubernetes.</p><p>Dois passos são necessários para a utilização de recursos estendidos.
Primeiramente, o operador do cluster deve anunciar um recurso estendido. Em
segundo lugar, os usuários devem solicitar o recurso estendido em Pods.</p><h3 id=gerenciando-recursos-estendidos>Gerenciando recursos estendidos</h3><h4 id=recursos-estendidos-a-nível-de-nó>Recursos estendidos a nível de nó</h4><p>Recursos estendidos a nível de nó são recursos ligados ao nó.</p><h5 id=recursos-gerenciados-por-dispositivos-conectados>Recursos gerenciados por dispositivos conectados</h5><p>Veja <a href=/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/>Device Plugin</a>
para mais informações sobre como anunciar recursos gerenciados por dispositivos
conectados em cada nó.</p><h5 id=outros-recursos>Outros recursos</h5><p>A fim de anunciar um novo recurso estendido a nível de nó, o operador do cluster
pode enviar uma requisição HTTP com o método <code>PATCH</code> para o servidor da API do
Kubernetes para especificar a quantidade disponível em um nó no cluster, através
do campo <code>status.capacity</code>. Após a realização desta operação, o campo
<code>status.capacity</code> do nó irá conter um novo recurso. O campo <code>status.allocatable</code>
é atualizado automaticamente pelo kubelet, de forma assíncrona, com o novo
recurso.</p><p>Como o escalonador utiliza o valor do campo <code>status.allocatable</code> do nó ao
verificar a saúde do Pod, o escalonador somente considerará o novo valor do
campo após esta atualização assíncrona. Pode haver um pequeno atraso entre a
atualização da capacidade do nó com um novo recurso e o momento em que o
primeiro Pod que requer o recurso poderá ser agendado naquele nó.</p><p><strong>Exemplo</strong>:</p><p>Este exemplo demonstra como utilizar a ferramenta <code>curl</code> para criar uma
requisição HTTP que anuncia cinco recursos "example.com/foo" no nó <code>k8s-node-1</code>,
cujo nó da camada de gerenciamento é <code>k8s-master</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl --header <span style=color:#b44>&#34;Content-Type: application/json-patch+json&#34;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --request PATCH <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --data <span style=color:#b44>&#39;[{&#34;op&#34;: &#34;add&#34;, &#34;path&#34;: &#34;/status/capacity/example.com~1foo&#34;, &#34;value&#34;: &#34;5&#34;}]&#39;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  http://k8s-master:8080/api/v1/nodes/k8s-node-1/status
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Na requisição anterior, a notação <code>~1</code> é a codificação do caractere <code>/</code> no campo
<code>path</code> para a operação de atualização. O valor do campo <code>path</code> em JSON-Patch é
interpretado como um JSON-Pointer. Para maiores detalhes, veja
<a href=https://tools.ietf.org/html/rfc6901#section-3>a seção 3 da IETF RFC 6901</a>.</div><h4 id=recursos-estendidos-a-nível-de-cluster>Recursos estendidos a nível de cluster</h4><p>Recursos estendidos a nível de cluster não são vinculados aos nós. Estes
recursos são normalmente gerenciados por extensões do escalonador, que manipulam
o consumo e as quotas de recursos.</p><p>Você pode especificar os recursos estendidos que são manipulados por extensões
do escalonador nas <a href=/docs/reference/config-api/kube-scheduler-config.v1beta3/>configurações do kube-scheduler</a>.</p><p><strong>Exemplo</strong>:</p><p>A configuração abaixo para uma política do escalonador indica que o recurso
estendido a nível de cluster "example.com/foo" é manipulado pelas extensões do
escalonador.</p><ul><li>O escalonador envia um Pod para a extensão do escalonador somente se o Pod
solicitar "example.com/foo".</li><li>O campo <code>ignoredByScheduler</code> especifica que o escalonador não verifica o
recurso "example.com/foo" em seu predicado <code>PodFitsResources</code>.</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;Policy&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;v1&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;extenders&#34;</span>: [
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;urlPrefix&#34;</span>:<span style=color:#b44>&#34;&lt;extender-endpoint&gt;&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;bindVerb&#34;</span>: <span style=color:#b44>&#34;bind&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;managedResources&#34;</span>: [
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>          <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;example.com/foo&#34;</span>,
</span></span><span style=display:flex><span>          <span style=color:green;font-weight:700>&#34;ignoredByScheduler&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>      ]
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  ]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=consumindo-recursos-estendidos>Consumindo recursos estendidos</h3><p>Usuários podem consumir recursos estendidos em especificações de Pods como CPU
e memória. O escalonador controla a contagem de recursos de modo que a
quantidade alocada simultaneamente a Pods não seja maior que a quantidade
disponível.</p><p>O servidor da API limita as quantidades de recursos estendidos a números inteiros.
Exemplos de quantidades <em>válidas</em> são <code>3</code>, <code>3000m</code> e <code>3Ki</code>. Exemplos de
quantidades <em>inválidas</em> são <code>0.5</code> e <code>1500m</code>.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Recursos estendidos substituem os Recursos Inteiros Opacos.
Usuários podem escolher qualquer prefixo de nome de domínio, com exceção do
domínio <code>kubernetes.io</code>, que é reservado.</div><p>Para consumir um recurso estendido em um Pod, inclua o nome do recurso como uma
chave no mapa <code>spec.containers[].resources.limits</code> na especificação do contêiner.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Recursos estendidos não podem ser superdimensionados. Portanto, <code>request</code> e
<code>limit</code> devem ser iguais se ambos estiverem presentes na especificação de um
contêiner.</div><p>Um Pod só é agendado se todos os seus requerimentos de recursos forem
satisfeitos, incluindo CPU, memória e quaisquer recursos estendidos. O Pod
permanece no estado <code>PENDING</code> enquanto seus requerimentos de recursos não puderem
ser satisfeitos.</p><p><strong>Exemplo</strong>:</p><p>O Pod abaixo requisita duas CPUs e um "example.com/foo" (um recurso estendido).</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>myimage<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>example.com/foo</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>example.com/foo</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=limitação-de-pid>Limitação de PID</h2><p>Limites de ID de processo (PID) permitem à configuração de um kubelet limitar o
número de PIDs que um dado Pod pode consumir. Consulte
<a href=/docs/concepts/policy/pid-limiting/>PID Limiting</a> para mais informações.</p><h2 id=troubleshooting>Solução de problemas</h2><h3 id=meus-pods-estão-pendentes-com-um-evento-failedscheduling>Meus pods estão pendentes com um evento <code>FailedScheduling</code></h3><p>Se o escalonador não conseguir encontrar nenhum nó que atenda aos requisitos de
recursos do Pod, este Pod permanecerá não-agendado até que um local destino
possa ser encontrado. Um <a href=/docs/reference/kubernetes-api/cluster-resources/event-v1/>Evento</a>
é produzido cada vez que o escalonador falhar em encontrar um local para agendar
o Pod. Você pode utilizar o utilitário <code>kubectl</code> para ver os eventos de um Pod.
Por exemplo:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe pod frontend | grep -A <span style=color:#666>9999999999</span> Events
</span></span></code></pre></div><pre tabindex=0><code>Events:
  Type     Reason            Age   From               Message
  ----     ------            ----  ----               -------
  Warning  FailedScheduling  23s   default-scheduler  0/42 nodes available: insufficient cpu
</code></pre><p>No exemplo acima, o Pod de nome "frontend" não pôde ser agendado devido à nenhum
nó possuir CPU suficiente para suprir seu requerimento de CPU. Mensagens de erro
semelhantes a essa podem sugerir falha devido a falta de memória
(<code>PodExceedsFreeMemory</code>). De maneira geral, se um Pod estiver pendente com uma
mensagem deste tipo, há diversas possibilidades de solução a serem tentadas:</p><ul><li>Adicione mais nós ao cluster.</li><li>Encerre Pods desnecessários para liberar espaço para Pods pendentes.</li><li>Verifique se o Pod não é maior que todos os nós. Por exemplo, se todos os nós
têm uma capacidade de <code>cpu: 1</code>, um Pod que requisita <code>cpu: 1.1</code> nunca será
agendado.</li><li>Verifique se os nós não possuem <em>taints</em>. Se a maioria dos seus nós possuem
<em>taints</em>, e o novo Pod não tolera tal <em>taint</em>, o escalonador somente considera
agendar o Pod nos nós que não possuem aquele <em>taint</em>.</li></ul><p>Você pode verificar capacidades de nós e quantidades alocadas com o comando
<code>kubectl describe nodes</code>. Por exemplo:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe nodes e2e-test-node-pool-4lw4
</span></span></code></pre></div><pre tabindex=0><code>Name:            e2e-test-node-pool-4lw4
[ ... linhas abreviadas para simplificação ...]
Capacity:
 cpu:                               2
 memory:                            7679792Ki
 pods:                              110
Allocatable:
 cpu:                               1800m
 memory:                            7474992Ki
 pods:                              110
[ ... linhas abreviadas para simplificação ...]
Non-terminated Pods:        (5 in total)
  Namespace    Name                                  CPU Requests  CPU Limits  Memory Requests  Memory Limits
  ---------    ----                                  ------------  ----------  ---------------  -------------
  kube-system  fluentd-gcp-v1.38-28bv1               100m (5%)     0 (0%)      200Mi (2%)       200Mi (2%)
  kube-system  kube-dns-3297075139-61lj3             260m (13%)    0 (0%)      100Mi (1%)       170Mi (2%)
  kube-system  kube-proxy-e2e-test-...               100m (5%)     0 (0%)      0 (0%)           0 (0%)
  kube-system  monitoring-influxdb-grafana-v4-z1m12  200m (10%)    200m (10%)  600Mi (8%)       600Mi (8%)
  kube-system  node-problem-detector-v0.1-fj7m3      20m (1%)      200m (10%)  20Mi (0%)        100Mi (1%)
Allocated resources:
  (Total limits may be over 100 percent, i.e., overcommitted.)
  CPU Requests    CPU Limits    Memory Requests    Memory Limits
  ------------    ----------    ---------------    -------------
  680m (34%)      400m (20%)    920Mi (11%)        1070Mi (13%)
</code></pre><p>No exemplo anterior, você pode verificar que se um Pod requisitar mais que 1,120
CPUs ou mais que 6,23Gi de memória, tal Pod não caberá neste nó.</p><p>Ao verificar a seção "Pods", você pode observar quais Pods estão consumindo
espaço neste nó.</p><p>A quantidade de recursos disponível aos Pods é menor que a capacidade do nó, pois
daemons do sistema utilizam uma parcela dos recursos disponíveis. Dentro da API
do Kubernetes, cada nó tem um campo <code>.status.allocatable</code>
(consulte <a href=/docs/reference/kubernetes-api/cluster-resources/node-v1/#NodeStatus>NodeStatus</a>
para mais detalhes).</p><p>O campo <code>.status.allocatable</code> descreve a quantidade de recursos que está
disponível a Pods naquele nó (por exemplo: 15 CPUs virtuais e 7538 MiB de
memória). Para mais informações sobre recursos alocáveis do nó no Kubernetes,
veja <a href=/docs/tasks/administer-cluster/reserve-compute-resources/>Reserve Compute Resources for System Daemons</a>.</p><p>Você pode configurar <a href=/docs/concepts/policy/resource-quotas/>quotas de recursos</a>
para limitar a quantidade total de recursos que um namespace pode consumir.
O Kubernetes garante quotas para objetos em um namespace específico quando há
uma <code>ResourceQuota</code> naquele namespace. Por exemplo, se você atribuir namespaces
específicos a times diferentes, você pode adicionar <code>ResourceQuota</code>s nestes
namespaces. Criar quotas de recursos ajuda a evitar que um time utilize tanto de
um recurso que chegue a afetar outros times utilizando o mesmo cluster.</p><p>Você deve também considerar o nível de acesso fornecido aos usuários de qualquer
namespace: acesso <strong>completo</strong> para escrita permite a alguém com este acesso
remover <strong>qualquer</strong> recurso, incluindo uma configuração de <code>ResourceQuota</code>.</p><h3 id=meu-contêiner-foi-terminado>Meu contêiner foi terminado</h3><p>Seu contêiner pode ser terminado se faltar recursos para que este rode. Para
verificar se um contêiner está sendo terminado por chegar no limite de algum
recurso, utilize o comando <code>kubectl describe pod</code> no Pod em questão:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe pod simmemleak-hra99
</span></span></code></pre></div><p>A saída será semelhante a:</p><pre tabindex=0><code>Name:                           simmemleak-hra99
Namespace:                      default
Image(s):                       saadali/simmemleak
Node:                           kubernetes-node-tf0f/10.240.216.66
Labels:                         name=simmemleak
Status:                         Running
Reason:
Message:
IP:                             10.244.2.75
Containers:
  simmemleak:
    Image:  saadali/simmemleak:latest
    Limits:
      cpu:          100m
      memory:       50Mi
    State:          Running
      Started:      Tue, 07 Jul 2019 12:54:41 -0700
    Last State:     Terminated
      Reason:       OOMKilled
      Exit Code:    137
      Started:      Fri, 07 Jul 2019 12:54:30 -0700
      Finished:     Fri, 07 Jul 2019 12:54:33 -0700
    Ready:          False
    Restart Count:  5
Conditions:
  Type      Status
  Ready     False
Events:
  Type    Reason     Age   From               Message
  ----    ------     ----  ----               -------
  Normal  Scheduled  42s   default-scheduler  Successfully assigned simmemleak-hra99 to kubernetes-node-tf0f
  Normal  Pulled     41s   kubelet            Container image &#34;saadali/simmemleak:latest&#34; already present on machine
  Normal  Created    41s   kubelet            Created container simmemleak
  Normal  Started    40s   kubelet            Started container simmemleak
  Normal  Killing    32s   kubelet            Killing container with id ead3fb35-5cf5-44ed-9ae1-488115be66c6: Need to kill Pod
</code></pre><p>No exemplo acima, o campo <code>Restart Count: 5</code> indica que o contêiner <code>simmemleak</code>
deste Pod foi terminado e reiniciado cinco vezes até o momento. A razão
<code>OOMKilled</code> demonstra que o contêiner tentou consumir mais memória do que o seu
limite.</p><p>O próximo passo neste cenário seria vasculhar e depurar o código da aplicação,
procurando por vazamentos de memória. Se você determinar que a aplicação está se
comportando conforme o esperado, considere aumentar o limite (e possivelmente
o requerimento) de memória para aquele contêiner.</p><h2 id=próximos-passos>Próximos passos</h2><ul><li>Pratique <a href=/docs/tasks/configure-pod-container/assign-memory-resource/>a criação de requerimentos de recursos de memória em contêineres e Pods</a>.</li><li>Pratique <a href=/docs/tasks/configure-pod-container/assign-cpu-resource/>a criação de requerimentos de CPU em contêineres and Pods</a>.</li><li>Leia como a referência da API define um <a href=/docs/reference/kubernetes-api/workload-resources/pod-v1/#Container>contêiner</a>
e seus <a href=/docs/reference/kubernetes-api/workload-resources/pod-v1/#resources>requerimentos de recursos</a>.</li><li>Leia sobre <a href=https://xfs.org/index.php/XFS_FAQ#Q:_Quota:_Do_quotas_work_on_XFS.3F>quotas de projeto</a> no XFS.</li><li>Leia mais sobre a <a href=/docs/reference/config-api/kube-scheduler-config.v1beta3/>referência de configuração do kube-scheduler (v1beta3)</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-ab6d20f33ad930a67ee7ef57bff6c75e>3.6.5 - Organizando o acesso ao cluster usando arquivos kubeconfig</h1><p>Utilize arquivos kubeconfig para organizar informações sobre clusters, usuários, namespaces e mecanismos de autenticação. A ferramenta de linha de comando <code>kubectl</code> faz uso dos arquivos kubeconfig para encontrar as informações necessárias para escolher e se comunicar com o serviço de API de um cluster.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Um arquivo que é utilizado para configurar o acesso aos clusters é chamado de <em>kubeconfig</em>. Esta á uma forma genérica de referenciamento para um arquivo de configuração desta natureza. Isso não significa que existe um arquivo com o nome <code>kubeconfig</code>.</div><p>Por padrão, o <code>kubectl</code> procura por um arquivo de nome <code>config</code> no diretório <code>$HOME/.kube</code></p><p>Você pode especificar outros arquivos kubeconfig através da variável de ambiente <code>KUBECONFIG</code> ou adicionando a opção <a href=/docs/reference/generated/kubectl/kubectl/><code>--kubeconfig</code></a>.</p><p>Para maiores detalhes na criação e especificação de um kubeconfig, veja o passo a passo em <a href=/docs/tasks/access-application-cluster/configure-access-multiple-clusters>Configurar Acesso para Múltiplos Clusters</a>.</p><h2 id=suportando-múltiplos-clusters-usuários-e-mecanismos-de-autenticação>Suportando múltiplos clusters, usuários e mecanismos de autenticação</h2><p>Imagine que você possua inúmeros clusters, e seus usuários e componentes se autenticam de várias formas. Por exemplo:</p><ul><li>Um kubelet ativo pode se autenticar utilizando certificados</li><li>Um usuário pode se autenticar através de tokens</li><li>Administradores podem possuir conjuntos de certificados os quais provém acesso aos usuários de forma individual.</li></ul><p>Através de arquivos kubeconfig, você pode organizar os seus clusters, usuários, e namespaces. Você também pode definir contextos para uma fácil troca entre clusters e namespaces.</p><h2 id=contexto>Contexto</h2><p>Um elemento de <em>contexto</em> em um kubeconfig é utilizado para agrupar parâmetros de acesso em um nome conveniente. Cada contexto possui três parâmetros: cluster, namespace, e usuário.</p><p>Por padrão, a ferramenta de linha de comando <code>kubectl</code> utiliza os parâmetros do <em>contexto atual</em> para se comunicar com o cluster.</p><p>Para escolher o contexto atual:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config use-context
</span></span></code></pre></div><h2 id=a-variável-de-ambiente-kubeconfig>A variável de ambiente KUBECONFIG</h2><p>A variável de ambiente <code>KUBECONFIG</code> possui uma lista dos arquivos kubeconfig. Para Linux e Mac, esta lista é delimitada por vírgula. No Windows, a lista é delimitada por ponto e vírgula. A variável de ambiente <code>KUBECONFIG</code> não é um requisito obrigatório - caso ela não exista o <code>kubectl</code> utilizará o arquivo kubeconfig padrão localizado no caminho <code>$HOME/.kube/config</code>.</p><p>Se a variável de ambiente <code>KUBECONFIG</code> existir, o <code>kubectl</code> utilizará uma configuração que é o resultado da combinação dos arquivos listados na variável de ambiente <code>KUBECONFIG</code>.</p><h2 id=combinando-arquivos-kubeconfig>Combinando arquivos kubeconfig</h2><p>Para inspecionar a sua configuração atual, execute o seguinte comando:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config view
</span></span></code></pre></div><p>Como descrito anteriormente, a saída poderá ser resultado de um único arquivo kubeconfig, ou poderá ser o resultado da junção de vários arquivos kubeconfig.</p><p>Aqui estão as regras que o <code>kubectl</code> utiliza quando realiza a combinação de arquivos kubeconfig:</p><ol><li><p>Se o argumento <code>--kubeconfig</code> está definido, apenas o arquivo especificado será utilizado. Apenas uma instância desta flag é permitida.</p><p>Caso contrário, se a variável de ambiente <code>KUBECONFIG</code> estiver definida, esta deverá ser utilizada como uma lista de arquivos a serem combinados, seguindo o fluxo a seguir:</p><ul><li>Ignorar arquivos vazios.</li><li>Produzir erros para aquivos cujo conteúdo não for possível desserializar.</li><li>O primeiro arquivo que definir um valor ou mapear uma chave determinada, será o escolhido.</li><li>Nunca modificar um valor ou mapear uma chave.
Exemplo: Preservar o contexto do primeiro arquivo que definir <code>current-context</code>.
Exemplo: Se dois arquivos especificarem um <code>red-user</code>, use apenas os valores do primeiro <code>red-user</code>. Mesmo se um segundo arquivo possuir entradas não conflitantes sobre a mesma entrada <code>red-user</code>, estas deverão ser descartadas.</li></ul><p>Para um exemplo de definição da variável de ambiente <code>KUBECONFIG</code> veja <a href=/docs/tasks/access-application-cluster/configure-access-multiple-clusters/#set-the-kubeconfig-environment-variable>Definido a variável de ambiente KUBECONFIG</a>.</p><p>Caso contrário, utilize o arquivo kubeconfig padrão encontrado no diretório <code>$HOME/.kube/config</code>, sem qualquer tipo de combinação.</p></li><li><p>Determine o contexto a ser utilizado baseado no primeiro padrão encontrado, nesta ordem:</p><ol><li>Usar o conteúdo da flag <code>--context</code> caso ela existir.</li><li>Usar o <code>current-context</code> a partir da combinação dos arquivos kubeconfig.</li></ol><p>Um contexto vazio é permitido neste momento.</p></li><li><p>Determinar o cluster e o usuário. Neste ponto, poderá ou não existir um contexto.
Determinar o cluster e o usuário no primeiro padrão encontrado de acordo com a ordem à seguir. Este procedimento deverá executado duas vezes: uma para definir o usuário a outra para definir o cluster.</p><ol><li>Utilizar a flag caso ela existir: <code>--user</code> ou <code>--cluster</code>.</li><li>Se o contexto não estiver vazio, utilizar o cluster ou usuário deste contexto.</li></ol><p>O usuário e o cluster poderão estar vazios neste ponto.</p></li><li><p>Determinar as informações do cluster atual a serem utilizadas. Neste ponto, poderá ou não existir informações de um cluster.</p><p>Construir cada peça de informação do cluster baseado nas opções à seguir; a primeira ocorrência encontrada será a opção vencedora:</p><ol><li>Usar as flags de linha de comando caso existirem: <code>--server</code>, <code>--certificate-authority</code>, <code>--insecure-skip-tls-verify</code>.</li><li>Se algum atributo do cluster existir a partir da combinação de kubeconfigs, estes deverão ser utilizados.</li><li>Se não existir informação de localização do servidor falhar.</li></ol></li><li><p>Determinar a informação atual de usuário a ser utilizada. Construir a informação de usuário utilizando as mesmas regras utilizadas para o caso de informações de cluster, exceto para a regra de técnica de autenticação que deverá ser única por usuário:</p><ol><li>Usar as flags, caso existirem: <code>--client-certificate</code>, <code>--client-key</code>, <code>--username</code>, <code>--password</code>, <code>--token</code>.</li><li>Usar os campos <code>user</code> resultado da combinação de arquivos kubeconfig.</li><li>Se existirem duas técnicas conflitantes, falhar.</li></ol></li><li><p>Para qualquer informação que ainda estiver ausente, utilizar os valores padrão e potencialmente solicitar informações de autenticação a partir do prompt de comando.</p></li></ol><h2 id=referências-de-arquivos>Referências de arquivos</h2><p>Arquivos e caminhos referenciados em um arquivo kubeconfig são relativos à localização do arquivo kubeconfig.</p><p>Referências de arquivos na linha de comando são relativas ao diretório de trabalho vigente.</p><p>No arquivo <code>$HOME/.kube/config</code>, caminhos relativos são armazenados de forma relativa, e caminhos absolutos são armazenados de forma absoluta.</p><h2 id=próximos-passos>Próximos passos</h2><ul><li><a href=/docs/tasks/access-application-cluster/configure-access-multiple-clusters/>Configurar Accesso para Multiplos Clusters</a></li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#config><code>kubectl config</code></a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-712cb3c03ff14a39e5a83a6d9b71d203>3.7 - Segurança</h1></div><div class=td-content><h1 id=pg-04eeb110d75afc8acb2cf7a3db743985>3.7.1 - Visão Geral da Segurança Cloud Native</h1><p>Esta visão geral define um modelo para pensar sobre a segurança em Kubernetes no contexto da Segurança em Cloud Native.</p><div class="alert alert-danger warning callout" role=alert><strong>Aviso:</strong> Este modelo de segurança no contêiner fornece sugestões, não prova políticas de segurança da informação.</div><h2 id=os-4c-da-segurança-cloud-native>Os 4C da Segurança Cloud Native</h2><p>Você pode pensar na segurança em camadas. Os 4C da segurança Cloud Native são a Cloud,
Clusters, Contêineres e Código.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Esta abordagem em camadas aumenta a <a href=https://en.wikipedia.org/wiki/Defense_in_depth_(computing)>defesa em profundidade</a>
para segurança, que é amplamente considerada como uma boa prática de segurança para software de sistemas.</div><figure><img src=/images/docs/4c.png><figcaption><h4>Os 4C da Segurança Cloud Native</h4></figcaption></figure><p>Cada camada do modelo de segurança Cloud Native é construída sobre a próxima camada mais externa.
A camada de código se beneficia de uma base forte (Cloud, Cluster, Contêiner) de camadas seguras.
Você não pode proteger contra padrões ruins de segurança nas camadas de base através de
segurança no nível do Código.</p><h2 id=cloud>Cloud</h2><p>De muitas maneiras, a Cloud (ou servidores co-localizados, ou o datacenter corporativo) é a
<a href=https://en.wikipedia.org/wiki/Trusted_computing_base>base de computação confiável</a>
de um cluster Kubernetes. Se a camada de Cloud é vulnerável (ou
configurado de alguma maneira vulnerável), então não há garantia de que os componentes construídos
em cima desta base estejam seguros. Cada provedor de Cloud faz recomendações de segurança
para executar as cargas de trabalho com segurança nos ambientes.</p><h3 id=segurança-no-provedor-da-cloud>Segurança no provedor da Cloud</h3><p>Se você estiver executando um cluster Kubernetes em seu próprio hardware ou em um provedor de nuvem diferente,
consulte sua documentação para melhores práticas de segurança.
Aqui estão os links para as documentações de segurança dos provedores mais populares de nuvem:</p><table><caption style=display:none>Cloud provider security</caption><thead><tr><th>Provedor IaaS</th><th>Link</th></tr></thead><tbody><tr><td>Alibaba Cloud</td><td><a href=https://www.alibabacloud.com/trust-center>https://www.alibabacloud.com/trust-center</a></td></tr><tr><td>Amazon Web Services</td><td><a href=https://aws.amazon.com/security/>https://aws.amazon.com/security/</a></td></tr><tr><td>Google Cloud Platform</td><td><a href=https://cloud.google.com/security/>https://cloud.google.com/security/</a></td></tr><tr><td>IBM Cloud</td><td><a href=https://www.ibm.com/cloud/security>https://www.ibm.com/cloud/security</a></td></tr><tr><td>Microsoft Azure</td><td><a href=https://docs.microsoft.com/en-us/azure/security/azure-security>https://docs.microsoft.com/en-us/azure/security/azure-security</a></td></tr><tr><td>Oracle Cloud Infrastructure</td><td><a href=https://www.oracle.com/security/>https://www.oracle.com/security/</a></td></tr><tr><td>VMWare VSphere</td><td><a href=https://www.vmware.com/security/hardening-guides.html>https://www.vmware.com/security/hardening-guides.html</a></td></tr></tbody></table><h3 id=infrastructure-security>Segurança de Infraestrutura</h3><p>Sugestões para proteger sua infraestrutura em um cluster Kubernetes:</p><table><caption style=display:none>Infrastructure security</caption><thead><tr><th>Área de Interesse para Infraestrutura Kubernetes</th><th>Recomendação</th></tr></thead><tbody><tr><td>Acesso de rede ao servidor API (Control plane)</td><td>Todo o acesso ao control plane do Kubernetes publicamente na Internet não é permitido e é controlado por listas de controle de acesso à rede restritas ao conjunto de endereços IP necessários para administrar o cluster.</td></tr><tr><td>Acesso de rede aos Nós (nodes)</td><td>Os nós devem ser configurados para <em>só</em> aceitar conexões (por meio de listas de controle de acesso à rede) do control plane nas portas especificadas e aceitar conexões para serviços no Kubernetes do tipo NodePort e LoadBalancer. Se possível, esses nós não devem ser expostos inteiramente na Internet pública.</td></tr><tr><td>Acesso do Kubernetes à API do provedor de Cloud</td><td>Cada provedor de nuvem precisa conceder um conjunto diferente de permissões para o control plane e nós do Kubernetes. É melhor fornecer ao cluster permissão de acesso ao provedor de nuvem que segue o <a href=https://en.wikipedia.org/wiki/Principle_of_least_privilege>princípio do menor privilégio</a> para os recursos que ele precisa administrar. A <a href=https://github.com/kubernetes/kops/blob/master/docs/iam_roles.md#iam-roles>documentação do Kops</a> fornece informações sobre as políticas e roles do IAM.</td></tr><tr><td>Acesso ao etcd</td><td>O acesso ao etcd (o armazenamento de dados do Kubernetes) deve ser limitado apenas ao control plane. Dependendo de sua configuração, você deve tentar usar etcd sobre TLS. Mais informações podem ser encontradas na <a href=https://github.com/etcd-io/etcd/tree/master/Documentation>documentação do etcd</a>.</td></tr><tr><td>Encriptação etcd</td><td>Sempre que possível, é uma boa prática encriptar todas as unidades de armazenamento, mas como o etcd mantém o estado de todo o cluster (incluindo os Secrets), seu disco deve ser criptografado.</td></tr></tbody></table><h2 id=cluster>Cluster</h2><p>Existem duas áreas de preocupação para proteger o Kubernetes:</p><ul><li>Protegendo os componentes do cluster que são configuráveis.</li><li>Protegendo as aplicações que correm no cluster.</li></ul><h3 id=cluster-components>Componentes do Cluster</h3><p>Se você deseja proteger seu cluster de acesso acidental ou malicioso e adotar
boas práticas de informação, leia e siga os conselhos sobre
<a href=/docs/tasks/administer-cluster/securing-a-cluster/>protegendo seu cluster</a>.</p><h3 id=cluster-applications>Componentes no cluster (sua aplicação)</h3><p>Dependendo da superfície de ataque de sua aplicação, você pode querer se concentrar em
tópicos específicos de segurança. Por exemplo: se você estiver executando um serviço (Serviço A) que é crítico
numa cadeia de outros recursos e outra carga de trabalho separada (Serviço B) que é
vulnerável a um ataque de exaustão de recursos e, por consequência, o risco de comprometer o Serviço A
é alto se você não limitar os recursos do Serviço B. A tabela a seguir lista
áreas de atenção na segurança e recomendações para proteger cargas de trabalho em execução no Kubernetes:</p><table><thead><tr><th>Área de interesse para a segurança do Workload</th><th>Recomendação</th></tr></thead><tbody><tr><td>Autorização RBAC (acesso à API Kubernetes)</td><td><a href=https://kubernetes.io/docs/reference/access-authn-authz/rbac/>https://kubernetes.io/docs/reference/access-authn-authz/rbac/</a></td></tr><tr><td>Autenticação</td><td><a href=https://kubernetes.io/docs/concepts/security/controlling-access/>https://kubernetes.io/docs/concepts/security/controlling-access/</a></td></tr><tr><td>Gerenciamento de segredos na aplicação (e encriptando-os no etcd em repouso)</td><td><a href=https://kubernetes.io/docs/concepts/configuration/secret/>https://kubernetes.io/docs/concepts/configuration/secret/</a><br><a href=https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/>https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/</a></td></tr><tr><td>Garantir que os Pods atendem aos padrões de segurança do Pod</td><td><a href=https://kubernetes.io/docs/concepts/security/pod-security-standards/#policy-instantiation>https://kubernetes.io/docs/concepts/security/pod-security-standards/#policy-instantiation</a></td></tr><tr><td>Qualidade de serviço (e gerenciamento de recursos de cluster)</td><td><a href=https://kubernetes.io/docs/tasks/configure-pod-container/quality-service-pod/>https://kubernetes.io/docs/tasks/configure-pod-container/quality-service-pod/</a></td></tr><tr><td>Políticas de Rede</td><td><a href=https://kubernetes.io/docs/concepts/services-networking/network-policies/>https://kubernetes.io/docs/concepts/services-networking/network-policies/</a></td></tr><tr><td>TLS para Kubernetes Ingress</td><td><a href=https://kubernetes.io/docs/concepts/services-networking/ingress/#tls>https://kubernetes.io/docs/concepts/services-networking/ingress/#tls</a></td></tr></tbody></table><h2 id=contêiner>Contêiner</h2><p>A segurança do contêiner está fora do escopo deste guia. Aqui estão recomendações gerais e
links para explorar este tópico:</p><table><thead><tr><th>Área de Interesse para Contêineres</th><th>Recomendação</th></tr></thead><tbody><tr><td>Scanners de Vulnerabilidade de Contêiner e Segurança de Dependência de SO</td><td>Como parte da etapa de construção de imagem, você deve usar algum scanner em seus contêineres em busca de vulnerabilidades.</td></tr><tr><td>Assinatura Imagem e Enforcement</td><td>Assinatura de imagens de contêineres para manter um sistema de confiança para o conteúdo de seus contêineres.</td></tr><tr><td>Proibir Usuários Privilegiados</td><td>Ao construir contêineres, consulte a documentação para criar usuários dentro dos contêineres que tenham o menor nível de privilégio no sistema operacional necessário para cumprir o objetivo do contêiner.</td></tr><tr><td>Use o Contêiner em Runtime com Isolamento mais Forte</td><td>Selecione <a href=/docs/concepts/containers/runtime-class/>classes de contêiner runtime</a> com o provedor de isolamento mais forte.</td></tr></tbody></table><h2 id=código>Código</h2><p>O código da aplicação é uma das principais superfícies de ataque sobre a qual você tem maior controle.
Embora a proteção do código do aplicativo esteja fora do tópico de segurança do Kubernetes, aqui
são recomendações para proteger o código do aplicativo:</p><h3 id=segurança-de-código>Segurança de código</h3><table><caption style=display:none>Code security</caption><thead><tr><th>Área de Atenção para o Código</th><th>Recomendação</th></tr></thead><tbody><tr><td>Acesso só através de TLS</td><td>Se seu código precisar se comunicar por TCP, execute um handshake TLS com o cliente antecipadamente. Com exceção de alguns casos, encripte tudo em trânsito. Indo um passo adiante, é uma boa ideia encriptar o tráfego de rede entre os serviços. Isso pode ser feito por meio de um processo conhecido como mutual ou <a href=https://en.wikipedia.org/wiki/Mutual_authentication>mTLS</a>, que realiza uma verificação bilateral da comunicação mediante os certificados nos serviços.</td></tr><tr><td>Limitando intervalos de porta de comunicação</td><td>Essa recomendação pode ser um pouco autoexplicativa, mas, sempre que possível, você só deve expor as portas em seu serviço que são absolutamente essenciais para a comunicação ou coleta de métricas.</td></tr><tr><td>Segurança na Dependência de Terceiros</td><td>É uma boa prática verificar regularmente as bibliotecas de terceiros de sua aplicação em busca de vulnerabilidades de segurança. Cada linguagem de programação possui uma ferramenta para realizar essa verificação automaticamente.</td></tr><tr><td>Análise de Código Estático</td><td>A maioria das linguagens fornece uma maneira para analisar um extrato do código referente a quaisquer práticas de codificação potencialmente inseguras. Sempre que possível, você deve automatizar verificações usando ferramentas que podem verificar as bases de código em busca de erros de segurança comuns. Algumas das ferramentas podem ser encontradas em <a href=https://owasp.org/www-community/Source_Code_Analysis_Tools>OWASP Source Code Analysis Tools</a>.</td></tr><tr><td>Ataques de sondagem dinâmica</td><td>Existem algumas ferramentas automatizadas que você pode executar contra seu serviço para tentar alguns dos ataques mais conhecidos. Isso inclui injeção de SQL, CSRF e XSS. Uma das ferramentas de análise dinâmica mais populares é o <a href=https://owasp.org/www-project-zap/>OWASP Zed Attack proxy</a>.</td></tr></tbody></table><h2 id=próximos-passos>Próximos passos</h2><p>Saiba mais sobre os tópicos de segurança do Kubernetes:</p><ul><li><a href=/docs/concepts/security/pod-security-standards/>Padrões de segurança do Pod</a></li><li><a href=/docs/concepts/services-networking/network-policies/>Políticas de rede para Pods</a></li><li><a href=/docs/concepts/security/controlling-access>Controle de acesso à API Kubernetes</a></li><li><a href=/docs/tasks/administer-cluster/securing-a-cluster/>Protegendo seu cluster</a></li><li><a href=/docs/tasks/tls/managing-tls-in-a-cluster/>Criptografia de dados em trânsito</a> for the control plane</li><li><a href=/docs/tasks/administer-cluster/encrypt-data/>Criptografia de dados em repouso</a></li><li><a href=/docs/concepts/configuration/secret/>Secrets no Kubernetes</a></li><li><a href=/docs/concepts/containers/runtime-class>Runtime class</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-4d77d1ae4c06aa14f54b385191627881>3.7.2 - Controlando Acesso à API do Kubernetes</h1><p>Esta página fornece uma visão geral do controle de acesso à API do Kubernetes.</p><p>Usuários podem acessar a <a href=/docs/concepts/overview/kubernetes-api/>API do Kubernetes</a> utilizando <code>kubectl</code>,
bibliotecas, ou executando requisições REST. Ambos, usuários humanos e
<a href=/docs/tasks/configure-pod-container/configure-service-account/>Contas de serviço do Kubernetes</a> podem ser autorizados
a acessar à API.
Quando uma requisição chega à API, ela passa por diversos estágios,
ilustrados no seguinte diagrama:</p><p><img src=/images/docs/admin/access-control-overview.svg alt="Diagrama de etapas de tratamento de requisições enviadas a API do Kubernetes"></p><h2 id=segurança-na-camada-de-transporte>Segurança na camada de transporte</h2><p>Em um cluster Kubernetes típico, a API fica disponível na porta 443, protegida por segurança na camada de transporte (TLS).
O servidor de API apresenta um certificado. Este certificado pode ser assinado utilizando
uma autoridade privada de certificados (CA), ou baseado em uma infraestrutura de chave pública ligada
a uma autoridade de certificados reconhecida publicamente.</p><p>Se o seu cluster utiliza uma autoridade privada de certificados, voce precisa de uma cópia do certificado
da autoridade de certificados (CA) dentro do arquivo de configuração <code>~/.kube/config</code>, no lado do cliente, para que
voce possa confiar na conexão e tenha a garantia de que não há interceptação de tráfego.</p><p>O seu cliente pode apresentar o certificado de cliente TLS neste estágio.</p><h2 id=autenticação>Autenticação</h2><p>Uma vez em que a segurança na camada de transporte (TLS) é estabelecida, a requisição HTTP move para o passo de autenticação.
Isto é demonstrado no passo <strong>1</strong> no diagrama acima.
O script de criação do cluster ou configurações de administração configuram o servidor de API para executar
um ou mais módulos autenticadores.</p><p>Autenticadores são descritos em maiores detalhes em
<a href=/pt-br/docs/reference/access-authn-authz/authentication/>Autenticação</a>.</p><p>A entrada para o passo de autenticação é a requisição HTTP completa; no entanto, tipicamente
são verificados os cabeçalhos e/ou o certificado de cliente.</p><p>Módulos de autenticação incluem certificados de cliente, senhas, tokens simples,
tokens de auto-inicialização e JSON Web Tokens (utilizados para contas de serviço).</p><p>Vários módulos de autenticação podem ser especificados, em que cada um será verificado em sequência,
até que um deles tenha sucesso.</p><p>Se a requisição não pode ser autenticada, será rejeitada com o código de status HTTP 401 (não autorizado).
Caso contrário, o usuário é autenticado com um "nome de usuário" específico e o nome de usuário
está disponível para as etapas subsequentes para usar em suas decisões. Alguns autenticadores
também fornecem as associações de grupo do usuário, enquanto outros autenticadores
não o fazem.</p><p>Enquanto o Kubernetes usa nomes de usuário para decisões de controle de acesso e no registro de requisições,
ele não possui um objeto <code>user</code> nem armazena nomes de usuários ou outras informações sobre
usuários em sua API.</p><h2 id=autorização>Autorização</h2><p>Após a requisição ser autenticada como originada de um usuário específico, a requisição deve ser autorizada. Isso é mostrado no passo <strong>2</strong> no diagrama.</p><p>Uma requisição deve incluir o nome do usuário requerente, a ação requisitada e o objeto afetado pela ação. A requisição é autorizada se uma
política existente declarar que o usuário tem as devidas permissões para concluir a ação requisitada.</p><p>Por exemplo, se Bob possui a política abaixo, então ele somente poderá ler pods no namespace <code>projectCaribou</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;abac.authorization.kubernetes.io/v1beta1&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;Policy&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;spec&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;user&#34;</span>: <span style=color:#b44>&#34;bob&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;namespace&#34;</span>: <span style=color:#b44>&#34;projectCaribou&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;resource&#34;</span>: <span style=color:#b44>&#34;pods&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;readonly&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Se Bob fizer a seguinte requisição, a requisição será autorizada porque ele tem permissão para ler objetos no namespace <code>projectCaribou</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;authorization.k8s.io/v1beta1&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;SubjectAccessReview&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;spec&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;resourceAttributes&#34;</span>: {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;namespace&#34;</span>: <span style=color:#b44>&#34;projectCaribou&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;verb&#34;</span>: <span style=color:#b44>&#34;get&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;group&#34;</span>: <span style=color:#b44>&#34;unicorn.example.org&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;resource&#34;</span>: <span style=color:#b44>&#34;pods&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Se Bob fizer uma requisição para escrever (<code>create</code> ou <code>update</code>) em objetos no namespace <code>projectCaribou</code>, sua autorização será negada. Se Bob fizer uma requisição para ler (<code>get</code>) objetos em um namespace diferente, como <code>projectFish</code>, sua autorização será negada.</p><p>A autorização do Kubernetes requer que você use atributos comuns a REST para interagir com os sistemas de controle de acesso existentes em toda uma organização ou em todo o provedor de nuvem utilizado. É importante usar a formatação REST porque esses sistemas de controle podem interagir com outras APIs além da API do Kubernetes.</p><p>O Kubernetes oferece suporte a vários módulos de autorização, como o modo de controle de acesso baseado em atributos (ABAC), o modo de controle de acesso baseado em função (RBAC) e o modo Webhook. Quando um administrador cria um cluster, ele configura os módulos de autorização que devem ser utilizados no servidor de API. Se mais de um módulo de autorização for configurado, o Kubernetes verificará cada módulo e, se algum módulo autorizar a requisição, a requisição poderá prosseguir. Se todos os módulos negarem a requisição, a requisição será negada (com código de status HTTP 403 - Acesso Proibido).</p><p>Para saber mais sobre a autorização do Kubernetes, incluindo detalhes sobre como criar políticas usando os módulos de autorização compatíveis, consulte <a href=/pt-br/docs/reference/access-authn-authz/authorization/>Visão Geral de Autorização</a>.</p><h2 id=controle-de-admissão>Controle de admissão</h2><p>Os módulos de controle de admissão são módulos de software que podem modificar ou rejeitar requisições.
Além dos atributos disponíveis para os módulos de Autorização, os módulos do controlador de admissão
podem acessar o conteúdo do objeto que está sendo criado ou modificado.</p><p>Os controladores de admissão atuam em requisições que criam, modificam, excluem ou age como um proxy para outro objeto.
Os controladores de admissão não agem em requisições que apenas leem objetos.
Quando vários controladores de admissão são configurados, eles são chamados em ordem.</p><p>Isso é mostrado como etapa <strong>3</strong> no diagrama.</p><p>Ao contrário dos módulos de autenticação e autorização, se algum módulo controlador de admissão
rejeita, a solicitação é imediatamente rejeitada.</p><p>Além de rejeitar objetos, os controladores de admissão também podem definir valores padrão complexos para
campos.</p><p>Os módulos de Controle de Admissão disponíveis são descritos em <a href=/docs/reference/access-authn-authz/admission-controllers/>Using Admission Controllers</a>.</p><p>Após uma requisição passar por todos os controladores de admissão, ela é validada usando as rotinas de validação
para o objeto de API correspondente e, em seguida, gravados no armazenamento de objetos (mostrado como etapa <strong>4</strong> no diagrama).</p><h2 id=auditoria>Auditoria</h2><p>A auditoria do Kubernetes fornece um conjunto de registros cronológicos relevantes para a segurança que documentam a sequência de ações em um cluster.
O cluster audita as atividades geradas pelos usuários, pelos aplicativos que usam a API do Kubernetes e pela própria camada de gerenciamento.</p><p>Para mais informações, consulte <a href=/docs/tasks/debug/debug-cluster/audit/>Auditing</a>.</p><h2 id=portas-e-ips-do-servidor-de-api>Portas e IPs do servidor de API</h2><p>A discussão anterior se aplica a requisições enviadas para a porta segura do servidor de API
(o caso típico). O servidor de API pode realmente servir em 2 portas.</p><p>Por padrão, o servidor da API Kubernetes atende HTTP em 2 portas:</p><ol><li><p>Porta <code>localhost</code>:</p><ul><li>destina-se a testes e auto-inicialização e a outros componentes do nó mestre
(scheduler, controller-manager) para falar com a API</li><li>sem segurança na camada de transporte (TLS)</li><li>o padrão é a porta 8080</li><li>IP padrão é localhost, mude com a flag <code>--insecure-bind-address</code>.</li><li>a requisição <strong>ignora</strong> os módulos de autenticação e autorização .</li><li>requisição tratada pelo(s) módulo(s) de controle de admissão.</li><li>protegido pela necessidade de ter acesso ao host</li></ul></li><li><p>“Porta segura”:</p><ul><li>utilize sempre que possível</li><li>utiliza segurança na camada de transporte (TLS). Defina o certificado com <code>--tls-cert-file</code> e a chave com a flag <code>--tls-private-key-file</code>.</li><li>o padrão é a porta 6443, mude com a flag <code>--secure-port</code>.</li><li>IP padrão é a primeira interface de rede não localhost, mude com a flag <code>--bind-address</code>.</li><li>requisição tratada pelos módulos de autenticação e autorização.</li><li>requisição tratada pelo(s) módulo(s) de controle de admissão.</li><li>módulos de autenticação e autorização executados.</li></ul></li></ol><h2 id=próximos-passos>Próximos passos</h2><p>Consulte mais documentação sobre autenticação, autorização e controle de acesso à API:</p><ul><li><a href=/pt-br/docs/reference/access-authn-authz/authentication/>Autenticação</a><ul><li><a href=/pt-br/docs/reference/access-authn-authz/bootstrap-tokens/>Autenticando com Tokens de Inicialização</a></li></ul></li><li><a href=/docs/reference/access-authn-authz/admission-controllers/>Using Admission Controllers</a><ul><li><a href=/docs/reference/access-authn-authz/extensible-admission-controllers/>Dynamic Admission Control</a></li></ul></li><li><a href=/pt-br/docs/reference/access-authn-authz/authorization/>Autorização</a><ul><li><a href=/docs/reference/access-authn-authz/rbac/>Using RBAC Authorization</a></li><li><a href=/docs/reference/access-authn-authz/abac/>Using ABAC Authorization</a></li><li><a href=/docs/reference/access-authn-authz/node/>Using Node Authorization</a></li><li><a href=/docs/reference/access-authn-authz/webhook/>Webhook Mode</a></li></ul></li><li><a href=/docs/reference/access-authn-authz/certificate-signing-requests/>Certificate Signing Requests</a><ul><li>incluindo <a href=/docs/reference/access-authn-authz/certificate-signing-requests/#approval-rejection>Approval or rejection of Certificate Signing Requests</a>
e <a href=/docs/reference/access-authn-authz/certificate-signing-requests/#signing>Signing certificates</a></li></ul></li><li>Contas de serviço<ul><li><a href=/docs/tasks/configure-pod-container/configure-service-account/>Configure Service Accounts for Pods</a></li><li><a href=/docs/reference/access-authn-authz/service-accounts-admin/>Managing Service Accounts</a></li></ul></li></ul><p>Você pode aprender mais sobre:</p><ul><li>como os pods podem usar <a href=/docs/concepts/configuration/secret/>Secrets</a> para obter credenciais de API.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-c21d05f31057c5bcd2ebdd01f4e62a0e>3.8 - Escalonamento</h1><div class=lead>No Kubernetes, agendamento refere-se a garantia de que os pods correspondam aos nós para que o kubelet possa executá-los. Remoção é o processo de falha proativa de um ou mais pods em nós com falta de recursos.</div></div><div class=td-content><h1 id=pg-ede4960b56a3529ee0bfe7c8fe2d09a5>3.8.1 - Taints e Tolerâncias</h1><p><a href=/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity><em>Afinidade de nó</em></a>
é uma propriedade dos <a class=glossary-tooltip title='O menor e mais simples objeto Kubernetes. Um Pod representa um conjunto de contêineres em execução no seu cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/ target=_blank aria-label=Pods>Pods</a> que os <em>associa</em> a um conjunto de <a class=glossary-tooltip title='Um Nó é uma máquina de trabalho no Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/nodes/ target=_blank aria-label=nós>nós</a> (seja como uma preferência ou uma exigência). <em>Taints</em> são o oposto -- eles permitem que um nó repudie um conjunto de pods.</p><p><em>Tolerâncias</em> são aplicadas em pods e permitem, mas não exigem, que os pods sejam alocados em nós com <em>taints</em> correspondentes.</p><p>Taints e tolerâncias trabalham juntos para garantir que pods não sejam alocados em nós inapropriados. Um ou mais taints são aplicados em um nó; isso define que o nó não deve aceitar nenhum pod que não tolera essas taints.</p><h2 id=conceitos>Conceitos</h2><p>Você adiciona um taint a um nó utilizando <a href=/docs/reference/generated/kubectl/kubectl-commands#taint>kubectl taint</a>.
Por exemplo,</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl taint nodes node1 <span style=color:#b8860b>key1</span><span style=color:#666>=</span>value1:NoSchedule
</span></span></code></pre></div><p>define um taint no nó <code>node1</code>. O taint tem a chave <code>key1</code>, valor <code>value1</code> e o efeito <code>NoSchedule</code>.
Isso significa que nenhum pod conseguirá ser executado no nó <code>node1</code> a menos que possua uma tolerância correspondente.</p><p>Para remover o taint adicionado pelo comando acima, você pode executar:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl taint nodes node1 <span style=color:#b8860b>key1</span><span style=color:#666>=</span>value1:NoSchedule-
</span></span></code></pre></div><p>Você especifica uma tolerância para um pod na <a href=/docs/reference/kubernetes-api/workload-resources/pod-v1#PodSpec>especificação do Pod</a>. Ambas as seguintes tolerâncias "correspondem" ao taint criado pelo <code>kubectl taint</code> acima, e assim um pod com qualquer uma delas poderia ser executado no <code>node1</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>tolerations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;key1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Equal&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;value1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;NoSchedule&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>tolerations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;key1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Exists&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;NoSchedule&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Aqui está um exemplo de um pod que utiliza tolerâncias:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/pt-br/examples/pods/pod-with-toleration.yaml download=pods/pod-with-toleration.yaml><code>pods/pod-with-toleration.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-pod-with-toleration-yaml")' title="Copy pods/pod-with-toleration.yaml to clipboard"></img></div><div class=includecode id=pods-pod-with-toleration-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb> </span>test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>IfNotPresent<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>tolerations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;example-key&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Exists&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;NoSchedule&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>O valor padrão de <code>operator</code> é <code>Equal</code>.</p><p>Uma tolerância "casa" um taint se as chaves e efeitos são os mesmos, e:</p><ul><li>o valor de <code>operator</code> é <code>Exists</code> (no caso nenhum <code>value</code> deve ser especificado), ou</li><li>o valor de <code>operator</code> é <code>Equal</code> e os valores de <code>value</code> são iguais.</li></ul><div class="alert alert-info note callout" role=alert><strong>Nota:</strong><p>Existem dois casos especiais:</p><p>Uma <code>key</code> vazia com o operador <code>Exists</code> "casa" todas as chaves, valores e efeitos, o que significa que o pod irá tolerar tudo.</p><p>Um <code>effect</code> vazio "casa" todos os efeitos com a chave <code>key1</code>.</p></div><p>O exemplo acima usou <code>effect</code> de <code>NoSchedule</code>. De forma alternativa, você pode usar <code>effect</code> de <code>PreferNoSchedule</code>.
Nesse efeito, o sistema <em>tentará</em> evitar que o pod seja alocado ao nó caso ele não tolere os taints definidos, contudo a alocação não será evitada de forma obrigatória. Pode-se dizer que o <code>PreferNoSchedule</code> é uma versão permissiva do <code>NoSchedule</code>. O terceiro tipo de <code>effect</code> é o <code>NoExecute</code> que será descrito posteriormente.</p><p>Você pode colocar múltiplos taints no mesmo nó e múltiplas tolerâncias no mesmo pod.
O jeito que o Kubernetes processa múltiplos taints e tolerâncias é como um filtro: começa com todos os taints de um nó, em seguida ignora aqueles para os quais o pod tem uma tolerância relacionada; os taints restantes que não foram ignorados indicam o efeito no pod. Mais especificamente,</p><ul><li>se existe pelo menos um taint não tolerado com o efeito <code>NoSchedule</code>, o Kubernetes não alocará o pod naquele nó</li><li>se existe um taint não tolerado com o efeito <code>NoSchedule</code>, mas existe pelo menos um taint não tolerado com o efeito <code>PreferNoSchedule</code>, o Kubernetes <em>tentará</em> não alocar o pod no nó</li><li>se existe pelo menos um taint não tolerado com o efeito <code>NoExecute</code>, o pod será expulso do nó (caso já esteja em execução) e não será alocado ao nó (caso ainda não esteja em execução).</li></ul><p>Por exemplo, imagine que você tem um nó com os seguintes taints</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl taint nodes node1 <span style=color:#b8860b>key1</span><span style=color:#666>=</span>value1:NoSchedule
</span></span><span style=display:flex><span>kubectl taint nodes node1 <span style=color:#b8860b>key1</span><span style=color:#666>=</span>value1:NoExecute
</span></span><span style=display:flex><span>kubectl taint nodes node1 <span style=color:#b8860b>key2</span><span style=color:#666>=</span>value2:NoSchedule
</span></span></code></pre></div><p>E um pod com duas tolerâncias:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>tolerations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;key1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Equal&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;value1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;NoSchedule&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;key1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Equal&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;value1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;NoExecute&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Nesse caso, o pod não será alocado ao nó porque não possui uma tolerância para o terceiro taint. Porém, se ele já estiver rodando no nó quando o taint foi adicionado, não será afetado e continuará rodando, tendo em vista que o terceiro taint é o único não tolerado pelo pod.</p><p>Normalmente, se um taint com o efeito <code>NoExecute</code> é adicionado a um nó, qualquer pod que não o tolere será expulso imediatamente e pods que o toleram nunca serão expulsos. Contudo, uma tolerância com efeito <code>NoExecute</code> pode especificar de forma opcional o campo <code>tolerationSeconds</code>, que determina quanto tempo o pod continuará alocado ao nó depois que o taint é adicionado. Por exemplo,</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>tolerations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;key1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Equal&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;value1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;NoExecute&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>tolerationSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>3600</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>significa que se esse pod está sendo executado e um taint correspondente é adicionado ao nó, o pod irá continuar rodando neste nó por 3600 segundos e depois será expulso. Se o taint for removido antes desse tempo acabar, o pod não será expulso.</p><h2 id=exemplos-de-casos-de-uso>Exemplos de Casos de Uso</h2><p>Taints e tolerâncias são um modo flexível de conduzir pods para <em>fora</em> dos nós ou expulsar pods que não deveriam estar sendo executados. Alguns casos de uso são</p><ul><li><p><strong>Nós Dedicados</strong>: Se você quiser dedicar um conjunto de nós para uso exclusivo de um conjunto específico de usuários, poderá adicionar um taint nesses nós. (digamos, <code>kubectl taint nodes nodename dedicated=groupName:NoSchedule</code>) e em seguida adicionar uma tolerância correspondente para seus pods (isso seria feito mais facilmente com a escrita de um <a href=/docs/reference/access-authn-authz/admission-controllers/>controlador de admissão</a> customizado).
Os pods com tolerância terão sua execução permitida nos nós com taints (dedicados), assim como em qualquer outro nó no cluster. Se você quiser dedicar nós a esses pods <em>e garantir</em> que eles usem <em>apenas</em> os nós dedicados, precisará adicionar uma label similar ao taint para o mesmo conjunto de nós (por exemplo, <code>dedicated=groupName</code>), e o controle de admissão deverá adicionar uma afinidade de nó para exigir que os pods podem ser executados apenas nos nós definidos com a label <code>dedicated=groupName</code>.</p></li><li><p><strong>Nós com hardware especial</strong>: Em um cluster no qual um pequeno grupo de nós possui hardware especializado (por exemplo, GPUs), é desejável manter pods que não necessitem desse tipo de hardware fora desses nós, dessa forma o recurso estará disponível para pods que precisem do hardware especializado. Isso pode ser feito aplicando taints nos nós com o hardware especializado (por exemplo, <code>kubectl taint nodes nodename special=true:NoSchedule</code> or <code>kubectl taint nodes nodename special=true:PreferNoSchedule</code>) e aplicando uma tolerância correspondente nos pods que usam o hardware especial. Assim como no caso de uso de nós dedicados, é provavelmente mais fácil aplicar as tolerâncias utilizando um <a href=/docs/reference/access-authn-authz/admission-controllers/>controlador de admissão</a>.
Por exemplo, é recomendado usar <a href=/docs/concepts/configuration/manage-resources-containers/#extended-resources>Extended Resources</a> para representar hardware especial, adicione um taint ao seus nós de hardware especializado com o nome do recurso estendido e execute o controle de admissão <a href=/docs/reference/access-authn-authz/admission-controllers/#extendedresourcetoleration>ExtendedResourceToleration</a>. Agora, tendo em vista que os nós estão marcados com um taint, nenhum pod sem a tolerância será executado neles. Porém, quando você submete um pod que requisita o recurso estendido, o controlador de admissão <code>ExtendedResourceToleration</code> irá adicionar automaticamente as tolerâncias necessárias ao pod que irá, por sua vez, ser alocado no nó com hardware especial. Isso garantirá que esses nós de hardware especial serão dedicados para os pods que requisitarem tal recurso e você não precisará adicionar manualmente as tolerâncias aos seus pods.</p></li><li><p><strong>Expulsões baseadas em Taint</strong>: Um comportamento de expulsão configurada por pod quando problemas existem em um nó, o qual será descrito na próxima seção.</p></li></ul><h2 id=expulsões-baseadas-em-taint>Expulsões baseadas em Taint</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.18 [stable]</code></div><p>O efeito de taint <code>NoExecute</code>, mencionado acima, afeta pods que já estão rodando no nó da seguinte forma</p><ul><li>pods que não toleram o taint são expulsos imediatamente</li><li>pods que toleram o taint sem especificar <code>tolerationSeconds</code> em sua especificação de tolerância, ficam alocados para sempre</li><li>pods que toleram o taint com um <code>tolerationSeconds</code> especificado, permanecem alocados pela quantidade de tempo definida</li></ul><p>O controlador de nó automaticamente adiciona um taint ao Nó quando certas condições se tornam verdadeiras. Os seguintes taints são embutidos:</p><ul><li><code>node.kubernetes.io/not-ready</code>: Nó não está pronto. Isso corresponde ao NodeCondition <code>Ready</code> com o valor "<code>False</code>".</li><li><code>node.kubernetes.io/unreachable</code>: Nó é inalcançável a partir do controlador de nó. Isso corresponde ao NodeCondition <code>Ready</code> com o valor "<code>Unknown</code>".</li><li><code>node.kubernetes.io/memory-pressure</code>: Nó possui pressão de memória.</li><li><code>node.kubernetes.io/disk-pressure</code>: Nó possui pressão de disco.</li><li><code>node.kubernetes.io/pid-pressure</code>: Nó possui pressão de PID.</li><li><code>node.kubernetes.io/network-unavailable</code>: A rede do nó está indisponível.</li><li><code>node.kubernetes.io/unschedulable</code>: Nó não é alocável.</li><li><code>node.cloudprovider.kubernetes.io/uninitialized</code>: Quando o kubelet é iniciado com um provedor de nuvem "externo", esse taint é adicionado ao nó para que ele seja marcado como não utilizável. Após o controlador do cloud-controller-manager inicializar o nó, o kubelet remove esse taint.</li></ul><p>No caso de um nó estar prestes a ser expulso, o controlador de nó ou kubelet adicionam os taints relevantes com o efeito <code>NoExecute</code>. Se a condição de falha retorna ao normal, o kubelet ou controlador de nó podem remover esses taints.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> A camada de gerenciamento limita a taxa de adição de novos taints aos nós. Esse limite gerencia o número de expulsões que são disparadas quando muitos nós se tornam inalcançáveis ao mesmo tempo (por exemplo: se ocorre uma falha na rede).</div><p>Você pode especificar <code>tolerationSeconds</code> em um Pod para definir quanto tempo ele ficará alocado em um nó que está falhando ou está sem resposta.</p><p>Por exemplo, você talvez queira manter uma aplicação com vários estados salvos localmente alocado em um nó por um longo período na ocorrência de uma divisão na rede, esperando que essa divisão se recuperará e assim a expulsão do pod pode ser evitada.
A tolerância que você define para esse Pod poderia ficar assim:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>tolerations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;node.kubernetes.io/unreachable&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Exists&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>effect</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;NoExecute&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>tolerationSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>6000</span><span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Nota:</strong><p>O Kubernetes automaticamente adiciona uma tolerância para <code>node.kubernetes.io/not-ready</code> e <code>node.kubernetes.io/unreachable</code> com <code>tolerationSeconds=300</code>, a menos que você, ou um controlador, defina essas tolerâncias explicitamente.</p><p>Essas tolerâncias adicionadas automaticamente significam que Pods podem continuar alocados aos Nós por 5 minutos após um desses problemas ser detectado.</p></div><p>Pods do tipo <a href=/docs/concepts/workloads/controllers/daemonset/>DaemonSet</a> são criados com tolerâncias <code>NoExecute</code> sem a propriedade <code>tolerationSeconds</code> para os seguintes taints:</p><ul><li><code>node.kubernetes.io/unreachable</code></li><li><code>node.kubernetes.io/not-ready</code></li></ul><p>Isso garante que esses pods do DaemonSet nunca sejam expulsos por conta desses problemas.</p><h2 id=taints-por-condições-de-nó>Taints por condições de nó</h2><p>A camada de gerenciamento, usando o <a class=glossary-tooltip title='Um ciclo de controle que observa o estado partilhado do cluster através do API Server e efetua mudanças tentando mover o estado atual em direção ao estado desejado.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=controlador>controlador</a> do nó, cria taints automaticamente com o efeito <code>NoSchedule</code> para <a href=/docs/concepts/scheduling-eviction/node-pressure-eviction/#node-conditions>condições de nó</a>.</p><p>O agendador verifica taints, não condições de nó, quando realiza suas decisões de agendamento. Isso garante que as condições de nó não afetem diretamente o agendamento.
Por exemplo, se a condição de nó <code>DiskPressure</code> está ativa, a camada de gerenciamento adiciona o taint <code>node.kubernetes.io/disk-pressure</code> e não aloca novos pods no nó afetado. Se a condição <code>MemoryPressure</code> está ativa, a camada de gerenciamento adiciona o taint <code>node.kubernetes.io/memory-pressure</code>.</p><p>Você pode ignorar condições de nó para pods recém-criados adicionando tolerâncias correspondentes. A camada de controle também adiciona a tolerância <code>node.kubernetes.io/memory-pressure</code> em pods que possuem uma <a class=glossary-tooltip title='QoS Class (Quality of Service Class) provides a way for Kubernetes to classify pods within the cluster into several classes and make decisions about scheduling and eviction.' data-toggle=tooltip data-placement=top href='/pt-br/docs/reference/glossary/?all=true#term-qos-class' target=_blank aria-label='classe de QoS'>classe de QoS</a> diferente de <code>BestEffort</code>. Isso ocorre porque o Kubernetes trata pods nas classes de QoS <code>Guaranteed</code> ou <code>Burstable</code> (até mesmo pods sem requisitos de memória definidos) como se fossem capazes de lidar com pressão de memória, enquanto novos pods com <code>BestEffort</code> não são alocados no nó afetado.</p><p>O controlador DaemonSet adiciona automaticamente as seguintes tolerâncias de <code>NoSchedule</code> para todos os daemons, prevenindo que DaemonSets quebrem.</p><ul><li><code>node.kubernetes.io/memory-pressure</code></li><li><code>node.kubernetes.io/disk-pressure</code></li><li><code>node.kubernetes.io/pid-pressure</code> (1.14 ou superior)</li><li><code>node.kubernetes.io/unschedulable</code> (1.10 ou superior)</li><li><code>node.kubernetes.io/network-unavailable</code> (<em>somente rede do host</em>)</li></ul><p>Adicionando essas tolerâncias garante retro compatibilidade. Você também pode adicionar tolerâncias de forma arbitrária aos DaemonSets.</p><h2 id=próximos-passos>Próximos passos</h2><ul><li>Leia sobre <a href=/docs/concepts/scheduling-eviction/node-pressure-eviction/>Node-pressure Eviction</a> e como você pode configurá-la</li><li>Leia sobre <a href=/docs/concepts/scheduling-eviction/pod-priority-preemption/>Pod Priority</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-598f36d691ab197f9d995784574b0a12>3.8.2 - Escalonador do Kubernetes</h1><p>No Kubernetes, <em>escalonamento</em> refere-se a garantir que os <a class=glossary-tooltip title='O menor e mais simples objeto Kubernetes. Um Pod representa um conjunto de contêineres em execução no seu cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/ target=_blank aria-label=Pods>Pods</a>
sejam correspondidos aos <a class=glossary-tooltip title='Um Nó é uma máquina de trabalho no Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/nodes/ target=_blank aria-label=Nodes>Nodes</a> para que o
<a class=glossary-tooltip title='Um agente que é executado em cada node no cluster. Ele garante que os contêineres estejam sendo executados em um pod.' data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kubelet target=_blank aria-label=Kubelet>Kubelet</a> possa executá-los.</p><h2 id=escalonamento>Visão geral do Escalonamento</h2><p>Um escalonador observa Pods recém-criados que não possuem um Node atribuído.
Para cada Pod que o escalonador descobre, ele se torna responsável por
encontrar o melhor Node para execução do Pod. O escalonador chega a essa decisão de alocação levando em consideração os princípios de programação descritos abaixo.</p><p>Se você quiser entender por que os Pods são alocados em um Node específico
ou se planeja implementar um escalonador personalizado, esta página ajudará você a
aprender sobre escalonamento.</p><h2 id=kube-scheduler>kube-scheduler</h2><p><a href=https://kubernetes.io/docs/reference/command-line-tools-reference/kube-scheduler/>kube-scheduler</a>
é o escalonador padrão do Kubernetes e é executado como parte do
<a class=glossary-tooltip title='A camada de gerenciamento de contêiner que expõe a API e as interfaces para definir, implantar e gerenciar o ciclo de vida dos contêineres.' data-toggle=tooltip data-placement=top href='/pt-br/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='control plane'>control plane</a>.
O kube-scheduler é projetado para que, se você quiser e precisar, possa
escrever seu próprio componente de escalonamento e usá-lo.</p><p>Para cada Pod recém-criado ou outros Pods não escalonados, o kube-scheduler
seleciona um Node ideal para execução. No entanto, todos os contêineres nos Pods
têm requisitos diferentes de recursos e cada Pod também possui requisitos diferentes.
Portanto, os Nodes existentes precisam ser filtrados de acordo com os requisitos de
escalonamento específicos.</p><p>Em um cluster, Nodes que atendem aos requisitos de escalonamento para um Pod
são chamados de Nodes <em>viáveis</em>. Se nenhum dos Nodes for adequado, o Pod
permanece não escalonado até que o escalonador possa alocá-lo.</p><p>O escalonador encontra Nodes viáveis para um Pod e, em seguida, executa um conjunto de
funções para pontuar os Nodes viáveis e escolhe um Node com a maior
pontuação entre os possíveis para executar o Pod. O escalonador então notifica
o servidor da API sobre essa decisão em um processo chamado <em>binding</em>.</p><p>Fatores que precisam ser levados em consideração para decisões de escalonamento incluem
requisitos individuais e coletivos de recursos,
restrições de hardware / software / política, especificações de afinidade e anti-afinidade,
localidade de dados, interferência entre cargas de trabalho e assim por diante.</p><h3 id=implementação-kube-scheduler>Seleção do Node no kube-scheduler</h3><p>O kube-scheduler seleciona um Node para o Pod em uma operação que consiste em duas etapas:</p><ol><li>Filtragem</li><li>Pontuação</li></ol><p>A etapa de <em>filtragem</em> localiza o conjunto de Nodes onde é possível
alocar o Pod. Por exemplo, o filtro PodFitsResources verifica se um Node
candidato possui recursos disponíveis suficientes para atender às solicitações
de recursos específicas de um Pod. Após esta etapa, a lista de Nodes contém
quaisquer Nodes adequados; frequentemente, haverá mais de um. Se a lista estiver vazia,
esse Pod (ainda) não é escalonável.</p><p>Na etapa de <em>pontuação</em>, o escalonador classifica os Nodes restantes para escolher
o mais adequado. O escalonador atribui uma pontuação a cada Node
que sobreviveu à filtragem, baseando essa pontuação nas regras de pontuação ativa.</p><p>Por fim, o kube-scheduler atribui o Pod ao Node com a classificação mais alta.
Se houver mais de um Node com pontuações iguais, o kube-scheduler seleciona
um deles aleatoriamente.</p><p>Existem duas maneiras suportadas de configurar o comportamento de filtragem e pontuação
do escalonador:</p><ol><li><p><a href=/docs/reference/scheduling/policies>Políticas de Escalonamento</a> permitem configurar <em>Predicados</em> para filtragem e <em>Prioridades</em> para pontuação.</p></li><li><p><a href=/docs/reference/scheduling/profiles>Perfis de Escalonamento</a> permitem configurar Plugins que implementam diferentes estágios de escalonamento, incluindo: <code>QueueSort</code>, <code>Filter</code>, <code>Score</code>, <code>Bind</code>, <code>Reserve</code>, <code>Permit</code>, e outros. Você também pode configurar o kube-scheduler para executar diferentes perfis.</p></li></ol><h2 id=próximos-passos>Próximos passos</h2><ul><li>Leia sobre <a href=/docs/concepts/scheduling/scheduler-perf-tuning/>ajuste de desempenho do escalonador</a></li><li>Leia sobre <a href=/docs/concepts/workloads/pods/pod-topology-spread-constraints/>restrições de propagação da topologia de pod</a></li><li>Leia a <a href=/docs/reference/command-line-tools-reference/kube-scheduler/>documentação de referência</a> para o kube-scheduler</li><li>Aprenda como <a href=/docs/tasks/administer-cluster/configure-multiple-schedulers/>configurar vários escalonadores</a></li><li>Aprenda sobre <a href=/docs/tasks/administer-cluster/topology-manager/>políticas de gerenciamento de topologia</a></li><li>Aprenda sobre <a href=/docs/concepts/configuration/pod-overhead/>Pod Overhead</a></li><li>Saiba mais sobre o agendamento de pods que usam volumes em:<ul><li><a href=/docs/concepts/storage/storage-classes/#volume-binding-mode>Suporte de topologia de volume</a></li><li><a href=/docs/concepts/storage/storage-capacity/>Rastreamento de capacidade de armazenamento</a></li><li><a href=/docs/concepts/storage/storage-limits/>Limites de volumes específicos do nó</a></li></ul></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-da22fe2278df236f71efbe672f392677>3.8.3 - Sobrecarga de Pod</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.18 [beta]</code></div><p>Quando você executa um Pod num nó, o próprio Pod usa uma quantidade de recursos do sistema. Estes
recursos são adicionais aos recursos necessários para executar o(s) contêiner(s) dentro do Pod.
Sobrecarga de Pod, do inglês <em>Pod Overhead</em>, é uma funcionalidade que serve para contabilizar os recursos consumidos pela
infraestrutura do Pod para além das solicitações e limites do contêiner.</p><p>No Kubernetes, a sobrecarga de Pods é definido no tempo de
<a href=/docs/reference/access-authn-authz/extensible-admission-controllers/#what-are-admission-webhooks>admissão</a>
de acordo com a sobrecarga associada à
<a href=/docs/concepts/containers/runtime-class/>RuntimeClass</a> do Pod.</p><p>Quando é ativada a Sobrecarga de Pod, a sobrecarga é considerada adicionalmente à soma das
solicitações de recursos do contêiner ao agendar um Pod. Semelhantemente, o <em>kubelet</em>
incluirá a sobrecarga do Pod ao dimensionar o cgroup do Pod e ao
executar a classificação de prioridade de migração do Pod em caso de <em>drain</em> do Node.</p><h2 id=set-up>Habilitando a Sobrecarga de Pod</h2><p>Terá de garantir que o <a href=/docs/reference/command-line-tools-reference/feature-gates/>Feature Gate</a>
<code>PodOverhead</code> esteja ativo (está ativo por padrão a partir da versão 1.18)
em todo o cluster, e uma <code>RuntimeClass</code> utilizada que defina o campo <code>overhead</code>.</p><h2 id=exemplo-de-uso>Exemplo de uso</h2><p>Para usar a funcionalidade PodOverhead, é necessário uma RuntimeClass que define o campo <code>overhead</code>.
Por exemplo, poderia usar a definição da RuntimeClass abaixo com um agente de execução de contêiner virtualizado
que use cerca de 120MiB por Pod para a máquina virtual e o sistema operacional convidado:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>RuntimeClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>node.k8s.io/v1beta1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>kata-fc<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>handler</span>:<span style=color:#bbb> </span>kata-fc<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>overhead</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>podFixed</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;120Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;250m&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>As cargas de trabalho que são criadas e que especificam o manipulador RuntimeClass <code>kata-fc</code> irão
usar a sobrecarga de memória e cpu em conta para os cálculos da quota de recursos, agendamento de nós,
assim como dimensionamento do cgroup do Pod.</p><p>Considere executar a seguinte carga de trabalho de exemplo, test-pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>runtimeClassName</span>:<span style=color:#bbb> </span>kata-fc<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>busybox-ctr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>stdin</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>tty</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>500m<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>100Mi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-ctr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>1500m<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>100Mi<span style=color:#bbb>
</span></span></span></code></pre></div><p>No tempo de admissão o <a href=https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/>controlador de admissão</a> RuntimeClass
atualiza o <em>PodSpec</em> da carga de trabalho de forma a incluir o <code>overhead</code> como descrito na RuntimeClass. Se o <em>PodSpec</em> já tiver este campo definido
o Pod será rejeitado. No exemplo dado, como apenas o nome do RuntimeClass é especificado, o controlador de admissão muda o Pod de forma a
incluir um <code>overhead</code>.</p><p>Depois do controlador de admissão RuntimeClass, pode verificar o <em>PodSpec</em> atualizado:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl get pod test-pod -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.spec.overhead}&#39;</span>
</span></span></code></pre></div><p>A saída é:</p><pre tabindex=0><code>map[cpu:250m memory:120Mi]
</code></pre><p>Se for definido um <em>ResourceQuota</em>, a soma das requisições dos contêineres assim como o campo <code>overhead</code> são contados.</p><p>Quando o kube-scheduler está decidindo que nó deve executar um novo Pod, o agendador considera o <code>overhead</code> do pod,
assim como a soma de pedidos aos contêineres para esse <em>Pod</em>. Para este exemplo, o agendador adiciona as requisições e a sobrecarga, depois procura um nó com 2.25 CPU e 320 MiB de memória disponível.</p><p>Assim que um Pod é agendado a um nó, o kubelet nesse nó cria um novo <a class=glossary-tooltip title='Um grupo de processos do Linux com isolamento de recursos opcional, contagem e limites.' data-toggle=tooltip data-placement=top href='/pt-br/docs/reference/glossary/?all=true#term-cgroup' target=_blank aria-label=cgroup>cgroup</a>
para o Pod. É dentro deste Pod que o agente de execução de contêiners subjacente vai criar contêineres.</p><p>Se o recurso tiver um limite definido para cada contêiner (<em>QoS</em> garantida ou <em>Burstrable QoS</em> com limites definidos),
o kubelet definirá um limite superior para o cgroup do Pod associado a esse recurso (cpu.cfs_quota_us para CPU
e memory.limit_in_bytes de memória). Este limite superior é baseado na soma dos limites do contêiner mais o <code>overhead</code>
definido no <em>PodSpec</em>.</p><p>Para CPU, se o Pod for QoS garantida ou <em>Burstrable QoS</em>, o kubelet vai definir <code>cpu.shares</code> baseado na soma dos
pedidos ao contêiner mais o <code>overhead</code> definido no <em>PodSpec</em>.</p><p>Olhando para o nosso exemplo, verifique as requisições ao contêiner para a carga de trabalho:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl get pod test-pod -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.spec.containers[*].resources.limits}&#39;</span>
</span></span></code></pre></div><p>O total de requisições ao contêiner são 2000m CPU e 200MiB de memória:</p><pre tabindex=0><code>map[cpu: 500m memory:100Mi] map[cpu:1500m memory:100Mi]
</code></pre><p>Verifique isto comparado ao que é observado pelo nó:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl describe node | grep test-pod -B2
</span></span></code></pre></div><p>A saída mostra que 2250m CPU e 320MiB de memória são solicitados, que inclui <em>PodOverhead</em>:</p><pre tabindex=0><code>  Namespace                   Name                CPU Requests  CPU Limits   Memory Requests  Memory Limits  AGE
  ---------                   ----                ------------  ----------   ---------------  -------------  ---
  default                     test-pod            2250m (56%)   2250m (56%)  320Mi (1%)       320Mi (1%)     36m
</code></pre><h2 id=verificar-os-limites-cgroup-do-pod>Verificar os limites cgroup do Pod</h2><p>Verifique os cgroups de memória do Pod no nó onde a carga de trabalho está em execução. No seguinte exemplo, <a href=https://github.com/kubernetes-sigs/cri-tools/blob/master/docs/crictl.md><code>crictl</code></a>
é usado no nó, que fornece uma CLI para agentes de execução compatíveis com CRI. Isto é um
exemplo avançado para mostrar o comportamento do <em>PodOverhead</em>, e não é esperado que os usuários precisem verificar
cgroups diretamente no nó.</p><p>Primeiro, no nó em particular, determine o identificador do Pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#080;font-style:italic># Execute no nó onde o Pod está agendado</span>
</span></span><span style=display:flex><span><span style=color:#b8860b>POD_ID</span><span style=color:#666>=</span><span style=color:#b44>&#34;</span><span style=color:#a2f;font-weight:700>$(</span>sudo crictl pods --name test-pod -q<span style=color:#a2f;font-weight:700>)</span><span style=color:#b44>&#34;</span>
</span></span></code></pre></div><p>A partir disto, pode determinar o caminho do cgroup para o <em>Pod</em>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#080;font-style:italic># Execute no nó onde o Pod está agendado</span>
</span></span><span style=display:flex><span>sudo crictl inspectp -o<span style=color:#666>=</span>json <span style=color:#b8860b>$POD_ID</span> | grep cgroupsPath
</span></span></code></pre></div><p>O caminho do cgroup resultante inclui o contêiner <code>pause</code> do Pod. O cgroup no nível do Pod está um diretório acima.</p><pre tabindex=0><code>        &#34;cgroupsPath&#34;: &#34;/kubepods/podd7f4b509-cf94-4951-9417-d1087c92a5b2/7ccf55aee35dd16aca4189c952d83487297f3cd760f1bbf09620e206e7d0c27a&#34;
</code></pre><p>Neste caso especifico, o caminho do cgroup do Pod é <code>kubepods/podd7f4b509-cf94-4951-9417-d1087c92a5b2</code>. Verifique a configuração cgroup de nível do Pod para a memória:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#080;font-style:italic># Execute no nó onde o Pod está agendado</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Mude também o nome do cgroup para combinar com o cgroup alocado ao Pod.</span>
</span></span><span style=display:flex><span> cat /sys/fs/cgroup/memory/kubepods/podd7f4b509-cf94-4951-9417-d1087c92a5b2/memory.limit_in_bytes
</span></span></code></pre></div><p>Isto é 320 MiB, como esperado:</p><pre tabindex=0><code>335544320
</code></pre><h3 id=observabilidade>Observabilidade</h3><p>Uma métrica <code>kube_pod_overhead</code> está disponível em <a href=https://github.com/kubernetes/kube-state-metrics>kube-state-metrics</a>
para ajudar a identificar quando o <em>PodOverhead</em> está sendo utilizado e para ajudar a observar a estabilidade das cargas de trabalho
em execução com uma sobrecarga (<em>Overhead</em>) definida. Esta funcionalidade não está disponível na versão 1.9 do kube-state-metrics,
mas é esperado em uma próxima versão. Os usuários necessitarão entretanto construir o kube-state-metrics a partir do código fonte.</p><h2 id=próximos-passos>Próximos passos</h2><ul><li><a href=/docs/concepts/containers/runtime-class/>RuntimeClass</a></li><li><a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-node/688-pod-overhead>PodOverhead Design</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-ac9161c6d952925b083ad9602b4e8e7f>3.9 - Políticas</h1><div class=lead>Políticas que você pode configurar e que afetam grupos de recursos.</div></div><div class=td-content><h1 id=pg-a935ff8c59eb116b43494255cc67f69a>3.9.1 - Intervalos de limite</h1><p>Por padrão, os cointêineres são executados com <a href=/docs/concepts/configuration/manage-resources-containers/>recursos computacionais</a> ilimitados em um cluster Kubernetes. Com cotas de recursos, os administradores de cluster podem restringir o consumo e a criação de recursos baseado no <a class=glossary-tooltip title='Uma abstração utilizada pelo Kubernetes para suportar múltiplos clusters virtuais no mesmo cluster físico.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/namespaces target=_blank aria-label=namespace>namespace</a>. Dentro de um <em>namespace</em>, pod ou contêiner pode haver o consumo de quantidade de CPU e memória definidos de acordo com a cota de recursos do <em>namespace</em>. Existe a preocupação de que um Pod ou contêiner possa monopolizar todos os recursos disponíveis, justamente por conta disso existe o conceito de <em>Limit Range</em>, ou intervalos de limite, que pode ser definido como uma política utilizada para a restrição de alocação de recursos (para pods ou contêineres) em um <em>namespace</em>.</p><p>Um <em>LimitRange</em> fornece restrições que podem:</p><ul><li>Aplicar o uso mínimo e máximo de recursos computacionais por pod ou contêiner em um <em>namespace</em>.</li><li>Impor a solicitação de armazenamento mínimo e máximo por <em>PersistentVolumeClaim</em> em um <em>namespace</em>.</li><li>Impor a proporção entre solicitação e limite para um recurso em um <em>namespace</em>.</li><li>Definir a solicitação/limite padrão para recursos computacionais em um <em>namespace</em> e utilizá-los automaticamente nos contêineres em tempo de execução.</li></ul><h2 id=ativando-o-limitrange>Ativando o LimitRange</h2><p>O suporte ao <em>LimitRange</em> foi ativado por padrão desde o Kubernetes 1.10.</p><p>Um <em>LimitRange</em> é aplicado em um <em>namespace</em> específico quando há um objeto <em>LimitRange</em> nesse <em>namespace</em>.</p><p>O nome de um objeto <em>LimitRange</em> deve ser um <a href=/pt-br/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>nome de subdomínio DNS</a> válido.</p><h3 id=visão-geral-do-limit-range>Visão geral do Limit Range</h3><ul><li>O administrador cria um <em>LimitRange</em> em um <em>namespace</em>.</li><li>Os usuários criam recursos como pods, contêineres e <em>PersistentVolumeClaims</em> no <em>namespace</em>.</li><li>O controlador de admissão <code>LimitRanger</code> impõe padrões e limites para todos os pods e contêineres que não definem os requisitos de recursos computacionais e rastreia o uso para garantir que não exceda o mínimo, o máximo e a proporção de recursos definidos em qualquer <em>LimitRange</em> presente no <em>namespace</em>.</li><li>Se estiver criando ou atualizando um recurso (Pod, Container, <em>PersistentVolumeClaim</em>) que viola uma restrição <em>LimitRange</em>, a solicitação ao servidor da API falhará com um código de status HTTP <code>403 FORBIDDEN</code> e uma mensagem explicando a restrição violada.</li><li>Se um <em>LimitRange</em> for ativado em um <em>namespace</em> para recursos computacionais como <code>cpu</code> e <code>memória</code>, os usuários deverão especificar solicitações ou limites para esses valores. Caso contrário, o sistema pode rejeitar a criação do pod.</li><li>As validações de <em>LimitRange</em> ocorrem apenas no estágio de Admissão de Pod, não em Pods em Execução.</li></ul><p>Alguns exemplos de políticas que podem ser criadas utilizando os intervalos de limite são:</p><ul><li>Em um cluster de 2 nós com capacidade de 8 GiB de RAM e 16 núcleos, restrinja os Pods em um namespace para solicitar 100m de CPU com um limite máximo de 500m para CPU e solicitar 200Mi para memória com um limite máximo de 600Mi para memória.</li><li>Defina o limite e a solicitação de CPU padrão para 150m e a solicitação padrão de memória para 300Mi para contêineres iniciados sem solicitações de CPU e memória em suas especificações.</li></ul><p>Caso os limites totais do namespace sejam menores que a soma dos limites dos Pods/Contêineres, pode haver contenção por recursos. Nesse caso, os contêineres ou Pods não serão criados.</p><p>Nem a contenção nem as alterações em um <em>LimitRange</em> afetarão os recursos já criados.</p><h2 id=próximos-passos>Próximos passos</h2><p>Consulte o <a href=https://git.k8s.io/community/contributors/design-proposals/resource-management/admission_control_limit_range.md>documento de design LimitRanger</a> para obter mais informações.</p><p>Para exemplos de uso de limites, leia:</p><ul><li><a href=/docs/tasks/administer-cluster/manage-resources/cpu-constraint-namespace/>Como configurar restrições mínimas e máximas de CPU por <em>namespace</em></a>.</li><li><a href=/docs/tasks/administer-cluster/manage-resources/memory-constraint-namespace/>Como configurar restrições de memória mínima e máxima por <em>namespace</em></a>.</li><li><a href=/docs/tasks/administer-cluster/manage-resources/cpu-default-namespace/>como configurar solicitações e limites de CPU padrão por <em>namespace</em></a>.</li><li><a href=/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/>como configurar solicitações e limites de memória padrão por <em>namespace</em></a>.</li><li><a href=/docs/tasks/administer-cluster/limit-storage-consumption/#limitrange-to-limit-requests-for-storage>como configurar o consumo mínimo e máximo de armazenamento por <em>namespace</em></a>.</li><li>Um <a href=/docs/tasks/administer-cluster/manage-resources/quota-memory-cpu-namespace/>exemplo detalhado de configuração de cota por <em>namespace</em></a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-94ddc6e901c30f256138db11d09f05a3>3.9.2 - Cotas de Recursos</h1><p>Quando vários usuários ou equipes compartilham um cluster com um número fixo de nós,
há uma preocupação de que uma equipe possa usar mais do que é justo durante o compartilhamento de recursos.</p><p>As cotas de recursos são uma ferramenta para os administradores resolverem essa preocupação.</p><p>Uma cota de recurso, definida por um objeto <code>ResourceQuota</code>, fornece restrições que limitam
consumo de recursos agregados por <em>namespace</em>. Pode limitar a quantidade de objetos que podem
ser criado em um <em>namespace</em> por tipo, bem como a quantidade total de recursos computacionais que podem
ser consumidos por recursos nesse <em>namespace</em>.</p><p>As cotas de recursos funcionam assim:</p><ul><li><p>Diferentes equipes trabalham em diferentes <em>namespaces</em>. Atualmente, isso é voluntário, mas o suporte para tornar isso obrigatório por meio de ACLs está planejado.</p></li><li><p>O administrador cria uma <code>ResourceQuota</code> para cada <em>namespace</em>.</p></li><li><p>Os usuários criam recursos (pods, serviços, etc.) no <em>namespace</em> e o sistema de cotas rastreia o uso para garantir que ele não exceda os limites de recursos definidos em um <code>ResourceQuota</code>.</p></li><li><p>Se a criação ou atualização de um recurso violar uma restrição de cota, a solicitação falhará com código de status HTTP <code>403 FORBIDDEN</code> acompanhado de uma mensagem explicando a restrição que foi violada.</p></li><li><p>Se a cota estiver habilitada em um <em>namespace</em> para recursos computacionais como <code>cpu</code> e <code>memória</code>, os usuários devem especificar solicitações ou limites para esses valores; caso contrário, o sistema de cotas poderá rejeitar a criação de pods. Dica: use o controlador de admissão <code>LimitRanger</code> para forçar padrões para pods que não exigem recursos computacionais.</p><p>Veja o <a href=/docs/tasks/administer-cluster/manage-resources/quota-memory-cpu-namespace/>passo a passo</a>
para um exemplo de como evitar este problema.</p></li></ul><p>O nome de um objeto <code>ResourceQuota</code> deve ser um <a href=/pt-br/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>nome do subdomínio DNS</a> válido.</p><p>Exemplos de políticas que podem ser criadas usando <em>namespaces</em> e cotas são:</p><ul><li>Em um cluster com capacidade de 32 GiB de RAM e 16 núcleos, deixe a equipe A usar 20 GiB e 10 núcleos, deixe B usar 10GiB e 4 núcleos e mantenha 2GiB e 2 núcleos em reserva para alocação futura.</li><li>Limite o <em>namespace</em> "testing" para usar 1 núcleo e 1GiB de RAM. Deixe o namespace "produção" usar qualquer quantia.</li></ul><p>Caso a capacidade total do cluster seja menor que a soma das cotas dos <em>namespaces</em>, pode haver contenção de recursos. Isso é tratado por ordem de chegada.</p><p>Nem a contenção nem as alterações na cota afetarão os recursos já criados.</p><h2 id=ativando-a-cota-de-recursos>Ativando a cota de recursos</h2><p>O suporte à cota de recursos é ativado por padrão para muitas distribuições do Kubernetes. Isto é
ativado quando a flag <a class=glossary-tooltip title='O componente da camada de gerenciamento que serve a API do Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label='API server'>API server</a> <code>--enable-admission-plugins=</code> tem <code>ResourceQuota</code> como
um de seus argumentos.</p><p>Uma cota de recurso é aplicada em um <em>namespace</em> específico quando há um <code>ResourceQuota</code> nesse <em>namespace</em>.</p><h2 id=cota-de-recursos-computacionais>Cota de recursos computacionais</h2><p>Você pode limitar a soma total de <a href=/docs/concepts/configuration/manage-resources-containers/>recursos computacionais</a> que pode ser solicitado em um determinado <em>namespace</em>.</p><p>Os seguintes tipos de recursos são suportados:</p><table><thead><tr><th>Nome do Recurso</th><th>Descrição</th></tr></thead><tbody><tr><td><code>limits.cpu</code></td><td>Em todos os pods em um estado não terminal, a soma dos limites de CPU não pode exceder esse valor.</td></tr><tr><td><code>limits.memory</code></td><td>Em todos os pods em um estado não terminal, a soma dos limites de memória não pode exceder esse valor.</td></tr><tr><td><code>requests.cpu</code></td><td>Em todos os pods em um estado não terminal, a soma das solicitações da CPU não pode exceder esse valor.</td></tr><tr><td><code>requests.memory</code></td><td>Em todos os pods em um estado não terminal, a soma das solicitações de memória não pode exceder esse valor.</td></tr><tr><td><code>hugepages-&lt;size></code></td><td>Em todos os pods em um estado não terminal, o número de solicitações de grandes páginas do tamanho especificado não pode exceder esse valor.</td></tr><tr><td><code>cpu</code></td><td>O mesmo que <code>requests.cpu</code></td></tr><tr><td><code>memory</code></td><td>O mesmo que <code>requests.memory</code></td></tr></tbody></table><h3 id=cota-de-recursos-para-recursos-estendidos>Cota de recursos para recursos estendidos</h3><p>Além dos recursos mencionados acima, na versão 1.10, suporte a cotas para <a href=/docs/concepts/configuration/manage-resources-containers/#extended-resources>recursos estendidos</a> foi adicionado.</p><p>Como o <code>overcommit</code> não é permitido para recursos estendidos, não faz sentido especificar tanto <code>requests</code> e <code>limits</code> para o mesmo recurso estendido em uma cota. Portanto, para recursos estendidos, apenas itens de cota com prefixo <code>requests.</code> é permitido por enquanto.</p><p>Tome o recurso GPU como exemplo, se o nome do recurso for <code>nvidia.com/gpu</code> e você quiser limitar o número total de GPUs solicitadas em um <em>namespace</em> para 4, você pode definir uma cota da seguinte maneira:</p><ul><li><code>requests.nvidia.com/gpu: 4</code></li></ul><p>Veja <a href=#viewing-and-setting-quotas>como visualizar e definir cotas</a> para mais informações.</p><h2 id=cota-de-recursos-de-armazenamento>Cota de recursos de armazenamento</h2><p>Você pode limitar a soma total de <a href=/docs/concepts/storage/persistent-volumes/>recursos de armazenamento</a> que podem ser solicitados em um determinado <em>namespace</em>.</p><p>Além disso, você pode limitar o consumo de recursos de armazenamento com base na classe de armazenamento associada.</p><table><thead><tr><th>Nome do recurso</th><th>Descrição</th></tr></thead><tbody><tr><td><code>requests.storage</code></td><td>Em todas as solicitações de volume persistentes, a soma das solicitações de armazenamento não pode exceder esse valor.</td></tr><tr><td><code>persistentvolumeclaims</code></td><td>O número total de <a href=/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims>PersistentVolumeClaims</a> que podem existir no namespace.</td></tr><tr><td><code>&lt;storage-class-name>.storageclass.storage.k8s.io/requests.storage</code></td><td>Em todas as solicitações de volume persistentes associadas ao <code>&lt;storage-class-name></code>, a soma das solicitações de armazenamento não pode exceder esse valor.</td></tr><tr><td><code>&lt;storage-class-name>.storageclass.storage.k8s.io/persistentvolumeclaims</code></td><td>Em todas as declarações de volume persistentes associadas ao storage-class-name, o número total de <a href=/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims>declarações de volume persistente</a> que podem existir no namespace.</td></tr></tbody></table><p>Por exemplo, se um operador deseja cotar armazenamento com classe de armazenamento <code>gold</code> separada da classe de armazenamento <code>bronze</code>, o operador pode definir uma cota da seguinte forma:</p><ul><li><code>gold.storageclass.storage.k8s.io/requests.storage: 500Gi</code></li><li><code>bronze.storageclass.storage.k8s.io/requests.storage: 100Gi</code></li></ul><p>Na versão 1.8, o suporte de cota para armazenamento temporário local foi adicionado como um recurso alfa:</p><table><thead><tr><th>Nome do Recurso</th><th>Descrição</th></tr></thead><tbody><tr><td><code>requests.ephemeral-storage</code></td><td>Em todos os pods no <em>namespace</em>, a soma das solicitações de armazenamento local efêmero não pode exceder esse valor.</td></tr><tr><td><code>limits.ephemeral-storage</code></td><td>Em todos os pods no <em>namespace</em>, a soma dos limites de armazenamento temporário local não pode exceder esse valor.</td></tr><tr><td><code>ephemeral-storage</code></td><td>O mesmo que <code>requests.ephemeral-storage</code>.</td></tr></tbody></table><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Ao usar um tempo de execução do contêiner CRI, os logs do contêiner serão contabilizados na cota de armazenamento efêmero. Isso pode resultar no despejo inesperado de pods que esgotaram suas cotas de armazenamento. Consulte <a href=/docs/concepts/cluster-administration/logging/>Arquitetura de registro</a> para mais detalhes.</div><h2 id=cota-de-contagem-de-objetos>Cota de contagem de objetos</h2><p>Você pode definir cotas para o número total de determinados recursos de todos os padrões, tipos de recursos com <em>namespace</em> usando a seguinte sintaxe:</p><ul><li><code>count/&lt;resource>.&lt;group></code> para recursos de grupos não principais</li><li><code>count/&lt;resource></code> para recursos do grupo principal</li></ul><p>Exemplo de conjunto de recursos que os usuários podem querer colocar na cota de contagem de objetos:</p><ul><li><code>count/persistentvolumeclaims</code></li><li><code>count/services</code></li><li><code>count/secrets</code></li><li><code>count/configmaps</code></li><li><code>count/replicationcontrollers</code></li><li><code>count/deployments.apps</code></li><li><code>count/replicasets.apps</code></li><li><code>count/statefulsets.apps</code></li><li><code>count/jobs.batch</code></li><li><code>count/cronjobs.batch</code></li></ul><p>A mesma sintaxe pode ser usada para recursos personalizados. Por exemplo, para criar uma cota em um recurso personalizado <code>widgets</code> no grupo de API <code>example.com</code>, use <code>count/widgets.example.com</code>.</p><p>Ao usar a cota de recurso <code>count/*</code>, um objeto é cobrado na cota se existir no armazenamento do servidor. Esses tipos de cotas são úteis para proteger contra o esgotamento dos recursos de armazenamento. Por exemplo, você pode desejar limitar o número de segredos em um servidor devido ao seu grande tamanho. Muitos segredos em um cluster podem
na verdade, impedir que servidores e controladores sejam iniciados. Você pode definir uma cota para projetos para proteger contra um <code>CronJob</code> mal configurado. <code>CronJobs</code> que criam muitos <code>Jobs</code> em um <em>namespace</em> podem levar a uma negação de serviço.</p><p>Também é possível fazer uma cota de contagem de objetos genéricos em um conjunto limitado de recursos.
Os seguintes tipos são suportados:</p><table><thead><tr><th>Nome do Recurso</th><th>Descrição</th></tr></thead><tbody><tr><td><code>configmaps</code></td><td>O número total de <code>ConfigMaps</code> que podem existir no namespace.</td></tr><tr><td><code>persistentvolumeclaims</code></td><td>O número total de <a href=/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims>PersistentVolumeClaims</a> que podem existir no namespace.</td></tr><tr><td><code>pods</code></td><td>O número total de pods em um estado não terminal que pode existir no namespace. Um pod está em um estado terminal se <code>.status.phase in (Failed, Succeeded)</code> for verdadeiro.</td></tr><tr><td><code>replicationcontrollers</code></td><td>O número total de <code>ReplicationControllers</code> que podem existir no <em>namespace</em>.</td></tr><tr><td><code>resourcequotas</code></td><td>O número total de <code>ResourceQuotas</code> que podem existir no <em>namespace</em>.</td></tr><tr><td><code>services</code></td><td>O número total de Serviços que podem existir no <em>namespace</em>.</td></tr><tr><td><code>services.loadbalancers</code></td><td>O número total de serviços do tipo <code>LoadBalancer</code> que podem existir no <em>namespace</em>.</td></tr><tr><td><code>services.nodeports</code></td><td>O número total de serviços do tipo <code>NodePort</code> que podem existir no <em>namespace</em>.</td></tr><tr><td><code>secrets</code></td><td>O número total de segredos que podem existir no <em>namespace</em>.</td></tr></tbody></table><p>Por exemplo, a cota de <code>pods</code> conta e impõe um número máximo de <code>pods</code> criados em um único <em>namespace</em> que não é terminal. Você pode querer definir uma cota <code>pods</code>em um <em>namespace</em> para evitar o caso em que um usuário cria muitos <code>pods</code> pequenos e esgota o fornecimento de IPs de pod do cluster.</p><h2 id=escopos-de-cota>Escopos de cota</h2><p>Cada cota pode ter um conjunto associado de <code>scopes</code>. Uma cota só medirá o uso de um recurso se corresponder
a interseção de escopos enumerados.</p><p>Quando um escopo é adicionado à cota, ele limita o número de recursos aos quais ele dá suporte a aqueles que pertencem ao escopo. Os recursos especificados na cota fora do conjunto permitido resultam em um erro de validação.</p><table><thead><tr><th>Escopo</th><th>Descrição</th></tr></thead><tbody><tr><td><code>Terminating</code></td><td>Pods correspondentes onde <code>.spec.activeDeadlineSeconds >= 0</code></td></tr><tr><td><code>NotTerminating</code></td><td>Pods correspondentes onde <code>.spec.activeDeadlineSeconds is nil</code></td></tr><tr><td><code>BestEffort</code></td><td>Pods correspondentes que tenham a qualidade de serviço de melhor esforço.</td></tr><tr><td><code>NotBestEffort</code></td><td>Pods correspondentes que não têm qualidade de serviço de melhor esforço.</td></tr><tr><td><code>PriorityClass</code></td><td>Corresponde aos pods que fazem referência à <a href=/docs/concepts/scheduling-eviction/pod-priority-preemption>classe de prioridade</a> especificada.</td></tr><tr><td><code>CrossNamespacePodAffinity</code></td><td>Corresponde a pods que tenham <a href=/docs/concepts/scheduling-eviction/assign-pod-node>termos de (anti)afinidade</a> de <em>namespace</em> cruzado.</td></tr></tbody></table><p>O escopo <code>BestEffort</code> restringe uma cota ao rastreamento do seguinte recurso:</p><ul><li><code>pods</code></li></ul><p>Os escopos <code>Termination</code>, <code>NotTerminate</code>, <code>NotBestEffort</code> e <code>PriorityClass</code>restringem uma cota para rastrear os seguintes recursos:</p><ul><li><code>pods</code></li><li><code>cpu</code></li><li><code>memory</code></li><li><code>requests.cpu</code></li><li><code>requests.memory</code></li><li><code>limits.cpu</code></li><li><code>limits.memory</code></li></ul><p>Observe que você não pode especificar os escopos <code>Terminate</code> e o <code>NotTerminate</code>na mesma cota, e você também não pode especificar o <code>BestEffort</code> e<code>NotBestEffort</code> na mesma cota.</p><p>O <code>scopeSelector</code> suporta os seguintes valores no campo <code>operator</code>:</p><ul><li><code>In</code></li><li><code>NotIn</code></li><li><code>Exists</code></li><li><code>DoesNotExist</code></li></ul><p>Ao usar um dos seguintes valores como o <code>scopeName</code> ao definir o<code>scopeSelector</code>, o <code>operator</code> deve ser <code>Exists</code>.</p><ul><li><code>Terminating</code></li><li><code>NotTerminating</code></li><li><code>BestEffort</code></li><li><code>NotBestEffort</code></li></ul><p>Se o <code>operator</code> for <code>In</code> ou <code>NotIn</code>, o campo <code>values</code> deve ter pelo menos um valor. Por exemplo:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scopeSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>scopeName</span>:<span style=color:#bbb> </span>PriorityClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>- middle<span style=color:#bbb>
</span></span></span></code></pre></div><p>Se o <code>operator</code> for <code>Exists</code> ou <code>DoesNotExist</code>, o campo <code>values</code> <em>NÃO</em> deve ser especificado.</p><h3 id=cota-de-recursos-por-classe-de-prioridade>Cota de recursos por classe de prioridade</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.17 [stable]</code></div><p>Os pods podem ser criados em uma <a href=/docs/concepts/scheduling-eviction/pod-priority-preemption/#pod-priority>prioridade</a> específica. Você pode controlar o consumo de recursos do sistema de um pod com base na prioridade de um pod, usando o <code>scopeSelector</code>
campo na especificação de cota.</p><p>Uma cota é correspondida e consumida apenas se <code>scopeSelector</code> na especificação de cota selecionar o pod.</p><p>Quando a cota está no escopo da classe de prioridade usando o campo <code>scopeSelector</code>, objeto de cota
está restrito a rastrear apenas os seguintes recursos:</p><ul><li><code>pods</code></li><li><code>cpu</code></li><li><code>memory</code></li><li><code>ephemeral-storage</code></li><li><code>limits.cpu</code></li><li><code>limits.memory</code></li><li><code>limits.ephemeral-storage</code></li><li><code>requests.cpu</code></li><li><code>requests.memory</code></li><li><code>requests.ephemeral-storage</code></li></ul><p>Este exemplo cria um objeto de cota e o corresponde a pods em prioridades específicas. O exemplo
funciona da seguinte forma:</p><ul><li>Os pods no cluster têm uma das três classes de prioridade, "baixa", "média", "alta".</li><li>Um objeto de cota é criado para cada prioridade.</li></ul><p>Salve o seguinte YAML em um arquivo <code>quota.yml</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>List<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ResourceQuota<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pods-high<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hard</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1000&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>200Gi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>pods</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;10&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>scopeSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>operator </span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>scopeName</span>:<span style=color:#bbb> </span>PriorityClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;high&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ResourceQuota<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pods-medium<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hard</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;10&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>20Gi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>pods</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;10&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>scopeSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>operator </span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>scopeName</span>:<span style=color:#bbb> </span>PriorityClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;medium&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ResourceQuota<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pods-low<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hard</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;5&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>10Gi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>pods</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;10&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>scopeSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>operator </span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>scopeName</span>:<span style=color:#bbb> </span>PriorityClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;low&#34;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div><p>Aplique o YAML usando <code>kubectl create</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f ./quota.yml
</span></span></code></pre></div><pre tabindex=0><code>resourcequota/pods-high created
resourcequota/pods-medium created
resourcequota/pods-low created
</code></pre><p>Verifique se a cota <code>Used</code> é <code>0</code> usando <code>kubectl describe quota</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe quota
</span></span></code></pre></div><pre tabindex=0><code>Name:       pods-high
Namespace:  default
Resource    Used  Hard
--------    ----  ----
cpu         0     1k
memory      0     200Gi
pods        0     10


Name:       pods-low
Namespace:  default
Resource    Used  Hard
--------    ----  ----
cpu         0     5
memory      0     10Gi
pods        0     10


Name:       pods-medium
Namespace:  default
Resource    Used  Hard
--------    ----  ----
cpu         0     10
memory      0     20Gi
pods        0     10
</code></pre><p>Crie um pod com prioridade "high". Salve o seguinte YAML em um arquivo <code>high-priority-pod.yml</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>high-priority<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>high-priority<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>ubuntu<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;/bin/sh&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;while true; do echo hello; sleep 10;done&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;10Gi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;500m&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;10Gi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;500m&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>priorityClassName</span>:<span style=color:#bbb> </span>high<span style=color:#bbb>
</span></span></span></code></pre></div><p>Applique com <code>kubectl create</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f ./high-priority-pod.yml
</span></span></code></pre></div><p>Verifique se as estatísticas "Used" para a cota de prioridade "high", <code>pods-high</code> foram alteradas e se
as outras duas cotas permanecem inalteradas.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe quota
</span></span></code></pre></div><pre tabindex=0><code>Name:       pods-high
Namespace:  default
Resource    Used  Hard
--------    ----  ----
cpu         500m  1k
memory      10Gi  200Gi
pods        1     10


Name:       pods-low
Namespace:  default
Resource    Used  Hard
--------    ----  ----
cpu         0     5
memory      0     10Gi
pods        0     10


Name:       pods-medium
Namespace:  default
Resource    Used  Hard
--------    ----  ----
cpu         0     10
memory      0     20Gi
pods        0     10
</code></pre><h3 id=cota-de-afinidade-de-pod-entre-namespaces>Cota de afinidade de pod entre <em>namespaces</em></h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.22 [beta]</code></div><p>Os operadores podem usar o escopo de cota <code>CrossNamespacePodAffinity</code> para limitar quais <em>namespaces</em> têm permissão para ter pods com termos de afinidade que cruzam <em>namespaces</em>. Especificamente, ele controla quais pods são permitidos para definir os campos <code>namespaces</code> ou <code>namespaceSelector</code> em termos de afinidade de pod.</p><p>Impedir que os usuários usem termos de afinidade entre <em>namespaces</em> pode ser desejável, pois um pod
com restrições antiafinidade pode bloquear pods de todos os outros <em>namespaces</em> de ser agendado em um domínio de falha.</p><p>O uso desses operadores de escopo pode impedir certos <em>namespaces</em> (<code>foo-ns</code> no exemplo abaixo) de ter pods que usam afinidade de pod entre <em>namespaces</em> criando um objeto de cota de recurso nesse <em>namespace</em> com escopo <code>CrossNamespaceAffinity</code> e limite rígido de 0:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ResourceQuota<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>disable-cross-namespace-affinity<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>foo-ns<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hard</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>pods</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;0&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scopeSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>scopeName</span>:<span style=color:#bbb> </span>CrossNamespaceAffinity<span style=color:#bbb>
</span></span></span></code></pre></div><p>Se os operadores quiserem proibir o uso de <code>namespaces</code> e <code>namespaceSelector</code> por padrão, e
permitir apenas para <em>namespaces</em> específicos, eles podem configurar <code>CrossNamespaceAffinity</code>como um recurso limitado definindo o sinalizador kube-apiserver --admission-control-config-file
para o caminho do seguinte arquivo de configuração:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiserver.config.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>AdmissionConfiguration<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>plugins</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;ResourceQuota&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>configuration</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiserver.config.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ResourceQuotaConfiguration<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>limitedResources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>resource</span>:<span style=color:#bbb> </span>pods<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>matchScopes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>scopeName</span>:<span style=color:#bbb> </span>CrossNamespaceAffinity<span style=color:#bbb>
</span></span></span></code></pre></div><p>Com a configuração acima, os pods podem usar <code>namespaces</code> e <code>namespaceSelector</code> apenas na afinidade do pod se o <em>namespace</em> em que foram criados tiver um objeto de cota de recurso com escopo <code>CrossNamespaceAffinity</code> e um limite rígido maior ou igual ao número de pods usando esses campos.</p><p>Esse recurso é beta e ativado por padrão. Você pode desativá-lo usando o <a href=/docs/reference/command-line-tools-reference/feature-gates/>feature gate</a> <code>PodAffinityNamespaceSelector</code> no kube-apiserver e no kube-scheduler.</p><h2 id=requests-vs-limits>Solicitações comparadas aos limites</h2><p>Ao alocar recursos computacionais, cada contêiner pode especificar uma solicitação e um valor limite para CPU ou memória. A cota pode ser configurada para cotar qualquer valor.</p><p>Se a cota tiver um valor especificado para <code>requests.cpu</code> ou <code>requests.memory</code>, ela exigirá que cada container faça uma solicitação explícita para esses recursos. Se a cota tiver um valor especificado para <code>limits.cpu</code> ou <code>limits.memory</code>, em seguida exige que cada contêiner de entrada especifique um limite explícito para esses recursos.</p><h2 id=como-visualizar-e-definir-cotas>Como visualizar e definir cotas</h2><p>O Kubectl é compatível com a criação, atualização e visualização de cotas:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create namespace myspace
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt; compute-resources.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: ResourceQuota
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: compute-resources
</span></span></span><span style=display:flex><span><span style=color:#b44>spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>  hard:
</span></span></span><span style=display:flex><span><span style=color:#b44>    requests.cpu: &#34;1&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44>    requests.memory: 1Gi
</span></span></span><span style=display:flex><span><span style=color:#b44>    limits.cpu: &#34;2&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44>    limits.memory: 2Gi
</span></span></span><span style=display:flex><span><span style=color:#b44>    requests.nvidia.com/gpu: 4
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f ./compute-resources.yaml --namespace<span style=color:#666>=</span>myspace
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt; object-counts.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: ResourceQuota
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: object-counts
</span></span></span><span style=display:flex><span><span style=color:#b44>spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>  hard:
</span></span></span><span style=display:flex><span><span style=color:#b44>    configmaps: &#34;10&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44>    persistentvolumeclaims: &#34;4&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44>    pods: &#34;4&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44>    replicationcontrollers: &#34;20&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44>    secrets: &#34;10&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44>    services: &#34;10&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44>    services.loadbalancers: &#34;2&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f ./object-counts.yaml --namespace<span style=color:#666>=</span>myspace
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get quota --namespace<span style=color:#666>=</span>myspace
</span></span></code></pre></div><pre tabindex=0><code class=language-none data-lang=none>NAME                    AGE
compute-resources       30s
object-counts           32s
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe quota compute-resources --namespace<span style=color:#666>=</span>myspace
</span></span></code></pre></div><pre tabindex=0><code class=language-none data-lang=none>Name:                    compute-resources
Namespace:               myspace
Resource                 Used  Hard
--------                 ----  ----
limits.cpu               0     2
limits.memory            0     2Gi
requests.cpu             0     1
requests.memory          0     1Gi
requests.nvidia.com/gpu  0     4
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe quota object-counts --namespace<span style=color:#666>=</span>myspace
</span></span></code></pre></div><pre tabindex=0><code class=language-none data-lang=none>Name:                   object-counts
Namespace:              myspace
Resource                Used    Hard
--------                ----    ----
configmaps              0       10
persistentvolumeclaims  0       4
pods                    0       4
replicationcontrollers  0       20
secrets                 1       10
services                0       10
services.loadbalancers  0       2
</code></pre><p>Kubectl also supports object count quota for all standard namespaced resources
using the syntax <code>count/&lt;resource>.&lt;group></code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create namespace myspace
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create quota <span style=color:#a2f>test</span> --hard<span style=color:#666>=</span>count/deployments.apps<span style=color:#666>=</span>2,count/replicasets.apps<span style=color:#666>=</span>4,count/pods<span style=color:#666>=</span>3,count/secrets<span style=color:#666>=</span><span style=color:#666>4</span> --namespace<span style=color:#666>=</span>myspace
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create deployment nginx --image<span style=color:#666>=</span>nginx --namespace<span style=color:#666>=</span>myspace --replicas<span style=color:#666>=</span><span style=color:#666>2</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe quota --namespace<span style=color:#666>=</span>myspace
</span></span></code></pre></div><pre tabindex=0><code>Name:                         test
Namespace:                    myspace
Resource                      Used  Hard
--------                      ----  ----
count/deployments.apps        1     2
count/pods                    2     3
count/replicasets.apps        1     4
count/secrets                 1     4
</code></pre><h2 id=capacidade-e-cota-de-cluster>Capacidade e cota de Cluster</h2><p><code>ResourceQuotas</code> são independentes da capacidade do cluster. Eles estão expresso em unidades absolutas. Portanto, se você adicionar nós ao cluster, isso <em>não</em>
dá automaticamente a cada <em>namespace</em> a capacidade de consumir mais recursos.</p><p>Às vezes, políticas mais complexas podem ser necessárias, como:</p><ul><li>Divida proporcionalmente os recursos totais do cluster entre várias equipes.</li><li>Permita que cada locatário aumente o uso de recursos conforme necessário, mas tenha um generoso limite para evitar o esgotamento acidental de recursos.</li><li>Detecte a demanda de um <em>namespace</em>, adicione nós e aumente a cota.</li></ul><p>Tais políticas podem ser implementadas usando <code>ResourceQuotas</code> como blocos de construção, por
escrevendo um "controlador" que observa o uso da cota e ajusta os limites rígidos da cota de cada <em>namespace</em> de acordo com outros sinais.</p><p>Observe que a cota de recursos divide os recursos agregados do cluster, mas não cria restrições em torno dos nós: pods de vários <em>namespaces</em> podem ser executados no mesmo nó.</p><h2 id=limite-de-consumo-de-classe-de-prioridade-por-padrão>Limite de consumo de classe de prioridade por padrão</h2><p>Pode ser desejado que os pods com uma prioridade particular, por exemplo. "cluster-services",
deve ser permitido em um <em>namespace</em>, se, e somente se, existir um objeto de cota correspondente.</p><p>Com este mecanismo, os operadores podem restringir o uso de certas classes de prioridade para um número limitado de <em>namespaces</em> , e nem todos poderão consumir essas classes de prioridade por padrão.</p><p>Para impor isso, a flag <code>kube-apiserver</code> <code>--admission-control-config-file</code> deve ser
usada para passar o caminho para o seguinte arquivo de configuração:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiserver.config.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>AdmissionConfiguration<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>plugins</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;ResourceQuota&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>configuration</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiserver.config.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ResourceQuotaConfiguration<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>limitedResources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>resource</span>:<span style=color:#bbb> </span>pods<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>matchScopes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>scopeName</span>:<span style=color:#bbb> </span>PriorityClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;cluster-services&#34;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div><p>Em seguida, crie um objeto de cota de recurso no <em>namespace</em> <code>kube-system</code>:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/pt-br/examples/policy/priority-class-resourcequota.yaml download=policy/priority-class-resourcequota.yaml><code>policy/priority-class-resourcequota.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("policy-priority-class-resourcequota-yaml")' title="Copy policy/priority-class-resourcequota.yaml to clipboard"></img></div><div class=includecode id=policy-priority-class-resourcequota-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ResourceQuota<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pods-cluster-services<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scopeSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>operator </span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>scopeName</span>:<span style=color:#bbb> </span>PriorityClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;cluster-services&#34;</span>]</span></span></code></pre></div></div></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/policy/priority-class-resourcequota.yaml -n kube-system
</span></span></code></pre></div><pre tabindex=0><code class=language-none data-lang=none>resourcequota/pods-cluster-services created
</code></pre><p>Nesse caso, a criação de um pod será permitida se:</p><ol><li>O <code>priorityClassName</code> do pod não foi especificado.</li><li>O <code>priorityClassName</code> do pod é especificado com um valor diferente de <code>cluster-services</code>.</li><li>O <code>priorityClassName</code> do pod está definido como <code>cluster-services</code>, ele deve ser criado no namespace <code>kube-system</code> e passou na verificação de cota de recursos.</li></ol><p>Uma solicitação de criação de pod é rejeitada caso seu <code>priorityClassName</code> estiver definido como <code>cluster-services</code> e deve ser criado em um <em>namespace</em> diferente de <code>kube-system</code>.</p><h2 id=próximos-passos>Próximos passos</h2><ul><li>Veja o <a href=https://git.k8s.io/community/contributors/design-proposals/resource-management/admission_control_resource_quota.md>documento de design de cota de recursos</a> para mais informações.</li><li>Veja um <a href=/docs/tasks/administer-cluster/quota-api-object/>exemplo detalhado de como usar a cota de recursos</a>.</li><li>Leia o <a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/scheduling/pod-priority-resourcequota.md>documento de design de suporte de cota para prioridade de classe</a>.</li><li>Veja <a href=https://github.com/kubernetes/kubernetes/pull/36765>recursos limitados</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-285a3785fd3d20f437c28d87ca4dadca>3.10 - Administração de Cluster</h1><div class=lead>Detalhes de baixo nível relevantes para criar ou administrar um cluster Kubernetes.</div><p>A visão geral da administração do cluster é para qualquer pessoa que crie ou administre um cluster do Kubernetes.
É pressuposto alguma familiaridade com os <a href=/docs/concepts>conceitos</a> principais do Kubernetes.</p><h2 id=planejando-um-cluster>Planejando um cluster</h2><p>Consulte os guias em <a href=/docs/setup>Configuração</a> para exemplos de como planejar, instalar e configurar clusters Kubernetes. As soluções listadas neste artigo são chamadas de <em>distros</em>.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Nem todas as distros são mantidas ativamente. Escolha distros que foram testadas com uma versão recente do Kubernetes.</div><p>Antes de escolher um guia, aqui estão algumas considerações:</p><ul><li>Você quer experimentar o Kubernetes em seu computador ou deseja criar um cluster de vários nós com alta disponibilidade? Escolha as distros mais adequadas ás suas necessidades.</li><li>Você vai usar um <strong>cluster Kubernetes gerenciado</strong> , como o <a href=https://cloud.google.com/kubernetes-engine/>Google Kubernetes Engine</a>, ou <strong>vai hospedar seu próprio cluster</strong>?</li><li>Seu cluster será <strong>local</strong>, ou <strong>na nuvem (IaaS)</strong>? O Kubernetes não oferece suporte direto a clusters híbridos. Em vez disso, você pode configurar vários clusters.</li><li><strong>Se você estiver configurando o Kubernetes local</strong>, leve em consideração qual <a href=/docs/concepts/cluster-Administration/networking>modelo de rede</a> se encaixa melhor.</li><li>Você vai executar o Kubernetes em um hardware <strong>bare metal</strong> ou em <strong>máquinas virtuais? (VMs)</strong>?</li><li>Você <strong>deseja apenas executar um cluster</strong> ou espera <strong>participar ativamente do desenvolvimento do código do projeto Kubernetes</strong>? Se for a segunda opção,
escolha uma distro desenvolvida ativamente. Algumas distros usam apenas versão binária, mas oferecem uma maior variedade de opções.</li><li>Familiarize-se com os <a href=/docs/concepts/overview/components/>componentes</a> necessários para executar um cluster.</li></ul><h2 id=gerenciando-um-cluster>Gerenciando um cluster</h2><ul><li>Aprenda como <a href=/docs/concepts/architecture/nodes/>gerenciar nós</a>.</li><li>Aprenda a configurar e <a href=/docs/concepts/policy/resource-quotas/>gerenciar a quota de recursos</a> para clusters compartilhados.</li></ul><h2 id=protegendo-um-cluster>Protegendo um cluster</h2><ul><li><p><a href=/docs/tasks/administer-cluster/certificates/>Gerar Certificados</a> descreve os passos para gerar certificados usando diferentes cadeias de ferramentas.</p></li><li><p><a href=/docs/concepts/containers/container-environment/>Ambiente de Contêineres do Kubernetes</a> descreve o ambiente para contêineres gerenciados pelo kubelet em um nó Kubernetes.</p></li><li><p><a href=/docs/concepts/security/controlling-access>Controle de Acesso a API do Kubernetes</a> descreve como o Kubernetes implementa o controle de acesso para sua própria API.</p></li><li><p><a href=/docs/reference/access-authn-authz/authentication/>Autenticação</a> explica a autenticação no Kubernetes, incluindo as várias opções de autenticação.</p></li><li><p><a href=/docs/reference/access-authn-authz/authorization/>Autorização</a> é separado da autenticação e controla como as chamadas HTTP são tratadas.</p></li><li><p><a href=/docs/reference/access-authn-authz/admission-controllers/>Usando Controladores de Admissão</a> explica plugins que interceptam requisições para o servidor da API Kubernetes após
a autenticação e autorização.</p></li><li><p><a href=/docs/tasks/administer-cluster/sysctl-cluster/>usando Sysctl em um Cluster Kubernetes</a> descreve a um administrador como usar a ferramenta de linha de comando <code>sysctl</code> para
definir os parâmetros do kernel.</p></li><li><p><a href=/docs/tasks/debug-application-cluster/audit/>Auditoria</a> descreve como interagir com <em>logs</em> de auditoria do Kubernetes.</p></li></ul><h3 id=protegendo-o-kubelet>Protegendo o kubelet</h3><ul><li><a href=/docs/concepts/architecture/control-plane-node-communication/>Comunicação Control Plane-Nó</a></li><li><a href=/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/>TLS bootstrapping</a></li><li><a href=/docs/reference/command-line-tools-reference/kubelet-authentication-authorization/>Autenticação/autorização do kubelet</a></li></ul><h2 id=serviços-opcionais-para-o-cluster>Serviços Opcionais para o Cluster</h2><ul><li><p><a href=/docs/concepts/services-networking/dns-pod-service/>Integração com DNS</a> descreve como resolver um nome DNS diretamente para um serviço Kubernetes.</p></li><li><p><a href=/docs/concepts/cluster-administration/logging/>Registro e Monitoramento da Atividade do Cluster</a> explica como funciona o <em>logging</em> no Kubernetes e como implementá-lo.</p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-fb494ea3b1874bd753dcd11c3f35c2dc>3.10.1 - Visão Geral da Administração de Cluster</h1><p>A visão geral da administração de cluster é para qualquer um criando ou administrando um cluster Kubernetes. Assume-se que você tenha alguma familiaridade com os <a href=/docs/concepts/>conceitos</a> centrais do Kubernetes.</p><h2 id=planejando-um-cluster>Planejando um cluster</h2><p>Veja os guias em <a href=/docs/setup/>Setup</a> para exemplos de como planejar, iniciar e configurar clusters Kubernetes. As soluções listadas neste artigo são chamadas <em>distros</em>.</p><p>Antes de escolher um guia, aqui estão algumas considerações.</p><ul><li><p>Você quer experimentar o Kubernetes no seu computador, ou você quer construir um cluster de alta disponibilidade e multi-nós? Escolha as distros mais adequadas às suas necessidades.</p></li><li><p><strong>Se você esta projetando para alta-disponibilidade</strong>, saiba mais sobre configuração <a href=/docs/concepts/cluster-administration/federation/>clusters em múltiplas zonas</a>.</p></li><li><p>Você usará <strong>um cluster Kubernetes hospedado</strong>, como <a href=https://cloud.google.com/kubernetes-engine/>Google Kubernetes Engine</a>, ou <strong>hospedará seu próprio cluster</strong>?</p></li><li><p>Seu cluster será <strong>on-premises</strong>, ou <strong>in the cloud (IaaS)</strong>? Kubernetes não suporta diretamente clusters híbridos. Em vez disso, você pode configurar vários clusters.</p></li><li><p><strong>Se você estiver configurando um Kubernetes on-premisess</strong>, considere qual <a href=/docs/concepts/cluster-administration/networking/>modelo de rede</a> melhor se adequa.</p></li><li><p>Você estará executando o Kubernetes em hardware <strong>"bare metal"</strong> ou em <strong>máquinas virtuais (VMs)</strong>?</p></li><li><p>Você <strong>quer apenas rodar um cluster</strong>, ou você espera fazer <strong>desenvolvimento ativo do código de projeto do Kubernetes</strong>? Se for a segunda opção, escolha uma distro mais ativa. Algumas distros fornecem apenas binários, mas oferecem uma maior variedade de opções.</p></li><li><p>Familiarize-se com os <a href=/docs/admin/cluster-components/>componentes</a> necessários para rodar um cluster.</p></li></ul><p>Nota: Nem todas as distros são ativamente mantidas. Escolha as distros que foram testadas com uma versão recente do Kubernetes.</p><h2 id=gerenciando-um-cluster>Gerenciando um cluster</h2><ul><li><p><a href=/docs/tasks/administer-cluster/cluster-management/>Gerenciando um cluster</a> descreve vários tópicos relacionados ao ciclo de vida de um cluster: criando um novo cluster, atualizando o nó mestre e os nós de trabalho do cluster, executando manutenção de nó (por exemplo, atualizações de kernel) e atualizando a versão da API do Kubernetes de um cluster em execução.</p></li><li><p>Aprender como <a href=/docs/concepts/nodes/node/>gerenciar um nó</a>.</p></li><li><p>Aprender como configurar e gerenciar o <a href=/docs/concepts/policy/resource-quotas/>recurso de quota</a> para um cluster compartilhado.</p></li></ul><h2 id=protegendo-um-cluster>Protegendo um cluster</h2><ul><li><p><a href=/docs/concepts/cluster-administration/certificates/>Certificados</a> descreve as etapas para gerar certificados usando diferentes ferramentas.</p></li><li><p><a href=/docs/concepts/containers/container-environment-variables/>Ambiente de Container Kubernetes</a> descreve o ambiente para contêineres gerenciados pelo Kubelet em um nó do Kubernetes.</p></li><li><p><a href=/docs/reference/access-authn-authz/controlling-access/>Controlando Acesso a API Kubernetes API</a> descreve como configurar
a permissão para usuários e contas de serviço.</p></li><li><p><a href=/docs/reference/access-authn-authz/authentication/>Autenticando</a> explica a autenticação no Kubernetes, incluindo as várias opções de autenticação.</p></li><li><p><a href=/docs/reference/access-authn-authz/authorization/>Autorização</a> é separada da autenticação e controla como as chamadas HTTP são tratadas.</p></li><li><p><a href=/docs/reference/access-authn-authz/admission-controllers/>Usando Controladores de Admissão</a> explica plug-ins que interceptam solicitações ao servidor da API do Kubernetes após autenticação e autorização.</p></li><li><p><a href=/docs/concepts/cluster-administration/sysctl-cluster/>Usando Sysctls em um Cluster Kubernetes</a> descreve a um administrador como usar a ferramenta de linha de comando <code>sysctl</code> para definir os parâmetros do kernel.</p></li><li><p><a href=/docs/tasks/debug-application-cluster/audit/>Auditando</a>
descreve como interagir com os logs de auditoria do Kubernetes.</p></li></ul><h3 id=protegendo-o-kubelet>Protegendo o kubelet</h3><ul><li><a href=/docs/concepts/architecture/master-node-communication/>Comunicação Master-Node</a></li><li><a href=/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/>TLS bootstrapping</a></li><li><a href=/docs/admin/kubelet-authentication-authorization/>Autenticação/Autorização Kubelet</a></li></ul><h2 id=serviços-opcionais-do-cluster>Serviços Opcionais do Cluster</h2><ul><li><p><a href=/docs/concepts/services-networking/dns-pod-service/>Integração DNS</a> descreve como resolver um nome DNS diretamente para um serviço do Kubernetes.</p></li><li><p><a href=/docs/concepts/cluster-administration/logging/>Logando e monitorando a atividade de cluster</a> explica como o log funciona no Kubernetes e como implementá-lo.</p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-2bf9a93ab5ba014fb6ff70b22c29d432>3.10.2 - Certificates</h1><p>Ao usar um client para autenticação de certificado, você pode gerar certificados
manualmente através <code>easyrsa</code>, <code>openssl</code> ou <code>cfssl</code>.</p><h3 id=easyrsa>easyrsa</h3><p><strong>easyrsa</strong> pode gerar manualmente certificados para o seu cluster.</p><ol><li><p>Baixe, descompacte e inicialize a versão corrigida do easyrsa3.</p><pre><code>curl -LO https://storage.googleapis.com/kubernetes-release/easy-rsa/easy-rsa.tar.gz
tar xzf easy-rsa.tar.gz
cd easy-rsa-master/easyrsa3
./easyrsa init-pki
</code></pre></li><li><p>Gerar o CA. (<code>--batch</code> set automatic mode. <code>--req-cn</code> default CN to use.)</p><pre><code>./easyrsa --batch &quot;--req-cn=${MASTER_IP}@`date +%s`&quot; build-ca nopass
</code></pre></li><li><p>Gere o certificado e a chave do servidor.
O argumento <code>--subject-alt-name</code> define os possíveis IPs e nomes (DNS) que o servidor de API usará para ser acessado. O <code>MASTER_CLUSTER_IP</code> é geralmente o primeiro IP do serviço CIDR que é especificado como argumento em <code>--service-cluster-ip-range</code> para o servidor de API e o componente gerenciador do controlador. O argumento <code>--days</code> é usado para definir o número de dias após o qual o certificado expira.
O exemplo abaixo também assume que você está usando <code>cluster.local</code> como DNS de domínio padrão</p><pre><code>./easyrsa --subject-alt-name=&quot;IP:${MASTER_IP},&quot;\
&quot;IP:${MASTER_CLUSTER_IP},&quot;\
&quot;DNS:kubernetes,&quot;\
&quot;DNS:kubernetes.default,&quot;\
&quot;DNS:kubernetes.default.svc,&quot;\
&quot;DNS:kubernetes.default.svc.cluster,&quot;\
&quot;DNS:kubernetes.default.svc.cluster.local&quot; \
--days=10000 \
build-server-full server nopass
</code></pre></li><li><p>Copie <code>pki/ca.crt</code>, <code>pki/issued/server.crt</code>, e <code>pki/private/server.key</code> para o seu diretório.</p></li><li><p>Preencha e adicione os seguintes parâmetros aos parâmetros de inicialização do servidor de API:</p><pre><code>--client-ca-file=/yourdirectory/ca.crt
--tls-cert-file=/yourdirectory/server.crt
--tls-private-key-file=/yourdirectory/server.key
</code></pre></li></ol><h3 id=openssl>openssl</h3><p><strong>openssl</strong> pode gerar manualmente certificados para o seu cluster.</p><ol><li><p>Gere um ca.key com 2048bit:</p><pre><code>openssl genrsa -out ca.key 2048
</code></pre></li><li><p>De acordo com o ca.key, gere um ca.crt (use -days para definir o tempo efetivo do certificado):</p><pre><code> openssl req -x509 -new -nodes -key ca.key -subj &quot;/CN=${MASTER_IP}&quot; -days 10000 -out ca.crt
</code></pre></li><li><p>Gere um server.key com 2048bit:</p><pre><code>openssl genrsa -out server.key 2048
</code></pre></li><li><p>Crie um arquivo de configuração para gerar uma solicitação de assinatura de certificado (CSR - Certificate Signing Request). Certifique-se de substituir os valores marcados com colchetes angulares (por exemplo, <code>&lt;MASTER_IP></code>) com valores reais antes de salvá-lo em um arquivo (por exemplo, <code>csr.conf</code>). Note que o valor para o <code>MASTER_CLUSTER_IP</code> é o IP do cluster de serviços para o Servidor de API, conforme descrito na subseção anterior. O exemplo abaixo também assume que você está usando <code>cluster.local</code> como DNS de domínio padrão</p><pre><code>[ req ]
default_bits = 2048
prompt = no
default_md = sha256
req_extensions = req_ext
distinguished_name = dn

[ dn ]
C = &lt;country&gt;
ST = &lt;state&gt;
L = &lt;city&gt;
O = &lt;organization&gt;
OU = &lt;organization unit&gt;
CN = &lt;MASTER_IP&gt;

[ req_ext ]
subjectAltName = @alt_names

[ alt_names ]
DNS.1 = kubernetes
DNS.2 = kubernetes.default
DNS.3 = kubernetes.default.svc
DNS.4 = kubernetes.default.svc.cluster
DNS.5 = kubernetes.default.svc.cluster.local
IP.1 = &lt;MASTER_IP&gt;
IP.2 = &lt;MASTER_CLUSTER_IP&gt;

[ v3_ext ]
authorityKeyIdentifier=keyid,issuer:always
basicConstraints=CA:FALSE
keyUsage=keyEncipherment,dataEncipherment
extendedKeyUsage=serverAuth,clientAuth
subjectAltName=@alt_names
</code></pre></li><li><p>Gere a solicitação de assinatura de certificado com base no arquivo de configuração:</p><pre><code>openssl req -new -key server.key -out server.csr -config csr.conf
</code></pre></li><li><p>Gere o certificado do servidor usando o ca.key, ca.crt e server.csr:</p><pre><code>openssl x509 -req -in server.csr -CA ca.crt -CAkey ca.key \
-CAcreateserial -out server.crt -days 10000 \
-extensions v3_ext -extfile csr.conf
</code></pre></li><li><p>Veja o certificado:</p><pre><code>openssl x509  -noout -text -in ./server.crt
</code></pre></li></ol><p>Por fim, adicione os mesmos parâmetros nos parâmetros iniciais do Servidor de API.</p><h3 id=cfssl>cfssl</h3><p><strong>cfssl</strong> é outra ferramenta para geração de certificados.</p><ol><li><p>Baixe, descompacte e prepare as ferramentas de linha de comando, conforme mostrado abaixo. Observe que você pode precisar adaptar os comandos de exemplo abaixo com base na arquitetura do hardware e versão cfssl que você está usando.</p><pre><code>curl -L https://pkg.cfssl.org/R1.2/cfssl_linux-amd64 -o cfssl
chmod +x cfssl
curl -L https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64 -o cfssljson
chmod +x cfssljson
curl -L https://pkg.cfssl.org/R1.2/cfssl-certinfo_linux-amd64 -o cfssl-certinfo
chmod +x cfssl-certinfo
</code></pre></li><li><p>Crie um diretório para conter os artefatos e inicializar o cfssl:</p><pre><code>mkdir cert
cd cert
../cfssl print-defaults config &gt; config.json
../cfssl print-defaults csr &gt; csr.json
</code></pre></li><li><p>Crie um arquivo de configuração JSON para gerar o arquivo CA, por exemplo, <code>ca-config.json</code>:</p><pre><code>{
  &quot;signing&quot;: {
    &quot;default&quot;: {
      &quot;expiry&quot;: &quot;8760h&quot;
    },
    &quot;profiles&quot;: {
      &quot;kubernetes&quot;: {
        &quot;usages&quot;: [
          &quot;signing&quot;,
          &quot;key encipherment&quot;,
          &quot;server auth&quot;,
          &quot;client auth&quot;
        ],
        &quot;expiry&quot;: &quot;8760h&quot;
      }
    }
  }
}
</code></pre></li><li><p>Crie um arquivo de configuração JSON para o CA - solicitação de assinatura de certificado (CSR - Certificate Signing Request), por exemplo, <code>ca-csr.json</code>. Certifique-se de substituir os valores marcados com colchetes angulares por valores reais que você deseja usar.</p><pre><code>{
  &quot;CN&quot;: &quot;kubernetes&quot;,
  &quot;key&quot;: {
    &quot;algo&quot;: &quot;rsa&quot;,
    &quot;size&quot;: 2048
  },
  &quot;names&quot;:[{
    &quot;C&quot;: &quot;&lt;country&gt;&quot;,
    &quot;ST&quot;: &quot;&lt;state&gt;&quot;,
    &quot;L&quot;: &quot;&lt;city&gt;&quot;,
    &quot;O&quot;: &quot;&lt;organization&gt;&quot;,
    &quot;OU&quot;: &quot;&lt;organization unit&gt;&quot;
  }]
}
</code></pre></li><li><p>Gere a chave CA (<code>ca-key.pem</code>) e o certificado (<code>ca.pem</code>):</p><pre><code>../cfssl gencert -initca ca-csr.json | ../cfssljson -bare ca
</code></pre></li><li><p>Crie um arquivo de configuração JSON para gerar chaves e certificados para o Servidor de API, por exemplo, <code>server-csr.json</code>. Certifique-se de substituir os valores entre colchetes angulares por valores reais que você deseja usar. O <code>MASTER_CLUSTER_IP</code> é o IP do serviço do cluster para o servidor da API, conforme descrito na subseção anterior. O exemplo abaixo também assume que você está usando <code>cluster.local</code> como DNS de domínio padrão</p><pre><code>{
  &quot;CN&quot;: &quot;kubernetes&quot;,
  &quot;hosts&quot;: [
    &quot;127.0.0.1&quot;,
    &quot;&lt;MASTER_IP&gt;&quot;,
    &quot;&lt;MASTER_CLUSTER_IP&gt;&quot;,
    &quot;kubernetes&quot;,
    &quot;kubernetes.default&quot;,
    &quot;kubernetes.default.svc&quot;,
    &quot;kubernetes.default.svc.cluster&quot;,
    &quot;kubernetes.default.svc.cluster.local&quot;
  ],
  &quot;key&quot;: {
    &quot;algo&quot;: &quot;rsa&quot;,
    &quot;size&quot;: 2048
  },
  &quot;names&quot;: [{
    &quot;C&quot;: &quot;&lt;country&gt;&quot;,
    &quot;ST&quot;: &quot;&lt;state&gt;&quot;,
    &quot;L&quot;: &quot;&lt;city&gt;&quot;,
    &quot;O&quot;: &quot;&lt;organization&gt;&quot;,
    &quot;OU&quot;: &quot;&lt;organization unit&gt;&quot;
  }]
}
</code></pre></li><li><p>Gere a chave e o certificado para o Servidor de API, que são, por padrão, salvos nos arquivos <code>server-key.pem</code> e<code> server.pem</code> respectivamente:</p><pre><code>../cfssl gencert -ca=ca.pem -ca-key=ca-key.pem \
--config=ca-config.json -profile=kubernetes \
server-csr.json | ../cfssljson -bare server
</code></pre></li></ol><h2 id=distribuindo-certificado-ca-auto-assinado>Distribuindo Certificado CA auto assinado</h2><p>Um nó cliente pode se recusar a reconhecer o certificado CA self-signed como válido.
Para uma implementação de não produção ou para uma instalação que roda atrás de um firewall, você pode distribuir certificados auto-assinados para todos os clientes e atualizar a lista de certificados válidos.</p><p>Em cada cliente, execute as seguintes operações:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo cp ca.crt /usr/local/share/ca-certificates/kubernetes.crt
</span></span><span style=display:flex><span>sudo update-ca-certificates
</span></span></code></pre></div><pre tabindex=0><code>Updating certificates in /etc/ssl/certs...
1 added, 0 removed; done.
Running hooks in /etc/ca-certificates/update.d....
done.
</code></pre><h2 id=api-de-certificados>API de certificados</h2><p>Você pode usar a API <code>certificates.k8s.io</code> para provisionar
certificados x509 a serem usados ​​para autenticação conforme documentado
<a href=/docs/tasks/tls/managing-tls-in-a-cluster>aqui</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-d649067a69d8d5c7e71564b42b96909e>3.10.3 - Conectividade do Cluster</h1><p>Conectividade é uma parte central do Kubernetes, mas pode ser desafiador
entender exatamente como é o seu funcionamento esperado. Existem 4 problemas
distintos em conectividade que devem ser tratados:</p><ol><li>Comunicações contêiner-para-contêiner altamente acopladas: Isso é resolvido
por <a class=glossary-tooltip title='O menor e mais simples objeto Kubernetes. Um Pod representa um conjunto de contêineres em execução no seu cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/ target=_blank aria-label=Pods>Pods</a> e comunicações através do <code>localhost</code>.</li><li>Comunicações pod-para-pod: Esse é o foco primário desse documento.</li><li>Comunicações pod-para-serviço (<em>service</em>): Isso é tratado em <a href=/docs/concepts/services-networking/service/>Services</a>.</li><li>Comunicações Externas-para-serviços: Isso é tratado em <a href=/docs/concepts/services-networking/service/>services</a>.</li></ol><p>Kubernetes é basicamente o compartilhamento de máquinas entre aplicações. Tradicionalmente,
compartilhar máquinas requer a garantia de que duas aplicações não tentem utilizar
as mesmas portas. Coordenar a alocação de portas entre múltiplos desenvolvedores é
muito dificil de fazer em escala e expõe os usuários a problemas em nível do cluster e
fora de seu controle.</p><p>A alocação dinâmica de portas traz uma série de complicações para o sistema - toda
aplicação deve obter suas portas através de flags de configuração, os servidores de API
devem saber como inserir números dinämicos de portas nos blocos de configuração, serviços
precisam saber como buscar um ao outro, etc. Ao invés de lidar com isso, o Kubernetes
faz de uma maneira diferente.</p><h2 id=o-modelo-de-conectividade-e-rede-do-kubernetes>O modelo de conectividade e rede do Kubernetes</h2><p>Todo <code>Pod</code> obtém seu próprio endereço IP. Isso significa que vocë não precisa
criar links explícitos entre os <code>Pods</code> e vocë quase nunca terá que lidar com o
mapeamento de portas de contêineres para portas do host. Isso cria um modelo simples,
retro-compatível onde os <code>Pods</code> podem ser tratados muito mais como VMs ou hosts
físicos da perspectiva de alocação de portas, nomes, descobrimento de serviços
(<em>service discovery</em>), balanceamento de carga, configuração de aplicações e migrações.</p><p>O Kubernetes impõe os seguintes requisitos fundamentais para qualquer implementação de
rede (exceto qualquer política de segmentação intencional):</p><ul><li>pods em um nó podem se comunicar com todos os pods em todos os nós sem usar <em>NAT</em>.</li><li>agentes em um nó (por exemplo o kubelet ou um serviço local) podem se comunicar com
todos os Pods naquele nó.</li></ul><p>Nota: Para as plataformas que suportam <code>Pods</code> executando na rede do host (como o Linux):</p><ul><li>pods alocados na rede do host de um nó podem se comunicar com todos os pods
em todos os nós sem <em>NAT</em>.</li></ul><p>Esse modelo não só é menos complexo, mas é principalmente compatível com o
desejo do Kubernetes de permitir a portabilidade com baixo esforço de aplicações
de VMs para contêineres. Se a sua aplicação executava anteriormente em uma VM, sua VM
possuía um IP e podia se comunicar com outras VMs no seu projeto. Esse é o mesmo
modelo básico.</p><p>Os endereços de IP no Kubernetes existem no escopo do <code>Pod</code> - contêineres em um <code>Pod</code>
compartilham o mesmo <em>network namespace</em> - incluíndo seu endereço de IP e MAC.
Isso significa que contêineres que compõem um <code>Pod</code> podem se comunicar entre eles
através do endereço <code>localhost</code> e respectivas portas. Isso também significa que
contêineres em um mesmo <code>Pod</code> devem coordenar a alocação e uso de portas, o que não
difere do modelo de processos rodando dentro de uma mesma VM. Isso é chamado de
modelo "IP-por-pod".</p><p>Como isso é implementado é um detalhe do agente de execução de contêiner em uso.</p><p>É possível solicitar uma porta no nó que será encaminhada para seu <code>Pod</code> (chamado
de <em>portas do host</em>), mas isso é uma operação muito específica. Como esse encaminhamento
é implementado é um detalhe do agente de execução do contêiner. O <code>Pod</code> mesmo
desconhece a existência ou não de portas do host.</p><h2 id=como-implementar-o-modelo-de-conectividade-do-kubernetes>Como implementar o modelo de conectividade do Kubernetes</h2><p>Existe um número de formas de implementar esse modelo de conectividade. Esse
documento não é um estudo exaustivo desses vários métodos, mas pode servir como
uma introdução de várias tecnologias e serve como um ponto de início.</p><p>A conectividade no Kubernetes é fornecida através de plugins de
<a class=glossary-tooltip title='Plugins Container network interface (CNI) são um tipo de plugin de Rede em conformidade com a especificação appc/CNI.' data-toggle=tooltip data-placement=top href=/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/ target=_blank aria-label=CNIs>CNIs</a></p><p>As seguintes opções estão organizadas alfabeticamente e não implicam preferência por
qualquer solução.</p><div class="alert alert-secondary callout third-party-content" role=alert><strong>Nota:</strong>
Esta seção tem links para projetos de terceiros que fornecem a funcionalidade exigida pelo Kubernetes. Os autores do projeto Kubernetes não são responsáveis por esses projetos. Esta página obedece as <a href=https://github.com/cncf/foundation/blob/master/website-guidelines.md target=_blank>diretrizes de conteúdo do site CNCF</a>, listando os itens em ordem alfabética. Para adicionar um projeto a esta lista, leia o <a href=/docs/contribute/style/content-guide/#third-party-content>guia de conteúdo</a> antes de enviar sua alteração.</div><h3 id=antrea>Antrea</h3><p>O projeto <a href=https://github.com/vmware-tanzu/antrea>Antrea</a> é uma solução de
conectividade para Kubernetes que pretende ser nativa. Ela utiliza o Open vSwitch
na camada de conectividade de dados. O Open vSwitch é um switch virtual de alta
performance e programável que suporta Linux e Windows. O Open vSwitch permite
ao Antrea implementar políticas de rede do Kubernetes (<em>NetworkPolicies</em>) de
uma forma muito performática e eficiente.</p><p>Graças à característica programável do Open vSwitch, o Antrea consegue implementar
uma série de funcionalidades de rede e segurança.</p><h3 id=aws-vpc-cni-para-kubernetes>AWS VPC CNI para Kubernetes</h3><p>O <a href=https://github.com/aws/amazon-vpc-cni-k8s>AWS VPC CNI</a> oferece conectividade
com o AWS Virtual Private Cloud (VPC) para clusters Kubernetes. Esse plugin oferece
alta performance e disponibilidade e baixa latência. Adicionalmente, usuários podem
aplicar as melhores práticas de conectividade e segurança existentes no AWS VPC
para a construção de clusters Kubernetes. Isso inclui possibilidade de usar o
<em>VPC flow logs</em>, políticas de roteamento da VPC e grupos de segurança para isolamento
de tráfego.</p><p>O uso desse plugin permite aos Pods no Kubernetes ter o mesmo endereço de IP dentro do
pod como se eles estivessem dentro da rede do VPC. O CNI (Container Network Interface)
aloca um <em>Elastic Networking Interface</em> (ENI) para cada nó do Kubernetes e usa uma
faixa de endereços IP secundário de cada ENI para os Pods no nó. O CNI inclui
controles para pré alocação dos ENIs e endereços IP para um início mais rápido dos
pods e permite clusters com até 2,000 nós.</p><p>Adicionalmente, esse CNI pode ser utilizado junto com o <a href=https://docs.aws.amazon.com/eks/latest/userguide/calico.html>Calico</a>
para a criação de políticas de rede (<em>NetworkPolicies</em>). O projeto AWS VPC CNI
tem código fonte aberto com a <a href=https://github.com/aws/amazon-vpc-cni-k8s>documentação no Github</a>.</p><h3 id=azure-cni-para-o-kubernetes>Azure CNI para o Kubernetes</h3><p><a href=https://docs.microsoft.com/en-us/azure/virtual-network/container-networking-overview>Azure CNI</a> é um
plugin de <a href=https://github.com/Azure/azure-container-networking/blob/master/docs/cni.md>código fonte aberto</a>
que integra os Pods do Kubernetes com uma rede virtual da Azure (também conhecida como VNet)
provendo performance de rede similar à de máquinas virtuais no ambiente. Os Pods
podem se comunicar com outras VNets e com ambientes <em>on-premises</em> com o uso de
funcionalidades da Azure, e também podem ter clientes com origem dessas redes.
Os Pods podem acessar serviços da Azure, como armazenamento e SQL, que são
protegidos por <em>Service Endpoints</em> e <em>Private Link</em>. Você pode utilizar as políticas
de segurança e roteamento para filtrar o tráfico do Pod. O plugin associa IPs da VNet
para os Pods utilizando um pool de IPs secundário pré-configurado na interface de rede
do nó Kubernetes.</p><p>O Azure CNI está disponível nativamente no <a href=https://docs.microsoft.com/en-us/azure/aks/configure-azure-cni>Azure Kubernetes Service (AKS)</a>.</p><h3 id=calico>Calico</h3><p><a href=https://docs.projectcalico.org/>Calico</a> é uma solução de conectividade e
segurança para contêineres, máquinas virtuais e serviços nativos em hosts. O
Calico suporta múltiplas camadas de conectividade/dados, como por exemplo:
uma camada Linux eBPF nativa, uma camada de conectividade baseada em conceitos
padrão do Linux e uma camada baseada no HNS do Windows. O calico provê uma
camada completa de conectividade e rede, mas também pode ser usado em conjunto com
<a href=https://docs.projectcalico.org/networking/determine-best-networking#calico-compatible-cni-plugins-and-cloud-provider-integrations>CNIs de provedores de nuvem</a>
para permitir a criação de políticas de rede.</p><h3 id=cilium>Cilium</h3><p><a href=https://github.com/cilium/cilium>Cilium</a> é um software de código fonte aberto
para prover conectividade e segurança entre contêineres de aplicação. O Cilium
pode lidar com tráfego na camada de aplicação (ex. HTTP) e pode forçar políticas
de rede nas camadas L3-L7 usando um modelo de segurança baseado em identidade e
desacoplado do endereçamento de redes, podendo inclusive ser utilizado com outros
plugins CNI.</p><h3 id=flannel>Flannel</h3><p><a href=https://github.com/coreos/flannel#flannel>Flannel</a> é uma camada muito simples
de conectividade que satisfaz os requisitos do Kubernetes. Muitas pessoas
reportaram sucesso em utilizar o Flannel com o Kubernetes.</p><h3 id=google-compute-engine-gce>Google Compute Engine (GCE)</h3><p>Para os scripts de configuração do Google Compute Engine, <a href=https://cloud.google.com/vpc/docs/routes>roteamento
avançado</a> é usado para associar
para cada VM uma sub-rede (o padrão é <code>/24</code> - 254 IPs). Qualquer tráfico direcionado
para aquela sub-rede será roteado diretamente para a VM pela rede do GCE. Isso é
adicional ao IP principal associado à VM, que é mascarado para o acesso à Internet.
Uma <em>brige</em> Linux (chamada <code>cbr0</code>) é configurada para existir naquela sub-rede, e é
configurada no docker através da opção <code>--bridge</code>.</p><p>O Docker é iniciado com:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#b8860b>DOCKER_OPTS</span><span style=color:#666>=</span><span style=color:#b44>&#34;--bridge=cbr0 --iptables=false --ip-masq=false&#34;</span>
</span></span></code></pre></div><p>Essa <em>bridge</em> é criada pelo Kubelet (controlada pela opção <code>--network-plugin=kubenet</code>)
de acordo com a informação <code>.spec.podCIDR</code> do Nó.</p><p>O Docker irá agora alocar IPs do bloco <code>cbr-cidr</code>. Contêineres podem alcançar
outros contêineres e nós através da interface <code>cbr0</code>. Esses IPs são todos roteáveis
dentro da rede do projeto do GCE.</p><p>O GCE mesmo não sabe nada sobre esses IPs, então não irá mascará-los quando tentarem
se comunicar com a internet. Para permitir isso uma regra de IPTables é utilizada para
mascarar o tráfego para IPs fora da rede do projeto do GCE (no exemplo abaixo, 10.0.0.0/8):</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>iptables -t nat -A POSTROUTING ! -d 10.0.0.0/8 -o eth0 -j MASQUERADE
</span></span></code></pre></div><p>Por fim, o encaminhamento de IP deve ser habilitado no Kernel de forma a processar
os pacotes vindos dos contêineres:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sysctl net.ipv4.ip_forward<span style=color:#666>=</span><span style=color:#666>1</span>
</span></span></code></pre></div><p>O resultado disso tudo é que <code>Pods</code> agora podem alcançar outros <code>Pods</code> e podem também
se comunicar com a Internet.</p><h3 id=kube-router>Kube-router</h3><p><a href=https://github.com/cloudnativelabs/kube-router>Kube-router</a> é uma solução construída
que visa prover alta performance e simplicidade operacional. Kube-router provê um
proxy de serviços baseado no <a href=https://www.linuxvirtualserver.org/software/ipvs.html>LVS/IPVS</a>,
uma solução de comunicação pod-para-pod baseada em encaminhamento de pacotes Linux e sem camadas
adicionais, e funcionalidade de políticas de redes baseadas no IPTables/IPSet.</p><h3 id=redes-l2-e-bridges-linux>Redes L2 e bridges Linux</h3><p>Se você tem uma rede L2 "burra", como um switch em um ambiente "bare-metal",
você deve conseguir fazer algo similar ao ambiente GCE explicado acima.
Note que essas instruções foram testadas casualmente - parece funcionar, mas
não foi propriamente testado. Se você conseguir usar essa técnica e aperfeiçoar
o processo, por favor nos avise!!</p><p>Siga a parte <em>"With Linux Bridge devices"</em> desse
<a href=https://blog.oddbit.com/2014/08/11/four-ways-to-connect-a-docker/>tutorial super bacana</a> do
Lars Kellogg-Stedman.</p><h3 id=multus>Multus (Plugin multi redes)</h3><p>Multus é um plugin Multi CNI para
suportar a funcionalidade multi redes do Kubernetes usando objetos baseados em <a class=glossary-tooltip title='Código customizado que define um recurso a ser adicionado ao seu servidor de API Kubernetes sem a necessidade de construir um servidor customizado.' data-toggle=tooltip data-placement=top href=/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/ target=_blank aria-label=CRDs>CRDs</a>.</p><p>Multus suporta todos os <a href=https://github.com/containernetworking/plugins>plugins referência</a> (ex. <a href=https://github.com/containernetworking/plugins/tree/master/plugins/meta/flannel>Flannel</a>,
<a href=https://github.com/containernetworking/plugins/tree/master/plugins/ipam/dhcp>DHCP</a>,
<a href=https://github.com/containernetworking/plugins/tree/master/plugins/main/macvlan>Macvlan</a>)
que implementam a especificação de CNI e plugins de terceiros
(ex. <a href=https://github.com/projectcalico/cni-plugin>Calico</a>, <a href=https://github.com/weaveworks/weave>Weave</a>,
<a href=https://github.com/cilium/cilium>Cilium</a>, <a href=https://github.com/contiv/netplugin>Contiv</a>).
Adicionalmente, Multus suporta cargas de trabalho no Kubernetes que necessitem de funcionalidades como
<a href=https://github.com/hustcat/sriov-cni>SRIOV</a>, <a href=https://github.com/Intel-Corp/sriov-cni>DPDK</a>,
<a href=https://github.com/intel/vhost-user-net-plugin>OVS-DPDK & VPP</a>.</p><h3 id=ovn-open-virtual-networking>OVN (Open Virtual Networking)</h3><p>OVN é uma solução de virtualização de redes de código aberto desenvolvido pela
comunidade Open vSwitch. Permite a criação de switches lógicos, roteadores lógicos,
listas de acesso, balanceadores de carga e mais, para construir diferences topologias
de redes virtuais. Esse projeto possui um plugin específico para o Kubernetes e a
documentação em <a href=https://github.com/openvswitch/ovn-kubernetes>ovn-kubernetes</a>.</p><h2 id=próximos-passos>Próximos passos</h2><p>Design inicial do modelo de conectividade do Kubernetes e alguns planos futuros
estão descritos com maiores detalhes no
<a href=https://git.k8s.io/design-proposals-archive/network/networking.md>documento de design de redes</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-c4b1e87a84441f8a90699a345ce48d68>3.10.4 - Arquitetura de Log</h1><p>Os logs de aplicativos e sistemas podem ajudá-lo a entender o que está acontecendo dentro do seu cluster. Os logs são particularmente úteis para depurar problemas e monitorar a atividade do cluster. A maioria das aplicações modernas possui algum tipo de mecanismo de logs; como tal, a maioria dos mecanismos de contêineres também é projetada para suportar algum tipo de log. O método de log mais fácil e abrangente para aplicações em contêiner é gravar nos fluxos de saída e erro padrão.</p><p>No entanto, a funcionalidade nativa fornecida por um mecanismo de contêiner ou tempo de execução geralmente não é suficiente para uma solução completa de log. Por exemplo, se um contêiner travar, um pod for despejado ou um nó morrer, geralmente você ainda desejará acessar os logs do aplicativo. Dessa forma, os logs devem ter armazenamento e ciclo de vida separados, independentemente de nós, pods ou contêineres. Este conceito é chamado <em>cluster-level-logging</em>. O log no nível de cluster requer um back-end separado para armazenar, analisar e consultar logs. O kubernetes não fornece uma solução de armazenamento nativa para dados de log, mas você pode integrar muitas soluções de log existentes no cluster do Kubernetes.</p><p>As arquiteturas de log no nível de cluster são descritas no pressuposto de que um back-end de log esteja presente dentro ou fora do cluster. Se você não estiver interessado em ter o log no nível do cluster, ainda poderá encontrar a descrição de como os logs são armazenados e manipulados no nó para serem úteis.</p><h2 id=log-básico-no-kubernentes>Log básico no Kubernentes</h2><p>Nesta seção, você pode ver um exemplo de log básico no Kubernetes que gera dados para o fluxo de saída padrão(standard output stream). Esta demostração usa uma <a href=/examples/debug/counter-pod.yaml>especificação de pod</a> com um contêiner que grava algum texto na saída padrão uma vez por segundo.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/pt-br/examples/debug/counter-pod.yaml download=debug/counter-pod.yaml><code>debug/counter-pod.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("debug-counter-pod-yaml")' title="Copy debug/counter-pod.yaml to clipboard"></img></div><div class=includecode id=debug-counter-pod-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>counter<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>count<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[/bin/sh, -c,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:#b44>&#39;i=0; while true; do echo &#34;$i: $(date)&#34;; i=$((i+1)); sleep 1; done&#39;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Para executar este pod, use o seguinte comando:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/debug/counter-pod.yaml
</span></span></code></pre></div><p>A saída será:</p><pre tabindex=0><code>pod/counter created
</code></pre><p>Para buscar os logs, use o comando <code>kubectl logs</code>, da seguinte maneira:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl logs counter
</span></span></code></pre></div><p>A saída será:</p><pre tabindex=0><code>0: Mon Jan  1 00:00:00 UTC 2001
1: Mon Jan  1 00:00:01 UTC 2001
2: Mon Jan  1 00:00:02 UTC 2001
...
</code></pre><p>Você pode usar <code>kubectl logs</code> para recuperar logs de uma instanciação anterior de um contêiner com o sinalizador <code>--previous</code>, caso o contêiner tenha falhado. Se o seu pod tiver vários contêineres, você deverá especificar quais logs do contêiner você deseja acessar anexando um nome de contêiner ao comando. Veja a <a href=/docs/reference/generated/kubectl/kubectl-commands#logs>documentação do <code>kubectl logs</code></a> para mais destalhes.</p><h2 id=logs-no-nível-do-nó>Logs no nível do Nó</h2><p><img src=/images/docs/user-guide/logging/logging-node-level.png alt="Log no nível do nó"></p><p>Tudo o que um aplicativo em contêiner grava no <code>stdout</code> e <code>stderr</code> é tratado e redirecionado para algum lugar por dentro do mecanismo de contêiner. Por exemplo, o mecanismo de contêiner do Docker redireciona esses dois fluxos para <a href=https://docs.docker.com/engine/admin/logging/overview>um driver de log</a>, configurado no Kubernetes para gravar em um arquivo no formato json.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> O driver de log json do Docker trata cada linha como uma mensagem separada. Ao usar o driver de log do Docker, não há suporte direto para mensagens de várias linhas. Você precisa lidar com mensagens de várias linhas no nível do agente de log ou superior.</div><p>Por padrão, se um contêiner reiniciar, o kubelet manterá um contêiner terminado com seus logs. Se um pod for despejado do nó, todos os contêineres correspondentes também serão despejados, juntamente com seus logs.</p><p>Uma consideração importante no log no nível do nó está implementado a rotação de log, para que os logs não consumam todo o armazenamento disponível no nó. Atualmente, o Kubernentes não é responsável pela rotação de logs, mas uma ferramenta de deployment deve configurar uma solução para resolver isso.
Por exemplo, nos clusters do Kubernetes, implementados pelo script <code>kube-up.sh</code>, existe uma ferramenta <a href=https://linux.die.net/man/8/logrotate><code>logrotate</code></a> configurada para executar a cada hora. Você pode configurar um tempo de execução do contêiner para girar os logs do aplicativo automaticamente, por exemplo, usando o <code>log-opt</code> do Docker.
No script <code>kube-up.sh</code>, a última abordagem é usada para imagem COS no GCP, e a anterior é usada em qualquer outro ambiente. Nos dois casos por padrão, a rotação é configurada para ocorrer quando o arquivo de log exceder 10MB.</p><p>Como exemplo, você pode encontrar informações detalhadas sobre como o <code>kube-up.sh</code> define o log da imagem COS no GCP no <a href=https://github.com/kubernetes/kubernetes/blob/master/cluster/gce/gci/configure-helper.sh>script</a> correspondente.</p><p>Quando você executa <a href=/docs/reference/generated/kubectl/kubectl-commands#logs><code>kubectl logs</code></a> como no exemplo de log básico acima, o kubelet no nó lida com a solicitação e lê diretamente do arquivo de log, retornando o conteúdo na resposta.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Atualmente, se algum sistema externo executou a rotação, apenas o conteúdo do arquivo de log mais recente estará disponível através de <code>kubectl logs</code>. Por exemplo, se houver um arquivo de 10MB, o <code>logrotate</code> executa a rotação e existem dois arquivos, um com 10MB de tamanho e um vazio, o <code>kubectl logs</code> retornará uma resposta vazia.</div><h3 id=logs-de-componentes-do-sistema>Logs de componentes do sistema</h3><p>Existem dois tipos de componentes do sistema: aqueles que são executados em um contêiner e aqueles que não são executados em um contêiner. Por exemplo:</p><ul><li>O scheduler Kubernetes e o kube-proxy são executados em um contêiner.</li><li>O tempo de execução do kubelet e do contêiner, por exemplo, Docker, não é executado em contêineres.</li></ul><p>Nas máquinas com systemd, o tempo de execução do kubelet e do container é gravado no journald. Se systemd não estiver presente, eles gravam em arquivos <code>.log</code> no diretório <code>/var/log</code>.
Os componentes do sistema dentro dos contêineres sempre gravam no diretório <code>/var/log</code>, ignorando o mecanismo de log padrão. Eles usam a biblioteca de logs <a href=https://github.com/kubernetes/klog>klog</a>. Você pode encontrar as convenções para a gravidade do log desses componentes nos <a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-instrumentation/logging.md>documentos de desenvolvimento sobre log</a>.</p><p>Da mesma forma que os logs de contêiner, os logs de componentes do sistema no diretório <code>/var/log</code> devem ser rotacionados. Nos clusters do Kubernetes criados pelo script <code>kube-up.sh</code>, esses logs são configurados para serem rotacionados pela ferramenta <code>logrotate</code> diariamente ou quando o tamanho exceder 100MB.</p><h2 id=arquiteturas-de-log-no-nível-de-cluster>Arquiteturas de log no nível de cluster</h2><p>Embora o Kubernetes não forneça uma solução nativa para o log em nível de cluster, há várias abordagens comuns que você pode considerar. Aqui estão algumas opções:</p><ul><li>Use um agente de log no nível do nó que seja executado em todos os nós.</li><li>Inclua um contêiner sidecar dedicado para efetuar logging em um pod de aplicativo.</li><li>Envie logs diretamente para um back-end de dentro de um aplicativo.</li></ul><h3 id=usando-um-agente-de-log-de-nó>Usando um agente de log de nó</h3><p><img src=/images/docs/user-guide/logging/logging-with-node-agent.png alt="Usando um agente de log no nível do nó"></p><p>Você pode implementar o log em nível de cluster incluindo um <em>agente de log em nível de nó</em> em cada nó. O agente de log é uma ferramenta dedicada que expõe logs ou envia logs para um back-end. Geralmente, o agente de log é um contêiner que tem acesso a um diretório com arquivos de log de todos os contêineres de aplicativos nesse nó.</p><p>Como o agente de log deve ser executado em todos os nós, é comum implementá-lo como uma réplica do DaemonSet, um pod de manifesto ou um processo nativo dedicado no nó. No entanto, as duas últimas abordagens são obsoletas e altamente desencorajadas.</p><p>O uso de um agente de log no nível do nó é a abordagem mais comum e incentivada para um cluster Kubernetes, porque ele cria apenas um agente por nó e não requer alterações nos aplicativos em execução no nó. No entanto, o log no nível do nó <em>funciona apenas para a saída padrão dos aplicativos e o erro padrão</em>.</p><p>O Kubernetes não especifica um agente de log, mas dois agentes de log opcionais são fornecidos com a versão Kubernetes: <a href=/docs/user-guide/logging/stackdriver>Stackdriver Logging</a> para uso com o Google Cloud Platform e <a href=/docs/user-guide/logging/elasticsearch>Elasticsearch</a>. Você pode encontrar mais informações e instruções nos documentos dedicados. Ambos usam <a href=http://www.fluentd.org/>fluentd</a> com configuração customizada como um agente no nó.</p><h3 id=usando-um-contêiner-sidecar-com-o-agente-de-log>Usando um contêiner sidecar com o agente de log</h3><p>Você pode usar um contêiner sidecar de uma das seguintes maneiras:</p><ul><li>O container sidecar transmite os logs do aplicativo para seu próprio <code>stdout</code>.</li><li>O contêiner do sidecar executa um agente de log, configurado para selecionar logs de um contêiner de aplicativo.</li></ul><h4 id=streaming-sidecar-conteiner>Streaming sidecar conteiner</h4><p><img src=/images/docs/user-guide/logging/logging-with-streaming-sidecar.png alt="Conteiner sidecar com um streaming container"></p><p>Fazendo com que seus contêineres de sidecar fluam para seus próprios <code>stdout</code> e <code>stderr</code>, você pode tirar proveito do kubelet e do agente de log que já executam em cada nó. Os contêineres sidecar lêem logs de um arquivo, socket ou journald. Cada contêiner sidecar individual imprime o log em seu próprio <code>stdout</code> ou <code>stderr</code> stream.</p><p>Essa abordagem permite separar vários fluxos de logs de diferentes partes do seu aplicativo, algumas das quais podem não ter suporte para gravar em <code>stdout</code> ou <code>stderr</code>. A lógica por trás do redirecionamento de logs é mínima, portanto dificilmente representa uma sobrecarga significativa. Além disso, como <code>stdout</code> e <code>stderr</code> são manipulados pelo kubelet, você pode usar ferramentas internas como o <code>kubectl logs</code>.</p><p>Considere o seguinte exemplo. Um pod executa um único contêiner e grava em dois arquivos de log diferentes, usando dois formatos diferentes. Aqui está um arquivo de configuração para o Pod:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/pt-br/examples/admin/logging/two-files-counter-pod.yaml download=admin/logging/two-files-counter-pod.yaml><code>admin/logging/two-files-counter-pod.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-logging-two-files-counter-pod-yaml")' title="Copy admin/logging/two-files-counter-pod.yaml to clipboard"></img></div><div class=includecode id=admin-logging-two-files-counter-pod-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>counter<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>count<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- /bin/sh<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- -c<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- &gt;<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      i=0;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      while true;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      do
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        echo &#34;$i: $(date)&#34; &gt;&gt; /var/log/1.log;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        echo &#34;$(date) INFO $i&#34; &gt;&gt; /var/log/2.log;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        i=$((i+1));
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        sleep 1;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      done</span><span style=color:#bbb>      
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/log<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Seria uma bagunça ter entradas de log de diferentes formatos no mesmo fluxo de logs, mesmo se você conseguisse redirecionar os dois componentes para o fluxo <code>stdout</code> do contêiner. Em vez disso, você pode introduzir dois contêineres sidecar. Cada contêiner sidecar pode direcionar um arquivo de log específico de um volume compartilhado e depois redirecionar os logs para seu próprio fluxo <code>stdout</code>.</p><p>Aqui está um arquivo de configuração para um pod que possui dois contêineres sidecar:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/pt-br/examples/admin/logging/two-files-counter-pod-streaming-sidecar.yaml download=admin/logging/two-files-counter-pod-streaming-sidecar.yaml><code>admin/logging/two-files-counter-pod-streaming-sidecar.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-logging-two-files-counter-pod-streaming-sidecar-yaml")' title="Copy admin/logging/two-files-counter-pod-streaming-sidecar.yaml to clipboard"></img></div><div class=includecode id=admin-logging-two-files-counter-pod-streaming-sidecar-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>counter<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>count<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- /bin/sh<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- -c<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- &gt;<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      i=0;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      while true;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      do
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        echo &#34;$i: $(date)&#34; &gt;&gt; /var/log/1.log;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        echo &#34;$(date) INFO $i&#34; &gt;&gt; /var/log/2.log;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        i=$((i+1));
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        sleep 1;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      done</span><span style=color:#bbb>      
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/log<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>count-log-1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[/bin/sh, -c, &#39;tail -n+1 -f /var/log/1.log&#39;]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/log<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>count-log-2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[/bin/sh, -c, &#39;tail -n+1 -f /var/log/2.log&#39;]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/log<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Agora, quando você executa este pod, é possível acessar cada fluxo de log separadamente, executando os seguintes comandos:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl logs counter count-log-1
</span></span></code></pre></div><pre tabindex=0><code>0: Mon Jan  1 00:00:00 UTC 2001
1: Mon Jan  1 00:00:01 UTC 2001
2: Mon Jan  1 00:00:02 UTC 2001
...
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl logs counter count-log-2
</span></span></code></pre></div><pre tabindex=0><code>Mon Jan  1 00:00:00 UTC 2001 INFO 0
Mon Jan  1 00:00:01 UTC 2001 INFO 1
Mon Jan  1 00:00:02 UTC 2001 INFO 2
...
</code></pre><p>O agente no nível do nó instalado em seu cluster coleta esses fluxos de logs automaticamente sem nenhuma configuração adicional. Se desejar, você pode configurar o agente para analisar as linhas de log, dependendo do contêiner de origem.</p><p>Observe que, apesar do baixo uso da CPU e da memória (ordem de alguns milicores por CPU e ordem de vários megabytes de memória), gravar logs em um arquivo e depois transmiti-los para o <code>stdout</code> pode duplicar o uso do disco. Se você tem um aplicativo que grava em um único arquivo, geralmente é melhor definir <code>/dev/stdout</code> como destino, em vez de implementar a abordagem de contêiner de transmissão no sidecar.</p><p>Os contêineres sidecar também podem ser usados para rotacionar arquivos de log que não podem ser rotacionados pelo próprio aplicativo. Um exemplo dessa abordagem é um pequeno contêiner executando <code>logrotate</code> periodicamente.
No entanto, é recomendável usar o <code>stdout</code> e o <code>stderr</code> diretamente e deixar as políticas de rotação e retenção no kubelet.</p><h4 id=contêiner-sidecar-com-um-agente-de-log>Contêiner sidecar com um agente de log</h4><p><img src=/images/docs/user-guide/logging/logging-with-sidecar-agent.png alt="Contêiner sidecar com um agente de log"></p><p>Se o agente de log no nível do nó não for flexível o suficiente para sua situação, você poderá criar um contêiner secundário com um agente de log separado que você configurou especificamente para executar com seu aplicativo.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> O uso de um agente de log em um contêiner sidecar pode levar a um consumo significativo de recursos. Além disso, você não poderá acessar esses logs usando o comando <code>kubectl logs</code>, porque eles não são controlados pelo kubelet.</div><p>Como exemplo, você pode usar o <a href=/docs/tasks/debug-application-cluster/logging-stackdriver/>Stackdriver</a>, que usa fluentd como um agente de log. Aqui estão dois arquivos de configuração que você pode usar para implementar essa abordagem. O primeiro arquivo contém um <a href=/docs/tasks/configure-pod-container/configure-pod-configmap/>ConfigMap</a> para configurar o fluentd.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/pt-br/examples/admin/logging/fluentd-sidecar-config.yaml download=admin/logging/fluentd-sidecar-config.yaml><code>admin/logging/fluentd-sidecar-config.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-logging-fluentd-sidecar-config-yaml")' title="Copy admin/logging/fluentd-sidecar-config.yaml to clipboard"></img></div><div class=includecode id=admin-logging-fluentd-sidecar-config-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fluentd-config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>fluentd.conf</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    &lt;source&gt;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      type tail
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      format none
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      path /var/log/1.log
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      pos_file /var/log/1.log.pos
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      tag count.format1
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    &lt;/source&gt;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    &lt;source&gt;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      type tail
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      format none
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      path /var/log/2.log
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      pos_file /var/log/2.log.pos
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      tag count.format2
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    &lt;/source&gt;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    &lt;match **&gt;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      type google_cloud
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    &lt;/match&gt;</span><span style=color:#bbb>    
</span></span></span></code></pre></div></div></div><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> A configuração do fluentd está além do escopo deste artigo. Para obter informações sobre como configurar o fluentd, consulte a <a href=http://docs.fluentd.org/>documentação oficial do fluentd</a>.</div><p>O segundo arquivo descreve um pod que possui um contêiner sidecar rodando fluentemente.
O pod monta um volume onde o fluentd pode coletar seus dados de configuração.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/pt-br/examples/admin/logging/two-files-counter-pod-agent-sidecar.yaml download=admin/logging/two-files-counter-pod-agent-sidecar.yaml><code>admin/logging/two-files-counter-pod-agent-sidecar.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("admin-logging-two-files-counter-pod-agent-sidecar-yaml")' title="Copy admin/logging/two-files-counter-pod-agent-sidecar.yaml to clipboard"></img></div><div class=includecode id=admin-logging-two-files-counter-pod-agent-sidecar-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>counter<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>count<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- /bin/sh<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- -c<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- &gt;<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      i=0;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      while true;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      do
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        echo &#34;$i: $(date)&#34; &gt;&gt; /var/log/1.log;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        echo &#34;$(date) INFO $i&#34; &gt;&gt; /var/log/2.log;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        i=$((i+1));
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        sleep 1;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      done</span><span style=color:#bbb>      
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/log<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>count-agent<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/fluentd-gcp:1.30<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>FLUENTD_ARGS<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span>-c /etc/fluentd-config/fluentd.conf<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/log<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/fluentd-config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>varlog<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>configMap</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fluentd-config<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Depois de algum tempo, você pode encontrar mensagens de log na interface do Stackdriver.</p><p>Lembre-se de que este é apenas um exemplo e você pode realmente substituir o fluentd por qualquer agente de log, lendo de qualquer fonte dentro de um contêiner de aplicativo.</p><h3 id=expondo-logs-diretamente-do-aplicativo>Expondo logs diretamente do aplicativo</h3><p><img src=/images/docs/user-guide/logging/logging-from-application.png alt="Expondo logs diretamente do aplicativo"></p><p>Você pode implementar o log no nível do cluster, expondo ou enviando logs diretamente de todos os aplicativos; no entanto, a implementação desse mecanismo de log está fora do escopo do Kubernetes.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-5cc31ecfba86467f8884856412cfb6b2>3.10.5 - Logs de Sistema</h1><p>Logs de componentes do sistema armazenam eventos que acontecem no cluster, sendo muito úteis para depuração. Seus níveis de detalhe podem ser ajustados para mais ou para menos. Podendo se ater, por exemplo, a mostrar apenas os erros que ocorrem no componente, ou chegando a mostrar cada passo de um evento. (Como acessos HTTP, mudanças no estado dos pods, ações dos controllers, ou decisões do scheduler).</p><h2 id=klog>Klog</h2><p><a href=https://github.com/kubernetes/klog>Klog</a> é a biblioteca de logs do Kubernetes. Responsável por gerar as mensagens de log para os componentes do sistema.</p><p>Para mais informações acerca da sua configuração, veja a documentação da <a href=https://kubernetes.io/docs/reference/command-line-tools-reference/>ferramenta de linha de comando</a>.</p><p>Um exemplo do formato padrão dos logs da biblioteca:</p><pre tabindex=0><code>I1025 00:15:15.525108       1 httplog.go:79] GET /api/v1/namespaces/kube-system/pods/metrics-server-v0.3.1-57c75779f-9p8wg: (1.512ms) 200 [pod_nanny/v0.0.0 (linux/amd64) kubernetes/$Format 10.56.1.19:51756]
</code></pre><h3 id=logs-estruturados>Logs Estruturados</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.19 [alpha]</code></div><div class="alert alert-danger warning callout" role=alert><strong>Aviso:</strong><p>A migração pro formato de logs estruturados é um processo em andamento. Nem todos os logs estão dessa forma na versão atual. Sendo assim, para realizar o processamento de arquivos de log, você também precisa lidar com logs não estruturados.</p><p>A formatação e serialização dos logs ainda estão sujeitas a alterações.</p></div><p>A estruturação dos logs trás uma estrutura uniforme para as mensagens de log, permitindo a extração programática de informações. Logs estruturados podem ser armazenados e processados com menos esforço e custo. Esse formato é totalmente retrocompatível e é habilitado por padrão.</p><p>Formato dos logs estruturados:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ini data-lang=ini><span style=display:flex><span><span style=color:#b44>&lt;klog header&gt; &#34;&lt;message&gt;&#34; &lt;key1&gt;</span><span style=color:#666>=</span><span style=color:#b44>&#34;&lt;value1&gt;&#34; &lt;key2&gt;=&#34;&lt;value2&gt;&#34; ...</span>
</span></span></code></pre></div><p>Exemplo:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ini data-lang=ini><span style=display:flex><span><span style=color:#b44>I1025 00:15:15.525108       1 controller_utils.go:116] &#34;Pod status updated&#34; pod</span><span style=color:#666>=</span><span style=color:#b44>&#34;kube-system/kubedns&#34; status=&#34;ready&#34;</span>
</span></span></code></pre></div><h3 id=logs-em-formato-json>Logs em formato JSON</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.19 [alpha]</code></div><div class="alert alert-danger warning callout" role=alert><strong>Aviso:</strong><p>Algumas opções da biblioteca klog ainda não funcionam com os logs em formato JSON. Para ver uma lista completa de quais são estas, veja a documentação da <a href=/docs/reference/command-line-tools-reference/>ferramenta de linha de comando</a>.</p><p>Nem todos os logs estarão garantidamente em formato JSON (como por exemplo durante o início de processos). Sendo assim, se você pretende realizar o processamento dos logs, seu código deverá saber tratar também linhas que não são JSON.</p><p>O nome dos campos e a serialização JSON ainda estão sujeitos a mudanças.</p></div><p>A opção <code>--logging-format=json</code> muda o formato dos logs, do formato padrão da klog para JSON. Abaixo segue um exemplo de um log em formato JSON (identado):</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>   <span style=color:green;font-weight:700>&#34;ts&#34;</span>: <span style=color:#666>1580306777.04728</span>,
</span></span><span style=display:flex><span>   <span style=color:green;font-weight:700>&#34;v&#34;</span>: <span style=color:#666>4</span>,
</span></span><span style=display:flex><span>   <span style=color:green;font-weight:700>&#34;msg&#34;</span>: <span style=color:#b44>&#34;Pod status updated&#34;</span>,
</span></span><span style=display:flex><span>   <span style=color:green;font-weight:700>&#34;pod&#34;</span>:{
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;nginx-1&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;namespace&#34;</span>: <span style=color:#b44>&#34;default&#34;</span>
</span></span><span style=display:flex><span>   },
</span></span><span style=display:flex><span>   <span style=color:green;font-weight:700>&#34;status&#34;</span>: <span style=color:#b44>&#34;ready&#34;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Chaves com significados especiais:</p><ul><li><code>ts</code> - Data e hora no formato Unix (obrigatório, float)</li><li><code>v</code> - Nível de detalhe (obrigatório, int, padrão 0)</li><li><code>err</code> - Mensagem de erro (opcional, string)</li><li><code>msg</code> - Mensagem (obrigatório, string)</li></ul><p>Lista dos componentes que suportam o formato JSON atualmente:</p><ul><li><a class=glossary-tooltip title='Componente da camada de gerenciamento que executa os processos de controle.' data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-controller-manager/ target=_blank aria-label=kube-controller-manager>kube-controller-manager</a></li><li><a class=glossary-tooltip title='O componente da camada de gerenciamento que serve a API do Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label=kube-apiserver>kube-apiserver</a></li><li><a class=glossary-tooltip title='Componente da camada de gerenciamento que observa os pods recém-criados sem nenhum nó atribuído, e seleciona um nó para executá-los.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-scheduler/ target=_blank aria-label=kube-scheduler>kube-scheduler</a></li><li><a class=glossary-tooltip title='Um agente que é executado em cada node no cluster. Ele garante que os contêineres estejam sendo executados em um pod.' data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kubelet target=_blank aria-label=kubelet>kubelet</a></li></ul><h3 id=limpeza-dos-logs>Limpeza dos Logs</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.20 [alpha]</code></div><div class="alert alert-danger warning callout" role=alert><strong>Aviso:</strong> A funcionalidade de limpeza dos logs pode causar impactos significativos na performance, sendo portanto contraindicada em produção.</div><p>A opção <code>--experimental-logging-sanitization</code> habilita o filtro de limpeza dos logs.
Quando habilitado, esse filtro inspeciona todos os argumentos dos logs, procurando por campos contendo dados sensíveis (como senhas, chaves e tokens). Tais campos não serão expostos nas mensagens de log.</p><p>Lista dos componentes que suportam a limpeza de logs atualmente:</p><ul><li><a class=glossary-tooltip title='Componente da camada de gerenciamento que executa os processos de controle.' data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-controller-manager/ target=_blank aria-label=kube-controller-manager>kube-controller-manager</a></li><li><a class=glossary-tooltip title='O componente da camada de gerenciamento que serve a API do Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label=kube-apiserver>kube-apiserver</a></li><li><a class=glossary-tooltip title='Componente da camada de gerenciamento que observa os pods recém-criados sem nenhum nó atribuído, e seleciona um nó para executá-los.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-scheduler/ target=_blank aria-label=kube-scheduler>kube-scheduler</a></li><li><a class=glossary-tooltip title='Um agente que é executado em cada node no cluster. Ele garante que os contêineres estejam sendo executados em um pod.' data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kubelet target=_blank aria-label=kubelet>kubelet</a></li></ul><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> O filtro de limpeza dos logs não impede a exposição de dados sensíveis nos logs das aplicações em execução.</div><h3 id=nível-de-detalhe-dos-logs>Nível de detalhe dos logs</h3><p>A opção <code>-v</code> controla o nível de detalhe dos logs. Um valor maior aumenta o número de eventos registrados, começando a registrar também os eventos menos importantes. Similarmente, um valor menor restringe os logs apenas aos eventos mais importantes. O valor padrão 0 registra apenas eventos críticos.</p><h3 id=localização-dos-logs>Localização dos Logs</h3><p>Existem dois tipos de componentes do sistema: aqueles que são executados em um contêiner e aqueles que não são. Por exemplo:</p><ul><li>O <a href=https://kubernetes.io/pt-br/docs/concepts/overview/components/#kube-scheduler>Kubernetes scheduler</a> e o <a href=https://kubernetes.io/pt-br/docs/concepts/overview/components/#kube-proxy>kube-proxy</a> são executados em um contêiner.</li><li>O <a href=https://kubernetes.io/pt-br/docs/concepts/overview/components/#kubelet>kubelet</a> e os <a href=https://kubernetes.io/pt-br/docs/concepts/overview/components/#container-runtime>agentes de execução</a>, como o Docker por exemplo, não são executados em contêineres.</li></ul><p>Em máquinas com systemd, o kubelet e os agentes de execução gravam os logs no journald.
Em outros casos, eles escrevem os logs em arquivos <code>.log</code> no diretório <code>/var/log</code>.
Já os componentes executados dentro de contêineres, sempre irão escrever os logs em arquivos <code>.log</code>
no diretório <code>/var/log</code>, ignorando o mecanismo padrão de log.</p><p>De forma similar aos logs de contêiner, os logs de componentes do sistema no diretório <code>/var/log</code> devem ser rotacionados.
Nos clusters Kubernetes criados com o script <code>kube-up.sh</code>, a rotação dos logs é configurada pela ferramenta <code>logrotate</code>. Essa ferramenta rotaciona os logs diariamente
ou quando o tamanho do arquivo excede 100MB.</p><h2 id=próximos-passos>Próximos passos</h2><ul><li>Leia sobre <a href=/pt-br/docs/concepts/cluster-administration/logging/>Arquitetura de Logs do Kubernetes</a></li><li>Leia sobre <a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-instrumentation/1602-structured-logging>Logs Estruturados</a></li><li>Leia sobre <a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-instrumentation/logging.md>Convenções sobre os níveis de logs</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-cbfd3654996eae9fcdef009f70fa83f0>3.10.6 - Métricas para componentes do sistema Kubernetes</h1><p>Métricas dos componentes do sistema podem dar uma visão melhor do que acontece internamente. Métricas são particularmente úteis para construir <em>dashboards</em> e alertas.</p><p>Componentes do Kubernetes emitem métricas no <a href=https://prometheus.io/docs/instrumenting/exposition_formats/>formato Prometheus</a>. Esse formato é um texto simples estruturado, projetado para que pessoas e máquinas possam lê-lo.</p><h2 id=métricas-no-kubernetes>Métricas no Kubernetes</h2><p>Na maioria dos casos, as métricas estão disponíveis no <em>endpoint</em> <code>/metrics</code> do servidor HTTP. Para componentes que não expõem o <em>endpoint</em> por padrão, ele pode ser ativado usando a <em>flag</em> <code>--bind-address</code>.</p><p>Exemplos desses componentes:</p><ul><li><a class=glossary-tooltip title='Componente da camada de gerenciamento que executa os processos de controle.' data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-controller-manager/ target=_blank aria-label=kube-controller-manager>kube-controller-manager</a></li><li><a class=glossary-tooltip title='kube-proxy é um proxy de rede executado em cada nó do cluster.' data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-proxy/ target=_blank aria-label=kube-proxy>kube-proxy</a></li><li><a class=glossary-tooltip title='O componente da camada de gerenciamento que serve a API do Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label=kube-apiserver>kube-apiserver</a></li><li><a class=glossary-tooltip title='Componente da camada de gerenciamento que observa os pods recém-criados sem nenhum nó atribuído, e seleciona um nó para executá-los.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-scheduler/ target=_blank aria-label=kube-scheduler>kube-scheduler</a></li><li><a class=glossary-tooltip title='Um agente que é executado em cada node no cluster. Ele garante que os contêineres estejam sendo executados em um pod.' data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kubelet target=_blank aria-label=kubelet>kubelet</a></li></ul><p>Em um ambiente de produção, você pode querer configurar o <a href=https://prometheus.io/>Servidor Prometheus</a> ou algum outro coletor de métricas e disponibilizá-las em algum tipo de banco de dados temporais.</p><p>Observe que o <a class=glossary-tooltip title='Um agente que é executado em cada node no cluster. Ele garante que os contêineres estejam sendo executados em um pod.' data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kubelet target=_blank aria-label=kubelet>kubelet</a> também expõe métricas nos <em>endpoints</em> <code>/metrics/cadvisor</code>, <code>/metrics/resource</code> e <code>/metrics/probes</code>. Essas métricas não possuem o mesmo ciclo de vida.</p><p>Se o seu <em>cluster</em> usa <a class=glossary-tooltip title='Gerencia decisões de autorização, permitindo que os administradores configurem dinamicamente políticas de acesso por meio da API do Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/reference/access-authn-authz/rbac/ target=_blank aria-label=RBAC>RBAC</a>, ler as métricas requer autorização por meio de um usuário, grupo ou <em>ServiceAccount</em> com um <em>ClusterRole</em> que conceda o acesso ao <code>/metrics</code>.</p><p>Por exemplo:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>prometheus<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>nonResourceURLs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;/metrics&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- get<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=ciclo-de-vida-da-métrica>Ciclo de vida da métrica</h2><p>Métrica alfa → Métrica estável → Métrica ultrapassada → Métrica oculta → Métrica excluída</p><p>A métrica alfa não tem garantias de estabilidade. Essas métricas podem ser modificadas ou deletadas a qualquer momento.</p><p>Métricas estáveis possuem a garantia de que não serão alteradas. Isso significa:</p><ul><li>Uma métrica estável sem uma assinatura ultrapassada não será deletada ou renomeada</li><li>O tipo de uma métrica estável não será modificado</li></ul><p>As métricas ultrapassadas estão programadas para exclusão, mas ainda estão disponíveis para uso.
Essas métricas incluem uma anotação sobre a versão em que se tornarão ultrapassadas.</p><p>Por exemplo:</p><ul><li><p>Antes de se tornar ultrapassado</p><pre tabindex=0><code># HELP some_counter isso conta coisas
# TYPE some_counter contador
some_counter 0
</code></pre></li><li><p>Depois de se tornar ultrapassado</p><pre tabindex=0><code># HELP some_counter (obsoleto desde 1.15.0) isso conta coisas
# TYPE some_counter contador
some_counter 0
</code></pre></li></ul><p>Métricas ocultas não são mais publicadas para extração, mas ainda estão disponíveis para uso. Para usar uma métrica oculta, por favor consulte a seção <a href=#mostrar-m%C3%A9tricas-ocultas>mostrar métricas ocultas</a>.</p><p>Métricas excluídas não estão mais disponíveis e não podem mais ser usadas.</p><h2 id=mostrar-métricas-ocultas>Mostrar métricas ocultas</h2><p>Como descrito anteriormente, administradores podem habilitar métricas ocultas por meio de uma <em>flag</em> de linha de comando em um binário específico. Isso pode ser usado como uma saída de emergência para os administradores caso percam a migração das métricas ultrapassadas na última versão.</p><p>A <em>flag</em> <code>show-hidden-metrics-for-version</code> usa uma versão para a qual você deseja mostrar métricas ultrapassadas nessa versão. A versão é expressada como x.y, onde x é a versão principal e y a versão secundária. A versão de <em>patch</em> não é necessária mesmo que uma métrica possa ser descontinuada em uma versão de <em>patch</em>, o motivo é que a política de descontinuação de métricas é executada na versão secundária.</p><p>A <em>flag</em> só pode usar a versão secundária anterior como seu valor. Todas as métricas ocultas no anterior serão emitidas se os administradores definirem a versão anterior como <code>show-hidden-metrics-for-version</code>. A versão muito antiga não é permitida porque viola a política de métricas ultrapassadas.</p><p>Utilize a métrica <code>A</code> como exemplo, assumindo que <code>A</code> está obsoleto em 1.n. De acordo com a política de métricas ultrapassadas, podemos chegar à seguinte conclusão:</p><ul><li>Na versão <code>1.n</code>, a métrica está ultrapassada, e pode ser emitida por padrão.</li><li>Na versão <code>1.n+1</code>, a métrica está oculta por padrão e pode ser emitida via linha de comando <code>show-hidden-metrics-for-version=1.n</code>.</li><li>Na versão <code>1.n+2</code>, a métrica deve ser removida do código fonte. Não há mais <em>escape hatch</em>.</li></ul><p>Se você está atualizando da versão <code>1.12</code> para <code>1.13</code>, mas ainda depende da métrica <code>A</code> ultrapassada em <code>1.12</code>, você deve definir métricas ocultas via linha de comando: <code>--show-hidden-metrics=1.12</code> e lembre-se de remover essa dependência de métrica antes de atualizar para <code>1.14</code>.</p><h2 id=desativar-métricas-do-accelerator>Desativar métricas do <em>accelerator</em></h2><p>O kubelet coleta métricas do <em>accelerator</em> por meio do cAdvisor. Para coletar essas métricas, para <em>accelerator</em> como as GPUs NVIDIA, o kubelet mantinha uma alça aberta no driver. Isso significava que, para realizar alterações na infraestrutura (por exemplo, atualizar o <em>driver</em>), um administrador do <em>cluster</em> precisa interromper o agente kubelet.</p><p>A responsabilidade de colear métricas do <em>accelerator</em> agora pertence ao fornecedor, e não ao kubelet. Os fornecedores devem providenciar um contêiner que colete métricas e as exponha ao serviço de métricas (por exemplo, Prometheus).</p><p>O <a href=/docs/reference/command-line-tools-reference/feature-gates/><code>DisableAcceleratorUsageMetrics</code> <em>feature gate</em></a> desabilita as métricas coletadas pelo kubelet, com uma <a href=https://github.com/kubernetes/enhancements/tree/411e51027db842355bd489691af897afc1a41a5e/keps/sig-node/1867-disable-accelerator-usage-metrics#graduation-criteria><em>timeline</em> para habilitar esse recurso por padrão</a>.</p><h2 id=métricas-de-componentes>Métricas de componentes</h2><h3 id=métricas-do-kube-controller-manager>Métricas do <em>kube-controller-manager</em></h3><p>As métricas do <em>controller manager</em> fornecem informações importantes sobre o desempenho e a integridade do <em>controller manager</em>.
Essas métricas incluem métricas comuns do agente de execução da linguagem Go, tais como a quantidade de <em>go_routine</em> e métricas específicas do <em>controller</em>, como latência de requisições etcd ou latência da <em>API</em> dos provedores de serviços de nuvem (AWS, GCE, OpenStack), que podem ser usadas para medir a integridade de um <em>cluster</em>.</p><p>A partir do Kubernetes 1.7, métricas detalhadas de provedores de serviços de nuvem estão disponíveis para operações de armazenamento para o GCE, AWS, Vsphere e OpenStack.
Essas métricas podem ser usadas para monitorar a integridade das operações de volumes persistentes.</p><p>Por exemplo, para o GCE as seguintes métricas são chamadas:</p><pre tabindex=0><code>cloudprovider_gce_api_request_duration_seconds { request = &#34;instance_list&#34;}
cloudprovider_gce_api_request_duration_seconds { request = &#34;disk_insert&#34;}
cloudprovider_gce_api_request_duration_seconds { request = &#34;disk_delete&#34;}
cloudprovider_gce_api_request_duration_seconds { request = &#34;attach_disk&#34;}
cloudprovider_gce_api_request_duration_seconds { request = &#34;detach_disk&#34;}
cloudprovider_gce_api_request_duration_seconds { request = &#34;list_disk&#34;}
</code></pre><h3 id=métricas-do-kube-scheduler>Métricas do <em>kube-scheduler</em></h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.21 [beta]</code></div><p>O <em>scheduler</em> expõe métricas opcionais que relatam os recursos solicitados e os limites desejados de todos os <em>pods</em> em execução. Essas métricas podem ser usadas para criar <em>dashboards</em> de planejamento de capacidade, avaliar os limites de agendamentos atuais ou históricos, identificar rapidamente cargas de trabalho que não podem ser agendadas devido à falta de recursos e comparar o uso atual com a solicitação do <em>pod</em>.</p><p>O <em>kube-scheduler</em> identifica as requisições de <a href=/docs/concepts/configuration/manage-resources-containers/>recursos e limites</a> configurado para cada <em>Pod</em>; quando uma requisição ou limite é diferente de zero o <em>kube-scheduler</em> relata uma <em>timeseries</em> de métricas. Essa <em>timeseries</em> é etiquetada por:</p><ul><li><em>namespace</em></li><li>nome do <em>pod</em></li><li>o nó onde o <em>pod</em> está programado ou uma <em>string</em> vazia caso ainda não esteja programado</li><li>prioridade</li><li>o <em>scheduler</em> atribuído para esse <em>pod</em></li><li>o nome do recurso (por exemplo, <code>cpu</code>)</li><li>a unidade do recurso, se conhecida (por exemplo, <code>cores</code>)</li></ul><p>Uma vez que o <em>pod</em> alcança um estado de conclusão (sua <code>restartPolicy</code> está como <code>Never</code> ou <code>onFailure</code> e está na fase de <code>Succeeded</code> ou <code>Failed</code>, ou foi deletado e todos os contêineres tem um estado de terminado), a série não é mais relatada já que o <em>scheduler</em> agora está livre para agendar a execução de outros <em>pods</em>. As duas métricas são chamadas de <code>kube_pod_resource_request</code> e <code>kube_pod_resource_limit</code>.</p><p>As métricas são expostas no <em>endpoint</em> HTTP <code>/metrics/resources</code> e requerem a mesma autorização que o <em>endpoint</em> <code>/metrics</code> no <em>scheduler</em>. Você deve usar a <em>flag</em> <code>--show-hidden-metrics-for-version=1.20</code> para expor essas métricas de estabilidade alfa.</p><h2 id=desativando-métricas>Desativando métricas</h2><p>Você pode desativar explicitamente as métricas via linha de comando utilizando a <em>flag</em> <code>--disabled-metrics</code>. Isso pode ser desejado se, por exemplo, uma métrica estiver causando um problema de desempenho. A entrada é uma lista de métricas desabilitadas (ou seja, <code>--disabled-metrics=metric1,metric2</code>).</p><h2 id=aplicação-de-cardinalidade-de-métrica>Aplicação de cardinalidade de métrica</h2><p>As métricas com dimensões sem limites podem causar problemas de memória nos componentes que elas instrumentam. Para limitar a utilização de recursos você pode usar a opção de linha de comando <code>--allow-label-value</code> para dinamicamente configurar uma lista de permissões de valores de <em>label</em> para uma métrica.</p><p>No estágio alfa, a <em>flag</em> pode receber apenas uma série de mapeamentos como lista de permissões de <em>labels</em> para uma métrica.
Cada mapeamento tem o formato <code>&lt;metric_name>,&lt;label_name>=&lt;allowed_labels></code> onde <code>&lt;allowed_labels></code> é uma lista separada por vírgulas de nomes aceitáveis para a <em>label</em>.</p><p>O formato geral se parece com:
<code>--allow-label-value &lt;metric_name>,&lt;label_name>='&lt;allow_value1>, &lt;allow_value2>...', &lt;metric_name2>,&lt;label_name>='&lt;allow_value1>, &lt;allow_value2>...', ...</code>.</p><p>Por exemplo:
<code>--allow-label-value number_count_metric,odd_number='1,3,5', number_count_metric,even_number='2,4,6', date_gauge_metric,weekend='Saturday,Sunday'</code></p><h2 id=próximos-passos>Próximos passos</h2><ul><li>Leia sobre o <a href=https://github.com/prometheus/docs/blob/master/content/docs/instrumenting/exposition_formats.md#text-based-format>formato de texto do Prometheus</a> para métricas</li><li>Veja a lista de <a href=https://github.com/kubernetes/kubernetes/blob/master/test/instrumentation/testdata/stable-metrics-list.yaml>métricas estáveis ​​do Kubernetes</a></li><li>Leia sobre a <a href=/docs/reference/using-api/deprecation-policy/#deprecating-a-feature-or-behavior>Política de suspensão de uso do Kubernetes</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-2e05a56491965ae320c2662590b2ca18>3.10.7 - Configurando o Garbage Collection do kubelet</h1><p>O Garbage collection(Coleta de lixo) é uma função útil do kubelet que limpa imagens e contêineres não utilizados. O kubelet executará o garbage collection para contêineres a cada minuto e para imagens a cada cinco minutos.</p><p>Ferramentas externas de garbage collection não são recomendadas, pois podem potencialmente interromper o comportamento do kubelet removendo os contêineres que existem.</p><h2 id=coleta-de-imagens>Coleta de imagens</h2><p>O Kubernetes gerencia o ciclo de vida de todas as imagens através do imageManager, com a cooperação do cadvisor.</p><p>A política para o garbage collection de imagens leva dois fatores em consideração:
<code>HighThresholdPercent</code> e <code>LowThresholdPercent</code>. Uso do disco acima do limite acionará o garbage collection. O garbage collection excluirá as imagens que foram menos usadas recentemente até que o nível fique abaixo do limite.</p><h2 id=coleta-de-container>Coleta de container</h2><p>A política para o garbage collection de contêineres considera três variáveis definidas pelo usuário. <code>MinAge</code> é a idade mínima em que um contêiner pode ser coletado. <code>MaxPerPodContainer</code> é o número máximo de contêineres mortos que todo par de pod (UID, container name) pode ter. <code>MaxContainers</code> é o número máximo de contêineres mortos totais. Essas variáveis podem ser desabilitadas individualmente, definindo <code>MinAge</code> como zero e definindo <code>MaxPerPodContainer</code> e <code>MaxContainers</code> respectivamente para menor que zero.</p><p>O Kubelet atuará em contêineres não identificados, excluídos ou fora dos limites definidos pelos sinalizadores mencionados. Os contêineres mais antigos geralmente serão removidos primeiro. <code>MaxPerPodContainer</code> e <code>MaxContainer</code> podem potencialmente conflitar entre si em situações em que a retenção do número máximo de contêineres por pod (<code>MaxPerPodContainer</code>) estaria fora do intervalo permitido de contêineres globais mortos (<code>MaxContainers</code>). O <code>MaxPerPodContainer</code> seria ajustado nesta situação: O pior cenário seria fazer o downgrade do <code>MaxPerPodContainer</code> para 1 e remover os contêineres mais antigos. Além disso, os contêineres pertencentes a pods que foram excluídos são removidos assim que se tornem mais antigos que <code>MinAge</code>.</p><p>Os contêineres que não são gerenciados pelo kubelet não estão sujeitos ao garbage collection de contêiner.</p><h2 id=configurações-do-usuário>Configurações do usuário</h2><p>Os usuários podem ajustar os seguintes limites para ajustar o garbage collection da imagem com os seguintes sinalizadores do kubelet:</p><ol><li><code>image-gh-high-threshold</code>, a porcentagem de uso de disco que aciona o garbage collection da imagem. O padrão é 85%.</li><li><code>image-gc-low-threshold</code>, a porcentagem de uso de disco com o qual o garbage collection da imagem tenta liberar. O padrão é 80%.</li></ol><p>Também permitimos que os usuários personalizem a política do garbagem collection através dos seguintes sinalizadores do kubelet:</p><ol><li><code>minimum-container-ttl-duration</code>, idade mínima para um contêiner finalizado antes de ser colectado. O padrão é 0 minuto, o que significa que todo contêiner finalizado será coletado como lixo.</li><li><code>maximum-dead-containers-per-container</code>, número máximo de instâncias antigas a serem retidas por contêiner. O padrão é 1.</li><li><code>maximum-dead-containers</code>, número máximo de instâncias antigas de contêineres para retenção global. O padrão é -1, o que significa que não há limite global.</li></ol><p>Os contêineres podem ser potencialmente coletados como lixo antes que sua utilidade expire. Esses contêineres podem conter logs e outros dados que podem ser úteis para solucionar problemas. Um valor suficientemente grande para <code>maximum-dead-containers-per-container</code> é altamente recomendado para permitir que pelo menos 1 contêiner morto seja retido por contêiner esperado. Um valor maior para <code>maximum-dead-containers</code> também é recomendados por um motivo semelhante.
Consulte <a href=https://github.com/kubernetes/kubernetes/issues/13287>esta issue</a> para obter mais detalhes.</p><h2 id=descontinuado>Descontinuado</h2><p>Alguns recursos do Garbage Collection neste documento serão substituídos pelo kubelet eviction no futuro.</p><p>Incluindo:</p><table><thead><tr><th>Flag Existente</th><th>Nova Flag</th><th>Fundamentação</th></tr></thead><tbody><tr><td><code>--image-gc-high-threshold</code></td><td><code>--eviction-hard</code> ou <code>--eviction-soft</code></td><td>os sinais existentes de despejo podem acionar o garbage collection da imagem</td></tr><tr><td><code>--image-gc-low-threshold</code></td><td><code>--eviction-minimum-reclaim</code></td><td>recuperações de despejo atinge o mesmo comportamento</td></tr><tr><td><code>--maximum-dead-containers</code></td><td></td><td>descontinuado quando os logs antigos forem armazenados fora do contexto do contêiner</td></tr><tr><td><code>--maximum-dead-containers-per-container</code></td><td></td><td>descontinuado quando os logs antigos forem armazenados fora do contexto do contêiner</td></tr><tr><td><code>--minimum-container-ttl-duration</code></td><td></td><td>descontinuado quando os logs antigos forem armazenados fora do contexto do contêiner</td></tr><tr><td><code>--low-diskspace-threshold-mb</code></td><td><code>--eviction-hard</code> ou <code>eviction-soft</code></td><td>O despejo generaliza os limites do disco para outros recursos</td></tr><tr><td><code>--outofdisk-transition-frequency</code></td><td><code>--eviction-pressure-transition-period</code></td><td>O despejo generaliza a transição da pressão do disco para outros recursos</td></tr></tbody></table><h2 id=próximos-passos>Próximos passos</h2><p>Consulte <a href=/docs/tasks/administer-cluster/out-of-resource/>Configurando a Manipulação de Recursos Insuficientes</a> para mais detalhes.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-08e94e6a480e0d6b2de72d84a1b97617>3.10.8 - Proxies no Kubernetes</h1><p>Esta página descreve o uso de proxies com Kubernetes.</p><h2 id=proxies>Proxies</h2><p>Existem vários tipos diferentes de proxies que você pode encontrar usando Kubernetes:</p><ol><li>O <a href=/docs/tasks/access-application-cluster/access-cluster/#directly-accessing-the-rest-api>kubectl proxy</a>:</li></ol><p>Quando o kubectl proxy é utilizado ocorre o seguinte:
- executa na máquina do usuário ou em um pod
- redireciona/encapsula conexões direcionadas ao localhost para o servidor de API
- a comunicação entre o cliente e o o proxy usa HTTP
- a comunicação entre o proxy e o servidor de API usa HTTPS
- o proxy localiza o servidor de API do cluster
- o proxy adiciona os cabeçalhos de comunicação.</p><ol><li><p>O <a href=/docs/tasks/access-application-cluster/access-cluster/#discovering-builtin-services>apiserver proxy</a>:</p><ul><li>é um bastion server, construído no servidor de API</li><li>conecta um usuário fora do cluster com os IPs do cluster que não podem ser acessados de outra forma</li><li>executa dentro do processo do servidor de API</li><li>cliente para proxy usa HTTPS (ou HTTP se o servidor de API for configurado)</li><li>proxy para o destino pode usar HTTP ou HTTPS conforme escolhido pelo proxy usando as informações disponíveis</li><li>pode ser usado para acessar um Nó, Pod ou serviço</li><li>faz balanceamento de carga quando usado para acessar um Service.</li></ul></li><li><p>O <a href=/docs/concepts/services-networking/service/#ips-and-vips>kube proxy</a>:</p><ul><li>executa em todos os Nós</li><li>atua como proxy para UDP, TCP e SCTP</li><li>não aceita HTTP</li><li>provém balanceamento de carga</li><li>apenas é usado para acessar serviços.</li></ul></li><li><p>Um Proxy/Balanceador de carga na frente de servidores de API(s):</p><ul><li>a existência e a implementação de tal elemento varia de cluster para cluster, por exemplo nginx</li><li>fica entre todos os clientes e um ou mais serviços</li><li>atua como balanceador de carga se existe mais de um servidor de API.</li></ul></li><li><p>Balanceadores de carga da nuvem em serviços externos:</p><ul><li>são fornecidos por algum provedor de nuvem (e.x AWS ELB, Google Cloud Load Balancer)</li><li>são criados automaticamente quando o serviço de Kubernetes tem o tipo <code>LoadBalancer</code></li><li>geralmente suportam apenas UDP/TCP</li><li>O suporte ao SCTP fica por conta da implementação do balanceador de carga da provedora de nuvem</li><li>a implementação varia de acordo com o provedor de cloud.</li></ul></li></ol><p>Os usuários de Kubernetes geralmente não precisam se preocupar com outras coisas além dos dois primeiros tipos. O
administrador do cluster tipicamente garante que os últimos tipos serão configurados corretamente.</p><h2 id=redirecionamento-de-requisições>Redirecionamento de requisições</h2><p>Os proxies substituíram as capacidades de redirecionamento. O redirecionamento foi depreciado.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-85d633ae590aa20ec024f1b7af1d74fc>3.10.9 - Instalando Complementos</h1><div class="alert alert-secondary callout third-party-content" role=alert><strong>Nota:</strong>
Esta seção tem links para projetos de terceiros que fornecem a funcionalidade exigida pelo Kubernetes. Os autores do projeto Kubernetes não são responsáveis por esses projetos. Esta página obedece as <a href=https://github.com/cncf/foundation/blob/master/website-guidelines.md target=_blank>diretrizes de conteúdo do site CNCF</a>, listando os itens em ordem alfabética. Para adicionar um projeto a esta lista, leia o <a href=/docs/contribute/style/content-guide/#third-party-content>guia de conteúdo</a> antes de enviar sua alteração.</div><p>Complementos estendem as funcionalidades do Kubernetes.</p><p>Esta página lista alguns dos complementos disponíveis e links com suas respectivas instruções de instalação.</p><h2 id=rede-e-política-de-rede>Rede e Política de Rede</h2><ul><li><a href=https://www.github.com/noironetworks/aci-containers>ACI</a> fornece rede integrada de contêineres e segurança de rede com a Cisco ACI.</li><li><a href=https://antrea.io/>Antrea</a> opera nas camadas 3 e 4 do modelo de rede OSI para fornecer serviços de rede e de segurança para o Kubernetes, aproveitando o Open vSwitch como camada de dados de rede.</li><li><a href=https://docs.projectcalico.org/latest/introduction/>Calico</a> é um provedor de serviços de rede e de políticas de rede. Este complemento suporta um conjunto flexível de opções de rede, de modo a permitir a escolha da opção mais eficiente para um dado caso de uso, incluindo redes <em>overlay</em> (sobrepostas) e não-<em>overlay</em>, com ou sem o uso do protocolo BGP. Calico usa o mesmo mecanismo para aplicar políticas de rede a hosts, pods, e aplicações na camada de <em>service mesh</em> (quando Istio e Envoy estão instalados).</li><li><a href=https://projectcalico.docs.tigera.io/getting-started/kubernetes/flannel/flannel>Canal</a> une Flannel e Calico, fornecendo rede e política de rede.</li><li><a href=https://github.com/cilium/cilium>Cilium</a> é um plug-in de rede de camada 3 e de políticas de rede que pode aplicar políticas HTTP/API/camada 7 de forma transparente. Tanto o modo de roteamento quanto o de sobreposição/encapsulamento são suportados. Este plug-in também consegue operar no topo de outros plug-ins CNI.</li><li><a href=https://github.com/cni-genie/CNI-Genie>CNI-Genie</a> permite que o Kubernetes se conecte facilmente a uma variedade de plug-ins CNI, como Calico, Canal, Flannel, Romana ou Weave.</li><li><a href=https://contivpp.io/>Contiv</a> oferece serviços de rede configuráveis para diferentes casos de uso (camada 3 nativa usando BGP, <em>overlay</em> (sobreposição) usando vxlan, camada 2 clássica e Cisco-SDN/ACI) e também um <em>framework</em> rico de políticas de rede. O projeto Contiv é totalmente <a href=http://github.com/contiv>open source</a>. O <a href=http://github.com/contiv/install>instalador</a> fornece opções de instalação com ou sem kubeadm.</li><li><a href=http://www.juniper.net/us/en/products-services/sdn/contrail/contrail-networking/>Contrail</a> é uma plataforma open source baseada no <a href=https://tungsten.io>Tungsten Fabric</a> que oferece virtualização de rede multi-nuvem e gerenciamento de políticas de rede. O Contrail e o Tungsten Fabric são integrados a sistemas de orquestração de contêineres, como Kubernetes, OpenShift, OpenStack e Mesos, e fornecem modos de isolamento para cargas de trabalho executando em máquinas virtuais, contêineres/pods e servidores físicos.</li><li><a href=https://github.com/flannel-io/flannel#deploying-flannel-manually>Flannel</a> é um provedor de redes <em>overlay</em> (sobrepostas) que pode ser usado com o Kubernetes.</li><li><a href=https://github.com/ZTE/Knitter/>Knitter</a> é um plug-in para suporte de múltiplas interfaces de rede em Pods do Kubernetes.</li><li><a href=https://github.com/k8snetworkplumbingwg/multus-cni>Multus</a> é um plugin para suporte a várias interfaces de rede em Pods no Kubernetes. Este plug-in pode agir como um "meta-plug-in", ou um plug-in CNI que se comunica com múltiplos outros plug-ins CNI (por exemplo, Calico, Cilium, Contiv, Flannel), além das cargas de trabalho baseadas em SRIOV, DPDK, OVS-DPDK e VPP no Kubernetes.</li><li><a href=https://docs.vmware.com/en/VMware-NSX-T-Data-Center/index.html>NSX-T</a> Container Plug-in (NCP) fornece integração entre o VMware NSX-T e sistemas de orquestração de contêineres como o Kubernetes. Além disso, oferece também integração entre o NSX-T e as plataformas CaaS/PaaS baseadas em contêiner, como o Pivotal Container Service (PKS) e o OpenShift.</li><li><a href=https://github.com/nuagenetworks/nuage-kubernetes/blob/v5.1.1-1/docs/kubernetes-1-installation.rst>Nuage</a> é uma plataforma de rede definida por software que fornece serviços de rede baseados em políticas entre os Pods do Kubernetes e os ambientes não-Kubernetes, com visibilidade e monitoramento de segurança.</li><li><a href=https://github.com/ovn-org/ovn-kubernetes/>OVN-Kubernetes</a> é um provedor de rede para o Kubernetes baseado no <a href=https://github.com/ovn-org/ovn/>OVN (Open Virtual Network)</a>, uma implementação de redes virtuais que surgiu através do projeto Open vSwitch (OVS). O OVN-Kubernetes fornece uma implementação de rede baseada em <em>overlay</em> (sobreposição) para o Kubernetes, incluindo uma implementação baseada em OVS para serviços de balanceamento de carga e políticas de rede.</li><li><a href=https://github.com/opnfv/ovn4nfv-k8s-plugin>OVN4NFV-K8S-Plugin</a> é um plug-in controlador CNI baseado no OVN (Open Virtual Network) que fornece serviços de rede <em>cloud native</em>, como <em>Service Function Chaining</em> (SFC), redes <em>overlay</em> (sobrepostas) OVN múltiplas, criação dinâmica de subredes, criação dinâmica de redes virtuais, provedor de rede VLAN e provedor de rede direto, e é plugável a outros plug-ins multi-rede. Ideal para cargas de trabalho que utilizam computação de borda <em>cloud native</em> em redes multi-cluster.</li><li><a href=https://github.com/romana/romana>Romana</a> é uma solução de rede de camada 3 para redes de pods que também suporta a <a href=/pt-br/docs/concepts/services-networking/network-policies/>API NetworkPolicy</a>. Detalhes da instalação do complemento Kubeadm disponíveis <a href=https://github.com/romana/romana/tree/master/containerize>aqui</a>.</li><li><a href=https://www.weave.works/docs/net/latest/kube-addon/>Weave Net</a> fornece rede e política de rede, funciona em ambos os lados de uma partição de rede e não requer um banco de dados externo.</li></ul><h2 id=descoberta-de-serviço>Descoberta de Serviço</h2><ul><li><a href=https://coredns.io>CoreDNS</a> é um servidor DNS flexível e extensível que pode ser <a href=https://github.com/coredns/deployment/tree/master/kubernetes>instalado</a> como o serviço de DNS dentro do cluster para ser utilizado por pods.</li></ul><h2 id=visualização-amp-controle>Visualização & Controle</h2><ul><li><a href=https://github.com/kubernetes/dashboard#kubernetes-dashboard>Dashboard</a> é uma interface web para gestão do Kubernetes.</li><li><a href=https://www.weave.works/documentation/scope-latest-installing/#k8s>Weave Scope</a> é uma ferramenta gráfica para visualizar contêineres, pods, serviços, entre outros objetos do cluster. Pode ser utilizado com uma <a href=https://cloud.weave.works/>conta Weave Cloud</a>. Como alternativa, é possível hospedar a interface do usuário por conta própria.</li></ul><h2 id=infraestrutura>Infraestrutura</h2><ul><li><a href=https://kubevirt.io/user-guide/#/installation/installation>KubeVirt</a> é um complemento para executar máquinas virtuais no Kubernetes. É geralmente executado em clusters em máquina física.</li></ul><h2 id=complementos-legados>Complementos Legados</h2><p>Existem vários outros complementos documentados no diretório <a href=https://git.k8s.io/kubernetes/cluster/addons>cluster/addons</a> que não são mais utilizados.</p><p>Projetos bem mantidos devem ser listados aqui. PRs são bem-vindos!</p></div><div class=td-content style=page-break-before:always><h1 id=pg-31c9327d2332c585341b64ddafa19cdd>3.10.10 - Prioridade e imparcialidade da API</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.20 [beta]</code></div><p>Controlar o comportamento do servidor da API Kubernetes em uma situação de sobrecarga
é uma tarefa chave para administradores de cluster. O <a class=glossary-tooltip title='O componente da camada de gerenciamento que serve a API do Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label=kube-apiserver>kube-apiserver</a> tem alguns controles disponíveis
(ou seja, as <em>flags</em> <code>--max-requests-inflight</code> e <code>--max-mutating-requests-inflight</code>)
para limitar a quantidade de trabalho pendente que será aceito,
evitando que uma grande quantidade de solicitações de entrada sobrecarreguem, e
potencialmente travando o servidor da API, mas essas <em>flags</em> não são suficientes para garantir
que as solicitações mais importantes cheguem em um período de alto tráfego.</p><p>O recurso de prioridade e imparcialidade da API (do inglês <em>API Priority and Fairness</em>, APF) é uma alternativa que melhora
as limitações mencionadas acima. A APF classifica
e isola os pedidos de uma forma mais refinada. Também introduz
uma quantidade limitada de filas, para que nenhuma solicitação seja rejeitada nos casos
de sobrecargas muito breves. As solicitações são despachadas das filas usando uma
técnica de filas justa para que, por exemplo, um
<a class=glossary-tooltip title='Um ciclo de controle que observa o estado partilhado do cluster através do API Server e efetua mudanças tentando mover o estado atual em direção ao estado desejado.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=controller>controller</a> não precise
negar as outras requisições (mesmo no mesmo nível de prioridade).</p><p>Esse recurso foi projetado para funcionar bem com controladores padrão, que
usam informantes e reagem a falhas de solicitações da API com exponencial
back-off, e outros clientes que também funcionam desta forma.</p><div class="alert alert-warning caution callout" role=alert><strong>Cuidado:</strong> Solicitações classificadas como "de longa duração" — principalmente <em>watches</em> — não são
sujeitas ao filtro da prioridade e imparcialidade da API. Isso também é verdade para
a <em>flag</em> <code>--max-requests-inflight</code> sem o recurso da APF ativado.</div><h2 id=ativando-desativando-a-prioridade-e-imparcialidade-da-api>Ativando/Desativando a prioridade e imparcialidade da API</h2><p>O recurso de prioridade e imparcialidade da API é controlado por um feature gate
e está habilitado por padrão. Veja <a href=/docs/reference/command-line-tools-reference/feature-gates/>Portões de Recurso</a>
para uma explicação geral dos portões de recursos e como habilitar e
desativá-los. O nome da porta de recurso para APF é
"APIPriorityAndFairness". Este recurso também envolve um <a class=glossary-tooltip title='Um conjunto de caminhos relacionados da API Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/kubernetes-api/#api-groups-and-versioning target=_blank aria-label='API Group'>API Group</a> com: (a) um
Versão <code>v1alpha1</code>, desabilitada por padrão, e (b) <code>v1beta1</code> e
Versões <code>v1beta2</code>, habilitadas por padrão. Você pode desativar o feature gate
e versões beta do grupo de APIs adicionando a seguinte
<em>flag</em> para sua invocação <code>kube-apiserver</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kube-apiserver <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>--feature-gates<span style=color:#666>=</span><span style=color:#b8860b>APIPriorityAndFairness</span><span style=color:#666>=</span><span style=color:#a2f>false</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>--runtime-config<span style=color:#666>=</span>flowcontrol.apiserver.k8s.io/v1beta1<span style=color:#666>=</span>false,flowcontrol.apiserver.k8s.io/v1beta2<span style=color:#666>=</span><span style=color:#a2f>false</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span> <span style=color:#080;font-style:italic># …and other flags as usual</span>
</span></span></code></pre></div><p>Como alternativa, você pode habilitar a versão v1alpha1 do grupo de APIs
com <code>--runtime-config=flowcontrol.apiserver.k8s.io/v1alpha1=true</code>.</p><p>A <em>flag</em> <code>--enable-priority-and-fairness=false</code> desabilitará o
recurso de prioridade e imparcialidade da API, mesmo que outras <em>flags</em> o tenha ativado.</p><h2 id=conceitos>Conceitos</h2><p>Existem vários recursos distintos envolvidos na APF.
As solicitações recebidas são classificadas por atributos da solicitação usando
<em>FlowSchemas</em> e atribuídos a níveis de prioridade. Os níveis de prioridade adicionam um grau de
isolamento mantendo limites de simultaneidade separados, para que as solicitações atribuídas
a diferentes níveis de prioridade não travem outros. Dentro de um nível de prioridade,
um algoritmo de <em>fair queuing</em> impede que solicitações de diferentes <em>flows</em> fiquem sem energia
entre si, e permite que os pedidos sejam enfileirados para evitar que um alto tráfego
cause falhas nas solicitações quando a carga média é aceitavelmente baixa.</p><h3 id=níveis-de-prioridade>Níveis de prioridade</h3><p>Sem o APF ativado, a simultaneidade geral no servidor de API é limitada pelo
<code>kube-apiserver</code> as <em>flags</em> <code>--max-requests-inflight</code> e
<code>--max-mutating-requests-inflight</code>. Com o APF ativado, os limites de simultaneidade
definidos por esses sinalizadores são somados e, em seguida, a soma é dividida entre um
conjunto configurável de <em>níveis de prioridade</em>. Cada solicitação recebida é atribuída a um
nível de prioridade único, e cada nível de prioridade só despachará tantos
solicitações simultâneas conforme sua configuração permite.</p><p>A configuração padrão, por exemplo, inclui níveis de prioridade separados para
solicitações de eleição de líder, solicitações de controladores integrados e solicitações de
<em>Pods</em>. Isso significa que um <em>pod</em> mal-comportado que inunda o servidor da API com
solicitações não podem impedir a eleição do líder ou ações dos controladores integrados
de ter sucesso.</p><h3 id=enfileiramento>Enfileiramento</h3><p>Mesmo dentro de um nível de prioridade pode haver um grande número de fontes distintas de
tráfego. Em uma situação de sobrecarga, é importante evitar um fluxo de
pedidos de outros serviços (em particular, no caso relativamente comum de um
único cliente buggy inundando o kube-apiserver com solicitações, esse cliente buggy
idealmente não teria muito impacto em outros clientes). Isto é
tratadas pelo uso de um algoritmo de <em>fair queuing</em> para processar solicitações que são atribuídas
ao mesmo nível de prioridade. Cada solicitação é atribuída a um <em>flow</em>, identificado pelo
nome do FlowSchema correspondente mais um <em>flow distincter</em> — que
é o usuário solicitante, o namespace do recurso de destino ou nada — e o
sistema tenta dar peso aproximadamente igual a solicitações em diferentes
fluxos do mesmo nível de prioridade.
Para habilitar o tratamento distinto de instâncias distintas, os controladores que
muitas instâncias devem ser autenticadas com nomes de usuário distintos</p><p>Depois de classificar uma solicitação em um fluxo, a APF
pode então atribuir a solicitação a uma fila. Esta atribuição usa
uma técnica conhecida como <a class=glossary-tooltip title='A technique for assigning requests to queues that provides better isolation than hashing modulo the number of queues.' data-toggle=tooltip data-placement=top href='/pt-br/docs/reference/glossary/?all=true#term-shuffle-sharding' target=_blank aria-label='shuffle sharding'>shuffle sharding</a>, que faz uso relativamente eficiente de
filas para isolar fluxos de baixa intensidade de fluxos de alta intensidade.</p><p>Os detalhes do algoritmo de enfileiramento são ajustáveis ​​para cada nível de prioridade e
permitem que os administradores troquem o uso de memória, justiça (a propriedade que
fluxos independentes irão progredir quando o tráfego total exceder a capacidade),
tolerância para tráfego e a latência adicionada induzida pelo enfileiramento.</p><h3 id=solicitações-de-isenção>Solicitações de isenção</h3><p>Alguns pedidos são considerados suficientemente importantes para que não estejam sujeitos a
qualquer uma das limitações impostas por este recurso. Estas isenções impedem uma
configuração de controle de fluxo mal configurada de desabilitar totalmente um servidor da API.</p><h2 id=recursos>Recursos</h2><p>A API de controle de fluxo envolve dois tipos de recursos.
<a href=/docs/reference/generated/kubernetes-api/v1.25/#prioritylevelconfiguration-v1beta2-flowcontrol-apiserver-k8s-io>PriorityLevelConfigurations</a>
define as classes de isolamento disponíveis, a parte da concorrência disponível
que cada um pode tratar e permite o ajuste fino do comportamento das filas.
<a href=/docs/reference/generated/kubernetes-api/v1.25/#flowschema-v1beta2-flowcontrol-apiserver-k8s-io>FlowSchemas</a>
são usados ​​para classificar solicitações de entrada individuais, correspondendo cada uma a um
único PriorityLevelConfiguration. Há também uma versão <code>v1alpha1</code>
do mesmo grupo de APIs e tem os mesmos tipos com a mesma sintaxe e
semântica.</p><h3 id=prioritylevelconfiguration>PriorityLevelConfiguration</h3><p>Um PriorityLevelConfiguration representa uma única classe de isolamento. Cada
PriorityLevelConfiguration tem um limite independente no número de solicitações de pendências
e limitações no número de solicitações enfileiradas.</p><p>Os limites de simultaneidade para PriorityLevelConfigurations não são especificados no número absoluto
de solicitações, mas sim em "compartilhamentos de simultaneidade". A simultaneidade limite total
para o servidor da API é distribuído entre os PriorityLevelConfigurations existentes
em proporção com esses compartilhamentos. Isso permite um
administrador de cluster aumentar ou diminuir a quantidade total de tráfego para um
servidor reiniciando <code>kube-apiserver</code> com um valor diferente para
<code>--max-requests-inflight</code> (ou <code>--max-mutating-requests-inflight</code>), e todos os
PriorityLevelConfigurations verá sua simultaneidade máxima permitida aumentar (ou
abaixar) pela mesma proporção.</p><div class="alert alert-warning caution callout" role=alert><strong>Cuidado:</strong> Com o recurso prioridade e imparcialidade ativado, o limite total de simultaneidade para
o servidor é definido como a soma de <code>--max-requests-inflight</code> e
<code>--max-mutating-requests-inflight</code>. Já não há distinção
entre solicitações mutantes e não mutantes; se você quiser tratá-las
separadamente para um determinado recurso, faça FlowSchemas separados que correspondam ao
verbos mutantes e não mutantes, respectivamente.</div><p>Quando o volume de solicitações de entrada atribuídas a um único
PriorityLevelConfiguration é maior do que o permitido por seu nível de simultaneidade, o
O campo <code>type</code> de sua especificação determina o que acontecerá com solicitações extras.
Um tipo de 'Reject' significa que o excesso de tráfego será imediatamente rejeitado com
um erro HTTP 429 (Too Many Requests). Um tipo de <code>Queue</code> significa que as solicitações
acima do limite será enfileirado, com as técnicas de
<em>shuffle sharding</em> e <em>fair queuing</em> usadas
para equilibrar o progresso entre os fluxos de solicitação.</p><p>A configuração de enfileiramento permite ajustar o algoritmo de <em>fair queuing</em> para um
nível de prioridade. Os detalhes do algoritmo podem ser lidos no
<a href=#whats-next>proposta de melhoria</a>, mas resumindo:</p><ul><li><p>Aumentar as 'filas' reduz a taxa de colisões entre diferentes fluxos,
o custo do aumento do uso de memória. Um valor de 1 aqui efetivamente desabilita a
lógica de <em>fair queuing</em>, mas ainda permite que as solicitações sejam enfileiradas.</p></li><li><p>Aumentar o <code>queueLengthLimit</code> permite que tráfegos maiores sejam
sustentados sem deixar de lado nenhum pedido, ao custo de aumento
latência e uso de memória.</p></li><li><p>Alterar <code>handSize</code> permite ajustar a probabilidade de colisões entre
fluxos diferentes e a simultaneidade geral disponível para um único fluxo em um
situação de sobrecarga.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Um 'handSize' maior torna menos provável que dois fluxos individuais colidam
(e, portanto, um bloqueie a solicitação do outro), mas é mais provável que
um pequeno número de fluxos pode dominar o apiserver. Um <code>handSize</code> maior também
aumenta potencialmente a quantidade de latência que um único fluxo de alto tráfego
pode causar. O número máximo de solicitações enfileiradas possíveis de um
fluxo único é <code>handSize * queueLengthLimit</code>.</div></li></ul><p>A seguir está uma tabela mostrando uma coleção interessante de configurações do
<em>shuffle sharding</em>, mostrando para cada uma a probabilidade de que um
determinado rato (fluxo de baixa intensidade) é esmagado pelos elefantes (fluxo de alta intensidade) para
uma coleção ilustrativa de números de elefantes. Veja
<a href=https://play.golang.org/p/Gi0PLgVHiUg>https://play.golang.org/p/Gi0PLgVHiUg</a> , que calcula esta tabela.</p><table><caption style=display:none>Example Shuffle Sharding Configurations</caption><thead><tr><th>HandSize</th><th>Filas</th><th>1 elefante</th><th>4 elefantes</th><th>16 elefantes</th></tr></thead><tbody><tr><td>12</td><td>32</td><td>4.428838398950118e-09</td><td>0.11431348830099144</td><td>0.9935089607656024</td></tr><tr><td>10</td><td>32</td><td>1.550093439632541e-08</td><td>0.0626479840223545</td><td>0.9753101519027554</td></tr><tr><td>10</td><td>64</td><td>6.601827268370426e-12</td><td>0.00045571320990370776</td><td>0.49999929150089345</td></tr><tr><td>9</td><td>64</td><td>3.6310049976037345e-11</td><td>0.00045501212304112273</td><td>0.4282314876454858</td></tr><tr><td>8</td><td>64</td><td>2.25929199850899e-10</td><td>0.0004886697053040446</td><td>0.35935114681123076</td></tr><tr><td>8</td><td>128</td><td>6.994461389026097e-13</td><td>3.4055790161620863e-06</td><td>0.02746173137155063</td></tr><tr><td>7</td><td>128</td><td>1.0579122850901972e-11</td><td>6.960839379258192e-06</td><td>0.02406157386340147</td></tr><tr><td>7</td><td>256</td><td>7.597695465552631e-14</td><td>6.728547142019406e-08</td><td>0.0006709661542533682</td></tr><tr><td>6</td><td>256</td><td>2.7134626662687968e-12</td><td>2.9516464018476436e-07</td><td>0.0008895654642000348</td></tr><tr><td>6</td><td>512</td><td>4.116062922897309e-14</td><td>4.982983350480894e-09</td><td>2.26025764343413e-05</td></tr><tr><td>6</td><td>1024</td><td>6.337324016514285e-16</td><td>8.09060164312957e-11</td><td>4.517408062903668e-07</td></tr></tbody></table><h3 id=flowschema>FlowSchema</h3><p>Um FlowSchema corresponde a algumas solicitações de entrada e as atribui a um
nível de prioridade. Cada solicitação de entrada é testada em relação a cada
FlowSchema, por sua vez, começando com aqueles com valores numericamente mais baixos ---
que consideramos ser o logicamente mais alto --- <code>matchingPrecedence</code> e
trabalhando adiante. A primeira correspondência ganha.</p><div class="alert alert-warning caution callout" role=alert><strong>Cuidado:</strong> Somente o primeiro FlowSchema correspondente para uma determinada solicitação é importante. Se vários
FlowSchemas correspondem a uma única solicitação de entrada, ela será atribuída com base na
com o maior em <code>matchingPrecedence</code>. Se vários FlowSchemas com igual
<code>matchingPrecedence</code> corresponde ao mesmo pedido, aquele com menor
<code>name</code> lexicográfico vencerá, mas é melhor não confiar nisso e, em vez disso,
certifique-se de que dois FlowSchemas não tenham o mesmo <code>matchingPrecedence</code>.</div><p>Um FlowSchema corresponde a uma determinada solicitação se pelo menos uma de suas <code>regras</code>
são correspondidas. Uma regra corresponde se pelo menos um de seus <code>assuntos</code> <em>e</em> pelo menos
uma de suas <code>resourceRules</code> ou <code>nonResourceRules</code> (dependendo se a
solicitação de entrada é para um recurso ou URL de não-recurso) corresponde à solicitação.</p><p>Para o campo <code>name</code> em assuntos, e os campos <code>verbs</code>, <code>apiGroups</code>, <code>resources</code>,
<code>namespaces</code> e <code>nonResourceURLs</code> de regras de recursos e não recursos,
o <em>wildcard</em> <code>*</code> pode ser especificado para corresponder a todos os valores do campo fornecido,
efetivamente removendo-o de consideração.</p><p>O <code>distinguisherMethod.type</code> de um FlowSchema determina como as solicitações correspondentes a esse
esquema será separado em fluxos. Pode ser
ou <code>ByUser</code>, caso em que um usuário solicitante não poderá ser bloqueado por outros,
ou <code>ByNamespace</code>, caso em que solicitações de recursos
em um namespace não será capaz de privar os pedidos de recursos em outros
namespaces de capacidade, ou pode estar em branco (ou <code>distinguisherMethod</code> pode ser
omitido inteiramente), caso em que todas as solicitações correspondidas por este FlowSchema serão
considerados parte de um único fluxo. A escolha correta para um determinado FlowSchema
depende do recurso e do seu ambiente específico.</p><h2 id=padrões>Padrões</h2><p>Cada kube-apiserver mantém dois tipos de objetos de configuração APF:
obrigatória e sugerida.</p><h3 id=objetos-de-configuração-obrigatórios>Objetos de configuração obrigatórios</h3><p>Os quatro objetos de configuração obrigatórios refletem no
comportamento do <em>guardrail</em> embutido. Este é o comportamento que os servidores tinham antes
desses objetos existirem e, quando esses objetos existem, suas especificações refletem
esse comportamento. Os quatro objetos obrigatórios são os seguintes.</p><ul><li><p>O nível de prioridade obrigatório <code>exempt</code> é usado para solicitações que são
não sujeito a controle de fluxo: eles sempre serão despachados
imediatamente. O FlowSchema obrigatório <code>exempt</code> classifica todos
solicitações do grupo <code>system:masters</code> para este nível de prioridade.
Você pode definir outros FlowSchemas que direcionam outras solicitações
a este nível de prioridade, se apropriado.</p></li><li><p>O nível de prioridade obrigatório <code>catch-all</code> é usado em combinação com
o FlowSchema <code>catch-all</code> obrigatório para garantir que todas as solicitações
recebam algum tipo de classificação. Normalmente você não deve confiar
nesta configuração catch-all, e deve criar seu próprio FlowSchema catch-all
e PriorityLevelConfiguration (ou use o
nível de prioridade <code>global-default</code> que é instalado por padrão) como
apropriado. Como não se espera que seja usado normalmente, o
o nível de prioridade obrigatório <code>catch-all</code> tem uma simultaneidade muito pequena
compartilha e não enfileira solicitações.</p></li></ul><h3 id=objetos-de-configuração-sugeridos>Objetos de configuração sugeridos</h3><p>Os FlowSchemas e PriorityLevelConfigurations sugeridos constituem uma
configuração padrão razoável. Você pode modificá-los e/ou criar
objetos de configuração adicionais, se desejar. Se o seu cluster tiver a
probabilidade de experimentar carga pesada, então você deve considerar qual
configuração funcionará melhor.</p><p>A configuração sugerida agrupa as solicitações em seis níveis de prioridade:</p><ul><li><p>O nível de prioridade <code>node-high</code> é para atualizações de integridade dos nós.</p></li><li><p>O nível de prioridade <code>system</code> é para solicitações não relacionadas à integridade do
grupo <code>system:nodes</code>, ou seja, Kubelets, que deve ser capaz de contatar
o servidor de API para que as cargas de trabalho possam ser agendadas
eles.</p></li><li><p>O nível de prioridade <code>leader-election</code> é para solicitações de eleição de líder de
controladores embutidos (em particular, solicitações para <code>endpoints</code>, <code>configmaps</code>,
ou <code>leases</code> vindo do <code>system:kube-controller-manager</code> ou
usuários <code>system:kube-scheduler</code> e contas de serviço no namespace <code>kube-system</code>).
Estes são importantes para isolar de outro tráfego porque as falhas
na eleição do líder fazem com que seus controladores falhem e reiniciem, o que por sua vez
causa tráfego mais caro à medida que os novos controladores sincronizam seus informantes.</p></li><li><p>O nível de prioridade <code>workload-high</code> é para outras solicitações de controladores built-in.</p></li><li><p>O nível de prioridade <code>workload-low</code> é para solicitações de qualquer outra conta de serviço,
que normalmente incluirá todas as solicitações de controladores em execução
<em>Pods</em>.</p></li><li><p>O nível de prioridade <code>global-default</code> trata de todos os outros tráfegos, por exemplo,
comandos <code>kubectl</code> interativos executados por usuários não privilegiados.</p></li></ul><p>Os FlowSchemas sugeridos servem para direcionar as solicitações para os
níveis de prioridade acima, e não são enumerados aqui.</p><h3 id=manutenção-dos-objetos-de-configuração-obrigatórios-e-sugeridos>Manutenção dos Objetos de Configuração Obrigatórios e Sugeridos</h3><p>Cada <code>kube-apiserver</code> mantém independentemente os requisitos obrigatórios e
objetos de configuração sugeridos, usando comportamento inicial e periódico.
Assim, em uma situação com uma mistura de servidores de diferentes versões
pode haver <em>thrashing</em> desde que servidores diferentes tenham
opiniões sobre o conteúdo adequado desses objetos.</p><p>Para os objetos de configuração obrigatórios, a manutenção consiste em
garantir que o objeto existe e, se existir, tem a especificação adequada.
O servidor se recusa a permitir uma criação ou atualização com uma especificação que é
inconsistente com o comportamento do guarda-corpo do servidor.</p><p>A manutenção de objetos de configuração sugeridos é projetada para permitir
que suas especificações sejam substituídas. A exclusão, por outro lado, não é
respeitada: a manutenção restaurará o objeto. Se você não quer um
objeto de configuração sugerido, então você precisa mantê-lo por perto, mas defina
sua especificação para ter consequências mínimas. Manutenção de objetos
sugeridos também é projetada para suportar a migração automática quando uma nova
versão do <code>kube-apiserver</code> é lançada, embora potencialmente com
<em>thrashing</em> enquanto há uma população mista de servidores.</p><p>A manutenção de um objeto de configuração sugerido consiste em cria-lo
--- com a especificação sugerida pelo servidor --- se o objeto não
existir. OTOH, se o objeto já existir, o comportamento de manutenção
depende se os <code>kube-apiservers</code> ou os usuários controlam o
objeto. No primeiro caso, o servidor garante que a especificação do objeto
é o que o servidor sugere; no último caso, a especificação é deixada
sozinho.</p><p>A questão de quem controla o objeto é respondida primeiro olhando
para uma anotação com a chave <code>apf.kubernetes.io/autoupdate-spec</code>. Se
existe tal anotação e seu valor é <code>true</code> então o
kube-apiservers controlam o objeto. Se houver tal anotação
e seu valor for <code>false</code>, os usuários controlarão o objeto. Se
nenhuma dessas condições é satisfeita entaão a <code>metadata.generation</code> do
objeto é consultado. Se for 1, o kube-apiservers controla
o objeto. Caso contrário, os usuários controlam o objeto. Essas regras foram
introduzido na versão 1.22 e sua consideração de
<code>metadata.generation</code> é para migrar do mais simples
comportamento anterior. Usuários que desejam controlar um objeto de configuração sugerido
deve definir sua anotação <code>apf.kubernetes.io/autoupdate-spec</code>
para 'falso'.</p><p>A manutenção de um objeto de configuração obrigatório ou sugerido também
inclui garantir que ele tenha uma anotação <code>apf.kubernetes.io/autoupdate-spec</code>
que reflete com precisão se os kube-apiservers
controlam o objeto.</p><p>A manutenção também inclui a exclusão de objetos que não são obrigatórios
nem sugeridos, mas são anotados
<code>apf.kubernetes.io/autoupdate-spec=true</code>.</p><h2 id=isenção-de-simultaneidade-da-verificação-de-integridade>Isenção de simultaneidade da verificação de integridade</h2><p>A configuração sugerida não dá nenhum tratamento especial a checagem de saúde das requisições
verifique solicitações em kube-apiservers de seus kubelets locais --- que
tendem a usar a porta segura, mas não fornecem credenciais. Com o
configuração sugerida, essas solicitações são atribuídas ao <code>global-default</code>
FlowSchema e o nível de prioridade "global-default" correspondente,
onde outro tráfego pode bloqueá-los.</p><p>Se você adicionar o seguinte FlowSchema adicional, isso isenta aquelas
solicitações de limitação de taxa.</p><div class="alert alert-warning caution callout" role=alert><strong>Cuidado:</strong> Fazer essa alteração também permite que qualquer parte hostil envie
solicitações de verificação de integridade que correspondam a este FlowSchema, em qualquer volume.
Se você tiver um filtro de tráfego da Web ou outro mecanismo de segurança externa semelhante
para proteger o servidor de API do seu cluster do trafego geral de internet,
você pode configurar regras para bloquear qualquer solicitação de verificação de integridade
que se originam de fora do seu cluster.</div><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/pt-br/examples/priority-and-fairness/health-for-strangers.yaml download=priority-and-fairness/health-for-strangers.yaml><code>priority-and-fairness/health-for-strangers.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("priority-and-fairness-health-for-strangers-yaml")' title="Copy priority-and-fairness/health-for-strangers.yaml to clipboard"></img></div><div class=includecode id=priority-and-fairness-health-for-strangers-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>flowcontrol.apiserver.k8s.io/v1beta2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>FlowSchema<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>health-for-strangers<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>matchingPrecedence</span>:<span style=color:#bbb> </span><span style=color:#666>1000</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>priorityLevelConfiguration</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>exempt<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>nonResourceRules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>nonResourceURLs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;/healthz&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;/livez&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;/readyz&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;*&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Group<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>group</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:unauthenticated<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><h2 id=diagnóstico>Diagnóstico</h2><p>Cada resposta HTTP de um servidor da API com o recurso de prioridade e justiça
ativado tem dois cabeçalhos extras: <code>X-Kubernetes-PF-FlowSchema-UID</code> e
<code>X-Kubernetes-PF-PriorityLevel-UID</code>, observando o esquema de fluxo que corresponde à solicitação
e o nível de prioridade ao qual foi atribuído, respectivamente. Os nomes dos objetos da API
não são incluídos nesses cabeçalhos caso o usuário solicitante não
tenha permissão para visualizá-los, então ao depurar você pode usar um comando como</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get flowschemas -o custom-columns<span style=color:#666>=</span><span style=color:#b44>&#34;uid:{metadata.uid},name:{metadata.name}&#34;</span>
</span></span><span style=display:flex><span>kubectl get prioritylevelconfigurations -o custom-columns<span style=color:#666>=</span><span style=color:#b44>&#34;uid:{metadata.uid},name:{metadata.name}&#34;</span>
</span></span></code></pre></div><p>para obter um mapeamento de UIDs de nomes para FlowSchemas e
PriorityLevelConfigurations.</p><h2 id=observabilidade>Observabilidade</h2><h3 id=metricas>Metricas</h3><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Nas versões do Kubernetes anteriores à v1.20, as <em>labels</em> <code>flow_schema</code> e
<code>priority_level</code> foram nomeados de forma inconsistente como <code>flowSchema</code> e <code>priorityLevel</code>,
respectivamente. Se você estiver executando versões do Kubernetes v1.19 ou anteriores, você
deve consultar a documentação da sua versão.</div><p>Quando você ativa o APF, o kube-apiserver
exporta métricas adicionais. Monitorá-los pode ajudá-lo a determinar se a sua
configuração está limitando indevidamente o tráfego importante, ou encontrar
cargas de trabalho mal comportadas que podem estar prejudicando a integridade do sistema.</p><ul><li><p><code>apiserver_flowcontrol_rejected_requests_total</code> é um vetor de contador
(cumulativo desde o início do servidor) de solicitações que foram rejeitadas,
dividido pelos rótulos <code>flow_schema</code> (indicando aquele que
correspondeu ao pedido), <code>priority_level</code> (indicando aquele para o qual
a solicitação foi atribuída) e <code>reason</code>. A <em>label</em> <code>reason</code> pode
ter um dos seguintes valores:</p><ul><li><code>queue-full</code>, indicando que muitos pedidos já foram enfileirados,</li><li><code>concurrency-limit</code>, indicando que o
PriorityLevelConfiguration está configurado para rejeitar em vez de
enfileirar solicitações em excesso ou</li><li><code>time-out</code>, indicando que a solicitação ainda estava na fila
quando seu limite de tempo de fila expirou.</li></ul></li><li><p><code>apiserver_flowcontrol_dispatched_requests_total</code> é um vetor contador
(cumulativo desde o início do servidor) de solicitações que começaram
executando, dividido pelos rótulos <code>flow_schema</code> (indicando o
um que corresponda à solicitação) e <code>priority_level</code> (indicando o
aquele ao qual o pedido foi atribuído).</p></li><li><p><code>apiserver_current_inqueue_requests</code> é um vetor de medidor de
limites máximos do número de solicitações enfileiradas, agrupadas por uma
<em>label</em> chamado <code>request_kind</code> cujo valor é <code>mutating</code> ou <code>readOnly</code>.
Essas marcas d'água altas descrevem o maior número visto em uma
segunda janela concluída recentemente. Estes complementam o mais antigo
vetor medidor <code>apiserver_current_inflight_requests</code> que contém o
marca d'água alta da última janela de número de solicitações sendo ativamente
servido.</p></li><li><p><code>apiserver_flowcontrol_read_vs_write_request_count_samples</code> é um
vetor de histograma de observações do número atual de
solicitações, divididas pelos rótulos <code>phase</code> (que assume o
valores <code>waiting</code> e <code>executing</code>) e <code>request_kind</code> (que assume
os valores <code>mutating</code> e <code>readOnly</code>). As observações são feitas
periodicamente a uma taxa elevada.</p></li><li><p><code>apiserver_flowcontrol_read_vs_write_request_count_watermarks</code> é um
vetor de histograma de marcas d'água altas ou baixas do número de
solicitações divididas pelos rótulos <code>phase</code> (que assume o
valores <code>waiting</code> e <code>executing</code>) e <code>request_kind</code> (que assume
os valores <code>mutating</code> e <code>readOnly</code>); o rótulo <code>mark</code> assume
valores <code>high</code> e <code>low</code>. As marcas d'água são acumuladas ao longo de
janelas delimitadas pelos tempos em que uma observação foi adicionada a
<code>apiserver_flowcontrol_read_vs_write_request_count_samples</code>. Esses
marcas d'água mostram o intervalo de valores que ocorreram entre as amostras.</p></li><li><p><code>apiserver_flowcontrol_current_inqueue_requests</code> é um vetor de medidor
mantendo o número instantâneo de solicitações enfileiradas (não em execução),
dividido pelos rótulos <code>priority_level</code> e <code>flow_schema</code>.</p></li><li><p><code>apiserver_flowcontrol_current_executing_requests</code> é um vetor de medidor
segurando o número instantâneo de execução (não esperando em uma
queue), divididas pelos rótulos <code>priority_level</code> e
<code>flow_schema</code>.</p></li><li><p><code>apiserver_flowcontrol_request_concurrency_in_use</code> é um vetor de medidor
ocupando o número instantâneo de assentos ocupados, diferenciados pelas
<em>labels</em> <code>priority_level</code> e <code>flow_schema</code>.</p></li><li><p><code>apiserver_flowcontrol_priority_level_request_count_samples</code> é um
vetor de histograma de observações do número atual de
solicitações divididas pelas <em>labels</em> <code>phase</code> (que assume o
valores <code>waiting</code> e <code>executing</code>) e <code>priority_level</code>. Cada
histograma obtém observações feitas periodicamente, até a última
atividade do tipo relevante. As observações são feitas em nota alta.</p></li><li><p><code>apiserver_flowcontrol_priority_level_request_count_watermarks</code> é um
vetor de histograma de marcas d'água altas ou baixas do número de
solicitações divididas pelas <em>labels</em> <code>phase</code> (que assume o
valores <code>waiting</code> e <code>executing</code>) e <code>priority_level</code>; a <em>label</em>
<code>mark</code> assume valores <code>high</code> e <code>low</code>. As marcas da água são
acumulada em janelas delimitadas pelos tempos em que uma observação
foi adicionado a
<code>apiserver_flowcontrol_priority_level_request_count_samples</code>. Esses
marcas d'água mostram o intervalo de valores que ocorreram entre as amostras.</p></li><li><p><code>apiserver_flowcontrol_request_queue_length_after_enqueue</code> é um
vetor de histograma de comprimentos de fila para as filas, dividido pelas
<em>labels</em> <code>priority_level</code> e <code>flow_schema</code>, conforme mostrado pelas
solicitações enfileiradas. Cada solicitação enfileirada contribui com uma
amostra para seu histograma, relatando o comprimento da fila imediatamente
depois que o pedido foi adicionado. Observe que isso produz diferentes
estatísticas do que uma pesquisa imparcial faria.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Um valor discrepante em um histograma aqui significa que é provável que um único fluxo
(ou seja, solicitações de um usuário ou de um namespace, dependendo da
configuração) está inundando o servidor de API e sendo limitado. Por contraste,
se o histograma de um nível de prioridade mostrar que todas as filas para essa prioridade
são mais longos do que os de outros níveis de prioridade, pode ser apropriado
aumentar os compartilhamentos de simultaneidade desse PriorityLevelConfiguration.</div></li><li><p><code>apiserver_flowcontrol_request_concurrency_limit</code> é um vetor de medidor
mantendo o limite de simultaneidade calculado (com base no limite total de simultaneidade do servidor da API
e na simultaneidade de PriorityLevelConfigurations share), divididos pela <em>label</em> <code>priority_level</code>.</p></li><li><p><code>apiserver_flowcontrol_request_wait_duration_seconds</code> é um vetor de histograma
de quanto tempo as solicitações ficaram na fila, divididas pelas <em>labels</em>
<code>flow_schema</code> (indicando qual corresponde à solicitação),
<code>priority_level</code> (indicando aquele para o qual o pedido foi
atribuído) e <code>execute</code> (indicando se a solicitação foi iniciada
executando).</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Como cada FlowSchema sempre atribui solicitações a um único
PriorityLevelConfiguration, você pode adicionar os histogramas para todos os
FlowSchemas para um nível de prioridade para obter o histograma efetivo para
solicitações atribuídas a esse nível de prioridade.</div></li><li><p><code>apiserver_flowcontrol_request_execution_seconds</code> é um vetor de histograma
de quanto tempo as solicitações levaram para realmente serem executadas, divididas pelas
<em>labels</em> <code>flow_schema</code> (indicando qual corresponde à solicitação)
e <code>priority_level</code> (indicando aquele para o qual o pedido foi
atribuído).</p></li></ul><h3 id=debug-endpoints><em>Debug endpoints</em></h3><p>Quando você ativa A APF, o <code>kube-apiserver</code>
serve os seguintes caminhos adicionais em suas portas HTTP[S].</p><ul><li><p><code>/debug/api_priority_and_fairness/dump_priority_levels</code> - uma lista de
todos os níveis de prioridade e o estado atual de cada um. Você pode buscar assim:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get --raw /debug/api_priority_and_fairness/dump_priority_levels
</span></span></code></pre></div><p>A saída é parecido com isto:</p><pre tabindex=0><code class=language-none data-lang=none>PriorityLevelName, ActiveQueues, IsIdle, IsQuiescing, WaitingRequests, ExecutingRequests,
workload-low,      0,            true,   false,       0,               0,
global-default,    0,            true,   false,       0,               0,
exempt,            &lt;none&gt;,       &lt;none&gt;, &lt;none&gt;,      &lt;none&gt;,          &lt;none&gt;,
catch-all,         0,            true,   false,       0,               0,
system,            0,            true,   false,       0,               0,
leader-election,   0,            true,   false,       0,               0,
workload-high,     0,            true,   false,       0,               0,
</code></pre></li><li><p><code>/debug/api_priority_and_fairness/dump_queues</code> - uma listagem de todas as
filas e seu estado atual. Você pode buscar assim:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get --raw /debug/api_priority_and_fairness/dump_queues
</span></span></code></pre></div><p>A saída é parecido com isto:</p><pre tabindex=0><code class=language-none data-lang=none>PriorityLevelName, Index,  PendingRequests, ExecutingRequests, VirtualStart,
workload-high,     0,      0,               0,                 0.0000,
workload-high,     1,      0,               0,                 0.0000,
workload-high,     2,      0,               0,                 0.0000,
...
leader-election,   14,     0,               0,                 0.0000,
leader-election,   15,     0,               0,                 0.0000,
</code></pre></li><li><p><code>/debug/api_priority_and_fairness/dump_requests</code> - uma lista de todos os pedidos
que estão atualmente esperando em uma fila. Você pode buscar assim:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get --raw /debug/api_priority_and_fairness/dump_requests
</span></span></code></pre></div><p>A saída é parecido com isto:</p><pre tabindex=0><code class=language-none data-lang=none>PriorityLevelName, FlowSchemaName, QueueIndex, RequestIndexInQueue, FlowDistingsher,       ArriveTime,
exempt,            &lt;none&gt;,         &lt;none&gt;,     &lt;none&gt;,              &lt;none&gt;,                &lt;none&gt;,
system,            system-nodes,   12,         0,                   system:node:127.0.0.1, 2020-07-23T15:26:57.179170694Z,
</code></pre><p>Além das solicitações enfileiradas, a saída inclui uma linha fantasma
para cada nível de prioridade isento de limitação.</p><p>Você pode obter uma lista mais detalhada com um comando como este:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get --raw <span style=color:#b44>&#39;/debug/api_priority_and_fairness/dump_requests?includeRequestDetails=1&#39;</span>
</span></span></code></pre></div><p>A saída é parecido com isto:</p><pre tabindex=0><code class=language-none data-lang=none>PriorityLevelName, FlowSchemaName, QueueIndex, RequestIndexInQueue, FlowDistingsher,       ArriveTime,                     UserName,              Verb,   APIPath,                                                     Namespace, Name,   APIVersion, Resource, SubResource,
system,            system-nodes,   12,         0,                   system:node:127.0.0.1, 2020-07-23T15:31:03.583823404Z, system:node:127.0.0.1, create, /api/v1/namespaces/scaletest/configmaps,
system,            system-nodes,   12,         1,                   system:node:127.0.0.1, 2020-07-23T15:31:03.594555947Z, system:node:127.0.0.1, create, /api/v1/namespaces/scaletest/configmaps,
</code></pre></li></ul><h2 id=próximos-passos>Próximos passos</h2><p>Para obter informações básicas sobre detalhes de design para prioridade e justiça da API, consulte
a <a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-api-machinery/1040-priority-and-fairness>proposta de aprimoramento</a>.
Você pode fazer sugestões e solicitações de recursos por meio do <a href=https://github.com/kubernetes/community/tree/master/sig-api-machinery>SIG API Machinery</a>
ou do <a href=https://kubernetes.slack.com/messages/api-priority-and-fairness>canal do slack</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-7e0d97616b15e2c383c6a0a96ec442cb>3.11 - Extendendo o Kubernetes</h1></div><div class=td-content><h1 id=pg-0af41d3bd7c785621b58b7564793396a>3.11.1 - Extendendo a API do Kubernetes</h1></div><div class=td-content><h1 id=pg-1ea4977c0ebf97569bf54a477faa7fa5>3.11.1.1 - Extendendo a API do Kubernetes com a camada de agregação</h1><p>A camada de agregação permite ao Kubernetes ser estendido com APIs adicionais,
para além do que é oferecido pelas APIs centrais do Kubernetes.
As APIs adicionais podem ser soluções prontas tal como o
<a href=/docs/concepts/extend-kubernetes/service-catalog/>catálogo de serviços</a>,
ou APIs que você mesmo desenvolva.</p><p>A camada de agregação é diferente dos <a href=/docs/concepts/extend-kubernetes/api-extension/custom-resources/>Recursos Personalizados</a>,
que são uma forma de fazer o <a class=glossary-tooltip title='O componente da camada de gerenciamento que serve a API do Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label=kube-apiserver>kube-apiserver</a>
reconhecer novas espécies de objetos.</p><h2 id=camada-de-agregação>Camada de agregação</h2><p>A camada de agregação executa em processo com o kube-apiserver.
Até que um recurso de extensão seja registado, a camada de agregação
não fará nada. Para registar uma API, terá de adicionar um objeto <em>APIService</em>
que irá "reclamar" o caminho URL na API do Kubernetes. Nesta altura, a camada
de agregação procurará qualquer coisa enviada para esse caminho da API
(e.g. <code>/apis/myextension.mycompany.io/v1/…</code>) para o <em>APIService</em> registado.</p><p>A maneira mais comum de implementar o <em>APIService</em> é executar uma
<em>extensão do servidor API</em> em <em>Pods</em> que executam no seu cluster.
Se estiver a usar o servidor de extensão da API para gerir recursos
no seu cluster, o servidor de extensão da API (também escrito como "extension-apiserver")
é tipicamente emparelhado com um ou mais <a class=glossary-tooltip title='Um ciclo de controle que observa o estado partilhado do cluster através do API Server e efetua mudanças tentando mover o estado atual em direção ao estado desejado.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=controladores>controladores</a>.
A biblioteca apiserver-builder providencia um esqueleto para ambos
os servidores de extensão da API e controladores associados.</p><h3 id=latência-da-resposta>Latência da resposta</h3><p>Servidores de extensão de APIs devem ter baixa latência de rede de e para o kube-apiserver.
Pedidos de descoberta são necessários que façam a ida e volta do kube-apiserver em 5
segundos ou menos.</p><p>Se o seu servidor de extensão da API não puder cumprir com o requisito de latência,
considere fazer alterações que permitam atingi-lo. Pode também definir
<a href=/docs/reference/command-line-tools-reference/feature-gates/>portal de funcionalidade</a> <code>EnableAggregatedDiscoveryTimeout=false</code> no kube-apiserver para desativar
a restrição de intervalo. Esta portal de funcionalidade deprecado será removido
num lançamento futuro.</p><h2 id=próximos-passos>Próximos passos</h2><ul><li>Para pôr o agregador a funcionar no seu ambiente, <a href=/docs/tasks/access-kubernetes-api/configure-aggregation-layer/>configure a camada de agregação</a>.</li><li>De seguida, <a href=/docs/tasks/access-kubernetes-api/setup-extension-api-server/>configura um api-server de extensão</a> para funcionar com a camada de agregação.</li><li>Também, aprenda como pode <a href=/docs/tasks/access-kubernetes-api/extend-api-custom-resource-definitions/>estender a API do Kubernetes através do use de Definições de Recursos Personalizados</a>.</li><li>Leia a especificação do <a href=/docs/reference/generated/kubernetes-api/v1.25/#apiservice-v1-apiregistration-k8s-io>APIService</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-c8937cdc9df96f3328becf04f8211292>3.11.2 - Extensões de Computação, armazenamento e redes</h1></div><div class=td-content><h1 id=pg-1ac2260db9ecccbf0303a899bc27ce6d>3.11.2.1 - Plugins de rede</h1><p>Plugins de redes no Kubernetes podem ser dos seguintes tipos:</p><ul><li>Plugins CNI: Aderentes à especificação <a href=https://github.com/containernetworking/cni>Container Network Interface</a> (CNI), desenhados para interoperabilidade.<ul><li>Kubernetes usa a versão <a href=https://github.com/containernetworking/cni/blob/spec-v0.4.0/SPEC.md>v0.4.0</a> da especificação CNI.</li></ul></li><li>Plugin kubenet: Implementa o <code>cbr0</code> básico usando os plugins CNI <code>bridge</code> e <code>host-local</code></li></ul><h2 id=instalação>Instalação</h2><p>O kubelet possui um plugin único padrão, e um plugin padrão comum para todo o cluster.
Ele verifica o plugin quando inicia, se lembra o que encontrou, e executa o plugin selecionado
em momentos oportunos dentro do ciclo de vida de um Pod (isso é verdadeiro apenas com o Docker,
uma vez que o CRI gerencia seus próprios plugins de CNI). Existem dois parâmetros de linha de comando
no Kubelet para se ter em mente quando usando plugins:</p><ul><li><code>cni-bin-dir</code>: O Kubelet verifica esse diretório por plugins na inicialização</li><li><code>network-plugin</code>: O plugin de rede que deve ser utilizado do diretório configurado em
<code>cni-bin-dir</code>. Deve ser igual ao nome configurado por um plugin no diretório de plugins.
Para plugins de CNI, isso equivale ao valor <code>cni</code>.</li></ul><h2 id=requisitos-de-plugins-de-rede>Requisitos de plugins de Rede</h2><p>Além de prover a <a href=https://github.com/kubernetes/kubernetes/tree/v1.25.0/pkg/kubelet/dockershim/network/plugins.go>interface <code>NetworkPlugin</code></a>
para configuração da rede do pod, o plugin pode necessitar de suporte específico ao
kube-proxy.
O proxy iptables obviamente depende do iptables, e o plugin deve garantir que o
tráfego do contêiner esteja disponível para o iptables. Por exemplo, se o plugin
conecta os contêineres à <em>Linux bridge</em>, o plugin deve configurar a diretiva de
<em>sysctl</em> <code>net/bridge/bridge-nf-call-iptables</code> com o valor <code>1</code> para garantir que o
proxy iptables opere normalmente. Se o plugin não faz uso da <em>Linux Bridge</em> (mas outro
mecanismo, como Open vSwitch) ele deve garantir que o tráfego do contêiner é roteado
apropriadamente para o proxy.</p><p>Por padrão, se nenhum plugin de rede é configurado no kubelet, o plugin <code>noop</code> é utilizado,
que configura <code>net/bridge/bridge-nf-call-iptables=1</code> para garantir que configurações simples
(como Docker com <em>bridge Linux</em>) operem corretamente com o proxy iptables.</p><h3 id=cni>CNI</h3><p>O plugin de CNI é selecionado utilizando-se da opção <code>--network-plugin=cni</code> no início do Kubeket.
O Kubelet lê um arquivo do diretório especificado em <code>--cni-conf-dir</code> (padrão <code>/etc/cni/net.d</code>)
e usa a configuração de CNI desse arquivo para configurar a rede de cada Pod. O arquivo de
configuração do CNI deve usar a <a href=https://github.com/containernetworking/cni/blob/master/SPEC.md#network-configuration>especificação de CNI</a>,
e qualquer plugin referenciado nesse arquivo deve estar presente no diretório
<code>--cni-bin-dir</code> (padrão <code>/opt/cni/bin</code>).</p><p>Se existirem múltiplos arquivos de configuração no diretório, o kubelet usa o arquivo de
configuração que vier primeiro pelo nome, em ordem alfabética.</p><p>Adicionalmente ao plugin de CNI especificado no arquivo de configuração, o Kubernetes requer
o plugin CNI padrão <a href=https://github.com/containernetworking/plugins/blob/master/plugins/main/loopback/loopback.go><code>lo</code></a> ao menos na versão 0.2.0.</p><h4 id=suporte-a-hostport>Suporte a hostPort</h4><p>O plugin de redes CNI suporta <code>hostPort</code>. Você pode utilizar o plugin oficial
<a href=https://github.com/containernetworking/plugins/tree/master/plugins/meta/portmap>portmap</a>
ou usar seu próprio plugin com a funcionalidade de <em>portMapping</em>.</p><p>Caso você deseje habilitar o suporte a <code>hostPort</code>, você deve especificar
<code>portMappings capability</code> no seu <code>cni-conf-dir</code>.
Por exemplo:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;k8s-pod-network&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;cniVersion&#34;</span>: <span style=color:#b44>&#34;0.4.0&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;plugins&#34;</span>: [
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;calico&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;log_level&#34;</span>: <span style=color:#b44>&#34;info&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;datastore_type&#34;</span>: <span style=color:#b44>&#34;kubernetes&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;nodename&#34;</span>: <span style=color:#b44>&#34;127.0.0.1&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;ipam&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;host-local&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;subnet&#34;</span>: <span style=color:#b44>&#34;usePodCidr&#34;</span>
</span></span><span style=display:flex><span>      },
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;policy&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;k8s&#34;</span>
</span></span><span style=display:flex><span>      },
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;kubernetes&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;kubeconfig&#34;</span>: <span style=color:#b44>&#34;/etc/cni/net.d/calico-kubeconfig&#34;</span>
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;portmap&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;capabilities&#34;</span>: {<span style=color:green;font-weight:700>&#34;portMappings&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>}
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  ]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=suporte-a-controle-de-banda>Suporte a controle de banda</h4><p><strong>Funcionalidade experimental</strong></p><p>O plugin de rede CNI também suporta o controle de banda de entrada e saída.
Você pode utilizar o plugin oficial <a href=https://github.com/containernetworking/plugins/tree/master/plugins/meta/bandwidth>bandwidth</a>
desenvolvido ou usar seu próprio plugin de controle de banda.</p><p>Se você habilitar o suporte ao controle de banda, você deve adicionar o plugin <code>bandwidth</code>
no seu arquivo de configuração de CNI (padrão <code>/etc/cni/net.d</code>) e garantir que o programa
exista no diretório de binários do CNI (padrão <code>/opt/cni/bin</code>).</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;k8s-pod-network&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;cniVersion&#34;</span>: <span style=color:#b44>&#34;0.4.0&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;plugins&#34;</span>: [
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;calico&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;log_level&#34;</span>: <span style=color:#b44>&#34;info&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;datastore_type&#34;</span>: <span style=color:#b44>&#34;kubernetes&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;nodename&#34;</span>: <span style=color:#b44>&#34;127.0.0.1&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;ipam&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;host-local&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;subnet&#34;</span>: <span style=color:#b44>&#34;usePodCidr&#34;</span>
</span></span><span style=display:flex><span>      },
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;policy&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;k8s&#34;</span>
</span></span><span style=display:flex><span>      },
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;kubernetes&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;kubeconfig&#34;</span>: <span style=color:#b44>&#34;/etc/cni/net.d/calico-kubeconfig&#34;</span>
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;bandwidth&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;capabilities&#34;</span>: {<span style=color:green;font-weight:700>&#34;bandwidth&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>}
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  ]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Agora você pode adicionar as anotações <code>kubernetes.io/ingress-bandwidth</code> e
<code>kubernetes.io/egress-bandwidth</code> em seu pod.
Por exemplo:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/ingress-bandwidth</span>:<span style=color:#bbb> </span>1M<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/egress-bandwidth</span>:<span style=color:#bbb> </span>1M<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=kubenet>kubenet</h3><p>Kubenet é um plugin de rede muito simples, existente apenas no Linux. Ele não
implementa funcionalidades mais avançadas, como rede entre nós ou políticas de rede.
Ele é geralmente utilizado junto a um provedor de nuvem que configura as regras de
roteamento para comunicação entre os nós, ou em ambientes com apenas um nó.</p><p>O Kubenet cria uma <em>interface bridge</em> no Linux chamada <code>cbr0</code> e cria um par <em>veth</em>
para cada um dos pods com o host como a outra ponta desse par, conectado à <code>cbr0</code>.
Na interface no lado do Pod um endereço IP é alocado de uma faixa associada ao nó,
sendo parte de alguma configuração no nó ou pelo controller-manager. Na interface <code>cbr0</code>
é associado o MTU equivalente ao menor MTU de uma interface de rede do host.</p><p>Esse plugin possui alguns requisitos:</p><ul><li>Os plugins CNI padrão <code>bridge</code>, <code>lo</code> e <code>host-local</code> são obrigatórios, ao menos na
versão 0.2.0. O Kubenet buscará inicialmente esses plugins no diretório <code>/opt/cni/bin</code>.
Especifique a opção <code>cni-bin-dir</code> no kubelet para fornecer um diretório adicional
de busca. O primeiro local equivalente será o utilizado.</li><li>O kubelet deve ser executado com a opção <code>--network-plugin=kubenet</code> para habilitar esse plugin.</li><li>O Kubelet deve ainda ser executado com a opção <code>--non-masquerade-cidr=&lt;clusterCidr></code> para
garantir que o tráfego de IPs para fora dessa faixa seja mascarado.</li><li>O nó deve possuir uma subrede associada, através da opção <code>--pod-cidr</code> configurada
na inicialização do kubelet, ou as opções <code>--allocate-node-cidrs=true --cluster-cidr=&lt;cidr></code>
utilizadas na inicialização do <em>controller-manager</em>.</li></ul><h3 id=customizando-o-mtu-com-kubenet>Customizando o MTU (com kubenet)</h3><p>O MTU deve sempre ser configurado corretamente para obter-se a melhor performance de
rede. Os plugins de rede geralmente tentam detectar uma configuração correta de MTU,
porém algumas vezes a lógica não irá resultar em uma configuração adequada. Por exemplo,
se a <em>Docker bridge</em> ou alguma outra interface possuir um MTU pequeno, o kubenet irá
selecionar aquela MTU. Ou caso você esteja utilizando encapsulamento IPSEC, o MTU deve
ser reduzido, e esse cálculo não faz parte do escopo da maioria dos plugins de rede.</p><p>Sempre que necessário, você pode configurar explicitamente o MTU com a opção <code>network-plugin-mtu</code>
no kubelet. Por exemplo, na AWS o MTU da <code>eth0</code> geralmente é 9001 então você deve
especificar <code>--network-plugin-mtu=9001</code>. Se você estiver usando IPSEC você deve reduzir
o MTU para permitir o encapsulamento excedente; por exemplo: <code>--network-plugin-mtu=8773</code>.</p><p>Essa opção faz parte do plugin de rede. Atualmente <strong>apenas o kubenet suporta a configuração
<code>network-plugin-mtu</code></strong>.</p><h2 id=resumo-de-uso>Resumo de uso</h2><ul><li><code>--network-plugin=cni</code> especifica que devemos usar o plugin de redes <code>cni</code> com os
binários do plugin localizados em <code>--cni-bin-dir</code> (padrão <code>/opt/cni/bin</code>) e as
configurações do plugin localizadas em <code>--cni-conf-dir</code> (default <code>/etc/cni/net.d</code>).</li><li><code>--network-plugin=kubenet</code> especifica que iremos usar o plugin de rede <code>kubenet</code>
com os plugins CNI <code>bridge</code>, <code>lo</code> e <code>host-local</code> localizados em <code>/opt/cni/bin</code> ou <code>cni-bin-dir</code>.</li><li><code>--network-plugin-mtu=9001</code> especifica o MTU a ser utilizado, atualmente apenas em uso
pelo plugin de rede <code>kubenet</code></li></ul><h2 id=próximos-passos>Próximos passos</h2></div><div class=td-content style=page-break-before:always><h1 id=pg-3131452556176159fb269593c1a52012>3.11.3 - Padrão Operador</h1><p>Operadores são extensões de software para o Kubernetes que
fazem uso de <a href=/docs/concepts/extend-kubernetes/api-extension/custom-resources/><em>recursos personalizados</em></a>
para gerir aplicações e os seus componentes. Operadores seguem os<br>princípios do Kubernetes, notavelmente o <a href=/docs/concepts/#kubernetes-control-plane>ciclo de controle</a>.</p><h2 id=motivação>Motivação</h2><p>O padrão Operador tem como objetivo capturar o principal objetivo de um operador
humano que gere um serviço ou um conjunto de serviços. Operadores humanos
responsáveis por aplicações e serviços específicos têm um conhecimento
profundo da forma como o sistema é suposto se comportar, como é instalado
e como deve reagir na ocorrência de problemas.</p><p>As pessoas que executam cargas de trabalho no Kubernetes habitualmente gostam
de usar automação para cuidar de tarefas repetitivas. O padrão Operador captura
a forma como pode escrever código para automatizar uma tarefa para além do que
o Kubernetes fornece.</p><h2 id=operadores-no-kubernetes>Operadores no Kubernetes</h2><p>O Kubernetes é desenhado para automação. <em>Out of the box</em>, você tem bastante
automação embutida no núcleo do Kubernetes. Pode usar
o Kubernetes para automatizar instalações e executar cargas de trabalho,
e pode ainda automatizar a forma como o Kubernetes faz isso.</p><p>O conceito de <a class=glossary-tooltip title='Um ciclo de controle que observa o estado partilhado do cluster através do API Server e efetua mudanças tentando mover o estado atual em direção ao estado desejado.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=controlador>controlador</a> no
Kubernetes permite a extensão do comportamento sem modificar o código do próprio
Kubernetes.
Operadores são clientes da API do Kubernetes que atuam como controladores para
um dado <a href=/docs/concepts/api-extension/custom-resources/><em>Custom Resource</em></a></p><h2 id=exemplo>Exemplo de um Operador</h2><p>Algumas das coisas que um operador pode ser usado para automatizar incluem:</p><ul><li>instalar uma aplicação a pedido</li><li>obter e restaurar backups do estado dessa aplicação</li><li>manipular atualizações do código da aplicação juntamente com alterações
como esquemas de base de dados ou definições de configuração extra</li><li>publicar um <em>Service</em> para aplicações que não suportam a APIs do Kubernetes
para as descobrir</li><li>simular uma falha em todo ou parte do cluster de forma a testar a resiliência</li><li>escolher um lider para uma aplicação distribuída sem um processo
de eleição de membro interno</li></ul><p>Como deve um Operador parecer em mais detalhe? Aqui está um exemplo em mais
detalhe:</p><ol><li>Um recurso personalizado (<em>custom resource</em>) chamado SampleDB, que você pode
configurar para dentro do <em>cluster</em>.</li><li>Um <em>Deployment</em> que garante que um <em>Pod</em> está a executar que contém a
parte controlador do operador.</li><li>Uma imagem do <em>container</em> do código do operador.</li><li>Código do controlador que consulta o plano de controle para descobrir quais
recursos <em>SampleDB</em> estão configurados.</li><li>O núcleo do Operador é o código para informar ao servidor da API (<em>API server</em>) como fazer
a realidade coincidir com os recursos configurados.<ul><li>Se você adicionar um novo <em>SampleDB</em>, o operador configurará <em>PersistentVolumeClaims</em>
para fornecer armazenamento de base de dados durável, um <em>StatefulSet</em> para executar <em>SampleDB</em> e
um <em>Job</em> para lidar com a configuração inicial.</li><li>Se você apagá-lo, o Operador tira um <em>snapshot</em> e então garante que
o <em>StatefulSet</em> e <em>Volumes</em> também são removidos.</li></ul></li><li>O operador também gere backups regulares da base de dados. Para cada recurso <em>SampleDB</em>,
o operador determina quando deve criar um <em>Pod</em> que possa se conectar
à base de dados e faça backups. Esses <em>Pods</em> dependeriam de um <em>ConfigMap</em>
e / ou um <em>Secret</em> que possui detalhes e credenciais de conexão com à base de dados.</li><li>Como o Operador tem como objetivo fornecer automação robusta para o recurso
que gere, haveria código de suporte adicional. Para este exemplo,
O código verifica se a base de dados está a executar uma versão antiga e, se estiver,
cria objetos <em>Job</em> que o atualizam para si.</li></ol><h2 id=instalar-operadores>Instalar Operadores</h2><p>A forma mais comum de instalar um Operador é a de adicionar a
definição personalizada de recurso (<em>Custom Resource Definition</em>) e
o seu Controlador associado ao seu cluster.
O Controlador vai normalmente executar fora do
<a class=glossary-tooltip title='A camada de gerenciamento de contêiner que expõe a API e as interfaces para definir, implantar e gerenciar o ciclo de vida dos contêineres.' data-toggle=tooltip data-placement=top href='/pt-br/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='plano de controle'>plano de controle</a>,
como você faria com qualquer aplicação containerizada.
Por exemplo, você pode executar o controlador no seu cluster como um <em>Deployment</em>.</p><h2 id=usando-um-operador>Usando um Operador</h2><p>Uma vez que você tenha um Operador instalado, usaria-o adicionando, modificando
ou apagando a espécie de recurso que o Operador usa. Seguindo o exemplo acima,
você configuraria um <em>Deployment</em> para o próprio Operador, e depois:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get SampleDB                   <span style=color:#080;font-style:italic># encontra a base de dados configurada</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl edit SampleDB/example-database <span style=color:#080;font-style:italic># mudar manualmente algumas definições</span>
</span></span></code></pre></div><p>…e é isso! O Operador vai tomar conta de aplicar
as mudanças assim como manter o serviço existente em boa forma.</p><h2 id=escrevendo-operador>Escrevendo o seu próprio Operador</h2><p>Se não existir no ecosistema um Operador que implementa
o comportamento que pretende, pode codificar o seu próprio.
<a href=#qual-%C3%A9-o-pr%C3%B3ximo>Qual é o próximo</a> você vai encontrar
alguns <em>links</em> para bibliotecas e ferramentas que pode usar
para escrever o seu próprio Operador <em>cloud native</em>.</p><p>Pode também implementar um Operador (isto é, um Controlador) usando qualquer linguagem / <em>runtime</em>
que pode atuar como um <a href=/docs/reference/using-api/client-libraries/>cliente da API do Kubernetes</a>.</p><h2 id=próximos-passos>Próximos passos</h2><ul><li>Aprenda mais sobre <a href=/docs/concepts/extend-kubernetes/api-extension/custom-resources/>Recursos Personalizados</a></li><li>Encontre operadores prontos em <a href=https://operatorhub.io/>OperatorHub.io</a> para o seu caso de uso</li><li>Use ferramentes existentes para escrever os seus Operadores:<ul><li>usando <a href=https://kudo.dev/>KUDO</a> (Kubernetes Universal Declarative Operator)</li><li>usando <a href=https://book.kubebuilder.io/>kubebuilder</a></li><li>usando <a href=https://metacontroller.github.io/metacontroller/intro.html>Metacontroller</a> juntamente com WebHooks que
implementa você mesmo</li><li>usando o <a href=https://operatorframework.io/>Operator Framework</a></li></ul></li><li><a href=https://operatorhub.io/>Publique</a> o seu operador para que outras pessoas o possam usar</li><li>Leia o <a href=https://coreos.com/blog/introducing-operators.html>artigo original da CoreOS</a> que introduz o padrão Operador</li><li>Leia um <a href=https://cloud.google.com/blog/products/containers-kubernetes/best-practices-for-building-kubernetes-operators-and-stateful-apps>artigo</a> da Google Cloud sobre as melhores práticas para contruir Operadores</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-f8918f697450c2009b75913f9e9317a5>4 - Tarefas</h1><p>Essa seção da documentação contém páginas que mostram como executar tarefas individuais.</p><p>Essas tarefas são organizadas em uma curta sequência de etapas e passos que te auxiliam a entender conceitos básicos.</p><p>Se você desejar adicionar uma tarefa, verifique como
<a href=/docs/contribute/new-content/open-a-pr/>criar um Pull Request para a documentação</a>.</p></div><div class=td-content><h1 id=pg-94f49ece137035764368f22a98942872>4.1 - Gerenciando Secrets</h1><div class=lead>Gerenciando dados de configurações usando Secrets.</div></div><div class=td-content><h1 id=pg-0ed63ce3c9665aed7ff5a560ff1da843>4.1.1 - Gerenciando Secret usando kubectl</h1><div class=lead>Criando objetos Secret usando a linha de comando kubectl.</div><h2 id=antes-de-você-começar>Antes de você começar</h2><p>Você precisa de um cluster Kubernetes e a ferramenta de linha de comando kubectl
precisa estar configurada para acessar o seu cluster. Se você ainda não tem um
cluster, pode criar um usando o <a href=/docs/tasks/tools/#minikube>minikube</a>
ou você pode usar um dos seguintes ambientes:</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul><h2 id=criando-um-secret>Criando um Secret</h2><p>Um <code>Secret</code> pode conter credenciais de usuário requeridas por Pods para acesso a um banco de dados.
Por exemplo, uma string de conexão de banco de dados é composta por um usuário e senha.
Você pode armazenar o usuário em um arquivo <code>./username.txt</code> e a senha em um
arquivo <code>./password.txt</code> na sua máquina local.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>echo</span> -n <span style=color:#b44>&#39;admin&#39;</span> &gt; ./username.txt
</span></span><span style=display:flex><span><span style=color:#a2f>echo</span> -n <span style=color:#b44>&#39;1f2d1e2e67df&#39;</span> &gt; ./password.txt
</span></span></code></pre></div><p>A opção <code>-n</code> nos comandos acima garante que os arquivos criados não vão conter
uma nova linha extra no final do arquivo de texto. Isso é importante porque
quando o <code>kubectl</code> lê um arquivo e codifica o conteúdo em uma string base64,
o caractere da nova linha extra também é codificado.</p><p>O comando <code>kubectl create secret</code> empacota os arquivos em um Secret e cria um
objeto no API server.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret generic db-user-pass <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --from-file<span style=color:#666>=</span>./username.txt <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --from-file<span style=color:#666>=</span>./password.txt
</span></span></code></pre></div><p>A saída deve ser similar a:</p><pre tabindex=0><code>secret/db-user-pass created
</code></pre><p>O nome da chave padrão é o nome do arquivo. Opcionalmente, você pode definir
o nome da chave usando <code>--from-file=[key=]source</code>. Por exemplo:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret generic db-user-pass <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --from-file<span style=color:#666>=</span><span style=color:#b8860b>username</span><span style=color:#666>=</span>./username.txt <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --from-file<span style=color:#666>=</span><span style=color:#b8860b>password</span><span style=color:#666>=</span>./password.txt
</span></span></code></pre></div><p>Você não precisa escapar o caractere especial em senhas a partir de arquivos (<code>--from-file</code>).</p><p>Você também pode prover dados para Secret usando a tag <code>--from-literal=&lt;key>=&lt;value></code>.
Essa tag pode ser especificada mais de uma vez para prover múltiplos pares de chave-valor.
Observe que caracteres especiais como <code>$</code>, <code>\</code>, <code>*</code>, <code>=</code>, e <code>!</code> vão ser interpretados
pelo seu <a href=https://en.wikipedia.org/wiki/Shell_(computing)>shell</a> e precisam ser escapados.
Na maioria dos shells, a forma mais fácil de escapar as senhas é usar aspas simples (<code>'</code>).
Por exemplo, se sua senha atual é <code>S!B\*d$zDsb=</code>, você precisa executar o comando dessa forma:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret generic db-user-pass <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --from-literal<span style=color:#666>=</span><span style=color:#b8860b>username</span><span style=color:#666>=</span>devuser <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --from-literal<span style=color:#666>=</span><span style=color:#b8860b>password</span><span style=color:#666>=</span><span style=color:#b44>&#39;S!B\*d$zDsb=&#39;</span>
</span></span></code></pre></div><h2 id=verificando-o-secret>Verificando o Secret</h2><p>Você pode verificar se o secret foi criado:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get secrets
</span></span></code></pre></div><p>A saída deve ser similar a:</p><pre tabindex=0><code>NAME                  TYPE                                  DATA      AGE
db-user-pass          Opaque                                2         51s
</code></pre><p>Você pode ver a descrição do <code>Secret</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe secrets/db-user-pass
</span></span></code></pre></div><p>A saída deve ser similar a:</p><pre tabindex=0><code>Name:            db-user-pass
Namespace:       default
Labels:          &lt;none&gt;
Annotations:     &lt;none&gt;

Type:            Opaque

Data
====
password:    12 bytes
username:    5 bytes
</code></pre><p>Os comandos <code>kubectl get</code> e <code>kubectl describe</code> omitem o conteúdo de um <code>Secret</code> por padrão.
Isso para proteger o <code>Secret</code> de ser exposto acidentalmente para uma pessoa não autorizada,
ou ser armazenado em um log de terminal.</p><h2 id=decoding-secret>Decodificando o Secret</h2><p>Para ver o conteúdo de um Secret que você criou, execute o seguinte comando:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get secret db-user-pass -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.data}&#39;</span>
</span></span></code></pre></div><p>A saída deve ser similar a:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{<span style=color:green;font-weight:700>&#34;password&#34;</span>:<span style=color:#b44>&#34;MWYyZDFlMmU2N2Rm&#34;</span>,<span style=color:green;font-weight:700>&#34;username&#34;</span>:<span style=color:#b44>&#34;YWRtaW4=&#34;</span>}
</span></span></code></pre></div><p>Agora, você pode decodificar os dados de <code>password</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b44>&#39;MWYyZDFlMmU2N2Rm&#39;</span> | base64 --decode
</span></span></code></pre></div><p>A saída deve ser similar a:</p><pre tabindex=0><code>1f2d1e2e67df
</code></pre><h2 id=limpeza>Limpeza</h2><p>Para apagar o Secret que você criou:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete secret db-user-pass
</span></span></code></pre></div><h2 id=próximos-passos>Próximos passos</h2><ul><li>Leia mais sobre o <a href=/docs/concepts/configuration/secret/>conceito do Secret</a></li><li>Leia sobre como <a href=/docs/tasks/configmap-secret/managing-secret-using-kubectl/>gerenciar Secret com o comando <code>kubectl</code></a></li><li>Leia sobre como <a href=/docs/tasks/configmap-secret/managing-secret-using-kustomize/>gerenciar Secret usando kustomize</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-e841cf91fd3566db1e86143ed7a9e13c>4.1.2 - Gerenciando Secret usando Arquivo de Configuração</h1><div class=lead>Criando objetos Secret usando arquivos de configuração de recursos.</div><h2 id=antes-de-você-começar>Antes de você começar</h2><p>Você precisa de um cluster Kubernetes e a ferramenta de linha de comando kubectl
precisa estar configurada para acessar o seu cluster. Se você ainda não tem um
cluster, pode criar um usando o <a href=/docs/tasks/tools/#minikube>minikube</a>
ou você pode usar um dos seguintes ambientes:</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul><h2 id=crie-o-arquivo-de-configuração>Crie o arquivo de configuração</h2><p>Você pode criar um Secret primeiramente em um arquivo, no formato JSON ou YAML, e depois
criar o objeto. O recurso <a href=/docs/reference/generated/kubernetes-api/v1.25/#secret-v1-core>Secret</a>
contém dois mapas: <code>data</code> e <code>stringData</code>.
O campo <code>data</code> é usado para armazenar dados arbitrários, codificados usando base64. O
campo <code>stringData</code> é usado por conveniência, e permite que você use dados para um Secret
como <em>strings</em> não codificadas.
As chaves para <code>data</code> e <code>stringData</code> precisam ser compostas por caracteres alfanuméricos,
<code>_</code>, <code>-</code> ou <code>.</code>.</p><p>Por exemplo, para armazenar duas strings em um Secret usando o campo <code>data</code>, converta
as strings para base64 da seguinte forma:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>echo</span> -n <span style=color:#b44>&#39;admin&#39;</span> | base64
</span></span></code></pre></div><p>A saída deve ser similar a:</p><pre tabindex=0><code>YWRtaW4=
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>echo</span> -n <span style=color:#b44>&#39;1f2d1e2e67df&#39;</span> | base64
</span></span></code></pre></div><p>A saída deve ser similar a:</p><pre tabindex=0><code>MWYyZDFlMmU2N2Rm
</code></pre><p>Escreva o arquivo de configuração do Secret, que será parecido com:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Opaque<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>username</span>:<span style=color:#bbb> </span>YWRtaW4=<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>password</span>:<span style=color:#bbb> </span>MWYyZDFlMmU2N2Rm<span style=color:#bbb>
</span></span></span></code></pre></div><p>Perceba que o nome do objeto Secret precisa ser um
<a href=/pt-br/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>nome de subdomínio DNS</a> válido.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Os valores serializados dos dados JSON e YAML de um Secret são codificados em strings
base64. Novas linhas não são válidas com essas strings e devem ser omitidas. Quando
usar o utilitário <code>base64</code> em Darwin/MacOS, os usuários devem evitar usar a opção <code>-b</code>
para separar linhas grandes. Por outro lado, usuários de Linux <em>devem</em> adicionar a opção
<code>-w 0</code> ao comando <code>base64</code> ou o <em>pipe</em> <code>base64 | tr -d '\n'</code> se a opção <code>w</code> não estiver disponível</div><p>Para cenários específicos, você pode querer usar o campo <code>stringData</code> ao invés de <code>data</code>.
Esse campo permite que você use strings não-base64 diretamente dentro do Secret,
e a string vai ser codificada para você quando o Secret for criado ou atualizado.</p><p>Um exemplo prático para isso pode ser quando você esteja fazendo <em>deploy</em> de uma aplicação
que usa um Secret para armazenar um arquivo de configuração, e você quer popular partes desse
arquivo de configuração durante o processo de implantação.</p><p>Por exemplo, se sua aplicação usa o seguinte arquivo de configuração:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiUrl</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;https://my.api.com/api/v1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>username</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&lt;user&gt;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>password</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&lt;password&gt;&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Você pode armazenar isso em um Secret usando a seguinte definição:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Opaque<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>stringData</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>config.yaml</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    apiUrl: &#34;https://my.api.com/api/v1&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    username: &lt;user&gt;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    password: &lt;password&gt;</span><span style=color:#bbb>    
</span></span></span></code></pre></div><h2 id=crie-o-objeto-secret>Crie o objeto Secret</h2><p>Agora, crie o Secret usando <a href=/docs/reference/generated/kubectl/kubectl-commands#apply><code>kubectl apply</code></a>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f ./secret.yaml
</span></span></code></pre></div><p>A saída deve ser similar a:</p><pre tabindex=0><code>secret/mysecret created
</code></pre><h2 id=verifique-o-secret>Verifique o Secret</h2><p>O campo <code>stringData</code> é um campo de conveniência apenas de leitura. Ele nunca vai ser exibido
ao buscar um Secret. Por exemplo, se você executar o seguinte comando:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get secret mysecret -o yaml
</span></span></code></pre></div><p>A saída deve ser similar a:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2018-11-15T20:40:59Z<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;7225&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>c280ad2e-e916-11e8-98f2-025000000001<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Opaque<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>config.yaml</span>:<span style=color:#bbb> </span>YXBpVXJsOiAiaHR0cHM6Ly9teS5hcGkuY29tL2FwaS92MSIKdXNlcm5hbWU6IHt7dXNlcm5hbWV9fQpwYXNzd29yZDoge3twYXNzd29yZH19<span style=color:#bbb>
</span></span></span></code></pre></div><p>Os comandos <code>kubectl get</code> e <code>kubectl describe</code> omitem o conteúdo de um <code>Secret</code> por padrão.
Isso para proteger o <code>Secret</code> de ser exposto acidentalmente para uma pessoa não autorizada,
ou ser armazenado em um log de terminal.
Para verificar o conteúdo atual de um dado codificado, veja <a href=/docs/tasks/configmap-secret/managing-secret-using-kubectl/#decoding-secret>decodificando secret</a>.</p><p>Se um campo, como <code>username</code>, é especificado em <code>data</code> e <code>stringData</code>,
o valor de <code>stringData</code> é o usado. Por exemplo, dada a seguinte definição do Secret:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Opaque<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>username</span>:<span style=color:#bbb> </span>YWRtaW4=<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>stringData</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>username</span>:<span style=color:#bbb> </span>administrator<span style=color:#bbb>
</span></span></span></code></pre></div><p>Resulta no seguinte Secret:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2018-11-15T20:46:46Z<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;7579&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>91460ecb-e917-11e8-98f2-025000000001<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Opaque<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>username</span>:<span style=color:#bbb> </span>YWRtaW5pc3RyYXRvcg==<span style=color:#bbb>
</span></span></span></code></pre></div><p>Onde <code>YWRtaW5pc3RyYXRvcg==</code> é decodificado em <code>administrator</code>.</p><h2 id=limpeza>Limpeza</h2><p>Para apagar o Secret que você criou:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete secret mysecret
</span></span></code></pre></div><h2 id=próximos-passos>Próximos passos</h2><ul><li>Leia mais sobre o <a href=/docs/concepts/configuration/secret/>conceito do Secret</a></li><li>Leia sobre como <a href=/docs/tasks/configmap-secret/managing-secret-using-kubectl/>gerenciar Secret com o comando <code>kubectl</code></a></li><li>Leia sobre como <a href=/docs/tasks/configmap-secret/managing-secret-using-kustomize/>gerenciar Secret usando kustomize</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-a0ff2e3ba8af5670d5dc3d94c4bd0a68>4.1.3 - Gerenciando Secret usando Kustomize</h1><div class=lead>Criando objetos Secret usando o arquivo kustomization.yaml</div><p>Desde o Kubernetes v1.14, o <code>kubectl</code> provê suporte para <a href=/docs/tasks/manage-kubernetes-objects/kustomization/>gerenciamento de objetos usando Kustomize</a>.
O Kustomize provê geradores de recursos para criar Secrets e ConfigMaps.
Os geradores Kustomize devem ser especificados em um arquivo <code>kustomization.yaml</code> dentro
de um diretório. Depois de gerar o Secret, você pode criar o Secret com <code>kubectl apply</code>.</p><h2 id=antes-de-você-começar>Antes de você começar</h2><p>Você precisa de um cluster Kubernetes e a ferramenta de linha de comando kubectl
precisa estar configurada para acessar o seu cluster. Se você ainda não tem um
cluster, pode criar um usando o <a href=/docs/tasks/tools/#minikube>minikube</a>
ou você pode usar um dos seguintes ambientes:</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul><h2 id=criando-um-arquivo-de-kustomization>Criando um arquivo de Kustomization</h2><p>Você pode criar um Secret definindo um <code>secretGenerator</code> em um
arquivo <code>kustomization.yaml</code> que referencia outros arquivos existentes.
Por exemplo, o seguinte arquivo kustomization referencia os
arquivos <code>./username.txt</code> e <code>./password.txt</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>secretGenerator</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>db-user-pass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>files</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- username.txt<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- password.txt<span style=color:#bbb>
</span></span></span></code></pre></div><p>Você também pode definir o <code>secretGenerator</code> no arquivo <code>kustomization.yaml</code>
por meio de alguns <em>literais</em>.
Por exemplo, o seguinte arquivo <code>kustomization.yaml</code> contém dois literais
para <code>username</code> e <code>password</code> respectivamente:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>secretGenerator</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>db-user-pass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>literals</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- username=admin<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- password=1f2d1e2e67df<span style=color:#bbb>
</span></span></span></code></pre></div><p>Observe que nos dois casos, você não precisa codificar os valores em base64.</p><h2 id=criando-o-secret>Criando o Secret</h2><p>Aplique o diretório que contém o arquivo <code>kustomization.yaml</code> para criar o Secret.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -k .
</span></span></code></pre></div><p>A saída deve ser similar a:</p><pre tabindex=0><code>secret/db-user-pass-96mffmfh4k created
</code></pre><p>Observe que quando um Secret é gerado, o nome do segredo é criado usando o hash
dos dados do Secret mais o valor do hash. Isso garante que
um novo Secret é gerado cada vez que os dados são modificados.</p><h2 id=verifique-o-secret-criado>Verifique o Secret criado</h2><p>Você pode verificar que o secret foi criado:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get secrets
</span></span></code></pre></div><p>A saída deve ser similar a:</p><pre tabindex=0><code>NAME                             TYPE                                  DATA      AGE
db-user-pass-96mffmfh4k          Opaque                                2         51s
</code></pre><p>Você pode ver a descrição de um secret:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe secrets/db-user-pass-96mffmfh4k
</span></span></code></pre></div><p>A saída deve ser similar a:</p><pre tabindex=0><code>Name:            db-user-pass-96mffmfh4k
Namespace:       default
Labels:          &lt;none&gt;
Annotations:     &lt;none&gt;

Type:            Opaque

Data
====
password.txt:    12 bytes
username.txt:    5 bytes
</code></pre><p>Os comandos <code>kubectl get</code> e <code>kubectl describe</code> omitem o conteúdo de um <code>Secret</code> por padrão.
Isso para proteger o <code>Secret</code> de ser exposto acidentalmente para uma pessoa não autorizada,
ou ser armazenado em um log de terminal.
Para verificar o conteúdo atual de um dado codificado, veja <a href=/docs/tasks/configmap-secret/managing-secret-using-kubectl/#decoding-secret>decodificando secret</a>.</p><h2 id=limpeza>Limpeza</h2><p>Para apagar o Secret que você criou:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete secret db-user-pass-96mffmfh4k
</span></span></code></pre></div><h2 id=próximos-passos>Próximos passos</h2><ul><li>Leia mais sobre o <a href=/docs/concepts/configuration/secret/>conceito do Secret</a></li><li>Leia sobre como <a href=/docs/tasks/configmap-secret/managing-secret-using-kubectl/>gerenciar Secret com o comando <code>kubectl</code></a></li><li>Leia sobre como <a href=/docs/tasks/configmap-secret/managing-secret-using-kustomize/>gerenciar Secret usando kustomize</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-904cea8c8efd5c0d33adbfe579ec2dd2>4.2 - Configurando Qualidade do Serviço Para Pods</h1><p>Esta página mostra como configurar os Pods para que, a eles sejam atribuídos particularmente classes de
Qualidade de Serviço (QoS). O Kubernetes usa classes QoS para tomar decisões sobre
agendamento e despejo de Pods.</p><h2 id=antes-de-você-começar>Antes de você começar</h2><p><p>Você precisa de um cluster Kubernetes e a ferramenta de linha de comando kubectl
precisa estar configurada para acessar o seu cluster. Se você ainda não tem um
cluster, pode criar um usando o <a href=/docs/tasks/tools/#minikube>minikube</a>
ou você pode usar um dos seguintes ambientes:</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul>Para verificar a versão, digite <code>kubectl version</code>.</p><h2 id=classes-qos>Classes QoS</h2><p>Quando o Kubernetes cria um Pod, ele atribui uma dessas classes de QoS ao Pod:</p><ul><li>Guaranteed</li><li>Burstable</li><li>BestEffort</li></ul><h2 id=crie-um-namespace>Crie um namespace</h2><p>Crie um namespace, assim os seus recursos criados neste exercício estarão
isolados do resto do seu cluster.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create namespace qos-example
</span></span></code></pre></div><h2 id=crie-um-pod-ao-qual-seja-atribuída-uma-classe-de-qos-guaranteed>Crie um Pod ao qual seja atribuída uma classe de QoS <code>Guaranteed</code></h2><p>Para que um Pod receba uma classe de QoS <code>Guaranteed</code>:</p><ul><li>Todo contêiner no Pod deve ter um limite de memória e um requisito de memória.</li><li>Para cada contêiner no Pod, o limite de memória deve ser igual ao requisito de memória.</li><li>Todo contêiner no Pod deve ter um limite de CPU e um requisito de CPU.</li><li>Para cada contêiner no Pod, o limite de CPU deve ser igual ao requisito de CPU.</li></ul><p>Essas restrições se aplicam igualmente a contêineres de inicialização bem como de aplicativos.</p><p>Aqui está o arquivo de configuração para um pod que possui um contêiner. O contêiner tem um limite de memória e um requisito de memória, ambos iguais a 200 MiB. O contêiner tem um limite de CPU e uma solicitação de CPU, ambos iguais a 700 miliCPU:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/pt-br/examples/pods/qos/qos-pod.yaml download=pods/qos/qos-pod.yaml><code>pods/qos/qos-pod.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-qos-qos-pod-yaml")' title="Copy pods/qos/qos-pod.yaml to clipboard"></img></div><div class=includecode id=pods-qos-qos-pod-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>qos-example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-ctr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;200Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;700m&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;200Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;700m&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Crie o Pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/qos/qos-pod.yaml --namespace<span style=color:#666>=</span>qos-example
</span></span></code></pre></div><p>Veja informações detalhadas sobre o pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod qos-demo --namespace<span style=color:#666>=</span>qos-example --output<span style=color:#666>=</span>yaml
</span></span></code></pre></div><p>A saída mostra que o Kubernetes forneceu ao pod uma classe de QoS <code>Guaranteed</code>. A saída também
verifica se o contêiner do Pod tem um requisito de memória que corresponde ao seu limite de memória, e possui
um requisito de CPU que corresponde ao seu limite de CPU.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>700m<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>200Mi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>700m<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>200Mi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>qosClass</span>:<span style=color:#bbb> </span>Guaranteed<span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Se um contêiner especificar seu próprio limite de memória, mas não especificar um requisito de memória, o Kubernetes
automaticamente atribui um requisito de memória que corresponda ao limite. Similarmente, se um contêiner especifica o seu próprio
limite de CPU, mas não especifica um requisito de CPU, o Kubernetes atribui automaticamente uma solicitação de CPU que corresponde
ao limite.</div><p>Apague seu Pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pod qos-demo --namespace<span style=color:#666>=</span>qos-example
</span></span></code></pre></div><h2 id=crie-um-pod-ao-qual-seja-atribuída-uma-classe-de-qos-burstable>Crie um Pod ao qual seja atribuída uma classe de QoS <code>Burstable</code></h2><p>Um Pod recebe uma classe de QoS <code>Burstable</code> se:</p><ul><li>O Pod não atende aos critérios para a classe de QoS <code>Guaranteed</code>.</li><li>Pelo menos um contêiner no Pod tem um requisito ou limite de memória ou CPU.</li></ul><p>Aqui está o arquivo de configuração para um Pod que possui um contêiner. O contêiner tem um limite de memória de 200 MiB
e um requisito de memória de 100 MiB.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/pt-br/examples/pods/qos/qos-pod-2.yaml download=pods/qos/qos-pod-2.yaml><code>pods/qos/qos-pod-2.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-qos-qos-pod-2-yaml")' title="Copy pods/qos/qos-pod-2.yaml to clipboard"></img></div><div class=includecode id=pods-qos-qos-pod-2-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>qos-example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-2-ctr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;200Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;100Mi&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Crie o Pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/qos/qos-pod-2.yaml --namespace<span style=color:#666>=</span>qos-example
</span></span></code></pre></div><p>Veja informações detalhadas sobre o Pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod qos-demo-2 --namespace<span style=color:#666>=</span>qos-example --output<span style=color:#666>=</span>yaml
</span></span></code></pre></div><p>A saída mostra que o Kubernetes forneceu ao pod uma classe de QoS <code>Burstable</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>Always<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-2-ctr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>200Mi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>100Mi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>qosClass</span>:<span style=color:#bbb> </span>Burstable<span style=color:#bbb>
</span></span></span></code></pre></div><p>Apague seu Pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pod qos-demo-2 --namespace<span style=color:#666>=</span>qos-example
</span></span></code></pre></div><h2 id=crie-um-pod-ao-qual-seja-atribuída-uma-classe-de-qos-besteffort>Crie um Pod ao qual seja atribuída uma classe de QoS <code>BestEffort</code></h2><p>Para que um Pod receba uma classe de QoS <code>BestEffort</code>, os contêineres no pod não devem
ter quaisquer requisitos ou limites de CPU ou memória.</p><p>Aqui está o arquivo de configuração para um Pod que possui um contêiner. O contêiner não tem requisitos ou limites de memória ou CPU:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/pt-br/examples/pods/qos/qos-pod-3.yaml download=pods/qos/qos-pod-3.yaml><code>pods/qos/qos-pod-3.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-qos-qos-pod-3-yaml")' title="Copy pods/qos/qos-pod-3.yaml to clipboard"></img></div><div class=includecode id=pods-qos-qos-pod-3-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-3<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>qos-example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-3-ctr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Crie o Pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/qos/qos-pod-3.yaml --namespace<span style=color:#666>=</span>qos-example
</span></span></code></pre></div><p>Veja informações detalhadas sobre o Pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod qos-demo-3 --namespace<span style=color:#666>=</span>qos-example --output<span style=color:#666>=</span>yaml
</span></span></code></pre></div><p>A saída mostra que o Kubernetes forneceu ao Pod uma classe de QoS <code>BestEffort</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>qosClass</span>:<span style=color:#bbb> </span>BestEffort<span style=color:#bbb>
</span></span></span></code></pre></div><p>Apague seu Pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pod qos-demo-3 --namespace<span style=color:#666>=</span>qos-example
</span></span></code></pre></div><h2 id=crie-um-pod-que-tenha-dois-contêineres>Crie um Pod que tenha dois contêineres</h2><p>Aqui está o arquivo de configuração para um Pod que possui dois contêineres. Um contêiner especifica um requisito de memória de 200 MiB. O outro contêiner não especifica nenhum requisito ou limite.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/pt-br/examples/pods/qos/qos-pod-4.yaml download=pods/qos/qos-pod-4.yaml><code>pods/qos/qos-pod-4.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-qos-qos-pod-4-yaml")' title="Copy pods/qos/qos-pod-4.yaml to clipboard"></img></div><div class=includecode id=pods-qos-qos-pod-4-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-4<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>qos-example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-4-ctr-1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;200Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-4-ctr-2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Observe que este Pod atende aos critérios para a classe de QoS <code>Burstable</code>. Isto é, ele não atende aos
critérios para a classe de QoS <code>Guaranteed</code>, e um de seus contêineres tem um requisito de memória.</p><p>Crie o Pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/qos/qos-pod-4.yaml --namespace<span style=color:#666>=</span>qos-example
</span></span></code></pre></div><p>Veja informações detalhadas sobre o Pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod qos-demo-4 --namespace<span style=color:#666>=</span>qos-example --output<span style=color:#666>=</span>yaml
</span></span></code></pre></div><p>A saída mostra que o Kubernetes forneceu ao pod uma classe de QoS <code>Burstable</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-4-ctr-1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>200Mi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-4-ctr-2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>qosClass</span>:<span style=color:#bbb> </span>Burstable<span style=color:#bbb>
</span></span></span></code></pre></div><p>Apague seu Pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pod qos-demo-4 --namespace<span style=color:#666>=</span>qos-example
</span></span></code></pre></div><h2 id=limpeza>Limpeza</h2><p>Apague seu namespace:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete namespace qos-example
</span></span></code></pre></div><h2 id=próximos-passos>Próximos passos</h2><h3 id=para-desenvolvedores-de-app>Para desenvolvedores de App</h3><ul><li><p><a href=/docs/tasks/configure-pod-container/assign-memory-resource/>Atribuir Recursos de Memória a Contêineres e Pods</a></p></li><li><p><a href=/docs/tasks/configure-pod-container/assign-cpu-resource/>Atribuir Recursos de CPU a Contêineres e Pods</a></p></li></ul><h3 id=para-administradores-de-cluster>Para administradores de cluster</h3><ul><li><p><a href=/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/>Configurar Requisitos e Limites de Memória Padrão Para um Namespace</a></p></li><li><p><a href=/docs/tasks/administer-cluster/manage-resources/cpu-default-namespace/>Configurar Requisitos e Limites Padrão de CPU Para um Namespace</a></p></li><li><p><a href=/docs/tasks/administer-cluster/manage-resources/memory-constraint-namespace/>Configurar Restrições de Memória Mínima e Máxima Para um Namespace</a></p></li><li><p><a href=/docs/tasks/administer-cluster/manage-resources/cpu-constraint-namespace/>Configurar Restrições Mínimas e Máximas de CPU Para um Namespace</a></p></li><li><p><a href=/docs/tasks/administer-cluster/manage-resources/quota-memory-cpu-namespace/>Configurar Cotas de Memória e CPU Para um Namespace</a></p></li><li><p><a href=/docs/tasks/administer-cluster/manage-resources/quota-pod-namespace/>Configurar uma Cota de Pod Para um Namespace</a></p></li><li><p><a href=/docs/tasks/administer-cluster/quota-api-object/>Configurar Cotas Para Objetos de Api</a></p></li><li><p><a href=/docs/tasks/administer-cluster/topology-manager/>Topologia de Controle de Gerenciamento de Politicas em um Nó</a></p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-bbc17480da6d051c696489654c64064a>4.3 - Atribuindo Pods aos Nós</h1><p>Esta página mostra como atribuir um Pod Kubernetes a um nó particular em um
cluster Kubernetes.</p><h2 id=antes-de-você-começar>Antes de você começar</h2><p><p>Você precisa de um cluster Kubernetes e a ferramenta de linha de comando kubectl
precisa estar configurada para acessar o seu cluster. Se você ainda não tem um
cluster, pode criar um usando o <a href=/docs/tasks/tools/#minikube>minikube</a>
ou você pode usar um dos seguintes ambientes:</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>Play with Kubernetes</a></li></ul>Para verificar a versão, digite <code>kubectl version</code>.</p><h2 id=adicione-um-rótulo-a-um-nó>Adicione um rótulo a um nó</h2><ol><li><p>Liste os <a class=glossary-tooltip title='Um Nó é uma máquina de trabalho no Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/nodes/ target=_blank aria-label=nós>nós</a> em seu cluster,
juntamente com seus rótulos:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get nodes --show-labels
</span></span></code></pre></div><p>A saída é similar a esta:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME      STATUS    ROLES    AGE     VERSION        LABELS
</span></span><span style=display:flex><span>worker0   Ready     &lt;none&gt;   1d      v1.13.0        ...,kubernetes.io/hostname<span style=color:#666>=</span>worker0
</span></span><span style=display:flex><span>worker1   Ready     &lt;none&gt;   1d      v1.13.0        ...,kubernetes.io/hostname<span style=color:#666>=</span>worker1
</span></span><span style=display:flex><span>worker2   Ready     &lt;none&gt;   1d      v1.13.0        ...,kubernetes.io/hostname<span style=color:#666>=</span>worker2
</span></span></code></pre></div></li><li><p>Escolha um de seus nós, e adicione um rótulo a ele:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl label nodes &lt;your-node-name&gt; <span style=color:#b8860b>disktype</span><span style=color:#666>=</span>ssd
</span></span></code></pre></div><p>onde <code>&lt;your-node-name></code> é o nome do seu nó escolhido.</p></li><li><p>Verifique se seu nó escolhido tem o rótulo <code>disktype=ssd</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get nodes --show-labels
</span></span></code></pre></div><p>A saída é similiar a esta:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME      STATUS    ROLES    AGE     VERSION        LABELS
</span></span><span style=display:flex><span>worker0   Ready     &lt;none&gt;   1d      v1.13.0        ...,disktype<span style=color:#666>=</span>ssd,kubernetes.io/hostname<span style=color:#666>=</span>worker0
</span></span><span style=display:flex><span>worker1   Ready     &lt;none&gt;   1d      v1.13.0        ...,kubernetes.io/hostname<span style=color:#666>=</span>worker1
</span></span><span style=display:flex><span>worker2   Ready     &lt;none&gt;   1d      v1.13.0        ...,kubernetes.io/hostname<span style=color:#666>=</span>worker2
</span></span></code></pre></div><p>Na saída anterior, você pode ver que o nó <code>worker0</code> tem o rótulo <code>disktype=ssd</code>.</p></li></ol><h2 id=crie-um-pod-que-é-agendado-em-seu-nó-escolhido>Crie um pod que é agendado em seu nó escolhido</h2><p>Este arquivo de configuração de pod descreve um pod que tem um seletor de nó,
<code>disktype: ssd</code>. Isto significa que o pod será agendado em um nó que tem o rótulo <code>disktype=ssd</code>.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/pt-br/examples/pods/pod-nginx.yaml download=pods/pod-nginx.yaml><code>pods/pod-nginx.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-pod-nginx-yaml")' title="Copy pods/pod-nginx.yaml to clipboard"></img></div><div class=includecode id=pods-pod-nginx-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb> </span>test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>IfNotPresent<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodeSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>disktype</span>:<span style=color:#bbb> </span>ssd<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><ol><li><p>Use o arquivo de configuração para criar um pod que será agendado no nó escolhido:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/pod-nginx.yaml
</span></span></code></pre></div></li><li><p>Verifique se o pod está executando no nó escolhido:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods --output<span style=color:#666>=</span>wide
</span></span></code></pre></div><p>A saída é similar a esta:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME     READY     STATUS    RESTARTS   AGE    IP           NODE
</span></span><span style=display:flex><span>nginx    1/1       Running   <span style=color:#666>0</span>          13s    10.200.0.4   worker0
</span></span></code></pre></div></li></ol><h2 id=crie-um-pod-que-é-agendado-em-um-nó-específico>Crie um pod que é agendado em um nó específico</h2><p>Você pode também agendar um pod para um nó específico usando <code>nodeName</code>.</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/pt-br/examples/pods/pod-nginx-specific-node.yaml download=pods/pod-nginx-specific-node.yaml><code>pods/pod-nginx-specific-node.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-pod-nginx-specific-node-yaml")' title="Copy pods/pod-nginx-specific-node.yaml to clipboard"></img></div><div class=includecode id=pods-pod-nginx-specific-node-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodeName</span>:<span style=color:#bbb> </span>foo-node<span style=color:#bbb> </span><span style=color:#080;font-style:italic># schedule pod to specific node</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>IfNotPresent<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Use o arquivo de configuração para criar um pod que será agendado somente no nó <code>foo-node</code>.</p><h2 id=próximos-passos>Próximos passos</h2><ul><li>Aprenda mais sobre <a href=/docs/concepts/overview/working-with-objects/labels/>rótulos e seletores</a>.</li><li>Aprenda mais sobre <a href=/docs/concepts/architecture/nodes/>nós</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-68ec2370d0409cc27325be36693f9368>5 - Tutoriais</h1><p>Essa seção da documentação contém tutoriais (em inglês). Um tutorial mostra como realizar um objetivo mais complexo que uma simples <a href=/docs/tasks/>tarefa</a>. Eles podem ser divididos em diversas seções, cada uma com uma sequência de passos e etapas a serem seguidos.</p><p>Antes de iniciar um tutorial, é interessante que vocẽ salve a página de <a href=/pt/docs/reference/glossary/>Glossário</a> para futuras referências.</p><h2 id=básicos>Básicos</h2><ul><li><p><a href=/docs/tutorials/kubernetes-basics/>Kubernetes básico</a> é um tutorial interativo que auxilia no entendimento do ecossistema Kubernetes, bem como te permite testar algumas funcionalidades básicas do Kubernetes.</p></li><li><p><a href=https://www.edx.org/course/introduction-kubernetes-linuxfoundationx-lfs158x#>Introdução ao Kubernetes (edX)</a> é um curso gratuíto da edX que te guia no entendimento do Kubernetes, seus conceitos, bem como na execução de tarefas mais simples.</p></li><li><p><a href=/pt/docs/tutorials/hello-minikube/>Olá, Minikube!</a> é um "Hello World" que te permite testar rapidamente o Kubernetes em sua estação com o uso do Minikube</p></li></ul><h2 id=configuração>Configuração</h2><ul><li><a href=/docs/tutorials/configuration/configure-redis-using-configmap/>Configurando o Redis usando um ConfigMap</a></li></ul><h2 id=aplicações-stateless>Aplicações stateless</h2><ul><li><p><a href=/docs/tutorials/stateless-application/expose-external-ip-address/>Expondo um Endereço de IP externo para acessar uma aplicação no Cluster</a></p></li><li><p><a href=/docs/tutorials/stateless-application/guestbook/>Exemplo: Implantando a aplicação de Livro de Visitas (Guestbook) em PHP com Redis</a></p></li></ul><h2 id=aplicações-stateful>Aplicações stateful</h2><ul><li><p><a href=/docs/tutorials/stateful-application/basic-stateful-set/>Básicos sobre StatefulSet</a></p></li><li><p><a href=/docs/tutorials/stateful-application/mysql-wordpress-persistent-volume/>Exemplo: WordPress e MySQL com Volumes Persistentes</a></p></li><li><p><a href=/docs/tutorials/stateful-application/cassandra/>Exemplo: Implantando Cassandra com Stateful Sets</a></p></li><li><p><a href=/docs/tutorials/stateful-application/zookeeper/>Executando ZooKeeper no Kubernetes</a></p></li></ul><h2 id=clusters>Clusters</h2><ul><li><p><a href=/docs/tutorials/clusters/apparmor/>AppArmor</a></p></li><li><p><a href=/docs/tutorials/clusters/seccomp/>seccomp</a></p></li></ul><h2 id=serviços-services>Serviços / "Services"</h2><ul><li><a href=/docs/tutorials/services/source-ip/>Usando IP de origem</a></li></ul><h2 id=próximos-passos>Próximos passos</h2><p>Se você desejar escrever um tutorial, veja a página
<a href=/docs/home/contribute/page-templates/>Utilizando templates</a>
para informações sobre o tipo de página e o formato a ser utilizado.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-5e3051fff9e84735871d9fb5e7b93f33>5.1 - Olá, Minikube!</h1><p>Este tutorial mostra como executar uma aplicação exemplo no Kubernetes utilizando o <a href=https://minikube.sigs.k8s.io>Minikube</a> e o <a href=https://www.katacoda.com>Katacoda</a>. O Katacoda disponibiliza um ambiente Kubernetes gratuito e acessível via navegador.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Você também consegue seguir os passos desse tutorial instalando o Minikube localmente. Para instruções de instalação, acesse: <a href=https://minikube.sigs.k8s.io/docs/start/>iniciando com minikube</a>.</div><h2 id=objetivos>Objetivos</h2><ul><li>Instalar uma aplicação exemplo no minikube.</li><li>Executar a aplicação.</li><li>Visualizar os logs da aplicação.</li></ul><h2 id=antes-de-você-iniciar>Antes de você iniciar</h2><p>Este tutorial disponibiliza uma imagem de contêiner que utiliza o NGINX para retornar todas as requisições.</p><h2 id=criando-um-cluster-do-minikube>Criando um cluster do Minikube</h2><ol><li><p>Clique no botão abaixo <strong>para iniciar o terminal do Katacoda</strong>.</p><script defer src=https://katacoda.com/embed.js></script>
<button class=button onclick=window.katacoda.init()>Launch Terminal</button></li></ol><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Se você instalou o Minikube localmente, execute: <code>minikube start</code>.</div><ol start=2><li><p>Abra o painel do Kubernetes em um navegador:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>minikube dashboard
</span></span></code></pre></div></li><li><p>Apenas no ambiente do Katacoda: Na parte superior do terminal, clique em <strong>Preview Port 30000</strong>.</p></li></ol><h2 id=criando-um-deployment>Criando um Deployment</h2><p>Um <a href=/docs/concepts/workloads/pods/><em>Pod</em></a> Kubernetes consiste em um ou mais contêineres agrupados para fins de administração e gerenciamento de rede. O Pod desse tutorial possui apenas um contêiner. Um <a href=/docs/concepts/workloads/controllers/deployment/><em>Deployment</em></a> Kubernetes verifica a saúde do seu Pod e reinicia o contêiner do Pod caso o mesmo seja finalizado. Deployments são a maneira recomendada de gerenciar a criação e escalonamento dos Pods.</p><ol><li><p>Usando o comando <code>kubectl create</code> para criar um Deployment que gerencia um Pod. O Pod executa um contêiner baseado na imagem docker disponibilizada.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create deployment hello-node --image<span style=color:#666>=</span>k8s.gcr.io/echoserver:1.4
</span></span></code></pre></div></li><li><p>Visualizando o Deployment:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get deployments
</span></span></code></pre></div><p>A saída será semelhante a:</p><pre tabindex=0><code>NAME         READY   UP-TO-DATE   AVAILABLE   AGE
hello-node   1/1     1            1           1m
</code></pre></li><li><p>Visualizando o Pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods
</span></span></code></pre></div><p>A saída será semelhante a:</p><pre tabindex=0><code>NAME                          READY     STATUS    RESTARTS   AGE
hello-node-5f76cf6ccf-br9b5   1/1       Running   0          1m
</code></pre></li><li><p>Visualizando os eventos do cluster:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get events
</span></span></code></pre></div></li><li><p>Visualizando a configuração do <code>kubectl</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config view
</span></span></code></pre></div></li></ol><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Para mais informações sobre o comando <code>kubectl</code>, veja o <a href=/docs/reference/kubectl/overview/>kubectl overview</a>.</div><h2 id=criando-um-serviço>Criando um serviço</h2><p>Por padrão, um Pod só é acessível utilizando o seu endereço IP interno no cluster Kubernetes. Para dispobiblilizar o contêiner <code>hello-node</code> fora da rede virtual do Kubernetes, você deve expor o Pod como um <a href=/docs/concepts/services-networking/service/><em>serviço</em></a> Kubernetes.</p><ol><li><p>Expondo o Pod usando o comando <code>kubectl expose</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl expose deployment hello-node --type<span style=color:#666>=</span>LoadBalancer --port<span style=color:#666>=</span><span style=color:#666>8080</span>
</span></span></code></pre></div><p>O parâmetro <code>--type=LoadBalancer</code> indica que você deseja expor o seu serviço fora do cluster Kubernetes.</p><p>A aplicação dentro da imagem <code>k8s.gcr.io/echoserver</code> "escuta" apenas na porta TCP 8080. Se você usou
<code>kubectl expose</code> para expor uma porta diferente, os clientes não conseguirão se conectar a essa outra porta.</p></li><li><p>Visualizando o serviço que você acabou de criar:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get services
</span></span></code></pre></div><p>A saída será semelhante a:</p><pre tabindex=0><code>NAME         TYPE           CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE
hello-node   LoadBalancer   10.108.144.78   &lt;pending&gt;     8080:30369/TCP   21s
kubernetes   ClusterIP      10.96.0.1       &lt;none&gt;        443/TCP          23m
</code></pre><p>Em provedores de Cloud que fornecem serviços de balanceamento de carga para o Kubernetes, um IP externo seria provisionado para acessar o serviço. No Minikube, o tipo <code>LoadBalancer</code> torna o serviço acessível por meio do comando <code>minikube service</code>.</p></li><li><p>Executar o comando a seguir:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>minikube service hello-node
</span></span></code></pre></div></li><li><p>(<strong>Apenas no ambiente do Katacoda</strong>) Clicar no sinal de mais e então clicar em <strong>Select port to view on Host 1</strong>.</p></li><li><p>(<strong>Apenas no ambiente do Katacoda</strong>) Observe o número da porta com 5 dígitos exibido ao lado de <code>8080</code> na saída do serviço. Este número de porta é gerado aleatoriamente e pode ser diferente para você. Digite seu número na caixa de texto do número da porta e clique em <strong>Display Port</strong>. Usando o exemplo anterior, você digitaria <code>30369</code>.</p></li></ol><p>Isso abre uma janela do navegador, acessa o seu aplicativo e mostra o retorno da requisição.</p><h2 id=habilitando-complementos-addons>Habilitando Complementos (addons)</h2><p>O Minikube inclui um conjunto integrado de <a class=glossary-tooltip title='Recursos que estendem a funcionalidade do Kubernetes.' data-toggle=tooltip data-placement=top href=/pt-br/docs/concepts/cluster-administration/addons/ target=_blank aria-label=complementos>complementos</a> que podem ser habilitados, desabilitados e executados no ambiente Kubernetes local.</p><ol><li><p>Listando os complementos suportados atualmente:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>minikube addons list
</span></span></code></pre></div><p>A saída será semelhante a:</p><pre tabindex=0><code>addon-manager: enabled
dashboard: enabled
default-storageclass: enabled
efk: disabled
freshpod: disabled
gvisor: disabled
helm-tiller: disabled
ingress: disabled
ingress-dns: disabled
logviewer: disabled
metrics-server: disabled
nvidia-driver-installer: disabled
nvidia-gpu-device-plugin: disabled
registry: disabled
registry-creds: disabled
storage-provisioner: enabled
storage-provisioner-gluster: disabled
</code></pre></li><li><p>Habilitando um complemento, por exemplo, <code>metrics-server</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>minikube addons <span style=color:#a2f>enable</span> metrics-server
</span></span></code></pre></div><p>A saída será semelhante a:</p><pre tabindex=0><code>metrics-server was successfully enabled
</code></pre></li><li><p>Visualizando os Pods e os Serviços que você acabou de criar:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod,svc -n kube-system
</span></span></code></pre></div><p>A saída será semelhante a:</p><pre tabindex=0><code>NAME                                        READY     STATUS    RESTARTS   AGE
pod/coredns-5644d7b6d9-mh9ll                1/1       Running   0          34m
pod/coredns-5644d7b6d9-pqd2t                1/1       Running   0          34m
pod/metrics-server-67fb648c5                1/1       Running   0          26s
pod/etcd-minikube                           1/1       Running   0          34m
pod/influxdb-grafana-b29w8                  2/2       Running   0          26s
pod/kube-addon-manager-minikube             1/1       Running   0          34m
pod/kube-apiserver-minikube                 1/1       Running   0          34m
pod/kube-controller-manager-minikube        1/1       Running   0          34m
pod/kube-proxy-rnlps                        1/1       Running   0          34m
pod/kube-scheduler-minikube                 1/1       Running   0          34m
pod/storage-provisioner                     1/1       Running   0          34m

NAME                           TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)             AGE
service/metrics-server         ClusterIP   10.96.241.45    &lt;none&gt;        80/TCP              26s
service/kube-dns               ClusterIP   10.96.0.10      &lt;none&gt;        53/UDP,53/TCP       34m
service/monitoring-grafana     NodePort    10.99.24.54     &lt;none&gt;        80:30002/TCP        26s
service/monitoring-influxdb    ClusterIP   10.111.169.94   &lt;none&gt;        8083/TCP,8086/TCP   26s
</code></pre></li><li><p>Desabilitando o complemento <code>metrics-server</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>minikube addons disable metrics-server
</span></span></code></pre></div><p>A saída será semelhante a:</p><pre tabindex=0><code>metrics-server was successfully disabled
</code></pre></li></ol><h2 id=removendo-os-recursos-do-minikube>Removendo os recursos do Minikube</h2><p>Agora você pode remover todos os recursos criados no seu cluster:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete service hello-node
</span></span><span style=display:flex><span>kubectl delete deployment hello-node
</span></span></code></pre></div><p>(<strong>Opcional</strong>) Pare a máquina virtual (VM) do Minikube:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>minikube stop
</span></span></code></pre></div><p>(<strong>Opcional</strong>) Remova a VM do Minikube:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>minikube delete
</span></span></code></pre></div><h2 id=próximos-passos>Próximos passos</h2><ul><li>Aprender mais sobre <a href=/docs/concepts/workloads/controllers/deployment/>Deployment objects</a>.</li><li>Aprender mais sobre <a href=/docs/tasks/run-application/run-stateless-application-deployment/>Deploying applications</a>.</li><li>Aprender mais sobre <a href=/docs/concepts/services-networking/service/>Service objects</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-3c83f53a74233ace9b289ac5e24c3e62>5.2 - Aprenda as noções básicas do Kubernetes</h1><!doctype html><html lang=en><body><link href=/docs/tutorials/kubernetes-basics/public/css/styles.css rel=stylesheet><div class=layout id=top><main class=content><div class=row><div class=col-md-9><h2>Básico do Kubernetes</h2><p>Este tutorial fornece instruções básicas sobre o sistema de orquestração de cluster do Kubernetes. Cada módulo contém algumas informações básicas sobre os principais recursos e conceitos do Kubernetes e inclui um tutorial online interativo. Esses tutoriais interativos permitem que você mesmo gerencie um cluster simples e seus aplicativos em contêineres.</p><p>Usando os tutoriais interativos, você pode aprender a:</p><ul><li>Implantar um aplicativo em contêiner em um cluster.</li><li>Dimensionar a implantação.</li><li>Atualizar o aplicativo em contêiner com uma nova versão do software.</li><li>Depurar o aplicativo em contêiner.</li></ul><p>Os tutoriais usam Katacoda para executar um terminal virtual em seu navegador da Web, executado em Minikube, uma implantação local em pequena escala do Kubernetes que pode ser executada em qualquer lugar. Não há necessidade de instalar nenhum software ou configurar nada; cada tutorial interativo é executado diretamente no navegador da web.</p></div></div><br><div class=row><div class=col-md-9><h2>O que o Kubernetes pode fazer por você?</h2><p>Com os serviços da Web modernos, os usuários esperam que os aplicativos estejam disponíveis 24 horas por dia, 7 dias por semana, e os desenvolvedores esperam implantar novas versões desses aplicativos várias vezes ao dia. A conteinerização ajuda a empacotar o software para atender a esses objetivos, permitindo que os aplicativos sejam lançados e atualizados de maneira fácil e rápida, sem tempo de inatividade. O Kubernetes ajuda a garantir que esses aplicativos em contêiner sejam executados onde e quando você quiser e os ajuda a encontrar os recursos e ferramentas de que precisam para funcionar. Kubernetes é uma plataforma de código aberto pronta para produção, projetada com a experiência acumulada do Google em orquestração de contêineres, combinada com as melhores idéias da comunidade.</p></div></div><br><div id=basics-modules class=content__modules><h2>Módulos básicos do Kubernetes</h2><div class=row><div class=col-md-12><div class=row><div class=col-md-4><div class=thumbnail><a href=/pt/docs/tutorials/kubernetes-basics/create-cluster/cluster-intro/><img src="/docs/tutorials/kubernetes-basics/public/images/module_01.svg?v=1469803628347" alt></a><div class=caption><a href=/pt/docs/tutorials/kubernetes-basics/create-cluster/cluster-intro/><h5>1. Criar um cluster Kubernetes</h5></a></div></div></div><div class=col-md-4><div class=thumbnail><a href=/pt/docs/tutorials/kubernetes-basics/deploy-app/deploy-intro/><img src="/docs/tutorials/kubernetes-basics/public/images/module_02.svg?v=1469803628347" alt></a><div class=caption><a href=/pt/docs/tutorials/kubernetes-basics/deploy-app/deploy-intro/><h5>2. Implantar um aplicativo</h5></a></div></div></div><div class=col-md-4><div class=thumbnail><a href=/pt/docs/tutorials/kubernetes-basics/explore/explore-intro/><img src="/docs/tutorials/kubernetes-basics/public/images/module_03.svg?v=1469803628347" alt></a><div class=caption><a href=/pt/docs/tutorials/kubernetes-basics/explore/explore-intro/><h5>3. Explore seu aplicativo</h5></a></div></div></div></div></div><div class=col-md-12><div class=row><div class=col-md-4><div class=thumbnail><a href=/pt/docs/tutorials/kubernetes-basics/expose/expose-intro/><img src="/docs/tutorials/kubernetes-basics/public/images/module_04.svg?v=1469803628347" alt></a><div class=caption><a href=/pt/docs/tutorials/kubernetes-basics/expose/expose-intro/><h5>4. Exponha seu aplicativo publicamente</h5></a></div></div></div><div class=col-md-4><div class=thumbnail><a href=/pt/docs/tutorials/kubernetes-basics/scale/scale-intro/><img src="/docs/tutorials/kubernetes-basics/public/images/module_05.svg?v=1469803628347" alt></a><div class=caption><a href=/pt/docs/tutorials/kubernetes-basics/scale/scale-intro/><h5>5. Escale seu aplicativo</h5></a></div></div></div><div class=col-md-4><div class=thumbnail><a href=/docs/tutorials/kubernetes-basics/update/update-intro/><img src="/docs/tutorials/kubernetes-basics/public/images/module_06.svg?v=1469803628347" alt></a><div class=caption><a href=/docs/tutorials/kubernetes-basics/update/update-intro/><h5>6. Atualize seu aplicativo</h5></a></div></div></div></div></div></div></div></main></div></body></html></div><div class=td-content style=page-break-before:always><h1 id=pg-7df66040311338d6098ebeab43ba9afb>5.2.1 - Crie um Cluster</h1></div><div class=td-content><h1 id=pg-de49316920e97a82e36763cb66781ada>5.2.1.1 - Usando Minikube para criar um cluster</h1><!doctype html><html lang=en><body><link href=/docs/tutorials/kubernetes-basics/public/css/styles.css rel=stylesheet><div class=layout id=top><main class=content><div class=row><div class=col-md-8><h3>Objetivos</h3><ul><li>Aprenda o que é um cluster Kubernetes.</li><li>Aprenda o que é o Minikube.</li><li>Inicie um cluster Kubernetes usando um terminal online.</li></ul></div><div class=col-md-8><h3>Clusters do Kubernetes</h3><p><b>O Kubernetes coordena um cluster com alta disponibilidade de computadores conectados para funcionar como uma única unidade.</b>
As abstrações no Kubernetes permitem implantar aplicativos em contêineres em um cluster sem amarrá-los especificamente as máquinas individuais.
Para fazer uso desse novo modelo de implantação, os aplicativos precisam ser empacotados de uma forma que os desacoplem dos hosts individuais: eles precisam ser empacotados em contêineres. Os aplicativos em contêineres são mais flexíveis e disponíveis do que nos modelos de implantação anteriores, nos quais os aplicativos eram instalados diretamente em máquinas específicas como pacotes profundamente integrados ao host.
<b>O Kubernetes automatiza a distribuição e o agendamento de contêineres de aplicativos em um cluster de maneira mais eficiente.</b>
O Kubernetes é uma plataforma de código aberto e está pronto para produção.</p><p>Um cluster Kubernetes consiste em dois tipos de recursos:<ul><li>A <b>Camada de gerenciamento <i>(Control Plane)</i></b> coordena o cluster</li><li>Os <b>Nós <i>(Nodes)</i></b> são os nós de processamento que executam aplicativos</li></ul></p></div><div class=col-md-4><div class="content__box content__box_lined"><h3>Resumo:</h3><ul><li>Cluster do Kubernetes</li><li>Minikube</li></ul></div><div class="content__box content__box_fill"><p><i>O Kubernetes é uma plataforma de código aberto de nível de produção que orquestra o agendamento e a execução de contêineres de aplicativos dentro e entre clusters de computador.</i></p></div></div></div><br><div class=row><div class=col-md-8><h2 style=color:#3771e3>Diagrama de Cluster</h2></div></div><div class=row><div class=col-md-8><p><img src=/docs/tutorials/kubernetes-basics/public/images/module_01_cluster.svg></p></div></div><br><div class=row><div class=col-md-8><p><b>A camada de gerenciamento é responsável por gerenciar o cluster.</b> A camada de gerenciamento coordena todas as atividades em seu cluster, como programação de aplicativos, manutenção do estado desejado dos aplicativos, escalonamento de aplicativos e lançamento de novas atualizações.</p><p><b>Um nó é uma VM ou um computador físico que atua como um nó de processamento em um cluster Kubernetes.</b> Cada nó tem um Kubelet, que é um agente para gerenciar o nó e se comunicar com a camada de gerenciamento do Kubernetes. O nó também deve ter ferramentas para lidar com operações de contêiner, como containerd ou Docker. Um cluster Kubernetes que lida com o tráfego de produção deve ter no mínimo três nós.</p></div><div class=col-md-4><div class="content__box content__box_fill"><p><i>As camadas de gerenciamento gerenciam o cluster e os nós que são usados ​​para hospedar os aplicativos em execução.</i></p></div></div></div><div class=row><div class=col-md-8><p>Ao implantar aplicativos no Kubernetes, você diz à camada de gerenciamento para iniciar os contêineres de aplicativos. A camada de gerenciamento agenda os contêineres para serem executados nos nós do cluster. <b>Os nós se comunicam com o camada de gerenciamento usando a <a href=/docs/concepts/overview/kubernetes-api/>API do Kubernetes</a> </b>, que a camada de gerenciamento expõe. Os usuários finais também podem usar a API do Kubernetes diretamente para interagir com o cluster.</p><p>Um cluster Kubernetes pode ser implantado em máquinas físicas ou virtuais. Para começar o desenvolvimento do Kubernetes, você pode usar o Minikube. O Minikube é uma implementação leve do Kubernetes que cria uma VM em sua máquina local e implanta um cluster simples contendo apenas um nó. O Minikube está disponível para sistemas Linux, macOS e Windows. A linha de comando <i>(cli)</i> do Minikube fornece operações básicas de inicialização para trabalhar com seu cluster, incluindo iniciar, parar, status e excluir. Para este tutorial, no entanto, você usará um terminal online fornecido com o Minikube pré-instalado.</p><p>Agora que você sabe o que é Kubernetes, vamos para o tutorial online e iniciar nosso primeiro cluster!</p></div></div><br><div class=row><div class=col-md-12><a class="btn btn-lg btn-success" href=/pt/docs/tutorials/kubernetes-basics/create-cluster/cluster-interactive/ role=button>Iniciar tutorial interativo <span class=btn__next>›</span></a></div></div></main></div></body></html></div><div class=td-content style=page-break-before:always><h1 id=pg-323b75976001e8dfe35d67d61bc74f1a>5.2.1.2 - Tutorial interativo - Criando um cluster</h1><!doctype html><html lang=en><body><link href=/docs/tutorials/kubernetes-basics/public/css/styles.css rel=stylesheet><link href=/docs/tutorials/kubernetes-basics/public/css/overrides.css rel=stylesheet><script src=https://katacoda.com/embed.js></script><div class=layout id=top><main class="content katacoda-content"><div class=katacoda><div class=katacoda__alert>Esta tela é muito estreita para interagir com o Terminal, use um desktop / tablet.</div><div class=katacoda__box id=inline-terminal-1 data-katacoda-id=kubernetes-bootcamp/1 data-katacoda-color=326de6 data-katacoda-secondary=273d6d data-katacoda-hideintro=false data-katacoda-prompt="Kubernetes Bootcamp Terminal" style=height:600px></div></div><div class=row><div class=col-md-12><a class="btn btn-lg btn-success" href=/pt/docs/tutorials/kubernetes-basics/deploy-app/deploy-intro/ role=button>Continue para o Módulo 2<span class=btn__next>›</span></a></div></div></main></div></body></html></div><div class=td-content style=page-break-before:always><h1 id=pg-76d78b3fba507f7ed33cef14a35b631d>5.2.2 - Implantar um aplicativo</h1></div><div class=td-content><h1 id=pg-2b1bba431989008c7493109a0f049ece>5.2.2.1 - Usando kubectl para criar uma implantação</h1><!doctype html><html lang=en><body><link href=/docs/tutorials/kubernetes-basics/public/css/styles.css rel=stylesheet><div class=layout id=top><main class=content><div class=row><div class=col-md-8><h3>Objetivos</h3><ul><li>Saiba mais sobre implantações de aplicativos.</li><li>Implante seu primeiro aplicativo no Kubernetes com o kubectl.</li></ul></div><div class=col-md-8><h3>Implantações do Kubernetes</h3><p>Assim que o seu cluster Kubernetes estiver em execução você pode implementar seu aplicativo em contêiners nele.
Para fazer isso, você precisa criar uma configuração do tipo <b>Deployment</b> do Kubernetes. O Deployment define como criar e
atualizar instâncias do seu aplicativo. Depois de criar um Deployment, o Master do Kubernetes
agenda as instâncias do aplicativo incluídas nesse Deployment para ser executado em nós individuais do Cluster.</p><p>Depois que as instâncias do aplicativo são criadas, um Controlador do Kubernetes Deployment monitora continuamente essas instâncias.
Se o nó que hospeda uma instância ficar inativo ou for excluído, o controlador de Deployment substituirá a instância por uma instância em outro nó no cluster.
<b>Isso fornece um mecanismo de autocorreção para lidar com falhas ou manutenção da máquina.</b></p><p>Em um mundo de pré-orquestração, os scripts de instalação costumavam ser usados ​​para iniciar aplicativos, mas não permitiam a recuperação de falha da máquina.
Ao criar suas instâncias de aplicativo e mantê-las em execução entre nós, as implantações do Kubernetes fornecem uma abordagem fundamentalmente diferente para o gerenciamento de aplicativos.</p></div><div class=col-md-4><div class="content__box content__box_lined"><h3>Resumo:</h3><ul><li>Deployments</li><li>Kubectl</li></ul></div><div class="content__box content__box_fill"><p><i>O tipo Deployment é responsável por criar e atualizar instâncias de seu aplicativo</i></p></div></div></div><br><div class=row><div class=col-md-8><h2 style=color:#3771e3>Implantar seu primeiro aplicativo no Kubernetes</h2></div></div><div class=row><div class=col-md-8><p><img src=/docs/tutorials/kubernetes-basics/public/images/module_02_first_app.svg></p></div></div><br><div class=row><div class=col-md-8><p>Você pode criar e gerenciar uma implantação usando a interface de linha de comando do Kubernetes, <b>Kubectl </b>.
O Kubectl usa a API Kubernetes para interagir com o cluster. Neste módulo, você aprenderá os comandos Kubectl mais comuns necessários para criar implantações que executam seus aplicativos em um cluster Kubernetes.</p><p>Quando você cria um Deployment, você precisa especificar a imagem do contêiner para seu aplicativo e o número de réplicas que deseja executar.
Você pode alterar essas informações posteriormente, atualizando sua implantação; Módulos<a href=/docs/tutorials/kubernetes-basics/scale/scale-intro/>5</a> e <a href=/docs/tutorials/kubernetes-basics/update/update-intro/>6</a> do bootcamp explica como você pode dimensionar e atualizar suas implantações.</p></div><div class=col-md-4><div class="content__box content__box_fill"><p><i>Os aplicativos precisam ser empacotados em um dos formatos de contêiner suportados para serem implantados no Kubernetes</i></p></div></div></div><div class=row><div class=col-md-8><p>Para sua primeira implantação, você usará um aplicativo Node.js empacotado em um contêiner Docker.(Se você ainda não tentou criar um aplicativo Node.js e implantá-lo usando um contêiner, você pode fazer isso primeiro seguindo as instruções do <a href=/pt/docs/tutorials/hello-minikube/>tutorial Olá, Minikube!</a>).<p><p>Agora que você sabe o que são implantações (Deployment), vamos para o tutorial online e implantar nosso primeiro aplicativo!</p></div></div><br><div class=row><div class=col-md-12><a class="btn btn-lg btn-success" href=/pt/docs/tutorials/kubernetes-basics/deploy-app/deploy-interactive/ role=button>Iniciar tutorial interativo<span class=btn__next>›</span></a></div></div></main></div></body></html></div><div class=td-content style=page-break-before:always><h1 id=pg-f8997ec143b382fa6c9621941ea62ca3>5.2.2.2 - Tutorial interativo - implantando um aplicativo</h1><!doctype html><html lang=en><body><link href=/docs/tutorials/kubernetes-basics/public/css/styles.css rel=stylesheet><link href=/docs/tutorials/kubernetes-basics/public/css/overrides.css rel=stylesheet><script src=https://katacoda.com/embed.js></script><div class=layout id=top><main class="content katacoda-content"><div class=row><div class=col-md-12><p>Um pod é a unidade de execução básica de um aplicativo Kubernetes. Cada pod representa uma parte de uma carga de trabalho em execução no cluster. <a href=/docs/concepts/workloads/pods/>Saiba mais sobre pods</a>.</p></div></div><br><div class=katacoda><div class=katacoda__alert>Para interagir com o Terminal, use a versão desktop/tablet</div><div class=katacoda__box id=inline-terminal-1 data-katacoda-id=kubernetes-bootcamp/7 data-katacoda-color=326de6 data-katacoda-secondary=273d6d data-katacoda-hideintro=false data-katacoda-prompt="Terminal para treinamento do Kubernetes" style=height:600px></div></div><div class=row><div class=col-md-12><a class="btn btn-lg btn-success" href=/pt/docs/tutorials/kubernetes-basics/explore/explore-intro/ role=button>Continue para o Módulo 3<span class=btn__next>›</span></a></div></div></main></div></body></html></div><div class=td-content style=page-break-before:always><h1 id=pg-250d620a73ec8be7e1f7d835574c4596>5.2.3 - Explore seu aplicativo</h1></div><div class=td-content><h1 id=pg-2771f4e8c45321b17cb0114a2d266453>5.2.3.1 - Visualizando Pods e Nós (Nodes)</h1><!doctype html><html lang=en><body><link href=/docs/tutorials/kubernetes-basics/public/css/styles.css rel=stylesheet><div class=layout id=top><main class=content><div class=row><div class=col-md-8><h3>Objetivos</h3><ul><li>Aprenda sobre Pods do Kubernetes.</li><li>Aprenda sobre Nós do Kubernetes.</li><li>Solucionar problemas de aplicativos implantados no Kubernetes.</li></ul></div><div class=col-md-8><h2>Kubernetes Pods</h2><p>Quando você criou um Deployment no Módulo <a href=/pt/docs/tutorials/kubernetes-basics/deploy-app/deploy-intro/>2</a>, o Kubernetes criou um <b>Pod</b> para hospedar a instância do seu aplicativo. Um Pod é uma abstração do Kubernetes que representa um grupo de um ou mais contêineres de aplicativos (como Docker) e alguns recursos compartilhados para esses contêineres. Esses recursos incluem:</p><ul><li>Armazenamento compartilhado, como Volumes</li><li>Rede, como um endereço IP único no cluster</li><li>Informações sobre como executar cada contêiner, como a versão da imagem do contêiner ou portas específicas a serem usadas</li></ul><p>Um Pod define um "host lógico" específico para o aplicativo e pode conter diferentes contêineres que, na maioria dos casos, são fortemente acoplados. Por exemplo, um Pod pode incluir o contêiner com seu aplicativo Node.js, bem como um outro contêiner que alimenta os dados a serem publicados pelo servidor web Node.js. Os contêineres de um Pod compartilham um endereço IP e intervalo de portas; são sempre localizados, programados e executam em um contexto compartilhado no mesmo Nó.</p><p>Pods são a unidade atômica na plataforma Kubernetes. Quando criamos um Deployment no Kubernetes, esse Deployment cria Pods com contêineres dentro dele (em vez de você criar contêineres diretamente). Cada Pod está vinculado ao nó onde está programado (scheduled) e lá permanece até o encerramento (de acordo com a política de reinicialização) ou exclusão. Em caso de falha do nó, Pods idênticos são programados em outros nós disponíveis no cluster.</p></div><div class=col-md-4><div class="content__box content__box_lined"><h3>Sumário:</h3><ul><li>Pods</li><li>Nós (Nodes)</li><li>Principais comandos do Kubectl</li></ul></div><div class="content__box content__box_fill"><p><i>Um Pod é um grupo de um ou mais contêineres de aplicativos (como Docker) que inclui armazenamento compartilhado (volumes), endereço IP e informações sobre como executá-los.</i></p></div></div></div><br><div class=row><div class=col-md-8><h2 style=color:#3771e3>Visão geral sobre os Pods</h2></div></div><div class=row><div class=col-md-8><p><img src=/docs/tutorials/kubernetes-basics/public/images/module_03_pods.svg></p></div></div><br><div class=row><div class=col-md-8><h2>Nós (Nodes)</h2><p>Um Pod sempre será executando em um <b>Nó</b>. Um Nó é uma máquina de processamento em um cluster Kubernetes e pode ser uma máquina física ou virtual. Cada Nó é gerenciado pelo Control Plane. Um Nó pode possuir múltiplos Pods e o Control Plane do Kubernetes gerencia automaticamente o agendamento dos Pods nos nós do cluster. Para o agendamento automático dos Pods, o Control Plane leva em consideração os recursos disponíveis em cada Nó.</p><p>Cada Nó do Kubernetes executa pelo menos:</p><ul><li>Kubelet, o processo responsável pela comunicação entre o Control Plane e o Nó; gerencia os Pods e os contêineres rodando em uma máquina.</li><li>Um runtime de contêiner (por exemplo o Docker) é responsável por baixar a imagem do contêiner de um registro de imagens (por exemplo o <a href=https://hub.docker.com/>Docker Hub</a>), extrair o contêiner e executar a aplicação.</li></ul></div><div class=col-md-4><div class="content__box content__box_fill"><p><i>Os contêineres só devem ser agendados juntos em um único Pod se estiverem fortemente acoplados e precisarem compartilhar recursos, como disco e IP.</i></p></div></div></div><br><div class=row><div class=col-md-8><h2 style=color:#3771e3>Visão Geral sobre os Nós</h2></div></div><div class=row><div class=col-md-8><p><img src=/docs/tutorials/kubernetes-basics/public/images/module_03_nodes.svg></p></div></div><br><div class=row><div class=col-md-8><h2>Solucionar problemas usando o comando kubectl</h2><p>No Módulo <a href=/pt/docs/tutorials/kubernetes-basics/deploy-app/deploy-intro/>2</a>, você usou o comando Kubectl. Você pode continuar utilizando o Kubectl no Módulo 3 para obter informação sobre Deployment realizado e seus recursos. As operações mais comuns podem ser realizadas com os comandos abaixo:</p><ul><li><b>kubectl get</b> - listar recursos</li><li><b>kubectl describe</b> - mostrar informações detalhadas sobre um recurso</li><li><b>kubectl logs</b> - mostrar os logs de um container em um Pod</li><li><b>kubectl exec</b> - executar um comando em um contêiner em um Pod</li></ul><p>Você pode usar esses comandos para verificar quando o Deployment foi realizado, qual seu status atual, ondes os Pods estão rodando e qual são as suas configurações.</p><p>Agora que sabemos mais sobre os componentes de um cluster Kubernetes e o comando kubectl, vamos explorar a nossa aplicação.</p></div><div class=col-md-4><div class="content__box content__box_fill"><p><i>Um nó é uma máquina operária do Kubernetes e pode ser uma VM ou máquina física, dependendo do cluster. Vários Pods podem ser executados em um nó.</i></p></div></div></div><br><div class=row><div class=col-md-12><a class="btn btn-lg btn-success" href=/pt/docs/tutorials/kubernetes-basics/explore/explore-interactive/ role=button>Inciar o Tutorial Interativo<span class=btn__next>›</span></a></div></div></main></div></body></html></div><div class=td-content style=page-break-before:always><h1 id=pg-4b01eab98a9844ad91131079654199dd>5.2.3.2 - Tutorial Interativo - Explorando seu aplicativo</h1><!doctype html><html lang=en><body><link href=/docs/tutorials/kubernetes-basics/public/css/styles.css rel=stylesheet><link href=/docs/tutorials/kubernetes-basics/public/css/overrides.css rel=stylesheet><script src=https://katacoda.com/embed.js></script><div class=layout id=top><main class="content katacoda-content"><br><div class=katacoda><div class=katacoda__alert>Para interagir com o Terminal, por favor, use a versão para desktop ou table.</div><div class=katacoda__box id=inline-terminal-1 data-katacoda-id=kubernetes-bootcamp/4 data-katacoda-color=326de6 data-katacoda-secondary=273d6d data-katacoda-hideintro=false data-katacoda-prompt="Kubernetes Bootcamp Terminal" style=height:600px></div></div><div class=row><div class=col-md-12><a class="btn btn-lg btn-success" href=/pt/docs/tutorials/kubernetes-basics/expose/expose-intro/ role=button>Continue para o Módulo 4<span class=btn__next>›</span></a></div></div></main></div></body></html></div><div class=td-content style=page-break-before:always><h1 id=pg-4b0e31c9e0eae68bbb0a358b4042ada9>5.2.4 - Exponha publicamente seu aplicativo</h1></div><div class=td-content><h1 id=pg-8ef4dad8f743b191a9e8c6f891cb191a>5.2.4.1 - Utilizando um serviço para expor seu aplicativo</h1><!doctype html><html lang=en><body><link href=/docs/tutorials/kubernetes-basics/public/css/styles.css rel=stylesheet><div class=layout id=top><main class=content><div class=row><div class=col-md-8><h3>Objetivos</h3><ul><li>Aprenda sobre um Serviço no Kubernetes</li><li>Entenda como os objetos <code>labels</code> e <code>LabelSelector</code> se relacionam a um Serviço</li><li>Exponha uma aplicação externamente ao cluster Kubernetes usando um Serviço</li></ul></div><div class=col-md-8><h3>Visão Geral de Serviços Kubernetes</h3><p><a href=/docs/concepts/workloads/pods/>Pods</a> Kubernetes são efêmeros. Na verdade, Pods possuem um <a href=/docs/concepts/workloads/pods/pod-lifecycle/>ciclo de vida</a>. Quando um nó de processamento morre, os Pods executados no nó também são perdidos. A partir disso, o <a href=/docs/concepts/workloads/controllers/replicaset/>ReplicaSet</a> pode dinamicamente retornar o cluster ao estado desejado através da criação de novos Pods para manter sua aplicação em execução. Como outro exemplo, considere um backend de processamento de imagens com 3 réplicas. Estas réplicas são intercambiáveis; o sistema front-end não deveria se importar com as réplicas backend ou ainda se um Pod é perdido ou recriado. Dito isso, cada Pod em um cluster Kubernetes tem um único endereço IP, mesmo Pods no mesmo nó, então há necessidade de ter uma forma de reconciliar automaticamente mudanças entre Pods de modo que sua aplicação continue funcionando.</p><p>Um serviço no Kubernetes é uma abstração que define um conjunto lógico de Pods e uma política pela qual acessá-los. Serviços permitem um baixo acoplamento entre os Pods dependentes. Um serviço é definido usando YAML <a href=/docs/concepts/configuration/overview/#general-configuration-tips>(preferencialmente)</a> ou JSON, como todos objetos Kubernetes. O conjunto de Pods selecionados por um Serviço é geralmente determinado por um seletor de rótulos <i>LabelSelector</i> (veja abaixo o motivo pelo qual você pode querer um Serviço sem incluir um seletor <code>selector</code> na especificação <code>spec</code>).</p><p>Embora cada Pod tenha um endereço IP único, estes IPs não são expostos externamente ao cluster sem um Serviço. Serviços permitem que suas aplicações recebam tráfego. Serviços podem ser expostos de formas diferentes especificando um tipo <code>type</code> na especificação do serviço <code>ServiceSpec</code>:</p><ul><li><i>ClusterIP</i> (padrão) - Expõe o serviço sob um endereço IP interno no cluster. Este tipo faz do serviço somente alcançável de dentro do cluster.</li><li><i>NodePort</i> - Expõe o serviço sob a mesma porta em cada nó selecionado no cluster usando NAT. Faz o serviço acessível externamente ao cluster usando <code>&lt;NodeIP>:&lt;NodePort></code>. Superconjunto de ClusterIP.</li><li><i>LoadBalancer</i> - Cria um balanceador de carga externo no provedor de nuvem atual (se suportado) e assinala um endereço IP fixo e externo para o serviço. Superconjunto de NodePort.</li><li><i>ExternalName</i> - Expõe o serviço usando um nome arbitrário (especificado através de <code>externalName</code> na especificação <code>spec</code>) retornando um registro de CNAME com o nome. Nenhum proxy é utilizado. Este tipo requer v1.7 ou mais recente de <code>kube-dns</code>.</li></ul><p>Mais informações sobre diferentes tipos de Serviços podem ser encontradas no tutorial <a href=/docs/tutorials/services/source-ip/>Utilizando IP de origem</a>. Também confira <a href=/docs/concepts/services-networking/connect-applications-service>Conectando aplicações com serviços</a>.</p><p>Adicionalmente, note que existem alguns casos de uso com serviços que envolvem a não definição de <code>selector</code> em <code>spec</code>. Serviços criados sem <code>selector</code> também não criarão objetos Endpoints correspondentes. Isto permite usuários mapear manualmente um serviço a endpoints específicos. Outra possibilidade na qual pode não haver seletores é ao se utilizar estritamente <code>type: ExternalName</code>.</p></div><div class=col-md-4><div class="content__box content__box_lined"><h3>Resumo</h3><ul><li>Expõe Pods ao tráfego externo</li><li>Tráfego de balanceamento de carga entre múltiplos Pods</li><li>Uso de rótulos <code>labels</code></li></ul></div><div class="content__box content__box_fill"><p><i>Um serviço Kubernetes é uma camada de abstração que define um conjunto lógico de Pods e habilita a exposição ao tráfego externo, balanceamento de carga e descoberta de serviço para esses Pods.</i></p></div></div></div><br><div class=row><div class=col-md-8><h3>Serviços e Rótulos</h3></div></div><div class=row><div class=col-md-8><p>Um serviço roteia tráfego entre um conjunto de Pods. Serviço é a abstração que permite pods morrerem e se replicarem no Kubernetes sem impactar sua aplicação. A descoberta e o roteamento entre Pods dependentes (tal como componentes frontend e backend dentro de uma aplicação) são controlados por serviços Kubernetes.</p><p>Serviços relacionam um conjunto de Pods usando <a href=/docs/concepts/overview/working-with-objects/labels>Rótulos e seletores</a>, um agrupamento primitivo que permite operações lógicas sobre objetos Kubernetes. Rótulos são pares de chave/valor anexados à objetos e podem ser usados de inúmeras formas:</p><ul><li>Designar objetos para desenvolvimento, teste e produção</li><li>Adicionar tags de versão</li><li>Classificar um objeto usando tags</li></ul></div></div><br><div class=row><div class=col-md-8><p><img src=/docs/tutorials/kubernetes-basics/public/images/module_04_labels.svg></p></div></div><br><div class=row><div class=col-md-8><p>Rótulos podem ser anexados à objetos no momento de sua criação ou posteriormente. Eles podem ser modificados a qualquer tempo. Vamos agora expor sua aplicação usando um serviço e aplicar alguns rótulos.</p></div></div><br><div class=row><div class=col-md-12><a class="btn btn-lg btn-success" href=/pt/docs/tutorials/kubernetes-basics/expose/expose-interactive/ role=button>Iniciar tutorial interativo<span class=btn__next>›</span></a></div></div></main></div></body></html></div><div class=td-content style=page-break-before:always><h1 id=pg-352241d22effe0714772d21c7d1b512d>5.2.4.2 - Tutorial Interativo - Expondo seu aplicativo</h1><!doctype html><html lang=en><body><link href=/docs/tutorials/kubernetes-basics/public/css/styles.css rel=stylesheet><link href=/docs/tutorials/kubernetes-basics/public/css/overrides.css rel=stylesheet><script src=https://katacoda.com/embed.js></script><div class=layout id=top><main class="content katacoda-content"><div class=katacoda><div class=katacoda__alert>Para interagir com o terminal, favor utilizar a versão desktop/tablet</div><div class=katacoda__box id=inline-terminal-1 data-katacoda-id=kubernetes-bootcamp/8 data-katacoda-color=326de6 data-katacoda-secondary=273d6d data-katacoda-hideintro=false data-katacoda-prompt="Terminal Kubernetes Bootcamp" style=height:600px></div></div><div class=row><div class=col-md-12><a class="btn btn-lg btn-success" href=/pt/docs/tutorials/kubernetes-basics/scale/scale-intro/ role=button>Continue para o Módulo 5<span class=btn__next>›</span></a></div></div></main></div></body></html></div><div class=td-content style=page-break-before:always><h1 id=pg-be4996c93fb39c459a30b6669569d423>5.2.5 - Escale seu aplicativo</h1></div><div class=td-content><h1 id=pg-d1c15c9bd4f625adbc13149b1475287c>5.2.5.1 - Executando múltiplas instâncias de seu aplicativo</h1><!doctype html><html lang=en><body><link href=/docs/tutorials/kubernetes-basics/public/css/styles.css rel=stylesheet><div class=layout id=top><main class=content><div class=row><div class=col-md-8><h3>Objetivos</h3><ul><li>Escalar uma aplicação usando kubectl.</li></ul></div><div class=col-md-8><h3>Escalando uma aplicação</h3><p>Nos módulos anteriores nós criamos um <a href=/docs/concepts/workloads/controllers/deployment/>Deployment</a>, e então o expusemos publicamente através de um serviço (<a href=/docs/concepts/services-networking/service/>Service</a>). O Deployment criou apenas um único Pod para executar nossa aplicação. Quando o tráfego aumentar nós precisaremos escalar a aplicação para suportar a demanda de usuários.</p><p>O <b>escalonamento</b> é obtido pela mudança do número de réplicas em um Deployment</p></div><div class=col-md-4><div class="content__box content__box_lined"><h3>Resumo:</h3><ul><li>Escalando um Deployment</li></ul></div><div class="content__box content__box_fill"><p><i>Você pode criar desde o início um Deployment com múltiplas instâncias usando o parâmetro <code>--replicas</code> para que o kubectl crie o comando de deployment</i></p></div></div></div><br><div class=row><div class=col-md-8><h2 style=color:#3771e3>Visão geral sobre escalonamento</h2></div></div><div class=row><div class=col-md-1></div><div class=col-md-8><div id=myCarousel class=carousel data-ride=carousel data-interval=3000><ol class=carousel-indicators><li data-target=#myCarousel data-slide-to=0 class=active></li><li data-target=#myCarousel data-slide-to=1></li></ol><div class=carousel-inner role=listbox><div class="item carousel-item active"><img src=/docs/tutorials/kubernetes-basics/public/images/module_05_scaling1.svg></div><div class="item carousel-item"><img src=/docs/tutorials/kubernetes-basics/public/images/module_05_scaling2.svg></div></div><a class="left carousel-control" href=#myCarousel role=button data-slide=prev><span class=sr-only>Anterior</span></a>
<a class="right carousel-control" href=#myCarousel role=button data-slide=next><span class=sr-only>Próximo</span></a></div></div></div><br><div class=row><div class=col-md-8><p>Escalar um Deployment garantirá que novos Pods serão criados e agendados para nós de processamento com recursos disponíveis. O escalonamento aumentará o número de Pods para o novo estado desejado. O Kubernetes também suporta o auto-escalonamento (<a href=/docs/user-guide/horizontal-pod-autoscaling/>autoscaling</a>) de Pods, mas isso está fora do escopo deste tutorial. Escalar para zero também é possível, e isso terminará todos os Pods do Deployment especificado.</p><p>Executar múltiplas instâncias de uma aplicação irá requerer uma forma de distribuir o tráfego entre todas elas. Serviços possuem um balanceador de carga integrado que distribuirá o tráfego de rede entre todos os Pods de um Deployment exposto. Serviços irão monitorar continuamente os Pods em execução usando endpoints para garantir que o tráfego seja enviado apenas para Pods disponíveis.</p></div><div class=col-md-4><div class="content__box content__box_fill"><p><i>O Escalonamento é obtido pela mudança do número de réplicas em um Deployment.</i></p></div></div></div><br><div class=row><div class=col-md-8><p>No momento em que múltiplas instâncias de uma aplicação estiverem em execução será possível realizar atualizações graduais no cluster sem que ocorra indisponibilidade. Nós cobriremos isso no próximo módulo. Agora, vamos ao terminal online e escalar nossa aplicação.</p></div></div><br><div class=row><div class=col-md-12><a class="btn btn-lg btn-success" href=/pt/docs/tutorials/kubernetes-basics/scale/scale-interactive/ role=button>Iniciar tutorial interativo<span class=btn__next>›</span></a></div></div></main></div></body></html></div><div class=td-content style=page-break-before:always><h1 id=pg-7bdb3fbaa1177ff5dfa3fe86bd35ef59>5.2.5.2 - Tutorial Interativo - Escalando seu aplicativo</h1><!doctype html><html lang=en><body><link href=/docs/tutorials/kubernetes-basics/public/css/styles.css rel=stylesheet><link href=/docs/tutorials/kubernetes-basics/public/css/overrides.css rel=stylesheet><script src=https://katacoda.com/embed.js></script><div class=layout id=top><main class="content katacoda-content"><div class=katacoda><div class=katacoda__alert>Para interagir com o terminal, favor utilizar a versão desktop/tablet</div><div class=katacoda__box id=inline-terminal-1 data-katacoda-id=kubernetes-bootcamp/5 data-katacoda-color=326de6 data-katacoda-secondary=273d6d data-katacoda-hideintro=false data-katacoda-prompt="Kubernetes Bootcamp Terminal" style=height:600px></div></div><div class=row><div class=col-md-12><a class="btn btn-lg btn-success" href=/docs/tutorials/kubernetes-basics/update/update-intro/ role=button>Continue para o Módulo 6<span class=btn__next>›</span></a></div></div></main><a class=scrolltop href=#top></a></div></body></html></div><div class=td-content style=page-break-before:always><h1 id=pg-b00a88a07ceb21b1a83e5822e0c86c1d>6 - Referência</h1><p>Esta seção da documentação do Kubernetes contém referências.</p><h2 id=referência-da-api>Referência da API</h2><ul><li><a href=/docs/reference/using-api/api-overview/>Visão geral da API do Kubernetes</a> - Visão geral da API para Kubernetes.</li><li><a href=/docs/reference/generated/kubernetes-api/v1.25/>Referência da API Kubernetes v1.25</a></li></ul><h2 id=biblioteca-de-clientes-da-api>Biblioteca de clientes da API</h2><p>Para chamar a API Kubernetes de uma linguagem de programação, você pode usar
<a href=/docs/reference/using-api/client-libraries/>bibliotecas de clientes</a>. Bibliotecas oficialmente suportadas:</p><ul><li><a href=https://github.com/kubernetes/client-go/>Biblioteca do cliente Kubernetes em Go</a></li><li><a href=https://github.com/kubernetes-client/python>Biblioteca do cliente Kubernetes em Python</a></li><li><a href=https://github.com/kubernetes-client/java>Biblioteca do cliente Kubernetes em Java</a></li><li><a href=https://github.com/kubernetes-client/javascript>Biblioteca do cliente Kubernetes em JavaScript</a></li></ul><h2 id=referência-da-cli>Referência da CLI</h2><ul><li><a href=/docs/reference/kubectl/overview/>kubectl</a> - Ferramenta CLI principal para executar comandos e gerenciar clusters do Kubernetes.<ul><li><a href=/docs/reference/kubectl/jsonpath/>JSONPath</a> - Guia de sintaxe para usar <a href=http://goessner.net/articles/JsonPath/>Expressões JSONPath</a> com o kubectl.</li></ul></li><li><a href=/docs/reference/setup-tools/kubeadm/kubeadm/>kubeadm</a> - Ferramenta CLI para provisionar facilmente um cluster Kubernetes seguro.</li></ul><h2 id=referência-de-configuração>Referência de configuração</h2><ul><li><a href=/docs/reference/command-line-tools-reference/kubelet/>kubelet</a> - O principal <em>agente do nó</em> que é executado em cada nó. O kubelet usa um conjunto de PodSpecs e garante que os contêineres descritos estejam funcionando e saudáveis.</li><li><a href=/docs/reference/command-line-tools-reference/kube-apiserver/>kube-apiserver</a> - API REST que valida e configura dados para objetos de API, como pods, serviços, controladores de replicação.</li><li><a href=/docs/reference/command-line-tools-reference/kube-controller-manager/>kube-controller-manager</a> - Daemon que incorpora os principais loops de controle enviados com o Kubernetes.</li><li><a href=/docs/reference/command-line-tools-reference/kube-proxy/>kube-proxy</a> - É possível fazer o encaminhamento de fluxo TCP/UDP de forma simples ou utilizando o algoritimo de Round Robin encaminhando através de um conjunto de back-ends.</li><li><a href=/docs/reference/command-line-tools-reference/kube-scheduler/>kube-scheduler</a> - Agendador que gerencia disponibilidade, desempenho e capacidade.</li></ul><h2 id=documentos-de-design>Documentos de design</h2><p>Um arquivo dos documentos de design para as funcionalidades do Kubernetes. Bons pontos de partida são <a href=https://git.k8s.io/community/contributors/design-proposals/architecture/architecture.md>Arquitetura Kubernetes</a> e <a href=https://git.k8s.io/community/contributors/design-proposals>Visão geral do design do Kubernetes</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-2b03679960950df772fb4fe7d78427b9>6.1 - Glossário</h1></div><div class=td-content style=page-break-before:always><h1 id=pg-a6264859a5ad6e2f4a6e4cff9ce4fa8b>6.2 - Autenticação</h1><p>Essa página demonstra uma visão geral sobre autenticação</p><h2 id=usuários-no-kubernetes>Usuários no Kubernetes</h2><p>Todos os clusters Kubernetes possuem duas categorias de usuários: contas de serviço gerenciadas pelo Kubernetes e usuários normais.</p><p>Assume-se que um serviço independente do cluster gerencia usuários normais das seguintes formas:</p><ul><li>Um administrador distribuindo chaves privadas</li><li>Uma base de usuários como Keystone<p>Keystone é o serviço de identidade usado pelo OpenStack para autenticação (authN) e autorização de alto nível (authZ). Atualmente, ele oferece suporte a authN com base em token e autorização de serviço do usuário. Recentemente, foi reprojetado para permitir a expansão para oferecer suporte a serviços externos de proxy e mecanismos AuthN / AuthZ, como oAuth, SAML e openID em versões futuras.</p>ou Google Accounts</li><li>Um arquivo com uma lista de nomes de usuários e senhas</li></ul><p>Neste quesito, <em>Kubernetes não possui objetos que possam representar as contas de um usuário normal.</em> Usuários normais não podem ser adicionados ao <em>cluster</em> através de uma chamada para a API.</p><p>Apesar de um usuário normal não poder ser adicionado através de uma chamada para a API, qualquer usuário que apresente um certificado válido e assinado pela autoridade de certificados (CA) do <em>cluster</em> é considerado autenticado. Nesta configuração, Kubernetes determina o nome do usuário baseado no campo de nome comum no sujeito (<em>subject</em>) do certificado (por exemplo: "/CN=bob"). A partir daí, o subsistema de controle de acesso baseado em função (RBAC) determina se o usuário é autorizado a realizar uma operação específica sobre o recurso. Para mais detalhes, veja a referência sobre o tópico de usuários normais dentro de <a href=/docs/reference/access-authn-authz/certificate-signing-requests/#normal-user>requisição de certificado</a>.</p><p>Em contraste a usuários normais, contas de serviço são considerados usuários gerenciados pela API do Kubernetes. Elas estão vinculadas à <em>namespaces</em> específicas e criadas automaticamente pelo servidor de API ou manualmente através de chamadas da API. Contas de serviço estão ligadas a um conjunto de credenciais armazenados como <code>Secrets</code>, aos quais são montados dentro dos <em>pods</em> assim permitindo que processos internos ao <em>cluster</em> comuniquem-se com a API do Kubernetes.</p><p>Requisições para a API estão ligadas a um usuário normal, conta de serviço ou serão tratadas como <a href=#anonymous-requests>requisições anônimas</a>. Isto significa que cada processo dentro ou fora do <em>cluster</em>, desde um usuário humano utilizando o <code>kubectl</code> de uma estação de trabalho, a <code>kubelets</code> rodando nos nós, a membros da camada de gerenciamento (s/painel de controle) devem autenticar-se ao realizarem suas requisições para o servidor API ou serão tratados como usuário anônimo.</p><h2 id=estratégias-de-autenticação>Estratégias de autenticação</h2><p>Kubernetes usa certificados de clientes, <em>bearer Token</em>, um proxy realizando autenticação, ou uma autenticação básica HTTP para autenticar requisições para o servidor de API através de plugins. Como requisições HTTP são feitas no servidor de API, plugins tentam associar os seguintes atributos junto a requisição:</p><ul><li>Username<p>Um nome de usuário é um nome que identifica exclusivamente alguém em um sistema de computador. Por exemplo, um computador pode ser configurado com várias contas, com nomes de usuário diferentes para cada conta. Muitos sites permitem que os usuários escolham um nome de usuário para que possam personalizar suas configurações ou configurar uma conta online. Por exemplo, seu banco pode permitir que você escolha um nome de usuário para acessar suas informações bancárias. Você pode precisar escolher um nome de usuário para postar mensagens em um determinado quadro de mensagens na web. Os serviços de e-mail, como o Hotmail, exigem que os usuários escolham um nome de usuário para usar o serviço.</p><p>Um nome de usuário geralmente é pareado com uma senha. Essa combinação de nome de usuário / senha é conhecida como login e geralmente é necessária para que os usuários façam login em sites. Por exemplo, para acessar seu e-mail pela Web, é necessário inserir seu nome de usuário e senha. Depois de fazer o login, seu nome de usuário pode aparecer na tela, mas sua senha é mantida em segredo. Ao manter sua senha privada, as pessoas podem criar contas seguras para vários sites. A maioria dos nomes de usuário pode conter letras e números, mas não espaços. Quando você escolhe um nome de usuário para uma conta de e-mail, a parte antes de "@" é o seu nome de usuário.</p>: um valor (String) que identifica o usuário final. Valores comuns podem ser <code>kube-admin</code> ou <code>jane@example.com</code></li><li>UID<p>Uma string gerada pelos sistemas do Kubernetes para identificar objetos de
forma única.</p><p>Cada objeto criado durante todo o ciclo de vida do cluster do Kubernetes possui
um UID distinto. O objetivo deste identificador é distinguir ocorrências
históricas de entidades semelhantes.</p>: um valor (String) que identifica o usuário final e tenta ser mais consistente e único do que username.</li><li>Groups: Um conjunto de valores em que cada item indica a associação de um usuário à uma coleção lógica de usuários. Valores comuns podem ser <code>system:masters</code> ou <code>devops-team</code>.</li><li>Campos extras: um mapa que pode conter uma lista de atributos que armazena informações adicionais em que autorizadores podem achar útil.</li></ul><p>Todos os valores são transparentes para o sistema de autenticação e somente trazem significado quando interpretados por um <a href=/docs/reference/access-authn-authz/authorization/>autorizador</a>.</p><p>É possível habilitar múltiplos métodos de autenticação. Deve-se normalmente usar pelo menos dois métodos:</p><ul><li><em>Tokens</em> para contas de serviço;</li><li>Pelo menos um outro método de autenticação para usuários.</li></ul><p>Quando múltiplos módulos de autenticação estão habilitados, o primeiro módulo a autenticar com sucesso uma requisição termina, o fluxo de avaliação da mesma.</p><p>O servidor de API não garante a ordem em que os autenticadores são processados.</p><p>O grupo <code>system:authenticated</code> é incluído na lista de grupos de todos os usuários autenticados.</p><p>Integrações com outros protocolos de autenticação, como LDAP<p>Abreviatura para "Lightweight Directory Access Protocol". Se você deseja disponibilizar informações de diretório na Internet, esta é a maneira de fazê-lo. O LDAP é uma versão simplificada de um padrão de diretório anterior denominado X.500. O que torna o LDAP tão útil é que ele funciona muito bem em redes TCP / IP (ao contrário do X.500), de modo que as informações podem ser acessadas por meio do LDAP por qualquer pessoa com uma conexão à Internet. Também é um protocolo aberto, o que significa que os diretórios podem ser armazenados em qualquer tipo de máquina (por exemplo, Windows 2000, Red Hat Linux, Mac OS X).</p><p>Para dar uma ideia de como um diretório LDAP é organizado, aqui estão os diferentes níveis de uma hierarquia de árvore LDAP simples:</p><p>O diretório raiz
Países
Organizações
Divisões, departamentos, etc.
Indivíduos
Recursos individuais, como arquivos e impressoras.
A maior parte da conectividade LDAP é feita nos bastidores, então o usuário típico provavelmente não notará ao navegar na web. No entanto, é uma boa tecnologia para se conhecer. Se nada mais, é outro termo para impressionar seus pais.</p>, SAML<p>SAML significa Linguagem de Marcação para Asserção de Segurança. É um padrão aberto baseado em XML para transferência de dados de identidade entre duas partes: um provedor de identidade (IdP) e um provedor de serviços (SP).</p><p>Provedor de identidade - executa autenticação e passa a identidade do usuário e o nível de autorização para o provedor de serviços.</p><p>Provedor de serviços - confia no provedor de identidade e autoriza o usuário fornecido a acessar o recurso solicitado.</p><p>A autenticação de logon único SAML normalmente envolve um provedor de serviços e um provedor de identidade. O fluxo do processo geralmente envolve os estágios de estabelecimento de confiança e fluxo de autenticação.</p><p>Considere este exemplo:</p><p>Nosso provedor de identidade é Auth0
Nosso provedor de serviços é um serviço fictício, Zagadat
Nota: O provedor de identidade pode ser qualquer plataforma de gerenciamento de identidade.</p><p>Agora, um usuário está tentando obter acesso ao Zagadat usando a autenticação SAML.</p><p>Este é o fluxo do processo:</p><p>O usuário tenta fazer login no Zagadat a partir de um navegador.
O Zagadat responde gerando uma solicitação SAML.</p>, Kerberos<p>Kerberos é um protocolo de rede que usa criptografia de chave secreta para autenticar aplicativos cliente-servidor. O Kerberos solicita um tíquete criptografado por meio de uma sequência de servidor autenticada para usar os serviços.</p><p>Kerberos foi desenvolvido pelo Project Athena - um projeto conjunto entre o Massachusetts Institute of Technology (MIT), Digital Equipment Corporation e IBM que funcionou entre 1983 e 1991.</p><p>Um servidor de autenticação usa um tíquete Kerberos para conceder acesso ao servidor e, em seguida, cria uma chave de sessão com base na senha do solicitante e outro valor aleatório. O tíquete de concessão de tíquete (TGT) é enviado ao servidor de concessão de tíquete (TGS), que é necessário para usar o mesmo servidor de autenticação.</p><p>O solicitante recebe uma chave TGS criptografada com um registro de data e hora e um tíquete de serviço, que é retornado ao solicitante e descriptografado. O solicitante envia ao TGS essas informações e encaminha a chave criptografada ao servidor para obter o serviço desejado. Se todas as ações forem tratadas corretamente, o servidor aceita o tíquete e realiza o atendimento ao usuário desejado, que deve descriptografar a chave, verificar a data e hora e entrar em contato com o centro de distribuição para obter as chaves de sessão. Essa chave de sessão é enviada ao solicitante, que descriptografa o tíquete.</p><p>Se as chaves e o carimbo de data / hora forem válidos, a comunicação cliente-servidor continuará. O tíquete TGS tem carimbo de data / hora, o que permite solicitações simultâneas dentro do período de tempo alocado.</p>, alternate x509 schemes<p>X.509 é um formato padrão para certificados de chave pública, documentos digitais que associam com segurança pares de chaves criptográficas a identidades como sites, indivíduos ou organizações.</p><p>Introduzido pela primeira vez em 1988 junto com os padrões X.500 para serviços de diretório eletrônico, o X.509 foi adaptado para uso na Internet pelo grupo de trabalho Public-Key Infrastructure (X.509) (PKIX) da IETF. O RFC 5280 define o perfil do certificado X.509 v3, a lista de revogação de certificado X.509 v2 (CRL) e descreve um algoritmo para a validação do caminho do certificado X.509.</p><p>As aplicações comuns de certificados X.509 incluem:</p><pre><code>- SSL / TLS e HTTPS para navegação na web autenticada e criptografada
- E-mail assinado e criptografado por meio do protocolo S / MIME
- Assinatura de código
- Assinatura de documento
- Autenticação de cliente
- Identificação eletrônica emitida pelo governo
</code></pre>, etc, podem ser alcançadas utilizando-se de um <a href=#autenticando-com-proxy>proxy</a> ou <a href=#token-de-autentica%C3%A7%C3%A3o-via-webhook>webhook</a> de autenticação.</p><h3 id=certificados-de-cliente-x509>Certificados de cliente X509</h3><p>Autenticação via certificados de cliente pode ser habilitada ao passar a opção <code>--client-ca-file=ARQUIVO</code> para o servidor de API. O arquivo referenciado deve conter um ou mais autoridades de certificação usadas para validar o certificado de cliente passado para o servidor de API. Se o certificado de cliente é apresentado e verificado, o <em>common name</em><p>O nome comum é normalmente composto de Host + Nome de domínio e será semelhante a <a href=https://www.seusite.com>www.seusite.com</a> ou seusite.com. Os certificados de servidor SSL são específicos para o nome comum para o qual foram emitidos no nível do host.</p><p>O nome comum deve ser igual ao endereço da Web que você acessará ao se conectar a um site seguro. Por exemplo, um certificado de servidor SSL para o domínio domínio.com receberá um aviso do navegador se o acesso a um site chamado <a href=https://www.domain.com>www.domain.com</a> ou secure.domain.com, pois <a href=https://www.domain.com>www.domain.com</a> e secure.domain.com são diferentes de dominio.com. Você precisaria criar um CSR para o nome comum correto.</p>do sujeito é usado como o nome de usuário para a requisição. A partir da versão 1.4, certificados de cliente podem também indicar o pertencimento de um usuário a um grupo utilizando o campo de organização do certificado. Para incluir múltiplos grupos para o usuário, deve-se incluir múltiplos campos de organização no certificado.</p><p>Por exemplo, utilizando o comando de linha <code>openssl</code> para gerar uma requisição de assinatura de certificado:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>openssl req -new -key jbeda.pem -out jbeda-csr.pem -subj <span style=color:#b44>&#34;/CN=jbeda/O=app1/O=app2&#34;</span>
</span></span></code></pre></div><p>Isto criaria um arquivo de tipo CSR (requisição de assinatura de certificado) para o usuário "jbeda" pertencendo a dois grupos: "app1" e "app2".</p><p>Veja como gerar um certificado de cliente em <a href=/docs/concepts/cluster-administration/certificates/>Gerenciando Certificados</a></p><h3 id=arquivo-estático-de-token>Arquivo estático de Token</h3><p>O servidor de API lê <em>bearer tokens</em> de um arquivo quando recebe uma requisição contendo a opção <code>--token-auth-file=ARQUIVO</code> via linha de comando. Atualmente, tokens têm duração indefinida, e a lista de tokens não pode ser modificada sem reiniciar o servidor de API.</p><p>O arquivo de token é do tipo CSV contendo no mínimo 3 colunas: token, nome de usuário, identificador de usuário (uid), seguido pelos nomes de grupos (opcional).</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong><p>Se uma entrada possuir mais de um grupo, a coluna deve ser cercada por aspas duplas, por exemplo:</p><pre tabindex=0><code class=language-conf data-lang=conf>token,usuario,uid,&#34;grupo1,grupo2,grupo3&#34;
</code></pre></div><h4 id=adicionando-um-bearer-token-em-uma-requisição>Adicionando um <em>bearer token</em> em uma requisição</h4><p>Quando utilizando-se de <em>bearer token</em> para autenticação de um cliente HTTP, o servidor de API espera um cabeçalho <code>Authorization</code> com um valor <code>Bearer TOKEN</code>. O token deve ser uma sequência de caracteres que pode ser colocada como valor em um cabeçalho HTTP não utilizando-se mais do que as facilidades de codificação e citação de HTTP. Por exemplo, se o valor de um token é <code>31ada4fd-adec-460c-809a-9e56ceb75269</code> então iria aparecer dentro de um cabeçalho HTTP como:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=display:flex><span><span>Authorization: Bearer 31ada4fd-adec-460c-809a-9e56ceb75269
</span></span></span></code></pre></div><h3 id=tokens-de-inicialização>Tokens de inicialização</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.18 [stable]</code></div><p>Para permitir a inicialização simplificada para novos <em>clusters</em>, Kubernetes inclui um token dinamicamente gerenciado denominado <em>Bootstrap Token</em>. Estes <em>tokens</em> são armazenados como Secrets dentro do namespace <code>kube-system</code>, onde eles podem ser dinamicamente criados e gerenciados. O componente Gerenciador de Controle (Controller Manager) possui um controlador "TokenCleaner" que apaga os <em>tokens</em> de inicialização expirados.</p><p>Os <em>tokens</em> seguem o formato <code>[a-z0-9]{6}.[a-z0-9]{16}</code>. O primeiro componente é um identificador do <em>token</em> e o segundo é o segredo. Você pode especificar o <em>token</em> como um cabeçalho HTTP como:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=display:flex><span><span>Authorization: Bearer 781292.db7bc3a58fc5f07e
</span></span></span></code></pre></div><p>Deve-se habilitar os <em>tokens</em> de inicialização com a opção <code>--enable-bootstrap-token-auth</code> no servidor de API. Deve-se habilitar o controlador <code>TokenCleaner</code> através da opção <code>--controllers</code> no Gerenciador de Controle. Isso é feito, por exemplo, como: <code>--controllers=*,tokencleaner</code>. O <code>kubeadm</code>, por exemplo, irá realizar isso caso seja utilizado para a inicialização do cluster.</p><p>O autenticador o autentica como <code>system:bootstrap:&lt;Token ID></code> e é incluído no grupo <code>system:bootstrappers</code>. O nome e grupo são intencionalmente limitados para desencorajar usuários a usarem estes <em>tokens</em> após inicialização. Os nomes de usuários e grupos podem ser utilizados (e são utilizados pelo <code>kubeadm</code>) para elaborar as políticas de autorização para suportar a inicialização de um cluster.</p><p>Por favor veja <a href=/docs/reference/access-authn-authz/bootstrap-tokens/>Bootstrap Tokens</a> para documentação detalhada sobre o autenticador e controladores de <em>Token</em> de inicialização, bem como gerenciar estes <em>tokens</em> com <code>kubeadm</code>.</p><h3 id=tokens-de-contas-de-serviço>Tokens de Contas de serviço</h3><p>Uma conta de serviço é um autenticador habilitado automaticamente que usa bearer tokens para verificar as requisições. O plugin aceita dois parâmetros opcionais:</p><ul><li><code>--service-account-key-file</code> Um arquivo contendo uma chave codificada no formato PEM para assinar <em>bearer tokens</em>. Se não especificado, a chave privada de TLS no servidor de API será utilizada</li><li><code>--service-account-lookup</code> Se habilitado, <em>tokens</em> deletados do servidor de API serão revogados.</li></ul><p>Contas de serviço são normalmente criadas automaticamente pelo servidor de API e associada a <em>pods</em> rodando no cluster através do controlador de admissão <a href=/docs/reference/access-authn-authz/admission-controllers/>Admission Controller</a> de <code>ServiceAccount</code>. Os tokens de contas de serviços são montados nos Pods, em localizações já pré definidas e conhecidas e permitem processos dentro do cluster a se comunicarem com o servidor de API. Contas podem ser explicitamente associadas com <em>pods</em> utilizando o campo <code>serviceAccountName</code> na especificação do pod (<code>PodSpec</code>):</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> <code>serviceAccountName</code> é normalmente omitida por ser feito automaticamente</div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1 <span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>serviceAccountName</span>:<span style=color:#bbb> </span>bob-the-bot<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>       </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span></span></span></code></pre></div><p>Os <em>tokens</em> de contas de serviço são perfeitamente válidos para ser usados fora do cluster e podem ser utilizados para criar identidades para processos de longa duração que desejem comunicar-se com a API do Kubernetes. Para criar manualmente uma conta de serviço, utilize-se simplesmente o comando <code>kubectl create serviceaccount (NOME)</code>. Isso cria uma conta de serviço e um segredo associado a ela no namespace atual.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl create serviceaccount jenkins
</span></span></code></pre></div><pre tabindex=0><code class=language-none data-lang=none>serviceaccount &#34;jenkins&#34; created
</code></pre><p>Verificando um segredo associado:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl get serviceaccounts jenkins -o yaml
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ServiceAccount<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>secrets</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>jenkins-token-1yvwg<span style=color:#bbb>
</span></span></span></code></pre></div><p>O segredo criado irá armazenar a autoridade de certificado do servidor de API e um JSON Web Token (JWT) digitalmente assinado.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl get secret jenkins-token-1yvwg -o yaml
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>ca.crt</span>:<span style=color:#bbb> </span>(APISERVER&#39;S CA BASE64 ENCODED)<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>ZGVmYXVsdA==<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>token</span>:<span style=color:#bbb> </span>(BEARER TOKEN BASE64 ENCODED)<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>kubernetes.io/service-account-token<span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Valores são codificados em base64 porque segredos são sempre codificados neste formato.</div><p>O JWT assinado pode ser usado como um <em>bearer token</em> para autenticar-se como a conta de serviço. Veja <a href=#adicionando-um-bearer-token-em-uma-requisi%C3%A7%C3%A3o>acima</a> como o <em>token</em> pode ser incluído em uma requisição. Normalmente esses segredos são montados no pod para um acesso interno ao cluster ao servidor de API, porém pode ser utilizado fora do cluster também.</p><p>Contas de serviço são autenticadas com o nome de usuário <code>system:serviceaccount:(NAMESPACE):(SERVICEACCOUNT)</code> e são atribuídas aos grupos <code>system:serviceaccounts</code> e <code>system:serviceaccounts:(NAMESPACE)</code>.</p><p>AVISO: porque os <em>tokens</em> das contas de serviço são armazenados em segredos, qualquer usuário com acesso de leitura a esses segredos podem autenticar-se como a conta de serviço. Tome cuidado quando conceder permissões a contas de serviços e capacidade de leitura de segredos.</p><h3 id=tokens-openid-connect>Tokens OpenID Connect</h3><p><a href=https://openid.net/connect/>OpenID Connect</a> é uma variação do framework de autorização OAuth2 que suporta provedores como Azure Active Directory, Salesforce, e Google. A principal extensão do OAuth2 é um campo adicional de <em>token</em> de acesso chamado <a href=https://openid.net/specs/openid-connect-core-1_0.html#IDToken>ID Token</a>. Este <em>token</em> é um tipo de JSON Web Token (JWT) com campos bem definidos, como usuário, e-mail e é assinado pelo servidor de autorização.</p><p>Para identificar o usuário, o autenticador usa o <code>id_token</code> (e não <code>access_token</code>) do <em>bearer token</em> da resposta de autorização do OAuth2 <a href=https://openid.net/specs/openid-connect-core-1_0.html#TokenResponse>token response</a>. Veja <a href=#adicionando-um-bearer-token-em-uma-requisi%C3%A7%C3%A3o>acima</a> como incluir um <em>token</em> em uma requisição.</p><figure><div class=mermaid>sequenceDiagram
participant usuário as Usuário
participant IDP as Provedor<br>de Identidade
participant kube as Kubectl
participant API as API Server
usuário ->> IDP: 1. Realizar Login no IdP
activate IDP
IDP -->> usuário: 2. Fornece access_token,<br>id_token, e refresh_token
deactivate IDP
activate usuário
usuário ->> kube: 3. Entrar Kubectl<br>com --token sendo id_token<br>ou adiciona tokens no arquivo .kube/config
deactivate usuário
activate kube
kube ->> API: 4. Emite requisição incluindo o cabeçalho HTTP Authorization: Bearer...
deactivate kube
activate API
API ->> API: 5. O token do tipo JWT possui assinatura válida ?
API ->> API: 6. O token está expirado ? (iat+exp)
API ->> API: 7. Usuário autorizado ?
API -->> kube: 8. Autorizado: Realiza<br>ação e retorna resultado
deactivate API
activate kube
kube --x usuário: 9. Retorna resultado
deactivate kube</div></figure><noscript><div class="alert alert-secondary callout" role=alert><em class=javascript-required>JavaScript must be <a href=https://www.enable-javascript.com/>enabled</a> to view this content</em></div></noscript><ol><li>Login no seu provedor de identidade.</li><li>Seu provedor de identidade ira fornecer um <code>access_token</code>, <code>id_token</code> e um <code>refresh_token</code>.</li><li>Quando utilizando <code>kubectl</code>, utilize do seu <code>id_token</code> com a opção <code>--token</code> ou adicione o token diretamente no seu arquivo de configuração <code>kubeconfig</code>.</li><li><code>kubectl</code> envia o seu <code>id_token</code> em um cabeçalho HTTP chamado <em>Authorization</em> para o servidor de API.</li><li>O servidor de API irá garantir que a assinatura do token JWT é válida, verificando-o em relação ao certificado mencionado na configuração.</li><li>Verificação para garantir que o<code>id_token</code> não esteja expirado.</li><li>Garantir que o usuário é autorizado.</li><li>Uma vez autorizado o servidor de API retorna a resposta para o <code>kubectl</code>.</li><li><code>kubectl</code> fornece retorno ao usuário.</li></ol><p>Uma vez que todos os dados necessários para determinar sua identidade encontram-se no <code>id_token</code>, Kubernetes não precisa realizar outra chamada para o provedor de identidade. Em um modelo onde cada requisição não possui estado, isso fornece uma solução escalável para autenticação. Isso, porem, apresenta alguns desafios:</p><ol><li>Kubernetes não possui uma "interface web" para disparar o processo de autenticação. Não há browser ou interface para coletar credenciais que são necessárias para autenticar-se primeiro no seu provedor de identidade.</li><li>O <code>id_token</code> não pode ser revogado, funcionando como um certificado, portanto deve possuir curta validade (somente alguns minutos) o que pode tornar a experiência um pouco desconfortável, fazendo com que se requisite um novo <em>token</em> toda vez em um curto intervalo (poucos minutos de validade do <em>token</em>)</li><li>Para autenticar-se ao dashboard Kubernetes, você deve executar o comando <code>kubectl proxy</code> ou um proxy reverso que consiga injetar o <code>id_token</code>.</li></ol><h4 id=configurando-o-servidor-de-api>Configurando o Servidor de API</h4><p>Para habilitar o plugin de autorização, configure as seguintes opções no servidor de API:</p><table><thead><tr><th>Parâmetro</th><th>Descrição</th><th>Exemplo</th><th>Obrigatório</th></tr></thead><tbody><tr><td><code>--oidc-issuer-url</code></td><td>URL do provedor que permite ao servidor de API descobrir chaves públicas de assinatura. Somente URLs que usam o esquema <code>https://</code> são aceitas. Isto normalmente é o endereço de descoberta do provedor sem o caminho, por exemplo "https://accounts.google.com" ou "https://login.salesforce.com". Esta URL deve apontar para o nível abaixo do caminho .well-known/openid-configuration</td><td>Se o valor da URL de descoberta é <code>https://accounts.google.com/.well-known/openid-configuration</code>, entao o valor deve ser <code>https://accounts.google.com</code></td><td>Sim</td></tr><tr><td><code>--oidc-client-id</code></td><td>Identificador do cliente para o qual todos os tokens são gerados.</td><td>kubernetes</td><td>Sim</td></tr><tr><td><code>--oidc-username-claim</code></td><td>Atributo do JWT a ser usado como nome de usuário. Por padrão o valor <code>sub</code>, o qual é esperado que seja um identificador único do usuário final. Administradores podem escolher outro atributo, como <code>email</code> ou <code>name</code>, dependendo de seu provedor de identidade. No entanto, outros atributos além de <code>email</code> serão prefixados com a URL do emissor issuer URL para prevenir conflitos de nome com outros plugins.</td><td>sub</td><td>Não</td></tr><tr><td><code>--oidc-username-prefix</code></td><td>Prefixos adicionados ao atributo de nome de usuário para prevenir conflitos de nomes existentes (como por exemplo usuários <code>system:</code>). Por exemplo, o valor <code>oidc:</code> irá criar usuários como <code>oidc:jane.doe</code>. Se esta opção não for fornecida <code>--oidc-username-claim</code> e um valor diferente de <code>email</code> irá conter um prefixo padrão com o valor de <code>( Issuer URL )#</code> onde <code>( Issuer URL )</code> era o valor da opção <code>--oidc-issuer-url</code>. O valor <code>-</code> pode ser utilizado para desabilitar todos os prefixos.</td><td><code>oidc:</code></td><td>Não</td></tr><tr><td><code>--oidc-groups-claim</code></td><td>Atributo do JWT a ser utilizado para mapear os grupos dos usuários. Se o atributo está presente, ele deve ser do tipo vetor de Strings.</td><td>groups</td><td>Não</td></tr><tr><td><code>--oidc-groups-prefix</code></td><td>Prefixo adicionados ao atributo de grupo para prevenir conflitos de nomes existentes (como por exemplo <code>system:</code> grupos). Por exemplo, o valor <code>oidc:</code> irá criar nomes de grupos como <code>oidc:engineering</code> e <code>oidc:infra</code>.</td><td><code>oidc:</code></td><td>Não</td></tr><tr><td><code>--oidc-required-claim</code></td><td>Um par de chave=valor que descreve atributos obrigatórios no <em>ID Token</em>. Se configurado, a presença do atributo é verificado dentro do <em>ID Token</em> com um valor relacionado. Repita esta opção para configurar múltiplos atributos obrigatórios.</td><td><code>claim=value</code></td><td>Não</td></tr><tr><td><code>--oidc-ca-file</code></td><td>O caminho para o arquivo de certificado da autoridade de certificados (CA) que assinou o certificado do provedor de identidades.</td><td><code>/etc/kubernetes/ssl/kc-ca.pem</code></td><td>Não</td></tr></tbody></table><p>É importante ressaltar que o servidor de API não é um cliente Oauth2, ao contrário, ele só pode ser configurado para confiar em um emissor. Isso permite o uso de emissores públicos, como Google, sem confiar em credenciais emitidas por terceiros. Administradores que desejam utilizar-se de múltiplos clientes OAuth2 devem explorar provedores os quais suportam atributos <code>azp</code> (parte autorizada), que é um mecanismo para permitir um cliente a emitir tokens em nome de outro.</p><p>Kubernetes não oferece um provedor de identidade OpenID Connect. Pode-se utilizar provedores públicos existentes como Google ou <a href=https://connect2id.com/products/nimbus-oauth-openid-connect-sdk/openid-connect-providers>outros</a>. Ou, pode-se rodar o próprio provedor de identidade no cluster, como <a href=https://dexidp.io/>dex</a>,
<a href=https://github.com/keycloak/keycloak>Keycloak</a>,
CloudFoundry <a href=https://github.com/cloudfoundry/uaa>UAA</a>, ou
Tremolo Security's <a href=https://github.com/tremolosecurity/openunison>OpenUnison</a>.</p><p>Para um provedor de identidades funcionar no Kubernetes, ele deve:</p><ol><li>Suportar o framework <a href=https://openid.net/specs/openid-connect-discovery-1_0.html>OpenID connect discovery</a>; Nem todos suportam.</li><li>Executar TLS com cifras criptográficas não obsoletos.</li><li>Possuir certificados assinados por uma Autoridade certificadora (mesmo que o CA não seja comercial ou seja auto-assinado)</li></ol><p>Uma nota sobre o requisito #3 acima. Se você instalar o seu próprio provedor de identidades (ao invés de utilizar um provedor como Google ou Microsoft) você DEVE ter o certificado web do seu provedor de identidades assinado por um certificado contendo a opção <code>CA</code> configurada para <code>TRUE</code>, mesmo que seja um certificado auto assinado. Isso deve-se a implementação do cliente TLS em Golang que é bastante restrito quanto aos padrões em torno da validação de certificados. Se você não possui um CA em fácil alcance, você pode usar <a href=https://github.com/dexidp/dex/blob/master/examples/k8s/gencert.sh>este script</a> criado pelo time Dex para criar um simples CA, um par de chaves e certificado assinados.
Ou você pode usar <a href=https://raw.githubusercontent.com/TremoloSecurity/openunison-qs-kubernetes/master/src/main/bash/makessl.sh>este script similar</a> o qual gera certificados SHA256 com uma vida mais longa e tamanho maior de chave.</p><p>Instruções de configuração para sistemas específicos podem ser encontrados em:</p><ul><li><a href=https://docs.cloudfoundry.org/concepts/architecture/uaa.html>UAA</a></li><li><a href=https://dexidp.io/docs/kubernetes/>Dex</a></li><li><a href=https://www.tremolosecurity.com/orchestra-k8s/>OpenUnison</a></li></ul><h4 id=utilizando-kubectl>Utilizando kubectl</h4><h5 id=opção-1-autenticador-oidc>Opção 1 - Autenticador OIDC</h5><p>A primeira opção é utilizar-se do autenticador <code>oidc</code> do kubectl, o qual define o valor do <code>id_token</code> como um <em>bearer token</em> para todas as requisições e irá atualizar o token quando o mesmo expirar. Após você efetuar o login no seu provedor, utilize o kubectl para adicionar os seus <code>id_token</code>, <code>refresh_token</code>, <code>client_id</code>, e <code>client_secret</code> para configurar o plugin.</p><p>Provedores os quais não retornem um <code>id_token</code> como parte da sua resposta de <em>refresh token</em> não são suportados por este plugin e devem utilizar a opção 2 abaixo.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl config set-credentials USER_NAME <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --auth-provider<span style=color:#666>=</span>oidc <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --auth-provider-arg<span style=color:#666>=</span>idp-issuer-url<span style=color:#666>=(</span> issuer url <span style=color:#666>)</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --auth-provider-arg<span style=color:#666>=</span>client-id<span style=color:#666>=(</span> your client id <span style=color:#666>)</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --auth-provider-arg<span style=color:#666>=</span>client-secret<span style=color:#666>=(</span> your client secret <span style=color:#666>)</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --auth-provider-arg<span style=color:#666>=</span>refresh-token<span style=color:#666>=(</span> your refresh token <span style=color:#666>)</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --auth-provider-arg<span style=color:#666>=</span>idp-certificate-authority<span style=color:#666>=(</span> path to your ca certificate <span style=color:#666>)</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --auth-provider-arg<span style=color:#666>=</span>id-token<span style=color:#666>=(</span> your id_token <span style=color:#666>)</span>
</span></span></code></pre></div><p>Um exemplo, executando o comando abaixo após autenticar-se no seu provedor de identidades:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl config set-credentials mmosley  <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>       --auth-provider<span style=color:#666>=</span>oidc  <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>       --auth-provider-arg<span style=color:#666>=</span>idp-issuer-url<span style=color:#666>=</span>https://oidcidp.tremolo.lan:8443/auth/idp/OidcIdP  <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>       --auth-provider-arg<span style=color:#666>=</span>client-id<span style=color:#666>=</span>kubernetes  <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>       --auth-provider-arg<span style=color:#666>=</span>client-secret<span style=color:#666>=</span>1db158f6-177d-4d9c-8a8b-d36869918ec5  <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>       --auth-provider-arg<span style=color:#666>=</span>refresh-token<span style=color:#666>=</span>q1bKLFOyUiosTfawzA93TzZIDzH2TNa2SMm0zEiPKTUwME6BkEo6Sql5yUWVBSWpKUGphaWpxSVAfekBOZbBhaEW+VlFUeVRGcluyVF5JT4+haZmPsluFoFu5XkpXk5BXqHega4GAXlF+ma+vmYpFcHe5eZR+slBFpZKtQA<span style=color:#666>=</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>       --auth-provider-arg<span style=color:#666>=</span>idp-certificate-authority<span style=color:#666>=</span>/root/ca.pem <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>       --auth-provider-arg<span style=color:#666>=</span>id-token<span style=color:#666>=</span>eyJraWQiOiJDTj1vaWRjaWRwLnRyZW1vbG8ubGFuLCBPVT1EZW1vLCBPPVRybWVvbG8gU2VjdXJpdHksIEw9QXJsaW5ndG9uLCBTVD1WaXJnaW5pYSwgQz1VUy1DTj1rdWJlLWNhLTEyMDIxNDc5MjEwMzYwNzMyMTUyIiwiYWxnIjoiUlMyNTYifQ.eyJpc3MiOiJodHRwczovL29pZGNpZHAudHJlbW9sby5sYW46ODQ0My9hdXRoL2lkcC9PaWRjSWRQIiwiYXVkIjoia3ViZXJuZXRlcyIsImV4cCI6MTQ4MzU0OTUxMSwianRpIjoiMm96US15TXdFcHV4WDlHZUhQdy1hZyIsImlhdCI6MTQ4MzU0OTQ1MSwibmJmIjoxNDgzNTQ5MzMxLCJzdWIiOiI0YWViMzdiYS1iNjQ1LTQ4ZmQtYWIzMC0xYTAxZWU0MWUyMTgifQ.w6p4J_6qQ1HzTG9nrEOrubxIMb9K5hzcMPxc9IxPx2K4xO9l-oFiUw93daH3m5pluP6K7eOE6txBuRVfEcpJSwlelsOsW8gb8VJcnzMS9EnZpeA0tW_p-mnkFc3VcfyXuhe5R3G7aa5d8uHv70yJ9Y3-UhjiN9EhpMdfPAoEB9fYKKkJRzF7utTTIPGrSaSU6d2pcpfYKaxIwePzEkT4DfcQthoZdy9ucNvvLoi1DIC-UocFD8HLs8LYKEqSxQvOcvnThbObJ9af71EwmuE21fO5KzMW20KtAeget1gnldOosPtz1G5EwvaQ401-RPQzPGMVBld0_zMCAwZttJ4knw
</span></span></code></pre></div><p>O qual irá produzir a configuração abaixo:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>users</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mmosley<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span><span style=color:green;font-weight:700>auth-provider</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>config</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>       </span><span style=color:green;font-weight:700>client-id</span>:<span style=color:#bbb> </span>kubernetes<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>       </span><span style=color:green;font-weight:700>client-secret</span>:<span style=color:#bbb> </span>1db158f6-177d-4d9c-8a8b-d36869918ec5<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>       </span><span style=color:green;font-weight:700>id-token</span>:<span style=color:#bbb> </span>eyJraWQiOiJDTj1vaWRjaWRwLnRyZW1vbG8ubGFuLCBPVT1EZW1vLCBPPVRybWVvbG8gU2VjdXJpdHksIEw9QXJsaW5ndG9uLCBTVD1WaXJnaW5pYSwgQz1VUy1DTj1rdWJlLWNhLTEyMDIxNDc5MjEwMzYwNzMyMTUyIiwiYWxnIjoiUlMyNTYifQ.eyJpc3MiOiJodHRwczovL29pZGNpZHAudHJlbW9sby5sYW46ODQ0My9hdXRoL2lkcC9PaWRjSWRQIiwiYXVkIjoia3ViZXJuZXRlcyIsImV4cCI6MTQ4MzU0OTUxMSwianRpIjoiMm96US15TXdFcHV4WDlHZUhQdy1hZyIsImlhdCI6MTQ4MzU0OTQ1MSwibmJmIjoxNDgzNTQ5MzMxLCJzdWIiOiI0YWViMzdiYS1iNjQ1LTQ4ZmQtYWIzMC0xYTAxZWU0MWUyMTgifQ.w6p4J_6qQ1HzTG9nrEOrubxIMb9K5hzcMPxc9IxPx2K4xO9l-oFiUw93daH3m5pluP6K7eOE6txBuRVfEcpJSwlelsOsW8gb8VJcnzMS9EnZpeA0tW_p-mnkFc3VcfyXuhe5R3G7aa5d8uHv70yJ9Y3-UhjiN9EhpMdfPAoEB9fYKKkJRzF7utTTIPGrSaSU6d2pcpfYKaxIwePzEkT4DfcQthoZdy9ucNvvLoi1DIC-UocFD8HLs8LYKEqSxQvOcvnThbObJ9af71EwmuE21fO5KzMW20KtAeget1gnldOosPtz1G5EwvaQ401-RPQzPGMVBld0_zMCAwZttJ4knw<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>       </span><span style=color:green;font-weight:700>idp-certificate-authority</span>:<span style=color:#bbb> </span>/root/ca.pem<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>       </span><span style=color:green;font-weight:700>idp-issuer-url</span>:<span style=color:#bbb> </span>https://oidcidp.tremolo.lan:8443/auth/idp/OidcIdP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>       </span><span style=color:green;font-weight:700>refresh-token</span>:<span style=color:#bbb> </span>q1bKLFOyUiosTfawzA93TzZIDzH2TNa2SMm0zEiPKTUwME6BkEo6Sql5yUWVBSWpKUGphaWpxSVAfekBOZbBhaEW+VlFUeVRGcluyVF5JT4+haZmPsluFoFu5XkpXk5BXq<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>oidc<span style=color:#bbb>
</span></span></span></code></pre></div><p>Uma vez que seu <code>id_token</code> expire, <code>kubectl</code> irá tentar atualizar o seu <code>id_token</code> utilizando-se do seu <code>refresh_token</code> e <code>client_secret</code> armazenando os novos valores para <code>refresh_token</code> e <code>id_token</code> no seu arquivo de configuração <code>.kube/config</code>.</p><h5 id=opção-2-utilize-a-opção-token>Opção 2 - Utilize a opção <code>--token</code></h5><p>O comando <code>kubectl</code> o permite passar o valor de um token utilizando a opção <code>--token</code>. Copie e cole o valor do seu <code>id_token</code> nesta opção:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl --token<span style=color:#666>=</span>eyJhbGciOiJSUzI1NiJ9.eyJpc3MiOiJodHRwczovL21sYi50cmVtb2xvLmxhbjo4MDQzL2F1dGgvaWRwL29pZGMiLCJhdWQiOiJrdWJlcm5ldGVzIiwiZXhwIjoxNDc0NTk2NjY5LCJqdGkiOiI2RDUzNXoxUEpFNjJOR3QxaWVyYm9RIiwiaWF0IjoxNDc0NTk2MzY5LCJuYmYiOjE0NzQ1OTYyNDksInN1YiI6Im13aW5kdSIsInVzZXJfcm9sZSI6WyJ1c2VycyIsIm5ldy1uYW1lc3BhY2Utdmlld2VyIl0sImVtYWlsIjoibXdpbmR1QG5vbW9yZWplZGkuY29tIn0.f2As579n9VNoaKzoF-dOQGmXkFKf1FMyNV0-va_B63jn-_n9LGSCca_6IVMP8pO-Zb4KvRqGyTP0r3HkHxYy5c81AnIh8ijarruczl-TK_yF5akjSTHFZD-0gRzlevBDiH8Q79NAr-ky0P4iIXS8lY9Vnjch5MF74Zx0c3alKJHJUnnpjIACByfF2SCaYzbWFMUNat-K1PaUk5-ujMBG7yYnr95xD-63n8CO8teGUAAEMx6zRjzfhnhbzX-ajwZLGwGUBT4WqjMs70-6a7_8gZmLZb2az1cZynkFRj2BaCkVT3A2RrjeEwZEtGXlMqKJ1_I2ulrOVsYx01_yD35-rw get nodes
</span></span></code></pre></div><h3 id=token-de-autenticação-via-webhook>Token de autenticação via Webhook</h3><p>Webhook de autenticação é usado para verificar <em>bearer tokens</em></p><ul><li><code>--authentication-token-webhook-config-file</code> arquivo de configuração descrevendo como acessar o serviço remoto de webhook.</li><li><code>--authentication-token-webhook-cache-ttl</code> por quanto tempo guardar em cache decisões de autenticação. Configuração padrão definida para dois minutos.</li><li><code>--authentication-token-webhook-version</code> determina quando usar o apiVersion <code>authentication.k8s.io/v1beta1</code> ou <code>authentication.k8s.io/v1</code> para objetos <code>TokenReview</code> quando enviar/receber informações do webhook. Valor padrão <code>v1beta1</code>.</li></ul><p>O arquivo de configuração usa o formato de arquivo do <a href=/docs/concepts/configuration/organize-cluster-access-kubeconfig/>kubeconfig</a>. Dentro do arquivo, <code>clusters</code> refere-se ao serviço remoto e <code>users</code> refere-se ao servidor de API do webhook. Um exemplo seria:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#080;font-style:italic># versão da API do Kubernetes</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># tipo do objeto da API</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># clusters refere-se ao serviço remoto</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>clusters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>name-of-remote-authn-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span><span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>certificate-authority</span>:<span style=color:#bbb> </span>/path/to/ca.pem        <span style=color:#bbb> </span><span style=color:#080;font-style:italic># CA para verificar o serviço remoto</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>server</span>:<span style=color:#bbb> </span>https://authn.example.com/authenticate<span style=color:#bbb> </span><span style=color:#080;font-style:italic># URL para procurar o serviço remoto. Deve utilizar &#39;https&#39;.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> 
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># users refere-se a configuração do webhook do servidor de  API</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>users</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>name-of-api-server<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>client-certificate</span>:<span style=color:#bbb> </span>/path/to/cert.pem<span style=color:#bbb> </span><span style=color:#080;font-style:italic># certificado para ser utilizado pelo plugin de webhook</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>client-key</span>:<span style=color:#bbb> </span>/path/to/key.pem         <span style=color:#bbb> </span><span style=color:#080;font-style:italic># chave referente ao certificado</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> 
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># arquivos kubeconfig requerem um contexto. Especifique um para o servidor de API.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>current-context</span>:<span style=color:#bbb> </span>webhook<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>contexts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>context</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span><span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb> </span>name-of-remote-authn-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb> </span>name-of-api-server<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>webhook<span style=color:#bbb>
</span></span></span></code></pre></div><p>Quando um cliente tenta autenticar-se com o servidor de API utilizando um <em>bearer token</em> como discutido <a href=#adicionando-um-bearer-token-em-uma-requisi%C3%A7%C3%A3o>acima</a>, o webhook de autenticação envia um objeto JSON serializado do tipo <code>TokenReview</code> contendo o valor do <em>token</em> para o serviço remoto.</p><p>Note que objetos de API do tipo <em>webhook</em> estão sujeitos às mesmas <a href=/docs/concepts/overview/kubernetes-api/>regras de compatibilidade de versão</a> como outros objetos de API Kubernetes.
Implementadores devem verificar o campo de versão da API (<code>apiVersion</code>) da requisição para garantir a correta deserialização e <strong>devem</strong> responder com um objeto do tipo <code>TokenReview</code> da mesma versão da requisição.</p><ul class="nav nav-tabs" id=tokenreview-request role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tokenreview-request-0 role=tab aria-controls=tokenreview-request-0 aria-selected=true>authentication.k8s.io/v1</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tokenreview-request-1 role=tab aria-controls=tokenreview-request-1>authentication.k8s.io/v1beta1</a></li></ul><div class=tab-content id=tokenreview-request><div id=tokenreview-request-0 class="tab-pane show active" role=tabpanel aria-labelledby=tokenreview-request-0><p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong><p>O servidor de API Kubernetes envia por padrão revisão de tokens para a API <code>authentication.k8s.io/v1beta1</code> para fins de compatibilidade com versões anteriores.</p><p>Para optar receber revisão de tokens de versão <code>authentication.k8s.io/v1</code>, o servidor de API deve ser inicializado com a opção <code>--authentication-token-webhook-version=v1</code>.</p></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>&#34;apiVersion&#34;: </span><span style=color:#b44>&#34;authentication.k8s.io/v1&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>&#34;kind&#34;: </span><span style=color:#b44>&#34;TokenReview&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>&#34;spec&#34;: </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span><span style=color:#080;font-style:italic># Bearer token opaco enviado para o servidor de API</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span><span style=color:green;font-weight:700>&#34;token&#34;: </span><span style=color:#b44>&#34;014fbff9a07c...&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> 
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span><span style=color:#080;font-style:italic># Lista opcional de identificadores de audiência para o servidor ao qual o token foi apresentado</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span><span style=color:#080;font-style:italic># Autenticadores de token  sensíveis a audiência (por exemplo, autenticadores de token OIDC)</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span><span style=color:#080;font-style:italic># deve-se verificar que o token foi direcionado a pelo menos um membro da lista de audiência</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span><span style=color:#080;font-style:italic># e retornar a interseção desta lista a audiência válida para o token no estado da resposta</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span><span style=color:#080;font-style:italic># Isto garante com que o token é válido para autenticar-se no servidor ao qual foi apresentado</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span><span style=color:#080;font-style:italic># Se nenhuma audiência for especificada, o token deve ser validado para autenticar-se ao servidor de API do Kubernetes</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span><span style=color:green;font-weight:700>&#34;audiences&#34;: </span>[<span style=color:#b44>&#34;https://myserver.example.com&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;https://myserver.internal.example.com&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></span></span></code></pre></div></div><div id=tokenreview-request-1 class=tab-pane role=tabpanel aria-labelledby=tokenreview-request-1><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>&#34;apiVersion&#34;: </span><span style=color:#b44>&#34;authentication.k8s.io/v1beta1&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>&#34;kind&#34;: </span><span style=color:#b44>&#34;TokenReview&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>&#34;spec&#34;: </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span><span style=color:#080;font-style:italic># Bearer token opaco enviado para o servidor de API</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span><span style=color:green;font-weight:700>&#34;token&#34;: </span><span style=color:#b44>&#34;014fbff9a07c...&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> 
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span><span style=color:#080;font-style:italic># Lista opcional de identificadores de audiência para o servidor ao qual o token foi apresentado</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span><span style=color:#080;font-style:italic># Autenticadores de token  sensíveis a audiência (por exemplo, autenticadores de token OIDC)</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span><span style=color:#080;font-style:italic># deve-se verificar que o token foi direcionado a pelo menos um membro da lista de audiência</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span><span style=color:#080;font-style:italic># e retornar a interseção desta lista a audiência válida para o token no estado da resposta</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span><span style=color:#080;font-style:italic># Isto garante com que o token é válido para autenticar-se no servidor ao qual foi apresentado</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span><span style=color:#080;font-style:italic># Se nenhuma audiência for especificada, o token deve ser validado para autenticar-se ao servidor de API do Kubernetes</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span><span style=color:green;font-weight:700>&#34;audiences&#34;: </span>[<span style=color:#b44>&#34;https://myserver.example.com&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;https://myserver.internal.example.com&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>É esperado que o serviço remoto preencha o campo <code>status</code> da requisição para indicar o sucesso do login.
O campo <code>spec</code> do corpo de resposta é ignorado e pode ser omitido.
O serviço remoto deverá retornar uma resposta usando a mesma versão de API do objeto <code>TokenReview</code> que foi recebido.
Uma validação bem sucedida deveria retornar:</p><ul class="nav nav-tabs" id=tokenreview-response-success role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tokenreview-response-success-0 role=tab aria-controls=tokenreview-response-success-0 aria-selected=true>authentication.k8s.io/v1</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tokenreview-response-success-1 role=tab aria-controls=tokenreview-response-success-1>authentication.k8s.io/v1beta1</a></li></ul><div class=tab-content id=tokenreview-response-success><div id=tokenreview-response-success-0 class="tab-pane show active" role=tabpanel aria-labelledby=tokenreview-response-success-0><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>&#34;apiVersion&#34;: </span><span style=color:#b44>&#34;authentication.k8s.io/v1&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>&#34;kind&#34;: </span><span style=color:#b44>&#34;TokenReview&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>&#34;status&#34;: </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span><span style=color:green;font-weight:700>&#34;authenticated&#34;: </span><span style=color:#a2f;font-weight:700>true</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span><span style=color:green;font-weight:700>&#34;user&#34;: </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:#080;font-style:italic># Obrigatório</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>&#34;username&#34;: </span><span style=color:#b44>&#34;janedoe@example.com&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:#080;font-style:italic># Opcional</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>&#34;uid&#34;: </span><span style=color:#b44>&#34;42&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:#080;font-style:italic># Opcional: lista de grupos associados</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>&#34;groups&#34;: </span>[<span style=color:#b44>&#34;developers&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;qa&#34;</span>],<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:#080;font-style:italic># Opcional: informação adicional  provida pelo autenticador.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:#080;font-style:italic># Isto não deve conter dados confidenciais, pois pode ser registrados em logs ou em objetos de API e estarão disponíveis para webhooks de admissão</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>&#34;extra&#34;: </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>       </span><span style=color:green;font-weight:700>&#34;extrafield1&#34;: </span>[<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>         </span><span style=color:#b44>&#34;extravalue1&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>         </span><span style=color:#b44>&#34;extravalue2&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>       </span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span>},<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span><span style=color:#080;font-style:italic># Lista opcional de Autenticadores de token  sensíveis a audiência que podem ser retornados,</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span><span style=color:#080;font-style:italic># contendo as audiências da lista `spec.audiences` válido para o token apresentado.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span><span style=color:#080;font-style:italic># Se este campo for omitido, o token é considerado válido para autenticar-se no servidor de API Kubernetes</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span><span style=color:green;font-weight:700>&#34;audiences&#34;: </span>[<span style=color:#b44>&#34;https://myserver.example.com&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></span></span></code></pre></div></div><div id=tokenreview-response-success-1 class=tab-pane role=tabpanel aria-labelledby=tokenreview-response-success-1><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>&#34;apiVersion&#34;: </span><span style=color:#b44>&#34;authentication.k8s.io/v1beta1&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>&#34;kind&#34;: </span><span style=color:#b44>&#34;TokenReview&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>&#34;status&#34;: </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span><span style=color:green;font-weight:700>&#34;authenticated&#34;: </span><span style=color:#a2f;font-weight:700>true</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span><span style=color:green;font-weight:700>&#34;user&#34;: </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:#080;font-style:italic># Obrigatório</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>&#34;username&#34;: </span><span style=color:#b44>&#34;janedoe@example.com&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:#080;font-style:italic># Opcional</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>&#34;uid&#34;: </span><span style=color:#b44>&#34;42&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:#080;font-style:italic># Opcional: lista de grupos associados</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>&#34;groups&#34;: </span>[<span style=color:#b44>&#34;developers&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;qa&#34;</span>],<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:#080;font-style:italic># Opcional: informação adicional  provida pelo autenticador.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:#080;font-style:italic># Isto não deve conter dados confidenciais, pois pode ser registrados em logs ou em objetos de API e estarão disponíveis para webhooks de admissão</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>&#34;extra&#34;: </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>       </span><span style=color:green;font-weight:700>&#34;extrafield1&#34;: </span>[<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>         </span><span style=color:#b44>&#34;extravalue1&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>         </span><span style=color:#b44>&#34;extravalue2&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>       </span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span>},<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span><span style=color:#080;font-style:italic># Lista opcional de Autenticadores de token  sensíveis a audiência que podem ser retornados,</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span><span style=color:#080;font-style:italic># contendo as audiências da lista `spec.audiences` válido para o token apresentado.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span><span style=color:#080;font-style:italic># Se este campo for omitido, o token é considerado válido para autenticar-se no servidor de API Kubernetes</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span><span style=color:green;font-weight:700>&#34;audiences&#34;: </span>[<span style=color:#b44>&#34;https://myserver.example.com&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Uma requisição mal sucedida retornaria:</p><ul class="nav nav-tabs" id=tokenreview-response-error role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tokenreview-response-error-0 role=tab aria-controls=tokenreview-response-error-0 aria-selected=true>authentication.k8s.io/v1</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tokenreview-response-error-1 role=tab aria-controls=tokenreview-response-error-1>authentication.k8s.io/v1beta1</a></li></ul><div class=tab-content id=tokenreview-response-error><div id=tokenreview-response-error-0 class="tab-pane show active" role=tabpanel aria-labelledby=tokenreview-response-error-0><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>&#34;apiVersion&#34;: </span><span style=color:#b44>&#34;authentication.k8s.io/v1&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>&#34;kind&#34;: </span><span style=color:#b44>&#34;TokenReview&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>&#34;status&#34;: </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span><span style=color:green;font-weight:700>&#34;authenticated&#34;: </span><span style=color:#a2f;font-weight:700>false</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span><span style=color:#080;font-style:italic># Opcionalmente inclui detalhes sobre o porque a autenticação falhou</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span><span style=color:#080;font-style:italic># Se nenhum erro é fornecido, a API irá retornar uma mensagem genérica de &#34;Não autorizado&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span><span style=color:#080;font-style:italic># O campo de erro é ignorado quando authenticated=true.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span><span style=color:green;font-weight:700>&#34;error&#34;: </span><span style=color:#b44>&#34;Credenciais expiradas&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></span></span></code></pre></div></div><div id=tokenreview-response-error-1 class=tab-pane role=tabpanel aria-labelledby=tokenreview-response-error-1><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>&#34;apiVersion&#34;: </span><span style=color:#b44>&#34;authentication.k8s.io/v1beta1&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>&#34;kind&#34;: </span><span style=color:#b44>&#34;TokenReview&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>&#34;status&#34;: </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span><span style=color:green;font-weight:700>&#34;authenticated&#34;: </span><span style=color:#a2f;font-weight:700>false</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span><span style=color:#080;font-style:italic># Opcionalmente inclui detalhes sobre o porque a autenticação falhou</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span><span style=color:#080;font-style:italic># Se nenhum erro é fornecido, a API irá retornar uma mensagem genérica de &#34;Não autorizado&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span><span style=color:#080;font-style:italic># O campo de erro é ignorado quando authenticated=true.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span><span style=color:green;font-weight:700>&#34;error&#34;: </span><span style=color:#b44>&#34;Credenciais expiradas&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><h3 id=autenticando-com-proxy>Autenticando com Proxy</h3><p>O servidor de API pode ser configurado para identificar usuários através de valores de cabeçalho de requisição, como por exemplo <code>X-Remote-User</code>.
Isto é projetado para o uso em combinação com um proxy de autenticação, o qual irá atribuir o valor do cabeçalho da requisição.</p><ul><li><p><code>--requestheader-username-headers</code> Obrigatório, não faz distinção entre caracteres maiúsculos/minúsculos. Nomes de cabeçalhos a serem verificados, em ordem, para a identidade do usuário. O primeiro cabeçalho contendo um valor será usado para o nome do usuário.</p></li><li><p><code>--requestheader-group-headers</code> 1.6+. Opcional, não faz distinção entre caracteres maiúsculos/minúsculos. "X-Remote-Group" é recomendado. Nomes de cabeçalhos a serem verificados, em ordem, para os grupos do usuário. Todos os valores especificados em todos os cabeçalhos serão utilizados como nome dos grupos do usuário.</p></li><li><p><code>--requestheader-extra-headers-prefix</code> 1.6+. Opcional, não faz distinção entre caracteres maiúsculos/minúsculos. "X-Remote-Extra-" é recomendado. Prefixos de cabeçalhos para serem utilizados para definir informações extras sobre o usuário (normalmente utilizado por um plugin de autorização). Todos os cabeçalhos que começam com qualquer um dos prefixos especificados têm o prefixo removido. O restante do nome do cabeçalho é transformado em letra minúscula, decodificado <a href=https://tools.ietf.org/html/rfc3986#section-2.1>percent-decoded</a> e torna-se uma chave extra, e o valor do cabeçalho torna-se um valor extra.</p></li></ul><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Antes da versão 1.11.3 (e 1.10.7, 1.9.11), a chave extra só poderia conter caracteres os quais fossem <a href=https://tools.ietf.org/html/rfc7230#section-3.2.6>legais em rótulos de cabeçalhos HTTP</a>.</div><p>Por exemplo, com esta configuração:</p><pre tabindex=0><code>--requestheader-username-headers=X-Remote-User
--requestheader-group-headers=X-Remote-Group
--requestheader-extra-headers-prefix=X-Remote-Extra-
</code></pre><p>e esta requisição:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=display:flex><span><span style=color:#00a000>GET</span> <span style=color:#00f;font-weight:700>/</span> <span style=color:#a2f;font-weight:700>HTTP</span><span style=color:#666>/</span><span style=color:#666>1.1</span>
</span></span><span style=display:flex><span>X-Remote-User<span style=color:#666>:</span> fido
</span></span><span style=display:flex><span>X-Remote-Group<span style=color:#666>:</span> dogs
</span></span><span style=display:flex><span>X-Remote-Group<span style=color:#666>:</span> dachshunds
</span></span><span style=display:flex><span>X-Remote-Extra-Acme.com%2Fproject<span style=color:#666>:</span> some-project
</span></span><span style=display:flex><span>X-Remote-Extra-Scopes<span style=color:#666>:</span> openid
</span></span><span style=display:flex><span>X-Remote-Extra-Scopes<span style=color:#666>:</span> profile
</span></span></code></pre></div><p>resultaria nesta informação de usuário:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fido<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>groups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- dogs<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- dachshunds<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>extra</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>acme.com/project</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span>- some-project<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>scopes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span>- openid<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span>- profile<span style=color:#bbb>
</span></span></span></code></pre></div><p>Para prevenir falsificação de cabeçalhos, o proxy de autenticação deverá apresentar um certificado de cliente válido para o servidor de API para que possa ser validado com a autoridade de certificados (CA) antes que os cabeçalhos de requisições sejam verificados. AVISO: <strong>não</strong> re-utilize uma autoridade de certificados (CA) que esteja sendo utilizado em um contexto diferente ao menos que você entenda os riscos e os mecanismos de proteção da utilização de uma autoridade de certificados.</p><ul><li><p><code>--requestheader-client-ca-file</code> Obrigatório. Pacote de certificados no formato PEM. Um certificado válido deve ser apresentado e validado com a autoridade de certificados no arquivo especificado antes da verificação de cabeçalhos de requisição para os nomes do usuário.</p></li><li><p><code>--requestheader-allowed-names</code> Opcional. Lista de valores de nomes comuns (CNs). Se especificado, um certificado de cliente válido contendo uma lista de nomes comuns denominados deve ser apresentado na verificação de cabeçalhos de requisição para os nomes do usuário. Se vazio, qualquer valor de nomes comuns será permitido.</p></li></ul><h2 id=requisições-anônimas>Requisições anônimas</h2><p>Quando habilitado, requisições que não são rejeitadas por outros métodos de autenticação configurados são tratadas como requisições anônimas e são dadas o nome de usuário <code>system:anonymous</code> e filiação ao grupo <code>system:unauthenticated</code>.</p><p>Por exemplo, uma requisição especificando um <em>bearer token</em> invalido chega a um servidor com token de autenticação configurado e acesso anônimo habilitado e receberia um erro de acesso não autorizado <code>401 Unauthorized</code>. Já uma requisição não especificando nenhum <em>bearer token</em> seria tratada como uma requisição anônima.</p><p>Nas versões 1.5.1-1.5.x, acesso anônimo é desabilitado por padrão e pode ser habilitado passando a opção <code>--anonymous-auth=true</code> durante a inicialização do servidor de API.</p><p>Na versão 1.6 e acima, acesso anônimo é habilitado por padrão se um modo de autorização diferente de <code>AlwaysAllow</code> é utilizado e pode ser desabilitado passando a opção <code>--anonymous-auth=false</code> durante a inicialização do servidor de API.
Começando na versão 1.6, os autorizadores <em>ABAC (Controle de Acesso Baseado em Atributos)</em> e <em>RBAC (Controle de Acesso Baseado em Função)</em> requerem autorização explícita do usuário <code>system:anonymous</code> e do grupo <code>system:unauthenticated</code>, portanto, regras de políticas legadas que permitam acesso a usuário <code>*</code> e grupo <code>*</code> nao incluíram usuários anônimos.</p><h2 id=personificação-de-usuário>Personificação de usuário</h2><p>Um usuário pode agir como outro através de cabeçalhos de personificação. Os mesmos permitem que requisições manualmente sobrescrevam as informações ao quais o usuário irá se autenticar como. Por exemplo, um administrador pode utilizar-se desta funcionalidade para investigar um problema com uma política de autorização e assim, temporariamente, personificar um outro usuário e ver se/como sua requisição está sendo negada.</p><p>Requisições de personificação primeiramente são autenticadas como o usuário requerente, então trocando para os detalhes de informação do usuário personificado.</p><p>O fluxo é:</p><ul><li>Um usuário faz uma chamada de API com suas credenciais <em>e</em> cabeçalhos de personificação.</li><li>O servidor de API autentica o usuário.</li><li>O servidor de API garante que o usuário autenticado possui permissão de personificação.</li><li>Detalhes de informação do usuário da requisição tem seus valores substituídos com os detalhes de personificação.</li><li>A requisição é avaliada e a autorização é feita sobre os detalhes do usuário personificado.</li></ul><p>Os seguintes cabeçalhos HTTP podem ser usados para realizar uma requisição de personificação:</p><ul><li><code>Impersonate-User</code>: O nome do usuário para se executar ações em seu nome.</li><li><code>Impersonate-Group</code>: Um nome de grupo para se executar ações em seu nome. Pode ser especificado múltiplas vezes para fornecer múltiplos grupos. Opcional. Requer "Impersonate-User".</li><li><code>Impersonate-Extra-( extra name )</code>: Um cabeçalho dinâmico usado para associar campos extras do usuário. Opcional. Requer "Impersonate-User". Para que seja preservado consistentemente, <code>( extra name )</code> deve ser somente minúsculo, e qualquer caracter que não seja <a href=https://tools.ietf.org/html/rfc7230#section-3.2.6>legal em rótulos de cabeçalhos HTTP</a> DEVE ser utf8 e <a href=https://tools.ietf.org/html/rfc3986#section-2.1>codificado</a>.</li></ul><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Antes da versão 1.11.3 (e 1.10.7, 1.9.11), <code>( extra name )</code> só poderia conter caracteres que fossem <a href=https://tools.ietf.org/html/rfc7230#section-3.2.6>legais em rótulos de cabeçalhos HTTP</a>.</div><p>Um exemplo de conjunto de cabeçalhos HTTP:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=display:flex><span><span>Impersonate-User: jane.doe@example.com
</span></span></span><span style=display:flex><span><span>Impersonate-Group: developers
</span></span></span><span style=display:flex><span><span>Impersonate-Group: admins
</span></span></span><span style=display:flex><span><span>Impersonate-Extra-dn: cn=jane,ou=engineers,dc=example,dc=com
</span></span></span><span style=display:flex><span><span>Impersonate-Extra-acme.com%2Fproject: some-project
</span></span></span><span style=display:flex><span><span>Impersonate-Extra-scopes: view
</span></span></span><span style=display:flex><span><span>Impersonate-Extra-scopes: development
</span></span></span></code></pre></div><p>Quando utilizando-se o <code>kubectl</code> especifique a opção <code>--as</code> para determinar o cabeçalho <code>Impersonate-User</code>, especifique a opção <code>--as-group</code> para determinar o cabeçalho <code>Impersonate-Group</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl drain mynode
</span></span></code></pre></div><pre tabindex=0><code class=language-none data-lang=none>Error from server (Forbidden): User &#34;clark&#34; cannot get nodes at the cluster scope. (get nodes mynode)
</code></pre><p>Especificando as opções <code>--as</code> e <code>--as-group</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl drain mynode --as<span style=color:#666>=</span>superman --as-group<span style=color:#666>=</span>system:masters
</span></span></code></pre></div><pre tabindex=0><code class=language-none data-lang=none>node/mynode cordoned
node/mynode drained
</code></pre><p>Para personificar um usuário, grupo ou especificar campos extras, o usuário efetuando a personificação deve possuir a permissão de executar o verbo "impersonate" no tipo de atributo sendo personificado ("user", "group", etc.). Para clusters com o plugin de autorização <em>RBAC</em> habilitados, a seguinte ClusterRole abrange as regras necessárias para definir os cabeçalhos de personificação de usuário e grupo:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>impersonator<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;users&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;groups&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;serviceaccounts&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;impersonate&#34;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div><p>Campos extras são avaliados como sub-recursos de um recurso denominado "userextras". Para permitir ao usuário que utilize os cabeçalhos de personificação para o campo extra "scopes", o usuário deve receber a seguinte permissão:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>scopes-impersonator<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># Pode definir o cabeçalho &#34;Impersonate-Extra-scopes&#34;.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;authentication.k8s.io&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;userextras/scopes&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;impersonate&#34;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div><p>Os valores dos cabeçalhos de personificação podem também ser restringidos ao limitar o conjunto de nomes de recursos (<code>resourceNames</code>) que um recurso pode ter.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>limited-impersonator<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># Pode personificar o usuário &#34;jane.doe@example.com&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;users&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;impersonate&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>resourceNames</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;jane.doe@example.com&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> 
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># Pode assumir os grupos &#34;developers&#34; and &#34;admins&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;groups&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;impersonate&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>resourceNames</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;developers&#34;</span>,<span style=color:#b44>&#34;admins&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> 
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># Pode personificar os campos extras &#34;scopes&#34; com valores &#34;view&#34; e &#34;development&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;authentication.k8s.io&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;userextras/scopes&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;impersonate&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>resourceNames</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;view&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;development&#34;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=plugins-de-credenciais-client-go>Plugins de credenciais client-go</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.11 [beta]</code></div><p>Ferramentas como <code>kubectl</code> e <code>kubelet</code> utilizando-se do <code>k8s.io/client-go</code> são capazes de executar um comando externo para receber credenciais de usuário.</p><p>Esta funcionalidade é direcionada à integração do lado cliente, com protocolos de autenticação não suportados nativamente pelo <code>k8s.io/client-go</code> como: LDAP, Kerberos, OAuth2, SAML, etc. O plugin implementa a lógica específica do protocolo e então retorna credenciais opacas para serem utilizadas. Quase todos os casos de usos de plugins de credenciais requerem um componente de lado do servidor com suporte para um <a href=#token-de-autentica%C3%A7%C3%A3o-via-webhook>autenticador de token webhook</a> para interpretar o formato das credenciais produzidas pelo plugin cliente.</p><h3 id=exemplo-de-caso-de-uso>Exemplo de caso de uso</h3><p>Num caso de uso hipotético, uma organização executaria um serviço externo que efetuaria a troca de credenciais LDAP por tokens assinados para um usuário específico. Este serviço seria também capaz de responder requisições do <a href=#token-de-autentica%C3%A7%C3%A3o-via-webhook>autenticador de token webhook</a> para validar tokens. Usuários seriam obrigados a instalar um plugin de credencial em sua estação de trabalho.</p><p>Para autenticar na API:</p><ul><li>O usuário entra um comando <code>kubectl</code>.</li><li>O plugin de credencial solicita ao usuário a entrada de credenciais LDAP e efetua troca das credenciais por um token via um serviço externo.</li><li>O plugin de credenciais retorna um token para o client-go, o qual o utiliza como um bearer token no servidor de API.</li><li>O servidor de API usa o <a href=#token-de-autentica%C3%A7%C3%A3o-via-webhook>autenticador de token webhook</a> para submeter um objeto <code>TokenReview</code> para o serviço externo.</li><li>O serviço externo verifica a assinatura do token e retorna o nome e grupos do usuário.</li></ul><h3 id=configuração>Configuração</h3><p>plugins de credencial são configurados através de <a href=/docs/tasks/access-application-cluster/configure-access-multiple-clusters/>arquivos de configuração do kubectl</a> como parte dos campos de usuário.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>users</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-user<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span><span style=color:green;font-weight:700>exec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:#080;font-style:italic># Comando a ser executado. Obrigatório.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;example-client-go-exec-plugin&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> 
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:#080;font-style:italic># Versão da API a ser utilizada quando decodificar o recurso  ExecCredentials. Obrigatório</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:#080;font-style:italic># A versão da API retornada pelo plugin DEVE ser a mesma versão listada aqui.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:#080;font-style:italic># Para integrar com ferramentas que suportem múltiplas versões (tal como client.authentication.k8s.io/v1alpha1),</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:#080;font-style:italic># defina uma variável de ambiente ou passe um argumento para a ferramenta que indique qual versão o plugin de execução deve esperar.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;client.authentication.k8s.io/v1beta1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> 
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:#080;font-style:italic># Variáveis de ambiente a serem configuradas ao executar o plugin. Opcional</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;FOO&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>       </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;bar&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> 
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:#080;font-style:italic># Argumentos a serem passados ao executar o plugin. Opcional</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span>- <span style=color:#b44>&#34;arg1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span>- <span style=color:#b44>&#34;arg2&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> 
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:#080;font-style:italic># Texto exibido para o usuário quando o executável não parece estar presente. Opcional</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>installHint</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>       </span><span style=color:#bbb>       </span><span style=color:green;font-weight:700>example-client-go-exec-plugin é necessário para autenticar no cluster atual. Pode ser instalado via</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> 
</span></span></span><span style=display:flex><span><span style=color:#bbb>       </span><span style=color:green;font-weight:700>Em macOS</span>:<span style=color:#bbb> </span>brew install example-client-go-exec-plugin<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> 
</span></span></span><span style=display:flex><span><span style=color:#bbb>       </span><span style=color:green;font-weight:700>Em Ubuntu</span>:<span style=color:#bbb> </span>apt-get install example-client-go-exec-plugin<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> 
</span></span></span><span style=display:flex><span><span style=color:#bbb>       </span><span style=color:green;font-weight:700>Em Fedora</span>:<span style=color:#bbb> </span>dnf install example-client-go-exec-plugin<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> 
</span></span></span><span style=display:flex><span><span style=color:#bbb>       </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> 
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:#080;font-style:italic># Deve-se ou não fornecer informações do cluster, que podem potencialmente conter grande quantidade de dados do CA,</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:#080;font-style:italic># para esse plugin de execução como parte da variável de ambiente KUBERNETES_EXEC_INFO</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>provideClusterInfo</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>clusters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-cluster<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span><span style=color:green;font-weight:700>server</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;https://172.17.4.100:6443&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span><span style=color:green;font-weight:700>certificate-authority</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/kubernetes/ca.pem&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span><span style=color:green;font-weight:700>extensions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>client.authentication.k8s.io/exec<span style=color:#bbb> </span><span style=color:#080;font-style:italic># nome de extensão reservado para configuração exclusiva do cluster</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>extension</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>       </span><span style=color:green;font-weight:700>arbitrary</span>:<span style=color:#bbb> </span>config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>       </span><span style=color:green;font-weight:700>this</span>:<span style=color:#bbb> </span>pode ser fornecido através da variável de ambiente KUBERNETES_EXEC_INFO na configuracao de provideClusterInfo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>       </span><span style=color:green;font-weight:700>you</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;coloque&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;qualquer&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;coisa&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;aqui&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>contexts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-cluster<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>context</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span><span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb> </span>my-cluster<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb> </span>my-user<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>current-context</span>:<span style=color:#bbb> </span>my-cluster<span style=color:#bbb>
</span></span></span></code></pre></div><p>Os caminhos relativos do comando são interpretados como relativo ao diretório do arquivo de configuração. Se
KUBECONFIG está configurado para o caminho <code>/home/jane/kubeconfig</code> e o comando executado é <code>./bin/example-client-go-exec-plugin</code>,
o binario <code>/home/jane/bin/example-client-go-exec-plugin</code> será executado.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-user<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span><span style=color:green;font-weight:700>exec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:#080;font-style:italic># Caminho relativo para o diretorio do kubeconfig</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;./bin/example-client-go-exec-plugin&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;client.authentication.k8s.io/v1beta1&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=formatos-de-entrada-e-saída>Formatos de entrada e saída</h3><p>O comando executado imprime um objeto <code>ExecCredential</code> para o <code>stdout</code>. <code>k8s.io/client-go</code>
autentica na API do Kubernetes utilizando as credenciais retornadas no <code>status</code>.</p><p>Quando executando uma sessão interativa, <code>stdin</code> é exposto diretamente para o plugin. plugins devem utilizar
um <a href=https://godoc.org/golang.org/x/crypto/ssh/terminal#IsTerminal>TTY check</a> para determinar se é
apropriado solicitar um usuário interativamente.</p><p>Para usar credenciais do tipo <em>bearer token</em>, o plugin retorna um token no status do objeto <code>ExecCredential</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span> <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;client.authentication.k8s.io/v1beta1&#34;</span>,
</span></span><span style=display:flex><span> <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;ExecCredential&#34;</span>,
</span></span><span style=display:flex><span> <span style=color:green;font-weight:700>&#34;status&#34;</span>: {
</span></span><span style=display:flex><span>   <span style=color:green;font-weight:700>&#34;token&#34;</span>: <span style=color:#b44>&#34;my-bearer-token&#34;</span>
</span></span><span style=display:flex><span> }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Alternativamente, um certificado de cliente e chave codificados em PEM podem ser retornados para serem utilizados em autenticação de cliente TLS.
Se o plugin retornar um certificado e chave diferentes numa chamada subsequente, <code>k8s.io/client-go</code>
Irá fechar conexões existentes com o servidor para forçar uma nova troca TLS.</p><p>Se especificado, <code>clientKeyData</code> e <code>clientCertificateData</code> devem ambos estar presentes.</p><p><code>clientCertificateData</code> pode conter certificados intermediários adicionais a serem enviados para o servidor.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span> <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;client.authentication.k8s.io/v1beta1&#34;</span>,
</span></span><span style=display:flex><span> <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;ExecCredential&#34;</span>,
</span></span><span style=display:flex><span> <span style=color:green;font-weight:700>&#34;status&#34;</span>: {
</span></span><span style=display:flex><span>   <span style=color:green;font-weight:700>&#34;clientCertificateData&#34;</span>: <span style=color:#b44>&#34;-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----&#34;</span>,
</span></span><span style=display:flex><span>   <span style=color:green;font-weight:700>&#34;clientKeyData&#34;</span>: <span style=color:#b44>&#34;-----BEGIN RSA PRIVATE KEY-----\n...\n-----END RSA PRIVATE KEY-----&#34;</span>
</span></span><span style=display:flex><span> }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Opcionalmente, a resposta pode incluir a validade da credencial em formato
RFC3339 de data/hora. A presença ou ausência de validade pode ter o seguinte impacto:</p><ul><li><p>Se uma validade está incluída, o <em>bearer token</em> e as credenciais TLS são guardadas em cache até
a o tempo de expiração é atingido ou se o servidor responder com um codigo de status HTTP 401
ou se o processo terminar.</p></li><li><p>Se uma validate está ausente, o <em>bearer token</em> e as credenciais TLS são guardadas em cache até
o servidor responder com um código de status HTTP 401 ou até o processo terminar.</p></li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span> <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;client.authentication.k8s.io/v1beta1&#34;</span>,
</span></span><span style=display:flex><span> <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;ExecCredential&#34;</span>,
</span></span><span style=display:flex><span> <span style=color:green;font-weight:700>&#34;status&#34;</span>: {
</span></span><span style=display:flex><span>   <span style=color:green;font-weight:700>&#34;token&#34;</span>: <span style=color:#b44>&#34;my-bearer-token&#34;</span>,
</span></span><span style=display:flex><span>   <span style=color:green;font-weight:700>&#34;expirationTimestamp&#34;</span>: <span style=color:#b44>&#34;2018-03-05T17:30:20-08:00&#34;</span>
</span></span><span style=display:flex><span> }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Para habilitar o plugin de execução para obter informações específicas do cluster, define <code>provideClusterInfo</code> no campo <code>user.exec</code>
dentro do arquivo de configuração <a href=/docs/concepts/configuration/organize-cluster-access-kubeconfig/>kubeconfig</a>.
O plugin irá então prover a variável de ambiente <code>KUBERNETES_EXEC_INFO</code>.
As informações desta variável de ambiente podem ser utilizadas para executar lógicas de aquisição
de credentiais específicas do cluster.
O manifesto <code>ExecCredential</code> abaixo descreve um exemplo de informação de cluster.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span> <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;client.authentication.k8s.io/v1beta1&#34;</span>,
</span></span><span style=display:flex><span> <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;ExecCredential&#34;</span>,
</span></span><span style=display:flex><span> <span style=color:green;font-weight:700>&#34;spec&#34;</span>: {
</span></span><span style=display:flex><span>   <span style=color:green;font-weight:700>&#34;cluster&#34;</span>: {
</span></span><span style=display:flex><span>     <span style=color:green;font-weight:700>&#34;server&#34;</span>: <span style=color:#b44>&#34;https://172.17.4.100:6443&#34;</span>,
</span></span><span style=display:flex><span>     <span style=color:green;font-weight:700>&#34;certificate-authority-data&#34;</span>: <span style=color:#b44>&#34;LS0t...&#34;</span>,
</span></span><span style=display:flex><span>     <span style=color:green;font-weight:700>&#34;config&#34;</span>: {
</span></span><span style=display:flex><span>       <span style=color:green;font-weight:700>&#34;arbitrary&#34;</span>: <span style=color:#b44>&#34;config&#34;</span>,
</span></span><span style=display:flex><span>       <span style=color:green;font-weight:700>&#34;this&#34;</span>: <span style=color:#b44>&#34;pode ser fornecido por meio da variável de ambiente KUBERNETES_EXEC_INFO na configuração de provideClusterInfo&#34;</span>,
</span></span><span style=display:flex><span>       <span style=color:green;font-weight:700>&#34;you&#34;</span>: [<span style=color:#b44>&#34;coloque&#34;</span>, <span style=color:#b44>&#34;qualquer&#34;</span>, <span style=color:#b44>&#34;coisa&#34;</span>, <span style=color:#b44>&#34;aqui&#34;</span>]
</span></span><span style=display:flex><span>     }
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span> }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div><div class=td-content style=page-break-before:always><h1 id=pg-de45b6ca7419a0e308044425b2ac52bb>6.3 - Autenticando com Tokens de Inicialização</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.18 [stable]</code></div><p>Os tokens de inicialização são um <em>bearer token</em> simples que devem ser utilizados
ao criar novos clusters ou para quando novos nós são registrados a clusters existentes. Eles foram construídos
para suportar a ferramenta <a href=/docs/reference/setup-tools/kubeadm/>kubeadm</a>, mas podem ser utilizados em outros contextos para usuários que desejam inicializar clusters sem utilizar o <code>kubeadm</code>.
Foram também construídos para funcionar, via políticas RBAC, com o sistema de <a href=/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/>Inicialização do Kubelet via TLS</a>.</p><h2 id=visão-geral-dos-tokens-de-inicialização>Visão geral dos tokens de inicialização</h2><p>Os tokens de inicialização são definidos com um tipo especifico de <em>secrets</em> (<code>bootstrap.kubernetes.io/token</code>) que existem no namespace <code>kube-system</code>. Estes <em>secrets</em> são então lidos pelo autenticador de inicialização do servidor de API.
Tokens expirados são removidos pelo controlador <em>TokenCleaner</em> no gerenciador de controle - kube-controller-manager.
Os tokens também são utilizados para criar uma assinatura para um ConfigMap específico usado no processo de descoberta através de um controlador denominado <code>BootstrapSigner</code>.</p><h2 id=formato-do-token>Formato do Token</h2><p>Tokens de inicialização tem o formato <code>abcdef.0123456789abcdef</code>. Mais formalmente, eles devem corresponder a expressão regular <code>[a-z0-9]{6}\.[a-z0-9]{16}</code>.</p><p>A primeira parte do token é um identificador ("Token ID") e é considerado informação pública.
Ele é utilizado para se referir a um token sem vazar a parte secreta usada para autenticação.
A segunda parte é o <em>secret</em> do token e somente deve ser compartilhado com partes confiáveis.</p><h2 id=habilitando-autenticação-com-tokens-de-inicialização>Habilitando autenticação com tokens de inicialização</h2><p>O autenticador de tokens de inicialização pode ser habilitado utilizando a seguinte opção no servidor de API:</p><pre tabindex=0><code>--enable-bootstrap-token-auth
</code></pre><p>Quando habilitado, tokens de inicialização podem ser utilizado como credenciais <em>bearer token</em>
para autenticar requisições no servidor de API.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=display:flex><span><span>Authorization: Bearer 07401b.f395accd246ae52d
</span></span></span></code></pre></div><p>Tokens são autenticados como o usuário <code>system:bootstrap:&lt;token id></code> e são membros
do grupo <code>system:bootstrappers</code>. Grupos adicionais podem ser
especificados dentro do <em>secret</em> do token.</p><p>Tokens expirados podem ser removidos automaticamente ao habilitar o controlador <code>tokencleaner</code>
do gerenciador de controle - kube-controller-manager.</p><pre tabindex=0><code>--controllers=*,tokencleaner
</code></pre><h2 id=formato-do-secret-dos-tokens-de-inicialização>Formato do <em>secret</em> dos tokens de inicialização</h2><p>Cada token válido possui um <em>secret</em> no namespace <code>kube-system</code>. Você pode
encontrar a documentação completa <a href=https://github.com/kubernetes/design-proposals-archive/blob/main/cluster-lifecycle/bootstrap-discovery.md>aqui</a>.</p><p>Um <em>secret</em> de token se parece com o exemplo abaixo:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># Nome DEVE seguir o formato &#34;bootstrap-token-&lt;token id&gt;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>bootstrap-token-07401b<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> 
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># Tipo DEVE ser &#39;bootstrap.kubernetes.io/token&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>bootstrap.kubernetes.io/token<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>stringData</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># Descrição legível. Opcional.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>description</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;The default bootstrap token generated by &#39;kubeadm init&#39;.&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> 
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># identificador do token e _secret_. Obrigatório.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>token-id</span>:<span style=color:#bbb> </span>07401b<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>token-secret</span>:<span style=color:#bbb> </span>f395accd246ae52d<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> 
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># Validade. Opcional.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>expiration</span>:<span style=color:#bbb> </span>2017-03-10T03:22:11Z<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> 
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># Usos permitidos.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>usage-bootstrap-authentication</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>usage-bootstrap-signing</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> 
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># Grupos adicionais para autenticar o token. Devem começar com &#34;system:bootstrappers:&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>auth-extra-groups</span>:<span style=color:#bbb> </span>system:bootstrappers:worker,system:bootstrappers:ingress<span style=color:#bbb>
</span></span></span></code></pre></div><p>O tipo do <em>secret</em> deve ser <code>bootstrap.kubernetes.io/token</code> e o nome deve seguir o formato <code>bootstrap-token-&lt;token id></code>. Ele também tem que existir no namespace <code>kube-system</code>.</p><p>Os membros listados em <code>usage-bootstrap-*</code> indicam qual a intenção de uso deste <em>secret</em>. O valor <code>true</code> deve ser definido para que seja ativado.</p><ul><li><code>usage-bootstrap-authentication</code> indica que o token pode ser utilizado para autenticar no servidor de API como um <em>bearer token</em>.</li><li><code>usage-bootstrap-signing</code> indica que o token pode ser utilizado para assinar o ConfigMap <code>cluster-info</code> como descrito abaixo.</li></ul><p>O campo <code>expiration</code> controla a expiração do token. Tokens expirados são
rejeitados quando usados para autenticação e ignorados durante assinatura de ConfigMaps.
O valor de expiração é codificado como um tempo absoluto UTC utilizando a RFC3339. Para automaticamente
remover tokens expirados basta habilitar o controlador <code>tokencleaner</code>.</p><h2 id=gerenciamento-de-tokens-com-kubeadm>Gerenciamento de tokens com kubeadm</h2><p>Você pode usar a ferramenta <code>kubeadm</code> para gerenciar tokens em um cluster. Veja <a href=/docs/reference/setup-tools/kubeadm/kubeadm-token/>documentação de tokens kubeadm</a> para mais detalhes.</p><h2 id=assinatura-de-configmap>Assinatura de ConfigMap</h2><p>Além de autenticação, os tokens podem ser utilizados para assinar um ConfigMap. Isto pode
ser utilizado em estágio inicial do processo de inicialização de um cluster, antes que o cliente confie
no servidor de API. O Configmap assinado pode ser autenticado por um token compartilhado.</p><p>Habilite a assinatura de ConfigMap ao habilitar o controlador <code>bootstrapsigner</code> no gerenciador de controle - kube-controller-manager.</p><pre tabindex=0><code>--controllers=*,bootstrapsigner
</code></pre><p>O ConfigMap assinado é o <code>cluster-info</code> no namespace <code>kube-public</code>.
No fluxo típico, um cliente lê o ConfigMap enquanto ainda não autenticado
e ignora os erros da camada de transporte seguro (TLS).
Ele então valida o conteúdo do ConfigMap ao verificar a assinatura contida no ConfigMap.</p><p>O ConfigMap pode se parecer com o exemplo abaixo:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cluster-info<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-public<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>jws-kubeconfig-07401b</span>:<span style=color:#bbb> </span>eyJhbGciOiJIUzI1NiIsImtpZCI6IjA3NDAxYiJ9..tYEfbo6zDNo40MQE07aZcQX2m3EB2rO3NuXtxVMYm9U<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>kubeconfig</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>   apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>   clusters:
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>   - cluster:
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>       certificate-authority-data: &lt;really long certificate data&gt;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>       server: https://10.138.0.2:6443
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>     name: &#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>   contexts: []
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>   current-context: &#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>   kind: Config
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>   preferences: {}
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>   users: []</span><span style=color:#bbb>   
</span></span></span></code></pre></div><p>O membro <code>kubeconfig</code> do ConfigMap é um arquivo de configuração contendo somente
as informações do cluster preenchidas. A informação chave sendo comunicada aqui
está em <code>certificate-authority-data</code>. Isto poderá ser expandido no futuro.</p><p>A assinatura é feita utilizando-se assinatura JWS em modo "separado". Para validar
a assinatura, o usuário deve codificar o conteúdo do <code>kubeconfig</code> de acordo com as regras do JWS
(codificando em base64 e descartando qualquer <code>=</code> ao final). O conteúdo codificado
e então usado para formar um JWS inteiro, inserindo-o entre os 2 pontos. Você pode
verificar o JWS utilizando o esquema <code>HS256</code> (HMAC-SHA256) com o token completo
(por exemplo: <code>07401b.f395accd246ae52d</code>) como o <em>secret</em> compartilhado. Usuários <em>devem</em>
verificar que o algoritmo HS256 (que é um método de assinatura simétrica) está sendo utilizado.</p><div class="alert alert-danger warning callout" role=alert><strong>Aviso:</strong> Qualquer parte em posse de um token de inicialização pode criar uma assinatura válida
daquele token. Não é recomendável, quando utilizando assinatura de ConfigMap, que se compartilhe
o mesmo token com muitos clientes, uma vez que um cliente comprometido pode abrir brecha para potenciais
"homem no meio" entre outro cliente que confia na assinatura para estabelecer inicialização via camada de transporte seguro (TLS).</div><p>Consulte a seção de <a href=/docs/reference/setup-tools/kubeadm/implementation-details/>detalhes de implementação do kubeadm</a> para mais informações.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-82b2fcf985bae77dcb754387a9fcc64f>6.4 - kubeadm init</h1><p>Este comando inicializa um nó da camada de gerenciamento do Kubernetes.</p><p>Rode este comando para configurar a camada de gerenciamento do Kubernetes</p><h3 id=sinopse>Sinopse</h3><p>Rode este comando para configurar a camada de gerenciamento do Kubernetes</p><p>O comando "init" executa as fases abaixo:</p><pre tabindex=0><code>preflight                    Efetua as verificações pré-execução
certs                        Geração de certificados
  /ca                          Gera a autoridade de certificação (CA) auto-assinada do Kubernetes para provisionamento de identidades para outros componentes do Kubernetes
  /apiserver                   Gera o certificado para o servidor da API do Kubernetes
  /apiserver-kubelet-client    Gera o certificado para o servidor da API se conectar ao Kubelet
  /front-proxy-ca              Gera a autoridade de certificação (CA) auto-assinada para provisionamento de identidades para o front proxy
  /front-proxy-client          Gera o certificado para o cliente do front proxy
  /etcd-ca                     Gera a autoridade de certificação (CA) auto-assinada para provisionamento de identidades para o etcd
  /etcd-server                 Gera o certificado para servir o etcd
  /etcd-peer                   Gera o certificado para comunicação entre nós do etcd
  /etcd-healthcheck-client     Gera o certificado para liveness probes fazerem a verificação de integridade do etcd
  /apiserver-etcd-client       Gera o certificado que o servidor da API utiliza para comunicar-se com o etcd
  /sa                          Gera uma chave privada para assinatura de tokens de conta de serviço, juntamente com sua chave pública
kubeconfig                   Gera todos os arquivos kubeconfig necessários para estabelecer a camada de gerenciamento e o arquivo kubeconfig de administração
  /admin                       Gera um arquivo kubeconfig para o administrador e o próprio kubeadm utilizarem
  /kubelet                     Gera um arquivo kubeconfig para o kubelet utilizar *somente* para fins de inicialização do cluster
  /controller-manager          Gera um arquivo kubeconfig para o gerenciador de controladores utilizar
  /scheduler                   Gera um arquivo kubeconfig para o escalonador do Kubernetes utilizar
kubelet-start                Escreve as configurações do kubelet e (re)inicializa o kubelet
control-plane                Gera todos os manifestos de Pods estáticos necessários para estabelecer a camada de gerenciamento
  /apiserver                   Gera o manifesto do Pod estático do kube-apiserver
  /controller-manager          Gera o manifesto do Pod estático do kube-controller-manager
  /scheduler                   Gera o manifesto do Pod estático do kube-scheduler
etcd                         Gera o manifesto do Pod estático para um etcd local
  /local                       Gera o manifesto do Pod estático para uma instância local e de nó único do etcd
upload-config                Sobe a configuração do kubeadm e do kubelet para um ConfigMap
  /kubeadm                     Sobe a configuração ClusterConfiguration do kubeadm para um ConfigMap
  /kubelet                     Sobe a configuração do kubelet para um ConfigMap
upload-certs                 Sobe os certificados para o kubeadm-certs
mark-control-plane           Marca um nó como parte da camada de gerenciamento
bootstrap-token              Gera tokens de autoinicialização utilizados para associar um nó a um cluster
kubelet-finalize             Atualiza configurações relevantes ao kubelet após a inicialização TLS
  /experimental-cert-rotation  Habilita rotação de certificados do cliente do kubelet
addon                        Instala os addons requeridos para passar nos testes de conformidade
  /coredns                     Instala o addon CoreDNS em um cluster Kubernetes
  /kube-proxy                  Instala o addon kube-proxy em um cluster Kubernetes
</code></pre><pre tabindex=0><code>kubeadm init [flags]
</code></pre><h3 id=opções>Opções</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--apiserver-advertise-address string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O endereço IP que o servidor da API irá divulgar que está escutando. Quando não informado, a interface de rede padrão é utilizada.</p></td></tr><tr><td colspan=2>--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: 6443</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Porta para o servidor da API conectar-se.</p></td></tr><tr><td colspan=2>--apiserver-cert-extra-sans strings</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Nomes alternativos (<i>Subject Alternative Names</i>, ou SANs) opcionais a serem adicionados ao certificado utilizado pelo servidor da API. Pode conter endereços IP ou nomes DNS.</p></td></tr><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O caminho para salvar e armazenar certificados.</p></td></tr><tr><td colspan=2>--certificate-key string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Chave utilizada para encriptar os certificados da camada de gerenciamento no Secret kubeadm-certs.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Caminho para um arquivo de configuração do kubeadm.</p></td></tr><tr><td colspan=2>--control-plane-endpoint string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Especifica um endereço IP estável ou nome DNS para a camada de gerenciamento.</p></td></tr><tr><td colspan=2>--cri-socket string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Caminho para o soquete CRI se conectar. Se vazio, o kubeadm tentará autodetectar este valor; utilize esta opção somente se você possui mais que um CRI instalado ou se você possui um soquete CRI fora do padrão.</p></td></tr><tr><td colspan=2>--dry-run</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Não aplica as modificações; apenas imprime as alterações que seriam efetuadas.</p></td></tr><tr><td colspan=2>--feature-gates string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Um conjunto de pares chave=valor que descreve <i>feature gates</i> para várias funcionalidades. As opções são:<br>PublicKeysECDSA=true|false (ALFA - padrão=false)<br>RootlessControlPlane=true|false (ALFA - padrão=false)<br>UnversionedKubeletConfigMap=true|false (BETA - padrão=true)</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>ajuda para init</p></td></tr><tr><td colspan=2>--ignore-preflight-errors strings</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Uma lista de verificações para as quais erros serão exibidos como avisos. Exemplos: 'IsPrivilegedUser,Swap'. O valor 'all' ignora erros de todas as verificações.</p></td></tr><tr><td colspan=2>--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "k8s.gcr.io"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Seleciona um registro de contêineres de onde baixar imagens.</p></td></tr><tr><td colspan=2>--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "stable-1"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Seleciona uma versão do Kubernetes específica para a camada de gerenciamento.</p></td></tr><tr><td colspan=2>--node-name string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Especifica o nome do nó.</p></td></tr><tr><td colspan=2>--patches string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Caminho para um diretório contendo arquivos nomeados no padrão "target[suffix][+patchtype].extension". Por exemplo, "kube-apiserver0+merge.yaml" ou somente "etcd.json".
"target" pode ser um dos seguintes valores: "kube-apiserver", "kube-controller-manager", "kube-scheduler", "etcd".
"patchtype" pode ser "strategic", "merge" ou "json" e corresponde aos formatos de patch suportados pelo kubectl. O valor padrão para "patchtype" é "strategic".
"extension" deve ser "json" ou "yaml". "suffix" é uma string opcional utilizada para determinar quais patches são aplicados primeiro em ordem alfanumérica.</p></td></tr><tr><td colspan=2>--pod-network-cidr string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Especifica um intervalo de endereços IP para a rede do Pod. Quando especificado, a camada de gerenciamento irá automaticamente alocar CIDRs para cada nó.</p></td></tr><tr><td colspan=2>--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "10.96.0.0/12"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Utiliza um intervalo alternativo de endereços IP para VIPs de serviço.</p></td></tr><tr><td colspan=2>--service-dns-domain string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "cluster.local"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Utiliza um domínio alternativo para os serviços. Por exemplo, "myorg.internal".</p></td></tr><tr><td colspan=2>--skip-certificate-key-print</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Não exibe a chave utilizada para encriptar os certificados da camada de gerenciamento.</p></td></tr><tr><td colspan=2>--skip-phases strings</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Lista de fases a serem ignoradas.</p></td></tr><tr><td colspan=2>--skip-token-print</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Pula a impressão do token de autoinicialização padrão gerado pelo comando 'kubeadm init'.</p></td></tr><tr><td colspan=2>--token string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O token a ser utilizado para estabelecer confiança bidirecional entre nós de carga de trabalho e nós da camada de gerenciamento. O formato segue a expressão regular [a-z0-9]{6}.[a-z0-9]{16} - por exemplo, abcdef.0123456789abcdef.</p></td></tr><tr><td colspan=2>--token-ttl duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: 24h0m0s</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>A duração de tempo de um token antes deste ser automaticamente apagado (por exemplo, 1s, 2m, 3h). Quando informado '0', o token não expira.</p></td></tr><tr><td colspan=2>--upload-certs</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Sobe os certificados da camada de gerenciamento para o Secret kubeadm-certs.</p></td></tr></tbody></table><h3 id=opções-herdadas-de-comandos-superiores>Opções herdadas de comandos superiores</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] O caminho para o sistema de arquivos raiz 'real' do host.</p></td></tr></tbody></table><h3 id=init-workflow>Fluxo do comando Init</h3><p>O comando <code>kubeadm init</code> inicializa um nó da camada de gerenciamento do Kubernetes
através da execução dos passos abaixo:</p><ol><li><p>Roda uma série de verificações pré-execução para validar o estado do sistema
antes de efetuar mudanças. Algumas verificações emitem apenas avisos, outras
são consideradas erros e cancelam a execução do kubeadm até que o problema
seja corrigido ou que o usuário especifique a opção
<code>--ignore-preflight-errors=&lt;lista-de-erros-a-ignorar></code>.</p></li><li><p>Gera uma autoridade de certificação (CA) auto-assinada para criar identidades
para cada um dos componentes do cluster. O usuário pode informar seu próprio
certificado CA e/ou chave ao instalar estes arquivos no diretório de
certificados configurado através da opção <code>--cert-dir</code> (por padrão, este
diretório é <code>/etc/kubernetes/pki</code>).
Os certificados do servidor da API terão entradas adicionais para nomes
alternativos (<em>subject alternative names</em>, ou SANs) especificados através da
opção <code>--apiserver-cert-extra-sans</code>. Estes argumentos serão modificados para
caracteres minúsculos quando necessário.</p></li><li><p>Escreve arquivos kubeconfig adicionais no diretório <code>/etc/kubernetes</code> para o
kubelet, para o gerenciador de controladores e para o escalonador utilizarem
ao conectarem-se ao servidor da API, cada um com sua própria identidade, bem
como um arquivo kubeconfig adicional para administração do cluster chamado
<code>admin.conf</code>.</p></li><li><p>Gera manifestos de Pods estáticos para o servidor da API, para o gerenciador
de controladores e para o escalonador. No caso de uma instância externa do
etcd não ter sido providenciada, um manifesto de Pod estático adicional é
gerado para o etcd.</p><p>Manifestos de Pods estáticos são escritos no diretório <code>/etc/kubernetes/manifests</code>;
o kubelet lê este diretório em busca de manifestos de Pods para criar na
inicialização.</p><p>Uma vez que os Pods da camada de gerenciamento estejam criados e rodando,
a sequência de execução do comando <code>kubeadm init</code> pode continuar.</p></li><li><p>Aplica <em>labels</em> e <em>taints</em> ao nó da camada de gerenciamento de modo que cargas
de trabalho adicionais não sejam escalonadas para executar neste nó.</p></li><li><p>Gera o token que nós adicionais podem utilizar para associarem-se a uma
camada de gerenciamento no futuro. Opcionalmente, o usuário pode fornecer um
token através da opção <code>--token</code>, conforme descrito na documentação do
comando <a href=/pt-br/docs/reference/setup-tools/kubeadm/kubeadm-token/>kubeadm token</a>.</p></li><li><p>Prepara todas as configurações necessárias para permitir que nós se associem
ao cluster utilizando os mecanismos de
<a href=/pt-br/docs/reference/access-authn-authz/bootstrap-tokens/>Tokens de Inicialização</a>
e <a href=/docs/reference/access-authn-authz/kubelet-tls-bootstrapping/>Inicialização TLS</a>:</p><ul><li><p>Escreve um ConfigMap para disponibilizar toda a informação necessária para
associar-se a um cluster e para configurar regras de controle de acesso
baseada em funções (RBAC).</p></li><li><p>Permite o acesso dos tokens de inicialização à API de assinaturas CSR.</p></li><li><p>Configura a auto-aprovação de novas requisições CSR.</p></li></ul><p>Para mais informações, consulte
<a href=/docs/reference/setup-tools/kubeadm/kubeadm-join/>kubeadm join</a>.</p></li><li><p>Instala um servidor DNS (CoreDNS) e os componentes adicionais do kube-proxy
através do servidor da API. A partir da versão 1.11 do Kubernetes, CoreDNS é
o servidor DNS padrão. Mesmo que o servidor DNS seja instalado nessa etapa,
o seu Pod não será escalonado até que um CNI seja instalado.</p><div class="alert alert-danger warning callout" role=alert><strong>Aviso:</strong> O uso do kube-dns com o kubeadm foi descontinuado na versão v1.18 e removido
na versão v1.21 do Kubernetes.</div></li></ol><h3 id=init-phases>Utilizando fases de inicialização com o kubeadm</h3><p>O kubeadm permite que você crie um nó da camada de gerenciamento em fases
utilizando o comando <code>kubeadm init phase</code>.</p><p>Para visualizar a lista ordenada de fases e subfases, você pode rodar o comando
<code>kubeadm init --help</code>. A lista estará localizada no topo da ajuda e cada fase
tem sua descrição listada juntamente com o comando. Perceba que ao rodar o
comando <code>kubeadm init</code> todas as fases e subfases são executadas nesta ordem
exata.</p><p>Algumas fases possuem flags específicas. Caso você deseje ver uma lista de todas
as opções disponíveis, utilize a flag <code>--help</code>. Por exemplo:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sudo kubeadm init phase control-plane controller-manager --help
</span></span></code></pre></div><p>Você também pode utilizar a flag <code>--help</code> para ver uma lista de subfases de uma
fase superior:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sudo kubeadm init phase control-plane --help
</span></span></code></pre></div><p><code>kubeadm init</code> também expõe uma flag chamada <code>--skip-phases</code> que pode ser
utilizada para pular a execução de certas fases. Esta flag aceita uma lista de
nomes de fases. Os nomes de fases aceitos estão descritos na lista ordenada
acima.</p><p>Um exemplo:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sudo kubeadm init phase control-plane all --config<span style=color:#666>=</span>configfile.yaml
</span></span><span style=display:flex><span>sudo kubeadm init phase etcd <span style=color:#a2f>local</span> --config<span style=color:#666>=</span>configfile.yaml
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># agora você pode modificar os manifestos da camada de gerenciamento e do etcd</span>
</span></span><span style=display:flex><span>sudo kubeadm init --skip-phases<span style=color:#666>=</span>control-plane,etcd --config<span style=color:#666>=</span>configfile.yaml
</span></span></code></pre></div><p>O que este exemplo faz é escrever os manifestos da camada de gerenciamento e do
etcd no diretório <code>/etc/kubernetes/manifests</code>, baseados na configuração descrita
no arquivo <code>configfile.yaml</code>. Isto permite que você modifique os arquivos e
então pule estas fases utilizando a opção <code>--skip-phases</code>. Ao chamar o último
comando, você cria um nó da camada de gerenciamento com os manifestos
personalizados.</p><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.22 [beta]</code></div><p>Como alternativa, você pode também utilizar o campo <code>skipPhases</code> na configuração
<code>InitConfiguration</code>.</p><h3 id=config-file>Utilizando kubeadm init com um arquivo de configuração</h3><div class="alert alert-warning caution callout" role=alert><strong>Cuidado:</strong> O arquivo de configuração ainda é considerado uma funcionalidade de estado beta
e pode mudar em versões futuras.</div><p>É possível configurar o comando <code>kubeadm init</code> com um arquivo de configuração ao
invés de argumentos de linha de comando, e algumas funcionalidades mais avançadas
podem estar disponíveis apenas como opções do arquivo de configuração. Este
arquivo é fornecido utilizando a opção <code>--config</code> e deve conter uma estrutura
<code>ClusterConfiguration</code> e, opcionalmente, mais estruturas separadas por <code>---\n</code>.
Combinar a opção <code>--config</code> com outras opções de linha de comando pode não ser
permitido em alguns casos.</p><p>A configuração padrão pode ser emitida utilizando o comando
<a href=/pt-br/docs/reference/setup-tools/kubeadm/kubeadm-config/>kubeadm config print</a>.</p><p>Se a sua configuração não estiver utilizando a última versão, é <strong>recomendado</strong>
que você migre utilizando o comando
<a href=/pt-br/docs/reference/setup-tools/kubeadm/kubeadm-config/>kubeadm config migrate</a>.</p><p>Para mais informações sobre os campos e utilização da configuração, você pode
consultar a
<a href=/docs/reference/config-api/kubeadm-config.v1beta3/>página de referência da API</a>.</p><h3 id=feature-gates>Utilizando kubeadm init com <em>feature gates</em></h3><p>O kubeadm suporta um conjunto de <em>feature gates</em> que são exclusivos do kubeadm e
podem ser utilizados somente durante a criação de um cluster com <code>kubeadm init</code>.
Estas funcionalidades podem controlar o comportamento do cluster. Os
<em>feature gates</em> são removidos assim que uma funcionalidade atinge a disponibilidade
geral (<em>general availability</em>, ou GA).</p><p>Para informar um <em>feature gate</em>, você pode utilizar a opção <code>--feature-gates</code>
do comando <code>kubeadm init</code>, ou pode adicioná-las no campo <code>featureGates</code> quando
um <a href=/docs/reference/config-api/kubeadm-config.v1beta3/#kubeadm-k8s-io-v1beta3-ClusterConfiguration>arquivo de configuração</a>
é utilizado através da opção <code>--config</code>.</p><p>A utilização de
<a href=/docs/reference/command-line-tools-reference/feature-gates><em>feature gates</em> dos componentes principais do Kubernetes</a>
com o kubeadm não é suportada. Ao invés disso, é possível enviá-los através da
<a href=/docs/setup/production-environment/tools/kubeadm/control-plane-flags/>personalização de componentes com a API do kubeadm</a>.</p><p>Lista dos <em>feature gates</em>:</p><table><caption style=display:none>_feature gates_ do kubeadm</caption><thead><tr><th style=text-align:left><em>Feature gate</em></th><th style=text-align:left>Valor-padrão</th><th style=text-align:left>Versão Alfa</th><th style=text-align:left>Versão Beta</th></tr></thead><tbody><tr><td style=text-align:left><code>PublicKeysECDSA</code></td><td style=text-align:left><code>false</code></td><td style=text-align:left>1.19</td><td style=text-align:left>-</td></tr><tr><td style=text-align:left><code>RootlessControlPlane</code></td><td style=text-align:left><code>false</code></td><td style=text-align:left>1.22</td><td style=text-align:left>-</td></tr><tr><td style=text-align:left><code>UnversionedKubeletConfigMap</code></td><td style=text-align:left><code>true</code></td><td style=text-align:left>1.22</td><td style=text-align:left>1.23</td></tr></tbody></table><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Assim que um <em>feature gate</em> atinge a disponibilidade geral, ele é removido desta
lista e o seu valor fica bloqueado em <code>true</code> por padrão. Ou seja, a funcionalidade
estará sempre ativa.</div><p>Descrição dos <em>feature gates</em>:</p><dl><dt><code>PublicKeysECDSA</code></dt><dd>Pode ser utilizado para criar um cluster que utilize certificados ECDSA no
lugar do algoritmo RSA padrão. A renovação dos certificados ECDSA existentes
também é suportada utilizando o comando <code>kubeadm certs renew</code>, mas você não pode
alternar entre os algoritmos RSA e ECDSA dinamicamente ou durante atualizações.</dd><dt><code>RootlessControlPlane</code></dt><dd>Quando habilitada esta opção, os componentes da camada de gerenciamento cuja
instalação de Pods estáticos é controlada pelo kubeadm, como o <code>kube-apiserver</code>,
<code>kube-controller-manager</code>, <code>kube-scheduler</code> e <code>etcd</code>, têm seus contêineres
configurados para rodarem como usuários não-root. Se a opção não for habilitada,
estes componentes são executados como root. Você pode alterar o valor deste
<em>feature gate</em> antes de atualizar seu cluster para uma versão mais recente do
Kubernetes.</dd><dt><code>UnversionedKubeletConfigMap</code></dt><dd>Esta opção controla o nome do <a class=glossary-tooltip title='Um objeto da API usado para armazenar dados não-confidenciais em pares chave-valor. Pode ser consumido como variáveis de ambiente, argumentos de linha de comando, ou arquivos de configuração em um volume.' data-toggle=tooltip data-placement=top href=/pt-br/docs/concepts/configuration/configmap target=_blank aria-label=ConfigMap>ConfigMap</a>
onde o kubeadm armazena os dados de configuração do kubelet. Quando esta opção
não for especificada ou estiver especificada com o valor <code>true</code>, o ConfigMap
será nomeado <code>kubelet-config</code>. Caso esteja especificada com o valor <code>false</code>, o
nome do ConfigMap incluirá as versões maior e menor do Kubernetes instalado
(por exemplo, <code>kubelet-config-1.25</code>). O kubeadm garante
que as regras de RBAC para leitura e escrita deste ConfigMap serão apropriadas
para o valor escolhido. Quando o kubeadm cria este ConfigMap (durante a execução
dos comandos <code>kubeadm init</code> ou <code>kubeadm upgrade apply</code>), o kubeadm irá respeitar
o valor da opção <code>UnversionedKubeletConfigMap</code>. Quando tal ConfigMap for lido
(durante a execução dos comandos <code>kubeadm join</code>, <code>kubeadm reset</code>,
<code>kubeadm upgrade...</code>), o kubeadm tentará utilizar o nome do ConfigMap sem a
versão primeiro. Se esta operação não for bem-sucedida, então o kubeadm irá
utilizar o nome legado (versionado) para este ConfigMap.</dd></dl><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Informar a opção <code>UnversionedKubeletConfigMap</code> com o valor <code>false</code> é suportado,
mas está <strong>descontinuado</strong>.</div><h3 id=kube-proxy>Adicionando parâmetros do kube-proxy</h3><p>Para informações sobre como utilizar parâmetros do kube-proxy na configuração
do kubeadm, veja:</p><ul><li><a href=/docs/reference/config-api/kube-proxy-config.v1alpha1/>referência do kube-proxy</a></li></ul><p>Para informações sobre como habilitar o modo IPVS com o kubeadm, veja:</p><ul><li><a href=https://github.com/kubernetes/kubernetes/blob/master/pkg/proxy/ipvs/README.md>IPVS</a></li></ul><h3 id=control-plane-flags>Informando opções personalizadas em componentes da camada de gerenciamento</h3><p>Para informações sobre como passar as opções aos componentes da camada de
gerenciamento, veja:</p><ul><li><a href=/docs/setup/production-environment/tools/kubeadm/control-plane-flags/>opções da camada de gerenciamento</a></li></ul><h3 id=without-internet-connection>Executando o kubeadm sem uma conexão à internet</h3><p>Para executar o kubeadm sem uma conexão à internet, você precisa baixar as imagens
de contêiner requeridas pela camada de gerenciamento.</p><p>Você pode listar e baixar as imagens utilizando o subcomando
<code>kubeadm config images</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubeadm config images list
</span></span><span style=display:flex><span>kubeadm config images pull
</span></span></code></pre></div><p>Você pode passar a opção <code>--config</code> para os comandos acima através de um
<a href=#config-file>arquivo de configuração do kubeadm</a> para controlar os campos
<code>kubernetesVersion</code> e <code>imageRepository</code>.</p><p>Todas as imagens padrão hospedadas em <code>k8s.gcr.io</code> que o kubeadm requer suportam
múltiplas arquiteturas.</p><h3 id=custom-images>Utilizando imagens personalizadas</h3><p>Por padrão, o kubeadm baixa imagens hospedadas no repositório de contêineres
<code>k8s.gcr.io</code>. Se a versão requisitada do Kubernetes é um rótulo de integração
contínua (por exemplo, <code>ci/latest</code>), o repositório de contêineres
<code>gcr.io/k8s-staging-ci-images</code> é utilizado.</p><p>Você pode sobrescrever este comportamento utilizando o
<a href=#config-file>kubeadm com um arquivo de configuração</a>. Personalizações permitidas
são:</p><ul><li>Fornecer um valor para o campo <code>kubernetesVersion</code> que afeta a versão das
imagens.</li><li>Fornecer um repositório de contêineres alternativo através do campo
<code>imageRepository</code> para ser utilizado no lugar de <code>k8s.gcr.io</code>.</li><li>Fornecer um valor específico para os campos <code>imageRepository</code> e <code>imageTag</code>,
correspondendo ao repositório de contêineres e tag a ser utilizada, para as imagens
dos componentes etcd ou CoreDNS.</li></ul><p>Caminhos de imagens do repositório de contêineres padrão <code>k8s.gcr.io</code> podem diferir
dos utilizados em repositórios de contêineres personalizados através do campo
<code>imageRepository</code> devido a razões de retrocompatibilidade. Por exemplo, uma
imagem pode ter um subcaminho em <code>k8s.gcr.io/subcaminho/imagem</code>, mas quando
utilizado um repositório de contêineres personalizado, o valor padrão será
<code>meu.repositoriopersonalizado.io/imagem</code>.</p><p>Para garantir que você terá as imagens no seu repositório personalizado em
caminhos que o kubeadm consiga consumir, você deve:</p><ul><li>Baixar as imagens dos caminhos padrão <code>k8s.gcr.io</code> utilizando o comando
<code>kubeadm config images {list|pull}</code>.</li><li>Subir as imagens para os caminhos listados no resultado do comando
<code>kubeadm config images list --config=config.yaml</code>, onde <code>config.yaml</code> contém
o valor customizado do campo <code>imageRepository</code>, e/ou <code>imageTag</code> para os
componentes etcd e CoreDNS.</li><li>Utilizar o mesmo arquivo <code>config.yaml</code> quando executar o comando <code>kubeadm init</code>.</li></ul><h4 id=custom-pause-image>Imagens personalizadas para o <em>sandbox</em> (imagem <code>pause</code>)</h4><p>Para configurar uma imagem personalizada para o <em>sandbox</em>, você precisará
configurar o <a class=glossary-tooltip title='O agente de execução de contêiner é o software responsável por executar os contêineres.' data-toggle=tooltip data-placement=top href=/docs/setup/production-environment/container-runtimes target=_blank aria-label='agente de execução de contêineres'>agente de execução de contêineres</a>
para utilizar a imagem.
Verifique a documentação para o seu agente de execução de contêineres para
mais informações sobre como modificar esta configuração; para alguns agentes de
execução de contêiner você também encontrará informações no tópico
<a href=/docs/setup/production-environment/container-runtimes/>Agentes de Execução de Contêineres</a>.</p><h3 id=carregando-certificados-da-camada-de-gerenciamento-no-cluster>Carregando certificados da camada de gerenciamento no cluster</h3><p>Ao adicionar a opção <code>--upload-certs</code> ao comando <code>kubeadm init</code> você pode
subir temporariamente certificados da camada de gerenciamento em um Secret no
cluster. Este Secret expira automaticamente após 2 horas. Os certificados são
encriptados utilizando uma chave de 32 bytes que pode ser especificada através
da opção <code>--certificate-key</code>. A mesma chave pode ser utilizada para baixar
certificados quando nós adicionais da camada de gerenciamento estão se associando
ao cluster, utilizando as opções <code>--control-plane</code> e <code>--certificate-key</code> ao rodar
<code>kubeadm join</code>.</p><p>O seguinte comando de fase pode ser usado para subir os certificados novamente
após a sua expiração:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubeadm init phase upload-certs --upload-certs --certificate-key<span style=color:#666>=</span>ALGUM_VALOR --config<span style=color:#666>=</span>ALGUM_ARQUIVO_YAML
</span></span></code></pre></div><p>Se a opção <code>--certificate-key</code> não for passada aos comandos <code>kubeadm init</code>
e <code>kubeadm init phase upload-certs</code>, uma nova chave será gerada automaticamente.</p><p>O comando abaixo pode ser utilizado para gerar uma nova chave sob demanda:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubeadm certs certificate-key
</span></span></code></pre></div><h3 id=gerenciamento-de-certificados-com-o-kubeadm>Gerenciamento de certificados com o kubeadm</h3><p>Para informações detalhadas sobre gerenciamento de certificados com o kubeadm,
consulte <a href=/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/>Gerenciamento de Certificados com o kubeadm</a>.
O documento inclui informações sobre a utilização de autoridades de certificação
(CA) externas, certificados personalizados e renovação de certificados.</p><h3 id=kubelet-drop-in>Gerenciando o arquivo <em>drop-in</em> do kubeadm para o kubelet</h3><p>O pacote <code>kubeadm</code> é distribuído com um arquivo de configuração para rodar o
<code>kubelet</code> utilizando <code>systemd</code>. Note que o kubeadm nunca altera este arquivo.
Este arquivo <em>drop-in</em> é parte do pacote DEB/RPM do kubeadm.</p><p>Para mais informações, consulte
<a href=/docs/setup/production-environment/tools/kubeadm/kubelet-integration/#the-kubelet-drop-in-file-for-systemd>Gerenciando o arquivo drop-in do kubeadm para o systemd</a>.</p><h3 id=usando-o-kubeadm-com-agentes-de-execução-cri>Usando o kubeadm com agentes de execução CRI</h3><p>Por padrão, o kubeadm tenta detectar seu agente de execução de contêineres. Para
mais detalhes sobre esta detecção, consulte o
<a href=/pt-br/docs/setup/production-environment/tools/kubeadm/install-kubeadm/#instalando-agente-de-execucao>guia de instalação CRI do kubeadm</a>.</p><h3 id=configurando-o-nome-do-nó>Configurando o nome do nó</h3><p>Por padrão, o <code>kubeadm</code> gera um nome para o nó baseado no endereço da máquina.
Você pode sobrescrever esta configuração utilizando a opção <code>--node-name</code>. Esta
opção passa o valor apropriado para a opção <a href=/docs/reference/command-line-tools-reference/kubelet/#options><code>--hostname-override</code></a>
do kubelet.</p><p>Note que sobrescrever o hostname de um nó pode
<a href=https://github.com/kubernetes/website/pull/8873>interferir com provedores de nuvem</a>.</p><h3 id=automatizando-o-kubeadm>Automatizando o kubeadm</h3><p>Ao invés de copiar o token que você obteve do comando <code>kubeadm init</code> para cada nó,
como descrito no <a href=/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/>tutorial básico do kubeadm</a>,
você pode paralelizar a distribuição do token para facilitar a automação.
Para implementar esta automação, você precisa saber o endereço IP que o nó da
camada de gerenciamento irá ter após a sua inicialização, ou utilizar um nome
DNS ou um endereço de um balanceador de carga.</p><ol><li><p>Gere um token. Este token deve ter a forma <code>&lt;string de 6 caracteres>.&lt;string de 16 caracteres></code>.
Mais especificamente, o token precisa ser compatível com a expressão regular:
<code>[a-z0-9]{6}\.[a-z0-9]{16}</code>.</p><p>O kubeadm pode gerar um token para você:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span> kubeadm token generate
</span></span></code></pre></div></li><li><p>Inicialize o nó da camada de gerenciamento e os nós de carga de trabalho de
forma concorrente com este token. Conforme os nós forem iniciando, eles
deverão encontrar uns aos outros e formar o cluster. O mesmo argumento
<code>--token</code> pode ser utilizado em ambos os comandos <code>kubeadm init</code> e
<code>kubeadm join</code>.</p></li><li><p>O mesmo procedimento pode ser feito para a opção <code>--certificate-key</code> quando
nós adicionais da camada de gerenciamento associarem-se ao cluster. A chave
pode ser gerada utilizando:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubeadm certs certificate-key
</span></span></code></pre></div></li></ol><p>Uma vez que o cluster esteja inicializado, você pode buscar as credenciais para
a camada de gerenciamento no caminho <code>/etc/kubernetes/admin.conf</code> e utilizá-las
para conectar-se ao cluster.</p><p>Note que este tipo de inicialização tem algumas garantias de segurança relaxadas
pois ele não permite que o hash do CA raiz seja validado com a opção
<code>--discovery-token-ca-cert-hash</code> (pois este hash não é gerado quando os nós são
provisionados). Para detalhes, veja a documentação do comando
<a href=/docs/reference/setup-tools/kubeadm/kubeadm-join/>kubeadm join</a>.</p><h2 id=próximos-passos>Próximos passos</h2><ul><li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-init-phase/>kubeadm init phase</a>
para entender mais sobre as fases do comando <code>kubeadm init</code></li><li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-join/>kubeadm join</a> para
inicializar um nó de carga de trabalho do Kubernetes e associá-lo ao cluster</li><li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-upgrade/>kubeadm upgrade</a>
para atualizar um cluster do Kubernetes para uma versão mais recente</li><li><a href=/pt-br/docs/reference/setup-tools/kubeadm/kubeadm-reset/>kubeadm reset</a>
para reverter quaisquer mudanças feitas neste host pelos comandos
<code>kubeadm init</code> ou <code>kubeadm join</code></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-5042dc49c5348b3674d3878f37f7670b>6.5 - kubeadm config</h1><p>Durante o <code>kubeadm init</code>, o kubeadm carrega o objeto <code>ClusterConfiguration</code> para o seu cluster em um ConfigMap chamado <code>kubeadm-config</code> no namespace do <code>kube-system</code>. Essa configuração é então lida durante <code>kubeadm join</code>, <code>kubeadm reset</code> e <code>kubeadm upgrade</code>.</p><p>Você pode usar o <code>kubeadm config print</code> para exibir a configuração estática padrão que o kubeadm usa para o <code>kubeadm init</code> e <code>kubeadm join</code>.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> A saída do comando deve servir de exemplo. Você deve editar manualmente a saída deste comando para adaptar à sua configuração. Remova os campos sobre os quais você não tem certeza e o kubeadm tentará usá-los como padrão, examinando o host durante a execução.</div><p>Para obter mais informações sobre <code>init</code> e <code>join</code>, navegue até <a href=/docs/reference/setup-tools/kubeadm/kubeadm-init/#config-file>Usando o kubeadm init com um arquivo de configuração</a> ou <a href=/docs/reference/setup-tools/kubeadm/kubeadm-join/#config-file>Usando o kubeadm join com um arquivo de configuração</a>.</p><p>Para obter mais informações sobre como usar a API de configuração do kubeadm, navegue até <a href=/docs/setup/production-environment/tools/kubeadm/control-plane-flags>Personalizando componentes com a API do kubeadm.</a>.</p><p>Você pode usar o <code>kubeadm config migrate</code> para converter seus arquivos de configuração antigos que contêm uma versão obsoleta da API para uma versão mais recente e suportada da API.</p><p><code>kubeadm config images list</code> e <code>kubeadm config images pull</code> podem ser usadas para listar e baixar as imagens que o kubeadm precisa.</p><h2 id=cmd-config-print>kubeadm config print</h2><p>Exibe configurações</p><h3 id=sinopse>Sinopse</h3><p>Este comando exibe as configurações para subcomandos fornecidos.
Para mais detalhes, consulte: <a href=https://pkg.go.dev/k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm#section-directories>https://pkg.go.dev/k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm#section-directories</a></p><pre tabindex=0><code>kubeadm config print [flags]
</code></pre><h3 id=opções>Opções</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>ajuda para print</p></td></tr></tbody></table><h3 id=opções-herdadas-do-comando-superior>Opções herdadas do comando superior</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O arquivo kubeconfig a ser usado para se comunicar com o cluster. Se a flag não estiver definida, um conjunto de locais predefinidos pode ser pesquisado por um arquivo kubeconfig existente.</p></td></tr><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] O caminho para o 'real' sistema de arquivos raiz do host.</p></td></tr></tbody></table><h2 id=cmd-config-print-init-defaults>kubeadm config print init-defaults</h2><p>Exibe a configuração de inicialização padrão, que pode ser usada para 'kubeadm init'</p><h3 id=sinopse>Sinopse</h3><p>Este comando exibe objetos, como a configuração de inicialização padrão que é usada para 'kubeadm init'.</p><p>Observe que os valores confidenciais, como os campos do Token Bootstrap, são substituídos por valores de exemplo como "abcdef.0123456789abcdef", a fim de passar na validação, mas não executar o cálculo real para criar um token.</p><pre tabindex=0><code>kubeadm config print init-defaults [flags]
</code></pre><h3 id=opções>Opções</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--component-configs strings</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Uma lista dos objetos da API de configuração, separados por vírgulas, exibirá os valores padrão. Valores disponíveis: [KubeProxyConfiguration KubeletConfiguration]. Se essa flag não estiver definida, nenhuma configuração de componente será impressa.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>ajuda para init-defaults</p></td></tr></tbody></table><h3 id=opções-herdadas-do-comando-superior>Opções herdadas do comando superior</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O arquivo kubeconfig a ser usado para se comunicar com o cluster. Se a flag não estiver definida, um conjunto de locais predefinidos pode ser pesquisado por um arquivo kubeconfig existente.</p></td></tr><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] O caminho para o 'real' sistema de arquivos raiz do host.</p></td></tr></tbody></table><h2 id=cmd-config-print-join-defaults>kubeadm config print join-defaults</h2><p>Exibe a configuração padrão do join, que pode ser usada para 'kubeadm join'</p><h3 id=sinopse>Sinopse</h3><p>Este comando exibe objetos como a configuração padrão de join que é usada para 'kubeadm join'.</p><p>Observe que valores confidenciais, como os campos do Token Bootstrap, são substituídos por valores de exemplo como "abcdef.0123456789abcdef", a fim de passar na validação, mas não executar o cálculo real para criar um token.</p><pre tabindex=0><code>kubeadm config print join-defaults [flags]
</code></pre><h3 id=opções>Opções</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--component-configs strings</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Uma lista dos objetos da API de configuração, separados por vírgulas, exibirá os valores padrão. Valores disponíveis: [KubeProxyConfiguration KubeletConfiguration]. Se essa flag não estiver definida, nenhuma configuração de componente será impressa.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>ajuda para join-defaults</p></td></tr></tbody></table><h3 id=opções-herdadas-do-comando-superior>Opções herdadas do comando superior</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O arquivo kubeconfig a ser usado para se comunicar com o cluster. Se a flag não estiver definida, um conjunto de locais predefinidos pode ser pesquisado por um arquivo kubeconfig existente.</p></td></tr><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] O caminho para o 'real' sistema de arquivos raiz do host.</p></td></tr></tbody></table><h2 id=cmd-config-migrate>kubeadm config migrate</h2><p>Leia uma versão mais antiga dos tipos de API de configuração do kubeadm a partir de um arquivo e envie o objeto de configuração semelhante para a versão mais recente</p><h3 id=sinopse>Sinopse</h3><p>Esse comando permite converter objetos de configuração de versões mais antigas para a versão mais recente suportada, localmente na ferramenta CLI sem nunca tocar em nada no cluster. Nesta versão do kubeadm, as seguintes versões da API são suportadas:</p><ul><li>Kubeadm.k8s.io/v1beta3</li></ul><p>Além disso, o kubeadm só pode escrever a configuração da versão "kubeadm.k8s.io/v1beta3", mas pode ler os dois tipos. Portanto, independentemente da versão que você passar para o parâmetro --old-config , o objeto API será lido, desserializado, padronizado, convertido, validado e serializado novamente quando escrito no stdout ou --new-config, se especificado.</p><p>Em outras palavras, a saída deste comando é o que o kubeadm realmente leria internamente se você enviasse este arquivo para "kubeadm init"</p><pre tabindex=0><code>kubeadm config migrate [flags]
</code></pre><h3 id=opções>Opções</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>ajuda para migrate</p></td></tr><tr><td colspan=2>--new-config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Caminho para o arquivo de configuração kubeadm equivalente usando a nova versão da API. Opcional, se não for especificado, a saída será enviada para o STDOUT.</p></td></tr><tr><td colspan=2>--old-config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Caminho para o arquivo de configuração do kubeadm que está usando uma versão antiga da API e que deve ser convertido. Essa flag é obrigatória.</p></td></tr></tbody></table><h3 id=opções-herdadas-do-comando-superior>Opções herdadas do comando superior</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O arquivo kubeconfig a ser usado para se comunicar com o cluster. Se a flag não estiver definida, um conjunto de locais predefinidos pode ser pesquisado por um arquivo kubeconfig existente.</p></td></tr><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] O caminho para o 'real' sistema de arquivos raiz do host.</p></td></tr></tbody></table><h2 id=cmd-config-images-list>kubeadm config images list</h2><p>Exibe uma lista de imagens que o kubeadm usará. O arquivo de configuração é usado caso quaisquer imagens ou repositórios de imagens sejam personalizados.</p><h3 id=sinopse>Sinopse</h3><p>Exibe uma lista de imagens que o kubeadm usará. O arquivo de configuração é usado caso quaisquer imagens ou repositórios de imagens sejam personalizados.</p><pre tabindex=0><code>kubeadm config images list [flags]
</code></pre><h3 id=opções>Opções</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--allow-missing-template-keys&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: true</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Se verdadeiro (true), ignore quaisquer erros nos modelos quando um campo ou chave de mapa estiver faltando no modelo. Aplica-se apenas aos formatos de saída golang e jsonpath.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Caminho para um arquivo de configuração kubeadm.</p></td></tr><tr><td colspan=2>-o, --experimental-output string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "text"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Formato de saída. Valores válidos: text|json|yaml|go-template|go-template-file|template|templatefile|jsonpath|jsonpath-as-json|jsonpath-file.</p></td></tr><tr><td colspan=2>--feature-gates string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Um conjunto de pares chave=valor que descrevem opções para vários recursos. As opções são:<br>PublicKeysECDSA=true|false (ALPHA - padrão=false)<br>RootlessControlPlane=true|false (ALPHA - padrão=false)<br>UnversionedKubeletConfigMap=true|false (ALPHA - padrão=false)</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>ajuda para list</p></td></tr><tr><td colspan=2>--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "k8s.gcr.io"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Escolha um registro de contêineres para baixar imagens da camada de gerenciamento</p></td></tr><tr><td colspan=2>--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "stable-1"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Escolha uma versão específica do Kubernetes para a camada de gerenciamento.</p></td></tr><tr><td colspan=2>--show-managed-fields</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Se verdadeiro, mantém os managedFields ao exibir os objetos no formato JSON ou YAML.</p></td></tr></tbody></table><h3 id=opções-herdadas-do-comando-superior>Opções herdadas do comando superior</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O arquivo kubeconfig a ser usado para se comunicar com o cluster. Se a flag não estiver definida, um conjunto de locais predefinidos pode ser pesquisado por um arquivo kubeconfig existente.</p></td></tr><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] O caminho para o 'real' sistema de arquivos raiz do host.</p></td></tr></tbody></table><h2 id=cmd-config-images-pull>kubeadm config images pull</h2><p>Puxe imagens usadas pelo kubeadm</p><h3 id=sinopse>Sinopse</h3><p>Baixa imagens usadas pelo kubeadm</p><pre tabindex=0><code>kubeadm config images pull [flags]
</code></pre><h3 id=opções>Opções</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Caminho para um arquivo de configuração kubeadm.</p></td></tr><tr><td colspan=2>--cri-socket string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Caminho para se conectar ao socket CRI. Se vazio, o kubeadm tentará detectar automaticamente esse valor; use essa opção somente se você tiver mais de um CRI instalado ou se tiver um socket CRI não padrão.</p></td></tr><tr><td colspan=2>--feature-gates string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Um conjunto de pares chave=valor que descrevem feature gates para vários recursos. As opções são:<br>PublicKeysECDSA=true|false (ALPHA - padrão=false)<br>RootlessControlPlane=true|false (ALPHA - padrão=false)<br>UnversionedKubeletConfigMap=true|false (ALPHA - padrão=false)</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>ajuda para pull</p></td></tr><tr><td colspan=2>--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "k8s.gcr.io"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Escolha um registro de contêineres para baixar imagens da camada de gerenciamento</p></td></tr><tr><td colspan=2>--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "stable-1"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Escolha uma versão específica do Kubernetes para a camada de gerenciamento.</p></td></tr></tbody></table><h3 id=opções-herdadas-do-comando-superior>Opções herdadas do comando superior</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O arquivo kubeconfig a ser usado para se comunicar com o cluster. Se a flag não estiver definida, um conjunto de locais predefinidos pode ser pesquisado por um arquivo kubeconfig existente.</p></td></tr><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] O caminho para o 'real' sistema de arquivos raiz do host.</p></td></tr></tbody></table><h2 id=próximos-passos>Próximos passos</h2><ul><li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-upgrade>kubeadm upgrade</a> para atualizar um cluster Kubernetes para uma versão mais recente</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-df8ff2190764e70c3de2015e2cb46b14>6.6 - Portas e protocolos</h1><p>Quando o Kubernetes está sendo executado em um ambiente com uma rede mais restritiva,
como por exemplo um data center on-premises com firewalls de rede físicos ou redes virtuais em nuvens públicas,
é útil saber quais portas e protocolos são utilizados pelos componentes do Kubernetes.</p><h2 id=camada-de-gerenciamento>Camada de gerenciamento</h2><table><thead><tr><th>Protocolo</th><th>Direção</th><th>Intervalo de Portas</th><th>Propósito</th><th>Utilizado por</th></tr></thead><tbody><tr><td>TCP</td><td>Entrada</td><td>6443</td><td>Servidor da API do Kubernetes</td><td>Todos</td></tr><tr><td>TCP</td><td>Entrada</td><td>2379-2380</td><td>API servidor-cliente do etcd</td><td>kube-apiserver, etcd</td></tr><tr><td>TCP</td><td>Entrada</td><td>10250</td><td>API do kubelet</td><td>kubeadm, Camada de gerenciamento</td></tr><tr><td>TCP</td><td>Entrada</td><td>10259</td><td>kube-scheduler</td><td>kubeadm</td></tr><tr><td>TCP</td><td>Entrada</td><td>10257</td><td>kube-controller-manager</td><td>kubeadm</td></tr></tbody></table><p>Embora as portas do etcd estejam inclusas na seção da Camada de gerenciamento, você também
pode hospedar o seu próprio cluster etcd externamente ou em portas customizadas.</p><h2 id=node>Nós de processamento</h2><table><thead><tr><th>Protocolo</th><th>Direção</th><th>Intervalo de Portas</th><th>Propósito</th><th>Utilizado por</th></tr></thead><tbody><tr><td>TCP</td><td>Entrada</td><td>10250</td><td>API do Kubelet</td><td>O próprio, Camada de gerenciamento</td></tr><tr><td>TCP</td><td>Entrada</td><td>30000-32767</td><td>Serviços NodePort†</td><td>Todos</td></tr></tbody></table><p>† Intervalo padrão de portas para os <a href=/docs/concepts/services-networking/service/>serviços NodePort</a>.</p><p>Todas as portas padrão podem ser sobrescritas. Quando portas customizadas são utilizadas, essas portas
precisam estar abertas, ao invés das mencionadas aqui.</p><p>Um exemplo comum é a porta do servidor da API, que as vezes é trocado para a porta 433.
Com isso, a porta padrão é mantida e o servidor da API é colocado atrás de um balanceador de carga
que escuta na porta 433 e faz o roteamento das requisições para o servidor da API na porta padrão.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-6eb5bc1e7114609930a76c683cc27c2b>6.7 - kubeadm reset</h1><p>Executa o melhor esforço para reverter as alterações feitas pelo <code>kubeadm init</code> ou <code>kubeadm join</code>.</p><p>Executa o melhor esforço para reverter as alterações feitas no host por 'kubeadm init' ou 'kubeadm join'</p><h3 id=sinopse>Sinopse</h3><p>Executa o melhor esforço para reverter as alterações feitas no host por 'kubeadm init' ou 'kubeadm join'</p><p>O comando "reset" executa as seguintes fases:</p><pre tabindex=0><code>preflight           Executa as verificações pré-execução do preflight.
remove-etcd-member  Remove um membro etcd local.
cleanup-node        Executa a limpeza do nó.
</code></pre><pre tabindex=0><code>kubeadm reset [flags]
</code></pre><h3 id=opções>Opções</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O caminho para o diretório onde os certificados estão armazenados. Se especificado, limpe este diretório.</p></td></tr><tr><td colspan=2>--cri-socket string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Caminho para o socket CRI se conectar. Se vazio, o kubeadm tentará detectar automaticamente esse valor; use essa opção somente se você tiver mais de um CRI instalado ou se tiver um socket CRI não padrão.</p></td></tr><tr><td colspan=2>-f, --force</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Redefine o nó sem solicitar confirmação..</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>ajuda para reset</p></td></tr><tr><td colspan=2>--ignore-preflight-errors strings</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Uma lista de verificações cujos erros serão mostrados como avisos. Exemplo: 'IsPrivilegedUser,Swap'. O valor 'all' ignora erros de todas as verificações.</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O arquivo kubeconfig a ser usado para se comunicar com o cluster. Se a flag não estiver definida, um conjunto de locais predefinidos pode ser pesquisado por um arquivo kubeconfig existente.</p></td></tr><tr><td colspan=2>--skip-phases strings</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Lista de fases a serem ignoradas</p></td></tr></tbody></table><h3 id=opções-herdadas-do-comando-superior>Opções herdadas do comando superior</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] O caminho para o 'real' sistema de arquivos raiz do host.</p></td></tr></tbody></table><h3 id=reset-workflow>Fluxo de execução do comando <code>reset</code></h3><p>O <code>kubeadm reset</code> é o responsável por limpar o sistema de arquivos local dos nós a partir dos arquivos que foram criados usando os comandos <code>kubeadm init</code> ou <code>kubeadm join</code>. O <code>reset</code> dos nós da camanda de gerenciamento também remove o etcd local do nó do cluster etcd.</p><p>O <code>kubeadm reset phase</code> pode ser usado para executar separadamente as fases do fluxo de trabalho acima. Para pular uma lista de fases você pode usar <code>--skip-phases</code>, que funciona de maneira semelhante aos executores de fases dos comandos <code>kubeadm join</code> e <code>kubeadm init</code>.</p><h3 id=limpeza-do-etcd-externo>Limpeza do etcd externo</h3><p>O <code>kubeadm reset</code> não excluirá nenhum dado do etcd se o etcd externo estiver em uso. Isso significa que, se você executar o <code>kubeadm init</code> novamente usando os mesmos etcd endpoints, verá o estado dos clusters anteriores.</p><p>Para limpar dados etcd, é recomendável que você use um cliente como etcdctl, tal como:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>etcdctl del <span style=color:#b44>&#34;&#34;</span> --prefix
</span></span></code></pre></div><p>Consulte a <a href=https://github.com/coreos/etcd/tree/master/etcdctl>documentação do etcd</a> para obter mais informações.</p><h2 id=próximos-passos>Próximos passos</h2><ul><li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-init>kubeadm init</a> para inicializar um nó do plano de controle do Kubernetes</li><li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-join>kubeadm join</a> para inicializar um nó de carga de trabalho do Kubernetes e associá-lo ao cluster</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-03460a7254c6c73eb2a1bb3dd7d25910>6.8 - kubectl CLI</h1></div><div class=td-content><h1 id=pg-8aba901ac13f124e5782b90ddb166ee2>6.8.1 - kubectl Cheat Sheet</h1><p>Veja também: <a href=/docs/reference/kubectl/overview/>Visão geral do Kubectl</a> e <a href=/docs/reference/kubectl/jsonpath>JsonPath Guide</a>.</p><p>Esta página é uma visão geral do comando <code>kubectl</code>.</p><h1 id=kubectl-cheat-sheet>kubectl - Cheat Sheet</h1><h2 id=kubectl-autocomplete>Kubectl Autocomplete</h2><h3 id=bash>BASH</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#a2f>source</span> &lt;<span style=color:#666>(</span>kubectl completion bash<span style=color:#666>)</span> <span style=color:#080;font-style:italic># configuração de autocomplete no bash do shell atual, o pacote bash-completion precisa ter sido instalado primeiro.</span>
</span></span><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b44>&#34;source &lt;(kubectl completion bash)&#34;</span> &gt;&gt; ~/.bashrc <span style=color:#080;font-style:italic># para adicionar o autocomplete permanentemente no seu shell bash.</span>
</span></span></code></pre></div><p>Você também pode usar uma abreviação para o atalho para <code>kubectl</code> que também funciona com o auto completar:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#a2f>alias</span> <span style=color:#b8860b>k</span><span style=color:#666>=</span>kubectl
</span></span><span style=display:flex><span><span style=color:#a2f>complete</span> -F __start_kubectl k
</span></span></code></pre></div><h3 id=zsh>ZSH</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#a2f>source</span> &lt;<span style=color:#666>(</span>kubectl completion zsh<span style=color:#666>)</span>  <span style=color:#080;font-style:italic># configuração para usar autocomplete no terminal zsh no shell atual</span>
</span></span><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b44>&#34;if [ </span><span style=color:#b8860b>$commands</span><span style=color:#b44>[kubectl] ]; then source &lt;(kubectl completion zsh); fi&#34;</span> &gt;&gt; ~/.zshrc <span style=color:#080;font-style:italic># adicionar auto completar permanentemente para o seu shell zsh</span>
</span></span></code></pre></div><h2 id=contexto-e-configuração-do-kubectl>Contexto e Configuração do Kubectl</h2><p>Defina com qual cluster Kubernetes o <code>kubectl</code> se comunica e modifique os detalhes da configuração.
Veja a documentação <a href=/docs/tasks/access-application-cluster/configure-access-multiple-clusters/>Autenticando entre clusters com o kubeconfig</a> para
informações detalhadas do arquivo de configuração.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl config view <span style=color:#080;font-style:italic># Mostrar configurações do kubeconfig mergeadas.</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># use vários arquivos kubeconfig ao mesmo tempo e visualize a configuração mergeada</span>
</span></span><span style=display:flex><span><span style=color:#b8860b>KUBECONFIG</span><span style=color:#666>=</span>~/.kube/config:~/.kube/kubconfig2 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl config view
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># obtenha a senha para o usuário e2e</span>
</span></span><span style=display:flex><span>kubectl config view -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.users[?(@.name == &#34;e2e&#34;)].user.password}&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl config view -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.users[].name}&#39;</span>    <span style=color:#080;font-style:italic># exibir o primeiro usuário</span>
</span></span><span style=display:flex><span>kubectl config view -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.users[*].name}&#39;</span>   <span style=color:#080;font-style:italic># obtenha uma lista de usuários</span>
</span></span><span style=display:flex><span>kubectl config get-contexts                          <span style=color:#080;font-style:italic># exibir lista de contextos</span>
</span></span><span style=display:flex><span>kubectl config current-context                       <span style=color:#080;font-style:italic># exibir o contexto atual</span>
</span></span><span style=display:flex><span>kubectl config use-context my-cluster-name           <span style=color:#080;font-style:italic># defina o contexto padrão como my-cluster-name</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># adicione um novo cluster ao seu kubeconfig que suporte autenticação básica</span>
</span></span><span style=display:flex><span>kubectl config set-credentials kubeuser/foo.kubernetes.com --username<span style=color:#666>=</span>kubeuser --password<span style=color:#666>=</span>kubepassword
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># salve o namespace permanentemente para todos os comandos subsequentes do kubectl nesse contexto.</span>
</span></span><span style=display:flex><span>kubectl config set-context --current --namespace<span style=color:#666>=</span>ggckad-s2
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># defina um contexto utilizando um nome de usuário e o namespace.</span>
</span></span><span style=display:flex><span>kubectl config set-context gce --user<span style=color:#666>=</span>cluster-admin --namespace<span style=color:#666>=</span>foo <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  <span style=color:#666>&amp;&amp;</span> kubectl config use-context gce
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>kubectl config <span style=color:#a2f>unset</span> users.foo                       <span style=color:#080;font-style:italic># excluir usuário foo</span>
</span></span></code></pre></div><h2 id=aplicar>Aplicar</h2><p><code>apply</code> gerencia aplicações através de arquivos que definem os recursos do Kubernetes. Ele cria e atualiza recursos em um cluster através da execução <code>kubectl apply</code>.
Esta é a maneira recomendada de gerenciar aplicações Kubernetes em ambiente de produção. Veja a <a href=https://kubectl.docs.kubernetes.io>documentação do Kubectl</a>.</p><h2 id=criando-objetos>Criando objetos</h2><p>Manifestos Kubernetes podem ser definidos em YAML ou JSON. A extensão de arquivo <code>.yaml</code>,
<code>.yml</code>, e <code>.json</code> pode ser usado.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl apply -f ./my-manifest.yaml            <span style=color:#080;font-style:italic># criar recurso(s)</span>
</span></span><span style=display:flex><span>kubectl apply -f ./my1.yaml -f ./my2.yaml      <span style=color:#080;font-style:italic># criar a partir de vários arquivos</span>
</span></span><span style=display:flex><span>kubectl apply -f ./dir                         <span style=color:#080;font-style:italic># criar recurso(s) em todos os arquivos de manifesto no diretório</span>
</span></span><span style=display:flex><span>kubectl apply -f https://git.io/vPieo          <span style=color:#080;font-style:italic># criar recurso(s) a partir de URL</span>
</span></span><span style=display:flex><span>kubectl create deployment nginx --image<span style=color:#666>=</span>nginx  <span style=color:#080;font-style:italic># iniciar uma única instância do nginx</span>
</span></span><span style=display:flex><span>kubectl explain pods,svc                       <span style=color:#080;font-style:italic># obtenha a documentação de manifesto do pod</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Crie vários objetos YAML a partir de stdin</span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF | kubectl apply -f -
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: Pod
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: busybox-sleep
</span></span></span><span style=display:flex><span><span style=color:#b44>spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>  containers:
</span></span></span><span style=display:flex><span><span style=color:#b44>  - name: busybox
</span></span></span><span style=display:flex><span><span style=color:#b44>    image: busybox
</span></span></span><span style=display:flex><span><span style=color:#b44>    args:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - sleep
</span></span></span><span style=display:flex><span><span style=color:#b44>    - &#34;1000000&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44>---
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: Pod
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: busybox-sleep-less
</span></span></span><span style=display:flex><span><span style=color:#b44>spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>  containers:
</span></span></span><span style=display:flex><span><span style=color:#b44>  - name: busybox
</span></span></span><span style=display:flex><span><span style=color:#b44>    image: busybox
</span></span></span><span style=display:flex><span><span style=color:#b44>    args:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - sleep
</span></span></span><span style=display:flex><span><span style=color:#b44>    - &#34;1000&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Crie um segredo com várias chaves</span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF | kubectl apply -f -
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: Secret
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: mysecret
</span></span></span><span style=display:flex><span><span style=color:#b44>type: Opaque
</span></span></span><span style=display:flex><span><span style=color:#b44>data:
</span></span></span><span style=display:flex><span><span style=color:#b44>  password: $(echo -n &#34;s33msi4&#34; | base64 -w0)
</span></span></span><span style=display:flex><span><span style=color:#b44>  username: $(echo -n &#34;jane&#34; | base64 -w0)
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><h2 id=visualizando-e-localizando-recursos>Visualizando e Localizando Recursos</h2><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#080;font-style:italic># Obter comandos com saída simples</span>
</span></span><span style=display:flex><span>kubectl get services                          <span style=color:#080;font-style:italic># Listar todos os serviços do namespace</span>
</span></span><span style=display:flex><span>kubectl get pods --all-namespaces             <span style=color:#080;font-style:italic># Listar todos os pods em todos namespaces</span>
</span></span><span style=display:flex><span>kubectl get pods -o wide                      <span style=color:#080;font-style:italic># Listar todos os pods no namespace atual, com mais detalhes</span>
</span></span><span style=display:flex><span>kubectl get deployment my-dep                 <span style=color:#080;font-style:italic># Listar um deployment específico</span>
</span></span><span style=display:flex><span>kubectl get pods                              <span style=color:#080;font-style:italic># Listar todos os pods no namespace</span>
</span></span><span style=display:flex><span>kubectl get pod my-pod -o yaml                <span style=color:#080;font-style:italic># Obter o YAML de um pod</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Descrever comandos com saída detalhada</span>
</span></span><span style=display:flex><span>kubectl describe nodes my-node
</span></span><span style=display:flex><span>kubectl describe pods my-pod
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Listar serviços classificados por nome</span>
</span></span><span style=display:flex><span>kubectl get services --sort-by<span style=color:#666>=</span>.metadata.name
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Listar pods classificados por contagem de reinicializações</span>
</span></span><span style=display:flex><span>kubectl get pods --sort-by<span style=color:#666>=</span><span style=color:#b44>&#39;.status.containerStatuses[0].restartCount&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Listar PersistentVolumes classificado por capacidade</span>
</span></span><span style=display:flex><span>kubectl get pv --sort-by<span style=color:#666>=</span>.spec.capacity.storage
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Obtenha a versão da label de todos os pods com a label app=cassandra</span>
</span></span><span style=display:flex><span>kubectl get pods --selector<span style=color:#666>=</span><span style=color:#b8860b>app</span><span style=color:#666>=</span>cassandra -o <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.items[*].metadata.labels.version}&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Obter todos os nós workers (use um seletor para excluir resultados que possuem uma label</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># nomeado &#39;node-role.kubernetes.io/master&#39;)</span>
</span></span><span style=display:flex><span>kubectl get node --selector<span style=color:#666>=</span><span style=color:#b44>&#39;!node-role.kubernetes.io/master&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Obter todos os pods em execução no namespace</span>
</span></span><span style=display:flex><span>kubectl get pods --field-selector<span style=color:#666>=</span>status.phase<span style=color:#666>=</span>Running
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Obter ExternalIPs de todos os nós</span>
</span></span><span style=display:flex><span>kubectl get nodes -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.items[*].status.addresses[?(@.type==&#34;ExternalIP&#34;)].address}&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Listar nomes de pods pertencentes a um RC particular </span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># O comando &#34;jq&#34; é útil para transformações que são muito complexas para jsonpath, pode ser encontrado em https://stedolan.github.io/jq/</span>
</span></span><span style=display:flex><span><span style=color:#b8860b>sel</span><span style=color:#666>=</span><span style=color:#b68;font-weight:700>${</span><span style=color:#a2f;font-weight:700>$(</span>kubectl get rc my-rc --output<span style=color:#666>=</span>json | jq -j <span style=color:#b44>&#39;.spec.selector | to_entries | .[] | &#34;\(.key)=\(.value),&#34;&#39;</span><span style=color:#a2f;font-weight:700>)</span>%?<span style=color:#b68;font-weight:700>}</span>
</span></span><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#a2f;font-weight:700>$(</span>kubectl get pods --selector<span style=color:#666>=</span><span style=color:#b8860b>$sel</span> --output<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>={</span>.items..metadata.name<span style=color:#666>}</span><span style=color:#a2f;font-weight:700>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Mostrar marcadores para todos os pods(ou qualquer outro objeto Kubernetes que suporte rotulagem)</span>
</span></span><span style=display:flex><span>kubectl get pods --show-labels
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Verifique quais nós estão prontos</span>
</span></span><span style=display:flex><span><span style=color:#b8860b>JSONPATH</span><span style=color:#666>=</span><span style=color:#b44>&#39;{range .items[*]}{@.metadata.name}:{range @.status.conditions[*]}{@.type}={@.status};{end}{end}&#39;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span> <span style=color:#666>&amp;&amp;</span> kubectl get nodes -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#34;</span><span style=color:#b8860b>$JSONPATH</span><span style=color:#b44>&#34;</span> | grep <span style=color:#b44>&#34;Ready=True&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Listar todos os segredos atualmente em uso por um pod</span>
</span></span><span style=display:flex><span>kubectl get pods -o json | jq <span style=color:#b44>&#39;.items[].spec.containers[].env[]?.valueFrom.secretKeyRef.name&#39;</span> | grep -v null | sort | uniq
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Listar todos os containerIDs de initContainer de todos os pods</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Útil ao limpar contêineres parados, evitando a remoção de initContainers.</span>
</span></span><span style=display:flex><span>kubectl get pods --all-namespaces -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{range .items[*].status.initContainerStatuses[*]}{.containerID}{&#34;\n&#34;}{end}&#39;</span> | cut -d/ -f3
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Listar eventos classificados por timestamp</span>
</span></span><span style=display:flex><span>kubectl get events --sort-by<span style=color:#666>=</span>.metadata.creationTimestamp
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Compara o estado atual do cluster com o estado em que o cluster estaria se o manifesto fosse aplicado.</span>
</span></span><span style=display:flex><span>kubectl diff -f ./my-manifest.yaml
</span></span></code></pre></div><h2 id=atualizando-recursos>Atualizando Recursos</h2><p>A partir da versão 1.11 <code>rolling-update</code> foi descontinuado (veja <a href=https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG/CHANGELOG-1.11.md>CHANGELOG-1.11.md</a>), utilize o comando <code>rollout</code> no lugar deste.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl <span style=color:#a2f>set</span> image deployment/frontend <span style=color:#b8860b>www</span><span style=color:#666>=</span>image:v2               <span style=color:#080;font-style:italic># Aplica o rollout nos containers &#34;www&#34; do deployment &#34;frontend&#34;, atualizando a imagem</span>
</span></span><span style=display:flex><span>kubectl rollout <span style=color:#a2f>history</span> deployment/frontend                      <span style=color:#080;font-style:italic># Verifica o histórico do deployment, incluindo a revisão</span>
</span></span><span style=display:flex><span>kubectl rollout undo deployment/frontend                         <span style=color:#080;font-style:italic># Rollback para o deployment anterior</span>
</span></span><span style=display:flex><span>kubectl rollout undo deployment/frontend --to-revision<span style=color:#666>=</span><span style=color:#666>2</span>         <span style=color:#080;font-style:italic># Rollback para uma revisão específica</span>
</span></span><span style=display:flex><span>kubectl rollout status -w deployment/frontend                    <span style=color:#080;font-style:italic># Acompanhe o status de atualização do &#34;frontend&#34; até sua conclusão sem interrupção </span>
</span></span><span style=display:flex><span>kubectl rollout restart deployment/frontend                      <span style=color:#080;font-style:italic># Reinício contínuo do deployment &#34;frontend&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># versão inicial descontinuada 1.11</span>
</span></span><span style=display:flex><span>kubectl rolling-update frontend-v1 -f frontend-v2.json           <span style=color:#080;font-style:italic># (descontinuada) Atualização contínua dos pods de frontend-v1</span>
</span></span><span style=display:flex><span>kubectl rolling-update frontend-v1 frontend-v2 --image<span style=color:#666>=</span>image:v2  <span style=color:#080;font-style:italic># (descontinuada) Altera o nome do recurso e atualiza a imagem</span>
</span></span><span style=display:flex><span>kubectl rolling-update frontend --image<span style=color:#666>=</span>image:v2                 <span style=color:#080;font-style:italic># (descontinuada) Atualize a imagem dos pods do frontend</span>
</span></span><span style=display:flex><span>kubectl rolling-update frontend-v1 frontend-v2 --rollback        <span style=color:#080;font-style:italic># (descontinuada) Interromper o lançamento existente em andamento</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>cat pod.json | kubectl replace -f -                              <span style=color:#080;font-style:italic># Substitua um pod com base no JSON passado para std</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Força a substituição, exclui e recria o recurso. Causará uma interrupção do serviço.</span>
</span></span><span style=display:flex><span>kubectl replace --force -f ./pod.json
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Crie um serviço para um nginx replicado, que serve na porta 80 e se conecta aos contêineres na porta 8000</span>
</span></span><span style=display:flex><span>kubectl expose rc nginx --port<span style=color:#666>=</span><span style=color:#666>80</span> --target-port<span style=color:#666>=</span><span style=color:#666>8000</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Atualizar a versão da imagem (tag) de um pod de contêiner único para a v4</span>
</span></span><span style=display:flex><span>kubectl get pod mypod -o yaml | sed <span style=color:#b44>&#39;s/\(image: myimage\):.*$/\1:v4/&#39;</span> | kubectl replace -f -
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl label pods my-pod new-label<span style=color:#666>=</span>awesome                      <span style=color:#080;font-style:italic># Adicionar uma label</span>
</span></span><span style=display:flex><span>kubectl annotate pods my-pod icon-url<span style=color:#666>=</span>http://goo.gl/XXBTWq       <span style=color:#080;font-style:italic># Adicionar uma anotação</span>
</span></span><span style=display:flex><span>kubectl autoscale deployment foo --min<span style=color:#666>=</span><span style=color:#666>2</span> --max<span style=color:#666>=</span><span style=color:#666>10</span>                <span style=color:#080;font-style:italic># Escalar automaticamente um deployment &#34;foo&#34;</span>
</span></span></code></pre></div><h2 id=recursos-de-correção>Recursos de Correção</h2><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#080;font-style:italic># Atualizar parcialmente um nó</span>
</span></span><span style=display:flex><span>kubectl patch node k8s-node-1 -p <span style=color:#b44>&#39;{&#34;spec&#34;:{&#34;unschedulable&#34;:true}}&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Atualizar a imagem de um contêiner; spec.containers[*].name é obrigatório porque é uma chave de mesclagem</span>
</span></span><span style=display:flex><span>kubectl patch pod valid-pod -p <span style=color:#b44>&#39;{&#34;spec&#34;:{&#34;containers&#34;:[{&#34;name&#34;:&#34;kubernetes-serve-hostname&#34;,&#34;image&#34;:&#34;new image&#34;}]}}&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Atualizar a imagem de um contêiner usando um patch json com matrizes posicionais</span>
</span></span><span style=display:flex><span>kubectl patch pod valid-pod --type<span style=color:#666>=</span><span style=color:#b44>&#39;json&#39;</span> -p<span style=color:#666>=</span><span style=color:#b44>&#39;[{&#34;op&#34;: &#34;replace&#34;, &#34;path&#34;: &#34;/spec/containers/0/image&#34;, &#34;value&#34;:&#34;new image&#34;}]&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Desative um livenessProbe de deployment usando um patch json com matrizes posicionais</span>
</span></span><span style=display:flex><span>kubectl patch deployment valid-deployment  --type json   -p<span style=color:#666>=</span><span style=color:#b44>&#39;[{&#34;op&#34;: &#34;remove&#34;, &#34;path&#34;: &#34;/spec/template/spec/containers/0/livenessProbe&#34;}]&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Adicionar um novo elemento a uma matriz posicional</span>
</span></span><span style=display:flex><span>kubectl patch sa default --type<span style=color:#666>=</span><span style=color:#b44>&#39;json&#39;</span> -p<span style=color:#666>=</span><span style=color:#b44>&#39;[{&#34;op&#34;: &#34;add&#34;, &#34;path&#34;: &#34;/secrets/1&#34;, &#34;value&#34;: {&#34;name&#34;: &#34;whatever&#34; } }]&#39;</span>
</span></span></code></pre></div><h2 id=editando-recursos>Editando Recursos</h2><p>Edite qualquer recurso da API no seu editor preferido.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl edit svc/docker-registry                      <span style=color:#080;font-style:italic># Edite o serviço chamado docker-registry</span>
</span></span><span style=display:flex><span><span style=color:#b8860b>KUBE_EDITOR</span><span style=color:#666>=</span><span style=color:#b44>&#34;nano&#34;</span> kubectl edit svc/docker-registry   <span style=color:#080;font-style:italic># Use um editor alternativo</span>
</span></span></code></pre></div><h2 id=escalando-recursos>Escalando Recursos</h2><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl scale --replicas<span style=color:#666>=</span><span style=color:#666>3</span> rs/foo                                 <span style=color:#080;font-style:italic># Escale um replicaset chamado &#39;foo&#39; para 3</span>
</span></span><span style=display:flex><span>kubectl scale --replicas<span style=color:#666>=</span><span style=color:#666>3</span> -f foo.yaml                            <span style=color:#080;font-style:italic># Escale um recurso especificado em &#34;foo.yaml&#34; para 3</span>
</span></span><span style=display:flex><span>kubectl scale --current-replicas<span style=color:#666>=</span><span style=color:#666>2</span> --replicas<span style=color:#666>=</span><span style=color:#666>3</span> deployment/mysql  <span style=color:#080;font-style:italic># Se o tamanho atual do deployment chamado mysql for dois, assim escale para 3</span>
</span></span><span style=display:flex><span>kubectl scale --replicas<span style=color:#666>=</span><span style=color:#666>5</span> rc/foo rc/bar rc/baz                   <span style=color:#080;font-style:italic># Escalar vários replicaset</span>
</span></span></code></pre></div><h2 id=exclusão-de-recursos>Exclusão de Recursos</h2><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl delete -f ./pod.json                                              <span style=color:#080;font-style:italic># Exclua um pod usando o tipo e o nome especificados em pod.json</span>
</span></span><span style=display:flex><span>kubectl delete pod,service baz foo                                        <span style=color:#080;font-style:italic># Excluir pods e serviços com os mesmos nomes &#34;baz&#34; e &#34;foo&#34;</span>
</span></span><span style=display:flex><span>kubectl delete pods,services -l <span style=color:#b8860b>name</span><span style=color:#666>=</span>myLabel                              <span style=color:#080;font-style:italic># Excluir pods e serviços com o nome da label = myLabel</span>
</span></span><span style=display:flex><span>kubectl -n my-ns delete pod,svc --all                                     <span style=color:#080;font-style:italic># Exclua todos os pods e serviços no namespace my-ns,</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Excluir todos os pods que correspondem ao awk pattern1 ou pattern2</span>
</span></span><span style=display:flex><span>kubectl get pods  -n mynamespace --no-headers<span style=color:#666>=</span><span style=color:#a2f>true</span> | awk <span style=color:#b44>&#39;/pattern1|pattern2/{print $1}&#39;</span> | xargs  kubectl delete -n mynamespace pod
</span></span></code></pre></div><h2 id=interagindo-com-pods-em-execução>Interagindo com Pods em execução</h2><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl logs my-pod                                 <span style=color:#080;font-style:italic># despejar logs de pod (stdout)</span>
</span></span><span style=display:flex><span>kubectl logs -l <span style=color:#b8860b>name</span><span style=color:#666>=</span>myLabel                        <span style=color:#080;font-style:italic># despejar logs de pod, com a label de name=myLabel (stdout)</span>
</span></span><span style=display:flex><span>kubectl logs my-pod --previous                      <span style=color:#080;font-style:italic># despejar logs de pod (stdout) para a instância anterior de um contêiner</span>
</span></span><span style=display:flex><span>kubectl logs my-pod -c my-container                 <span style=color:#080;font-style:italic># despejar logs de um específico contêiner em um pod (stdout, no caso de vários contêineres)</span>
</span></span><span style=display:flex><span>kubectl logs -l <span style=color:#b8860b>name</span><span style=color:#666>=</span>myLabel -c my-container        <span style=color:#080;font-style:italic># despejar logs de pod, com nome da label = myLabel (stdout)</span>
</span></span><span style=display:flex><span>kubectl logs my-pod -c my-container --previous      <span style=color:#080;font-style:italic># despejar logs de um contêiner específico em um pod (stdout, no caso de vários contêineres) para uma instanciação anterior de um contêiner</span>
</span></span><span style=display:flex><span>kubectl logs -f my-pod                              <span style=color:#080;font-style:italic># Fluxo de logs de pod (stdout)</span>
</span></span><span style=display:flex><span>kubectl logs -f my-pod -c my-container              <span style=color:#080;font-style:italic># Fluxo de logs para um específico contêiner em um pod (stdout, caixa com vários contêineres)</span>
</span></span><span style=display:flex><span>kubectl logs -f -l <span style=color:#b8860b>name</span><span style=color:#666>=</span>myLabel --all-containers    <span style=color:#080;font-style:italic># transmitir todos os logs de pods com a label name=myLabel (stdout)</span>
</span></span><span style=display:flex><span>kubectl run -i --tty busybox --image<span style=color:#666>=</span>busybox -- sh  <span style=color:#080;font-style:italic># Executar pod como shell interativo</span>
</span></span><span style=display:flex><span>kubectl run nginx --image<span style=color:#666>=</span>nginx --restart<span style=color:#666>=</span>Never -n 
</span></span><span style=display:flex><span>mynamespace                                         <span style=color:#080;font-style:italic># Execute o pod nginx em um namespace específico</span>
</span></span><span style=display:flex><span>kubectl run nginx --image<span style=color:#666>=</span>nginx --restart<span style=color:#666>=</span>Never     <span style=color:#080;font-style:italic># Execute o pod nginx e salve suas especificações em um arquivo chamado pod.yaml</span>
</span></span><span style=display:flex><span>--dry-run -o yaml &gt; pod.yaml
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl attach my-pod -i                            <span style=color:#080;font-style:italic># Anexar ao contêiner em execução</span>
</span></span><span style=display:flex><span>kubectl port-forward my-pod 5000:6000               <span style=color:#080;font-style:italic># Ouça na porta 5000 na máquina local e encaminhe para a porta 6000 no my-pod</span>
</span></span><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> my-pod -- ls /                         <span style=color:#080;font-style:italic># Executar comando no pod existente (1 contêiner)</span>
</span></span><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> my-pod -c my-container -- ls /         <span style=color:#080;font-style:italic># Executar comando no pod existente (pod com vários contêineres)</span>
</span></span><span style=display:flex><span>kubectl top pod POD_NAME --containers               <span style=color:#080;font-style:italic># Mostrar métricas para um determinado pod e seus contêineres</span>
</span></span></code></pre></div><h2 id=interagindo-com-nós-e-cluster>Interagindo com Nós e Cluster</h2><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl cordon my-node                                                <span style=color:#080;font-style:italic># Marcar o nó my-node como não agendável</span>
</span></span><span style=display:flex><span>kubectl drain my-node                                                 <span style=color:#080;font-style:italic># Drene o nó my-node na preparação para manutenção</span>
</span></span><span style=display:flex><span>kubectl uncordon my-node                                              <span style=color:#080;font-style:italic># Marcar nó my-node como agendável</span>
</span></span><span style=display:flex><span>kubectl top node my-node                                              <span style=color:#080;font-style:italic># Mostrar métricas para um determinado nó</span>
</span></span><span style=display:flex><span>kubectl cluster-info                                                  <span style=color:#080;font-style:italic># Exibir endereços da master e serviços</span>
</span></span><span style=display:flex><span>kubectl cluster-info dump                                             <span style=color:#080;font-style:italic># Despejar o estado atual do cluster no stdout</span>
</span></span><span style=display:flex><span>kubectl cluster-info dump --output-directory<span style=color:#666>=</span>/path/to/cluster-state   <span style=color:#080;font-style:italic># Despejar o estado atual do cluster em /path/to/cluster-state</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Se uma `taint` com essa chave e efeito já existir, seu valor será substituído conforme especificado.</span>
</span></span><span style=display:flex><span>kubectl taint nodes foo <span style=color:#b8860b>dedicated</span><span style=color:#666>=</span>special-user:NoSchedule
</span></span></code></pre></div><h3 id=tipos-de-recursos>Tipos de Recursos</h3><p>Listar todos os tipos de recursos suportados, juntamente com seus nomes abreviados, <a href=/docs/concepts/overview/kubernetes-api/#api-groups>Grupo de API</a>, se eles são por <a href=/docs/concepts/overview/working-with-objects/namespaces>namespaces</a>, e <a href=/docs/concepts/overview/working-with-objects/kubernetes-objects>objetos</a>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl api-resources
</span></span></code></pre></div><p>Outras operações para explorar os recursos da API:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl api-resources --namespaced<span style=color:#666>=</span><span style=color:#a2f>true</span>      <span style=color:#080;font-style:italic># Todos os recursos com namespace</span>
</span></span><span style=display:flex><span>kubectl api-resources --namespaced<span style=color:#666>=</span><span style=color:#a2f>false</span>     <span style=color:#080;font-style:italic># Todos os recursos sem namespace</span>
</span></span><span style=display:flex><span>kubectl api-resources -o name                <span style=color:#080;font-style:italic># Todos os recursos com saída simples (apenas o nome do recurso)</span>
</span></span><span style=display:flex><span>kubectl api-resources -o wide                <span style=color:#080;font-style:italic># Todos os recursos com saída expandida (também conhecida como &#34;ampla&#34;)</span>
</span></span><span style=display:flex><span>kubectl api-resources --verbs<span style=color:#666>=</span>list,get       <span style=color:#080;font-style:italic># Todos os recursos que suportam os verbos de API &#34;list&#34; e &#34;get&#34;</span>
</span></span><span style=display:flex><span>kubectl api-resources --api-group<span style=color:#666>=</span>extensions <span style=color:#080;font-style:italic># Todos os recursos no grupo de API &#34;extensions&#34;</span>
</span></span></code></pre></div><h3 id=formatação-de-saída>Formatação de Saída</h3><p>Para enviar detalhes para a janela do terminal em um formato específico, adicione a flag <code>-o</code> (ou <code>--output</code>) para um comando <code>kubectl</code> suportado.</p><table><thead><tr><th>Formato de saída</th><th>Descrição</th></tr></thead><tbody><tr><td><code>-o=custom-columns=&lt;spec></code></td><td>Imprimir uma tabela usando uma lista separada por vírgula de colunas personalizadas</td></tr><tr><td><code>-o=custom-columns-file=&lt;filename></code></td><td>Imprima uma tabela usando o modelo de colunas personalizadas no arquivo <code>&lt;nome do arquivo></code></td></tr><tr><td><code>-o=json</code></td><td>Saída de um objeto de API formatado em JSON</td></tr><tr><td><code>-o=jsonpath=&lt;template></code></td><td>Imprima os campos definidos em uma expressão <a href=/docs/reference/kubectl/jsonpath>jsonpath</a></td></tr><tr><td><code>-o=jsonpath-file=&lt;filename></code></td><td>Imprima os campos definidos pela expressão <a href=/docs/reference/kubectl/jsonpath>jsonpath</a> no arquivo <code>&lt;nome do arquivo></code></td></tr><tr><td><code>-o=name</code></td><td>Imprima apenas o nome do recurso e nada mais</td></tr><tr><td><code>-o=wide</code></td><td>Saída no formato de texto sem formatação com qualquer informação adicional e, para pods, o nome do nó está incluído</td></tr><tr><td><code>-o=yaml</code></td><td>Saída de um objeto de API formatado em YAML</td></tr></tbody></table><h3 id=verbosidade-da-saída-do-kubectl-e-debugging>Verbosidade da Saída do Kubectl e Debugging</h3><p>A verbosidade do Kubectl é controlado com os sinalizadores <code>-v</code> ou<code> --v</code> seguidos por um número inteiro representando o nível do log. As convenções gerais de log do Kubernetes e os níveis de log associados são descritos <a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-instrumentation/logging.md>aqui</a>.</p><table><thead><tr><th>Verbosidade</th><th>Descrição</th></tr></thead><tbody><tr><td><code>--v=0</code></td><td>Geralmente útil para <em>sempre</em> estar visível para um operador de cluster.</td></tr><tr><td><code>--v=1</code></td><td>Um nível de log padrão razoável se você não deseja verbosidade.</td></tr><tr><td><code>--v=2</code></td><td>Informações úteis sobre o estado estacionário sobre o serviço e mensagens importantes de log que podem se correlacionar com alterações significativas no sistema. Este é o nível de log padrão recomendado para a maioria dos sistemas.</td></tr><tr><td><code>--v=3</code></td><td>Informações estendidas sobre alterações.</td></tr><tr><td><code>--v=4</code></td><td>Detalhamento no nível de debugging.</td></tr><tr><td><code>--v=6</code></td><td>Exibir os recursos solicitados.</td></tr><tr><td><code>--v=7</code></td><td>Exibir cabeçalhos de solicitação HTTP.</td></tr><tr><td><code>--v=8</code></td><td>Exibir conteúdo da solicitação HTTP.</td></tr><tr><td><code>--v=9</code></td><td>Exiba o conteúdo da solicitação HTTP sem o truncamento do conteúdo.</td></tr></tbody></table><h2 id=próximos-passos>Próximos passos</h2><ul><li><p>Saiba mais em <a href=/docs/reference/kubectl/overview/>Visão geral do kubectl</a>.</p></li><li><p>Veja as opções do <a href=/docs/reference/kubectl/kubectl/>kubectl</a>.</p></li><li><p>Veja as <a href=/docs/reference/kubectl/conventions/>Convenções de uso do kubectl</a> para entender como usá-lo em scripts reutilizáveis.</p></li><li><p>Ver mais comunidade <a href=https://github.com/dennyzhang/cheatsheet-kubernetes-A4>kubectl cheatsheets</a>.</p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-342be69d36f174f762c36f4fe11fcb20>6.9 - Visão Geral de Autorização</h1><p>Aprenda mais sobre autorização no Kubernetes, incluindo detalhes sobre
criação de políticas utilizando módulos de autorização suportados.</p><p>No Kubernetes, você deve estar autenticado (conectado) antes que sua requisição possa ser
autorizada (permissão concedida para acesso). Para obter informações sobre autenticação,
visite <a href=/pt-br/docs/concepts/security/controlling-access/>Controlando Acesso à API do Kubernetes</a>.</p><p>O Kubernetes espera atributos que são comuns a requisições de APIs REST. Isto significa
que autorização no Kubernetes funciona com sistemas de controle de acesso a nível de organizações
ou de provedores de nuvem que possam lidar com outras APIs além das APIs do Kubernetes.</p><h2 id=determinar-se-uma-requisição-é-permitida-ou-negada>Determinar se uma requisição é permitida ou negada</h2><p>O Kubernetes autoriza requisições de API utilizando o servidor de API. Ele avalia
todos os atributos de uma requisição em relação a todas as políticas disponíveis e permite ou nega a requisição.
Todas as partes de uma requisição de API deve ser permitidas por alguma política para que possa prosseguir.
Isto significa que permissões são negadas por padrão.</p><p>(Embora o Kubernetes use o servidor de API, controles de acesso e políticas que
dependem de campos específicos de tipos específicos de objetos são tratados pelos controladores de admissão.)</p><p>Quando múltiplos módulos de autorização são configurados, cada um será verificado em sequência.
Se qualquer dos autorizadores aprovarem ou negarem uma requisição, a decisão é imediatamente
retornada e nenhum outro autorizador é consultado. Se nenhum módulo de autorização tiver
nenhuma opinião sobre requisição, então a requisição é negada. Uma negação retorna um
código de status HTTP 403.</p><h2 id=revisão-de-atributos-de-sua-requisição>Revisão de atributos de sua requisição</h2><p>O Kubernetes revisa somente os seguintes atributos de uma requisição de API:</p><ul><li><strong>user</strong> - O string de <code>user</code> fornecido durante a autenticação.</li><li><strong>group</strong> - A lista de nomes de grupos aos quais o usuário autenticado pertence.</li><li><strong>extra</strong> - Um mapa de chaves de string arbitrárias para valores de string, fornecido pela camada de autenticação.</li><li><strong>API</strong> - Indica se a solicitação é para um recurso de API.</li><li><strong>Caminho da requisição</strong> - Caminho para diversos endpoints que não manipulam recursos, como <code>/api</code> ou <code>/healthz</code>.</li><li><strong>Verbo de requisição de API</strong> - Verbos da API como <code>get</code>, <code>list</code>, <code>create</code>, <code>update</code>, <code>patch</code>, <code>watch</code>, <code>delete</code> e <code>deletecollection</code> que são utilizados para solicitações de recursos. Para determinar o verbo de requisição para um endpoint de recurso de API , consulte <a href=/pt-br/docs/reference/access-authn-authz/authorization/#determine-the-request-verb>Determine o verbo da requisição</a>.</li><li><strong>Verbo de requisição HTTP</strong> - Métodos HTTP em letras minúsculas como <code>get</code>, <code>post</code>, <code>put</code> e <code>delete</code> que são utilizados para requisições que não são de recursos.</li><li><strong>Recurso</strong> - O identificador ou nome do recurso que está sendo acessado (somente para requisições de recursos) - para requisições de recursos usando os verbos <code>get</code>, <code>update</code>, <code>patch</code> e <code>delete</code>, deve-se fornecer o nome do recurso.</li><li><strong>Subrecurso</strong> - O sub-recurso que está sendo acessado (somente para solicitações de recursos).</li><li><strong>Namespace</strong> - O namespace do objeto que está sendo acessado (somente para solicitações de recursos com namespace).</li><li><strong>Grupo de API</strong> - O <a class=glossary-tooltip title='Um conjunto de caminhos relacionados da API Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/kubernetes-api/#api-groups-and-versioning target=_blank aria-label='API Group'>API Group</a> sendo acessado (somente para requisições de recursos). Uma string vazia designa o <a href=/docs/reference/using-api/#api-groups>Grupo de API</a> <em>core</em>.</li></ul><h2 id=determine-the-request-verb>Determine o verbo da requisição</h2><p><strong>Requisições de não-recursos</strong>
Requisições sem recursos de <code>/api/v1/...</code> ou <code>/apis/&lt;group>/&lt;version>/...</code>
são considerados "requisições sem recursos" e usam o método HTTP em letras minúsculas da solicitação como o verbo.
Por exemplo, uma solicitação <code>GET</code> para endpoints como <code>/api</code> ou <code>/healthz</code> usaria <code>get</code> como o verbo.</p><p><strong>Requisições de recursos</strong>
Para determinar o verbo de requisição para um endpoint de API de recurso, revise o verbo HTTP
utilizado e se a requisição atua ou não em um recurso individual ou em uma
coleção de recursos:</p><table><thead><tr><th>Verbo HTTP</th><th>Verbo de Requisição</th></tr></thead><tbody><tr><td>POST</td><td>create</td></tr><tr><td>GET, HEAD</td><td>get (para recursos individuais), list (para coleções, includindo o conteúdo do objeto inteiro), watch (para observar um recurso individual ou coleção de recursos)</td></tr><tr><td>PUT</td><td>update</td></tr><tr><td>PATCH</td><td>patch</td></tr><tr><td>DELETE</td><td>delete (para recursos individuais), deletecollection (para coleções)</td></tr></tbody></table><div class="alert alert-warning caution callout" role=alert><strong>Cuidado:</strong> Os verbos <code>get</code>, <code>list</code> e <code>watch</code> podem retornar todos os detalhes de um recurso. Eles são equivalentes em relação aos dados retornados. Por exemplo, <code>list</code> em <code>secrets</code> revelará os atributos de <code>data</code> de qualquer recurso retornado.</div><p>Às vezes, o Kubernetes verifica a autorização para permissões adicionais utilizando verbos especializados. Por exemplo:</p><ul><li><a href=/docs/concepts/security/pod-security-policy/>PodSecurityPolicy</a><ul><li>Verbo <code>use</code> em recursos <code>podsecuritypolicies</code> no grupo <code>policy</code> de API.</li></ul></li><li><a href=/docs/reference/access-authn-authz/rbac/#privilege-escalation-prevention-and-bootstrapping>RBAC</a><ul><li>Verbos <code>bind</code> e <code>escalate</code> em <code>roles</code> e recursos <code>clusterroles</code> no grupo <code>rbac.authorization.k8s.io</code> de API.</li></ul></li><li><a href=/pt-br/docs/reference/access-authn-authz/authentication/>Authentication</a><ul><li>Verbo <code>impersonate</code> em <code>users</code>, <code>groups</code>, e <code>serviceaccounts</code> no grupo de API <code>core</code>, e o <code>userextras</code> no grupo <code>authentication.k8s.io</code> de API.</li></ul></li></ul><h2 id=authorization-modules>Modos de Autorização</h2><p>O servidor da API Kubernetes pode autorizar uma solicitação usando um dos vários modos de autorização:</p><ul><li><strong>Node</strong> - Um modo de autorização de finalidade especial que concede permissões a <code>kubelets</code> com base nos <code>Pods</code> que estão programados para execução. Para saber mais sobre como utilizar o modo de autorização do nó, consulte <a href=/docs/reference/access-authn-authz/node/>Node Authorization</a>.</li><li><strong>ABAC</strong> - Attribute-based access control (ABAC), ou Controle de acesso baseado em atributos, define um paradigma de controle de acesso pelo qual os direitos de acesso são concedidos aos usuários por meio do uso de políticas que combinam atributos. As políticas podem usar qualquer tipo de atributo (atributos de usuário, atributos de recurso, objeto, atributos de ambiente, etc.). Para saber mais sobre como usar o modo ABAC, consulte <a href=/docs/reference/access-authn-authz/abac/>ABAC Mode</a>.</li><li><strong>RBAC</strong> - Role-based access control (RBAC), ou controle de acesso baseado em função, é um método de regular o acesso a recursos computacionais ou de rede com base nas funções de usuários individuais dentro de uma empresa. Nesse contexto, acesso é a capacidade de um usuário individual realizar uma tarefa específica, como visualizar, criar ou modificar um arquivo. Para saber mais sobre como usar o modo RBAC, consulte <a href=/docs/reference/access-authn-authz/rbac/>RBAC Mode</a><ul><li>Quando especificado RBAC (Role-Based Access Control) usa o grupo de API <code>rbac.authorization.k8s.io</code> para orientar as decisões de autorização, permitindo que os administradores configurem dinamicamente as políticas de permissão por meio da API do Kubernetes.</li><li>Para habilitar o modo RBAC, inicie o servidor de API (apiserver) com a opção <code>--authorization-mode=RBAC</code>.</li></ul></li><li><strong>Webhook</strong> - Um WebHook é um retorno de chamada HTTP: um HTTP POST que ocorre quando algo acontece; uma simples notificação de evento via HTTP POST. Um aplicativo da Web que implementa WebHooks postará uma mensagem em um URL quando um determinado evento ocorrer. Para saber mais sobre como usar o modo Webhook, consulte <a href=/docs/reference/access-authn-authz/webhook/>Webhook Mode</a>.</li></ul><h4 id=verificando-acesso-a-api>Verificando acesso a API</h4><p><code>kubectl</code> fornece o subcomando <code>auth can-i</code> para consultar rapidamente a camada de autorização da API.
O comando usa a API <code>SelfSubjectAccessReview</code> para determinar se o usuário atual pode executar
uma determinada ação e funciona independentemente do modo de autorização utilizado.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#080;font-style:italic># &#34;can-i create&#34; = &#34;posso criar&#34;</span>
</span></span><span style=display:flex><span>kubectl auth can-i create deployments --namespace dev
</span></span></code></pre></div><p>A saída é semelhante a esta:</p><pre tabindex=0><code>yes
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># &#34;can-i create&#34; = &#34;posso criar&#34;</span>
</span></span><span style=display:flex><span>kubectl auth can-i create deployments --namespace prod
</span></span></code></pre></div><p>A saída é semelhante a esta:</p><pre tabindex=0><code>no
</code></pre><p>Os administradores podem combinar isso com <a href=/pt-br/docs/reference/access-authn-authz/authentication/#personifica%C3%A7%C3%A3o-de-usu%C3%A1rio>personificação de usuário</a>
para determinar qual ação outros usuários podem executar.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#080;font-style:italic># &#34;can-i list&#34; = &#34;posso listar&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl auth can-i list secrets --namespace dev --as dave
</span></span></code></pre></div><p>A saída é semelhante a esta:</p><pre tabindex=0><code>no
</code></pre><p>Da mesma forma, para verificar se uma ServiceAccount chamada <code>dev-sa</code> no Namespace <code>dev</code>
pode listar <code>Pods</code> no namespace <code>target</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#080;font-style:italic># &#34;can-i list&#34; = &#34;posso listar&#34;</span>
</span></span><span style=display:flex><span>kubectl auth can-i list pods <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>	--namespace target <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>	--as system:serviceaccount:dev:dev-sa
</span></span></code></pre></div><p>A saída é semelhante a esta:</p><pre tabindex=0><code>yes
</code></pre><p><code>SelfSubjectAccessReview</code> faz parte do grupo de API <code>authorization.k8s.io</code>, que
expõe a autorização do servidor de API para serviços externos. Outros recursos
neste grupo inclui:</p><ul><li><p><code>SubjectAccessReview</code> - Revisão de acesso para qualquer usuário, não apenas o atual. Útil para delegar decisões de autorização para o servidor de API. Por exemplo, o <code>kubelet</code> e extensões de servidores de API utilizam disso para determinar o acesso do usuário às suas próprias APIs.</p></li><li><p><code>LocalSubjectAccessReview</code> - Similar a <code>SubjectAccessReview</code>, mas restrito a um namespace específico.</p></li><li><p><code>SelfSubjectRulesReview</code> - Uma revisão que retorna o conjunto de ações que um usuário pode executar em um namespace. Útil para usuários resumirem rapidamente seu próprio acesso ou para interfaces de usuário mostrarem ações.</p></li></ul><p>Essas APIs podem ser consultadas criando recursos normais do Kubernetes, onde a resposta no campo <code>status</code>
do objeto retornado é o resultado da consulta.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl create -f - -o yaml <span style=color:#b44>&lt;&lt; EOF
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: authorization.k8s.io/v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: SelfSubjectAccessReview
</span></span></span><span style=display:flex><span><span style=color:#b44>spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>  resourceAttributes:
</span></span></span><span style=display:flex><span><span style=color:#b44>    group: apps
</span></span></span><span style=display:flex><span><span style=color:#b44>    resource: deployments
</span></span></span><span style=display:flex><span><span style=color:#b44>    verb: create
</span></span></span><span style=display:flex><span><span style=color:#b44>    namespace: dev
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>A <code>SelfSubjectAccessReview</code> gerada seria:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>authorization.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>SelfSubjectAccessReview<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>null</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceAttributes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>group</span>:<span style=color:#bbb> </span>apps<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resource</span>:<span style=color:#bbb> </span>deployments<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>dev<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>verb</span>:<span style=color:#bbb> </span>create<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>allowed</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>denied</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=usando-flags-para-seu-módulo-de-autorização>Usando flags para seu módulo de autorização</h2><p>Você deve incluir uma flag em sua política para indicar qual módulo de autorização
suas políticas incluem:</p><p>As seguintes flags podem ser utilizadas:</p><ul><li><code>--authorization-mode=ABAC</code> O modo de controle de acesso baseado em atributos (ABAC) permite configurar políticas usando arquivos locais.</li><li><code>--authorization-mode=RBAC</code> O modo de controle de acesso baseado em função (RBAC) permite que você crie e armazene políticas usando a API do Kubernetes.</li><li><code>--authorization-mode=Webhook</code> WebHook é um modo de retorno de chamada HTTP que permite gerenciar a autorização usando endpoint REST.</li><li><code>--authorization-mode=Node</code> A autorização de nó é um modo de autorização de propósito especial que autoriza especificamente requisições de API feitas por <code>kubelets</code>.</li><li><code>--authorization-mode=AlwaysDeny</code> Esta flag bloqueia todas as requisições. Utilize esta flag somente para testes.</li><li><code>--authorization-mode=AlwaysAllow</code> Esta flag permite todas as requisições. Utilize esta flag somente se não existam requisitos de autorização para as requisições de API.</li></ul><p>Você pode escolher mais de um modulo de autorização. Módulos são verificados
em ordem, então, um modulo anterior tem maior prioridade para permitir ou negar uma requisição.</p><h2 id=privilege-escalation-via-pod-creation>Escalonamento de privilégios através da criação ou edição da cargas de trabalho</h2><p>Usuários que podem criar ou editar <code>pods</code> em um namespace diretamente ou através de um <a href=/pt-br/docs/concepts/architecture/controller/>controlador</a>
como, por exemplo, um operador, conseguiriam escalar seus próprios privilégios naquele namespace.</p><div class="alert alert-warning caution callout" role=alert><strong>Cuidado:</strong> Administradores de sistemas, tenham cuidado ao permitir acesso para criar ou editar cargas de trabalho.
Detalhes de como estas permissões podem ser usadas de forma maliciosa podem ser encontradas em <a href=#escalation-paths>caminhos para escalonamento</a>.</div><h3 id=escalation-paths>Caminhos para escalonamento</h3><ul><li>Montagem de Secret arbitrários nesse namespace<ul><li>Pode ser utilizado para acessar Secret destinados a outras cargas de trabalho</li><li>Pode ser utilizado para obter um token da conta de serviço com maior privilégio</li></ul></li><li>Uso de contas de serviço arbitrárias nesse namespace<ul><li>Pode executar ações da API do Kubernetes como outra carga de trabalho (personificação)</li><li>Pode executar quaisquer ações privilegiadas que a conta de serviço tenha acesso</li></ul></li><li>Montagem de configmaps destinados a outras cargas de trabalho nesse namespace<ul><li>Pode ser utilizado para obter informações destinadas a outras cargas de trabalho, como nomes de host de banco de dados.</li></ul></li><li>Montagem de volumes destinados a outras cargas de trabalho nesse namespace<ul><li>Pode ser utilizado para obter informações destinadas a outras cargas de trabalho e alterá-las.</li></ul></li></ul><div class="alert alert-warning caution callout" role=alert><strong>Cuidado:</strong> Administradores de sistemas devem ser cuidadosos ao instalar CRDs que
promovam mudanças nas áreas mencionadas acima. Estes podem abrir caminhos para escalonamento.
Isto deve ser considerado ao decidir os controles de acesso baseado em função (RBAC).</div><h2 id=próximos-passos>Próximos passos</h2><ul><li>Para aprender mais sobre autenticação, visite <strong>Authentication</strong> in <a href=/pt-br/docs/concepts/security/controlling-access/>Controlando acesso a APIs do Kubernetes</a>.</li><li>Para aprender mais sobre Admission Control, visite <a href=/docs/reference/access-authn-authz/admission-controllers/>Utilizando Admission Controllers</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-516f4705fb2f5f62c76c7742772726a3>6.10 - kubeadm token</h1><p>Os Bootstrap tokens são usados para estabelecer uma relação de confiança bidirecional entre um nó que se junta ao cluster e um nó do plano de controle, conforme descrito na <a href=/docs/reference/access-authn-authz/bootstrap-tokens/>autenticação com tokens de inicialização</a>.</p><p>O <code>kubeadm init</code> cria um token inicial com um TTL de 24 horas. Os comandos a seguir permitem que você gerencie esse token e também crie e gerencie os novos.</p><h2 id=cmd-token-create>kubeadm token create</h2><p>Crie tokens de inicialização no servidor</p><h3 id=sinopse>Sinopse</h3><p>Este comando criará um token de inicialização. Você pode especificar os usos para este token, o "tempo de vida" e uma descrição amigável, que é opcional.</p><p>O [token] é o token real para gravar. Este deve ser um token aleatório gerado com segurança da forma "[a-z0-9]{6}.[a-z0-9]{16}". Se nenhum [token] for fornecido, o kubeadm gerará um token aleatório.</p><pre tabindex=0><code>kubeadm token create [token]
</code></pre><h3 id=opções>Opções</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--certificate-key string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Quando usado em conjunto com '--print-join-command', exibe a flag completa 'kubeadm join' necessária para se unir ao cluster como um nó de camada de gerenciamento. Para criar uma nova chave de certificado, você deve usar 'kubeadm init phase upload-certs --upload-certs'.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Caminho para o arquivo de configuração kubeadm.</p></td></tr><tr><td colspan=2>--description string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Uma descrição amigável de como esse token é usado.</p></td></tr><tr><td colspan=2>--groups strings&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "system:bootstrappers:kubeadm:default-node-token"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Grupos extras que este token autenticará quando usado para autenticação. Deve corresponder "\Asystem:bootstrappers:[a-z0-9:-]{0,255}[a-z0-9]\z"</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>ajuda para create</p></td></tr><tr><td colspan=2>--print-join-command</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Em vez de exibir apenas o token, exibe a flag completa 'kubeadm join' necessária para se associar ao cluster usando o token.</p></td></tr><tr><td colspan=2>--ttl duração&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: 24h0m0s</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>A duração antes do token ser excluído automaticamente (por exemplo, 1s, 2m, 3h). Se definido como '0', o token nunca expirará</p></td></tr><tr><td colspan=2>--usages strings&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "signing,authentication"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Descreve as maneiras pelas quais esse token pode ser usado. Você pode passar --usages várias vezes ou fornecer uma lista de opções separada por vírgulas. Opções válidas: [signing,authentication]</p></td></tr></tbody></table><h3 id=opções-herdadas-dos-comandos-superiores>Opções herdadas dos comandos superiores</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--dry-run</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Ativar ou não o modo de execução dry-run</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O arquivo kubeconfig a ser usado para se comunicar com o cluster. Se a flag não estiver definida, um conjunto de locais predefinidos pode ser pesquisado por um arquivo kubeconfig existente.</p></td></tr><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] O caminho para o 'real' sistema de arquivos raiz do host.</p></td></tr></tbody></table><h2 id=cmd-token-delete>kubeadm token delete</h2><p>Excluir tokens de inicialização no servidor</p><h3 id=sinopse>Sinopse</h3><p>Este comando excluirá uma lista de tokens de inicialização para você.</p><p>O [token-value] é um Token completo na forma "[a-z0-9]{6}.[a-z0-9]{16}" ou o ID do Token na forma "[a-z0-9]{6}" a ser excluído.</p><pre tabindex=0><code>kubeadm token delete [token-value] ...
</code></pre><h3 id=opções>Opções</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>ajuda para delete</p></td></tr></tbody></table><h3 id=opções-herdadas-dos-comandos-superiores>Opções herdadas dos comandos superiores</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--dry-run</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Ativar ou não o modo de execução dry-run</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O arquivo kubeconfig a ser usado para se comunicar com o cluster. Se a flag não estiver definida, um conjunto de locais predefinidos pode ser pesquisado por um arquivo kubeconfig existente.</p></td></tr><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] O caminho para o 'real' sistema de arquivos raiz do host.</p></td></tr></tbody></table><h2 id=cmd-token-generate>kubeadm token generate</h2><p>Gere e exiba um token de inicialização, mas não o crie no servidor</p><h3 id=sinopse>Sinopse</h3><p>Este comando exibirá um token de inicialização gerado aleatoriamente que pode ser usado com os comandos "init" e "join".</p><p>Você não precisa usar este comando para gerar um token. Você pode fazer isso sozinho, desde que esteja no formato "[a-z0-9]{6}.[a-z0-9]{16}". Este comando é fornecido por conveniência para gerar tokens no formato fornecido.</p><p>Você também pode usar "kubeadm init" sem especificar um token e ele gerará e exibirá um para você.</p><pre tabindex=0><code>kubeadm token generate [flags]
</code></pre><h3 id=opções>Opções</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>ajuda para generate</p></td></tr></tbody></table><h3 id=opções-herdadas-dos-comandos-superiores>Opções herdadas dos comandos superiores</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--dry-run</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Ativar ou não o modo de execução dry-run</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O arquivo kubeconfig a ser usado para se comunicar com o cluster. Se a flag não estiver definida, um conjunto de locais predefinidos pode ser pesquisado por um arquivo kubeconfig existente.</p></td></tr><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] O caminho para o 'real' sistema de arquivos raiz do host.</p></td></tr></tbody></table><h2 id=cmd-token-list>kubeadm token list</h2><p>Liste tokens de inicialização no servidor</p><h3 id=sinopse>Sinopse</h3><p>Este comando listará todos os tokens de inicialização para você</p><pre tabindex=0><code>kubeadm token list [flags]
</code></pre><h3 id=opções>Opções</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--allow-missing-template-keys&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: true</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Se verdadeiro (true), ignora quaisquer erros nos modelos quando um campo ou chave de mapa estiver faltando no modelo. Aplica-se apenas aos formatos de saída golang e jsonpath.</p></td></tr><tr><td colspan=2>-o, --experimental-output string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "text"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Formato de saída. Valores válidos: text|json|yaml|go-template|go-template-file|template|templatefile|jsonpath|jsonpath-as-json|jsonpath-file.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>ajuda para list</p></td></tr><tr><td colspan=2>--show-managed-fields</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Se verdadeiro (true), mantém os managedFields ao exibir os objetos no formato JSON ou YAML.</p></td></tr></tbody></table><h3 id=opções-herdadas-dos-comandos-superiores>Opções herdadas dos comandos superiores</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--dry-run</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Ativar ou não o modo de execução dry-run</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O arquivo kubeconfig a ser usado para se comunicar com o cluster. Se a flag não estiver definida, um conjunto de locais predefinidos pode ser pesquisado por um arquivo kubeconfig existente.</p></td></tr><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] O caminho para o 'real' sistema de arquivos raiz do host.</p></td></tr></tbody></table><h2 id=próximos-passos>Próximos passos</h2><ul><li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-join>kubeadm join</a> para inicializar um nó de carga de trabalho do Kubernetes e associá-lo ao cluster</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-af7c1f9168ec67f957edc504f43faf9a>6.11 - Problemas e Alertas de Segurança do Kubernetes</h1></div><div class=td-content style=page-break-before:always><h1 id=pg-34c4af6f36d969ed08ba840e7fb64c6d>6.12 - kubeadm version</h1><p>Este comando exibe a versão do kubeadm.</p><p>Exibe a versão do kubeadm</p><h3 id=sinopse>Sinopse</h3><p>Exibe a versão do kubeadm</p><pre tabindex=0><code>kubeadm version [flags]
</code></pre><h3 id=opções>Opções</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>ajuda para version</p></td></tr><tr><td colspan=2>-o, --output string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Formato de saída; as opções disponíveis são 'yaml', 'json' e 'short'</p></td></tr></tbody></table><h3 id=opção-herdada-do-comando-superior>Opção herdada do comando superior</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] O caminho para o 'real' sistema de arquivos raiz do host.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-92a39c69c3689119dd5fa12886cb73a3>6.13 - kubeadm alpha</h1><div class="alert alert-warning caution callout" role=alert><strong>Cuidado:</strong> O <code>kubeadm alpha</code> fornece uma prévia de um conjunto de recursos disponibilizados para coletar feedback da comunidade. Por favor, experimente e nos dê seu feedback!</div><p>Atualmente, não há comandos experimentais sob o <code>kubeadm alpha</code>.</p><h2 id=próximos-passos>Próximos passos</h2><ul><li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-init>kubeadm init</a> para inicializar um nó da camada de gerenciamento do Kubernetes</li><li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-join>kubeadm join</a> para inicializar um nó <code>worker</code> do Kubernetes e associá-lo ao cluster</li><li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-reset>kubeadm reset</a> para reverter quaisquer alterações feitas neste host pelo <code>kubeadm init</code> ou <code>kubeadm join</code></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-6a1fed09235bbf3644c804339928f10e>6.14 - kubeadm certs</h1><p>O <code>kubeadm certs</code> fornece os utilitários para gerenciar os certificados. Para obter mais detalhes sobre como esses comandos podem ser usados, consulte <a href=/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/>Gerenciamento de Certificados com o kubeadm</a>.</p><h2 id=cmd-certs>kubeadm certs</h2><p>Um conjunto de utilitários para usar os certificados Kubernetes</p><ul class="nav nav-tabs" id=tab-certs role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-certs-0 role=tab aria-controls=tab-certs-0 aria-selected=true>visão geral</a></li></ul><div class=tab-content id=tab-certs><div id=tab-certs-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-certs-0><p><p>Comandos relacionados ao manuseio de certificados kubernetes</p><h3 id=sinopse>Sinopse</h3><p>Comandos relacionados ao manuseio de certificados kubernetes</p><h3 id=opções>Opções</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>ajuda para certs</p></td></tr></tbody></table><h3 id=opções-herdadas-do-comando-superior>Opções herdadas do comando superior</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] O caminho para o 'real' sistema de arquivos raiz do host.</p></td></tr></tbody></table></div></div><h2 id=cmd-certs-renew>kubeadm certs renew</h2><p>Você pode renovar todos os certificados Kubernetes usando o subcomando <code>all</code> ou renová-los seletivamente. Para mais detalhes, consulte <a href=/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/#manual-certificate-renewal>Manual de renovação do certificado</a>.</p><ul class="nav nav-tabs" id=tab-certs-renew role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-certs-renew-0 role=tab aria-controls=tab-certs-renew-0 aria-selected=true>renew</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-certs-renew-1 role=tab aria-controls=tab-certs-renew-1>all</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-certs-renew-2 role=tab aria-controls=tab-certs-renew-2>admin.conf</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-certs-renew-3 role=tab aria-controls=tab-certs-renew-3>apiserver-etcd-client</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-certs-renew-4 role=tab aria-controls=tab-certs-renew-4>apiserver-kubelet-client</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-certs-renew-5 role=tab aria-controls=tab-certs-renew-5>apiserver</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-certs-renew-6 role=tab aria-controls=tab-certs-renew-6>controller-manager.conf</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-certs-renew-7 role=tab aria-controls=tab-certs-renew-7>etcd-healthcheck-client</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-certs-renew-8 role=tab aria-controls=tab-certs-renew-8>etcd-peer</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-certs-renew-9 role=tab aria-controls=tab-certs-renew-9>etcd-server</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-certs-renew-10 role=tab aria-controls=tab-certs-renew-10>front-proxy-client</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-certs-renew-11 role=tab aria-controls=tab-certs-renew-11>scheduler.conf</a></li></ul><div class=tab-content id=tab-certs-renew><div id=tab-certs-renew-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-certs-renew-0><p><p>Renove certificados para um cluster Kubernetes</p><h3 id=sinopse>Sinopse</h3><p>Este comando não deve ser executado sozinho. Veja a lista de subcomandos disponíveis.</p><pre tabindex=0><code>kubeadm certs renew [flags]
</code></pre><h3 id=opções>Opções</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>ajuda para renew</p></td></tr></tbody></table><h3 id=opções-herdadas-do-comando-superior>Opções herdadas do comando superior</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] O caminho para o 'real' sistema de arquivos raiz do host.</p></td></tr></tbody></table></div><div id=tab-certs-renew-1 class=tab-pane role=tabpanel aria-labelledby=tab-certs-renew-1><p><p>Renovar todos os certificados disponíveis</p><h3 id=sinopse>Sinopse</h3><p>Renove todos os certificados conhecidos e necessários para executar a camada de gerenciamento. As renovações são executadas incondicionalmente, independentemente da data de expiração. As renovações também podem ser executadas individualmente para obter mais controle.</p><pre tabindex=0><code>kubeadm certs renew all [flags]
</code></pre><h3 id=opções>Opções</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O caminho para salvar os certificados</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Caminho para um arquivo de configuração kubeadm.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>ajuda para all</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O arquivo kubeconfig a ser usado para se comunicar com o cluster. Se a flag não estiver definida, um conjunto de locais predefinidos pode ser pesquisado por um arquivo kubeconfig existente.</p></td></tr></tbody></table><h3 id=opções-herdadas-do-comando-superior>Opções herdadas do comando superior</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] O caminho para o 'real' sistema de arquivos raiz do host.</p></td></tr></tbody></table></div><div id=tab-certs-renew-2 class=tab-pane role=tabpanel aria-labelledby=tab-certs-renew-2><p><p>Renove o certificado incorporado no arquivo kubeconfig para o administrador e o kubeadm usarem</p><h3 id=sinopse>Sinopse</h3><p>Renove o certificado incorporado no arquivo kubeconfig para o administrador e o kubeadm usarem.</p><p>As renovações são executadas incondicionalmente, independentemente da data de expiração do certificado; atributos extras, como SANs, serão baseados no arquivo/certificados existentes, não há necessidade de informá-los novamente.</p><p>A renovação, por padrão, tenta usar a autoridade de certificação na PKI local gerenciada pelo kubeadm; como alternativa, é possível usar a API de certificados do K8s para renovação de certificado, ou como última opção, para gerar uma solicitação CSR.</p><p>Após a renovação, para tornar as alterações efetivas, é necessário reiniciar os componentes da camada de gerenciamento e, eventualmente, redistribuir o certificado renovado, caso o arquivo seja usado em outro lugar.</p><pre tabindex=0><code>kubeadm certs renew admin.conf [flags]
</code></pre><h3 id=opções>Opções</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O caminho para salvar os certificados.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O caminho para um arquivo de configuração kubeadm.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>ajuda para o admin.conf</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O arquivo kubeconfig a ser usado para se comunicar com o cluster. Se a flag não estiver definida, um conjunto de locais predefinidos pode ser pesquisado por um arquivo kubeconfig existente.</p></td></tr></tbody></table><h3 id=opções-herdadas-dos-comandos-superiores>Opções herdadas dos comandos superiores</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] O caminho para o 'real' sistema de arquivos raiz do host.</p></td></tr></tbody></table></div><div id=tab-certs-renew-3 class=tab-pane role=tabpanel aria-labelledby=tab-certs-renew-3><p><p>Renove o certificado que o apiserver usa para acessar o etcd.</p><h3 id=sinopse>Sinopse</h3><p>Renove o certificado que o apiserver usa para acessar o etcd.</p><p>As renovações são executadas incondicionalmente, independentemente da data de expiração do certificado; atributos extras, como SANs, serão baseados no arquivo/certificados existentes, não há necessidade de informá-los novamente.</p><p>A renovação, por padrão, tenta usar a autoridade de certificação na PKI local gerenciada pelo kubeadm; como alternativa, é possível usar a API de certificado K8s para renovação do certificado, ou como última opção, para gerar uma solicitação CSR.</p><p>Após a renovação, para tornar as alterações efetivas, é necessário reiniciar os componentes da camada de gerenciamento e, eventualmente, redistribuir o certificado renovado, caso o arquivo seja usado em outro lugar.</p><pre tabindex=0><code>kubeadm certs renew apiserver-etcd-client [flags]
</code></pre><h3 id=opções>Opções</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O caminho para salvar os certificados</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Caminho para um arquivo de configuração kubeadm.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>ajuda para apiserver-etcd-client</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O arquivo kubeconfig a ser usado para se comunicar com o cluster. Se a flag não estiver definida, um conjunto de locais predefinidos pode ser pesquisado por um arquivo kubeconfig existente.</p></td></tr></tbody></table><h3 id=opções-herdadas-do-comando-superior>Opções herdadas do comando superior</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] O caminho para o 'real' sistema de arquivos raiz do host.</p></td></tr></tbody></table></div><div id=tab-certs-renew-4 class=tab-pane role=tabpanel aria-labelledby=tab-certs-renew-4><p><p>Renove o certificado para o servidor API se conectar ao kubelet</p><h3 id=sinopse>Sinopse</h3><p>Renove o certificado para o servidor da API se conectar ao kubelet.</p><p>As renovações são executadas incondicionalmente, independentemente da data de expiração do certificado; atributos extras, como SANs, serão baseados no arquivo/certificados existentes, não há necessidade de informá-los novamente.</p><p>A renovação, por padrão, tenta usar a autoridade de certificação na PKI local gerenciada pelo kubeadm; como alternativa, é possível usar a API de certificado do K8s para renovação de certificado, ou como última opção, para gerar uma solicitação CSR.</p><p>Após a renovação, para tornar as alterações efetivas, é necessário reiniciar os componentes da camada de gerenciamento e, eventualmente, redistribuir o certificado renovado, caso o arquivo seja usado em outro lugar.</p><pre tabindex=0><code>kubeadm certs renew apiserver-kubelet-client [flags]
</code></pre><h3 id=opções>Opções</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O caminho para salvar os certificados</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Caminho para um arquivo de configuração kubeadm.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>ajuda para apiserver-kubelet-client</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O arquivo kubeconfig a ser usado para se comunicar com o cluster. Se a flag não estiver definida, um conjunto de locais predefinidos pode ser pesquisado por um arquivo kubeconfig existente.</p></td></tr></tbody></table><h3 id=opções-herdadas-do-comando-superior>Opções herdadas do comando superior</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] O caminho para o 'real' sistema de arquivos raiz do host.</p></td></tr></tbody></table></div><div id=tab-certs-renew-5 class=tab-pane role=tabpanel aria-labelledby=tab-certs-renew-5><p><p>Renove o certificado para servir a API do Kubernetes</p><h3 id=sinopse>Sinopse</h3><p>Renove o certificado para servir a API do Kubernetes.</p><p>As renovações são executadas incondicionalmente, independentemente da data de expiração do certificado; atributos extras, como SANs, serão baseados no arquivo/certificados existentes, não há necessidade de informá-los novamente.</p><p>A renovação, por padrão, tenta usar a autoridade de certificação na PKI local gerenciada pelo kubeadm; como alternativa, é possível usar o certificado K8s da API para renovação de certificado, ou como última opção, para gerar uma solicitação CSR.</p><p>Após a renovação, para tornar as alterações efetivas, é necessário reiniciar os componentes da camada de gerenciamento e, eventualmente, redistribuir o certificado renovado, caso o arquivo seja usado em outro lugar.</p><pre tabindex=0><code>kubeadm certs renew apiserver [flags]
</code></pre><h3 id=opções>Opções</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O caminho para salvar os certificados</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Caminho para um arquivo de configuração kubeadm.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>ajuda para apiserver</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O arquivo kubeconfig a ser usado para se comunicar com o cluster. Se a flag não estiver definida, um conjunto de locais predefinidos pode ser pesquisado por um arquivo kubeconfig existente.</p></td></tr></tbody></table><h3 id=opções-herdadas-do-comando-superior>Opções herdadas do comando superior</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] O caminho para o 'real' sistema de arquivos raiz do host.</p></td></tr></tbody></table></div><div id=tab-certs-renew-6 class=tab-pane role=tabpanel aria-labelledby=tab-certs-renew-6><p><p>Renove o certificado incorporado no arquivo kubeconfig para o uso do gerenciador de controladores.</p><h3 id=sinopse>Sinopse</h3><p>Renove o certificado incorporado no arquivo kubeconfig para o uso do gerenciador de controladores.</p><p>As renovações são executadas incondicionalmente, independentemente da data de expiração do certificado; atributos extras, como SANs, serão baseados no arquivo/certificados existentes, não há necessidade de informá-los novamente.</p><p>A renovação, por padrão, tenta usar a autoridade de certificação na PKI local gerenciada pelo kubeadm; como alternativa, é possível usar o certificado K8s da API para renovação de certificado, ou como última opção, para gerar uma solicitação CSR.</p><p>Após a renovação, para tornar as alterações efetivas, é necessário reiniciar os componentes da camada de gerenciamento e, eventualmente, redistribuir o certificado renovado, caso o arquivo seja usado em outro lugar.</p><pre tabindex=0><code>kubeadm certs renew controller-manager.conf [flags]
</code></pre><h3 id=opções>Opções</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O caminho para salvar os certificados</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Caminho para um arquivo de configuração kubeadm.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>ajuda para controller-manager.conf</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O arquivo kubeconfig a ser usado para se comunicar com o cluster. Se a flag não estiver definida, um conjunto de locais predefinidos pode ser pesquisado por um arquivo kubeconfig existente.</p></td></tr></tbody></table><h3 id=opções-herdadas-do-comando-superior>Opções herdadas do comando superior</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] O caminho para o 'real' sistema de arquivos raiz do host.</p></td></tr></tbody></table></div><div id=tab-certs-renew-7 class=tab-pane role=tabpanel aria-labelledby=tab-certs-renew-7><p><p>Renove o certificado para <code>liveness probes</code> para verificar a integridade do etcd</p><h3 id=sinopse>Sinopse</h3><p>Renove o certificado para <code>liveness probes</code> para verificar a integridade do etcd.</p><p>As renovações são executadas incondicionalmente, independentemente da data de expiração do certificado; atributos extras, como SANs, serão baseados no arquivo/certificados existentes, não há necessidade de informá-los novamente.</p><p>A renovação, por padrão, tenta usar a autoridade de certificação na PKI local gerenciada pelo kubeadm; como alternativa, é possível usar o certificado K8s da API para renovação de certificado, ou como última opção, para gerar uma solicitação CSR.</p><p>Após a renovação, para tornar as alterações efetivas, é necessário reiniciar os componentes da camada de gerenciamento e, eventualmente, redistribuir o certificado renovado, caso o arquivo seja usado em outro lugar.</p><pre tabindex=0><code>kubeadm certs renew etcd-healthcheck-client [flags]
</code></pre><h3 id=opções>Opções</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O caminho para salvar os certificados</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Caminho para um arquivo de configuração kubeadm.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>ajuda para etcd-healthcheck-client</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O arquivo kubeconfig a ser usado para se comunicar com o cluster. Se a flag não estiver definida, um conjunto de locais predefinidos pode ser pesquisado por um arquivo kubeconfig existente.</p></td></tr></tbody></table><h3 id=opções-herdadas-do-comando-superior>Opções herdadas do comando superior</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] O caminho para o 'real' sistema de arquivos raiz do host.</p></td></tr></tbody></table></div><div id=tab-certs-renew-8 class=tab-pane role=tabpanel aria-labelledby=tab-certs-renew-8><p><p>Renove o certificado para nós etcd se comunicarem uns com os outros</p><h3 id=sinopse>Sinopse</h3><p>Renove o certificado para nós etcd se comunicarem uns com os outros.</p><p>As renovações são executadas incondicionalmente, independentemente da data de expiração do certificado; atributos extras, como SANs, serão baseados no arquivo/certificados existentes, não há necessidade de informá-los novamente.</p><p>A renovação, por padrão, tenta usar a autoridade de certificação na PKI local gerenciada pelo kubeadm; como alternativa, é possível usar o certificado K8s da API para renovação de certificado, ou como última opção, para gerar uma solicitação CSR.</p><p>Após a renovação, para tornar as alterações efetivas, é necessário reiniciar os componentes da camada de gerenciamento e, eventualmente, redistribuir o certificado renovado, caso o arquivo seja usado em outro lugar.</p><pre tabindex=0><code>kubeadm certs renew etcd-peer [flags]
</code></pre><h3 id=opções>Opções</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O caminho para salvar os certificados</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Caminho para um arquivo de configuração kubeadm.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>ajuda para etcd-peer</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O arquivo kubeconfig a ser usado para se comunicar com o cluster. Se a flag não estiver definida, um conjunto de locais predefinidos pode ser pesquisado por um arquivo kubeconfig existente.</p></td></tr></tbody></table><h3 id=opções-herdadas-do-comando-superior>Opções herdadas do comando superior</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] O caminho para o 'real' sistema de arquivos raiz do host.</p></td></tr></tbody></table></div><div id=tab-certs-renew-9 class=tab-pane role=tabpanel aria-labelledby=tab-certs-renew-9><p><p>Renove o certificado para servir o etcd</p><h3 id=sinopse>Sinopse</h3><p>Renove o certificado para servir o etcd.</p><p>As renovações são executadas incondicionalmente, independentemente da data de expiração do certificado; atributos extras, como SANs, serão baseados no arquivo/certificados existentes, não há necessidade de informá-los novamente.</p><p>A renovação, por padrão, tenta usar a autoridade de certificação na PKI local gerenciada pelo kubeadm; como alternativa, é possível usar o certificado K8s da API para renovação de certificado, ou como última opção, para gerar uma solicitação CSR.</p><p>Após a renovação, para tornar as alterações efetivas, é necessário reiniciar os componentes da camada de gerenciamento e, eventualmente, redistribuir o certificado renovado, caso o arquivo seja usado em outro lugar.</p><pre tabindex=0><code>kubeadm certs renew etcd-server [flags]
</code></pre><h3 id=opções>Opções</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O caminho para salvar os certificados</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Caminho para um arquivo de configuração kubeadm.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>ajuda para etcd-server</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O arquivo kubeconfig a ser usado para se comunicar com o cluster. Se a flag não estiver definida, um conjunto de locais predefinidos pode ser pesquisado por um arquivo kubeconfig existente.</p></td></tr></tbody></table><h3 id=opções-herdadas-do-comando-superior>Opções herdadas do comando superior</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] O caminho para o 'real' sistema de arquivos raiz do host.</p></td></tr></tbody></table></div><div id=tab-certs-renew-10 class=tab-pane role=tabpanel aria-labelledby=tab-certs-renew-10><p><p>Renove o certificado para o cliente front proxy</p><h3 id=sinopse>Sinopse</h3><p>Renove o certificado para o cliente front proxy.</p><p>As renovações são executadas incondicionalmente, independentemente da data de expiração do certificado; atributos extras, como SANs, serão baseados no arquivo/certificados existentes, não há necessidade de informá-los novamente.</p><p>A renovação, por padrão, tenta usar a autoridade de certificação na PKI local gerenciada pelo kubeadm; como alternativa, é possível usar o certificado K8s da API para renovação de certificado, ou como última opção, para gerar uma solicitação CSR.</p><p>Após a renovação, para tornar as alterações efetivas, é necessário reiniciar os componentes da camada de gerenciamento e, eventualmente, redistribuir o certificado renovado, caso o arquivo seja usado em outro lugar.</p><pre tabindex=0><code>kubeadm certs renew front-proxy-client [flags]
</code></pre><h3 id=opções>Opções</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O caminho para salvar os certificados</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Caminho para um arquivo de configuração kubeadm.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>ajuda para front-proxy-client</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O arquivo kubeconfig a ser usado para se comunicar com o cluster. Se a flag não estiver definida, um conjunto de locais predefinidos pode ser pesquisado por um arquivo kubeconfig existente.</p></td></tr></tbody></table><h3 id=opções-herdadas-do-comando-superior>Opções herdadas do comando superior</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] O caminho para o 'real' sistema de arquivos raiz do host.</p></td></tr></tbody></table></div><div id=tab-certs-renew-11 class=tab-pane role=tabpanel aria-labelledby=tab-certs-renew-11><p><p>Renove o certificado incorporado no arquivo kubeconfig para o gerenciador de agendamento usar</p><h3 id=sinopse>Sinopse</h3><p>Renove o certificado incorporado no arquivo kubeconfig para o gerenciador de agendamento usar.</p><p>As renovações são executadas incondicionalmente, independentemente da data de expiração do certificado; atributos extras, como SANs, serão baseados no arquivo/certificados existentes, não há necessidade de informá-los novamente.</p><p>A renovação, por padrão, tenta usar a autoridade de certificação na PKI local gerenciada pelo kubeadm; como alternativa, é possível usar o certificado K8s da API para renovação de certificado, ou como última opção, para gerar uma solicitação CSR.</p><p>Após a renovação, para tornar as alterações efetivas, é necessário reiniciar os componentes da camada de gerenciamento e, eventualmente, redistribuir o certificado renovado, caso o arquivo seja usado em outro lugar.</p><pre tabindex=0><code>kubeadm certs renew scheduler.conf [flags]
</code></pre><h3 id=opções>Opções</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O caminho para salvar os certificados</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Caminho para um arquivo de configuração kubeadm.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>ajuda para scheduler.conf</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O arquivo kubeconfig a ser usado para se comunicar com o cluster. Se a flag não estiver definida, um conjunto de locais predefinidos pode ser pesquisado por um arquivo kubeconfig existente.</p></td></tr></tbody></table><h3 id=opções-herdadas-do-comando-superior>Opções herdadas do comando superior</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] O caminho para o 'real' sistema de arquivos raiz do host.</p></td></tr></tbody></table></div></div><h2 id=cmd-certs-certificate-key>kubeadm certs certificate-key</h2><p>Este comando pode ser usado para gerar uma nova chave do certificado da camada de gerenciamento. A chave pode ser passada como <code>--certificate-key</code> to <a href=/docs/reference/setup-tools/kubeadm/kubeadm-init><code>kubeadm init</code></a> e <a href=/docs/reference/setup-tools/kubeadm/kubeadm-join><code>kubeadm join</code></a> para permitir uma cópia automática dos certificados ao unir nós adicionais a camada de gerenciamento.</p><ul class="nav nav-tabs" id=tab-certs-certificate-key role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-certs-certificate-key-0 role=tab aria-controls=tab-certs-certificate-key-0 aria-selected=true>certificate-key</a></li></ul><div class=tab-content id=tab-certs-certificate-key><div id=tab-certs-certificate-key-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-certs-certificate-key-0><p><p>Gerar as chaves de certificado</p><h3 id=sinopse>Sinopse</h3><p>Este comando exibirá uma chave de certificado segura gerada aleatoriamente que pode ser usada com o comando "init".</p><p>Você também pode usar "kubeadm init --upload-certs" sem especificar uma chave de certificado e ela irá gerar e exibir uma para você.</p><pre tabindex=0><code>kubeadm certs certificate-key [flags]
</code></pre><h3 id=opções>Opções</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>ajuda para certificate-key</p></td></tr></tbody></table><h3 id=opções-herdadas-do-comando-superior>Opções herdadas do comando superior</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] O caminho para o 'real' sistema de arquivos raiz do host.</p></td></tr></tbody></table></div></div><h2 id=cmd-certs-check-expiration>kubeadm certs check-expiration</h2><p>Este comando verifica a expiração dos certificados na PKI local gerenciada pelo kubeadm. Para mais detalhes, consulte <a href=/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/#check-certificate-expiration>Verificar a expiração do certificado</a>.</p><ul class="nav nav-tabs" id=tab-certs-check-expiration role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-certs-check-expiration-0 role=tab aria-controls=tab-certs-check-expiration-0 aria-selected=true>check-expiration</a></li></ul><div class=tab-content id=tab-certs-check-expiration><div id=tab-certs-check-expiration-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-certs-check-expiration-0><p><p>Verifique a expiração dos certificados para um cluster Kubernetes</p><h3 id=sinopse>Sinopse</h3><p>Verifica a expiração dos certificados PKI local gerenciados pelo kubeadm.</p><pre tabindex=0><code>kubeadm certs check-expiration [flags]
</code></pre><h3 id=opções>Opções</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O caminho para salvar os certificados</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Caminho para um arquivo de configuração kubeadm.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>ajuda para check-expiration</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O arquivo kubeconfig usado na comunicação com o cluster. Se a flag não estiver definida, um conjunto de locais padrão pode ser pesquisado em busca de um arquivo kubeconfig existente.</p></td></tr></tbody></table><h3 id=opções-herdadas-do-comando-superior>Opções herdadas do comando superior</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] O caminho para o 'real' sistema de arquivos raiz do host.</p></td></tr></tbody></table></div></div><h2 id=cmd-certs-generate-csr>kubeadm certs generate-csr</h2><p>Este comando pode ser usado para gerar chaves e CSRs para todos os certificados da camada de gerenciamento e arquivos kubeconfig. O usuário pode então assinar os CSRs com uma autoridade de certificação de sua escolha.</p><ul class="nav nav-tabs" id=tab-certs-generate-csr role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-certs-generate-csr-0 role=tab aria-controls=tab-certs-generate-csr-0 aria-selected=true>generate-csr</a></li></ul><div class=tab-content id=tab-certs-generate-csr><div id=tab-certs-generate-csr-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-certs-generate-csr-0><p><p>Gerar chaves e solicitações de assinatura de certificados</p><h3 id=sinopse>Sinopse</h3><p>Gera as chaves e as solicitações de assinatura de certificados (CSRs) para todos os certificados necessários para executar a camada de gerenciamento. Este comando também gera os arquivos kubeconfig parciais com dados de chave privada no campo "users > user > client-key-data" e, para cada arquivo kubeconfig, um arquivo ".csr" correspondente é criado.</p><p>Esse comando foi projetado para uso no <a href=https://kubernetes.io/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/#external-ca-mode>modo de CA externo do Kubeadm</a>. Ele gera CSRs que você pode enviar à sua autoridade de certificação externa para assinatura.</p><p>Os certificados PEM assinados e codificados devem ser salvos juntamente com os arquivos da chave, usando ".crt" como extensão de arquivo ou, no caso de arquivos kubeconfig, o certificado assinado codificado no formato PEM deve ser codificado em base64 e adicionado ao arquivo kubeconfig no campo "users > user > client-certificate-data".</p><pre tabindex=0><code>kubeadm certs generate-csr [flags]
</code></pre><h3 id=exemplos>Exemplos</h3><pre tabindex=0><code>  # O comando a seguir gera as chaves e CSRs para todos os certificados do plano de controle e arquivos kubeconfig: 
  kubeadm certs generate-csr --kubeconfig-dir /tmp/etc-k8s --cert-dir /tmp/etc-k8s/pki
</code></pre><h3 id=opções>Opções</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O caminho para salvar os certificados</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Caminho para um arquivo de configuração kubeadm.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>ajuda para generate-csr</p></td></tr><tr><td colspan=2>--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "/etc/kubernetes"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O caminho para salvar o arquivo kubeconfig.</p></td></tr></tbody></table><h3 id=opções-herdadas-do-comando-superior>Opções herdadas do comando superior</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] O caminho para o 'real' sistema de arquivos raiz do host.</p></td></tr></tbody></table></div></div><h2 id=próximos-passos>Próximos passos</h2><ul><li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-init>kubeadm init</a> para inicializar um nó da camada de gerenciamento do Kubernetes</li><li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-join>kubeadm join</a> para inicializar um nó de carga de trabalho do Kubernetes e associá-lo ao cluster</li><li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-reset>kubeadm reset</a> para reverter quaisquer alterações feitas, neste host, pelo <code>kubeadm init</code> ou <code>kubeadm join</code></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-1ab2d643d770ca684548de4ddbc7d8c4>6.15 - kubeadm kubeconfig</h1><p><code>kubeadm kubeconfig</code> fornece utilitários para gerenciar arquivos kubeconfig.</p><p>Para exemplos de uso do comando <code>kubeadm kubeconfig user</code>, consulte <a href=/docs/tasks/administer-cluster/kubeadm/kubeadm-certs#kubeconfig-additional-users>Gerando arquivos kubeconfig para usuários adicionais</a>.</p><h2 id=cmd-kubeconfig>kubeadm kubeconfig</h2><ul class="nav nav-tabs" id=tab-kubeconfig role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-kubeconfig-0 role=tab aria-controls=tab-kubeconfig-0 aria-selected=true>visão geral</a></li></ul><div class=tab-content id=tab-kubeconfig><div id=tab-kubeconfig-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-kubeconfig-0><p><p>Utilitários de arquivo Kubeconfig</p><h3 id=sinopse>Sinopse</h3><p>Utilitários de arquivo Kubeconfig.</p><h3 id=opções>Opções</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>ajuda para kubeconfig</p></td></tr></tbody></table><h3 id=opções-herdadas-do-comando-superior>Opções herdadas do comando superior</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] O caminho para o 'real' sistema de arquivos raiz do host.</p></td></tr></tbody></table></div></div><h2 id=cmd-kubeconfig-user>kubeadm kubeconfig user</h2><p>Esse comando pode ser usado para gerar um arquivo kubeconfig para um usuário adicional.</p><ul class="nav nav-tabs" id=tab-kubeconfig-user role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-kubeconfig-user-0 role=tab aria-controls=tab-kubeconfig-user-0 aria-selected=true>user</a></li></ul><div class=tab-content id=tab-kubeconfig-user><div id=tab-kubeconfig-user-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-kubeconfig-user-0><p><p>Saída do arquivo kubeconfig para um usuário adicional.</p><h3 id=sinopse>Sinopse</h3><p>Exibe o arquivo kubeconfig para um usuário adicional.</p><pre tabindex=0><code>kubeadm kubeconfig user [flags]
</code></pre><h3 id=exemplos>Exemplos</h3><pre tabindex=0><code>  # Exibe um arquivo kubeconfig para um usuário adicional chamado foo usando um arquivo bar de configuração
  kubeadm kubeconfig user --client-name=foo --config=bar
</code></pre><h3 id=opções>Opções</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--client-name string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O nome do usuário. Será usado como CN se os certificados do cliente forem criados.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Caminho para um arquivo de configuração kubeadm.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>ajuda para user</p></td></tr><tr><td colspan=2>--org strings</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>As organizações do certificado do cliente. Será usado como O se os certificados de cliente forem criados.</p></td></tr><tr><td colspan=2>--token string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O token que deve ser usado como mecanismo de autenticação para esse kubeconfig, em vez de certificados de cliente</p></td></tr><tr><td colspan=2>--validity-period duração&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: 8760h0m0s</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O período de validade do certificado do cliente. É um deslocamento da hora atual.</p></td></tr></tbody></table><h3 id=opções-herdadas-do-comando-superior>Opções herdadas do comando superior</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] O caminho para o 'real' sistema de arquivos raiz do host.</p></td></tr></tbody></table></div></div></div><div class=td-content style=page-break-before:always><h1 id=pg-dfd085b5ab706bd84dda15847dd27f1b>6.16 - kubeadm upgrade phase</h1><p>Na versão v1.15.0, o kubeadm introduziu suporte preliminar para as fases <code>kubeadm upgrade node</code>. Fases para outros subcomandos <code>kubeadm upgrade</code>, tal como <code>apply</code>, podem ser adicionadas nas seguintes versões.</p><h2 id=cmd-node-phase>kubeadm upgrade node phase</h2><p>Usando essa fase, você pode optar por executar as etapas separadas da atualização de nós, sejam eles nós secundários da camada de gerenciamento ou nós de execução de cargas de trabalho. Observe que <code>kubeadm upgrade apply</code> ainda precisa ser chamado em um nó principal da camada de gerenciamento.</p><ul class="nav nav-tabs" id=tab-phase role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-phase-0 role=tab aria-controls=tab-phase-0 aria-selected=true>phase</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-phase-1 role=tab aria-controls=tab-phase-1>preflight</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-phase-2 role=tab aria-controls=tab-phase-2>control-plane</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-phase-3 role=tab aria-controls=tab-phase-3>kubelet-config</a></li></ul><div class=tab-content id=tab-phase><div id=tab-phase-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-phase-0><p><p>Use este comando para invocar uma fase única do fluxo de trabalho do nó</p><h3 id=sinopse>Sinopse</h3><p>Use este comando para invocar uma fase única do fluxo de trabalho do nó</p><h3 id=opções>Opções</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>ajuda para fase</p></td></tr></tbody></table><h3 id=opções-herdadas-dos-comandos-superiores>Opções herdadas dos comandos superiores</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] O caminho para o 'real' sistema de arquivos raiz do host.</p></td></tr></tbody></table></div><div id=tab-phase-1 class=tab-pane role=tabpanel aria-labelledby=tab-phase-1><p><p>Execute verificações antes de atualização do nó</p><h3 id=sinopse>Sinopse</h3><p>Execute verificações antes de atualização do nó</p><pre tabindex=0><code>kubeadm upgrade node phase preflight [flags]
</code></pre><h3 id=opções>Opções</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>ajuda para preflight</p></td></tr><tr><td colspan=2>--ignore-preflight-errors strings</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Uma lista de verificações cujos erros serão mostrados como avisos. Exemplo: 'IsPrivilegedUser,Swap'. O valor 'all' ignora erros de todas as verificações.</p></td></tr></tbody></table><h3 id=opções-herdadas-dos-comandos-superiores>Opções herdadas dos comandos superiores</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] O caminho para o 'real' sistema de arquivos raiz do host.</p></td></tr></tbody></table></div><div id=tab-phase-2 class=tab-pane role=tabpanel aria-labelledby=tab-phase-2><p><p>Atualiza a instância da camada de gerenciamento instalada nesse nó, se houver</p><h3 id=sinopse>Sinopse</h3><p>Atualiza a instância da camada de gerenciamento instalada nesse nó, se houver</p><pre tabindex=0><code>kubeadm upgrade node phase control-plane [flags]
</code></pre><h3 id=opções>Opções</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--certificate-renewal&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: true</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Executa a renovação dos certificados usados pelo componente alterado durante as atualizações.</p></td></tr><tr><td colspan=2>--dry-run</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Não altera nenhum estado, apenas produz as ações que seriam executadas.</p></td></tr><tr><td colspan=2>--etcd-upgrade&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: true</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Atualiza o etcd.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>ajuda para o comando control-plane</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O arquivo kubeconfig a ser usado para se comunicar com o cluster. Se a flag não estiver definida, uma série de locais predefinidos pode ser pesquisado por um arquivo kubeconfig existente.</p></td></tr><tr><td colspan=2>--patches string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O caminho para um diretório que contém arquivos chamados "target[suffix][+patchtype].extension". Por exemplo, "kube-apiserver0+merge.yaml" ou apenas "etcd.json". "target" são "kube-apiserver", "kube-controller-manager", "kube-scheduler", "etcd". "patchtype" pode ser um dos "strategic", "merge" or "json"e eles correspondem aos formatos de patch suportados pelo kubectl. O padrão "patchtype" é "strategic". "extension" deve ser "json" ou "yaml". "suffix" é uma string opcional que pode ser usada para determinar a ordem de aplicação dos patches alfanumericamente.</p></td></tr></tbody></table><h3 id=opções-herdadas-dos-comandos-superiores>Opções herdadas dos comandos superiores</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] O caminho para o 'real' sistema de arquivos raiz do host.</p></td></tr></tbody></table></div><div id=tab-phase-3 class=tab-pane role=tabpanel aria-labelledby=tab-phase-3><p><p>Atualize a configuração do kubelet para este nó</p><h3 id=sinopse>Sinopse</h3><p>Baixa no cluster o ConfigMap de configuração do kubelet no formato "kubelet-config-1.X", onde X é a menor versão do kubelet. O kubeadm usa o campo KuberneteVersion no ConfigMap kubeadm-config para determinar qual é a versão <em>desejada</em> do kubelet.</p><pre tabindex=0><code>kubeadm upgrade node phase kubelet-config [flags]
</code></pre><h3 id=opções>Opções</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--dry-run</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Não altera nenhum estado, apenas produz as ações que seriam executadas.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>ajuda para kubelet-config</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O arquivo kubeconfig a ser usado para se comunicar com o cluster. Se a flag não estiver definida, uma série de locais predefinidos pode ser pesquisado por um arquivo kubeconfig existente.</p></td></tr></tbody></table><h3 id=opções-herdadas-dos-comandos-superiores>Opções herdadas dos comandos superiores</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] O caminho para o 'real' sistema de arquivos raiz do host.</p></td></tr></tbody></table></div></div><h2 id=próximos-passos>Próximos passos</h2><ul><li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-init>kubeadm init</a> para inicializar um nó da camada de gerenciamento do Kubernetes</li><li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-join>kubeadm join</a> para inicializar um nó <code>worker</code> do Kubernetes e associá-lo ao cluster</li><li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-reset>kubeadm reset</a> para reverter quaisquer alterações feitas, neste host, pelo <code>kubeadm init</code> ou <code>kubeadm join</code></li><li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-upgrade>kubeadm upgrade</a> para atualizar um cluster Kubernetes para uma versão mais recente</li><li><a href=/docs/reference/setup-tools/kubeadm/kubeadm-alpha>kubeadm alpha</a> para visualizar um conjunto de recursos disponibilizados para coletar feedback da comunidade</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-8df9aba508b2736a6712ef46227eea7d>6.17 -</h1><p>Comandos relacionados ao manuseio de certificados kubernetes</p><h3 id=sinopse>Sinopse</h3><p>Comandos relacionados ao manuseio de certificados kubernetes</p><h3 id=opções>Opções</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>ajuda para certs</p></td></tr></tbody></table><h3 id=opções-herdadas-do-comando-superior>Opções herdadas do comando superior</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] O caminho para o 'real' sistema de arquivos raiz do host.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-018648dfc6f28bc9b969f45af0563cae>6.18 -</h1><p>Gerar as chaves de certificado</p><h3 id=sinopse>Sinopse</h3><p>Este comando exibirá uma chave de certificado segura gerada aleatoriamente que pode ser usada com o comando "init".</p><p>Você também pode usar "kubeadm init --upload-certs" sem especificar uma chave de certificado e ela irá gerar e exibir uma para você.</p><pre tabindex=0><code>kubeadm certs certificate-key [flags]
</code></pre><h3 id=opções>Opções</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>ajuda para certificate-key</p></td></tr></tbody></table><h3 id=opções-herdadas-do-comando-superior>Opções herdadas do comando superior</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] O caminho para o 'real' sistema de arquivos raiz do host.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-4a1ff27cdf01c1c47d034278048e776b>6.19 -</h1><p>Verifique a expiração dos certificados para um cluster Kubernetes</p><h3 id=sinopse>Sinopse</h3><p>Verifica a expiração dos certificados PKI local gerenciados pelo kubeadm.</p><pre tabindex=0><code>kubeadm certs check-expiration [flags]
</code></pre><h3 id=opções>Opções</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O caminho para salvar os certificados</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Caminho para um arquivo de configuração kubeadm.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>ajuda para check-expiration</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O arquivo kubeconfig usado na comunicação com o cluster. Se a flag não estiver definida, um conjunto de locais padrão pode ser pesquisado em busca de um arquivo kubeconfig existente.</p></td></tr></tbody></table><h3 id=opções-herdadas-do-comando-superior>Opções herdadas do comando superior</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] O caminho para o 'real' sistema de arquivos raiz do host.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-5d6b2999153cd86f56329534249fc4ec>6.20 -</h1><p>Gerar chaves e solicitações de assinatura de certificados</p><h3 id=sinopse>Sinopse</h3><p>Gera as chaves e as solicitações de assinatura de certificados (CSRs) para todos os certificados necessários para executar a camada de gerenciamento. Este comando também gera os arquivos kubeconfig parciais com dados de chave privada no campo "users > user > client-key-data" e, para cada arquivo kubeconfig, um arquivo ".csr" correspondente é criado.</p><p>Esse comando foi projetado para uso no <a href=https://kubernetes.io/docs/tasks/administer-cluster/kubeadm/kubeadm-certs/#external-ca-mode>modo de CA externo do Kubeadm</a>. Ele gera CSRs que você pode enviar à sua autoridade de certificação externa para assinatura.</p><p>Os certificados PEM assinados e codificados devem ser salvos juntamente com os arquivos da chave, usando ".crt" como extensão de arquivo ou, no caso de arquivos kubeconfig, o certificado assinado codificado no formato PEM deve ser codificado em base64 e adicionado ao arquivo kubeconfig no campo "users > user > client-certificate-data".</p><pre tabindex=0><code>kubeadm certs generate-csr [flags]
</code></pre><h3 id=exemplos>Exemplos</h3><pre tabindex=0><code>  # O comando a seguir gera as chaves e CSRs para todos os certificados do plano de controle e arquivos kubeconfig: 
  kubeadm certs generate-csr --kubeconfig-dir /tmp/etc-k8s --cert-dir /tmp/etc-k8s/pki
</code></pre><h3 id=opções>Opções</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O caminho para salvar os certificados</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Caminho para um arquivo de configuração kubeadm.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>ajuda para generate-csr</p></td></tr><tr><td colspan=2>--kubeconfig-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "/etc/kubernetes"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O caminho para salvar o arquivo kubeconfig.</p></td></tr></tbody></table><h3 id=opções-herdadas-do-comando-superior>Opções herdadas do comando superior</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] O caminho para o 'real' sistema de arquivos raiz do host.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-adb5eecdc351074cc2e0cc2b1b4f04a8>6.21 -</h1><p>Renove certificados para um cluster Kubernetes</p><h3 id=sinopse>Sinopse</h3><p>Este comando não deve ser executado sozinho. Veja a lista de subcomandos disponíveis.</p><pre tabindex=0><code>kubeadm certs renew [flags]
</code></pre><h3 id=opções>Opções</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>ajuda para renew</p></td></tr></tbody></table><h3 id=opções-herdadas-do-comando-superior>Opções herdadas do comando superior</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] O caminho para o 'real' sistema de arquivos raiz do host.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-df4c2dc6cba0be90d8d7de2fca9b87f7>6.22 -</h1><p>Renove o certificado incorporado no arquivo kubeconfig para o administrador e o kubeadm usarem</p><h3 id=sinopse>Sinopse</h3><p>Renove o certificado incorporado no arquivo kubeconfig para o administrador e o kubeadm usarem.</p><p>As renovações são executadas incondicionalmente, independentemente da data de expiração do certificado; atributos extras, como SANs, serão baseados no arquivo/certificados existentes, não há necessidade de informá-los novamente.</p><p>A renovação, por padrão, tenta usar a autoridade de certificação na PKI local gerenciada pelo kubeadm; como alternativa, é possível usar a API de certificados do K8s para renovação de certificado, ou como última opção, para gerar uma solicitação CSR.</p><p>Após a renovação, para tornar as alterações efetivas, é necessário reiniciar os componentes da camada de gerenciamento e, eventualmente, redistribuir o certificado renovado, caso o arquivo seja usado em outro lugar.</p><pre tabindex=0><code>kubeadm certs renew admin.conf [flags]
</code></pre><h3 id=opções>Opções</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O caminho para salvar os certificados.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O caminho para um arquivo de configuração kubeadm.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>ajuda para o admin.conf</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O arquivo kubeconfig a ser usado para se comunicar com o cluster. Se a flag não estiver definida, um conjunto de locais predefinidos pode ser pesquisado por um arquivo kubeconfig existente.</p></td></tr></tbody></table><h3 id=opções-herdadas-dos-comandos-superiores>Opções herdadas dos comandos superiores</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] O caminho para o 'real' sistema de arquivos raiz do host.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-6d6746e8ac1f1602f7dab1056b27e5c2>6.23 -</h1><p>Renovar todos os certificados disponíveis</p><h3 id=sinopse>Sinopse</h3><p>Renove todos os certificados conhecidos e necessários para executar a camada de gerenciamento. As renovações são executadas incondicionalmente, independentemente da data de expiração. As renovações também podem ser executadas individualmente para obter mais controle.</p><pre tabindex=0><code>kubeadm certs renew all [flags]
</code></pre><h3 id=opções>Opções</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O caminho para salvar os certificados</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Caminho para um arquivo de configuração kubeadm.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>ajuda para all</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O arquivo kubeconfig a ser usado para se comunicar com o cluster. Se a flag não estiver definida, um conjunto de locais predefinidos pode ser pesquisado por um arquivo kubeconfig existente.</p></td></tr></tbody></table><h3 id=opções-herdadas-do-comando-superior>Opções herdadas do comando superior</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] O caminho para o 'real' sistema de arquivos raiz do host.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-7449c7fa06f25b967cf531e937b0f4b2>6.24 -</h1><p>Renove o certificado que o apiserver usa para acessar o etcd.</p><h3 id=sinopse>Sinopse</h3><p>Renove o certificado que o apiserver usa para acessar o etcd.</p><p>As renovações são executadas incondicionalmente, independentemente da data de expiração do certificado; atributos extras, como SANs, serão baseados no arquivo/certificados existentes, não há necessidade de informá-los novamente.</p><p>A renovação, por padrão, tenta usar a autoridade de certificação na PKI local gerenciada pelo kubeadm; como alternativa, é possível usar a API de certificado K8s para renovação do certificado, ou como última opção, para gerar uma solicitação CSR.</p><p>Após a renovação, para tornar as alterações efetivas, é necessário reiniciar os componentes da camada de gerenciamento e, eventualmente, redistribuir o certificado renovado, caso o arquivo seja usado em outro lugar.</p><pre tabindex=0><code>kubeadm certs renew apiserver-etcd-client [flags]
</code></pre><h3 id=opções>Opções</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O caminho para salvar os certificados</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Caminho para um arquivo de configuração kubeadm.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>ajuda para apiserver-etcd-client</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O arquivo kubeconfig a ser usado para se comunicar com o cluster. Se a flag não estiver definida, um conjunto de locais predefinidos pode ser pesquisado por um arquivo kubeconfig existente.</p></td></tr></tbody></table><h3 id=opções-herdadas-do-comando-superior>Opções herdadas do comando superior</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] O caminho para o 'real' sistema de arquivos raiz do host.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-b5c6ae77d3be9bd358c68667006cfc18>6.25 -</h1><p>Renove o certificado para o servidor API se conectar ao kubelet</p><h3 id=sinopse>Sinopse</h3><p>Renove o certificado para o servidor da API se conectar ao kubelet.</p><p>As renovações são executadas incondicionalmente, independentemente da data de expiração do certificado; atributos extras, como SANs, serão baseados no arquivo/certificados existentes, não há necessidade de informá-los novamente.</p><p>A renovação, por padrão, tenta usar a autoridade de certificação na PKI local gerenciada pelo kubeadm; como alternativa, é possível usar a API de certificado do K8s para renovação de certificado, ou como última opção, para gerar uma solicitação CSR.</p><p>Após a renovação, para tornar as alterações efetivas, é necessário reiniciar os componentes da camada de gerenciamento e, eventualmente, redistribuir o certificado renovado, caso o arquivo seja usado em outro lugar.</p><pre tabindex=0><code>kubeadm certs renew apiserver-kubelet-client [flags]
</code></pre><h3 id=opções>Opções</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O caminho para salvar os certificados</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Caminho para um arquivo de configuração kubeadm.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>ajuda para apiserver-kubelet-client</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O arquivo kubeconfig a ser usado para se comunicar com o cluster. Se a flag não estiver definida, um conjunto de locais predefinidos pode ser pesquisado por um arquivo kubeconfig existente.</p></td></tr></tbody></table><h3 id=opções-herdadas-do-comando-superior>Opções herdadas do comando superior</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] O caminho para o 'real' sistema de arquivos raiz do host.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-4f804e59ec1739e733807d2b591d771f>6.26 -</h1><p>Renove o certificado para servir a API do Kubernetes</p><h3 id=sinopse>Sinopse</h3><p>Renove o certificado para servir a API do Kubernetes.</p><p>As renovações são executadas incondicionalmente, independentemente da data de expiração do certificado; atributos extras, como SANs, serão baseados no arquivo/certificados existentes, não há necessidade de informá-los novamente.</p><p>A renovação, por padrão, tenta usar a autoridade de certificação na PKI local gerenciada pelo kubeadm; como alternativa, é possível usar o certificado K8s da API para renovação de certificado, ou como última opção, para gerar uma solicitação CSR.</p><p>Após a renovação, para tornar as alterações efetivas, é necessário reiniciar os componentes da camada de gerenciamento e, eventualmente, redistribuir o certificado renovado, caso o arquivo seja usado em outro lugar.</p><pre tabindex=0><code>kubeadm certs renew apiserver [flags]
</code></pre><h3 id=opções>Opções</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Default: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O caminho para salvar os certificados</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Caminho para um arquivo de configuração kubeadm.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>ajuda para apiserver</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O arquivo kubeconfig a ser usado para se comunicar com o cluster. Se a flag não estiver definida, um conjunto de locais predefinidos pode ser pesquisado por um arquivo kubeconfig existente.</p></td></tr></tbody></table><h3 id=opções-herdadas-do-comando-superior>Opções herdadas do comando superior</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] O caminho para o 'real' sistema de arquivos raiz do host.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-f5cf8caa95834803b133d53c321ab4a9>6.27 -</h1><p>Renove o certificado incorporado no arquivo kubeconfig para o uso do gerenciador de controladores.</p><h3 id=sinopse>Sinopse</h3><p>Renove o certificado incorporado no arquivo kubeconfig para o uso do gerenciador de controladores.</p><p>As renovações são executadas incondicionalmente, independentemente da data de expiração do certificado; atributos extras, como SANs, serão baseados no arquivo/certificados existentes, não há necessidade de informá-los novamente.</p><p>A renovação, por padrão, tenta usar a autoridade de certificação na PKI local gerenciada pelo kubeadm; como alternativa, é possível usar o certificado K8s da API para renovação de certificado, ou como última opção, para gerar uma solicitação CSR.</p><p>Após a renovação, para tornar as alterações efetivas, é necessário reiniciar os componentes da camada de gerenciamento e, eventualmente, redistribuir o certificado renovado, caso o arquivo seja usado em outro lugar.</p><pre tabindex=0><code>kubeadm certs renew controller-manager.conf [flags]
</code></pre><h3 id=opções>Opções</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O caminho para salvar os certificados</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Caminho para um arquivo de configuração kubeadm.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>ajuda para controller-manager.conf</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O arquivo kubeconfig a ser usado para se comunicar com o cluster. Se a flag não estiver definida, um conjunto de locais predefinidos pode ser pesquisado por um arquivo kubeconfig existente.</p></td></tr></tbody></table><h3 id=opções-herdadas-do-comando-superior>Opções herdadas do comando superior</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] O caminho para o 'real' sistema de arquivos raiz do host.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-ee770858e2bb767b79d572b4882af656>6.28 -</h1><p>Renove o certificado para <code>liveness probes</code> para verificar a integridade do etcd</p><h3 id=sinopse>Sinopse</h3><p>Renove o certificado para <code>liveness probes</code> para verificar a integridade do etcd.</p><p>As renovações são executadas incondicionalmente, independentemente da data de expiração do certificado; atributos extras, como SANs, serão baseados no arquivo/certificados existentes, não há necessidade de informá-los novamente.</p><p>A renovação, por padrão, tenta usar a autoridade de certificação na PKI local gerenciada pelo kubeadm; como alternativa, é possível usar o certificado K8s da API para renovação de certificado, ou como última opção, para gerar uma solicitação CSR.</p><p>Após a renovação, para tornar as alterações efetivas, é necessário reiniciar os componentes da camada de gerenciamento e, eventualmente, redistribuir o certificado renovado, caso o arquivo seja usado em outro lugar.</p><pre tabindex=0><code>kubeadm certs renew etcd-healthcheck-client [flags]
</code></pre><h3 id=opções>Opções</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O caminho para salvar os certificados</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Caminho para um arquivo de configuração kubeadm.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>ajuda para etcd-healthcheck-client</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O arquivo kubeconfig a ser usado para se comunicar com o cluster. Se a flag não estiver definida, um conjunto de locais predefinidos pode ser pesquisado por um arquivo kubeconfig existente.</p></td></tr></tbody></table><h3 id=opções-herdadas-do-comando-superior>Opções herdadas do comando superior</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] O caminho para o 'real' sistema de arquivos raiz do host.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-7484bf11b6183f4c329b1f66734cc886>6.29 -</h1><p>Renove o certificado para nós etcd se comunicarem uns com os outros</p><h3 id=sinopse>Sinopse</h3><p>Renove o certificado para nós etcd se comunicarem uns com os outros.</p><p>As renovações são executadas incondicionalmente, independentemente da data de expiração do certificado; atributos extras, como SANs, serão baseados no arquivo/certificados existentes, não há necessidade de informá-los novamente.</p><p>A renovação, por padrão, tenta usar a autoridade de certificação na PKI local gerenciada pelo kubeadm; como alternativa, é possível usar o certificado K8s da API para renovação de certificado, ou como última opção, para gerar uma solicitação CSR.</p><p>Após a renovação, para tornar as alterações efetivas, é necessário reiniciar os componentes da camada de gerenciamento e, eventualmente, redistribuir o certificado renovado, caso o arquivo seja usado em outro lugar.</p><pre tabindex=0><code>kubeadm certs renew etcd-peer [flags]
</code></pre><h3 id=opções>Opções</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O caminho para salvar os certificados</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Caminho para um arquivo de configuração kubeadm.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>ajuda para etcd-peer</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O arquivo kubeconfig a ser usado para se comunicar com o cluster. Se a flag não estiver definida, um conjunto de locais predefinidos pode ser pesquisado por um arquivo kubeconfig existente.</p></td></tr></tbody></table><h3 id=opções-herdadas-do-comando-superior>Opções herdadas do comando superior</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] O caminho para o 'real' sistema de arquivos raiz do host.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-bf444d915ab856dba693c36294c5427b>6.30 -</h1><p>Renove o certificado para servir o etcd</p><h3 id=sinopse>Sinopse</h3><p>Renove o certificado para servir o etcd.</p><p>As renovações são executadas incondicionalmente, independentemente da data de expiração do certificado; atributos extras, como SANs, serão baseados no arquivo/certificados existentes, não há necessidade de informá-los novamente.</p><p>A renovação, por padrão, tenta usar a autoridade de certificação na PKI local gerenciada pelo kubeadm; como alternativa, é possível usar o certificado K8s da API para renovação de certificado, ou como última opção, para gerar uma solicitação CSR.</p><p>Após a renovação, para tornar as alterações efetivas, é necessário reiniciar os componentes da camada de gerenciamento e, eventualmente, redistribuir o certificado renovado, caso o arquivo seja usado em outro lugar.</p><pre tabindex=0><code>kubeadm certs renew etcd-server [flags]
</code></pre><h3 id=opções>Opções</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O caminho para salvar os certificados</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Caminho para um arquivo de configuração kubeadm.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>ajuda para etcd-server</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O arquivo kubeconfig a ser usado para se comunicar com o cluster. Se a flag não estiver definida, um conjunto de locais predefinidos pode ser pesquisado por um arquivo kubeconfig existente.</p></td></tr></tbody></table><h3 id=opções-herdadas-do-comando-superior>Opções herdadas do comando superior</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] O caminho para o 'real' sistema de arquivos raiz do host.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-f5c087e087714c5290b4967dd7924b3b>6.31 -</h1><p>Renove o certificado para o cliente front proxy</p><h3 id=sinopse>Sinopse</h3><p>Renove o certificado para o cliente front proxy.</p><p>As renovações são executadas incondicionalmente, independentemente da data de expiração do certificado; atributos extras, como SANs, serão baseados no arquivo/certificados existentes, não há necessidade de informá-los novamente.</p><p>A renovação, por padrão, tenta usar a autoridade de certificação na PKI local gerenciada pelo kubeadm; como alternativa, é possível usar o certificado K8s da API para renovação de certificado, ou como última opção, para gerar uma solicitação CSR.</p><p>Após a renovação, para tornar as alterações efetivas, é necessário reiniciar os componentes da camada de gerenciamento e, eventualmente, redistribuir o certificado renovado, caso o arquivo seja usado em outro lugar.</p><pre tabindex=0><code>kubeadm certs renew front-proxy-client [flags]
</code></pre><h3 id=opções>Opções</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O caminho para salvar os certificados</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Caminho para um arquivo de configuração kubeadm.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>ajuda para front-proxy-client</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O arquivo kubeconfig a ser usado para se comunicar com o cluster. Se a flag não estiver definida, um conjunto de locais predefinidos pode ser pesquisado por um arquivo kubeconfig existente.</p></td></tr></tbody></table><h3 id=opções-herdadas-do-comando-superior>Opções herdadas do comando superior</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] O caminho para o 'real' sistema de arquivos raiz do host.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-20703ce1c236264ad78cb1ad7244723e>6.32 -</h1><p>Renove o certificado incorporado no arquivo kubeconfig para o gerenciador de agendamento usar</p><h3 id=sinopse>Sinopse</h3><p>Renove o certificado incorporado no arquivo kubeconfig para o gerenciador de agendamento usar.</p><p>As renovações são executadas incondicionalmente, independentemente da data de expiração do certificado; atributos extras, como SANs, serão baseados no arquivo/certificados existentes, não há necessidade de informá-los novamente.</p><p>A renovação, por padrão, tenta usar a autoridade de certificação na PKI local gerenciada pelo kubeadm; como alternativa, é possível usar o certificado K8s da API para renovação de certificado, ou como última opção, para gerar uma solicitação CSR.</p><p>Após a renovação, para tornar as alterações efetivas, é necessário reiniciar os componentes da camada de gerenciamento e, eventualmente, redistribuir o certificado renovado, caso o arquivo seja usado em outro lugar.</p><pre tabindex=0><code>kubeadm certs renew scheduler.conf [flags]
</code></pre><h3 id=opções>Opções</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O caminho para salvar os certificados</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Caminho para um arquivo de configuração kubeadm.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>ajuda para scheduler.conf</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O arquivo kubeconfig a ser usado para se comunicar com o cluster. Se a flag não estiver definida, um conjunto de locais predefinidos pode ser pesquisado por um arquivo kubeconfig existente.</p></td></tr></tbody></table><h3 id=opções-herdadas-do-comando-superior>Opções herdadas do comando superior</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] O caminho para o 'real' sistema de arquivos raiz do host.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-8f73e208cc67d221165f6294393881a7>6.33 -</h1><p>Exibe uma lista de imagens que o kubeadm usará. O arquivo de configuração é usado caso quaisquer imagens ou repositórios de imagens sejam personalizados.</p><h3 id=sinopse>Sinopse</h3><p>Exibe uma lista de imagens que o kubeadm usará. O arquivo de configuração é usado caso quaisquer imagens ou repositórios de imagens sejam personalizados.</p><pre tabindex=0><code>kubeadm config images list [flags]
</code></pre><h3 id=opções>Opções</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--allow-missing-template-keys&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: true</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Se verdadeiro (true), ignore quaisquer erros nos modelos quando um campo ou chave de mapa estiver faltando no modelo. Aplica-se apenas aos formatos de saída golang e jsonpath.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Caminho para um arquivo de configuração kubeadm.</p></td></tr><tr><td colspan=2>-o, --experimental-output string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "text"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Formato de saída. Valores válidos: text|json|yaml|go-template|go-template-file|template|templatefile|jsonpath|jsonpath-as-json|jsonpath-file.</p></td></tr><tr><td colspan=2>--feature-gates string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Um conjunto de pares chave=valor que descrevem opções para vários recursos. As opções são:<br>PublicKeysECDSA=true|false (ALPHA - padrão=false)<br>RootlessControlPlane=true|false (ALPHA - padrão=false)<br>UnversionedKubeletConfigMap=true|false (ALPHA - padrão=false)</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>ajuda para list</p></td></tr><tr><td colspan=2>--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "k8s.gcr.io"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Escolha um registro de contêineres para baixar imagens da camada de gerenciamento</p></td></tr><tr><td colspan=2>--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "stable-1"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Escolha uma versão específica do Kubernetes para a camada de gerenciamento.</p></td></tr><tr><td colspan=2>--show-managed-fields</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Se verdadeiro, mantém os managedFields ao exibir os objetos no formato JSON ou YAML.</p></td></tr></tbody></table><h3 id=opções-herdadas-do-comando-superior>Opções herdadas do comando superior</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O arquivo kubeconfig a ser usado para se comunicar com o cluster. Se a flag não estiver definida, um conjunto de locais predefinidos pode ser pesquisado por um arquivo kubeconfig existente.</p></td></tr><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] O caminho para o 'real' sistema de arquivos raiz do host.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-9aec3477159c105a46f4479de1c21418>6.34 -</h1><p>Puxe imagens usadas pelo kubeadm</p><h3 id=sinopse>Sinopse</h3><p>Baixa imagens usadas pelo kubeadm</p><pre tabindex=0><code>kubeadm config images pull [flags]
</code></pre><h3 id=opções>Opções</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Caminho para um arquivo de configuração kubeadm.</p></td></tr><tr><td colspan=2>--cri-socket string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Caminho para se conectar ao socket CRI. Se vazio, o kubeadm tentará detectar automaticamente esse valor; use essa opção somente se você tiver mais de um CRI instalado ou se tiver um socket CRI não padrão.</p></td></tr><tr><td colspan=2>--feature-gates string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Um conjunto de pares chave=valor que descrevem feature gates para vários recursos. As opções são:<br>PublicKeysECDSA=true|false (ALPHA - padrão=false)<br>RootlessControlPlane=true|false (ALPHA - padrão=false)<br>UnversionedKubeletConfigMap=true|false (ALPHA - padrão=false)</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>ajuda para pull</p></td></tr><tr><td colspan=2>--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "k8s.gcr.io"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Escolha um registro de contêineres para baixar imagens da camada de gerenciamento</p></td></tr><tr><td colspan=2>--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "stable-1"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Escolha uma versão específica do Kubernetes para a camada de gerenciamento.</p></td></tr></tbody></table><h3 id=opções-herdadas-do-comando-superior>Opções herdadas do comando superior</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O arquivo kubeconfig a ser usado para se comunicar com o cluster. Se a flag não estiver definida, um conjunto de locais predefinidos pode ser pesquisado por um arquivo kubeconfig existente.</p></td></tr><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] O caminho para o 'real' sistema de arquivos raiz do host.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-045e41c28798930e21f77a90c3a90263>6.35 -</h1><p>Leia uma versão mais antiga dos tipos de API de configuração do kubeadm a partir de um arquivo e envie o objeto de configuração semelhante para a versão mais recente</p><h3 id=sinopse>Sinopse</h3><p>Esse comando permite converter objetos de configuração de versões mais antigas para a versão mais recente suportada, localmente na ferramenta CLI sem nunca tocar em nada no cluster. Nesta versão do kubeadm, as seguintes versões da API são suportadas:</p><ul><li>Kubeadm.k8s.io/v1beta3</li></ul><p>Além disso, o kubeadm só pode escrever a configuração da versão "kubeadm.k8s.io/v1beta3", mas pode ler os dois tipos. Portanto, independentemente da versão que você passar para o parâmetro --old-config , o objeto API será lido, desserializado, padronizado, convertido, validado e serializado novamente quando escrito no stdout ou --new-config, se especificado.</p><p>Em outras palavras, a saída deste comando é o que o kubeadm realmente leria internamente se você enviasse este arquivo para "kubeadm init"</p><pre tabindex=0><code>kubeadm config migrate [flags]
</code></pre><h3 id=opções>Opções</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>ajuda para migrate</p></td></tr><tr><td colspan=2>--new-config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Caminho para o arquivo de configuração kubeadm equivalente usando a nova versão da API. Opcional, se não for especificado, a saída será enviada para o STDOUT.</p></td></tr><tr><td colspan=2>--old-config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Caminho para o arquivo de configuração do kubeadm que está usando uma versão antiga da API e que deve ser convertido. Essa flag é obrigatória.</p></td></tr></tbody></table><h3 id=opções-herdadas-do-comando-superior>Opções herdadas do comando superior</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O arquivo kubeconfig a ser usado para se comunicar com o cluster. Se a flag não estiver definida, um conjunto de locais predefinidos pode ser pesquisado por um arquivo kubeconfig existente.</p></td></tr><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] O caminho para o 'real' sistema de arquivos raiz do host.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-e7d83478123771ad14f475ee44440303>6.36 -</h1><p>Exibe configurações</p><h3 id=sinopse>Sinopse</h3><p>Este comando exibe as configurações para subcomandos fornecidos.
Para mais detalhes, consulte: <a href=https://pkg.go.dev/k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm#section-directories>https://pkg.go.dev/k8s.io/kubernetes/cmd/kubeadm/app/apis/kubeadm#section-directories</a></p><pre tabindex=0><code>kubeadm config print [flags]
</code></pre><h3 id=opções>Opções</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>ajuda para print</p></td></tr></tbody></table><h3 id=opções-herdadas-do-comando-superior>Opções herdadas do comando superior</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O arquivo kubeconfig a ser usado para se comunicar com o cluster. Se a flag não estiver definida, um conjunto de locais predefinidos pode ser pesquisado por um arquivo kubeconfig existente.</p></td></tr><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] O caminho para o 'real' sistema de arquivos raiz do host.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-57a6b20d9571220989a7a445d4459468>6.37 -</h1><p>Exibe a configuração de inicialização padrão, que pode ser usada para 'kubeadm init'</p><h3 id=sinopse>Sinopse</h3><p>Este comando exibe objetos, como a configuração de inicialização padrão que é usada para 'kubeadm init'.</p><p>Observe que os valores confidenciais, como os campos do Token Bootstrap, são substituídos por valores de exemplo como "abcdef.0123456789abcdef", a fim de passar na validação, mas não executar o cálculo real para criar um token.</p><pre tabindex=0><code>kubeadm config print init-defaults [flags]
</code></pre><h3 id=opções>Opções</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--component-configs strings</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Uma lista dos objetos da API de configuração, separados por vírgulas, exibirá os valores padrão. Valores disponíveis: [KubeProxyConfiguration KubeletConfiguration]. Se essa flag não estiver definida, nenhuma configuração de componente será impressa.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>ajuda para init-defaults</p></td></tr></tbody></table><h3 id=opções-herdadas-do-comando-superior>Opções herdadas do comando superior</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O arquivo kubeconfig a ser usado para se comunicar com o cluster. Se a flag não estiver definida, um conjunto de locais predefinidos pode ser pesquisado por um arquivo kubeconfig existente.</p></td></tr><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] O caminho para o 'real' sistema de arquivos raiz do host.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-92a2c11eef37937af846b55d9b87a544>6.38 -</h1><p>Exibe a configuração padrão do join, que pode ser usada para 'kubeadm join'</p><h3 id=sinopse>Sinopse</h3><p>Este comando exibe objetos como a configuração padrão de join que é usada para 'kubeadm join'.</p><p>Observe que valores confidenciais, como os campos do Token Bootstrap, são substituídos por valores de exemplo como "abcdef.0123456789abcdef", a fim de passar na validação, mas não executar o cálculo real para criar um token.</p><pre tabindex=0><code>kubeadm config print join-defaults [flags]
</code></pre><h3 id=opções>Opções</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--component-configs strings</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Uma lista dos objetos da API de configuração, separados por vírgulas, exibirá os valores padrão. Valores disponíveis: [KubeProxyConfiguration KubeletConfiguration]. Se essa flag não estiver definida, nenhuma configuração de componente será impressa.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>ajuda para join-defaults</p></td></tr></tbody></table><h3 id=opções-herdadas-do-comando-superior>Opções herdadas do comando superior</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O arquivo kubeconfig a ser usado para se comunicar com o cluster. Se a flag não estiver definida, um conjunto de locais predefinidos pode ser pesquisado por um arquivo kubeconfig existente.</p></td></tr><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] O caminho para o 'real' sistema de arquivos raiz do host.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-dcfffcaafb438cd650475945ddc129ee>6.39 -</h1><p>Rode este comando para configurar a camada de gerenciamento do Kubernetes</p><h3 id=sinopse>Sinopse</h3><p>Rode este comando para configurar a camada de gerenciamento do Kubernetes</p><p>O comando "init" executa as fases abaixo:</p><pre tabindex=0><code>preflight                    Efetua as verificações pré-execução
certs                        Geração de certificados
  /ca                          Gera a autoridade de certificação (CA) auto-assinada do Kubernetes para provisionamento de identidades para outros componentes do Kubernetes
  /apiserver                   Gera o certificado para o servidor da API do Kubernetes
  /apiserver-kubelet-client    Gera o certificado para o servidor da API se conectar ao Kubelet
  /front-proxy-ca              Gera a autoridade de certificação (CA) auto-assinada para provisionamento de identidades para o front proxy
  /front-proxy-client          Gera o certificado para o cliente do front proxy
  /etcd-ca                     Gera a autoridade de certificação (CA) auto-assinada para provisionamento de identidades para o etcd
  /etcd-server                 Gera o certificado para servir o etcd
  /etcd-peer                   Gera o certificado para comunicação entre nós do etcd
  /etcd-healthcheck-client     Gera o certificado para liveness probes fazerem a verificação de integridade do etcd
  /apiserver-etcd-client       Gera o certificado que o servidor da API utiliza para comunicar-se com o etcd
  /sa                          Gera uma chave privada para assinatura de tokens de conta de serviço, juntamente com sua chave pública
kubeconfig                   Gera todos os arquivos kubeconfig necessários para estabelecer a camada de gerenciamento e o arquivo kubeconfig de administração
  /admin                       Gera um arquivo kubeconfig para o administrador e o próprio kubeadm utilizarem
  /kubelet                     Gera um arquivo kubeconfig para o kubelet utilizar *somente* para fins de inicialização do cluster
  /controller-manager          Gera um arquivo kubeconfig para o gerenciador de controladores utilizar
  /scheduler                   Gera um arquivo kubeconfig para o escalonador do Kubernetes utilizar
kubelet-start                Escreve as configurações do kubelet e (re)inicializa o kubelet
control-plane                Gera todos os manifestos de Pods estáticos necessários para estabelecer a camada de gerenciamento
  /apiserver                   Gera o manifesto do Pod estático do kube-apiserver
  /controller-manager          Gera o manifesto do Pod estático do kube-controller-manager
  /scheduler                   Gera o manifesto do Pod estático do kube-scheduler
etcd                         Gera o manifesto do Pod estático para um etcd local
  /local                       Gera o manifesto do Pod estático para uma instância local e de nó único do etcd
upload-config                Sobe a configuração do kubeadm e do kubelet para um ConfigMap
  /kubeadm                     Sobe a configuração ClusterConfiguration do kubeadm para um ConfigMap
  /kubelet                     Sobe a configuração do kubelet para um ConfigMap
upload-certs                 Sobe os certificados para o kubeadm-certs
mark-control-plane           Marca um nó como parte da camada de gerenciamento
bootstrap-token              Gera tokens de autoinicialização utilizados para associar um nó a um cluster
kubelet-finalize             Atualiza configurações relevantes ao kubelet após a inicialização TLS
  /experimental-cert-rotation  Habilita rotação de certificados do cliente do kubelet
addon                        Instala os addons requeridos para passar nos testes de conformidade
  /coredns                     Instala o addon CoreDNS em um cluster Kubernetes
  /kube-proxy                  Instala o addon kube-proxy em um cluster Kubernetes
</code></pre><pre tabindex=0><code>kubeadm init [flags]
</code></pre><h3 id=opções>Opções</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--apiserver-advertise-address string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O endereço IP que o servidor da API irá divulgar que está escutando. Quando não informado, a interface de rede padrão é utilizada.</p></td></tr><tr><td colspan=2>--apiserver-bind-port int32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: 6443</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Porta para o servidor da API conectar-se.</p></td></tr><tr><td colspan=2>--apiserver-cert-extra-sans strings</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Nomes alternativos (<i>Subject Alternative Names</i>, ou SANs) opcionais a serem adicionados ao certificado utilizado pelo servidor da API. Pode conter endereços IP ou nomes DNS.</p></td></tr><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O caminho para salvar e armazenar certificados.</p></td></tr><tr><td colspan=2>--certificate-key string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Chave utilizada para encriptar os certificados da camada de gerenciamento no Secret kubeadm-certs.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Caminho para um arquivo de configuração do kubeadm.</p></td></tr><tr><td colspan=2>--control-plane-endpoint string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Especifica um endereço IP estável ou nome DNS para a camada de gerenciamento.</p></td></tr><tr><td colspan=2>--cri-socket string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Caminho para o soquete CRI se conectar. Se vazio, o kubeadm tentará autodetectar este valor; utilize esta opção somente se você possui mais que um CRI instalado ou se você possui um soquete CRI fora do padrão.</p></td></tr><tr><td colspan=2>--dry-run</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Não aplica as modificações; apenas imprime as alterações que seriam efetuadas.</p></td></tr><tr><td colspan=2>--feature-gates string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Um conjunto de pares chave=valor que descreve <i>feature gates</i> para várias funcionalidades. As opções são:<br>PublicKeysECDSA=true|false (ALFA - padrão=false)<br>RootlessControlPlane=true|false (ALFA - padrão=false)<br>UnversionedKubeletConfigMap=true|false (BETA - padrão=true)</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>ajuda para init</p></td></tr><tr><td colspan=2>--ignore-preflight-errors strings</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Uma lista de verificações para as quais erros serão exibidos como avisos. Exemplos: 'IsPrivilegedUser,Swap'. O valor 'all' ignora erros de todas as verificações.</p></td></tr><tr><td colspan=2>--image-repository string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "k8s.gcr.io"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Seleciona um registro de contêineres de onde baixar imagens.</p></td></tr><tr><td colspan=2>--kubernetes-version string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "stable-1"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Seleciona uma versão do Kubernetes específica para a camada de gerenciamento.</p></td></tr><tr><td colspan=2>--node-name string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Especifica o nome do nó.</p></td></tr><tr><td colspan=2>--patches string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Caminho para um diretório contendo arquivos nomeados no padrão "target[suffix][+patchtype].extension". Por exemplo, "kube-apiserver0+merge.yaml" ou somente "etcd.json".
"target" pode ser um dos seguintes valores: "kube-apiserver", "kube-controller-manager", "kube-scheduler", "etcd".
"patchtype" pode ser "strategic", "merge" ou "json" e corresponde aos formatos de patch suportados pelo kubectl. O valor padrão para "patchtype" é "strategic".
"extension" deve ser "json" ou "yaml". "suffix" é uma string opcional utilizada para determinar quais patches são aplicados primeiro em ordem alfanumérica.</p></td></tr><tr><td colspan=2>--pod-network-cidr string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Especifica um intervalo de endereços IP para a rede do Pod. Quando especificado, a camada de gerenciamento irá automaticamente alocar CIDRs para cada nó.</p></td></tr><tr><td colspan=2>--service-cidr string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "10.96.0.0/12"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Utiliza um intervalo alternativo de endereços IP para VIPs de serviço.</p></td></tr><tr><td colspan=2>--service-dns-domain string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "cluster.local"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Utiliza um domínio alternativo para os serviços. Por exemplo, "myorg.internal".</p></td></tr><tr><td colspan=2>--skip-certificate-key-print</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Não exibe a chave utilizada para encriptar os certificados da camada de gerenciamento.</p></td></tr><tr><td colspan=2>--skip-phases strings</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Lista de fases a serem ignoradas.</p></td></tr><tr><td colspan=2>--skip-token-print</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Pula a impressão do token de autoinicialização padrão gerado pelo comando 'kubeadm init'.</p></td></tr><tr><td colspan=2>--token string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O token a ser utilizado para estabelecer confiança bidirecional entre nós de carga de trabalho e nós da camada de gerenciamento. O formato segue a expressão regular [a-z0-9]{6}.[a-z0-9]{16} - por exemplo, abcdef.0123456789abcdef.</p></td></tr><tr><td colspan=2>--token-ttl duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: 24h0m0s</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>A duração de tempo de um token antes deste ser automaticamente apagado (por exemplo, 1s, 2m, 3h). Quando informado '0', o token não expira.</p></td></tr><tr><td colspan=2>--upload-certs</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Sobe os certificados da camada de gerenciamento para o Secret kubeadm-certs.</p></td></tr></tbody></table><h3 id=opções-herdadas-de-comandos-superiores>Opções herdadas de comandos superiores</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] O caminho para o sistema de arquivos raiz 'real' do host.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-257824537b4c6c6b33249aa786461156>6.40 -</h1><p>Utilitários de arquivo Kubeconfig</p><h3 id=sinopse>Sinopse</h3><p>Utilitários de arquivo Kubeconfig.</p><h3 id=opções>Opções</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>ajuda para kubeconfig</p></td></tr></tbody></table><h3 id=opções-herdadas-do-comando-superior>Opções herdadas do comando superior</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] O caminho para o 'real' sistema de arquivos raiz do host.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-e10faf6f940de61052258af59e036518>6.41 -</h1><p>Saída do arquivo kubeconfig para um usuário adicional.</p><h3 id=sinopse>Sinopse</h3><p>Exibe o arquivo kubeconfig para um usuário adicional.</p><pre tabindex=0><code>kubeadm kubeconfig user [flags]
</code></pre><h3 id=exemplos>Exemplos</h3><pre tabindex=0><code>  # Exibe um arquivo kubeconfig para um usuário adicional chamado foo usando um arquivo bar de configuração
  kubeadm kubeconfig user --client-name=foo --config=bar
</code></pre><h3 id=opções>Opções</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--client-name string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O nome do usuário. Será usado como CN se os certificados do cliente forem criados.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Caminho para um arquivo de configuração kubeadm.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>ajuda para user</p></td></tr><tr><td colspan=2>--org strings</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>As organizações do certificado do cliente. Será usado como O se os certificados de cliente forem criados.</p></td></tr><tr><td colspan=2>--token string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O token que deve ser usado como mecanismo de autenticação para esse kubeconfig, em vez de certificados de cliente</p></td></tr><tr><td colspan=2>--validity-period duração&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: 8760h0m0s</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O período de validade do certificado do cliente. É um deslocamento da hora atual.</p></td></tr></tbody></table><h3 id=opções-herdadas-do-comando-superior>Opções herdadas do comando superior</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] O caminho para o 'real' sistema de arquivos raiz do host.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-a46a193f2322aa88cb3b2de2447b0461>6.42 -</h1><p>Executa o melhor esforço para reverter as alterações feitas no host por 'kubeadm init' ou 'kubeadm join'</p><h3 id=sinopse>Sinopse</h3><p>Executa o melhor esforço para reverter as alterações feitas no host por 'kubeadm init' ou 'kubeadm join'</p><p>O comando "reset" executa as seguintes fases:</p><pre tabindex=0><code>preflight           Executa as verificações pré-execução do preflight.
remove-etcd-member  Remove um membro etcd local.
cleanup-node        Executa a limpeza do nó.
</code></pre><pre tabindex=0><code>kubeadm reset [flags]
</code></pre><h3 id=opções>Opções</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--cert-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "/etc/kubernetes/pki"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O caminho para o diretório onde os certificados estão armazenados. Se especificado, limpe este diretório.</p></td></tr><tr><td colspan=2>--cri-socket string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Caminho para o socket CRI se conectar. Se vazio, o kubeadm tentará detectar automaticamente esse valor; use essa opção somente se você tiver mais de um CRI instalado ou se tiver um socket CRI não padrão.</p></td></tr><tr><td colspan=2>-f, --force</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Redefine o nó sem solicitar confirmação..</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>ajuda para reset</p></td></tr><tr><td colspan=2>--ignore-preflight-errors strings</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Uma lista de verificações cujos erros serão mostrados como avisos. Exemplo: 'IsPrivilegedUser,Swap'. O valor 'all' ignora erros de todas as verificações.</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O arquivo kubeconfig a ser usado para se comunicar com o cluster. Se a flag não estiver definida, um conjunto de locais predefinidos pode ser pesquisado por um arquivo kubeconfig existente.</p></td></tr><tr><td colspan=2>--skip-phases strings</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Lista de fases a serem ignoradas</p></td></tr></tbody></table><h3 id=opções-herdadas-do-comando-superior>Opções herdadas do comando superior</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] O caminho para o 'real' sistema de arquivos raiz do host.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-bdd9680ec894593d17f782d5e5665fd4>6.43 -</h1><p>Crie tokens de inicialização no servidor</p><h3 id=sinopse>Sinopse</h3><p>Este comando criará um token de inicialização. Você pode especificar os usos para este token, o "tempo de vida" e uma descrição amigável, que é opcional.</p><p>O [token] é o token real para gravar. Este deve ser um token aleatório gerado com segurança da forma "[a-z0-9]{6}.[a-z0-9]{16}". Se nenhum [token] for fornecido, o kubeadm gerará um token aleatório.</p><pre tabindex=0><code>kubeadm token create [token]
</code></pre><h3 id=opções>Opções</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--certificate-key string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Quando usado em conjunto com '--print-join-command', exibe a flag completa 'kubeadm join' necessária para se unir ao cluster como um nó de camada de gerenciamento. Para criar uma nova chave de certificado, você deve usar 'kubeadm init phase upload-certs --upload-certs'.</p></td></tr><tr><td colspan=2>--config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Caminho para o arquivo de configuração kubeadm.</p></td></tr><tr><td colspan=2>--description string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Uma descrição amigável de como esse token é usado.</p></td></tr><tr><td colspan=2>--groups strings&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "system:bootstrappers:kubeadm:default-node-token"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Grupos extras que este token autenticará quando usado para autenticação. Deve corresponder "\Asystem:bootstrappers:[a-z0-9:-]{0,255}[a-z0-9]\z"</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>ajuda para create</p></td></tr><tr><td colspan=2>--print-join-command</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Em vez de exibir apenas o token, exibe a flag completa 'kubeadm join' necessária para se associar ao cluster usando o token.</p></td></tr><tr><td colspan=2>--ttl duração&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: 24h0m0s</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>A duração antes do token ser excluído automaticamente (por exemplo, 1s, 2m, 3h). Se definido como '0', o token nunca expirará</p></td></tr><tr><td colspan=2>--usages strings&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "signing,authentication"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Descreve as maneiras pelas quais esse token pode ser usado. Você pode passar --usages várias vezes ou fornecer uma lista de opções separada por vírgulas. Opções válidas: [signing,authentication]</p></td></tr></tbody></table><h3 id=opções-herdadas-dos-comandos-superiores>Opções herdadas dos comandos superiores</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--dry-run</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Ativar ou não o modo de execução dry-run</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O arquivo kubeconfig a ser usado para se comunicar com o cluster. Se a flag não estiver definida, um conjunto de locais predefinidos pode ser pesquisado por um arquivo kubeconfig existente.</p></td></tr><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] O caminho para o 'real' sistema de arquivos raiz do host.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-1d005baad1a1e217d7ae0210fec96c3f>6.44 -</h1><p>Excluir tokens de inicialização no servidor</p><h3 id=sinopse>Sinopse</h3><p>Este comando excluirá uma lista de tokens de inicialização para você.</p><p>O [token-value] é um Token completo na forma "[a-z0-9]{6}.[a-z0-9]{16}" ou o ID do Token na forma "[a-z0-9]{6}" a ser excluído.</p><pre tabindex=0><code>kubeadm token delete [token-value] ...
</code></pre><h3 id=opções>Opções</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>ajuda para delete</p></td></tr></tbody></table><h3 id=opções-herdadas-dos-comandos-superiores>Opções herdadas dos comandos superiores</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--dry-run</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Ativar ou não o modo de execução dry-run</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O arquivo kubeconfig a ser usado para se comunicar com o cluster. Se a flag não estiver definida, um conjunto de locais predefinidos pode ser pesquisado por um arquivo kubeconfig existente.</p></td></tr><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] O caminho para o 'real' sistema de arquivos raiz do host.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-c79d11d27bed54caac743c93e0b2fb24>6.45 -</h1><p>Gere e exiba um token de inicialização, mas não o crie no servidor</p><h3 id=sinopse>Sinopse</h3><p>Este comando exibirá um token de inicialização gerado aleatoriamente que pode ser usado com os comandos "init" e "join".</p><p>Você não precisa usar este comando para gerar um token. Você pode fazer isso sozinho, desde que esteja no formato "[a-z0-9]{6}.[a-z0-9]{16}". Este comando é fornecido por conveniência para gerar tokens no formato fornecido.</p><p>Você também pode usar "kubeadm init" sem especificar um token e ele gerará e exibirá um para você.</p><pre tabindex=0><code>kubeadm token generate [flags]
</code></pre><h3 id=opções>Opções</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>ajuda para generate</p></td></tr></tbody></table><h3 id=opções-herdadas-dos-comandos-superiores>Opções herdadas dos comandos superiores</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--dry-run</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Ativar ou não o modo de execução dry-run</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O arquivo kubeconfig a ser usado para se comunicar com o cluster. Se a flag não estiver definida, um conjunto de locais predefinidos pode ser pesquisado por um arquivo kubeconfig existente.</p></td></tr><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] O caminho para o 'real' sistema de arquivos raiz do host.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-ba78e64c325e4131dd741235e2a1b2c0>6.46 -</h1><p>Liste tokens de inicialização no servidor</p><h3 id=sinopse>Sinopse</h3><p>Este comando listará todos os tokens de inicialização para você</p><pre tabindex=0><code>kubeadm token list [flags]
</code></pre><h3 id=opções>Opções</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--allow-missing-template-keys&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: true</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Se verdadeiro (true), ignora quaisquer erros nos modelos quando um campo ou chave de mapa estiver faltando no modelo. Aplica-se apenas aos formatos de saída golang e jsonpath.</p></td></tr><tr><td colspan=2>-o, --experimental-output string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "text"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Formato de saída. Valores válidos: text|json|yaml|go-template|go-template-file|template|templatefile|jsonpath|jsonpath-as-json|jsonpath-file.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>ajuda para list</p></td></tr><tr><td colspan=2>--show-managed-fields</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Se verdadeiro (true), mantém os managedFields ao exibir os objetos no formato JSON ou YAML.</p></td></tr></tbody></table><h3 id=opções-herdadas-dos-comandos-superiores>Opções herdadas dos comandos superiores</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--dry-run</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Ativar ou não o modo de execução dry-run</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O arquivo kubeconfig a ser usado para se comunicar com o cluster. Se a flag não estiver definida, um conjunto de locais predefinidos pode ser pesquisado por um arquivo kubeconfig existente.</p></td></tr><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] O caminho para o 'real' sistema de arquivos raiz do host.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-19a94d2f7649959b218952cef00729f4>6.47 -</h1><p>Use este comando para invocar uma fase única do fluxo de trabalho do nó</p><h3 id=sinopse>Sinopse</h3><p>Use este comando para invocar uma fase única do fluxo de trabalho do nó</p><h3 id=opções>Opções</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>ajuda para fase</p></td></tr></tbody></table><h3 id=opções-herdadas-dos-comandos-superiores>Opções herdadas dos comandos superiores</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] O caminho para o 'real' sistema de arquivos raiz do host.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-b22d3ed181fb7f926ae2081f8fc8c14d>6.48 -</h1><p>Atualiza a instância da camada de gerenciamento instalada nesse nó, se houver</p><h3 id=sinopse>Sinopse</h3><p>Atualiza a instância da camada de gerenciamento instalada nesse nó, se houver</p><pre tabindex=0><code>kubeadm upgrade node phase control-plane [flags]
</code></pre><h3 id=opções>Opções</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--certificate-renewal&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: true</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Executa a renovação dos certificados usados pelo componente alterado durante as atualizações.</p></td></tr><tr><td colspan=2>--dry-run</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Não altera nenhum estado, apenas produz as ações que seriam executadas.</p></td></tr><tr><td colspan=2>--etcd-upgrade&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: true</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Atualiza o etcd.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>ajuda para o comando control-plane</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O arquivo kubeconfig a ser usado para se comunicar com o cluster. Se a flag não estiver definida, uma série de locais predefinidos pode ser pesquisado por um arquivo kubeconfig existente.</p></td></tr><tr><td colspan=2>--patches string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O caminho para um diretório que contém arquivos chamados "target[suffix][+patchtype].extension". Por exemplo, "kube-apiserver0+merge.yaml" ou apenas "etcd.json". "target" são "kube-apiserver", "kube-controller-manager", "kube-scheduler", "etcd". "patchtype" pode ser um dos "strategic", "merge" or "json"e eles correspondem aos formatos de patch suportados pelo kubectl. O padrão "patchtype" é "strategic". "extension" deve ser "json" ou "yaml". "suffix" é uma string opcional que pode ser usada para determinar a ordem de aplicação dos patches alfanumericamente.</p></td></tr></tbody></table><h3 id=opções-herdadas-dos-comandos-superiores>Opções herdadas dos comandos superiores</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] O caminho para o 'real' sistema de arquivos raiz do host.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-ae1ea74c2c21b25a3c1eacdaf549274b>6.49 -</h1><p>Atualize a configuração do kubelet para este nó</p><h3 id=sinopse>Sinopse</h3><p>Baixa no cluster o ConfigMap de configuração do kubelet no formato "kubelet-config-1.X", onde X é a menor versão do kubelet. O kubeadm usa o campo KuberneteVersion no ConfigMap kubeadm-config para determinar qual é a versão <em>desejada</em> do kubelet.</p><pre tabindex=0><code>kubeadm upgrade node phase kubelet-config [flags]
</code></pre><h3 id=opções>Opções</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--dry-run</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Não altera nenhum estado, apenas produz as ações que seriam executadas.</p></td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>ajuda para kubelet-config</p></td></tr><tr><td colspan=2>--kubeconfig string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Padrão: "/etc/kubernetes/admin.conf"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>O arquivo kubeconfig a ser usado para se comunicar com o cluster. Se a flag não estiver definida, uma série de locais predefinidos pode ser pesquisado por um arquivo kubeconfig existente.</p></td></tr></tbody></table><h3 id=opções-herdadas-dos-comandos-superiores>Opções herdadas dos comandos superiores</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] O caminho para o 'real' sistema de arquivos raiz do host.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-633020ef232bc34f60c82153578a6c9b>6.50 -</h1><p>Execute verificações antes de atualização do nó</p><h3 id=sinopse>Sinopse</h3><p>Execute verificações antes de atualização do nó</p><pre tabindex=0><code>kubeadm upgrade node phase preflight [flags]
</code></pre><h3 id=opções>Opções</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>ajuda para preflight</p></td></tr><tr><td colspan=2>--ignore-preflight-errors strings</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Uma lista de verificações cujos erros serão mostrados como avisos. Exemplo: 'IsPrivilegedUser,Swap'. O valor 'all' ignora erros de todas as verificações.</p></td></tr></tbody></table><h3 id=opções-herdadas-dos-comandos-superiores>Opções herdadas dos comandos superiores</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] O caminho para o 'real' sistema de arquivos raiz do host.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-aa9f718186487df2ab6885cae45f5d37>6.51 -</h1><p>Exibe a versão do kubeadm</p><h3 id=sinopse>Sinopse</h3><p>Exibe a versão do kubeadm</p><pre tabindex=0><code>kubeadm version [flags]
</code></pre><h3 id=opções>Opções</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>ajuda para version</p></td></tr><tr><td colspan=2>-o, --output string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>Formato de saída; as opções disponíveis são 'yaml', 'json' e 'short'</p></td></tr></tbody></table><h3 id=opção-herdada-do-comando-superior>Opção herdada do comando superior</h3><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--rootfs string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word><p>[EXPERIMENTAL] O caminho para o 'real' sistema de arquivos raiz do host.</p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-4f002b9458521ca7afd32176fd590646>6.52 - Ferramentas</h1><p>O Kubernetes contém várias ferramentas internas para ajudá-lo a trabalhar com o sistema Kubernetes.</p><h2 id=kubectl>Kubectl</h2><p><a href=/docs/tasks/tools/install-kubectl/><code>kubectl</code></a> é a ferramenta de linha de comando para o Kubernetes. Ela controla o gerenciador de cluster do Kubernetes.</p><h2 id=kubeadm>Kubeadm</h2><p><a href=/docs/setup/production-environment/tools/kubeadm/install-kubeadm/><code>kubeadm</code></a> é a ferramenta de linha de comando para provisionar facilmente um cluster Kubernetes seguro sobre servidores físicos ou na nuvem ou em máquinas virtuais (atualmente em alfa).</p><h2 id=minikube>Minikube</h2><p><a href=/docs/tasks/tools/install-minikube/><code>minikube</code></a> é uma ferramenta que facilita a execução local de um cluster Kubernetes de nó único em sua estação de trabalho para fins de desenvolvimento e teste.</p><h2 id=dashboard>Dashboard</h2><p><a href=/docs/tasks/access-application-cluster/web-ui-dashboard/><code>Dashboard</code></a>, a interface Web do Kubernetes, permite implantar aplicativos em contêiner em um cluster do Kubernetes, solucionar problemas e gerenciar o cluster e seus próprios recursos.</p><h2 id=helm>Helm</h2><p><a href=https://github.com/kubernetes/helm><code>Kubernetes Helm</code></a> é uma ferramenta para gerenciar pacotes de recursos pré-configurados do Kubernetes, também conhecidos como Kubernetes charts.</p><p>Use o Helm para:</p><ul><li>Encontrar e usar softwares populares empacotados como Kubernetes charts</li><li>Compartilhar seus próprios aplicativos como Kubernetes charts</li><li>Criar builds reproduzíveis de seus aplicativos Kubernetes</li><li>Gerenciar de forma inteligente os arquivos de manifesto do Kubernetes</li><li>Gerenciar versões dos pacotes Helm</li></ul><h2 id=kompose>Kompose</h2><p><a href=https://github.com/kubernetes-incubator/kompose><code>Kompose</code></a> é uma ferramenta para ajudar os usuários do Docker Compose a migrar para o Kubernetes.</p><p>Use o Kompose para:</p><ul><li>Converter um arquivo Docker Compose em objetos Kubernetes</li><li>Ir do desenvolvimento local do Docker ao gerenciamento de seu aplicativo via Kubernetes</li><li>Converter arquivos <code>yaml</code> do Docker Compose v1 ou v2 ou <a href=https://docs.docker.com/compose/bundles/>Bundles de Aplicativos Distribuídos</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-4985cb55ddfb184639d767ec54b9f0f7>7 - Contribua com a documentação do Kubernetes</h1><hr><p><em>O Kubernetes agradece as melhorias de todos os contribuidores, novos e experientes!</em></p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Para saber mais sobre como contribuir o Kubernetes em geral, veja a
<a href=https://www.kubernetes.dev/docs/>documentação para contribuidor</a>.</div><p>Este site é mantido pelo <a href=/docs/contribute/#get-involved-with-sig-docs>Kubernetes SIG Docs</a>.</p><p>Contribuidores da documentação do Kubernetes podem:</p><ul><li>Melhorar o conteúdo existente</li><li>Criar novo conteúdo</li><li>Traduzir a documentação</li><li>Gerenciar e publicar a documentação como parte do ciclo de lançamento do Kubernetes</li></ul><h2 id=começando>Começando</h2><p>Qualquer pessoa pode abrir uma issue sobre a documentação, ou contribuir com uma mudança por meio de um pull request (PR) para o <a href=https://github.com/kubernetes/website>repositório do Github <code>kubernetes/website</code></a>.
É recomendável que você se sinta confortável com <a href=https://git-scm.com/>git</a> e
<a href=https://lab.github.com/>Github</a> para trabalhar efetivamente na comunidade Kubernetes.</p><p>Para se envolver com a documentação:</p><ol><li>Assine o <a href=https://github.com/kubernetes/community/blob/master/CLA.md>Contrato de Licença de Colaborador</a> do CNCF.</li><li>Familiarize-se com o <a href=https://github.com/kubernetes/website>repositório de documentação</a> e o <a href=https://gohugo.io>gerador de site estático</a> hugo.</li><li>Certifique-se de entender os processos básicos para <a href=https://kubernetes.io/docs/contribute/start/#improve-existing-content>melhorar o conteúdo</a> e <a href=https://kubernetes.io/docs/contribute/start/#review-docs-pull-requests>revisar alterações</a>.</li></ol><p>Algumas tarefas requerem mais confiança e mais acessos na organização do Kubernetes.
Veja <a href=/docs/contribute/participate/>Participando no SIG Docs</a> para mais detalhes
sobre funções e permissões.</p><h2 id=sua-primeira-contribuição>Sua primeira contribuição</h2><ul><li>Leia sobre <a href=/docs/contribute/new-content/overview/>visão geral para contribuição</a> para saber mais sobre diferentes formas para você contribuir.</li><li>Veja a <a href=https://github.com/kubernetes/website/issues/>lista de issues em <code>kubernetes/website</code></a> para identificar issues que sejam um bom ponto de partida.</li><li><a href=/docs/contribute/new-content/open-a-pr/#changes-using-github>Abra um pull request usando o Github</a> para documentações existentes e aprenda mais sobre resolver issues no Github.</li><li>Leia sobre o <a href=/docs/contribute/style/content-guide/>guia de conteúdo</a> e <a href=/docs/contribute/style/style-guide/>guias de estilo</a>.</li><li>Leia sobre <a href=/docs/contribute/style/page-content-types/>tipos de conteúdo de páginas</a> e <a href=/docs/contribute/style/hugo-shortcodes/>shortcodes do Hugo</a>.</li></ul><h2 id=próximos-passos>Próximos passos</h2><ul><li>Aprenda a <a href=/docs/contribute/new-content/open-a-pr/#fork-the-repo>trabalhar com um clone local</a> de um repositório.</li><li>Documente <a href=/docs/contribute/new-content/new-features/>funcionalidades em uma release</a>.</li><li>Participe do <a href=/docs/contribute/participate/>SIG Docs</a>, e se torne um
<a href=/docs/contribute/participate/roles-and-responsibilities/>membro ou revisor</a>.</li><li>Comece ou ajude com uma <a href=/docs/contribute/localization/>localização</a>.</li></ul><h2 id=se-envolva-com-o-sig-docs>Se envolva com o SIG Docs</h2><p>O <a href=/docs/contribute/participate/>SIG Docs</a> é um grupo de contribuidores que publica e mantém
a documentação e o site do Kubernetes. Se envolver com o SIG Docs é uma ótima forma de contribuidores Kubernetes (pessoas desenvolvedoras de features ou outros) terem um grande impacto dentro do projeto Kubernetes.</p><p>A comunicação do SIG Docs é feita de diferentes formas:</p><ul><li><a href=https://slack.k8s.io/>Entre em <code>#sig-docs</code> no slack do Kubernetes</a>.</li><li><a href=https://groups.google.com/forum/#!forum/kubernetes-sig-docs>Se inscreva na lista de email <code>kubernetes-dig-docs</code></a>, onde acontecem discussões e
decisões oficiais são registradas.</li><li><a href=https://github.com/kubernetes/community/tree/master/sig-docs>Participe do encontro semanal do SIG Docs</a>. Os encontros são sempre anunciados no <code>#sig-docs</code> e adicionados ao <a href="https://calendar.google.com/calendar/embed?src=cgnt364vd8s86hr2phapfjc6uk%40group.calendar.google.com&ctz=America/Los_Angeles">calendário de eventos de comunidade do Kubernetes</a>. Você precisa baixar o <a href=https://zoom.us/download>cliente do Zoom</a> ou usar um telefone.</li></ul><h2 id=outras-formas-de-contribuir>Outras formas de contribuir</h2><ul><li>Para contribuir com a comunidade Kubernetes por meio de fóruns on-line, como Twitter ou Stack Overflow, ou aprender sobre encontros locais e eventos do Kubernetes, visite a area de <a href=/community/>comunidade Kubernetes</a>.</li><li>Para contribuir com o desenvolvimento de novas funcionalidades, leia o <a href=https://github.com/kubernetes/community/tree/master/contributors/guide/contributor-cheatsheet>cheatsheet do colaborador</a> para começar.</li><li>Leia o <a href=https://github.com/kubernetes/community/tree/master/contributors/guide/contributor-cheatsheet>cheatsheet de contribuidor</a> para saber mais sobre as funcionalidades de desenvolvimento do Kubernetes.</li><li>Submeta <a href=/docs/contribute/new-content/blogs-case-studies/>um post de blog ou um caso de estudo</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-ed3187078744c086d64f3d804a926218>7.1 - Visualizando Analytics do Site</h1><p>Essa página contém informações sobre a dashboard de analystics do kubernetes.io.</p><p>Essa <a href=https://datastudio.google.com/reporting/fede2672-b2fd-402a-91d2-7473bdb10f04>dashboard</a> foi feita usando
o Google Data Studio e possui informações coletadas do
kubernetes.io usando o Google Analytics.</p><h3 id=usando-a-dashboard>Usando a dashboard</h3><p>Por padrão, a dashboard mostra todos os analytics coletados nos últimos 30 dias. Use o seletor de data
para ver dados de outros intervalos de data. Outras
opções de filtros permitem que você veja dados baseados
em localização do usuário para acessar o site, a tradução
da documentação usada e outros.</p><p>Se você identificar um problema com essa dashboard ou quer solicitar qualquer melhoria, <a href=https://github.com/kubernetes/website/issues/new/choose>abra uma issue</a> no repositório.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-91737b3265a3e3f407fbeeb86a8973ab>8 -</h1><script language=javascript>var dropDownsPopulated=!1;$(document).ready(function(){$.get("/metadata.txt",function(e){metadata=$.parseJSON(e),metadata.pages.sort(dynamicSort("t")),mainLogic(),$(window).bind("hashchange",function(){mainLogic()})})});function mainLogic(){dropDownsPopulated||populateDropdowns();var e=window.location.hash.replace("#","");if(e){e=$.trim(e);for(i=0;i<tagName.length;i++)querystringTag=tagName[i]+"=",e.indexOf(querystringTag)>-1&&(console.log("in mainLog: querystringTag of "+querystringTag+" matches tag of "+e),e=e.replace(querystringTag,""),selectDropDown(tagName[i],e),topicsFilter(tagName[i],e,"output"))}else currentTopics=metadata.pages;renderTable(currentTopics,"output")}function populateDropdowns(){for(i=0;i<metadata.pages.length;i++){var e,t=[metadata.pages[i].cr,metadata.pages[i].or,metadata.pages[i].mr];for(j=0;j<t.length;j++)if(t[j])for(k=0;k<t[j].length;k++)typeof storedTagsArrays[j]=="undefined"&&(storedTagsArrays[j]=new Array),storedTagsArrays[j][t[j][k][tagName[j]]]=!0}e=new Array;for(i=0;i<tagName.length;i++)e=[],e.push("<select id='"+tagName[i]+"' onchange='dropFilter(this)'>"),e.push("<option>---</option>"),Object.keys(storedTagsArrays[i]).sort().forEach(function(t){e.push("<option>"+t+"</option>")}),e.push("</select>"),$(dropDowns[i]).html(e.join(""));dropDownsPopulated=!0}function dropFilter(e){console.log("dropFilter:"+$(e).attr("id")+":"+$(e).find(":selected").text()),topicsFilter($(e).attr("id").replace("#",""),$(e).find(":selected").text(),"output");for(i=0;i<tagName.length;i++)$(e).attr("id")!=tagName[i]&&selectDropDown(tagName[i],"---")}function selectDropDown(e,t){$("#"+e).val(t)}</script><style>#filters select{font-size:14px;border:1px #000 solid}#filters{padding-top:20px}</style><p>Clique nas tags ou use as listas suspensas para filtrar. Clique nos cabeçalhos das tabelas para classificar ou inverter a classificação.</p><p id=filters>Filtrar por Conceito: <span id=conceptFilter><br>Filtrar por objeto: <span id=objectFilter><br>Filtrar por Comando: <span id=commandFilter></p><div id=output></div><div class=td-content style=page-break-before:always><h1 id=pg-8ce5371351476b7b76c7eb723eac4417>9 - Resultados da pesquisa</h1></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/pt-br/docs/home/>Home</a>
<a class=text-white href=/pt-br/blog/>Blog</a>
<a class=text-white href=/pt-br/partners/>Parceiros</a>
<a class=text-white href=/pt-br/community/>Comunidade</a>
<a class=text-white href=/pt-br/case-studies/>Casos de estudo</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 Os autores do Kubernetes | Documentação Distribuída sob <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small><br><small class=text-white>Copyright &copy; 2023 A Fundação Linux &reg;. Todos os direitos reservados. A Linux Foundation tem marcas registradas e usa marcas registradas. Para uma lista de marcas registradas da The Linux Foundation, por favor, veja nossa <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>Página de uso de marca registrada</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>