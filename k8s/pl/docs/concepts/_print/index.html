<!doctype html><html lang=pl class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=en href=https://kubernetes.io/docs/concepts/><link rel=alternate hreflang=zh-cn href=https://kubernetes.io/zh-cn/docs/concepts/><link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/concepts/><link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/concepts/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/concepts/><link rel=alternate hreflang=it href=https://kubernetes.io/it/docs/concepts/><link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/concepts/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/concepts/><link rel=alternate hreflang=pt-br href=https://kubernetes.io/pt-br/docs/concepts/><link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/concepts/><link rel=alternate hreflang=ru href=https://kubernetes.io/ru/docs/concepts/><link rel=alternate hreflang=uk href=https://kubernetes.io/uk/docs/concepts/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/pl/docs/concepts/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>Pojęcia | Kubernetes</title><meta property="og:title" content="Pojęcia"><meta property="og:description" content="Produkcyjny system zarządzania kontenerami"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/pl/docs/concepts/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="Pojęcia"><meta itemprop=description content="Produkcyjny system zarządzania kontenerami"><meta name=twitter:card content="summary"><meta name=twitter:title content="Pojęcia"><meta name=twitter:description content="Produkcyjny system zarządzania kontenerami"><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content="Rozdział dotyczący pojęć ma za zadanie pomóc w zrozumieniu poszczególnych składowych systemu oraz obiektów abstrakcyjnych, których Kubernetes używa do reprezentacji klastra, a także posłużyć do lepszego poznania działania całego systemu."><meta property="og:description" content="Rozdział dotyczący pojęć ma za zadanie pomóc w zrozumieniu poszczególnych składowych systemu oraz obiektów abstrakcyjnych, których Kubernetes używa do reprezentacji klastra, a także posłużyć do lepszego poznania działania całego systemu."><meta name=twitter:description content="Rozdział dotyczący pojęć ma za zadanie pomóc w zrozumieniu poszczególnych składowych systemu oraz obiektów abstrakcyjnych, których Kubernetes używa do reprezentacji klastra, a także posłużyć do lepszego poznania działania całego systemu."><meta property="og:url" content="https://kubernetes.io/pl/docs/concepts/"><meta property="og:title" content="Pojęcia"><meta name=twitter:title content="Pojęcia"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/pl/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/pl/docs/>Dokumentacja</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/pl/training/>Szkolenia</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Wersje</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/pl/releases>Informacje o wydaniu</a>
<a class=dropdown-item href=https://kubernetes.io/pl/docs/concepts/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/pl/docs/concepts/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/pl/docs/concepts/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/pl/docs/concepts/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/pl/docs/concepts/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Polski (Polish)</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/docs/concepts/>English</a>
<a class=dropdown-item href=/zh-cn/docs/concepts/>中文 (Chinese)</a>
<a class=dropdown-item href=/ko/docs/concepts/>한국어 (Korean)</a>
<a class=dropdown-item href=/ja/docs/concepts/>日本語 (Japanese)</a>
<a class=dropdown-item href=/fr/docs/concepts/>Français (French)</a>
<a class=dropdown-item href=/it/docs/concepts/>Italiano (Italian)</a>
<a class=dropdown-item href=/de/docs/concepts/>Deutsch (German)</a>
<a class=dropdown-item href=/es/docs/concepts/>Español (Spanish)</a>
<a class=dropdown-item href=/pt-br/docs/concepts/>Português (Portuguese)</a>
<a class=dropdown-item href=/id/docs/concepts/>Bahasa Indonesia</a>
<a class=dropdown-item href=/ru/docs/concepts/>Русский (Russian)</a>
<a class=dropdown-item href=/uk/docs/concepts/>Українська (Ukrainian)</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>To wielostronicowy widok tej sekcji do wydrukowania.
<a href=# onclick="return print(),!1">Kliknij aby wydrukować</a>.</p><p><a href=/pl/docs/concepts/>Wróć do zwykłego widoku tej strony</a>.</p></div><h1 class=title>Pojęcia</h1><ul><li>1: <a href=#pg-0554ac387412eaf4e6e89b2f847dacde>Przegląd</a></li><ul><li>1.1: <a href=#pg-45bdca6129cf540121623e903c18ba46>Kubernetes — co to jest?</a></li><li>1.2: <a href=#pg-13b0f1dbe89228e3d76d2ac231e245f1>Składniki Kubernetesa</a></li><li>1.3: <a href=#pg-0c745f42e623d2b70a53bc0e6db73d95>API Kubernetesa</a></li></ul></ul><div class=content><p>Rozdział dotyczący pojęć ma za zadanie pomóc w zrozumieniu poszczególnych składowych systemu oraz obiektów abstrakcyjnych, których Kubernetes używa do reprezentacji <a class=glossary-tooltip title='Zestaw maszyn roboczych, nazywanych , na których uruchamiane są aplikacje w kontenerach. Każdy klaster musi posiadać przynajmniej jeden węzeł.' data-toggle=tooltip data-placement=top href='/pl/docs/reference/glossary/?all=true#term-cluster' target=_blank aria-label=klastra>klastra</a>, a także posłużyć do lepszego poznania działania całego systemu.</p></div></div><div class=td-content><h1 id=pg-0554ac387412eaf4e6e89b2f847dacde>1 - Przegląd</h1><div class=lead>Ogólny zarys Kubernetesa i komponentów, z których jest zbudowany.</div></div><div class=td-content><h1 id=pg-45bdca6129cf540121623e903c18ba46>1.1 - Kubernetes — co to jest?</h1><div class=lead>Kubernetes to przenośna, rozszerzalna platforma oprogramowania <em>open-source</em> służąca do zarządzania zadaniami i serwisami uruchamianymi w kontenerach. Umożliwia ich deklaratywną konfigurację i automatyzację. Kubernetes posiada duży i dynamicznie rozwijający się ekosystem. Szeroko dostępne są serwisy, wsparcie i dodatkowe narzędzia.</div><p>Na tej stronie znajdziesz ogólne informacje o Kubernetesie.</p><p>Kubernetes to przenośna, rozszerzalna platforma oprogramowania <em>open-source</em> służąca do zarządzania zadaniami i serwisami uruchamianymi w kontenerach, która umożliwia deklaratywną konfigurację i automatyzację. Ekosystem Kubernetesa jest duży i dynamicznie się rozwija. Serwisy Kubernetesa, wsparcie i narzędzia są szeroko dostępne.</p><p>Nazwa Kubernetes pochodzi z greki i oznacza sternika albo pilota. Skrót K8s powstał poprzez zastąpienie ośmiu liter pomiędzy "K" i "s" .Google otworzyło projekt Kubernetes publicznie w 2014. Kubernetes korzysta z <a href=/blog/2015/04/borg-predecessor-to-kubernetes/>piętnastoletniego doświadczenia Google w uruchamianiu wielkoskalowych serwisów</a> i łączy je z najlepszymi pomysłami i praktykami wypracowanymi przez społeczność.</p><h2 id=trochę-historii>Trochę historii</h2><p>Aby zrozumieć, dlaczego Kubernetes stał się taki przydatny, cofnijmy sie trochę w czasie.</p><p><img src=/images/docs/Container_Evolution.svg alt="Jak zmieniały sie metody wdrożeń"></p><p><strong>Era wdrożeń tradycyjnych:</strong>
Na początku aplikacje uruchamiane były na fizycznych serwerach. Nie było możliwości separowania zasobów poszczególnych aplikacji, co prowadziło do problemów z alokacją zasobów. Przykładowo, kiedy wiele aplikacji jest uruchomionych na jednym fizycznym serwerze, część tych aplikacji może zużyć większość dostępnych zasobów, powodując spowolnienie działania innych. Rozwiązaniem tego problemu mogło być uruchamianie każdej aplikacji na osobnej maszynie. Niestety, takie podejście ograniczało skalowanie, ponieważ większość zasobów nie była w pełni wykorzystywana, a utrzymanie wielu fizycznych maszyn było kosztowne.</p><p><strong>Era wdrożeń w środowiskach wirtualnych:</strong><br>Jako rozwiązanie zaproponowano wirtualizację, która umożliwiała uruchamianie wielu maszyn wirtualnych (VM) na jednym procesorze fizycznego serwera. Wirtualizacja pozwalała izolować aplikacje pomiędzy maszynami wirtualnymi i osiągnąć pewien poziom bezpieczeństwa, jako że informacje związane z jedną aplikacją nie były w łatwy sposób dostępne dla pozostałych.</p><p>Wirtualizacja pozwala lepiej wykorzystywać zasoby fizycznego serwera i lepiej skalować, ponieważ aplikacje mogą być łatwo dodawane oraz aktualizowane, pozwala ograniczyć koszty sprzętu oraz ma wiele innych zalet. Za pomocą wirtualizacji można udostępnić wybrane zasoby fizyczne jako klaster maszyn wirtualnych "wielokrotnego użytku".</p><p>Każda maszyna wirtualna jest pełną maszyną zawierającą własny system operacyjny pracujący na zwirtualizowanej warstwie sprzętowej.</p><p><strong>Era wdrożeń w kontenerach:</strong>
Kontenery działają w sposób zbliżony do maszyn wirtualnych, ale mają mniejszy stopnień wzajemnej izolacji, współdzieląc ten sam system operacyjny. Kontenery określane są mianem "lekkich". Podobnie, jak maszyna wirtualna, kontener posiada własny system plików, udział w zasobach procesora, pamięć, przestrzeń procesów itd. Ponieważ kontenery nie są związane z leżącymi poniżej warstwami infrastruktury, mogą być łatwiej przenoszone pomiędzy chmurami i różnymi dystrybucjami systemu operacyjnego.</p><p>Kontenery zyskały popularność ze względu na swoje zalety, takie jak:</p><ul><li>Szybkość i elastyczność w tworzeniu i instalacji aplikacji: obraz kontenera buduje się łatwiej niż obraz VM.</li><li>Ułatwienie ciągłego rozwoju, integracji oraz wdrażania aplikacji (<em>Continuous development, integration, and deployment</em>): obrazy kontenerów mogą być budowane w sposób wiarygodny i częsty. Wycofywanie zmian jest skuteczne i szybkie (ponieważ obrazy są niezmienne).</li><li>Rozdzielenie zadań <em>Dev</em> i <em>Ops</em>: obrazy kontenerów powstają w fazie <em>build/release</em>, oddzielając w ten sposób aplikacje od infrastruktury.</li><li>Obserwowalność obejmuje nie tylko informacje i metryki z poziomu systemu operacyjnego, ale także poprawność działania samej aplikacji i inne sygnały.</li><li>Spójność środowiska na etapach rozwoju oprogramowania, testowania i działania w trybie produkcyjnym: działa w ten sam sposób na laptopie i w chmurze.</li><li>Możliwość przenoszenia pomiędzy systemami operacyjnymi i platformami chmurowymi: Ubuntu, RHEL, CoreOS, prywatnymi centrami danych, największymi dostawcami usług chmurowych czy gdziekolwiek indziej.</li><li>Zarządzanie, które w centrum uwagi ma aplikacje: Poziom abstrakcji przeniesiony jest z warstwy systemu operacyjnego działającego na maszynie wirtualnej na poziom działania aplikacji, która działa na systemie operacyjnym używając zasobów logicznych.</li><li>Luźno powiązane, rozproszone i elastyczne "swobodne" mikro serwisy: Aplikacje podzielone są na mniejsze, niezależne komponenty, które mogą być dynamicznie uruchamiane i zarządzane - nie jest to monolityczny system działający na jednej, dużej maszynie dedykowanej na wyłączność.</li><li>Izolacja zasobów: wydajność aplikacji możliwa do przewidzenia</li><li>Wykorzystanie zasobów: wysoka wydajność i upakowanie.</li></ul><h2 id=do-czego-potrzebujesz-kubernetesa-i-jakie-są-jego-możliwości>Do czego potrzebujesz Kubernetesa i jakie są jego możliwości</h2><p>Kontenery są dobrą metodą na opakowywanie i uruchamianie aplikacji. W środowisku produkcyjnym musisz zarządzać kontenerami, w których działają aplikacje i pilnować, aby nie było żadnych przerw w ich dostępności. Przykładowo, kiedy jeden z kontenerów przestaje działać, inny musi zostać uruchomiony. Nie byłoby prościej, aby takimi działaniami zajmował się jakiś system?</p><p>I tu właśnie Kubernetes przychodzi z pomocą! Kubernetes dostarcza środowisko do uruchamiania systemów rozproszonych o wysokiej niezawodności. Kubernetes obsługuje skalowanie aplikacji, przełączanie w sytuacjach awaryjnych, różne scenariusze wdrożeń itp. Przykładowo, Kubernetes w łatwy sposób może zarządzać wdrożeniem nowej wersji oprogramowania zgodnie z metodyką <em>canary deployments</em>.</p><p>Kubernetes zapewnia:</p><ul><li><strong>Detekcję nowych serwisów i balansowanie ruchu</strong>
Kubernetes może udostępnić kontener używając nazwy DNS lub swojego własnego adresu IP. Jeśli ruch przychodzący do kontenera jest duży, Kubernetes może balansować obciążenie i przekierować ruch sieciowy, aby zapewnić stabilność całej instalacji.</li><li><strong>Zarządzanie obsługą składowania danych</strong>
Kubernetes umożliwia automatyczne montowanie systemów składowania danych dowolnego typu — lokalnych, od dostawców chmurowych i innych.</li><li><strong>Automatyczne wdrożenia i wycofywanie zmian</strong>
Możesz opisać oczekiwany stan instalacji za pomocą Kubernetesa, który zajmie się doprowadzeniem w sposób kontrolowany stanu faktycznego do stanu oczekiwanego. Przykładowo, przy pomocy Kubernetesa możesz zautomatyzować proces tworzenia nowych kontenerów na potrzeby swojego wdrożenia, usuwania istniejących i przejęcia zasobów przez nowe kontenery.</li><li><strong>Automatyczne zarządzanie dostępnymi zasobami</strong>
Twoim zadaniem jest dostarczenie klastra maszyn, które Kubernetes może wykorzystać do uruchamiania zadań w kontenerach. Określasz zapotrzebowanie na moc procesora i pamięć RAM dla każdego z kontenerów. Kubernetes rozmieszcza kontenery na maszynach w taki sposób, aby jak najlepiej wykorzystać dostarczone zasoby.</li><li><strong>Samoczynne naprawianie</strong>
Kubernetes restartuje kontenery, które przestały działać, wymienia je na nowe, wymusza wyłączenie kontenerów, które nie odpowiadają na określone zapytania o stan i nie rozgłasza powiadomień o ich dostępności tak długo, dopóki nie są gotowe do działania.</li><li><strong>Zarządzanie informacjami poufnymi i konfiguracją</strong>
Kubernetes pozwala składować i zarządzać informacjami poufnymi, takimi jak hasła, tokeny OAuth i klucze SSH. Informacje poufne i zawierające konfigurację aplikacji mogą być dostarczane i zmieniane bez konieczności ponownego budowania obrazu kontenerów i bez ujawniania poufnych danych w ogólnej konfiguracji oprogramowania.</li></ul><h2 id=czym-kubernetes-nie-jest>Czym Kubernetes nie jest</h2><p>Kubernetes nie jest tradycyjnym, zawierającym wszystko systemem PaaS <em>(Platform as a Service)</em>. Ponieważ Kubernetes działa w warstwie kontenerów, a nie sprzętu, posiada różne funkcjonalności ogólnego zastosowania, wspólne dla innych rozwiązań PaaS, takie jak: instalacje <em>(deployments)</em>, skalowanie i balansowanie ruchu, umożliwiając użytkownikom integrację rozwiązań służących do logowania, monitoringu i ostrzegania. Co ważne, Kubernetes nie jest monolitem i domyślnie dostępne rozwiązania są opcjonalne i działają jako wtyczki. Kubernetes dostarcza elementy, z których może być zbudowana platforma deweloperska, ale pozostawia użytkownikowi wybór i elastyczność tam, gdzie jest to ważne.</p><p>Kubernetes:</p><ul><li>Nie ogranicza typów aplikacji, które są obsługiwane. Celem Kubernetesa jest możliwość obsługi bardzo różnorodnego typu zadań, włączając w to aplikacje bezstanowe (<em>stateless</em>), aplikacje ze stanem (<em>stateful</em>) i ogólne przetwarzanie danych. Jeśli jakaś aplikacja może działać w kontenerze, będzie doskonale sobie radzić w środowisku Kubernetesa.</li><li>Nie oferuje wdrażania aplikacji wprost z kodu źródłowego i nie buduje aplikacji. Procesy Continuous Integration, Delivery, and Deployment (CI/CD) są zależne od kultury pracy organizacji, jej preferencji oraz wymagań technicznych.</li><li>Nie dostarcza serwisów z warstwy aplikacyjnej, takich jak warstwy pośrednie <em>middleware</em> (np. broker wiadomości), środowiska analizy danych (np. Spark), bazy danych (np. MySQL), cache ani klastrowych systemów składowania danych (np. Ceph) jako usług wbudowanych. Te składniki mogą być uruchamiane na klastrze Kubernetes i udostępniane innym aplikacjom przez przenośne rozwiązania, takie jak <a href=https://openservicebrokerapi.org/>Open Service Broker</a>.</li><li>Nie wymusza użycia konkretnych systemów zbierania logów, monitorowania ani ostrzegania. Niektóre z tych rozwiązań są udostępnione jako przykłady. Dostępne są też mechanizmy do gromadzenia i eksportowania różnych metryk.</li><li>Nie dostarcza, ani nie wymusza języka/systemu używanego do konfiguracji (np. Jsonnet). Udostępnia API typu deklaratywnego, z którego można korzystać za pomocą różnych metod wykorzystujących deklaratywne specyfikacje.</li><li>Nie zapewnia, ani nie wykorzystuje żadnego ogólnego systemu do zarządzania konfiguracją, utrzymaniem i samo-naprawianiem maszyn.</li><li>Co więcej, nie jest zwykłym systemem planowania <em>(orchestration)</em>. W rzeczywistości, eliminuje konieczność orkiestracji. Zgodnie z definicją techniczną, orkiestracja to wykonywanie określonego ciągu zadań: najpierw A, potem B i następnie C. Dla kontrastu, Kubernetes składa się z wielu niezależnych, możliwych do złożenia procesów sterujących, których zadaniem jest doprowadzenie stanu faktycznego do stanu oczekiwanego. Nie ma znaczenia, w jaki sposób przechodzi się od A do C. Nie ma konieczności scentralizowanego zarządzania. Dzięki temu otrzymujemy system, który jest potężniejszy, bardziej odporny i niezawodny i dający więcej możliwości rozbudowy.</li></ul><h2 id=co-dalej>Co dalej?</h2><ul><li>Dowiedz się o <a href=/pl/docs/concepts/overview/components/>komponentach Kubernetesa</a></li><li>Jesteś gotowy <a href=/pl/docs/setup/>zacząć pracę</a>?</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-13b0f1dbe89228e3d76d2ac231e245f1>1.2 - Składniki Kubernetesa</h1><div class=lead>Klaster Kubernetesa tworzą: komponenty warstwy sterowania oraz zbiór maszyn nazywanych węzłami.</div><p>W wyniku instalacji Kubernetesa otrzymujesz klaster.</p><p><p>Klaster Kubernetes to zestaw maszyn roboczych, nazywanych węzłami, na których uruchamiane są aplikacje w kontenerach. Każdy klaster musi posiadać przynajmniej jeden węzeł.</p></p><p>Na węźle (lub węzłach) roboczych rozmieszczane są <a class=glossary-tooltip title='A Pod represents a set of running containers in your cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/ target=_blank aria-label=pody>pody</a>,
które są częściami składowymi aplikacji.
<a class=glossary-tooltip title='The container orchestration layer that exposes the API and interfaces to define, deploy, and manage the lifecycle of containers.' data-toggle=tooltip data-placement=top href='/pl/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='Warstwa sterowania'>Warstwa sterowania</a> zarządza
węzłami roboczymi i podami należącymi do klastra. W środowisku produkcyjnym warstwa sterowania
rozłożona jest zazwyczaj na kilka maszyn, a klaster uruchomiony jest na wielu węzłach zapewniając
większą niezawodność i odporność na awarie.</p><p>W tym dokumencie opisujemy składniki niezbędne do zbudowania kompletnego, poprawnie działającego klastra Kubernetesa.</p><figure class=diagram-large><img src=/images/docs/components-of-kubernetes.svg alt="Składniki Kubernetesa"><figcaption><p>Części składowe klastra Kubernetes</p></figcaption></figure><h2 id=części-składowe-warstwy-sterowania>Części składowe warstwy sterowania</h2><p>Komponenty warstwy sterowania podejmują ogólne decyzje dotyczące klastra (np. zlecanie zadań), a także wykrywają i reagują na zdarzenia w klastrze (przykładowo, start nowego <a class=glossary-tooltip title='A Pod represents a set of running containers in your cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/ target=_blank aria-label=poda>poda</a>, kiedy wartość <code>replicas</code> dla deploymentu nie zgadza się z faktyczną liczbą replik).</p><p>Komponenty warstwy sterowania mogą być uruchomione na dowolnej maszynie w klastrze. Dla uproszczenia jednak skrypty instalacyjne zazwyczaj startują wszystkie składniki na tej samej maszynie i jednocześnie nie pozwalają na uruchamianie na niej kontenerów użytkowników. Na stronie <a href=/docs/setup/production-environment/tools/kubeadm/high-availability/>Creating Highly Available clusters with kubeadm</a> znajdziesz opis konfiguracji warstwy sterowania działającej na wielu maszynach wirtualnych.</p><h3 id=kube-apiserver>kube-apiserver</h3><p>Serwer API jest składnikiem
<a class=glossary-tooltip title='The container orchestration layer that exposes the API and interfaces to define, deploy, and manage the lifecycle of containers.' data-toggle=tooltip data-placement=top href='/pl/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='warstwy sterowania'>warstwy sterowania</a> Kubernetesa, który udostępnia API.
Server API służy jako front-end warstwy sterowania Kubernetes.</p><p>Podstawową implementacją serwera API Kubernetesa jest <a href=/docs/reference/generated/kube-apiserver/>kube-apiserver</a>.
kube-apiserver został zaprojektowany w taki sposób, aby móc skalować się horyzontalnie — to oznacza, że zwiększa swoją wydajność poprzez dodawanie kolejnych instancji.
Można uruchomić kilka instancji kube-apiserver i rozkładać między nimi ruch od klientów.</p><h3 id=etcd>etcd</h3><p>Magazyn typu klucz-wartość <em>(key/value store)</em>, zapewniający spójność i wysoką dostępność, używany do przechowywania wszystkich danych o klastrze Kubernetes.</p><p>Jeśli Twój klaster Kubernetes używa etcd do przechowywania swoich danych, upewnij się, że masz opracowany plan tworzenia
<a href=/docs/tasks/administer-cluster/configure-upgrade-etcd/#backing-up-an-etcd-cluster>kopii zapasowych</a> tych danych.</p><p>Szczegółowe informacje na temat etcd można znaleźć w oficjalnej <a href=https://etcd.io/docs/>dokumentacji</a>.</p><h3 id=kube-scheduler>kube-scheduler</h3><p>Składnik warstwy sterowania, który śledzi tworzenie nowych
<a class=glossary-tooltip title='A Pod represents a set of running containers in your cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/ target=_blank aria-label=podów>podów</a> i przypisuje im <a class=glossary-tooltip title='A node is a worker machine in Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/nodes/ target=_blank aria-label=węzły>węzły</a>,
na których powinny zostać uruchomione.</p><p>Przy podejmowaniu decyzji o wyborze węzła brane pod uwagę są wymagania
indywidualne i zbiorcze odnośnie zasobów, ograniczenia wynikające z polityk
sprzętu i oprogramowania, wymagania <em>affinity</em> i <em>anty-affinity</em>, lokalizacja danych,
zależności między zadaniami i wymagania czasowe.</p><h3 id=kube-controller-manager>kube-controller-manager</h3><p>Składnik warstwy sterowania odpowiedzialny za uruchamianie <a class=glossary-tooltip title='A control loop that watches the shared state of the cluster through the apiserver and makes changes attempting to move the current state towards the desired state.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=kontrolerów>kontrolerów</a>.</p><p>Z poziomu podziału logicznego, każdy <a class=glossary-tooltip title='A control loop that watches the shared state of the cluster through the apiserver and makes changes attempting to move the current state towards the desired state.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=kontroler>kontroler</a> jest oddzielnym procesem, ale w celu zmniejszenia złożoności, wszystkie kontrolery są skompilowane do jednego programu binarnego i uruchamiane jako jeden proces.</p><p>Przykładowe kontrolery:</p><ul><li>Node controller: Odpowiada za rozpoznawanie i reagowanie na sytuacje, kiedy węzeł staje się z jakiegoś powodu niedostępny.</li><li>Job controller: Czeka na obiekty typu <em>Job</em>, które definiują zadania uruchamiane jednorazowo
i startuje Pody, odpowiadające za ich wykonanie tych zadań.</li><li>Endpoints controller: Dostarcza informacji do obiektów typu <em>Endpoints</em> (tzn. łączy ze sobą Serwisy i Pody).</li><li>Service Account & Token controllers: Tworzy domyślne konta i tokeny dostępu API dla nowych przestrzeni nazw (<em>namespaces</em>).</li></ul><h3 id=cloud-controller-manager>cloud-controller-manager</h3>Element składowy <a class=glossary-tooltip title='The container orchestration layer that exposes the API and interfaces to define, deploy, and manage the lifecycle of containers.' data-toggle=tooltip data-placement=top href='/pl/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='warstwy sterowania'>warstwy sterowania</a> Kubernetesa,
który zarządza usługami realizowanymi po stronie chmur obliczeniowych. Cloud controller manager umożliwia
połączenie Twojego klastra z API operatora usług chmurowych i rozdziela składniki operujące na platformie
chmurowej od tych, które dotyczą wyłącznie samego klastra.<p>cloud-controller-manager uruchamia jedynie kontrolery właściwe dla konkretnego dostawcy usług chmurowych.
Jeśli uruchamiasz Kubernetesa we własnym centrum komputerowym lub w środowisku szkoleniowym na swoim
komputerze, klaster nie będzie miał cloud controller managera.</p><p>Podobnie jak w przypadku kube-controller-manager, cloud-controller-manager łączy w jednym pliku binarnym
kilka niezależnych pętli sterowania. Można go skalować horyzontalnie
(uruchomić więcej niż jedną instancję), aby poprawić wydajność lub zwiększyć odporność na awarie.</p><p>Następujące kontrolery mogą zależeć od dostawców usług chmurowych:</p><ul><li>Node controller: Aby sprawdzić u dostawcy usługi chmurowej, czy węzeł został skasowany po tym, jak przestał odpowiadać</li><li>Route controller: Aby ustawić trasy <em>(routes)</em> w niższych warstwach infrastruktury chmurowej</li><li>Service controller: Aby tworzyć, aktualizować i kasować <em>cloud load balancers</em></li></ul><h2 id=składniki-węzłów>Składniki węzłów</h2><p>Składniki węzłów uruchomiane są na każdym węźle. Utrzymują pody w działaniu i ustawiają środowisko uruchomieniowe Kubernetes.</p><h3 id=kubelet>kubelet</h3><p>Agent, który działa na każdym <a class=glossary-tooltip title='A node is a worker machine in Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/nodes/ target=_blank aria-label=węźle>węźle</a> klastra. Odpowiada za uruchamianie <a class=glossary-tooltip title='A lightweight and portable executable image that contains software and all of its dependencies.' data-toggle=tooltip data-placement=top href=/docs/concepts/containers/ target=_blank aria-label=kontenerów>kontenerów</a> w ramach <a class=glossary-tooltip title='A Pod represents a set of running containers in your cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/ target=_blank aria-label=poda>poda</a>.</p><p>Kubelet korzysta z dostarczanych (różnymi metodami) <em>PodSpecs</em> i gwarantuje, że kontenery opisane przez te PodSpecs są uruchomione i działają poprawnie. Kubelet nie zarządza kontenerami, które nie zostały utworzone przez Kubernetesa.</p><h3 id=kube-proxy>kube-proxy</h3><p>kube-proxy to <em>proxy</em> sieciowe, które uruchomione jest na każdym
<a class=glossary-tooltip title='A node is a worker machine in Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/nodes/ target=_blank aria-label=węźle>węźle</a> klastra
i uczestniczy w tworzeniu
<a class=glossary-tooltip title='A way to expose an application running on a set of Pods as a network service.' data-toggle=tooltip data-placement=top href=/docs/concepts/services-networking/service/ target=_blank aria-label=serwisu>serwisu</a>.</p><p><a href=/docs/reference/command-line-tools-reference/kube-proxy/>kube-proxy</a>
utrzymuje reguły sieciowe na węźle. Dzięki tym regułom
sieci na zewnątrz i wewnątrz klastra mogą komunikować się
z podami.</p><p>kube-proxy używa warstwy filtrowania pakietów dostarczanych przez system operacyjny, o ile taka jest dostępna.
W przeciwnym przypadku, kube-proxy samo zajmuje sie przekazywaniem ruchu sieciowego.</p><h3 id=container-runtime>Container runtime</h3><p><em>Container runtime</em> to oprogramowanie zajmujące się uruchamianiem kontenerów.</p><p>Kubernetes obsługuje różne <em>container runtimes</em>:
<a class=glossary-tooltip title='A container runtime with an emphasis on simplicity, robustness and portability' data-toggle=tooltip data-placement=top href=https://containerd.io/docs/ target=_blank aria-label=containerd>containerd</a>, <a class=glossary-tooltip title='A lightweight container runtime specifically for Kubernetes' data-toggle=tooltip data-placement=top href=https://cri-o.io/#what-is-cri-o target=_blank aria-label=CRI-O>CRI-O</a>
oraz każdą implementację zgodną z <a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-node/container-runtime-interface.md>Kubernetes CRI (Container Runtime
Interface)</a>.</p><h2 id=dodatki>Dodatki (<em>Addons</em>)</h2><p>Dodatki korzystają z podstawowych obiektów Kubernetes (<a class=glossary-tooltip title='Ensures a copy of a Pod is running across a set of nodes in a cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/daemonset target=_blank aria-label=DaemonSet>DaemonSet</a>, <a class=glossary-tooltip title='Manages a replicated application on your cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Deployment>Deployment</a>, itp.), aby rozszerzyć funkcjonalności klastra. Ponieważ są to funkcjonalności obejmujące cały klaster, zasoby te należą do przestrzeni nazw <em>(namespace)</em> <code>kube-system</code>.</p><p>Wybrane dodatki opisano poniżej. Rozszerzona lista dostępnych dodatków jest w części <a href=/docs/concepts/cluster-administration/addons/>Dodatki</a>.</p><h3 id=dns>DNS</h3><p>Mimo, że inne dodatki nie są bezwzględnie wymagane, wszystkie klastry Kubernetes powinny mieć <a href=/docs/concepts/services-networking/dns-pod-service/>cluster DNS</a>, ponieważ wiele przykładów z niego korzysta.</p><p><em>Cluster DNS</em> to serwer DNS, który uzupełnienia inne serwery DNS z twojego środowiska, dostarczając informacje o rekordach DNS dla usług Kubernetes.</p><p>Kontenery uruchomione przez Kubernetes automatycznie przeszukują ten serwer DNS.</p><h3 id=interfejs-użytkownika-dashboard>Interfejs użytkownika (Dashboard)</h3><p><a href=/docs/tasks/access-application-cluster/web-ui-dashboard/>Dashboard</a> to webowy interfejs ogólnego zastosowania przeznaczony dla użytkowników klastra Kubernetes. Umożliwia zarządzanie i rozwiązywanie problemów związanych z aplikacjami uruchamianymi na klastrze, a także z samym klastrem.</p><h3 id=monitorowanie-zasobów-w-kontenerach>Monitorowanie zasobów w kontenerach</h3><p><a href=/docs/tasks/debug-application-cluster/resource-usage-monitoring/>Container Resource Monitoring</a> zapisuje serie czasowe podstawowych metryk kontenerów w centralnej bazie danych i oferuje interfejs użytkownika do przeglądania tych danych.</p><h3 id=logowanie-na-poziomie-klastra>Logowanie na poziomie klastra</h3><p>Mechanizm <a href=/docs/concepts/cluster-administration/logging/>logowania na poziomie klastra</a> odpowiada za zapisywanie logów pochodzących z poszczególnych kontenerów do wspólnego magazynu, który posiada interfejs do przeglądania i przeszukiwania.</p><h2 id=co-dalej>Co dalej?</h2><ul><li>Więcej o <a href=/docs/concepts/architecture/nodes/>Węzłach</a></li><li>Więcej o <a href=/docs/concepts/architecture/controller/>Kontrolerach</a></li><li>Więcej o <a href=/docs/concepts/scheduling-eviction/kube-scheduler/>kube-scheduler</a></li><li>Oficjalna <a href=https://etcd.io/docs/>dokumentacja</a> etcd</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-0c745f42e623d2b70a53bc0e6db73d95>1.3 - API Kubernetesa</h1><div class=lead>API Kubernetesa służy do odpytywania i zmiany stanu obiektów Kubernetesa. Sercem warstwy sterowania Kubernetesa jest serwer API i udostępniane po HTTP API. Przez ten serwer odbywa się komunikacja pomiędzy użytkownikami, różnymi częściami składowymi klastra oraz komponentami zewnętrznymi.</div><p>Sercem <a class=glossary-tooltip title='The container orchestration layer that exposes the API and interfaces to define, deploy, and manage the lifecycle of containers.' data-toggle=tooltip data-placement=top href='/pl/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='warstwy sterowania'>warstwy sterowania</a> Kubernetes
jest <a class=glossary-tooltip title='Składnik warstwy sterowania udostępniający API Kubernetesa.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label='serwer API'>serwer API</a>. Serwer udostępnia
API poprzez HTTP, umożliwiając wzajemną komunikację pomiędzy użytkownikami, częściami składowymi klastra
i komponentami zewnętrznymi.</p><p>API Kubernetesa pozwala na sprawdzanie i zmianę stanu obiektów
(przykładowo: pody, <em>Namespaces</em>, <em>ConfigMaps</em>, <em>Events</em>).</p><p>Większość operacji może zostać wykonana poprzez
interfejs linii komend (CLI) <a href=/docs/reference/kubectl/>kubectl</a> lub inne
programy, takie jak
<a href=/docs/reference/setup-tools/kubeadm/>kubeadm</a>, które używają
API. Możesz też korzystać z API bezpośrednio przez wywołania typu REST.</p><p>Jeśli piszesz aplikację używającą API Kubernetesa,
warto rozważyć użycie jednej z <a href=/docs/reference/using-api/client-libraries/>bibliotek klienckich</a>.</p><h2 id=api-specification>Specyfikacja OpenAPI</h2><p>Pełną specyfikację API udokumentowano za pomocą <a href=https://www.openapis.org/>OpenAPI</a>.</p><p>Serwer API Kubernetesa udostępnia specyfikację OpenAPI poprzez
ścieżkę <code>/openapi/v2</code>. Aby wybrać format odpowiedzi,
użyj nagłówków żądania zgodnie z tabelą:</p><table><caption style=display:none>Dopuszczalne wartości nagłówka żądania dla zapytań OpenAPI v2</caption><thead><tr><th>Nagłówek</th><th style=min-width:50%>Dopuszczalne wartości</th><th>Uwagi</th></tr></thead><tbody><tr><td><code>Accept-Encoding</code></td><td><code>gzip</code></td><td><em>pominięcie tego nagłówka jest dozwolone</em></td></tr><tr><td rowspan=3><code>Accept</code></td><td><code>application/com.github.proto-openapi.spec.v2@v1.0+protobuf</code></td><td><em>głównie do celu komunikacji wewnątrz klastra</em></td></tr><tr><td><code>application/json</code></td><td><em>domyślne</em></td></tr><tr><td><code>*</code></td><td><em>udostępnia </em><code>application/json</code></td></tr></tbody></table><p>W Kubernetesie zaimplementowany jest alternatywny format serializacji na potrzeby API oparty o
Protobuf, który jest przede wszystkim przeznaczony na potrzeby wewnętrznej komunikacji w klastrze.
Więcej szczegółów znajduje się w dokumencie <a href=https://git.k8s.io/design-proposals-archive/api-machinery/protobuf.md>Kubernetes Protobuf serialization</a>.
oraz w plikach <em>Interface Definition Language</em> (IDL) dla każdego ze schematów
zamieszczonych w pakietach Go, które definiują obiekty API.</p><h3 id=openapi-v3>OpenAPI V3</h3><div style=margin-top:10px;margin-bottom:10px><b>STATUS FUNKCJONALNOŚCI:</b> <code>Kubernetes v1.24 [beta]</code></div><p>Kubernetes v1.25 publikuje (na razie w wersji roboczej) własne API zgodnie ze specyfikacją OpenAPI v3.
Ta funkcjonalność jest w wersji <em>beta</em> i jest domyślnie włączona.
Funkcjonalności w wersji <em>beta</em> można wyłączać poprzez
<a href=/docs/reference/command-line-tools-reference/feature-gates/>feature gate</a> o nazwie <code>OpenAPIV3</code>
składnika kube-apiserver.</p><p>Pod adresem <code>/openapi/v3</code> można znaleźć listę wszystkich
dostępnych grup/wersji. Zwracane wartości są dostępne tylko w formacie JSON. Grupy/wersje
opisane są następującym schematem:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;paths&#34;: </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>...,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>&#34;api/v1&#34;: </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>&#34;serverRelativeURL&#34;: </span><span style=color:#b44>&#34;/openapi/v3/api/v1?hash=CC0E9BFD992D8C59AEC98A1E2336F899E8318D3CF4C68944C3DEC640AF5AB52D864AC50DAA8D145B3494F75FA3CFF939FCBDDA431DAD3CA79738B297795818CF&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>},<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>&#34;apis/admissionregistration.k8s.io/v1&#34;: </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>&#34;serverRelativeURL&#34;: </span><span style=color:#b44>&#34;/openapi/v3/apis/admissionregistration.k8s.io/v1?hash=E19CC93A116982CE5422FC42B590A8AFAD92CDE9AE4D59B5CAAD568F083AD07946E6CB5817531680BCE6E215C16973CD39003B0425F3477CFD854E89A9DB6597&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>},<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>....<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></span></span></code></pre></div><p>Względne adresy URL wskazują na niezmieniające się opisy OpenAPI,
aby umożliwić trzymanie cache po stronie klienta. Serwer API zwraca
również odpowiednie nagłówki HTTP dla cache (<code>Expires</code> ustawione na 1 rok wprzód,
<code>Cache-Control</code> jako <code>immutable</code>). Wysłanie zapytania do nieaktualnego URL
spowoduje przekierowanie przez serwer API do wersji najnowszej.</p><p>Serwer API Kubernetesa udostępnia specyfikację OpenAPI v3
pod adresem <code>/openapi/v3/apis/&lt;group>/&lt;version>?hash=&lt;hash></code>,
zgodnie z podziałem na grupy i wersje.</p><p>Tabela poniżej podaje dopuszczalne wartości nagłówków żądania.</p><table><caption style=display:none>Dopuszczalne wartości nagłówka żądania dla zapytań OpenAPI v3</caption><thead><tr><th>Nagłówek</th><th style=min-width:50%>Dopuszczalne wartości</th><th>Uwagi</th></tr></thead><tbody><tr><td><code>Accept-Encoding</code></td><td><code>gzip</code></td><td><em>pominięcie tego nagłówka jest dozwolone</em></td></tr><tr><td rowspan=3><code>Accept</code></td><td><code>application/com.github.proto-openapi.spec.v3@v1.0+protobuf</code></td><td><em>głównie do celu komunikacji wewnątrz klastra</em></td></tr><tr><td><code>application/json</code></td><td><em>domyślne</em></td></tr><tr><td><code>*</code></td><td><em>udostępnia </em><code>application/json</code></td></tr></tbody></table><h2 id=przechowywanie-stanu>Przechowywanie stanu</h2><p>Kubernetes przechowuje serializowany stan swoich obiektów w
<a class=glossary-tooltip title='Magazyn typu klucz-wartość (key/value store), zapewniający spójność i wysoką dostępność, używany do przechowywania wszystkich danych o klastrze Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/tasks/administer-cluster/configure-upgrade-etcd/ target=_blank aria-label=etcd>etcd</a>.</p><h2 id=grupy-i-wersje-api>Grupy i wersje API</h2><p>Aby ułatwić usuwanie poszczególnych pól lub restrukturyzację reprezentacji zasobów, Kubernetes obsługuje
równocześnie wiele wersji API, każde poprzez osobną ścieżkę API,
na przykład: <code>/api/v1</code> lub <code>/apis/rbac.authorization.k8s.io/v1alpha1</code>.</p><p>Rozdział wersji wprowadzony jest na poziomie całego API, a nie na poziomach poszczególnych zasobów lub pól,
aby być pewnym, że API odzwierciedla w sposób przejrzysty i spójny zasoby systemowe
i ich zachowania oraz pozwala na kontrolowany dostęp do tych API, które są w fazie wycofywania
lub fazie eksperymentalnej.</p><p>Aby ułatwić rozbudowę API Kubernetes, wprowadziliśmy
<a href=https://git.k8s.io/community/contributors/design-proposals/api-machinery/api-group.md><em>grupy API</em></a>, które mogą
być <a href=/docs/reference/using-api/#enabling-or-disabling>włączane i wyłączane</a>.</p><p>Zasoby API są rozróżniane poprzez przynależność do grupy API, typ zasobu, przestrzeń nazw (<em>namespace</em>,<br>o ile ma zastosowanie) oraz nazwę. Serwer API może przeprowadzać konwersję między
różnymi wersjami API w sposób niewidoczny dla użytkownika: wszystkie te różne wersje
reprezentują w rzeczywistości ten sam zasób. Serwer API może udostępniać te same dane
poprzez kilka różnych wersji API.</p><p>Załóżmy przykładowo, że istnieją dwie wersje <code>v1</code> i <code>v1beta1</code> tego samego zasobu.
Obiekt utworzony przez wersję <code>v1beta1</code> może być odczytany,
zaktualizowany i skasowany zarówno przez wersję
<code>v1beta1</code>, jak i <code>v1</code>.</p><h2 id=trwałość-api>Trwałość API</h2><p>Z naszego doświadczenia wynika, że każdy system, który odniósł sukces, musi się nieustająco rozwijać w miarę zmieniających się potrzeb.
Dlatego Kubernetes został tak zaprojektowany, aby API mogło się zmieniać i rozrastać.
Projekt Kubernetes dąży do tego, aby nie wprowadzać zmian niezgodnych z istniejącymi aplikacjami klienckimi
i utrzymywać zgodność przez wystarczająco długi czas, aby inne projekty zdążyły się dostosować do zmian.</p><p>W ogólności, nowe zasoby i pola definiujące zasoby API są dodawane stosunkowo często.
Usuwanie zasobów lub pól jest regulowane przez
<a href=/docs/reference/using-api/deprecation-policy/>API deprecation policy</a>.</p><p>Po osiągnięciu przez API statusu ogólnej dostępności (<em>general availability</em> - GA),
oznaczanej zazwyczaj jako wersja API <code>v1</code>, bardzo zależy nam na utrzymaniu jej zgodności w kolejnych wydaniach.
Kubernetes utrzymuje także zgodność dla wersji <em>beta</em> API tam, gdzie jest to możliwe:
jeśli zdecydowałeś się używać API w wersji beta, możesz z niego korzystać także później,
kiedy dana funkcjonalność osiągnie status stabilnej.</p><div class="alert alert-info note callout" role=alert><strong>Informacja:</strong> Mimo, że Kubernetes stara się także zachować zgodność dla API w wersji <em>alpha</em>, zdarzają się przypadki,
kiedy nie jest to możliwe. Jeśli korzystasz z API w wersji alfa, przed aktualizacją klastra do nowej wersji
zalecamy sprawdzenie w informacjach o wydaniu, czy nie nastąpiła jakaś zmiana w tej części API.</div><p>Zajrzyj do <a href=/docs/reference/using-api/#api-versioning>API versions reference</a>
po szczegółowe definicje różnych poziomów wersji API.</p><h2 id=rozbudowa-api>Rozbudowa API</h2><p>API Kubernetesa można rozszerzać na dwa sposoby:</p><ol><li><a href=/docs/concepts/extend-kubernetes/api-extension/custom-resources/>Definicje zasobów własnych (<em>custom resources</em>)</a>
pozwalają deklaratywnie określać, jak serwer API powinien dostarczać wybrane przez Ciebie zasoby API.</li><li>Można także rozszerzać API Kubernetesa implementując
<a href=/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>warstwę agregacji</a>.</li></ol><h2 id=co-dalej>Co dalej?</h2><ul><li>Naucz się, jak rozbudowywać API Kubernetesa poprzez dodawanie własnych
<a href=/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/>CustomResourceDefinition</a>.</li><li><a href=/docs/concepts/security/controlling-access/>Controlling Access To The Kubernetes API</a> opisuje
sposoby, jakimi klaster zarządza dostępem do API.</li><li>Punkty dostępowe API <em>(endpoints)</em>, typy zasobów i przykłady zamieszczono w
<a href=/docs/reference/kubernetes-api/>API Reference</a>.</li><li>Aby dowiedzieć się, jaki rodzaj zmian można określić jako zgodne i jak zmieniać API, zajrzyj do
<a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api_changes.md#readme>API changes</a>.</li></ul></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/pl/docs/home/>Strona główna</a>
<a class=text-white href=/pl/training/>Szkolenia</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 Autorzy Kubernetesa | Dokumentacja jest udostępniona w ramach licencji <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small><br><small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>Trademark Usage page</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>