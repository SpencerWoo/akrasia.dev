<!doctype html><html lang=pl class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=en href=https://kubernetes.io/docs/><link rel=alternate hreflang=zh-cn href=https://kubernetes.io/zh-cn/docs/><link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/><link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/><link rel=alternate hreflang=it href=https://kubernetes.io/it/docs/><link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/><link rel=alternate hreflang=pt-br href=https://kubernetes.io/pt-br/docs/><link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/><link rel=alternate hreflang=hi href=https://kubernetes.io/hi/docs/><link rel=alternate hreflang=vi href=https://kubernetes.io/vi/docs/><link rel=alternate hreflang=ru href=https://kubernetes.io/ru/docs/><link rel=alternate hreflang=uk href=https://kubernetes.io/uk/docs/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/pl/docs/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>Dokumentacja | Kubernetes</title><meta property="og:title" content="Dokumentacja"><meta property="og:description" content="Produkcyjny system zarządzania kontenerami"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/pl/docs/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="Dokumentacja"><meta itemprop=description content="Produkcyjny system zarządzania kontenerami"><meta name=twitter:card content="summary"><meta name=twitter:title content="Dokumentacja"><meta name=twitter:description content="Produkcyjny system zarządzania kontenerami"><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content><meta property="og:description" content><meta name=twitter:description content><meta property="og:url" content="https://kubernetes.io/pl/docs/"><meta property="og:title" content="Dokumentacja"><meta name=twitter:title content="Dokumentacja"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/pl/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/pl/docs/>Dokumentacja</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/pl/training/>Szkolenia</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Wersje</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/pl/releases>Informacje o wydaniu</a>
<a class=dropdown-item href=https://kubernetes.io/pl/docs/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/pl/docs/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/pl/docs/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/pl/docs/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/pl/docs/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Polski (Polish)</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/docs/>English</a>
<a class=dropdown-item href=/zh-cn/docs/>中文 (Chinese)</a>
<a class=dropdown-item href=/ko/docs/>한국어 (Korean)</a>
<a class=dropdown-item href=/ja/docs/>日本語 (Japanese)</a>
<a class=dropdown-item href=/fr/docs/>Français (French)</a>
<a class=dropdown-item href=/it/docs/>Italiano (Italian)</a>
<a class=dropdown-item href=/de/docs/>Deutsch (German)</a>
<a class=dropdown-item href=/es/docs/>Español (Spanish)</a>
<a class=dropdown-item href=/pt-br/docs/>Português (Portuguese)</a>
<a class=dropdown-item href=/id/docs/>Bahasa Indonesia</a>
<a class=dropdown-item href=/hi/docs/>हिन्दी (Hindi)</a>
<a class=dropdown-item href=/vi/docs/>Tiếng Việt (Vietnamese)</a>
<a class=dropdown-item href=/ru/docs/>Русский (Russian)</a>
<a class=dropdown-item href=/uk/docs/>Українська (Ukrainian)</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>To wielostronicowy widok tej sekcji do wydrukowania.
<a href=# onclick="return print(),!1">Kliknij aby wydrukować</a>.</p><p><a href=/pl/docs/>Wróć do zwykłego widoku tej strony</a>.</p></div><h1 class=title>Dokumentacja</h1><ul><li>1: <a href=#pg-e735cee7e913aa88bc0aa10594d12966>Kubernetes — Dokumentacja</a></li><ul><li>1.1: <a href=#pg-92dfff0ca612d0bff40171aa9df6c4ae>Dostępne wersje dokumentacji</a></li></ul><li>2: <a href=#pg-66b565805ca1061be35ff2c0165f13c1>Od czego zacząć</a></li><ul></ul><li>3: <a href=#pg-dd948255948d6b59b32c471abcb62997>Pojęcia</a></li><ul><li>3.1: <a href=#pg-0554ac387412eaf4e6e89b2f847dacde>Przegląd</a></li><ul><li>3.1.1: <a href=#pg-45bdca6129cf540121623e903c18ba46>Kubernetes — co to jest?</a></li><li>3.1.2: <a href=#pg-13b0f1dbe89228e3d76d2ac231e245f1>Składniki Kubernetesa</a></li><li>3.1.3: <a href=#pg-0c745f42e623d2b70a53bc0e6db73d95>API Kubernetesa</a></li></ul></ul><li>4: <a href=#pg-f8918f697450c2009b75913f9e9317a5>Zadania</a></li><ul></ul><li>5: <a href=#pg-68ec2370d0409cc27325be36693f9368>Samouczki</a></li><ul><li>5.1: <a href=#pg-5e3051fff9e84735871d9fb5e7b93f33>Hello Minikube</a></li><li>5.2: <a href=#pg-3c83f53a74233ace9b289ac5e24c3e62>Naucz się podstaw</a></li><ul><li>5.2.1: <a href=#pg-7df66040311338d6098ebeab43ba9afb>Tworzenie klastra</a></li><ul><li>5.2.1.1: <a href=#pg-de49316920e97a82e36763cb66781ada>Jak użyć Minikube do stworzenia klastra</a></li><li>5.2.1.2: <a href=#pg-323b75976001e8dfe35d67d61bc74f1a>Interaktywny samouczek - Tworzenie klastra</a></li></ul><li>5.2.2: <a href=#pg-76d78b3fba507f7ed33cef14a35b631d>Instalowanie aplikacji</a></li><ul><li>5.2.2.1: <a href=#pg-2b1bba431989008c7493109a0f049ece>Jak użyć kubectl do tworzenia Deploymentu</a></li><li>5.2.2.2: <a href=#pg-f8997ec143b382fa6c9621941ea62ca3>Interaktywny samouczek - Instalacja aplikacji</a></li></ul><li>5.2.3: <a href=#pg-250d620a73ec8be7e1f7d835574c4596>Poznawanie aplikacji</a></li><ul><li>5.2.3.1: <a href=#pg-2771f4e8c45321b17cb0114a2d266453>Pody i Węzły</a></li><li>5.2.3.2: <a href=#pg-4b01eab98a9844ad91131079654199dd>Interaktywny samouczek - Poznaj swoją aplikację</a></li></ul><li>5.2.4: <a href=#pg-4b0e31c9e0eae68bbb0a358b4042ada9>Udostępnianie aplikacji</a></li><ul><li>5.2.4.1: <a href=#pg-8ef4dad8f743b191a9e8c6f891cb191a>Jak używać Service do udostępniania aplikacji</a></li><li>5.2.4.2: <a href=#pg-352241d22effe0714772d21c7d1b512d>Interaktywny samouczek - Udostępnianie aplikacji</a></li></ul><li>5.2.5: <a href=#pg-be4996c93fb39c459a30b6669569d423>Skalowanie aplikacji</a></li><ul><li>5.2.5.1: <a href=#pg-d1c15c9bd4f625adbc13149b1475287c>Uruchamianie wielu instancji aplikacji</a></li><li>5.2.5.2: <a href=#pg-7bdb3fbaa1177ff5dfa3fe86bd35ef59>Interaktywny samouczek - Skalowanie aplikacji</a></li></ul><li>5.2.6: <a href=#pg-62b8b17dadfb55f1801cf8439e944e58>Aktualizowanie aplikacji</a></li><ul><li>5.2.6.1: <a href=#pg-12e04355145afad615ca3c38335ba019>Aktualizacje Rolling Update</a></li><li>5.2.6.2: <a href=#pg-dddc0cb356c280e0339bcf42776987dc>Interaktywny samouczek - Aktualizowanie aplikacji</a></li></ul></ul></ul><li>6: <a href=#pg-b00a88a07ceb21b1a83e5822e0c86c1d>Materiały źródłowe</a></li><ul><li>6.1: <a href=#pg-2b03679960950df772fb4fe7d78427b9>Słownik</a></li></ul><li>7: <a href=#pg-4985cb55ddfb184639d767ec54b9f0f7>Współtwórz dokumentację K8s</a></li><ul><li>7.1: <a href=#pg-ac6156512315f527b7ffa1daded4e91b>Tłumaczenie dokumentacji na język polski</a></li></ul><li>8: <a href=#pg-91737b3265a3e3f407fbeeb86a8973ab></a></li></ul><div class=content></div></div><div class=td-content><h1 id=pg-e735cee7e913aa88bc0aa10594d12966>1 - Kubernetes — Dokumentacja</h1><div class=lead>Kubernetes to otwarte oprogramowanie służące do automatyzacji procesów uruchamiania, skalowania i zarządzania aplikacjami w kontenerach. Gospodarzem tego projektu o otwartym kodzie źródłowym jest Cloud Native Computing Foundation.</div></div><div class=td-content><h1 id=pg-92dfff0ca612d0bff40171aa9df6c4ae>1.1 - Dostępne wersje dokumentacji</h1><p>Ten serwis zawiera dokumentację do bieżącej i czterech poprzednich wersji Kubernetesa.</p><p>Dostępność dokumentacji obejmującej konkretną wersję Kubernetesa nie oznacza automatycznie,
że dana wersja Kubernetesa jest ciągle aktywnie wspierana.
Zajrzyj do dokumentu <a href=/releases/patch-releases/#support-period>Support period</a>, aby dowiedzieć się,
do kiedy objęte wsparciem są poszczególne wersje Kubernetesa.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-66b565805ca1061be35ff2c0165f13c1>2 - Od czego zacząć</h1><p>Ten rozdział poświęcony jest różnym metodom konfiguracji i uruchomienia Kubernetesa.
Instalując Kubernetesa, przy wyborze platformy kieruj się: łatwością w utrzymaniu, spełnianymi wymogami bezpieczeństwa, poziomem sterowania, dostępnością zasobów oraz doświadczeniem wymaganym do zarządzania klastrem.</p><p>Możesz <a href=/releases/download/>pobrać Kubernetesa</a>, aby zainstalować klaster
na lokalnym komputerze, w chmurze czy w prywatnym centrum obliczeniowym.</p><p>Niektóre <a href=/docs/concepts/overview/components/>komponenty Kubernetesa</a>, na przykład <code>kube-apiserver</code> czy <code>kube-proxy</code> mogą być
uruchamiane jako <a href=/releases/download/#container-images>kontenery</a> wewnątrz samego klastra.</p><p><strong>Zalecamy</strong> uruchamianie komponentów Kubernetesa jako kontenery zawsze,
kiedy jest to możliwe i na zarządzanie nimi przez samego Kubernetesa.
Do tej kategorii nie należą komponenty odpowiedzialne za uruchamianie kontenerów, w szczególności - kubelet.</p><p>Jeśli nie chcesz zarządzać klastrem Kubernetesa samodzielnie, możesz wybrać serwis zarządzany przez zewnętrznego dostawcę,
wybierając na przykład spośród <a href=/docs/setup/production-environment/turnkey-solutions/>certyfikowanych platform</a>.
Dostępne są także inne standardowe i specjalizowane rozwiązania dla różnych środowisk chmurowych
bądź bazujące bezpośrednio na sprzęcie fizycznym.</p><h2 id=srodowisko-do-nauki>Środowisko do nauki</h2><p>Do nauki Kubernetesa wykorzystaj narzędzia wspierane przez społeczność Kubernetesa
lub inne narzędzia dostępne w ekosystemie, aby uruchomić klaster Kubernetesa na swoim komputerze lokalnym.
Zapoznaj się z <a href=/docs/tasks/tools/>narzędziami instalacyjnymi</a>.</p><h2 id=srodowisko-produkcyjne>Środowisko produkcyjne</h2><p>Wybierając rozwiązanie dla
<a href=/docs/setup/production-environment/>środowiska produkcyjnego</a> musisz zdecydować,
którymi poziomami zarządzania klastrem (<em>abstrakcjami</em>) chcesz zajmować się sam,
a które będą realizowane po stronie zewnętrznego operatora.</p><p>Do instalacji klastra Kubernetesa zarządzanego samodzielnie oficjalnym narzędziem
jest <a href=/docs/setup/production-environment/tools/kubeadm/>kubeadm</a>.</p><h2 id=co-dalej>Co dalej?</h2><ul><li><a href=/releases/download/>Pobierz Kubernetesa</a></li><li>Pobierz i <a href=/docs/tasks/tools/>zainstaluj narzędzia</a>, w tym <code>kubectl</code></li><li>Wybierz <a href=/docs/setup/production-environment/container-runtimes/>środowisko uruchomieniowe dla kontenerów</a> w nowym klastrze</li><li>Naucz się <a href=/docs/setup/best-practices/>najlepszych praktyk</a> przy konfigurowaniu klastra</li></ul><p>Na stronie <a href=https://kubernetes.io/partners/#conformance>Partnerów Kubernetesa</a> znajdziesz listę dostawców posiadających
<a href=https://github.com/cncf/k8s-conformance/#certified-kubernetes>certyfikację Kubernetes</a>.</p><p>Kubernetes zaprojektowano w ten sposób, że <a class=glossary-tooltip title='The container orchestration layer that exposes the API and interfaces to define, deploy, and manage the lifecycle of containers.' data-toggle=tooltip data-placement=top href='/pl/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='warstwa sterowania'>warstwa sterowania</a>
wymaga do działania systemu Linux. W ramach klastra aplikacje mogą być uruchamiane na systemie Linux i innych,
w tym Windows.</p><ul><li>Naucz się, <a href=/docs/concepts/windows/>jak zbudować klaster z węzłami Windows</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-dd948255948d6b59b32c471abcb62997>3 - Pojęcia</h1><p>Rozdział dotyczący pojęć ma za zadanie pomóc w zrozumieniu poszczególnych składowych systemu oraz obiektów abstrakcyjnych, których Kubernetes używa do reprezentacji <a class=glossary-tooltip title='Zestaw maszyn roboczych, nazywanych , na których uruchamiane są aplikacje w kontenerach. Każdy klaster musi posiadać przynajmniej jeden węzeł.' data-toggle=tooltip data-placement=top href='/pl/docs/reference/glossary/?all=true#term-cluster' target=_blank aria-label=klastra>klastra</a>, a także posłużyć do lepszego poznania działania całego systemu.</p></div><div class=td-content><h1 id=pg-0554ac387412eaf4e6e89b2f847dacde>3.1 - Przegląd</h1><div class=lead>Ogólny zarys Kubernetesa i komponentów, z których jest zbudowany.</div></div><div class=td-content><h1 id=pg-45bdca6129cf540121623e903c18ba46>3.1.1 - Kubernetes — co to jest?</h1><div class=lead>Kubernetes to przenośna, rozszerzalna platforma oprogramowania <em>open-source</em> służąca do zarządzania zadaniami i serwisami uruchamianymi w kontenerach. Umożliwia ich deklaratywną konfigurację i automatyzację. Kubernetes posiada duży i dynamicznie rozwijający się ekosystem. Szeroko dostępne są serwisy, wsparcie i dodatkowe narzędzia.</div><p>Na tej stronie znajdziesz ogólne informacje o Kubernetesie.</p><p>Kubernetes to przenośna, rozszerzalna platforma oprogramowania <em>open-source</em> służąca do zarządzania zadaniami i serwisami uruchamianymi w kontenerach, która umożliwia deklaratywną konfigurację i automatyzację. Ekosystem Kubernetesa jest duży i dynamicznie się rozwija. Serwisy Kubernetesa, wsparcie i narzędzia są szeroko dostępne.</p><p>Nazwa Kubernetes pochodzi z greki i oznacza sternika albo pilota. Skrót K8s powstał poprzez zastąpienie ośmiu liter pomiędzy "K" i "s" .Google otworzyło projekt Kubernetes publicznie w 2014. Kubernetes korzysta z <a href=/blog/2015/04/borg-predecessor-to-kubernetes/>piętnastoletniego doświadczenia Google w uruchamianiu wielkoskalowych serwisów</a> i łączy je z najlepszymi pomysłami i praktykami wypracowanymi przez społeczność.</p><h2 id=trochę-historii>Trochę historii</h2><p>Aby zrozumieć, dlaczego Kubernetes stał się taki przydatny, cofnijmy sie trochę w czasie.</p><p><img src=/images/docs/Container_Evolution.svg alt="Jak zmieniały sie metody wdrożeń"></p><p><strong>Era wdrożeń tradycyjnych:</strong>
Na początku aplikacje uruchamiane były na fizycznych serwerach. Nie było możliwości separowania zasobów poszczególnych aplikacji, co prowadziło do problemów z alokacją zasobów. Przykładowo, kiedy wiele aplikacji jest uruchomionych na jednym fizycznym serwerze, część tych aplikacji może zużyć większość dostępnych zasobów, powodując spowolnienie działania innych. Rozwiązaniem tego problemu mogło być uruchamianie każdej aplikacji na osobnej maszynie. Niestety, takie podejście ograniczało skalowanie, ponieważ większość zasobów nie była w pełni wykorzystywana, a utrzymanie wielu fizycznych maszyn było kosztowne.</p><p><strong>Era wdrożeń w środowiskach wirtualnych:</strong><br>Jako rozwiązanie zaproponowano wirtualizację, która umożliwiała uruchamianie wielu maszyn wirtualnych (VM) na jednym procesorze fizycznego serwera. Wirtualizacja pozwalała izolować aplikacje pomiędzy maszynami wirtualnymi i osiągnąć pewien poziom bezpieczeństwa, jako że informacje związane z jedną aplikacją nie były w łatwy sposób dostępne dla pozostałych.</p><p>Wirtualizacja pozwala lepiej wykorzystywać zasoby fizycznego serwera i lepiej skalować, ponieważ aplikacje mogą być łatwo dodawane oraz aktualizowane, pozwala ograniczyć koszty sprzętu oraz ma wiele innych zalet. Za pomocą wirtualizacji można udostępnić wybrane zasoby fizyczne jako klaster maszyn wirtualnych "wielokrotnego użytku".</p><p>Każda maszyna wirtualna jest pełną maszyną zawierającą własny system operacyjny pracujący na zwirtualizowanej warstwie sprzętowej.</p><p><strong>Era wdrożeń w kontenerach:</strong>
Kontenery działają w sposób zbliżony do maszyn wirtualnych, ale mają mniejszy stopnień wzajemnej izolacji, współdzieląc ten sam system operacyjny. Kontenery określane są mianem "lekkich". Podobnie, jak maszyna wirtualna, kontener posiada własny system plików, udział w zasobach procesora, pamięć, przestrzeń procesów itd. Ponieważ kontenery nie są związane z leżącymi poniżej warstwami infrastruktury, mogą być łatwiej przenoszone pomiędzy chmurami i różnymi dystrybucjami systemu operacyjnego.</p><p>Kontenery zyskały popularność ze względu na swoje zalety, takie jak:</p><ul><li>Szybkość i elastyczność w tworzeniu i instalacji aplikacji: obraz kontenera buduje się łatwiej niż obraz VM.</li><li>Ułatwienie ciągłego rozwoju, integracji oraz wdrażania aplikacji (<em>Continuous development, integration, and deployment</em>): obrazy kontenerów mogą być budowane w sposób wiarygodny i częsty. Wycofywanie zmian jest skuteczne i szybkie (ponieważ obrazy są niezmienne).</li><li>Rozdzielenie zadań <em>Dev</em> i <em>Ops</em>: obrazy kontenerów powstają w fazie <em>build/release</em>, oddzielając w ten sposób aplikacje od infrastruktury.</li><li>Obserwowalność obejmuje nie tylko informacje i metryki z poziomu systemu operacyjnego, ale także poprawność działania samej aplikacji i inne sygnały.</li><li>Spójność środowiska na etapach rozwoju oprogramowania, testowania i działania w trybie produkcyjnym: działa w ten sam sposób na laptopie i w chmurze.</li><li>Możliwość przenoszenia pomiędzy systemami operacyjnymi i platformami chmurowymi: Ubuntu, RHEL, CoreOS, prywatnymi centrami danych, największymi dostawcami usług chmurowych czy gdziekolwiek indziej.</li><li>Zarządzanie, które w centrum uwagi ma aplikacje: Poziom abstrakcji przeniesiony jest z warstwy systemu operacyjnego działającego na maszynie wirtualnej na poziom działania aplikacji, która działa na systemie operacyjnym używając zasobów logicznych.</li><li>Luźno powiązane, rozproszone i elastyczne "swobodne" mikro serwisy: Aplikacje podzielone są na mniejsze, niezależne komponenty, które mogą być dynamicznie uruchamiane i zarządzane - nie jest to monolityczny system działający na jednej, dużej maszynie dedykowanej na wyłączność.</li><li>Izolacja zasobów: wydajność aplikacji możliwa do przewidzenia</li><li>Wykorzystanie zasobów: wysoka wydajność i upakowanie.</li></ul><h2 id=do-czego-potrzebujesz-kubernetesa-i-jakie-są-jego-możliwości>Do czego potrzebujesz Kubernetesa i jakie są jego możliwości</h2><p>Kontenery są dobrą metodą na opakowywanie i uruchamianie aplikacji. W środowisku produkcyjnym musisz zarządzać kontenerami, w których działają aplikacje i pilnować, aby nie było żadnych przerw w ich dostępności. Przykładowo, kiedy jeden z kontenerów przestaje działać, inny musi zostać uruchomiony. Nie byłoby prościej, aby takimi działaniami zajmował się jakiś system?</p><p>I tu właśnie Kubernetes przychodzi z pomocą! Kubernetes dostarcza środowisko do uruchamiania systemów rozproszonych o wysokiej niezawodności. Kubernetes obsługuje skalowanie aplikacji, przełączanie w sytuacjach awaryjnych, różne scenariusze wdrożeń itp. Przykładowo, Kubernetes w łatwy sposób może zarządzać wdrożeniem nowej wersji oprogramowania zgodnie z metodyką <em>canary deployments</em>.</p><p>Kubernetes zapewnia:</p><ul><li><strong>Detekcję nowych serwisów i balansowanie ruchu</strong>
Kubernetes może udostępnić kontener używając nazwy DNS lub swojego własnego adresu IP. Jeśli ruch przychodzący do kontenera jest duży, Kubernetes może balansować obciążenie i przekierować ruch sieciowy, aby zapewnić stabilność całej instalacji.</li><li><strong>Zarządzanie obsługą składowania danych</strong>
Kubernetes umożliwia automatyczne montowanie systemów składowania danych dowolnego typu — lokalnych, od dostawców chmurowych i innych.</li><li><strong>Automatyczne wdrożenia i wycofywanie zmian</strong>
Możesz opisać oczekiwany stan instalacji za pomocą Kubernetesa, który zajmie się doprowadzeniem w sposób kontrolowany stanu faktycznego do stanu oczekiwanego. Przykładowo, przy pomocy Kubernetesa możesz zautomatyzować proces tworzenia nowych kontenerów na potrzeby swojego wdrożenia, usuwania istniejących i przejęcia zasobów przez nowe kontenery.</li><li><strong>Automatyczne zarządzanie dostępnymi zasobami</strong>
Twoim zadaniem jest dostarczenie klastra maszyn, które Kubernetes może wykorzystać do uruchamiania zadań w kontenerach. Określasz zapotrzebowanie na moc procesora i pamięć RAM dla każdego z kontenerów. Kubernetes rozmieszcza kontenery na maszynach w taki sposób, aby jak najlepiej wykorzystać dostarczone zasoby.</li><li><strong>Samoczynne naprawianie</strong>
Kubernetes restartuje kontenery, które przestały działać, wymienia je na nowe, wymusza wyłączenie kontenerów, które nie odpowiadają na określone zapytania o stan i nie rozgłasza powiadomień o ich dostępności tak długo, dopóki nie są gotowe do działania.</li><li><strong>Zarządzanie informacjami poufnymi i konfiguracją</strong>
Kubernetes pozwala składować i zarządzać informacjami poufnymi, takimi jak hasła, tokeny OAuth i klucze SSH. Informacje poufne i zawierające konfigurację aplikacji mogą być dostarczane i zmieniane bez konieczności ponownego budowania obrazu kontenerów i bez ujawniania poufnych danych w ogólnej konfiguracji oprogramowania.</li></ul><h2 id=czym-kubernetes-nie-jest>Czym Kubernetes nie jest</h2><p>Kubernetes nie jest tradycyjnym, zawierającym wszystko systemem PaaS <em>(Platform as a Service)</em>. Ponieważ Kubernetes działa w warstwie kontenerów, a nie sprzętu, posiada różne funkcjonalności ogólnego zastosowania, wspólne dla innych rozwiązań PaaS, takie jak: instalacje <em>(deployments)</em>, skalowanie i balansowanie ruchu, umożliwiając użytkownikom integrację rozwiązań służących do logowania, monitoringu i ostrzegania. Co ważne, Kubernetes nie jest monolitem i domyślnie dostępne rozwiązania są opcjonalne i działają jako wtyczki. Kubernetes dostarcza elementy, z których może być zbudowana platforma deweloperska, ale pozostawia użytkownikowi wybór i elastyczność tam, gdzie jest to ważne.</p><p>Kubernetes:</p><ul><li>Nie ogranicza typów aplikacji, które są obsługiwane. Celem Kubernetesa jest możliwość obsługi bardzo różnorodnego typu zadań, włączając w to aplikacje bezstanowe (<em>stateless</em>), aplikacje ze stanem (<em>stateful</em>) i ogólne przetwarzanie danych. Jeśli jakaś aplikacja może działać w kontenerze, będzie doskonale sobie radzić w środowisku Kubernetesa.</li><li>Nie oferuje wdrażania aplikacji wprost z kodu źródłowego i nie buduje aplikacji. Procesy Continuous Integration, Delivery, and Deployment (CI/CD) są zależne od kultury pracy organizacji, jej preferencji oraz wymagań technicznych.</li><li>Nie dostarcza serwisów z warstwy aplikacyjnej, takich jak warstwy pośrednie <em>middleware</em> (np. broker wiadomości), środowiska analizy danych (np. Spark), bazy danych (np. MySQL), cache ani klastrowych systemów składowania danych (np. Ceph) jako usług wbudowanych. Te składniki mogą być uruchamiane na klastrze Kubernetes i udostępniane innym aplikacjom przez przenośne rozwiązania, takie jak <a href=https://openservicebrokerapi.org/>Open Service Broker</a>.</li><li>Nie wymusza użycia konkretnych systemów zbierania logów, monitorowania ani ostrzegania. Niektóre z tych rozwiązań są udostępnione jako przykłady. Dostępne są też mechanizmy do gromadzenia i eksportowania różnych metryk.</li><li>Nie dostarcza, ani nie wymusza języka/systemu używanego do konfiguracji (np. Jsonnet). Udostępnia API typu deklaratywnego, z którego można korzystać za pomocą różnych metod wykorzystujących deklaratywne specyfikacje.</li><li>Nie zapewnia, ani nie wykorzystuje żadnego ogólnego systemu do zarządzania konfiguracją, utrzymaniem i samo-naprawianiem maszyn.</li><li>Co więcej, nie jest zwykłym systemem planowania <em>(orchestration)</em>. W rzeczywistości, eliminuje konieczność orkiestracji. Zgodnie z definicją techniczną, orkiestracja to wykonywanie określonego ciągu zadań: najpierw A, potem B i następnie C. Dla kontrastu, Kubernetes składa się z wielu niezależnych, możliwych do złożenia procesów sterujących, których zadaniem jest doprowadzenie stanu faktycznego do stanu oczekiwanego. Nie ma znaczenia, w jaki sposób przechodzi się od A do C. Nie ma konieczności scentralizowanego zarządzania. Dzięki temu otrzymujemy system, który jest potężniejszy, bardziej odporny i niezawodny i dający więcej możliwości rozbudowy.</li></ul><h2 id=co-dalej>Co dalej?</h2><ul><li>Dowiedz się o <a href=/pl/docs/concepts/overview/components/>komponentach Kubernetesa</a></li><li>Jesteś gotowy <a href=/pl/docs/setup/>zacząć pracę</a>?</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-13b0f1dbe89228e3d76d2ac231e245f1>3.1.2 - Składniki Kubernetesa</h1><div class=lead>Klaster Kubernetesa tworzą: komponenty warstwy sterowania oraz zbiór maszyn nazywanych węzłami.</div><p>W wyniku instalacji Kubernetesa otrzymujesz klaster.</p><p><p>Klaster Kubernetes to zestaw maszyn roboczych, nazywanych węzłami, na których uruchamiane są aplikacje w kontenerach. Każdy klaster musi posiadać przynajmniej jeden węzeł.</p></p><p>Na węźle (lub węzłach) roboczych rozmieszczane są <a class=glossary-tooltip title='A Pod represents a set of running containers in your cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/ target=_blank aria-label=pody>pody</a>,
które są częściami składowymi aplikacji.
<a class=glossary-tooltip title='The container orchestration layer that exposes the API and interfaces to define, deploy, and manage the lifecycle of containers.' data-toggle=tooltip data-placement=top href='/pl/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='Warstwa sterowania'>Warstwa sterowania</a> zarządza
węzłami roboczymi i podami należącymi do klastra. W środowisku produkcyjnym warstwa sterowania
rozłożona jest zazwyczaj na kilka maszyn, a klaster uruchomiony jest na wielu węzłach zapewniając
większą niezawodność i odporność na awarie.</p><p>W tym dokumencie opisujemy składniki niezbędne do zbudowania kompletnego, poprawnie działającego klastra Kubernetesa.</p><figure class=diagram-large><img src=/images/docs/components-of-kubernetes.svg alt="Składniki Kubernetesa"><figcaption><p>Części składowe klastra Kubernetes</p></figcaption></figure><h2 id=części-składowe-warstwy-sterowania>Części składowe warstwy sterowania</h2><p>Komponenty warstwy sterowania podejmują ogólne decyzje dotyczące klastra (np. zlecanie zadań), a także wykrywają i reagują na zdarzenia w klastrze (przykładowo, start nowego <a class=glossary-tooltip title='A Pod represents a set of running containers in your cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/ target=_blank aria-label=poda>poda</a>, kiedy wartość <code>replicas</code> dla deploymentu nie zgadza się z faktyczną liczbą replik).</p><p>Komponenty warstwy sterowania mogą być uruchomione na dowolnej maszynie w klastrze. Dla uproszczenia jednak skrypty instalacyjne zazwyczaj startują wszystkie składniki na tej samej maszynie i jednocześnie nie pozwalają na uruchamianie na niej kontenerów użytkowników. Na stronie <a href=/docs/setup/production-environment/tools/kubeadm/high-availability/>Creating Highly Available clusters with kubeadm</a> znajdziesz opis konfiguracji warstwy sterowania działającej na wielu maszynach wirtualnych.</p><h3 id=kube-apiserver>kube-apiserver</h3><p>Serwer API jest składnikiem
<a class=glossary-tooltip title='The container orchestration layer that exposes the API and interfaces to define, deploy, and manage the lifecycle of containers.' data-toggle=tooltip data-placement=top href='/pl/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='warstwy sterowania'>warstwy sterowania</a> Kubernetesa, który udostępnia API.
Server API służy jako front-end warstwy sterowania Kubernetes.</p><p>Podstawową implementacją serwera API Kubernetesa jest <a href=/docs/reference/generated/kube-apiserver/>kube-apiserver</a>.
kube-apiserver został zaprojektowany w taki sposób, aby móc skalować się horyzontalnie — to oznacza, że zwiększa swoją wydajność poprzez dodawanie kolejnych instancji.
Można uruchomić kilka instancji kube-apiserver i rozkładać między nimi ruch od klientów.</p><h3 id=etcd>etcd</h3><p>Magazyn typu klucz-wartość <em>(key/value store)</em>, zapewniający spójność i wysoką dostępność, używany do przechowywania wszystkich danych o klastrze Kubernetes.</p><p>Jeśli Twój klaster Kubernetes używa etcd do przechowywania swoich danych, upewnij się, że masz opracowany plan tworzenia
<a href=/docs/tasks/administer-cluster/configure-upgrade-etcd/#backing-up-an-etcd-cluster>kopii zapasowych</a> tych danych.</p><p>Szczegółowe informacje na temat etcd można znaleźć w oficjalnej <a href=https://etcd.io/docs/>dokumentacji</a>.</p><h3 id=kube-scheduler>kube-scheduler</h3><p>Składnik warstwy sterowania, który śledzi tworzenie nowych
<a class=glossary-tooltip title='A Pod represents a set of running containers in your cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/ target=_blank aria-label=podów>podów</a> i przypisuje im <a class=glossary-tooltip title='A node is a worker machine in Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/nodes/ target=_blank aria-label=węzły>węzły</a>,
na których powinny zostać uruchomione.</p><p>Przy podejmowaniu decyzji o wyborze węzła brane pod uwagę są wymagania
indywidualne i zbiorcze odnośnie zasobów, ograniczenia wynikające z polityk
sprzętu i oprogramowania, wymagania <em>affinity</em> i <em>anty-affinity</em>, lokalizacja danych,
zależności między zadaniami i wymagania czasowe.</p><h3 id=kube-controller-manager>kube-controller-manager</h3><p>Składnik warstwy sterowania odpowiedzialny za uruchamianie <a class=glossary-tooltip title='A control loop that watches the shared state of the cluster through the apiserver and makes changes attempting to move the current state towards the desired state.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=kontrolerów>kontrolerów</a>.</p><p>Z poziomu podziału logicznego, każdy <a class=glossary-tooltip title='A control loop that watches the shared state of the cluster through the apiserver and makes changes attempting to move the current state towards the desired state.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=kontroler>kontroler</a> jest oddzielnym procesem, ale w celu zmniejszenia złożoności, wszystkie kontrolery są skompilowane do jednego programu binarnego i uruchamiane jako jeden proces.</p><p>Przykładowe kontrolery:</p><ul><li>Node controller: Odpowiada za rozpoznawanie i reagowanie na sytuacje, kiedy węzeł staje się z jakiegoś powodu niedostępny.</li><li>Job controller: Czeka na obiekty typu <em>Job</em>, które definiują zadania uruchamiane jednorazowo
i startuje Pody, odpowiadające za ich wykonanie tych zadań.</li><li>Endpoints controller: Dostarcza informacji do obiektów typu <em>Endpoints</em> (tzn. łączy ze sobą Serwisy i Pody).</li><li>Service Account & Token controllers: Tworzy domyślne konta i tokeny dostępu API dla nowych przestrzeni nazw (<em>namespaces</em>).</li></ul><h3 id=cloud-controller-manager>cloud-controller-manager</h3>Element składowy <a class=glossary-tooltip title='The container orchestration layer that exposes the API and interfaces to define, deploy, and manage the lifecycle of containers.' data-toggle=tooltip data-placement=top href='/pl/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='warstwy sterowania'>warstwy sterowania</a> Kubernetesa,
który zarządza usługami realizowanymi po stronie chmur obliczeniowych. Cloud controller manager umożliwia
połączenie Twojego klastra z API operatora usług chmurowych i rozdziela składniki operujące na platformie
chmurowej od tych, które dotyczą wyłącznie samego klastra.<p>cloud-controller-manager uruchamia jedynie kontrolery właściwe dla konkretnego dostawcy usług chmurowych.
Jeśli uruchamiasz Kubernetesa we własnym centrum komputerowym lub w środowisku szkoleniowym na swoim
komputerze, klaster nie będzie miał cloud controller managera.</p><p>Podobnie jak w przypadku kube-controller-manager, cloud-controller-manager łączy w jednym pliku binarnym
kilka niezależnych pętli sterowania. Można go skalować horyzontalnie
(uruchomić więcej niż jedną instancję), aby poprawić wydajność lub zwiększyć odporność na awarie.</p><p>Następujące kontrolery mogą zależeć od dostawców usług chmurowych:</p><ul><li>Node controller: Aby sprawdzić u dostawcy usługi chmurowej, czy węzeł został skasowany po tym, jak przestał odpowiadać</li><li>Route controller: Aby ustawić trasy <em>(routes)</em> w niższych warstwach infrastruktury chmurowej</li><li>Service controller: Aby tworzyć, aktualizować i kasować <em>cloud load balancers</em></li></ul><h2 id=składniki-węzłów>Składniki węzłów</h2><p>Składniki węzłów uruchomiane są na każdym węźle. Utrzymują pody w działaniu i ustawiają środowisko uruchomieniowe Kubernetes.</p><h3 id=kubelet>kubelet</h3><p>Agent, który działa na każdym <a class=glossary-tooltip title='A node is a worker machine in Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/nodes/ target=_blank aria-label=węźle>węźle</a> klastra. Odpowiada za uruchamianie <a class=glossary-tooltip title='A lightweight and portable executable image that contains software and all of its dependencies.' data-toggle=tooltip data-placement=top href=/docs/concepts/containers/ target=_blank aria-label=kontenerów>kontenerów</a> w ramach <a class=glossary-tooltip title='A Pod represents a set of running containers in your cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/ target=_blank aria-label=poda>poda</a>.</p><p>Kubelet korzysta z dostarczanych (różnymi metodami) <em>PodSpecs</em> i gwarantuje, że kontenery opisane przez te PodSpecs są uruchomione i działają poprawnie. Kubelet nie zarządza kontenerami, które nie zostały utworzone przez Kubernetesa.</p><h3 id=kube-proxy>kube-proxy</h3><p>kube-proxy to <em>proxy</em> sieciowe, które uruchomione jest na każdym
<a class=glossary-tooltip title='A node is a worker machine in Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/nodes/ target=_blank aria-label=węźle>węźle</a> klastra
i uczestniczy w tworzeniu
<a class=glossary-tooltip title='A way to expose an application running on a set of Pods as a network service.' data-toggle=tooltip data-placement=top href=/docs/concepts/services-networking/service/ target=_blank aria-label=serwisu>serwisu</a>.</p><p><a href=/docs/reference/command-line-tools-reference/kube-proxy/>kube-proxy</a>
utrzymuje reguły sieciowe na węźle. Dzięki tym regułom
sieci na zewnątrz i wewnątrz klastra mogą komunikować się
z podami.</p><p>kube-proxy używa warstwy filtrowania pakietów dostarczanych przez system operacyjny, o ile taka jest dostępna.
W przeciwnym przypadku, kube-proxy samo zajmuje sie przekazywaniem ruchu sieciowego.</p><h3 id=container-runtime>Container runtime</h3><p><em>Container runtime</em> to oprogramowanie zajmujące się uruchamianiem kontenerów.</p><p>Kubernetes obsługuje różne <em>container runtimes</em>:
<a class=glossary-tooltip title='A container runtime with an emphasis on simplicity, robustness and portability' data-toggle=tooltip data-placement=top href=https://containerd.io/docs/ target=_blank aria-label=containerd>containerd</a>, <a class=glossary-tooltip title='A lightweight container runtime specifically for Kubernetes' data-toggle=tooltip data-placement=top href=https://cri-o.io/#what-is-cri-o target=_blank aria-label=CRI-O>CRI-O</a>
oraz każdą implementację zgodną z <a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-node/container-runtime-interface.md>Kubernetes CRI (Container Runtime
Interface)</a>.</p><h2 id=dodatki>Dodatki (<em>Addons</em>)</h2><p>Dodatki korzystają z podstawowych obiektów Kubernetes (<a class=glossary-tooltip title='Ensures a copy of a Pod is running across a set of nodes in a cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/daemonset target=_blank aria-label=DaemonSet>DaemonSet</a>, <a class=glossary-tooltip title='Manages a replicated application on your cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Deployment>Deployment</a>, itp.), aby rozszerzyć funkcjonalności klastra. Ponieważ są to funkcjonalności obejmujące cały klaster, zasoby te należą do przestrzeni nazw <em>(namespace)</em> <code>kube-system</code>.</p><p>Wybrane dodatki opisano poniżej. Rozszerzona lista dostępnych dodatków jest w części <a href=/docs/concepts/cluster-administration/addons/>Dodatki</a>.</p><h3 id=dns>DNS</h3><p>Mimo, że inne dodatki nie są bezwzględnie wymagane, wszystkie klastry Kubernetes powinny mieć <a href=/docs/concepts/services-networking/dns-pod-service/>cluster DNS</a>, ponieważ wiele przykładów z niego korzysta.</p><p><em>Cluster DNS</em> to serwer DNS, który uzupełnienia inne serwery DNS z twojego środowiska, dostarczając informacje o rekordach DNS dla usług Kubernetes.</p><p>Kontenery uruchomione przez Kubernetes automatycznie przeszukują ten serwer DNS.</p><h3 id=interfejs-użytkownika-dashboard>Interfejs użytkownika (Dashboard)</h3><p><a href=/docs/tasks/access-application-cluster/web-ui-dashboard/>Dashboard</a> to webowy interfejs ogólnego zastosowania przeznaczony dla użytkowników klastra Kubernetes. Umożliwia zarządzanie i rozwiązywanie problemów związanych z aplikacjami uruchamianymi na klastrze, a także z samym klastrem.</p><h3 id=monitorowanie-zasobów-w-kontenerach>Monitorowanie zasobów w kontenerach</h3><p><a href=/docs/tasks/debug-application-cluster/resource-usage-monitoring/>Container Resource Monitoring</a> zapisuje serie czasowe podstawowych metryk kontenerów w centralnej bazie danych i oferuje interfejs użytkownika do przeglądania tych danych.</p><h3 id=logowanie-na-poziomie-klastra>Logowanie na poziomie klastra</h3><p>Mechanizm <a href=/docs/concepts/cluster-administration/logging/>logowania na poziomie klastra</a> odpowiada za zapisywanie logów pochodzących z poszczególnych kontenerów do wspólnego magazynu, który posiada interfejs do przeglądania i przeszukiwania.</p><h2 id=co-dalej>Co dalej?</h2><ul><li>Więcej o <a href=/docs/concepts/architecture/nodes/>Węzłach</a></li><li>Więcej o <a href=/docs/concepts/architecture/controller/>Kontrolerach</a></li><li>Więcej o <a href=/docs/concepts/scheduling-eviction/kube-scheduler/>kube-scheduler</a></li><li>Oficjalna <a href=https://etcd.io/docs/>dokumentacja</a> etcd</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-0c745f42e623d2b70a53bc0e6db73d95>3.1.3 - API Kubernetesa</h1><div class=lead>API Kubernetesa służy do odpytywania i zmiany stanu obiektów Kubernetesa. Sercem warstwy sterowania Kubernetesa jest serwer API i udostępniane po HTTP API. Przez ten serwer odbywa się komunikacja pomiędzy użytkownikami, różnymi częściami składowymi klastra oraz komponentami zewnętrznymi.</div><p>Sercem <a class=glossary-tooltip title='The container orchestration layer that exposes the API and interfaces to define, deploy, and manage the lifecycle of containers.' data-toggle=tooltip data-placement=top href='/pl/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='warstwy sterowania'>warstwy sterowania</a> Kubernetes
jest <a class=glossary-tooltip title='Składnik warstwy sterowania udostępniający API Kubernetesa.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label='serwer API'>serwer API</a>. Serwer udostępnia
API poprzez HTTP, umożliwiając wzajemną komunikację pomiędzy użytkownikami, częściami składowymi klastra
i komponentami zewnętrznymi.</p><p>API Kubernetesa pozwala na sprawdzanie i zmianę stanu obiektów
(przykładowo: pody, <em>Namespaces</em>, <em>ConfigMaps</em>, <em>Events</em>).</p><p>Większość operacji może zostać wykonana poprzez
interfejs linii komend (CLI) <a href=/docs/reference/kubectl/>kubectl</a> lub inne
programy, takie jak
<a href=/docs/reference/setup-tools/kubeadm/>kubeadm</a>, które używają
API. Możesz też korzystać z API bezpośrednio przez wywołania typu REST.</p><p>Jeśli piszesz aplikację używającą API Kubernetesa,
warto rozważyć użycie jednej z <a href=/docs/reference/using-api/client-libraries/>bibliotek klienckich</a>.</p><h2 id=api-specification>Specyfikacja OpenAPI</h2><p>Pełną specyfikację API udokumentowano za pomocą <a href=https://www.openapis.org/>OpenAPI</a>.</p><p>Serwer API Kubernetesa udostępnia specyfikację OpenAPI poprzez
ścieżkę <code>/openapi/v2</code>. Aby wybrać format odpowiedzi,
użyj nagłówków żądania zgodnie z tabelą:</p><table><caption style=display:none>Dopuszczalne wartości nagłówka żądania dla zapytań OpenAPI v2</caption><thead><tr><th>Nagłówek</th><th style=min-width:50%>Dopuszczalne wartości</th><th>Uwagi</th></tr></thead><tbody><tr><td><code>Accept-Encoding</code></td><td><code>gzip</code></td><td><em>pominięcie tego nagłówka jest dozwolone</em></td></tr><tr><td rowspan=3><code>Accept</code></td><td><code>application/com.github.proto-openapi.spec.v2@v1.0+protobuf</code></td><td><em>głównie do celu komunikacji wewnątrz klastra</em></td></tr><tr><td><code>application/json</code></td><td><em>domyślne</em></td></tr><tr><td><code>*</code></td><td><em>udostępnia </em><code>application/json</code></td></tr></tbody></table><p>W Kubernetesie zaimplementowany jest alternatywny format serializacji na potrzeby API oparty o
Protobuf, który jest przede wszystkim przeznaczony na potrzeby wewnętrznej komunikacji w klastrze.
Więcej szczegółów znajduje się w dokumencie <a href=https://git.k8s.io/design-proposals-archive/api-machinery/protobuf.md>Kubernetes Protobuf serialization</a>.
oraz w plikach <em>Interface Definition Language</em> (IDL) dla każdego ze schematów
zamieszczonych w pakietach Go, które definiują obiekty API.</p><h3 id=openapi-v3>OpenAPI V3</h3><div style=margin-top:10px;margin-bottom:10px><b>STATUS FUNKCJONALNOŚCI:</b> <code>Kubernetes v1.24 [beta]</code></div><p>Kubernetes v1.25 publikuje (na razie w wersji roboczej) własne API zgodnie ze specyfikacją OpenAPI v3.
Ta funkcjonalność jest w wersji <em>beta</em> i jest domyślnie włączona.
Funkcjonalności w wersji <em>beta</em> można wyłączać poprzez
<a href=/docs/reference/command-line-tools-reference/feature-gates/>feature gate</a> o nazwie <code>OpenAPIV3</code>
składnika kube-apiserver.</p><p>Pod adresem <code>/openapi/v3</code> można znaleźć listę wszystkich
dostępnych grup/wersji. Zwracane wartości są dostępne tylko w formacie JSON. Grupy/wersje
opisane są następującym schematem:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;paths&#34;: </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>...,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>&#34;api/v1&#34;: </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>&#34;serverRelativeURL&#34;: </span><span style=color:#b44>&#34;/openapi/v3/api/v1?hash=CC0E9BFD992D8C59AEC98A1E2336F899E8318D3CF4C68944C3DEC640AF5AB52D864AC50DAA8D145B3494F75FA3CFF939FCBDDA431DAD3CA79738B297795818CF&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>},<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>&#34;apis/admissionregistration.k8s.io/v1&#34;: </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>&#34;serverRelativeURL&#34;: </span><span style=color:#b44>&#34;/openapi/v3/apis/admissionregistration.k8s.io/v1?hash=E19CC93A116982CE5422FC42B590A8AFAD92CDE9AE4D59B5CAAD568F083AD07946E6CB5817531680BCE6E215C16973CD39003B0425F3477CFD854E89A9DB6597&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>},<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>....<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></span></span></code></pre></div><p>Względne adresy URL wskazują na niezmieniające się opisy OpenAPI,
aby umożliwić trzymanie cache po stronie klienta. Serwer API zwraca
również odpowiednie nagłówki HTTP dla cache (<code>Expires</code> ustawione na 1 rok wprzód,
<code>Cache-Control</code> jako <code>immutable</code>). Wysłanie zapytania do nieaktualnego URL
spowoduje przekierowanie przez serwer API do wersji najnowszej.</p><p>Serwer API Kubernetesa udostępnia specyfikację OpenAPI v3
pod adresem <code>/openapi/v3/apis/&lt;group>/&lt;version>?hash=&lt;hash></code>,
zgodnie z podziałem na grupy i wersje.</p><p>Tabela poniżej podaje dopuszczalne wartości nagłówków żądania.</p><table><caption style=display:none>Dopuszczalne wartości nagłówka żądania dla zapytań OpenAPI v3</caption><thead><tr><th>Nagłówek</th><th style=min-width:50%>Dopuszczalne wartości</th><th>Uwagi</th></tr></thead><tbody><tr><td><code>Accept-Encoding</code></td><td><code>gzip</code></td><td><em>pominięcie tego nagłówka jest dozwolone</em></td></tr><tr><td rowspan=3><code>Accept</code></td><td><code>application/com.github.proto-openapi.spec.v3@v1.0+protobuf</code></td><td><em>głównie do celu komunikacji wewnątrz klastra</em></td></tr><tr><td><code>application/json</code></td><td><em>domyślne</em></td></tr><tr><td><code>*</code></td><td><em>udostępnia </em><code>application/json</code></td></tr></tbody></table><h2 id=przechowywanie-stanu>Przechowywanie stanu</h2><p>Kubernetes przechowuje serializowany stan swoich obiektów w
<a class=glossary-tooltip title='Magazyn typu klucz-wartość (key/value store), zapewniający spójność i wysoką dostępność, używany do przechowywania wszystkich danych o klastrze Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/tasks/administer-cluster/configure-upgrade-etcd/ target=_blank aria-label=etcd>etcd</a>.</p><h2 id=grupy-i-wersje-api>Grupy i wersje API</h2><p>Aby ułatwić usuwanie poszczególnych pól lub restrukturyzację reprezentacji zasobów, Kubernetes obsługuje
równocześnie wiele wersji API, każde poprzez osobną ścieżkę API,
na przykład: <code>/api/v1</code> lub <code>/apis/rbac.authorization.k8s.io/v1alpha1</code>.</p><p>Rozdział wersji wprowadzony jest na poziomie całego API, a nie na poziomach poszczególnych zasobów lub pól,
aby być pewnym, że API odzwierciedla w sposób przejrzysty i spójny zasoby systemowe
i ich zachowania oraz pozwala na kontrolowany dostęp do tych API, które są w fazie wycofywania
lub fazie eksperymentalnej.</p><p>Aby ułatwić rozbudowę API Kubernetes, wprowadziliśmy
<a href=https://git.k8s.io/community/contributors/design-proposals/api-machinery/api-group.md><em>grupy API</em></a>, które mogą
być <a href=/docs/reference/using-api/#enabling-or-disabling>włączane i wyłączane</a>.</p><p>Zasoby API są rozróżniane poprzez przynależność do grupy API, typ zasobu, przestrzeń nazw (<em>namespace</em>,<br>o ile ma zastosowanie) oraz nazwę. Serwer API może przeprowadzać konwersję między
różnymi wersjami API w sposób niewidoczny dla użytkownika: wszystkie te różne wersje
reprezentują w rzeczywistości ten sam zasób. Serwer API może udostępniać te same dane
poprzez kilka różnych wersji API.</p><p>Załóżmy przykładowo, że istnieją dwie wersje <code>v1</code> i <code>v1beta1</code> tego samego zasobu.
Obiekt utworzony przez wersję <code>v1beta1</code> może być odczytany,
zaktualizowany i skasowany zarówno przez wersję
<code>v1beta1</code>, jak i <code>v1</code>.</p><h2 id=trwałość-api>Trwałość API</h2><p>Z naszego doświadczenia wynika, że każdy system, który odniósł sukces, musi się nieustająco rozwijać w miarę zmieniających się potrzeb.
Dlatego Kubernetes został tak zaprojektowany, aby API mogło się zmieniać i rozrastać.
Projekt Kubernetes dąży do tego, aby nie wprowadzać zmian niezgodnych z istniejącymi aplikacjami klienckimi
i utrzymywać zgodność przez wystarczająco długi czas, aby inne projekty zdążyły się dostosować do zmian.</p><p>W ogólności, nowe zasoby i pola definiujące zasoby API są dodawane stosunkowo często.
Usuwanie zasobów lub pól jest regulowane przez
<a href=/docs/reference/using-api/deprecation-policy/>API deprecation policy</a>.</p><p>Po osiągnięciu przez API statusu ogólnej dostępności (<em>general availability</em> - GA),
oznaczanej zazwyczaj jako wersja API <code>v1</code>, bardzo zależy nam na utrzymaniu jej zgodności w kolejnych wydaniach.
Kubernetes utrzymuje także zgodność dla wersji <em>beta</em> API tam, gdzie jest to możliwe:
jeśli zdecydowałeś się używać API w wersji beta, możesz z niego korzystać także później,
kiedy dana funkcjonalność osiągnie status stabilnej.</p><div class="alert alert-info note callout" role=alert><strong>Informacja:</strong> Mimo, że Kubernetes stara się także zachować zgodność dla API w wersji <em>alpha</em>, zdarzają się przypadki,
kiedy nie jest to możliwe. Jeśli korzystasz z API w wersji alfa, przed aktualizacją klastra do nowej wersji
zalecamy sprawdzenie w informacjach o wydaniu, czy nie nastąpiła jakaś zmiana w tej części API.</div><p>Zajrzyj do <a href=/docs/reference/using-api/#api-versioning>API versions reference</a>
po szczegółowe definicje różnych poziomów wersji API.</p><h2 id=rozbudowa-api>Rozbudowa API</h2><p>API Kubernetesa można rozszerzać na dwa sposoby:</p><ol><li><a href=/docs/concepts/extend-kubernetes/api-extension/custom-resources/>Definicje zasobów własnych (<em>custom resources</em>)</a>
pozwalają deklaratywnie określać, jak serwer API powinien dostarczać wybrane przez Ciebie zasoby API.</li><li>Można także rozszerzać API Kubernetesa implementując
<a href=/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>warstwę agregacji</a>.</li></ol><h2 id=co-dalej>Co dalej?</h2><ul><li>Naucz się, jak rozbudowywać API Kubernetesa poprzez dodawanie własnych
<a href=/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/>CustomResourceDefinition</a>.</li><li><a href=/docs/concepts/security/controlling-access/>Controlling Access To The Kubernetes API</a> opisuje
sposoby, jakimi klaster zarządza dostępem do API.</li><li>Punkty dostępowe API <em>(endpoints)</em>, typy zasobów i przykłady zamieszczono w
<a href=/docs/reference/kubernetes-api/>API Reference</a>.</li><li>Aby dowiedzieć się, jaki rodzaj zmian można określić jako zgodne i jak zmieniać API, zajrzyj do
<a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api_changes.md#readme>API changes</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-f8918f697450c2009b75913f9e9317a5>4 - Zadania</h1><p>W tej części dokumentacji Kubernetesa znajdują się opisy
sposobu realizacji różnych zadań. Przedstawione są one zazwyczaj jako
krótka sekwencja kilku kroków związanych z pojedynczym zadaniem.</p><p>Jeśli chciałbyś stworzyć nową stronę poświęconą jakiemuś zadaniu, przeczytaj
<a href=/docs/contribute/new-content/open-a-pr/>Jak przygotować propozycję zmian (PR)</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-68ec2370d0409cc27325be36693f9368>5 - Samouczki</h1><p>W tym rozdziale dokumentacji Kubernetes znajdziesz różne samouczki.
Dzięki nim dowiesz się, jak osiągnąć złożone cele, które przekraczają wielkość
pojedynczego <a href=/docs/tasks/>zadania</a>. Typowy samouczek podzielony jest na kilka części,
z których każda zawiera sekwencję odpowiednich kroków.
Przed zapoznaniem się z samouczkami warto stworzyć zakładkę do
<a href=/docs/reference/glossary/>słownika</a>, aby móc się później do niego na bieżąco odwoływać.</p><h2 id=podstawy>Podstawy</h2><ul><li><p><a href=/pl/docs/tutorials/kubernetes-basics/>Podstawy Kubernetesa</a> (PL) to interaktywny samouczek, który pomoże zrozumieć system Kubernetes i wypróbować jego podstawowe możliwości.</p></li><li><p><a href=https://www.edx.org/course/introduction-kubernetes-linuxfoundationx-lfs158x#>Introduction to Kubernetes (edX)</a></p></li><li><p><a href=/pl/docs/tutorials/hello-minikube/>Hello Minikube</a> (PL)</p></li></ul><h2 id=konfiguracja>Konfiguracja</h2><ul><li><p><a href=/docs/tutorials/configuration/configure-java-microservice/>Configuring a Java Microservice</a></p></li><li><p><a href=/docs/tutorials/configuration/configure-redis-using-configmap/>Configuring Redis Using a ConfigMap</a></p></li></ul><h2 id=aplikacje-bezstanowe-stateless-applications>Aplikacje bezstanowe <em>(Stateless Applications)</em></h2><ul><li><p><a href=/docs/tutorials/stateless-application/expose-external-ip-address/>Exposing an External IP Address to Access an Application in a Cluster</a></p></li><li><p><a href=/docs/tutorials/stateless-application/guestbook/>Example: Deploying PHP Guestbook application with Redis</a></p></li></ul><h2 id=aplikacje-stanowe-stateful-applications>Aplikacje stanowe <em>(Stateful Applications)</em></h2><ul><li><p><a href=/docs/tutorials/stateful-application/basic-stateful-set/>StatefulSet Basics</a></p></li><li><p><a href=/docs/tutorials/stateful-application/mysql-wordpress-persistent-volume/>Example: WordPress and MySQL with Persistent Volumes</a></p></li><li><p><a href=/docs/tutorials/stateful-application/cassandra/>Example: Deploying Cassandra with Stateful Sets</a></p></li><li><p><a href=/docs/tutorials/stateful-application/zookeeper/>Running ZooKeeper, A CP Distributed System</a></p></li></ul><h2 id=serwisy>Serwisy</h2><ul><li><a href=/docs/tutorials/services/source-ip/>Using Source IP</a></li></ul><h2 id=bezpieczeństwo>Bezpieczeństwo</h2><ul><li><a href=/docs/tutorials/security/cluster-level-pss/>Apply Pod Security Standards at Cluster level</a></li><li><a href=/docs/tutorials/security/ns-level-pss/>Apply Pod Security Standards at Namespace level</a></li><li><a href=/docs/tutorials/security/apparmor/>AppArmor</a></li><li><a href=/docs/tutorials/security/seccomp/>seccomp</a></li></ul><h2 id=co-dalej>Co dalej?</h2><p>Jeśli chciałbyś napisać nowy samouczek, odwiedź
<a href=/docs/contribute/style/page-content-types/>Content Page Types</a>,
gdzie znajdziesz dodatkowe informacje o tym typie strony.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-5e3051fff9e84735871d9fb5e7b93f33>5.1 - Hello Minikube</h1><p>Ten samouczek pokaże, jak uruchomić przykładową aplikację
na Kubernetesie przy użyciu minikube oraz Katacoda.
Katacoda to darmowe środowisko Kubernetes dostępne bezpośrednio z przeglądarki web.</p><div class="alert alert-info note callout" role=alert><strong>Informacja:</strong> Możesz też skorzystać z tego samouczka, jeśli już zainstalowałeś minikube.
Odwiedź stronę <a href=https://minikube.sigs.k8s.io/docs/start/>minikube start</a>, aby dowiedzieć się, jak go zainstalować.</div><h2 id=cele>Cele</h2><ul><li>Skonfiguruj przykładową aplikację do uruchomienia w minikube.</li><li>Uruchom aplikację.</li><li>Przejrzyj jej logi.</li></ul><h2 id=nim-zaczniesz>Nim zaczniesz</h2><p>W tym samouczku wykorzystamy obraz kontenera, który korzysta z NGINX, aby wyświetlić z powrotem wszystkie przychodzące zapytania.</p><h2 id=stwórz-klaster-minikube>Stwórz klaster minikube</h2><ol><li><p>Kliknij w <strong>Launch Terminal</strong></p><script defer src=https://katacoda.com/embed.js></script>
<button class=button onclick=window.katacoda.init()>Launch Terminal</button><div class="alert alert-info note callout" role=alert><strong>Informacja:</strong> Jeśli masz minikube zainstalowane lokalnie, uruchom <code>minikube start</code>. Przed uruchomieniem <code>minikube dashboard</code>, otwórz okno nowego terminala, uruchom w nim <code>minikube dashboard</code> i przełącz się z powrotem do okna głównego terminala.</div></li><li><p>Otwórz panel Kubernetesa w przeglądarce:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>minikube dashboard
</span></span></code></pre></div></li><li><p>Tylko w Katacoda: Na górze okienka z terminalem kliknij na znak plus, a następnie wybierz <strong>Select port to view on Host 1</strong>.</p></li><li><p>Tylko w Katacoda: Wpisz <code>30000</code>i kliknij <strong>Display Port</strong>.</p></li></ol><div class="alert alert-info note callout" role=alert><strong>Informacja:</strong><p>Polecenie <code>dashboard</code> uruchamia dodatek panelu i otwiera proxy w domyślnej przeglądarce.
W panelu można tworzyć różne obiekty Kubernetesa, takie jak <em>Deployment</em> czy <em>Serwis</em>.</p><p>Jeśli pracujesz z uprawnieniami roota, skorzystaj z: <a href=#otwieranie-panelu-poprzez-url>Otwieranie panelu poprzez URL</a>.</p><p>Panel jest domyślnie dostępny jedynie z wewnętrznej sieci Kubernetesa.
Polecenie <code>dashboard</code> tworzy tymczasowe proxy, które udostępnia panel także poza tą wewnętrzną sieć.</p><p>Aby zatrzymać proxy, wciśnij <code>Ctrl+C</code> i zakończ proces.
Panel ciągle działa na klastrze Kubernetesa, nawet po przerwaniu działania proxy.
Aby dostać się ponownie do panelu, trzeba stworzyć kolejne proxy poleceniem <code>dashboard</code>.</p></div><h2 id=otwieranie-panelu-poprzez-url>Otwieranie panelu poprzez URL</h2><p>Jeśli nie chcesz otwierać przeglądarki, uruchom panel z opcją <code>--url</code>, aby wyświetlić URL:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>minikube dashboard --url
</span></span></code></pre></div><h2 id=stwórz-deployment>Stwórz Deployment</h2><p><a href=/docs/concepts/workloads/pods/><em>Pod</em></a> w Kubernetesie to grupa jednego lub wielu kontenerów
połączonych ze sobą na potrzeby administrowania i dostępu sieci. W tym samouczku Pod
zawiera tylko jeden kontener. <a href=/docs/concepts/workloads/controllers/deployment/><em>Deployment</em></a>
w Kubernetesie monitoruje stan twojego Poda
i restartuje należące do niego kontenery, jeśli z jakichś powodów przestaną działać.
Użycie Deploymentu to rekomendowana metoda zarządzania tworzeniem i skalowaniem Podów.</p><ol><li><p>Użyj polecenia <code>kubectl create</code> do stworzenia Deploymentu, który będzie zarządzał Podem. Pod uruchamia kontener
wykorzystując podany obraz Dockera.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create deployment hello-node --image<span style=color:#666>=</span>k8s.gcr.io/echoserver:1.4
</span></span></code></pre></div></li><li><p>Sprawdź stan Deploymentu:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get deployments
</span></span></code></pre></div><p>Wynik powinien wyglądać podobnie do:</p><pre tabindex=0><code>NAME         READY   UP-TO-DATE   AVAILABLE   AGE
hello-node   1/1     1            1           1m
</code></pre></li><li><p>Sprawdź stan Poda:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods
</span></span></code></pre></div><p>Wynik powinien wyglądać podobnie do:</p><pre tabindex=0><code>NAME                          READY     STATUS    RESTARTS   AGE
hello-node-5f76cf6ccf-br9b5   1/1       Running   0          1m
</code></pre></li><li><p>Obejrzyj zdarzenia na klastrze:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get events
</span></span></code></pre></div></li><li><p>Sprawdź konfigurację <code>kubectl</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config view
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Informacja:</strong> Więcej informacji na temat polecenia <code>kubectl</code> znajdziesz w <a href=/docs/reference/kubectl/overview/>przeglądzie kubectl</a>.</div></li></ol><h2 id=stwórz-serwis>Stwórz Serwis</h2><p>Domyślnie Pod jest dostępny tylko poprzez swój wewnętrzny adres IP
wewnątrz klastra Kubernetes. Aby kontener <code>hello-node</code> był osiągalny spoza
wirtualnej sieci Kubernetesa, musisz najpierw udostępnić Pod
jako <a href=/docs/concepts/services-networking/service/><em>Serwis</em></a> Kubernetes.</p><ol><li><p>Udostępnij Pod w Internecie przy pomocy polecenia <code>kubectl expose</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl expose deployment hello-node --type<span style=color:#666>=</span>LoadBalancer --port<span style=color:#666>=</span><span style=color:#666>8080</span>
</span></span></code></pre></div><p>Opcja <code>--type=LoadBalancer</code> wskazuje, że chcesz udostępnić swój Serwis
na zewnątrz klastra.</p><p>Aplikacja, która jest umieszczona w obrazie kontenera <code>k8s.gcr.io/echoserver</code>, nasłuchuje jedynie na porcie TCP 8080. Jeśli użyłeś
<code>kubectl expose</code> do wystawienia innego portu, aplikacje klienckie mogą nie móc się podłączyć do tamtego innego portu.</p></li><li><p>Sprawdź Serwis, który właśnie utworzyłeś:</p><pre tabindex=0><code>kubectl get services
</code></pre><p>Wynik powinien wyglądać podobnie do:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME         TYPE           CLUSTER-IP      EXTERNAL-IP   PORT<span style=color:#666>(</span>S<span style=color:#666>)</span>          AGE
</span></span><span style=display:flex><span>hello-node   LoadBalancer   10.108.144.78   &lt;pending&gt;     8080:30369/TCP   21s
</span></span><span style=display:flex><span>kubernetes   ClusterIP      10.96.0.1       &lt;none&gt;        443/TCP          23m
</span></span></code></pre></div><p>U dostawców usług chmurowych, którzy obsługują <em>load balancers</em>,
zostanie przydzielony zewnętrzny adres IP na potrzeby serwisu.
W minikube, typ <code>LoadBalancer</code> udostępnia serwis poprzez polecenie
<code>minikube service</code>.</p></li><li><p>Uruchom poniższe polecenie:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>minikube service hello-node
</span></span></code></pre></div></li><li><p>Tylko w Katacoda: Kliknij znak plus, a następnie <strong>Select port to view on Host 1</strong>.</p></li><li><p>Tylko w Katacoda: Wpisz <code>30369</code> (sprawdź numer portu obok <code>8080</code> w opisie Serwisu) i kliknij <strong>Display Port</strong></p><p>Otworzy sie okno przeglądarki obsługującej twoją aplikację i wyświetli odpowiedź tej aplikacji.</p></li></ol><h2 id=włącz-dodatki>Włącz dodatki</h2><p>Narzędzie minikube dysponuje zestawem wbudowanych <a class=glossary-tooltip title='Resources that extend the functionality of Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/concepts/cluster-administration/addons/ target=_blank aria-label=dodatków>dodatków</a>, które mogą być włączane, wyłączane i otwierane w lokalnym środowisku Kubernetes.</p><ol><li><p>Lista aktualnie obsługiwanych dodatków:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>minikube addons list
</span></span></code></pre></div><p>Wynik powinien wyglądać podobnie do:</p><pre tabindex=0><code>addon-manager: enabled
dashboard: enabled
default-storageclass: enabled
efk: disabled
freshpod: disabled
gvisor: disabled
helm-tiller: disabled
ingress: disabled
ingress-dns: disabled
logviewer: disabled
metrics-server: disabled
nvidia-driver-installer: disabled
nvidia-gpu-device-plugin: disabled
registry: disabled
registry-creds: disabled
storage-provisioner: enabled
storage-provisioner-gluster: disabled
</code></pre></li><li><p>Włącz dodatek, na przykład <code>metrics-server</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>minikube addons <span style=color:#a2f>enable</span> metrics-server
</span></span></code></pre></div><p>Wynik powinien wyglądać podobnie do:</p><pre tabindex=0><code>The &#39;metrics-server&#39; addon is enabled
</code></pre></li><li><p>Sprawdź Pody i Serwisy, który właśnie stworzyłeś:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod,svc -n kube-system
</span></span></code></pre></div><p>Wynik powinien wyglądać podobnie do:</p><pre tabindex=0><code>NAME                                        READY     STATUS    RESTARTS   AGE
pod/coredns-5644d7b6d9-mh9ll                1/1       Running   0          34m
pod/coredns-5644d7b6d9-pqd2t                1/1       Running   0          34m
pod/metrics-server-67fb648c5                1/1       Running   0          26s
pod/etcd-minikube                           1/1       Running   0          34m
pod/influxdb-grafana-b29w8                  2/2       Running   0          26s
pod/kube-addon-manager-minikube             1/1       Running   0          34m
pod/kube-apiserver-minikube                 1/1       Running   0          34m
pod/kube-controller-manager-minikube        1/1       Running   0          34m
pod/kube-proxy-rnlps                        1/1       Running   0          34m
pod/kube-scheduler-minikube                 1/1       Running   0          34m
pod/storage-provisioner                     1/1       Running   0          34m

NAME                           TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)             AGE
service/metrics-server         ClusterIP   10.96.241.45    &lt;none&gt;        80/TCP              26s
service/kube-dns               ClusterIP   10.96.0.10      &lt;none&gt;        53/UDP,53/TCP       34m
service/monitoring-grafana     NodePort    10.99.24.54     &lt;none&gt;        80:30002/TCP        26s
service/monitoring-influxdb    ClusterIP   10.111.169.94   &lt;none&gt;        8083/TCP,8086/TCP   26s
</code></pre></li><li><p>Wyłącz dodatek <code>metrics-server</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>minikube addons disable metrics-server
</span></span></code></pre></div><p>Wynik powinien wyglądać podobnie do:</p><pre tabindex=0><code>metrics-server was successfully disabled
</code></pre></li></ol><h2 id=porządkujemy-po-sobie>Porządkujemy po sobie</h2><p>Teraz jest czas na wyczyszczenie zasobów, które utworzyłeś w klastrze:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete service hello-node
</span></span><span style=display:flex><span>kubectl delete deployment hello-node
</span></span></code></pre></div><p>(Opcjonalnie) Zatrzymaj wirtualną maszynę Minikube (VM):</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>minikube stop
</span></span></code></pre></div><p>(Opcjonalnie) Skasuj Minikube VM:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>minikube delete
</span></span></code></pre></div><h2 id=co-dalej>Co dalej?</h2><ul><li>Dowiedz się więcej o <a href=/docs/concepts/workloads/controllers/deployment/>obiektach typu Deployment</a>.</li><li>Dowiedz się więcej o <a href=/docs/tasks/run-application/run-stateless-application-deployment/>instalowaniu aplikacji</a>.</li><li>Dowiedz się więcej o <a href=/docs/concepts/services-networking/service/>obiektach typu Serwis</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-3c83f53a74233ace9b289ac5e24c3e62>5.2 - Naucz się podstaw</h1><!doctype html><html lang=pl><body><link href=/docs/tutorials/kubernetes-basics/public/css/styles.css rel=stylesheet><div class=layout id=top><main class=content><div class=row><div class=col-md-9><h2>Podstawy Kubernetesa</h2><p>Ten samouczek poprowadzi Cię przez podstawy systemu zarządzania zadaniami na klastrze Kubernetes. W każdym module znajdziesz najważniejsze informacje o głównych pojęciach i funkcjonalnościach Kubernetes oraz interaktywny samouczek online. Dzięki samouczkom nauczysz się zarządzać prostym klasterem i skonteneryzowanymi aplikacjami uruchamianymi na tym klastrze.</p><p>Nauczysz się, jak:</p><ul><li>Zainstalować skonteneryzowaną aplikację na klastrze.</li><li>Wyskalować tę instalację.</li><li>Zaktualizować aplikację do nowej wersji.</li><li>Rozwiązywać problemy z aplikacją.</li></ul><p>Ten samouczek korzysta z Katacoda do uruchomienia wirtualnego terminalu w przeglądarce. W terminalu dostępny jest Minikube, niewielka lokalna instalacja Kubernetes, która może być uruchamiana z dowolnego miejsca. Nie ma konieczności instalowania ani konfigurowania żadnego oprogramowania. Każdy z interaktywnych samouczków jest wykonywany bezpośrednio w przeglądarce.</p></div></div><br><div class=row><div class=col-md-9><h2>Co Kubernetes może dla Ciebie zrobić?</h2><p>Użytkownicy oczekują od współczesnych serwisów internetowych dostępności non-stop, a deweloperzy chcą móc instalować nowe wersje swoich serwisów kilka razy dziennie. Używając kontenerów można przygotowywać oprogramowanie w taki sposób, aby mogło być instalowane i aktualizowane nie powodując żadnych przestojów. Kubernetes pomaga uruchamiać te aplikacje w kontenerach tam, gdzie chcesz i kiedy chcesz i znajdować niezbędne zasoby i narzędzia wymagane do ich pracy. Kubernetes może działać w środowiskach produkcyjnych, jest otwartym oprogramowaniem zaprojektowanym z wykorzystaniem nagromadzonego przez Google doświadczenia w zarządzaniu kontenerami, w połączeniu z najcenniejszymi ideami społeczności.</p></div></div><br><div id=basics-modules class=content__modules><h2>Podstawy Kubernetes — Moduły</h2><div class=row><div class=col-md-12><div class=row><div class=col-md-4><div class=thumbnail><a href=/pl/docs/tutorials/kubernetes-basics/create-cluster/cluster-intro/><img src="/docs/tutorials/kubernetes-basics/public/images/module_01.svg?v=1469803628347" alt></a><div class=caption><a href=/pl/docs/tutorials/kubernetes-basics/create-cluster/cluster-intro/><h5>1. Zbuduj klaster Kubernetes</h5></a></div></div></div><div class=col-md-4><div class=thumbnail><a href=/pl/docs/tutorials/kubernetes-basics/deploy-app/deploy-intro/><img src="/docs/tutorials/kubernetes-basics/public/images/module_02.svg?v=1469803628347" alt></a><div class=caption><a href=/pl/docs/tutorials/kubernetes-basics/deploy-app/deploy-intro/><h5>2. Zainstaluj aplikację</h5></a></div></div></div><div class=col-md-4><div class=thumbnail><a href=/pl/docs/tutorials/kubernetes-basics/explore/explore-intro/><img src="/docs/tutorials/kubernetes-basics/public/images/module_03.svg?v=1469803628347" alt></a><div class=caption><a href=/pl/docs/tutorials/kubernetes-basics/explore/explore-intro/><h5>3. Zapoznaj się z aplikacją</h5></a></div></div></div></div></div><div class=col-md-12><div class=row><div class=col-md-4><div class=thumbnail><a href=/pl/docs/tutorials/kubernetes-basics/expose/expose-intro/><img src="/docs/tutorials/kubernetes-basics/public/images/module_04.svg?v=1469803628347" alt></a><div class=caption><a href=/pl/docs/tutorials/kubernetes-basics/expose/expose-intro/><h5>4. Udostępnij aplikację publicznie</h5></a></div></div></div><div class=col-md-4><div class=thumbnail><a href=/pl/docs/tutorials/kubernetes-basics/scale/scale-intro/><img src="/docs/tutorials/kubernetes-basics/public/images/module_05.svg?v=1469803628347" alt></a><div class=caption><a href=/pl/docs/tutorials/kubernetes-basics/scale/scale-intro/><h5>5. Skaluj aplikację</h5></a></div></div></div><div class=col-md-4><div class=thumbnail><a href=/pl/docs/tutorials/kubernetes-basics/update/update-intro/><img src="/docs/tutorials/kubernetes-basics/public/images/module_06.svg?v=1469803628347" alt></a><div class=caption><a href=/pl/docs/tutorials/kubernetes-basics/update/update-intro/><h5>6. Zaktualizuj aplikację</h5></a></div></div></div></div></div></div></div></main></div></body></html></div><div class=td-content style=page-break-before:always><h1 id=pg-7df66040311338d6098ebeab43ba9afb>5.2.1 - Tworzenie klastra</h1><p>Poznaj <a class=glossary-tooltip title='Zestaw maszyn roboczych, nazywanych , na których uruchamiane są aplikacje w kontenerach. Każdy klaster musi posiadać przynajmniej jeden węzeł.' data-toggle=tooltip data-placement=top href='/pl/docs/reference/glossary/?all=true#term-cluster' target=_blank aria-label=klaster>klaster</a> Kubernetesa i naucz się, jak stworzyć jego prostą wersję przy pomocy Minikube.</p></div><div class=td-content><h1 id=pg-de49316920e97a82e36763cb66781ada>5.2.1.1 - Jak użyć Minikube do stworzenia klastra</h1><!doctype html><html lang=pl><body><link href=/docs/tutorials/kubernetes-basics/public/css/styles.css rel=stylesheet><div class=layout id=top><main class=content><div class=row><div class=col-md-8><h3>Cele</h3><ul><li>Nauczyć się, czym jest klaster Kubernetes.</li><li>Nauczyć się, czym jest Minikube.</li><li>Uruchomić klaster Kubernetes przy pomocy terminala online.</li></ul></div><div class=col-md-8><h3>Klaster Kubernetes</h3><p><b>Zadaniem Kubernetesa jest zarządzanie klastrem komputerów o wysokiej dostępności, działającego jako jedna całość.</b> Kubernetes, poprzez swój system obiektów abstrakcyjnych, umożliwia uruchamianie aplikacji w kontenerach bez przypisywania ich do konkretnej maszyny. Aby móc korzystać z tego nowego modelu instalacji, aplikacje muszą być przygotowane w taki sposób, aby były niezależne od konkretnego serwera: muszą być skonteneryzowane. Aplikacje w kontenerach są bardziej elastyczne przy instalacji, niż to miało miejsce w poprzednich modelach, kiedy aplikacje były instalowane bezpośrednio na konkretne maszyny jako pakiety ściśle powiązane z tą maszyną. <b>Kubernetes automatyzuje dystrybucję i zlecanie uruchamiania aplikacji na klastrze w bardziej efektywny sposób.</b> Kubernetes jest platformą otwartego oprogramowania, gotowym do pracy w środowiskach produkcyjnych.</p><p>Klaster Kubernetes składa się z dwóch rodzajów zasobów:<ul><li><b>Warstwa sterowania</b> koordynuje działanie klastra</li><li>Na <b>węzłach <i>(nodes)</i></b> uruchamiane są aplikacje</li></ul></p></div><div class=col-md-4><div class="content__box content__box_lined"><h3>Podsumowanie:</h3><ul><li>Klaster Kubernetes</li><li>Minikube</li></ul></div><div class="content__box content__box_fill"><p><i>Kubernetes to platforma oprogramowania typu open source, gotowa do pracy w środowiskach produkcyjnych, która zarządza rozmieszczeniem i uruchomieniem kontenerów zawierających aplikacje na klastrach komputerowych.</i></p></div></div></div><br><div class=row><div class=col-md-8><h2 style=color:#3771e3>Schemat klastra</h2></div></div><div class=row><div class=col-md-8><p><img src=/docs/tutorials/kubernetes-basics/public/images/module_01_cluster.svg></p></div></div><br><div class=row><div class=col-md-8><p><b>Warstwa sterowania odpowiada za zarządzanie klastrem.</b> Warstwa sterowania koordynuje wszystkie działania klastra, takie jak zlecanie uruchomienia aplikacji, utrzymywanie pożądanego stanu aplikacji, skalowanie aplikacji i instalowanie nowych wersji.</p><p><b>Węzeł to maszyna wirtualna (VM) lub fizyczny serwer, który jest maszyną roboczą w klastrze Kubernetes.</b> Na każdym węźle działa Kubelet, agent zarządzający tym węzłem i komunikujący się z warstwą sterowania Kubernetesa. Węzeł zawiera także narzędzia do obsługi kontenerów, takie jak containerd lub Docker. Klaster Kubernetes w środowisku produkcyjnym powinien składać się minimum z trzech węzłów, ponieważ w przypadku awarii jednego węzła traci się zarówno element etcd, jak i warstwy sterowania przy jednoczesnym zachowaniu minimalnej nadmiarowości (<em>redundancy</em>). Dodanie kolejnych węzłów warstwy sterowania może temu zapobiec.</p></p></div><div class=col-md-4><div class="content__box content__box_fill"><p><i>Warstwa sterowania zarządza klastrem i węzłami wykorzystywanymi do uruchamiania aplikacji.</i></p></div></div></div><div class=row><div class=col-md-8><p>Kiedy instalujesz aplikację na Kubernetesie, zlecasz warstwie sterowania uruchomienie kontenera z aplikacją. Warstwa sterowania zleca uruchomienie kontenera na węzłach klastra. <b>Węzły komunikują się z warstwą sterowania przy użyciu <a href=/docs/concepts/overview/kubernetes-api/>API Kubernetesa</a></b>, udostępnianego poprzez warstwę sterowania. Użytkownicy końcowi mogą korzystać bezpośrednio z API Kubernetesa do komunikacji z klastrem.</p><p>Klaster Kubernetes może być zainstalowany zarówno na fizycznych, jak i na maszynach wirtualnych. Aby wypróbować Kubernetesa, można też wykorzystać Minikube. Minikube to "lekka" implementacja Kubernetesa, która tworzy VM na maszynie lokalnej i instaluje prosty klaster składający się tylko z jednego węzła. Minikube jest dostępny na systemy Linux, macOS i Windows. Narzędzie linii poleceń Minikube obsługuje podstawowe operacje na klastrze, takie jak start, stop, prezentacja informacji jego stanie i usunięcie klastra. Na potrzeby tego samouczka wykorzystamy jednak terminal online z zainstalowanym już wcześniej Minikube.</p><p>Teraz, kiedy już wiesz, co to jest Kubernetes, przejdźmy do samouczka online i stwórzmy nasz pierwszy klaster!</p></div></div><br><div class=row><div class=col-md-12><a class="btn btn-lg btn-success" href=/pl/docs/tutorials/kubernetes-basics/create-cluster/cluster-interactive/ role=button>Uruchom interaktywny samouczek <span class=btn__next>›</span></a></div></div></main></div></body></html></div><div class=td-content style=page-break-before:always><h1 id=pg-323b75976001e8dfe35d67d61bc74f1a>5.2.1.2 - Interaktywny samouczek - Tworzenie klastra</h1><!doctype html><html lang=pl><body><link href=/docs/tutorials/kubernetes-basics/public/css/styles.css rel=stylesheet><link href=/docs/tutorials/kubernetes-basics/public/css/overrides.css rel=stylesheet><script src=https://katacoda.com/embed.js></script><div class=layout id=top><main class="content katacoda-content"><div class=katacoda><div class=katacoda__alert>Ekran jest za wąski do pracy z terminalem. Użyj wersji na desktop/tablet.</div><div class=katacoda__box id=inline-terminal-1 data-katacoda-id=kubernetes-bootcamp/1 data-katacoda-color=326de6 data-katacoda-secondary=273d6d data-katacoda-hideintro=false data-katacoda-prompt="Kubernetes Bootcamp Terminal" style=height:600px></div></div><div class=row><div class=col-md-12><a class="btn btn-lg btn-success" href=/pl/docs/tutorials/kubernetes-basics/ role=button>Początek<span></span></a>
<a class="btn btn-lg btn-success" href=/pl/docs/tutorials/kubernetes-basics/deploy-app/deploy-intro/ role=button>Przejdź do modułu 2 ><span></span></a></div></div></main></div></body></html></div><div class=td-content style=page-break-before:always><h1 id=pg-76d78b3fba507f7ed33cef14a35b631d>5.2.2 - Instalowanie aplikacji</h1></div><div class=td-content><h1 id=pg-2b1bba431989008c7493109a0f049ece>5.2.2.1 - Jak użyć kubectl do tworzenia Deploymentu</h1><!doctype html><html lang=pl><body><link href=/docs/tutorials/kubernetes-basics/public/css/styles.css rel=stylesheet><div class=layout id=top><main class=content><div class=row><div class=col-md-8><h3>Cele</h3><ul><li>Nauczyć się jak działa Deployment dla aplikacji.</li><li>Zainstalować pierwszą aplikację używając kubectl.</li></ul></div><div class=col-md-8><h3>Instalacje w Kubernetes</h3><p>Mając działający klaster Kubernetes, można na nim zacząć instalować aplikacje.
W tym celu należy skonfigurować <b>Deployment</b>. Deployment informuje Kubernetesa,
jak tworzyć i aktualizować instancje Twojej aplikacji. Po stworzeniu Deploymentu, węzeł <em>master</em> Kubernetesa
zleca uruchomienie tej aplikacji na indywidualnych węzłach klastra.</p><p>Po utworzeniu instancji aplikacji, Kubernetes Deployment Controller na bieżąco monitoruje te instancje. Jeśli węzeł, na którym działała jedna z instancji ulegnie awarii lub zostanie usunięty, Deployment Controller zamieni tę instancję z instancją na innym węźle klastra. <b>W ten sposób działa samo naprawiający się mechanizm, który reaguje na awarie lub wyłączenia maszyn w klastrze.</b></p><p>W czasach przed wprowadzeniem takiej automatyzacji, skrypty instalacyjne używane były zazwyczaj do uruchomienia aplikacji, ale nie radziły sobie z awariami maszyn. Poprzez połączenie procesu instalacji i kontroli nad działaniem aplikacji na węzłach, Deployment Kubernetes oferuje fundamentalnie różne podejście do zarządzania aplikacjami.</p></div><div class=col-md-4><div class="content__box content__box_lined"><h3>Podsumowanie:</h3><ul><li>Deployments</li><li>Kubectl</li></ul></div><div class="content__box content__box_fill"><p><i>Deployment odpowiada za stworzenie i aktualizacje instancji Twojej aplikacji</i></p></div></div></div><br><div class=row><div class=col-md-8><h2 style=color:#3771e3>Instalacja pierwszej aplikacji w Kubernetes</h2></div></div><div class=row><div class=col-md-8><p><img src=/docs/tutorials/kubernetes-basics/public/images/module_02_first_app.svg></p></div></div><br><div class=row><div class=col-md-8><p>Do tworzenia i zarządzaniem Deploymentem służy polecenie linii komend, <b>Kubectl</b>. Kubectl używa Kubernetes API do komunikacji z klasterem. W tym module nauczysz się najczęściej używanych poleceń Kubectl niezbędnych do stworzenia Deploymentu, który uruchomi Twoje aplikacje na klastrze Kubernetes.</p><p>Tworząc Deployment musisz określić obraz kontenera oraz liczbę replik, które mają być uruchomione. Te ustawienia możesz zmieniać później, aktualizując Deployment. Moduły <a href=/pl/docs/tutorials/kubernetes-basics/scale/scale-intro/>5</a> oraz <a href=/pl/docs/tutorials/kubernetes-basics/update/update-intro/>6</a> omawiają skalowanie i aktualizowanie Deploymentów.</p></div><div class=col-md-4><div class="content__box content__box_fill"><p><i>Aby aplikacja mogła zostać uruchomiona w Kubernetes, musi być opakowana w jeden z obsługiwanych formatów kontenerów</i></p></div></div></div><div class=row><div class=col-md-8><p>Na potrzeby pierwszej instalacji użyjesz aplikacji hello-node zapakowaną w kontener Docker-a, która korzysta z NGINXa i powtarza wszystkie wysłane do niej zapytania. (Jeśli jeszcze nie próbowałeś stworzyć aplikacji hello-node i uruchomić za pomocą kontenerów, możesz spróbować teraz, kierując się instrukcjami samouczka <a href=/pl/docs/tutorials/hello-minikube/>Hello Minikube</a>).<p><p>Teraz, kiedy wiesz, czym są Deploymenty, przejdźmy do samouczka online, żeby zainstalować naszą pierwszą aplikację!</p></div></div><br><div class=row><div class=col-md-12><a class="btn btn-lg btn-success" href=/pl/docs/tutorials/kubernetes-basics/deploy-app/deploy-interactive/ role=button>Uruchom interaktywny samouczek <span class=btn__next>›</span></a></div></div></main></div></body></html></div><div class=td-content style=page-break-before:always><h1 id=pg-f8997ec143b382fa6c9621941ea62ca3>5.2.2.2 - Interaktywny samouczek - Instalacja aplikacji</h1><!doctype html><html lang=pl><body><link href=/docs/tutorials/kubernetes-basics/public/css/styles.css rel=stylesheet><link href=/docs/tutorials/kubernetes-basics/public/css/overrides.css rel=stylesheet><script src=https://katacoda.com/embed.js></script><div class=layout id=top><main class="content katacoda-content"><div class=row><div class=col-md-12><p>Pod to podstawowy element odpowiedzialny za uruchomienie aplikacji na Kubernetesie. Każdy pod to część składowa całościowego obciążenia Twojego klastra. <a href=/docs/concepts/workloads/pods/>Dowiedz się więcej na temat Podów</a>.</p></div></div><br><div class=katacoda><div class=katacoda__alert>Do pracy z terminalem użyj wersji na desktop/tablet</div><div class=katacoda__box id=inline-terminal-1 data-katacoda-id=kubernetes-bootcamp/7 data-katacoda-color=326de6 data-katacoda-secondary=273d6d data-katacoda-hideintro=false data-katacoda-prompt="Kubernetes Bootcamp Terminal" style=height:600px></div></div><div class=row><div class=col-md-12><a class="btn btn-lg btn-success" href=/pl/docs/tutorials/kubernetes-basics/create-cluster/cluster-intro/ role=button>&lt; Powrót do modułu 1<span></span></a>
<a class="btn btn-lg btn-success" href=/pl/docs/tutorials/kubernetes-basics/ role=button>Początek<span></span></a>
<a class="btn btn-lg btn-success" href=/pl/docs/tutorials/kubernetes-basics/explore/explore-intro/ role=button>Przejdź do modułu 3 ><span></span></a></div></div></main></div></body></html></div><div class=td-content style=page-break-before:always><h1 id=pg-250d620a73ec8be7e1f7d835574c4596>5.2.3 - Poznawanie aplikacji</h1></div><div class=td-content><h1 id=pg-2771f4e8c45321b17cb0114a2d266453>5.2.3.1 - Pody i Węzły</h1><!doctype html><html lang=pl><body><link href=/docs/tutorials/kubernetes-basics/public/css/styles.css rel=stylesheet><div class=layout id=top><main class=content><div class=row><div class=col-md-8><h3>Cele</h3><ul><li>Poznać Pody Kubernetes.</li><li>Poznać węzły Kubernetes.</li><li>Nauczyć się rozwiązywać problemy z aplikacjami.</li></ul></div><div class=col-md-8><h2>Pody Kubernetes</h2><p>Po stworzeniu Deploymentu w Module <a href=/pl/docs/tutorials/kubernetes-basics/deploy-app/deploy-intro/>2</a>, Kubernetes stworzył <b>Pod</b>, który "przechowuje" instancję Twojej aplikacji. Pod jest obiektem abstrakcyjnym Kubernetes, który reprezentuje grupę jednego bądź wielu kontenerów (jak np. Docker) wraz ze wspólnymi zasobami dla tych kontenerów. Zasobami mogą być:</p><ul><li>Współdzielona przestrzeń dyskowa, np. Volumes</li><li>Zasoby sieciowe, takie jak unikatowy adres IP klastra</li><li>Informacje służące do uruchamiania każdego z kontenerów ⏤ wersja obrazu dla kontenera lub numery portów, które mają być użyte</li></ul><p>Pod tworzy model specyficznego dla aplikacji "wirtualnego serwera" i może zawierać różne kontenery aplikacji, które są relatywnie blisko powiązane. Przykładowo, pod może zawierać zarówno kontener z Twoją aplikacją w Node.js, jak i inny kontener dostarczający dane, które mają być opublikowane przez serwer Node.js. Kontenery wewnątrz poda współdzielą adres IP i przestrzeń portów, zawsze są uruchamiane wspólnie w tej samej lokalizacji i współdzielą kontekst wykonawczy na tym samym węźle.</p><p>Pody są niepodzielnymi jednostkami na platformie Kubernetes. W trakcie tworzenia Deploymentu na Kubernetes, Deployment tworzy Pody zawierające kontenery (w odróżnieniu od tworzenia kontenerów bezpośrednio). Każdy Pod związany jest z węzłem, na którym zostało zlecone jego uruchomienie i pozostaje tam aż do jego wyłączenia (zgodnie z polityką restartowania) lub skasowania. W przypadku awarii węzła, identyczny pod jest skierowany do uruchomienia na innym węźle klastra.</p></div><div class=col-md-4><div class="content__box content__box_lined"><h3>Podsumowanie:</h3><ul><li>Pody</li><li>Węzły</li><li>Główne polecenia Kubectl</li></ul></div><div class="content__box content__box_fill"><p><i>Pod to grupa jednego lub wielu kontenerów aplikacji (jak np. Docker) zawierających współdzieloną przestrzeń dyskową (volumes), adres IP i informacje, jak mają być uruchamiane.</i></p></div></div></div><br><div class=row><div class=col-md-8><h2 style=color:#3771e3>Schemat ogólny podów</h2></div></div><div class=row><div class=col-md-8><p><img src=/docs/tutorials/kubernetes-basics/public/images/module_03_pods.svg></p></div></div><br><div class=row><div class=col-md-8><h2>Węzły</h2><p>Pod jest uruchamiany na <b>węźle <em>(Node)</em></b>. Węzeł jest maszyną roboczą, fizyczną lub wirtualną, w zależności od klastra. Każdy z węzłów jest zarządzany przez warstwę sterowania <em>(Control Plane)</em>. Węzeł może zawierać wiele podów. Warstwa sterowania Kubernetesa automatycznie zleca uruchomienie podów na różnych węzłach w ramach klastra. Automatyczne zlecanie uruchomienia bierze pod uwagę zasoby dostępne na każdym z węzłów.</p><p>Na każdym węźle Kubernetes działają co najmniej:</p><ul><li>Kubelet, proces odpowiedzialny za komunikację pomiędzy warstwą sterowania Kubernetesa i węzłami; zarządza podami i kontenerami działającymi na maszynie.</li><li>Proces wykonawczy kontenera (np. Docker), który zajmuje się pobraniem obrazu dla kontenera z repozytorium, rozpakowaniem kontenera i uruchomieniem aplikacji.</li></ul></div><div class=col-md-4><div class="content__box content__box_fill"><p><i>Kontenery powinny być uruchamiane razem w jednym podzie, jeśli są ściśle ze sobą związane i muszą współdzielić zasoby, np. dysk.</i></p></div></div></div><br><div class=row><div class=col-md-8><h2 style=color:#3771e3>Schemat węzła</h2></div></div><div class=row><div class=col-md-8><p><img src=/docs/tutorials/kubernetes-basics/public/images/module_03_nodes.svg></p></div></div><br><div class=row><div class=col-md-8><h2>Rozwiązywanie problemów przy pomocy kubectl</h2><p>W module <a href=/pl/docs/tutorials/kubernetes-basics/deploy-app/deploy-intro/>2</a> używałeś narzędzia Kubectl. W module 3 będziemy go nadal używać, aby wydobyć informacje na temat zainstalowanych aplikacji i środowiska, w jakim działają. Najczęstsze operacje przeprowadzane są przy pomocy następujących poleceń kubectl:</p><ul><li><b>kubectl get</b> - wyświetl informacje o zasobach</li><li><b>kubectl describe</b> - pokaż szczegółowe informacje na temat konkretnego zasobu</li><li><b>kubectl logs</b> - wyświetl logi z kontenera w danym podzie</li><li><b>kubectl exec</b> - wykonaj komendę wewnątrz kontenera w danym podzie</li></ul><p>Korzystaj z tych poleceń, aby sprawdzić, kiedy aplikacja została zainstalowana, jaki jest jej aktualny status, gdzie jest uruchomiona i w jakiej konfiguracji.</p><p>Kiedy już wiemy więcej na temat części składowych klastra i podstawowych poleceń, przyjrzyjmy się naszej aplikacji.</p></div><div class=col-md-4><div class="content__box content__box_fill"><p><i>Węzeł jest maszyną roboczą Kubernetes - fizyczną lub wirtualną, zależnie od klastra. Wiele podów może być uruchomionych na tym samym węźle.</i></p></div></div></div><br><div class=row><div class=col-md-12><a class="btn btn-lg btn-success" href=/pl/docs/tutorials/kubernetes-basics/explore/explore-interactive/ role=button>Rozpocznij interaktywny samouczek <span class=btn__next>›</span></a></div></div></main></div></body></html></div><div class=td-content style=page-break-before:always><h1 id=pg-4b01eab98a9844ad91131079654199dd>5.2.3.2 - Interaktywny samouczek - Poznaj swoją aplikację</h1><!doctype html><html lang=pl><body><link href=/docs/tutorials/kubernetes-basics/public/css/styles.css rel=stylesheet><link href=/docs/tutorials/kubernetes-basics/public/css/overrides.css rel=stylesheet><script src=https://katacoda.com/embed.js></script><div class=layout id=top><main class="content katacoda-content"><br><div class=katacoda><div class=katacoda__alert>Do pracy z terminalem użyj wersji na desktop/tablet</div><div class=katacoda__box id=inline-terminal-1 data-katacoda-id=kubernetes-bootcamp/4 data-katacoda-color=326de6 data-katacoda-secondary=273d6d data-katacoda-hideintro=false data-katacoda-prompt="Kubernetes Bootcamp Terminal" style=height:600px></div></div><div class=row><div class=col-md-12><a class="btn btn-lg btn-success" href=/pl/docs/tutorials/kubernetes-basics/deploy-app/deploy-intro/ role=button>&lt; Powrót do modułu 2<span class=btn></span></a>
<a class="btn btn-lg btn-success" href=/pl/docs/tutorials/kubernetes-basics/ role=button>Początek<span></span></a>
<a class="btn btn-lg btn-success" href=/pl/docs/tutorials/kubernetes-basics/expose/expose-intro/ role=button>Przejdź do modułu 4 ><span class=btn></span></a></div></div></main></div></body></html></div><div class=td-content style=page-break-before:always><h1 id=pg-4b0e31c9e0eae68bbb0a358b4042ada9>5.2.4 - Udostępnianie aplikacji</h1></div><div class=td-content><h1 id=pg-8ef4dad8f743b191a9e8c6f891cb191a>5.2.4.1 - Jak używać Service do udostępniania aplikacji</h1><!doctype html><html lang=pl><body><link href=/docs/tutorials/kubernetes-basics/public/css/styles.css rel=stylesheet><div class=layout id=top><main class=content><div class=row><div class=col-md-8><h3>Cele</h3><ul><li>Poznać Serwis w Kubernetesie</li><li>Zrozumieć, jak obiekty Label i LabelSelector są powiązane z Serwisem</li><li>Udostępnić aplikację na zewnątrz klastra Kubernetes korzystając z Serwisu</li></ul></div><div class=col-md-8><h3>Kubernetes Services - przegląd</h3><p><a href=/docs/concepts/workloads/pods/>Pody</a> Kubernetes są nietrwałe. Pody mają swój <a href=/docs/concepts/workloads/pods/pod-lifecycle/>cykl życia</a>. Jeśli węzeł roboczy ulegnie awarii, tracone są wszystkie pody działające na węźle. <a href=/docs/concepts/workloads/controllers/replicaset/>ReplicaSet</a> będzie próbował automatycznie doprowadzić klaster z powrotem do pożądanego stanu tworząc nowe pody i w ten sposób zapewnić działanie aplikacji. Innym przykładem może być system na back-endzie przetwarzania obrazów posiadający 3 repliki. Każda z tych replik jest wymienna - system front-endu nie powinien musieć pilnować replik back-endu ani tego, czy któryś z podów przestał działać i został odtworzony na nowo. Nie należy jednak zapominać o tym, że każdy Pod w klastrze Kubernetes ma swój unikatowy adres IP, nawet pody w obrębie tego samego węzła, zatem powinna istnieć metoda automatycznego uzgadniania zmian pomiędzy podami, aby aplikacja mogła dalej funkcjonować.</p><p>Serwis w Kubernetes jest abstrakcyjnym obiektem, która definiuje logiczny zbiór podów oraz politykę dostępu do nich. Serwisy pozwalają na swobodne łączenie zależnych podów. Serwis jest zdefiniowany w YAMLu <a href=/docs/concepts/configuration/overview/#general-configuration-tips>(zalecane)</a> lub w JSONie - tak, jak wszystkie obiekty Kubernetes. Zbiór podów, które obsługuje Serwis, jest zazwyczaj określany przez <i>LabelSelector</i> (poniżej opisane jest, w jakich przypadkach możesz potrzebować zdefiniować Serwis bez specyfikowania <code>selektora</code>).</p><p>Mimo, że każdy pod ma swój unikatowy adres IP, te adresy nie są dostępne poza klastrem, o ile nie zostaną wystawione za pomocą Serwisu. Serwis umożliwia aplikacji przyjmować ruch przychodzący. Serwisy mogą być wystawiane na zewnątrz na kilka różnych sposobów, poprzez określenie <code>typu</code> w ServiceSpec:</p><ul><li><i>ClusterIP</i> (domyślnie) - Wystawia serwis poprzez wewnętrzny adres IP w klastrze. W ten sposób serwis jest dostępny tylko wewnątrz klastra.</li><li><i>NodePort</i> - Wystawia serwis na tym samym porcie na każdym z wybranych węzłów klastra przy pomocy NAT. W ten sposób serwis jest dostępny z zewnątrz klastra poprzez <code>&lt;NodeIP>:&lt;NodePort></code>. Nadzbiór ClusterIP.</li><li><i>LoadBalancer</i> - Tworzy zewnętrzny load balancer u bieżącego dostawcy usług chmurowych (o ile jest taka możliwość) i przypisuje serwisowi stały, zewnętrzny adres IP. Nadzbiór NodePort.</li><li><i>ExternalName</i> - Przypisuje Service do <code>externalName</code> (np. <code>foo.bar.example.com</code>), zwracając rekord <code>CNAME</code> wraz z zawartością. W tym przypadku nie jest wykorzystywany proces przekierowania ruchu metodą proxy. Ta metoda wymaga <code>kube-dns</code> w wersji v1.7 lub wyższej lub CoreDNS w wersji 0.0.8 lub wyższej.</li></ul><p>Więcej informacji na temat różnych typów serwisów znajduje się w samouczku <a href=/docs/tutorials/services/source-ip/>Używanie adresu źródłowego (Source IP)</a>. Warto też zapoznać się z <a href=/docs/concepts/services-networking/connect-applications-service>Łączeniem Aplikacji z Serwisami</a>.</p><p>W pewnych przypadkach w serwisie nie specyfikuje się <code>selector</code>. Serwis, który został stworzony bez pola <code>selector</code>, nie utworzy odpowiedniego obiektu Endpoints. W ten sposób użytkownik ma możliwość ręcznego przyporządkowania serwisu do konkretnych endpoints. Inny przypadek, kiedy nie używa się selektora, ma miejsce, kiedy stosujemy <code>type: ExternalName</code>.</p></div><div class=col-md-4><div class="content__box content__box_lined"><h3>Podsumowanie</h3><ul><li>Otwarcie Poda na ruch z zewnątrz</li><li>Rozkładanie ruchu pomiędzy poszczególne Pody</li><li>Używanie etykiet</li></ul></div><div class="content__box content__box_fill"><p><i>Serwis Kubernetesa to warstwa abstrakcji, która definiuje logiczny zbiór Podów i umożliwia kierowanie ruchu przychodzącego do Podów, jego równoważenie oraz service discovery.</i></p></div></div></div><br><div class=row><div class=col-md-8><h3>Sewisy i Etykiety <em>(Labels)</em></h3></div></div><div class=row><div class=col-md-8><p>Serwis kieruje przychodzący ruch do grupy Podów. Serwisy są obiektami abstrakcyjnymi, dzięki którym pody mogą się psuć i być zastępowane przez Kubernetes nowymi bez ujemnego wpływu na działanie twoich aplikacji. Detekcją nowych podów i kierowaniem ruchu pomiędzy zależnymi podami (takimi, jak składowe front-end i back-end w aplikacji) zajmują się Serwisy Kubernetes.</p><p>Serwis znajduje zestaw odpowiednich Podów przy pomocy <a href=/docs/concepts/overview/working-with-objects/labels>etykiet i selektorów</a>, podstawowych jednostek grupujących, które umożliwiają operacje logiczne na obiektach Kubernetes. Etykiety to pary klucz/wartość przypisane do obiektów. Mogą być używane na różne sposoby:</p><ul><li>Dzielić obiekty na deweloperskie, testowe i produkcyjne</li><li>Osadzać znaczniki <em>(tags)</em>określające wersje</li><li>Klasyfikować obiekty przy użyciu znaczników</li></ul></div></div><br><div class=row><div class=col-md-8><p><img src=/docs/tutorials/kubernetes-basics/public/images/module_04_labels.svg></p></div></div><br><div class=row><div class=col-md-8><p>Obiekty mogą być oznaczane etykietami w momencie tworzenia lub później. Etykiety mogą być zmienianie w dowolnej chwili. Udostępnijmy teraz naszą aplikację przy użyciu Serwisu i oznaczmy ją odpowiednimi etykietami.</p></div></div><br><div class=row><div class=col-md-12><a class="btn btn-lg btn-success" href=/pl/docs/tutorials/kubernetes-basics/expose/expose-interactive/ role=button>Rozpocznij interaktywny samouczek<span class=btn__next>›</span></a></div></div></main></div></body></html></div><div class=td-content style=page-break-before:always><h1 id=pg-352241d22effe0714772d21c7d1b512d>5.2.4.2 - Interaktywny samouczek - Udostępnianie aplikacji</h1><!doctype html><html lang=pl><body><link href=/docs/tutorials/kubernetes-basics/public/css/styles.css rel=stylesheet><link href=/docs/tutorials/kubernetes-basics/public/css/overrides.css rel=stylesheet><script src=https://katacoda.com/embed.js></script><div class=layout id=top><main class="content katacoda-content"><div class=katacoda><div class=katacoda__alert>Do pracy z terminalem użyj wersji na desktop/tablet</div><div class=katacoda__box id=inline-terminal-1 data-katacoda-id=kubernetes-bootcamp/8 data-katacoda-color=326de6 data-katacoda-secondary=273d6d data-katacoda-hideintro=false data-katacoda-prompt="Kubernetes Bootcamp Terminal" style=height:600px></div></div><div class=row><div class=col-md-12><a class="btn btn-lg btn-success" href=/pl/docs/tutorials/kubernetes-basics/explore/explore-intro/ role=button>&lt; Powrót do modułu 3<span></span></a>
<a class="btn btn-lg btn-success" href=/pl/docs/tutorials/kubernetes-basics/ role=button>Początek<span></span></a>
<a class="btn btn-lg btn-success" href=/pl/docs/tutorials/kubernetes-basics/scale/scale-intro/ role=button>Przejdź do modułu 5 ><span></span></a></div></div></main></div></body></html></div><div class=td-content style=page-break-before:always><h1 id=pg-be4996c93fb39c459a30b6669569d423>5.2.5 - Skalowanie aplikacji</h1></div><div class=td-content><h1 id=pg-d1c15c9bd4f625adbc13149b1475287c>5.2.5.1 - Uruchamianie wielu instancji aplikacji</h1><!doctype html><html lang=pl><body><link href=/docs/tutorials/kubernetes-basics/public/css/styles.css rel=stylesheet><div class=layout id=top><main class=content><div class=row><div class=col-md-8><h3>Cele</h3><ul><li>Wyskaluj aplikację przy użyciu kubectl.</li></ul></div><div class=col-md-8><h3>Skalowanie aplikacji</h3><p>W poprzednim module stworzyliśmy <a href=/docs/concepts/workloads/controllers/deployment/>Deployment</a> i udostępniliśmy go publicznie korzystając z <a href=/docs/concepts/services-networking/service/>Serwisu</a>. Deployment utworzył tylko jeden Pod, w którym uruchomiona jest nasza aplikacja. Wraz ze wzrostem ruchu, będziemy musieli wyskalować aplikację, aby była w stanie obsłużyć zwiększone zapotrzebowanie użytkowników.</p><p><b>Skalowanie</b> polega na zmianie liczby replik w Deploymencie.</p></div><div class=col-md-4><div class="content__box content__box_lined"><h3>Podsumowanie:</h3><ul><li>Skalowanie Deploymentu</li></ul></div><div class="content__box content__box_fill"><p><i>Od samego początku w ramach Deploymentu można uruchomić wiele instancji — skorzystaj z parametru --replicas polecenia kubectl create deployment</i></p></div></div></div><br><div class=row><div class=col-md-8><h2 style=color:#3771e3>Ogólnie o skalowaniu</h2></div></div><div class=row><div class=col-md-1></div><div class=col-md-8><div id=myCarousel class=carousel data-ride=carousel data-interval=3000><ol class=carousel-indicators><li data-target=#myCarousel data-slide-to=0 class=active></li><li data-target=#myCarousel data-slide-to=1></li></ol><div class=carousel-inner role=listbox><div class="item carousel-item active"><img src=/docs/tutorials/kubernetes-basics/public/images/module_05_scaling1.svg></div><div class="item carousel-item"><img src=/docs/tutorials/kubernetes-basics/public/images/module_05_scaling2.svg></div></div><a class="left carousel-control" href=#myCarousel role=button data-slide=prev><span class=sr-only>Wstecz</span></a>
<a class="right carousel-control" href=#myCarousel role=button data-slide=next><span class=sr-only>Dalej</span></a></div></div></div><br><div class=row><div class=col-md-8><p>Kiedy zwiększamy skalę Deploymentu, uruchomienie nowych Podów jest zlecane na Węzłach, które posiadają odpowiednio dużo zasobów. Operacja skalowania zwiększy liczbę Podów do oczekiwanej wartości. W Kubernetes możliwe jest również <a href=/docs/user-guide/horizontal-pod-autoscaling/>autoskalowanie</a> Podów, ale jest ono poza zakresem niniejszego samouczka. Istnieje także możliwość skalowania do zera — w ten sposób zatrzymane zostaną wszystkie Pody należące do konkretnego Deploymentu.</p><p>Kiedy działa jednocześnie wiele instancji jednej aplikacji, należy odpowiednio rozłożyć ruch pomiędzy każdą z nich. Serwisy posiadają zintegrowany load-balancer, który dystrybuuje ruch na wszystkie Pody w Deployment wystawionym na zewnątrz. Serwis prowadzi ciągły monitoring Podów poprzez ich punkty dostępowe <em>(endpoints)</em>, aby zapewnić, że ruch kierowany jest tylko do tych Podów, które są faktycznie dostępne.</p></div><div class=col-md-4><div class="content__box content__box_fill"><p><i>Skalowanie polega na zmianie liczby replik w ramach Deploymentu.</i></p></div></div></div><br><div class=row><div class=col-md-8><p>Kiedy aplikacja ma uruchomioną więcej niż jedną instancję, można prowadzić ciągłe aktualizacje <em>(Rolling updates)</em> bez przerw w działaniu aplikacji. O tym będzie mowa w następnym module. Na razie przejdźmy do terminala online, aby przeprowadzić skalowanie aplikacji.</p></div></div><br><div class=row><div class=col-md-12><a class="btn btn-lg btn-success" href=/pl/docs/tutorials/kubernetes-basics/scale/scale-interactive/ role=button>Uruchom interaktywny samouczek<span class=btn__next>›</span></a></div></div></main></div></body></html></div><div class=td-content style=page-break-before:always><h1 id=pg-7bdb3fbaa1177ff5dfa3fe86bd35ef59>5.2.5.2 - Interaktywny samouczek - Skalowanie aplikacji</h1><!doctype html><html lang=pl><body><link href=/docs/tutorials/kubernetes-basics/public/css/styles.css rel=stylesheet><link href=/docs/tutorials/kubernetes-basics/public/css/overrides.css rel=stylesheet><script src=https://katacoda.com/embed.js></script><div class=layout id=top><main class="content katacoda-content"><div class=katacoda><div class=katacoda__alert>Do pracy z terminalem użyj wersji na desktop/tablet</div><div class=katacoda__box id=inline-terminal-1 data-katacoda-id=kubernetes-bootcamp/5 data-katacoda-color=326de6 data-katacoda-secondary=273d6d data-katacoda-hideintro=false data-katacoda-prompt="Kubernetes Bootcamp Terminal" style=height:600px></div></div><div class=row><div class=col-md-12><a class="btn btn-lg btn-success" href=/pl/docs/tutorials/kubernetes-basics/expose/expose-interactive/ role=button>&lt; Powrót do modułu 4<span></span></a>
<a class="btn btn-lg btn-success" href=/pl/docs/tutorials/kubernetes-basics/ role=button>Początek<span></span></a>
<a class="btn btn-lg btn-success" href=/pl/docs/tutorials/kubernetes-basics/update/update-intro/ role=button>Przejdź do modułu 6 ><span></span></a></div></div></main><a class=scrolltop href=#top></a></div></body></html></div><div class=td-content style=page-break-before:always><h1 id=pg-62b8b17dadfb55f1801cf8439e944e58>5.2.6 - Aktualizowanie aplikacji</h1></div><div class=td-content><h1 id=pg-12e04355145afad615ca3c38335ba019>5.2.6.1 - Aktualizacje Rolling Update</h1><!doctype html><html lang=pl><body><link href=/docs/tutorials/kubernetes-basics/public/css/styles.css rel=stylesheet><div class=layout id=top><main class=content><div class=row><div class=col-md-8><h3>Cele</h3><ul><li>Przeprowadzić płynną aktualizację przy użyciu kubectl.</li></ul></div><div class=col-md-8><h3>Aktualizowanie aplikacji</h3><p>Użytkownicy oczekują, że aplikacje są dostępne non-stop, a deweloperzy chcieliby móc wprowadzać nowe wersje nawet kilka razy dziennie. W Kubernetes jest to możliwe dzięki mechanizmowi płynnych aktualizacji <em>(rolling updates)</em>. <b>Rolling updates</b> pozwala prowadzić aktualizację w ramach Deploymentu bez przerw w jego działaniu dzięki krokowemu aktualizowaniu kolejnych Podów. Nowe Pody uruchamiane są na Węzłach, które posiadają wystarczające zasoby.</p><p>W poprzednim module wyskalowaliśmy aplikację aby była uruchomiona na wielu instancjach. To niezbędny wymóg, aby móc prowadzić aktualizacje bez wpływu na dostępność aplikacji. Domyślnie, maksymalna liczba Podów, które mogą być niedostępne w trakcie aktualizacji oraz Podów, które mogą być tworzone, wynosi jeden. Obydwie opcje mogą być zdefiniowane w wartościach bezwzględnych lub procentowych (ogólnej liczby Podów).
W Kubernetes, każdy aktualizacja ma nadany numer wersji i każdy Deployment może być wycofany do wersji poprzedniej (stabilnej).</p></div><div class=col-md-4><div class="content__box content__box_lined"><h3>Podsumowanie:</h3><ul><li>Aktualizacja aplikacji</li></ul></div><div class="content__box content__box_fill"><p><i>Rolling updates to metoda na aktualizację Deploymentów bez przerwy w ich dostępności poprzez stopniową zamianę kolejnych Podów na ich nowe wersje.</i></p></div></div></div><br><div class=row><div class=col-md-8><h2 style=color:#3771e3>Ogólnie o Rolling updates</h2></div></div><div class=row><div class=col-md-1></div><div class=col-md-8><div id=myCarousel class=carousel data-ride=carousel data-interval=3000><ol class=carousel-indicators><li data-target=#myCarousel data-slide-to=0 class=active></li><li data-target=#myCarousel data-slide-to=1></li><li data-target=#myCarousel data-slide-to=2></li><li data-target=#myCarousel data-slide-to=3></li></ol><div class=carousel-inner role=listbox><div class="item carousel-item active"><img src=/docs/tutorials/kubernetes-basics/public/images/module_06_rollingupdates1.svg></div><div class="item carousel-item"><img src=/docs/tutorials/kubernetes-basics/public/images/module_06_rollingupdates2.svg></div><div class="item carousel-item"><img src=/docs/tutorials/kubernetes-basics/public/images/module_06_rollingupdates3.svg></div><div class="item carousel-item"><img src=/docs/tutorials/kubernetes-basics/public/images/module_06_rollingupdates4.svg></div></div><a class="left carousel-control" href=#myCarousel role=button data-slide=prev><span class=sr-only>Wstecz</span></a>
<a class="right carousel-control" href=#myCarousel role=button data-slide=next><span class=sr-only>Dalej</span></a></div></div></div><br><div class=row><div class=col-md-8><p>Podobnie, jak w przypadku skalowania aplikacji, jeśli Deployment jest udostępniony publicznie, Serwis będzie kierował ruch tylko do Podów, które są dostępne w trakcie aktualizacji. Dostępny Pod to taki, którego instancja jest dostępna dla użytkowników aplikacji.</p><p>Płynne aktualizacje pozwalają na:</p><ul><li>Promocję aplikacji z jednego środowiska do innego (poprzez aktualizację obrazu kontenera)</li><li>Wycofywanie się do poprzedniej wersji</li><li><em>Continuous Integration</em> oraz <em>Continuous Delivery</em> aplikacji bez przerw w jej działaniu</li></ul></div><div class=col-md-4><div class="content__box content__box_fill"><p><i>Jeśli Deployment jest udostępniony publicznie, Serwis będzie kierował ruch w trakcie aktualizacji tylko do Podów, które są aktualnie dostępne.</i></p></div></div></div><br><div class=row><div class=col-md-8><p>W ramach tego interaktywnego samouczka zaktualizujemy aplikację do nowej wersji oraz wycofamy tę aktualizację.</p></div></div><br><div class=row><div class=col-md-12><a class="btn btn-lg btn-success" href=/pl/docs/tutorials/kubernetes-basics/update/update-interactive/ role=button>Rozpocznij interaktywny samouczek <span class=btn__next>›</span></a></div></div></main></div></body></html></div><div class=td-content style=page-break-before:always><h1 id=pg-dddc0cb356c280e0339bcf42776987dc>5.2.6.2 - Interaktywny samouczek - Aktualizowanie aplikacji</h1><!doctype html><html lang=pl><body><link href=/docs/tutorials/kubernetes-basics/public/css/styles.css rel=stylesheet><link href=/docs/tutorials/kubernetes-basics/public/css/overrides.css rel=stylesheet><script src=https://katacoda.com/embed.js></script><div class=layout id=top><main class="content katacoda-content"><div class=katacoda><div class=katacoda__alert>Do pracy z terminalem użyj wersji na desktop/tablet</div><div class=katacoda__box id=inline-terminal-1 data-katacoda-id=kubernetes-bootcamp/6 data-katacoda-color=326de6 data-katacoda-secondary=273d6d data-katacoda-hideintro=false data-katacoda-prompt="Kubernetes Bootcamp Terminal" style=height:600px></div></div><div class=row><div class=col-md-12><a class="btn btn-lg btn-success" href=/pl/docs/tutorials/kubernetes-basics/scale/scale-interactive/ role=button>&lt; Powrót do modułu 5<span></span></a>
<a class="btn btn-lg btn-success" href=/pl/docs/tutorials/kubernetes-basics/ role=button>Z powrotem do Podstaw Kubernetesa<span></span></a></div></div></main></div></body></html></div><div class=td-content style=page-break-before:always><h1 id=pg-b00a88a07ceb21b1a83e5822e0c86c1d>6 - Materiały źródłowe</h1><p>Tutaj znajdziesz dokumentację źródłową Kubernetesa.</p><h2 id=dokumentacja-api>Dokumentacja API</h2><ul><li><p><a href=/docs/reference/glossary/>Glossary</a> - Pełna, zestandaryzowana lista terminologii Kubernetesa</p></li><li><p><a href=/docs/reference/kubernetes-api/>Kubernetes API Reference</a></p></li><li><p><a href=/docs/reference/generated/kubernetes-api/v1.25/>One-page API Reference for Kubernetes v1.25</a></p></li><li><p><a href=/docs/reference/using-api/>Using The Kubernetes API</a> - ogólne informacje na temat API Kubernetesa</p></li><li><p><a href=/docs/reference/access-authn-authz/>API access control</a> - szczegóły dotyczące kontroli dostępu do API Kubernetesa</p></li><li><p><a href=/docs/reference/labels-annotations-taints/>Well-Known Labels, Annotations and Taints</a></p></li></ul><h2 id=oficjalnie-wspierane-biblioteki-klienckie>Oficjalnie wspierane biblioteki klienckie</h2><p>Aby wywołać Kubernetes API z wybranego języka programowania, możesz skorzystać z
<a href=/docs/reference/using-api/client-libraries/>bibliotek klienckich</a>. Oficjalnie wspierane
biblioteki to:</p><ul><li><a href=https://github.com/kubernetes-client/python>Kubernetes Python client library</a></li><li><a href=https://github.com/kubernetes-client/java>Kubernetes Java client library</a></li><li><a href=https://github.com/kubernetes-client/javascript>Kubernetes JavaScript client library</a></li><li><a href=https://github.com/kubernetes-client/csharp>Kubernetes C# client library</a></li><li><a href=https://github.com/kubernetes-client/haskell>Kubernetes Haskell client library</a></li></ul><h2 id=polecenia-tekstowe-cli>Polecenia tekstowe <em>(CLI)</em></h2><ul><li><a href=/docs/reference/kubectl/overview/>kubectl</a> - Główne narzędzie tekstowe (linii poleceń) do zarządzania klastrem Kubernetes.<ul><li><a href=/docs/reference/kubectl/jsonpath/>JSONPath</a> - Podręcznik składni <a href=https://goessner.net/articles/JsonPath/>wyrażeń JSONPath</a> dla kubectl.</li></ul></li><li><a href=/docs/reference/setup-tools/kubeadm/>kubeadm</a> - Narzędzie tekstowe do łatwego budowania klastra Kubernetes spełniającego niezbędne wymogi bezpieczeństwa.</li></ul><h2 id=komponenty>Komponenty</h2><ul><li><p><a href=/docs/reference/command-line-tools-reference/kubelet/>kubelet</a> - Główny
agent działający na każdym węźle. Kubelet pobiera zestaw definicji PodSpecs
i gwarantuje, że opisane przez nie kontenery poprawnie działają.</p></li><li><p><a href=/docs/reference/command-line-tools-reference/kube-apiserver/>kube-apiserver</a> -
REST API, które sprawdza poprawność i konfiguruje obiekty API, takie jak pody, serwisy czy kontrolery replikacji.</p></li><li><p><a href=/docs/reference/command-line-tools-reference/kube-controller-manager/>kube-controller-manager</a> - Proces wykonujący główne pętle sterowania Kubernetes.</p></li><li><p><a href=/docs/reference/command-line-tools-reference/kube-proxy/>kube-proxy</a> - Przekazuje
bezpośrednio dane przepływające w transmisji TCP/UDP lub dystrybuuje ruch TCP/UDP
zgodnie ze schematem <em>round-robin</em> pomiędzy usługi back-endu.</p></li><li><p><a href=/docs/reference/command-line-tools-reference/kube-scheduler/>kube-scheduler</a> - Scheduler odpowiada za dostępność, wydajność i zasoby.</p></li><li><p><a href=/docs/reference/scheduling/policies>Scheduler Policies</a></p></li><li><p><a href=/docs/reference/scheduling/config#profiles>Scheduler Profiles</a></p></li><li><p>Spis <a href=/docs/reference/ports-and-protocols/>portów i protokołów</a>, które
muszą być otwarte dla warstwy sterowania i na węzłach roboczych.</p></li></ul><h2 id=api-konfiguracji>API konfiguracji</h2><p>W tej części zebrano "niepublikowane" API, które służą do konfiguracji komponentów
Kubernetesa lub innych narzędzi. Choć większość tych API nie jest udostępniane przez
serwer API w trybie RESTful, są one niezbędne dla użytkowników i administratorów
w korzystaniu i zarządzaniu klastrem.</p><ul><li><a href=/docs/reference/config-api/apiserver-config.v1/>kube-apiserver configuration (v1)</a></li><li><a href=/docs/reference/config-api/kubelet-config.v1alpha1/>kubelet configuration (v1alpha1)</a> i
<a href=/docs/reference/config-api/kubelet-config.v1beta1/>kubelet configuration (v1beta1)</a></li><li><a href=/docs/reference/config-api/kube-scheduler-config.v1beta2/>kube-scheduler configuration (v1beta2)</a> i
<a href=/docs/reference/config-api/kube-scheduler-config.v1beta3/>kube-scheduler configuration (v1beta3)</a></li><li><a href=/docs/reference/config-api/kube-proxy-config.v1alpha1/>kube-proxy configuration (v1alpha1)</a></li><li><a href=/docs/reference/config-api/apiserver-audit.v1/><code>audit.k8s.io/v1</code> API</a></li><li><a href=/docs/reference/config-api/client-authentication.v1beta1/>Client authentication API (v1beta1)</a> i
<a href=/docs/reference/config-api/client-authentication.v1/>Client authentication API (v1)</a></li><li><a href=/docs/reference/config-api/apiserver-webhookadmission.v1/>WebhookAdmission configuration (v1)</a></li></ul><h2 id=api-konfiguracji-dla-kubeadm>API konfiguracji dla kubeadm</h2><ul><li><a href=/docs/reference/config-api/kubeadm-config.v1beta2/>v1beta2</a></li><li><a href=/docs/reference/config-api/kubeadm-config.v1beta3/>v1beta3</a></li></ul><h2 id=dokumentacja-projektowa>Dokumentacja projektowa</h2><p>Archiwum dokumentacji projektowej różnych funkcjonalności Kubernetes. Warto zacząć od
<a href=https://git.k8s.io/community/contributors/design-proposals/architecture/architecture.md>Kubernetes Architecture</a> oraz
<a href=https://git.k8s.io/community/contributors/design-proposals>Kubernetes Design Overview</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-2b03679960950df772fb4fe7d78427b9>6.1 - Słownik</h1></div><div class=td-content style=page-break-before:always><h1 id=pg-4985cb55ddfb184639d767ec54b9f0f7>7 - Współtwórz dokumentację K8s</h1><p><em>Kubernetes zaprasza do współpracy wszystkich - zarówno nowicjuszy, jak i doświadczonych!</em></p><div class="alert alert-info note callout" role=alert><strong>Informacja:</strong><p>Aby dowiedzieć się więcej ogólnych informacji o współpracy przy tworzeniu Kubernetesa, zajrzyj
do <a href=https://www.kubernetes.dev/docs/>contributor documentation</a>.</p><p>Warto także zapoznać się z
<a href=https://contribute.cncf.io/contributors/projects/#kubernetes>informacjami</a>
<a class=glossary-tooltip title='Cloud Native Computing Foundation' data-toggle=tooltip data-placement=top href=https://cncf.io/ target=_blank aria-label=CNCF>CNCF</a>
na temat współpracy w ramach projektu Kubernetes.</p></div><hr><p>Tym serwisem www opiekuje się <a href=/docs/contribute/#get-involved-with-sig-docs>Kubernetes SIG Docs</a>.</p><p>Współtwórcy dokumentacji Kubernetesa:</p><ul><li>Ulepszają istniejącą zawartość</li><li>Tworzą nowe treści</li><li>Tłumaczą dokumentację</li><li>Zarządzają i publikują dokumentację w ramach cyklu wydawniczego Kubernetesa</li></ul><h2 id=jak-zacząć>Jak zacząć?</h2><p>Każdy może otworzyć zgłoszenie dotyczące dokumentacji lub zaproponować zmianę poprzez
<em>pull request</em> (PR) do
<a href=https://github.com/kubernetes/website>repozytorium GitHub <code>kubernetes/website</code></a>.
Aby móc sprawnie funkcjonować w społeczności Kubernetes,
wymagana jest pewna biegłość w korzystaniu z
<a href=https://git-scm.com/>git-a</a> i
<a href=https://lab.github.com/>GitHub-a</a>.</p><p>Aby zaangażować się w prace nad dokumentacją należy:</p><ol><li>Podpisać <a href=https://github.com/kubernetes/community/blob/master/CLA.md>Contributor License Agreement</a> CNCF.</li><li>Zapoznać się z <a href=https://github.com/kubernetes/website>repozytorium dokumentacji</a>
i z <a href=https://gohugo.io>generatorem statycznej strony</a> www.</li><li>Zrozumieć podstawowe procesy <a href=/docs/contribute/new-content/new-content/>otwierania <em>pull request</em></a> oraz
<a href=/docs/contribute/review/reviewing-prs/>recenzowania zmian</a>.</li></ol><p><figure><div class=mermaid>flowchart TB
subgraph third[Otwórz PR]
direction TB
U[ ] -.-
Q[Ulepsz zawartość] --- N[Dodaj nową]
N --- O[Przetłumacz dokumentację]
O --- P[Zarządzaj dokumentacją<br>przy kolejnych<br>wydaniach K8s]
end
subgraph second[Recenzuj]
direction TB
T[ ] -.-
D[Przejrzyj<br>repozytorium<br>K8s/website] --- E[Pobierz generator<br>stron statycznych<br>Hugo]
E --- F[Zrozum podstawowe<br>polecenia GitHub-a]
F --- G[Zrecenzuj otwarty PR<br>i zmień procesy<br>recenzji]
end
subgraph first[Zapisz się]
direction TB
S[ ] -.-
B[Podpisz CNCF<br>Contributor<br>License Agreement] --- C[Dołącz do Slack-a<br>sig-docs]
C --- V[Zapisz się na listę<br>kubernetes-sig-docs]
V --- M[Weź udział w cotygodniowych<br>spotkaniach sig-docs]
end
A([fa:fa-user Nowy<br>uczestnik]) --> first
A --> second
A --> third
A --> H[Zapytaj!!!]
classDef grey fill:#dddddd,stroke:#ffffff,stroke-width:px,color:#000000, font-size:15px;
classDef white fill:#ffffff,stroke:#000,stroke-width:px,color:#000,font-weight:bold
classDef spacewhite fill:#ffffff,stroke:#fff,stroke-width:0px,color:#000
class A,B,C,D,E,F,G,H,M,Q,N,O,P,V grey
class S,T,U spacewhite
class first,second,third white</div></figure><noscript><div class="alert alert-secondary callout" role=alert><em class=javascript-required>JavaScript musi być <a href=https://www.enable-javascript.com/pl/>włączony</a> na tej stronie</em></div></noscript>Schemat 1. - Jak rozpocząć współpracę</p><p>Schemat 1 przeznaczony jest dla osób, które chcą zacząć współtworzyć Kubernetesa. Przejdź część lub wszystkie kroki opisane w częściach <code>Zapisz się</code> i <code>Recenzuj</code>. Teraz już możesz tworzyć nowe PR, zgodnie z sugestiami w <code>Otwórz PR</code>. I jak zawsze, pytania mile widziane!</p><p>Do realizacji niektórych zadań potrzeba wyższego poziomu zaufania i odpowiednich uprawnień w organizacji Kubernetes.
Zajrzyj do <a href=/docs/contribute/participate/>Participating in SIG Docs</a> po więcej szczegółów dotyczących
ról i uprawnień.</p><h2 id=pierwsze-kroki>Pierwsze kroki</h2><p>Zapoznaj się z krokami opisanymi na schemacie 2, aby się lepiej przygotować.</p><p><figure><div class=mermaid>flowchart LR
subgraph second[Pierwszy wkład]
direction TB
S[ ] -.-
G[Obejrzyj PR-y<br>innych uczestników K8s] -->
A[Przejrzyj listę zgłoszonych spraw<br>na K8s/website<br>po pomysł na nowy PR] --> B[Otwórz PR!!]
end
subgraph first[Sugerowane przygotowanie]
direction TB
T[ ] -.-
D[Przeczytaj wprowadzenie<br>dla współtwórców] -->E[Przeczytaj K8s content<br>and style guides]
E --> F[Poczytaj o typach zawartości<br>stron i skrótach Hugo]
end
first ----> second
classDef grey fill:#dddddd,stroke:#ffffff,stroke-width:px,color:#000000, font-size:15px;
classDef white fill:#ffffff,stroke:#000,stroke-width:px,color:#000,font-weight:bold
classDef spacewhite fill:#ffffff,stroke:#fff,stroke-width:0px,color:#000
class A,B,D,E,F,G grey
class S,T spacewhite
class first,second white</div></figure><noscript><div class="alert alert-secondary callout" role=alert><em class=javascript-required>JavaScript musi być <a href=https://www.enable-javascript.com/pl/>włączony</a> na tej stronie</em></div></noscript>Schemat 2. - Jak się przygotować</p><ul><li>Przeczytaj <a href=/docs/contribute/new-content/>Contribution overview</a>,
aby dowiedzieć się o różnych sposobach współpracy.</li><li>Zajrzyj do <a href=https://github.com/kubernetes/website/contribute>Contribute to kubernetes/website</a>,
aby znaleźć dobre zgłoszenie na początek.</li><li><a href=/docs/contribute/new-content/new-content/#changes-using-github>Otwórz <em>pull request</em> przy pomocy GitHub-a</a>
dotyczący zmiany istniejącej dokumentacji i dowiedz się, jak otwierać zgłoszenia przy GitHub-ie.</li><li><a href=/docs/contribute/review/reviewing-prs/>Zrecenzuj <em>pull requests</em></a>
innego członka społeczności Kubernetes pod kątem dokładności i stylu.</li><li>Zapoznaj się z poradnikami Kubernetesa dotyczącymi <a href=/docs/contribute/style/content-guide/>zawartości</a>
i <a href=/docs/contribute/style/style-guide/>stylu</a>, aby twoje uwagi były zgodne z tymi wytycznymi.</li><li>Przeczytaj o <a href=/docs/contribute/style/page-content-types/>różnych typach zawartości na stronie</a>
i <a href=/docs/contribute/style/hugo-shortcodes/>skrótach Hugo</a>.</li></ul><h2 id=co-dalej>Co dalej?</h2><ul><li>Naucz się, jak <a href=/docs/contribute/new-content/new-content/#fork-the-repo>pracować z lokalną kopią</a>
repozytorium.</li><li>Udokumentuj <a href=/docs/contribute/new-content/new-features/>nowe funkcjonalności</a>.</li><li>Włącz się w prace <a href=/docs/contribute/participating/>SIG Docs</a>
i zostań <a href=/docs/contribute/participating/#roles-and-responsibilities>członkiem organizacji lub recenzentem</a>.</li><li>Pomagaj przy <a href=/docs/contribute/localization/>tłumaczeniu</a>.</li></ul><h2 id=włącz-się-w-prace-sig-docs>Włącz się w prace SIG Docs</h2><p><a href=/docs/contribute/participating/>SIG Docs</a> to grupa, która publikuje
i utrzymuje dokumentację Kubernetesa i jej stronę www. Zaangażowanie się w prace SIG Docs
to doskonała okazja dla współtwórców Kubernetesa (rozwijających nowe funkcjonalności
lub działających w innych obszarach), aby wywierać wpływ na cały projekt Kubernetes.</p><p>Aby włączyć się w komunikację w ramach SIG Docs, możesz:</p><ul><li><a href=https://slack.k8s.io/>Dołączyć do kanału <code>#sig-docs</code> na komunikatorze Slack dla Kubernetesa</a>. Nie zapomnij
się przedstawić!</li><li><a href=https://groups.google.com/forum/#!forum/kubernetes-sig-docs>Zapisać się na listę <code>kubernetes-sig-docs</code></a>,
na której prowadzone są dyskusje o szerszym zasięgu i zapisywane oficjalne decyzje.</li><li>Dołączyć do <a href=https://github.com/kubernetes/community/tree/master/sig-docs>spotkania wideo SIG Docs</a> odbywającego się co dwa tygodnie. Spotkania są zawsze zapowiadane na <code>#sig-docs</code> i dodawane do <a href="https://calendar.google.com/calendar/embed?src=cgnt364vd8s86hr2phapfjc6uk%40group.calendar.google.com&ctz=Europe/Warsaw">kalendarza spotkań społeczności Kubernetesa</a>. Będziesz potrzebował komunikatora <a href=https://zoom.us/download>Zoom</a> lub telefonu, aby się wdzwonić.</li><li>Dołączyć do spotkania SIG Docs na Slacku organizowanego w tych tygodniach, kiedy nie ma spotkania na Zoomie. Informacja o spotkaniu zawsze ogłaszana jest na <code>#sig-docs</code>. W rozmowach prowadzonych w różnych wątkach na tym kanale można brać udział do 24 godzin od chwili ogłoszenia.</li></ul><h2 id=inne-sposoby-współpracy>Inne sposoby współpracy</h2><ul><li>Odwiedź <a href=/community/>stronę społeczności Kubernetesa</a>. Korzystaj z Twittera i Stack Overflow, dowiedz się o spotkaniach lokalnych grup Kubernetesa, różnych wydarzeniach i nie tylko.</li><li>Przeczytaj <a href=https://www.kubernetes.dev/docs/contributor-cheatsheet/contributor-cheatsheet/>ściągawkę dla współtwórców</a>, aby zaangażować się w dalszy rozwój Kubernetesa.</li><li>Odwiedź stronę <a href=https://www.kubernetes.dev/>Kubernetes Contributors</a> i zajrzyj do <a href=https://www.kubernetes.dev/resources/>dodatkowych zasobów</a>.</li><li>Przygotuj <a href=/docs/contribute/new-content/blogs-case-studies/>wpis na blogu lub <em>case study</em></a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-ac6156512315f527b7ffa1daded4e91b>7.1 - Tłumaczenie dokumentacji na język polski</h1><p>Na tej stronie znajdziesz wskazówki i wytyczne przydatne przy tłumaczeniu dokumentacji Kubernetesa na język polski.</p><p>Dokumentem nadrzędnym jest angielski <a href=/docs/contribute/style/style-guide>opis stylu dokumentacji</a>.</p><h2 id=wskazówki-ogólne>Wskazówki ogólne</h2><p>Staramy się, aby styl tłumaczenia był jak najbardziej naturalny. W przypadku dokumentacji technicznej może być to trudne zadanie,
szczególnie gdy chcemy utrzymać precyzję tłumaczenia.
Zależy nam na unikaniu sytuacji, kiedy tekst zaczyna sprawiać wrażenie przetłumaczonego maszynowo.</p><p>Pamiętajmy też, że oficjalna wykładnia zawsze znajduje się w tekście angielskim. Polskie tłumaczenie ma ułatwić pierwsze kroki osobom,
które zaczynają swoją przygodę z Kubernetesem.</p><h2 id=wytyczne-szczegółowe>Wytyczne szczegółowe</h2><h3 id=odmiana-terminu-kubernetes>Odmiana terminu Kubernetes</h3><p>Kubernetes jest nazwą własną, liczba pojedyncza, rodzaj męski. Odmieniamy: Kubernetesa, Kubernetesem itp.
W uzasadnionych przypadkach można stosować też "system Kubernetes".</p><h3 id=odmiana-terminów-pod-deployment>Odmiana terminów Pod, Deployment</h3><p>Odmieniamy zgodnie z ogólnymi zasadami - poda, deploymentu itp.</p><h3 id=ujednolicony-słownik>Ujednolicony słownik</h3><p>W sieci dostępne są słowniki terminów informatycznych. Poniższa tabela zawiera słowa specyficzne dla Kubernetesa i inne często używane wyrażenia.</p><table><thead><tr><th>Termin angielski</th><th>Tłumaczenie</th></tr></thead><tbody><tr><td>container</td><td>kontener</td></tr><tr><td>control plane</td><td>warstwa sterowania</td></tr><tr><td>Deployment</td><td>Deployment</td></tr><tr><td>horizontal scaling</td><td>skalowanie horyzontalne</td></tr><tr><td>Pod</td><td>Pod</td></tr><tr><td>rolling update</td><td>aktualizacje stopniowe</td></tr><tr><td>volume</td><td>volume (opcjonalnie: wolumin)</td></tr><tr><td>worker node</td><td>węzeł roboczy</td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-91737b3265a3e3f407fbeeb86a8973ab>8 -</h1><script language=javascript>var dropDownsPopulated=!1;$(document).ready(function(){$.get("/metadata.txt",function(e){metadata=$.parseJSON(e),metadata.pages.sort(dynamicSort("t")),mainLogic(),$(window).bind("hashchange",function(){mainLogic()})})});function mainLogic(){dropDownsPopulated||populateDropdowns();var e=window.location.hash.replace("#","");if(e){e=$.trim(e);for(i=0;i<tagName.length;i++)querystringTag=tagName[i]+"=",e.indexOf(querystringTag)>-1&&(console.log("in mainLog: querystringTag of "+querystringTag+" matches tag of "+e),e=e.replace(querystringTag,""),selectDropDown(tagName[i],e),topicsFilter(tagName[i],e,"output"))}else currentTopics=metadata.pages;renderTable(currentTopics,"output")}function populateDropdowns(){for(i=0;i<metadata.pages.length;i++){var e,t=[metadata.pages[i].cr,metadata.pages[i].or,metadata.pages[i].mr];for(j=0;j<t.length;j++)if(t[j])for(k=0;k<t[j].length;k++)typeof storedTagsArrays[j]=="undefined"&&(storedTagsArrays[j]=new Array),storedTagsArrays[j][t[j][k][tagName[j]]]=!0}e=new Array;for(i=0;i<tagName.length;i++)e=[],e.push("<select id='"+tagName[i]+"' onchange='dropFilter(this)'>"),e.push("<option>---</option>"),Object.keys(storedTagsArrays[i]).sort().forEach(function(t){e.push("<option>"+t+"</option>")}),e.push("</select>"),$(dropDowns[i]).html(e.join(""));dropDownsPopulated=!0}function dropFilter(e){console.log("dropFilter:"+$(e).attr("id")+":"+$(e).find(":selected").text()),topicsFilter($(e).attr("id").replace("#",""),$(e).find(":selected").text(),"output");for(i=0;i<tagName.length;i++)$(e).attr("id")!=tagName[i]&&selectDropDown(tagName[i],"---")}function selectDropDown(e,t){$("#"+e).val(t)}</script><style>#filters select{font-size:14px;border:1px #000 solid}#filters{padding-top:20px}</style><p>Aby zastosować odpowiedni filtr, kliknij w etykietę lub użyj rozwijanej listy. Aby posortować rosnąco lub malejąco, kliknij w wybrany nagłówek tabeli.</p><p id=filters>Filtruj według pojęć: <span id=conceptFilter><br>Filtruj według obiektów: <span id=objectFilter><br>Filtruj według poleceń: <span id=commandFilter></p><div id=output></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/pl/docs/home/>Strona główna</a>
<a class=text-white href=/pl/training/>Szkolenia</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 Autorzy Kubernetesa | Dokumentacja jest udostępniona w ramach licencji <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small><br><small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. All rights reserved. The Linux Foundation has registered trademarks and uses trademarks. For a list of trademarks of The Linux Foundation, please see our <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>Trademark Usage page</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>