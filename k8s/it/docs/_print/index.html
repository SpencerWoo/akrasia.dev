<!doctype html><html lang=it class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=en href=https://kubernetes.io/docs/><link rel=alternate hreflang=zh-cn href=https://kubernetes.io/zh-cn/docs/><link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/><link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/><link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/><link rel=alternate hreflang=pt-br href=https://kubernetes.io/pt-br/docs/><link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/><link rel=alternate hreflang=hi href=https://kubernetes.io/hi/docs/><link rel=alternate hreflang=vi href=https://kubernetes.io/vi/docs/><link rel=alternate hreflang=ru href=https://kubernetes.io/ru/docs/><link rel=alternate hreflang=pl href=https://kubernetes.io/pl/docs/><link rel=alternate hreflang=uk href=https://kubernetes.io/uk/docs/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/it/docs/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>Documentazione | Kubernetes</title><meta property="og:title" content="Documentazione"><meta property="og:description" content="Orchestrazione di Container in produzione"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/it/docs/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="Documentazione"><meta itemprop=description content="Orchestrazione di Container in produzione"><meta name=twitter:card content="summary"><meta name=twitter:title content="Documentazione"><meta name=twitter:description content="Orchestrazione di Container in produzione"><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content><meta property="og:description" content><meta name=twitter:description content><meta property="og:url" content="https://kubernetes.io/it/docs/"><meta property="og:title" content="Documentazione"><meta name=twitter:title content="Documentazione"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/it/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/it/docs/>Documentazione</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/it/blog/>Blog di Kubernetes</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/it/training/>Formazione</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/it/partners/>Partner</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/it/community/>Community</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/it/case-studies/>Casi di Studio</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Versions</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/it/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/it/docs/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/it/docs/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/it/docs/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/it/docs/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/it/docs/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Italiano (Italian)</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/docs/>English</a>
<a class=dropdown-item href=/zh-cn/docs/>中文 (Chinese)</a>
<a class=dropdown-item href=/ko/docs/>한국어 (Korean)</a>
<a class=dropdown-item href=/ja/docs/>日本語 (Japanese)</a>
<a class=dropdown-item href=/fr/docs/>Français (French)</a>
<a class=dropdown-item href=/de/docs/>Deutsch (German)</a>
<a class=dropdown-item href=/es/docs/>Español (Spanish)</a>
<a class=dropdown-item href=/pt-br/docs/>Português (Portuguese)</a>
<a class=dropdown-item href=/id/docs/>Bahasa Indonesia</a>
<a class=dropdown-item href=/hi/docs/>हिन्दी (Hindi)</a>
<a class=dropdown-item href=/vi/docs/>Tiếng Việt (Vietnamese)</a>
<a class=dropdown-item href=/ru/docs/>Русский (Russian)</a>
<a class=dropdown-item href=/pl/docs/>Polski (Polish)</a>
<a class=dropdown-item href=/uk/docs/>Українська (Ukrainian)</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>This is the multi-page printable view of this section.
<a href=# onclick="return print(),!1">Click here to print</a>.</p><p><a href=/it/docs/>Return to the regular view of this page</a>.</p></div><h1 class=title>Documentazione</h1><ul><li>1: <a href=#pg-2b03679960950df772fb4fe7d78427b9>Glossary</a></li><li>2: <a href=#pg-e735cee7e913aa88bc0aa10594d12966>Documentazione di Kubernetes</a></li><ul></ul><li>3: <a href=#pg-dd948255948d6b59b32c471abcb62997>Concetti</a></li><ul><li>3.1: <a href=#pg-0554ac387412eaf4e6e89b2f847dacde>Overview</a></li><ul><li>3.1.1: <a href=#pg-45bdca6129cf540121623e903c18ba46>Cos'è Kubernetes?</a></li><li>3.1.2: <a href=#pg-13b0f1dbe89228e3d76d2ac231e245f1>I componenti di Kubernetes</a></li><li>3.1.3: <a href=#pg-0c745f42e623d2b70a53bc0e6db73d95>Le API di Kubernetes</a></li></ul><li>3.2: <a href=#pg-2bf36ccd6b3dbeafecf87c39761b07c7>Architettura di Kubernetes</a></li><ul><li>3.2.1: <a href=#pg-c0251def6da29b30afebfb04549f1703>Comunicazione Control Plane - Nodo</a></li><li>3.2.2: <a href=#pg-bc804b02614d67025b4c788f1ca87fbc>Concetti alla base del Cloud Controller Manager</a></li><li>3.2.3: <a href=#pg-ca8819042a505291540e831283da66df>Controller</a></li></ul><li>3.3: <a href=#pg-a5f7383c83ab9eb9cd0e3c4c020b3ae6>Containers</a></li><ul><li>3.3.1: <a href=#pg-16042b4652ad19e565c7263824029a43>Immagini</a></li><li>3.3.2: <a href=#pg-643212488f778acf04bebed65ba34441>Container Environment</a></li><li>3.3.3: <a href=#pg-e6941d969d81540208a3e78bc56f43bc>Container Lifecycle Hooks</a></li></ul><li>3.4: <a href=#pg-275bea454e1cf4c5adeca4058b5af988>Configurazione</a></li><ul><li>3.4.1: <a href=#pg-6b5ccadd699df0904e8e9917c5450c4b>ConfigMaps</a></li></ul><li>3.5: <a href=#pg-285a3785fd3d20f437c28d87ca4dadca>Amministrazione del Cluster</a></li><ul><li>3.5.1: <a href=#pg-08e94e6a480e0d6b2de72d84a1b97617>Proxy in Kubernetes</a></li></ul><li>3.6: <a href=#pg-4c31edff4063c7b31c556b3eb1405c65>Esempio di modello di concetto</a></li></ul><li>4: <a href=#pg-68ec2370d0409cc27325be36693f9368>Tutorials</a></li><ul><li>4.1: <a href=#pg-5e3051fff9e84735871d9fb5e7b93f33>Hello Minikube</a></li></ul></ul><div class=content></div></div><div class=td-content><h1 id=pg-2b03679960950df772fb4fe7d78427b9>1 - Glossary</h1></div><div class=td-content style=page-break-before:always><h1 id=pg-e735cee7e913aa88bc0aa10594d12966>2 - Documentazione di Kubernetes</h1></div><div class=td-content style=page-break-before:always><h1 id=pg-dd948255948d6b59b32c471abcb62997>3 - Concetti</h1><p>La sezione Concetti ti aiuta a conoscere le parti del sistema Kubernetes e le astrazioni utilizzate da Kubernetes per rappresentare il tuo cluster e ti aiuta ad ottenere una comprensione più profonda di come funziona Kubernetes.</p><h2 id=overview>Overview</h2><p>Per lavorare con Kubernetes, usi <em>gli oggetti API Kubernetes</em> per descrivere lo <em>stato desiderato del tuo cluster</em>: quali applicazioni o altri carichi di lavoro vuoi eseguire, quali immagini del contenitore usano, numero di repliche, quali risorse di rete e disco vuoi rendere disponibile e altro ancora. Puoi impostare lo stato desiderato creando oggetti usando l'API di Kubernetes, in genere tramite l'interfaccia della riga di comando, <code>kubectl</code>. Puoi anche utilizzare direttamente l'API di Kubernetes per interagire con il cluster e impostare o modificare lo stato desiderato.</p><p>Una volta impostato lo stato desiderato, il <em>Kubernetes Control Plane</em> funziona per fare in modo che lo stato corrente del cluster corrisponda allo stato desiderato. Per fare ciò, Kubernetes esegue automaticamente una serie di attività, come l'avvio o il riavvio dei contenitori, il ridimensionamento del numero di repliche di una determinata applicazione e altro ancora. Il piano di controllo di Kubernetes è costituito da una raccolta di processi in esecuzione sul cluster:</p><ul><li>Il <strong>Kubernetes Master</strong> è una raccolta di tre processi che vengono eseguiti su un singolo nodo nel cluster, che è designato come nodo principale. Questi processi sono: <a href=/docs/admin/kube-apiserver/>kube-apiserver</a>, <a href=/docs/admin/kube-controller-manager/>kube-controller-manager</a> e <a href=/docs/admin/kube-scheduler/>kube-scheduler</a>.</li><li>Ogni singolo nodo non principale nel cluster esegue due processi:
  * <strong><a href=/docs/admin/kubelet/>kubelet</a></strong>, che comunica con il master di Kubernetes.
  * <strong><a href=/docs/admin/kube-proxy/>kube-proxy</a></strong>, un proxy di rete che riflette i servizi di rete di Kubernetes su ciascun nodo.</li></ul><h2 id=kubernetes-objects>Kubernetes Objects</h2><p>kubernetes contiene una serie di astrazioni che rappresentano lo stato del tuo sistema: applicazioni e carichi di lavoro distribuiti in container, le loro risorse di rete e disco associate e altre informazioni su ciò che sta facendo il tuo cluster. Queste astrazioni sono rappresentate da oggetti nell'API di Kubernetes; guarda la <a href=/docs/concepts/abstractions/overview/>Panoramica degli oggetti di Kubernetes</a> per maggiori dettagli.</p><p>Gli oggetti di base di Kubernetes includono:</p><ul><li><a href=/docs/concepts/workloads/pods/pod-overview/>Pod</a></li><li><a href=/docs/concepts/services-networking/service/>Service</a></li><li><a href=/docs/concepts/storage/volumes/>Volume</a></li><li><a href=/docs/concepts/overview/working-with-objects/namespaces/>Namespace</a></li></ul><p>209/5000
Inoltre, Kubernetes contiene una serie di astrazioni di livello superiore denominate Controllori. I controller si basano sugli oggetti di base e forniscono funzionalità aggiuntive e funzionalità di convenienza. Loro includono:</p><ul><li><a href=/docs/concepts/workloads/controllers/replicaset/>ReplicaSet</a></li><li><a href=/docs/concepts/workloads/controllers/deployment/>Deployment</a></li><li><a href=/docs/concepts/workloads/controllers/statefulset/>StatefulSet</a></li><li><a href=/docs/concepts/workloads/controllers/daemonset/>DaemonSet</a></li><li><a href=/docs/concepts/workloads/controllers/jobs-run-to-completion/>Job</a></li></ul><h2 id=kubernetes-control-plane>Kubernetes Control Plane</h2><p>Le varie parti del Piano di controllo di Kubernetes, come i master Kubernetes e i processi di Kubelet, regolano il modo in cui Kubernetes comunica con il cluster. Il Piano di controllo mantiene un registro di tutti gli oggetti Kubernetes nel sistema e esegue cicli di controllo continui per gestire lo stato di tali oggetti. In qualsiasi momento, i loop di controllo di Control Plane risponderanno ai cambiamenti nel cluster e lavoreranno per fare in modo che lo stato effettivo di tutti gli oggetti nel sistema corrisponda allo stato desiderato che hai fornito.</p><p>Ad esempio, quando si utilizza l'API di Kubernetes per creare un oggetto di distribuzione, si fornisce un nuovo stato desiderato per il sistema. Il piano di controllo di Kubernetes registra la creazione dell'oggetto e svolge le tue istruzioni avviando le applicazioni richieste e pianificandole sui nodi del cluster, in modo che lo stato effettivo del cluster corrisponda allo stato desiderato.</p><h3 id=kubernetes-master>Kubernetes Master</h3><p>Il master Kubernetes è responsabile della gestione dello stato desiderato per il tuo cluster. Quando interagisci con Kubernetes, ad esempio utilizzando l'interfaccia della riga di comando <code>kubectl</code>, stai comunicando con il master di Kubernetes del cluster.</p><blockquote><p>Il "master" si riferisce a una raccolta di processi che gestiscono lo stato del cluster. In genere questi processi vengono eseguiti tutti su un singolo nodo nel cluster e questo nodo viene anche definito master. Il master può anche essere replicato per disponibilità e ridondanza.</p></blockquote><h3 id=kubernetes-nodes>Kubernetes Nodes</h3><p>I nodi di un cluster sono le macchine (VM, server fisici, ecc.) che eseguono i flussi di lavoro delle applicazioni e del cloud. Il master Kubernetes controlla ciascun nodo; raramente interagirai direttamente con i nodi.</p><h4 id=object-metadata>Object Metadata</h4><ul><li><a href=/docs/concepts/overview/working-with-objects/annotations/>Annotations</a></li></ul><h2 id=voci-correlate>Voci correlate</h2><p>Se vuoi scrivere una pagina concettuale, vedi
<a href=/docs/home/contribute/page-templates/>Uso dei modelli di pagina</a>
per informazioni sul tipo di pagina di concetto e il modello di concetto.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-0554ac387412eaf4e6e89b2f847dacde>3.1 - Overview</h1></div><div class=td-content><h1 id=pg-45bdca6129cf540121623e903c18ba46>3.1.1 - Cos'è Kubernetes?</h1><div class=lead>Kubernetes è una piattaforma portatile, estensibile e open-source per la gestione di carichi di lavoro e servizi containerizzati, in grado di facilitare sia la configurazione dichiarativa che l'automazione. La piattaforma vanta un grande ecosistema in rapida crescita. Servizi, supporto e strumenti sono ampiamente disponibili nel mondo Kubernetes .</div><p>Questa pagina è una panoramica generale su Kubernetes.</p><p>Kubernetes è una piattaforma portatile, estensibile e open-source per la gestione di carichi di lavoro e servizi containerizzati, in grado di facilitare sia la configurazione dichiarativa che l'automazione. La piattaforma vanta un grande ecosistema in rapida crescita. Servizi, supporto e strumenti sono ampiamente disponibili nel mondo Kubernetes .</p><p>Il nome Kubernetes deriva dal greco, significa timoniere o pilota. Google ha reso open-source il progetto Kubernetes nel 2014. Kubernetes unisce <a href=/blog/2015/04/borg-predecessor-to-kubernetes/>oltre quindici anni di esperienza di Google</a> nella gestione di carichi di lavoro di produzione su scala mondiale con le migliori idee e pratiche della comunità.</p><h2 id=facciamo-un-piccolo-salto-indietro>Facciamo un piccolo salto indietro</h2><p>Diamo un'occhiata alla ragione per cui Kubernetes è così utile facendo un piccolo salto indietro nel tempo.</p><p><img src=/images/docs/Container_Evolution.svg alt="Deployment evolution"></p><p><strong>L'era del deployment tradizionale:</strong>
All'inizio, le organizzazioni eseguivano applicazioni su server fisici. Non c'era modo di definire i limiti delle risorse per le applicazioni in un server fisico e questo ha causato non pochi problemi di allocazione delle risorse. Ad esempio, se più applicazioni vengono eseguite sullo stesso server fisico, si possono verificare casi in cui un'applicazione assorbe la maggior parte delle risorse e, di conseguenza, le altre applicazioni non hanno le prestazioni attese. Una soluzione per questo sarebbe di eseguire ogni applicazione su un server fisico diverso. Ma questa non è una soluzione ideale, dal momento che le risorse vengono sottoutilizzate, inoltre, questa pratica risulta essere costosa per le organizzazioni, le quali devono mantenere numerosi server fisici.</p><p><strong>L'era del deployment virtualizzato:</strong>
Come soluzione venne introdotta la virtualizzazione. Essa consente di eseguire più macchine virtuali (VM) su una singola CPU fisica. La virtualizzazione consente di isolare le applicazioni in più macchine virtuali e fornisce un livello di sicurezza superiore, dal momento che le informazioni di un'applicazione non sono liberamente accessibili da un'altra applicazione.</p><p>La virtualizzazione consente un migliore utilizzo delle risorse riducendo i costi per l'hardware, permette una migliore scalabilità, dato che un'applicazione può essere aggiunta o aggiornata facilmente, e ha molti altri vantaggi.</p><p>Ogni VM è una macchina completa che esegue tutti i componenti, compreso il proprio sistema operativo, sopra all'hardware virtualizzato.</p><p><strong>L'era del deployment in container:</strong>
I container sono simili alle macchine virtuali, ma presentano un modello di isolamento più leggero, condividendo il sistema operativo (OS) tra le applicazioni. Pertanto, i container sono considerati più leggeri. Analogamente a una macchina virtuale, un container dispone di una segregazione di filesystem, CPU, memoria, PID e altro ancora. Poiché sono disaccoppiati dall'infrastruttura sottostante, risultano portabili tra differenti cloud e diverse distribuzioni.</p><p>I container sono diventati popolari dal momento che offrono molteplici vantaggi, ad esempio:</p><ul><li>Creazione e distribuzione di applicazioni in modalità Agile: maggiore facilità ed efficienza nella creazione di immagini container rispetto all'uso di immagini VM.</li><li>Adozione di pratiche per lo sviluppo/test/rilascio continuativo: consente la frequente creazione e la distribuzione di container image affidabili, dando la possibilità di fare rollback rapidi e semplici (grazie all'immutabilità dell'immagine stessa).</li><li>Separazione delle fasi di Dev e Ops: le container image vengono prodotte al momento della compilazione dell'applicativo piuttosto che nel momento del rilascio, permettendo così di disaccoppiare le applicazioni dall'infrastruttura sottostante.</li><li>L'osservabilità non riguarda solo le informazioni e le metriche del sistema operativo, ma anche lo stato di salute e altri segnali dalle applicazioni.</li><li>Coerenza di ambiente tra sviluppo, test e produzione: i container funzionano allo stesso modo su un computer portatile come nel cloud.</li><li>Portabilità tra cloud e sistemi operativi differenti: lo stesso container funziona su Ubuntu, RHEL, CoreOS, on-premise, nei più grandi cloud pubblici e da qualsiasi altra parte.</li><li>Gestione incentrata sulle applicazioni: Aumenta il livello di astrazione dall'esecuzione di un sistema operativo su hardware virtualizzato all'esecuzione di un'applicazione su un sistema operativo utilizzando risorse logiche.</li><li>Microservizi liberamente combinabili, distribuiti, ad alta scalabilità: le applicazioni sono suddivise in pezzi più piccoli e indipendenti che possono essere distribuite e gestite dinamicamente - niente stack monolitici che girano su una singola grande macchina.</li><li>Isolamento delle risorse: le prestazioni delle applicazioni sono prevedibili.</li><li>Utilizzo delle risorse: alta efficienza e densità.</li></ul><h2 id=perché-necessito-di-kubernetes-e-cosa-posso-farci>Perché necessito di Kubernetes e cosa posso farci</h2><p>I container sono un buon modo per distribuire ed eseguire le tue applicazioni. In un ambiente di produzione, è necessario gestire i container che eseguono le applicazioni e garantire che non si verifichino interruzioni dei servizi. Per esempio, se un container si interrompe, è necessario avviare un nuovo container. Non sarebbe più facile se questo comportamento fosse gestito direttamente da un sistema?</p><p>È proprio qui che Kubernetes viene in soccorso! Kubernetes ti fornisce un framework per far funzionare i sistemi distribuiti in modo resiliente. Kubernetes si occupa della scalabilità, failover, distribuzione delle tue applicazioni. Per esempio, Kubernetes può facilmente gestire i rilasci con modalità Canary deployment.</p><p>Kubernetes ti fornisce:</p><ul><li><strong>Scoperta dei servizi e bilanciamento del carico</strong>
Kubernetes può esporre un container usando un nome DNS o il suo indirizzo IP. Se il traffico verso un container è alto, Kubernetes è in grado di distribuire il traffico su più container in modo che il servizio rimanga stabile.</li><li><strong>Orchestrazione dello storage</strong>
Kubernetes ti permette di montare automaticamente un sistema di archiviazione di vostra scelta, come per esempio storage locale, dischi forniti da cloud pubblici, e altro ancora.</li><li><strong>Rollout e rollback automatizzati</strong>
Puoi utilizzare Kubernetes per descrivere lo stato desiderato per i propri container, e Kubernetes si occuperà di cambiare lo stato attuale per raggiungere quello desiderato ad una velocità controllata. Per esempio, puoi automatizzare Kubernetes per creare nuovi container per il tuo servizio, rimuovere i container esistenti e adattare le loro risorse a quelle richieste dal nuovo container.</li><li><strong>Ottimizzazione dei carichi</strong>
Fornisci a Kubernetes un cluster di nodi per eseguire i container. Puoi istruire Kubernetes su quanta CPU e memoria (RAM) ha bisogno ogni singolo container. Kubernetes allocherà i container sui nodi per massimizzare l'uso delle risorse a disposizione.</li><li><strong>Self-healing</strong>
Kubernetes riavvia i container che si bloccano, sostituisce container, termina i container che non rispondono agli health checks, e evita di far arrivare traffico ai container che non sono ancora pronti per rispondere correttamente.</li><li><strong>Gestione di informazioni sensibili e della configurazione</strong>
Kubernetes consente di memorizzare e gestire informazioni sensibili, come le password, i token OAuth e le chiavi SSH. Puoi distribuire e aggiornare le informazioni sensibili e la configurazione dell'applicazione senza dover ricostruire le immagini dei container e senza svelare le informazioni sensibili nella configurazione del tuo sistema.</li></ul><h2 id=cosa-non-è-kubernetes>Cosa non è Kubernetes</h2><p>Kubernetes non è un sistema PaaS (Platform as a Service) tradizionale e completo. Dal momento che Kubernetes opera a livello di container piuttosto che che a livello hardware, esso fornisce alcune caratteristiche generalmente disponibili nelle offerte PaaS, come la distribuzione, il ridimensionamento, il bilanciamento del carico, la registrazione e il monitoraggio. Tuttavia, Kubernetes non è monolitico, e queste soluzioni predefinite sono opzionali ed estensibili. Kubernetes fornisce gli elementi base per la costruzione di piattaforme di sviluppo, ma conserva le scelte dell'utente e la flessibilità dove è importante.</p><p>Kubernetes:</p><ul><li>Non limita i tipi di applicazioni supportate. Kubernetes mira a supportare una grande varietà di carichi di lavoro, compresi i carichi di lavoro stateless, stateful e elaborazione di dati. Se un'applicazione può essere eseguita in un container, dovrebbe funzionare alla grande anche su Kubernetes.</li><li>Non compila il codice sorgente e non crea i container. I flussi di Continuous Integration, Delivery, and Deployment (CI/CD) sono determinati dalla cultura e dalle preferenze dell'organizzazione e dai requisiti tecnici.</li><li>Non fornisce servizi a livello applicativo, come middleware (per esempio, bus di messaggi), framework di elaborazione dati (per esempio, Spark), database (per esempio, mysql), cache, né sistemi di storage distribuito (per esempio, Ceph) come servizi integrati. Tali componenti possono essere eseguiti su Kubernetes, e/o possono essere richiamati da applicazioni che girano su Kubernetes attraverso meccanismi come l'<a href=https://openservicebrokerapi.org/>Open Service Broker</a>.</li><li>Non impone soluzioni di logging, monitoraggio o di gestione degli alert. Fornisce alcune integrazioni come dimostrazione, e meccanismi per raccogliere ed esportare le metriche.</li><li>Non fornisce né rende obbligatorio un linguaggio/sistema di configurazione (per esempio, Jsonnet). Fornisce un'API dichiarativa che può essere richiamata da qualsiasi sistema.</li><li>Non fornisce né adotta alcun sistema di gestione completa della macchina, configurazione, manutenzione, gestione o sistemi di self healing.</li><li>Inoltre, Kubernetes non è un semplice sistema di orchestrazione. Infatti, questo sistema elimina la necessità di orchestrazione. La definizione tecnica di orchestrazione è l'esecuzione di un flusso di lavoro definito: prima si fa A, poi B, poi C. Al contrario, Kubernetes è composto da un insieme di processi di controllo indipendenti e componibili che guidano costantemente lo stato attuale verso lo stato desiderato. Non dovrebbe importare come si passa dalla A alla C. Anche il controllo centralizzato non è richiesto. Questo si traduce in un sistema più facile da usare, più potente, robusto, resiliente ed estensibile.</li></ul><h2 id=voci-correlate>Voci correlate</h2><ul><li>Dai un'occhiata alla pagina <a href=/docs/concepts/overview/components/>i componenti di Kubernetes</a></li><li>Sai già <a href=/docs/setup/>Come Iniziare</a>?</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-13b0f1dbe89228e3d76d2ac231e245f1>3.1.2 - I componenti di Kubernetes</h1><div class=lead>Un cluster di Kubernetes è costituito da un insieme di componenti che sono, come minimo, un Control Plane e uno o più sistemi di elaborazione, detti nodi.</div><p>Facendo il deployment di Kubernetes, ottieni un cluster.<p><p>Un cluster Kubernetes è un'insieme di macchine, chiamate nodi, che eseguono container gestiti da Kubernetes. Un cluster ha almeno un Worker Node.</p></p><p>Il/I Worker Node ospitano i Pod che eseguono i workload dell'utente. Il/I Control Plane Node gestiscono i Worker Node e tutto quanto accade all'interno del cluster. Per garantire la high-availability e la possibilità di failover del cluster, vengono utilizzati più Control Plane Node.</p></p><p>Questo documento descrive i diversi componenti che sono necessari per avere
un cluster Kubernetes completo e funzionante.</p><p>Questo è un diagramma di un cluster Kubernetes con tutti i componenti e le loro relazioni.</p><p><img src=/images/docs/components-of-kubernetes.png alt="I componenti di Kubernetes"></p><h2 id=componenti-della-control-plane>Componenti della Control Plane</h2><p>I componenti del Control Plane sono responsabili di tutte le decisioni globali sul cluster (ad esempio, lo scheduling) oltre che a rilevare e rispondere agli eventi del cluster (ad esempio, l'avvio di un nuovo <a class=glossary-tooltip title='Un Pod rappresenta un gruppo di container nel tuo cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=pod>pod</a> quando il valore <code>replicas</code> di un deployment non è soddisfatto).</p><p>I componenti della Control Plane possono essere eseguiti su qualsiasi nodo del cluster stesso. Solitamente, per semplicità, gli script di installazione tendono a eseguire tutti i componenti della Control Plane sulla stessa macchina, separando la Control Plane dai workload dell'utente.
Vedi <a href=/docs/admin/high-availability/>creare un cluster in High-Availability</a> per un esempio di un'installazione multi-master.</p><h3 id=kube-apiserver>kube-apiserver</h3><p>L'API server è un componente di Kubernetes
<a class=glossary-tooltip title="Lo strato per l'orchestrazione dei container che espone le API e interfaccie per definere, deploy, e gestione del ciclo di vita dei container." data-toggle=tooltip data-placement=top href='/it/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='control plane'>control plane</a> che espone le Kubernetes API.
L'API server è il front end del control plane di Kubernetes.</p><p>La principale implementazione di un server Kubernetes API è <a href=/docs/reference/generated/kube-apiserver/>kube-apiserver</a>.
kube-apiserver è progettato per scalare orizzontalmente, cioè scala aumentando il numero di istanze.
Puoi eseguire multiple istanze di kube-apiserver e bilanciare il traffico tra queste istanze.</p><h3 id=etcd>etcd</h3><p>È un database key-value ridondato, che è usato da Kubernetes per salvare tutte le informazioni del cluster.</p><p>Se il tuo cluster utilizza etcd per salvare le informazioni, assicurati di
avere una strategia di <a href=/docs/tasks/administer-cluster/configure-upgrade-etcd/#backing-up-an-etcd-cluster>backup</a> per questi dati.</p><p>Puoi trovare informazioni dettagliate su etcd sulla <a href=https://etcd.io/docs/>documentazione</a> ufficiale.</p><h3 id=kube-scheduler>kube-scheduler</h3><p>Componente della Control Plane che controlla i pod appena creati che non hanno un nodo assegnato, e dopo averlo identificato glielo assegna.</p><p>I fattori presi in considerazioni nell'individuare un nodo a cui assegnare l'esecuzione di un Pod includono la richiesta di risorse del Pod stesso e degli altri workload presenti nel sistema, i vincoli delle hardware/software/policy, le indicazioni di affinity e di anti-affinity, requisiti relativi alla disponibilità di dati/Volumes, le interferenze tra diversi workload e le scadenze.</p><h3 id=kube-controller-manager>kube-controller-manager</h3><p>Componente della Control Plane che gestisce <a class=glossary-tooltip title="Un software che implementa un circuito di controllo che osserva lo stato condiviso del cluster attraverso l'API server e apporta le modifiche necessarie per portate lo stato corrente verso lo stato desiderato." data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=controllers>controllers</a>.</p><p>Da un punto di vista logico, ogni <a class=glossary-tooltip title="Un software che implementa un circuito di controllo che osserva lo stato condiviso del cluster attraverso l'API server e apporta le modifiche necessarie per portate lo stato corrente verso lo stato desiderato." data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=controller>controller</a> è un processo separato, ma per ridurre la complessità, tutti i principali controller di Kubernetes vengono raggruppati in un unico container ed eseguiti in un singolo processo.</p><p>Alcuni esempi di controller gestiti dal kube-controller-manager sono:</p><ul><li>Node Controller: Responsabile del monitoraggio dei nodi del cluster, e.g. della gestione delle azioni da eseguire quando un nodo diventa non disponibile.</li><li>Replication Controller: Responsabile per il mantenimento del corretto numero di Pod per ogni ReplicaSet presente nel sistema</li><li>Endpoints Controller: Popola gli oggetti Endpoints (cioè, mette in relazioni i Pods con i Services).</li><li>Service Account & Token Controllers: Creano gli account di default e i token di accesso alle API per i nuovi namespaces.</li></ul><h3 id=cloud-controller-manager>cloud-controller-manager</h3>Un componente della <a class=glossary-tooltip title="Lo strato per l'orchestrazione dei container che espone le API e interfaccie per definere, deploy, e gestione del ciclo di vita dei container." data-toggle=tooltip data-placement=top href='/it/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='control plane'>control plane</a> di Kubernetes
che aggiunge logiche di controllo specifiche per il cloud. Il cloud-controller-manager ti permette di collegare il tuo
cluster con le API del cloud provider e separa le componenti che interagiscono
con la piattaforma cloud dai componenti che interagiscono solamente col cluster.<p>Il cloud-controller-manager esegue dei controller specifici del tuo cloud provider.
Se hai una installazione Kubernetes on premises, o un ambiente di laboratorio
nel tuo PC, il cluster non ha un cloud-controller-manager.</p><p>Come nel kube-controller-manager, il cloud-controller-manager combina diversi control loop
logicamente indipendenti in un singolo binario che puoi eseguire come un singolo processo. Tu puoi
scalare orizzontalmente (eseguire più di una copia) per migliorare la responsività o per migliorare la tolleranza ai fallimenti.</p><p>I seguenti controller hanno dipendenze verso implementazioni di specifici cloud provider:</p><ul><li>Node Controller: Per controllare se sul cloud provider i nodi che hanno smesso di rispondere sono stati cancellati</li><li>Route Controller: Per configurare le network route nella sottostante infrastruttura cloud</li><li>Service Controller: Per creare, aggiornare ed eliminare i load balancer del cloud provider</li></ul><h2 id=componenti-dei-nodi>Componenti dei Nodi</h2><p>I componenti del nodo vengono eseguiti su ogni nodo, mantenendo i pod in esecuzione e fornendo l'ambiente di runtime Kubernetes.</p><h3 id=kubelet>kubelet</h3><p>Un agente che è eseguito su ogni nodo del cluster. Si assicura che i container siano eseguiti in un pod.</p><p>La kubelet riceve un set di PodSpecs che vengono forniti attraverso vari meccanismi, e si assicura che i container descritti in questi PodSpecs funzionino correttamente e siano sani. La kubelet non gestisce i container che non sono stati creati da Kubernetes.</p><h3 id=kube-proxy>kube-proxy</h3><p><a href=/docs/reference/command-line-tools-reference/kube-proxy/>kube-proxy</a> è un
proxy eseguito su ogni nodo del cluster, responsabile della gestione dei
Kubernetes <a class=glossary-tooltip title='A way to expose an application running on a set of Pods as a network service.' data-toggle=tooltip data-placement=top href=/docs/concepts/services-networking/service/ target=_blank aria-label=Service>Service</a>.</p><p>I kube-proxy mantengono le regole di networking sui nodi.
Queste regole permettono la comunicazione verso gli altri nodi del cluster o l'esterno.</p><p>Il kube-proxy usa le librerie del sistema operativo quando possible; in caso contrario il kube-proxy gestisce il traffico direttamente.</p><h3 id=container-runtime>Container Runtime</h3><p>Il container runtime è il software che è responsabile per l'esecuzione dei container.</p><p>Kubernetes supporta diversi container runtimes: <a href=http://www.docker.com>Docker</a>,
<a href=https://containerd.io>containerd</a>, <a href=https://cri-o.io/>cri-o</a>,
<a href=https://github.com/kubernetes-incubator/rktlet>rktlet</a> e tutte le implementazioni di
<a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-node/container-runtime-interface.md>Kubernetes CRI (Container Runtime Interface)</a>.</p><h2 id=addons>Addons</h2><p>Gli Addons usano le risorse Kubernetes (<a class=glossary-tooltip title='Assicura che una copia di un Pod è attiva su tutti nodi di un cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/daemonset target=_blank aria-label=DaemonSet>DaemonSet</a>, <a class=glossary-tooltip title='Gestisce una applicazione replicata nel tuo cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Deployment>Deployment</a>, etc) per implementare funzionalità di cluster.
Dal momento che gli addons forniscono funzionalità a livello di cluster, le risorse che necessitano di un namespace, vengono collocate nel namespace <code>kube-system</code>.</p><p>Alcuni addons sono descritti di seguito; mentre per una più estesa lista di addons, per favore vedere <a href=/docs/concepts/cluster-administration/addons/>Addons</a>.</p><h3 id=dns>DNS</h3><p>Mentre gli altri addons non sono strettamente richiesti, tutti i cluster Kubernetes dovrebbero essere muniti di un <a href=/docs/concepts/services-networking/dns-pod-service/>DNS del cluster</a>, dal momento che molte applicazioni lo necessitano.</p><p>Il DNS del cluster è un server DNS aggiuntivo rispetto ad altri server DNS presenti nella rete, e si occupa specificatamente dei record DNS per i servizi Kubernetes.</p><p>I container eseguiti da Kubernetes automaticamente usano questo server per la risoluzione DNS.</p><h3 id=interfaccia-web-dashboard>Interfaccia web (Dashboard)</h3><p>La <a href=/docs/tasks/access-application-cluster/web-ui-dashboard/>Dashboard</a> è una interfaccia web per i cluster Kubernetes.
Permette agli utenti di gestire e fare troubleshooting delle applicazioni che girano nel cluster, e del cluster stesso.</p><h3 id=monitoraggio-dei-container>Monitoraggio dei Container</h3><p>Il <a href=/docs/tasks/debug-application-cluster/resource-usage-monitoring/>Monitoraggio dei Container</a> salva serie temporali di metriche generiche dei container in un database centrale e fornisce una interfaccia in cui navigare i dati stessi.</p><h3 id=log-a-livello-di-cluster>Log a livello di Cluster</h3><p>Un <a href=/docs/concepts/cluster-administration/logging/>log a livello di cluster</a> è responsabile per il salvataggio dei log dei container in un log centralizzato la cui interfaccia permette di cercare e navigare nei log.</p><h2 id=voci-correlate>Voci correlate</h2><ul><li>Scopri i concetti relativi ai <a href=/docs/concepts/architecture/nodes/>Nodi</a></li><li>Scopri i concetti relativi ai <a href=/docs/concepts/architecture/controller/>Controller</a></li><li>Scopri i concetti relativi al <a href=/docs/concepts/scheduling/kube-scheduler/>kube-scheduler</a></li><li>Leggi la <a href=https://etcd.io/docs/>documentazione</a> ufficiale di etcd</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-0c745f42e623d2b70a53bc0e6db73d95>3.1.3 - Le API di Kubernetes</h1><div class=lead>Le API di Kubernetes ti permettono di interrogare e manipolare lo stato degli oggetti in Kubernetes. Il cuore del Control Plane di Kubernetes è l'API server e le API HTTP che esso espone. Ogni entità o componente che si interfaccia con il cluster (gli utenti, le singole parti del tuo cluster, i componenti esterni), comunica attraverso l'API server.</div><p>Le convenzioni generali seguite dalle API sono descritte in <a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md>API conventions doc</a>.</p><p>Gli <em>endpoints</em> delle API, la lista delle risorse esposte ed i relativi esempi sono descritti in <a href=/docs/reference>API Reference</a>.</p><p>L'accesso alle API da remoto è discusso in <a href=/docs/reference/access-authn-authz/controlling-access/>Controllare l'accesso alle API</a>.</p><p>Le API di Kubernetes servono anche come riferimento per lo schema dichiarativo della configurazione del sistema stesso. Il comando <a href=/docs/reference/kubectl/overview/>kubectl</a> può essere usato per creare, aggiornare, cancellare ed ottenere le istanze delle risorse esposte attraverso le API.</p><p>Kubernetes assicura la persistenza del suo stato (al momento in <a href=https://coreos.com/docs/distributed-configuration/getting-started-with-etcd/>etcd</a>) usando la rappresentazione delle risorse implementata dalle API.</p><p>Kubernetes stesso è diviso in differenti componenti, i quali interagiscono tra loro attraverso le stesse API.</p><h2 id=evoluzione-delle-api>Evoluzione delle API</h2><p>In base alla nostra esperienza, ogni sistema di successo ha bisogno di evolvere ovvero deve estendersi aggiungendo funzionalità o modificare le esistenti per adattarle a nuovi casi d'uso. Le API di Kubernetes sono quindi destinate a cambiare e ad estendersi. In generale, ci si deve aspettare che nuove risorse vengano aggiunte di frequente cosi come nuovi campi possano altresì essere aggiunti a risorse esistenti. L'eliminazione di risorse o di campi devono seguire la <a href=/docs/reference/using-api/deprecation-policy/>politica di deprecazione delle API</a>.</p><p>In cosa consiste una modifica compatibile e come modificare le API è descritto dal <a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api_changes.md>API change document</a>.</p><h2 id=definizioni-openapi-e-swagger>Definizioni OpenAPI e Swagger</h2><p>La documentazione completa e dettagliata delle API è fornita attraverso la specifica <a href=https://www.openapis.org/>OpenAPI</a>.</p><p>Dalla versione 1.10 di Kubernetes, l'API server di Kubernetes espone le specifiche OpenAPI attraverso il seguente <em>endpoint</em> <code>/openapi/v2</code>. Attraverso i seguenti <em>headers</em> HTTP è possibile richiedere un formato specifico:</p><table><thead><tr><th>Header</th><th>Possibili Valori</th></tr></thead><tbody><tr><td>Accept</td><td><code>application/json</code>, <code>application/com.github.proto-openapi.spec.v2@v1.0+protobuf</code> (il content-type di default è <code>application/json</code> per <code>*/*</code> ovvero questo header può anche essere omesso)</td></tr><tr><td>Accept-Encoding</td><td><code>gzip</code> (questo header è facoltativo)</td></tr></tbody></table><p>Prima della versione 1.14, gli <em>endpoints</em> che includono il formato del nome all'interno del segmento (<code>/swagger.json</code>, <code>/swagger-2.0.0.json</code>, <code>/swagger-2.0.0.pb-v1</code>, <code>/swagger-2.0.0.pb-v1.gz</code>)
espongo le specifiche OpenAPI in formati differenti. Questi <em>endpoints</em> sono deprecati, e saranno rimossi dalla versione 1.14 di Kubernetes.</p><p><strong>Esempi per ottenere le specifiche OpenAPI</strong>:</p><table><thead><tr><th>Prima della 1.10</th><th>Dalla versione 1.10 di Kubernetes</th></tr></thead><tbody><tr><td>GET /swagger.json</td><td>GET /openapi/v2 <strong>Accept</strong>: application/json</td></tr><tr><td>GET /swagger-2.0.0.pb-v1</td><td>GET /openapi/v2 <strong>Accept</strong>: <a href=mailto:application/com.github.proto-openapi.spec.v2@v1.0>application/com.github.proto-openapi.spec.v2@v1.0</a>+protobuf</td></tr><tr><td>GET /swagger-2.0.0.pb-v1.gz</td><td>GET /openapi/v2 <strong>Accept</strong>: <a href=mailto:application/com.github.proto-openapi.spec.v2@v1.0>application/com.github.proto-openapi.spec.v2@v1.0</a>+protobuf <strong>Accept-Encoding</strong>: gzip</td></tr></tbody></table><p>Kubernetes implementa per le sue API anche una serializzazione alternativa basata sul formato Protobuf che è stato pensato principalmente per la comunicazione intra-cluster, documentato nella seguente <a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/protobuf.md>design proposal</a>, e i files IDL per ciascun schema si trovano nei <em>Go packages</em> che definisco i tipi delle API.</p><p>Prima della versione 1.14, l'<em>apiserver</em> di Kubernetes espone anche un'<em>endpoint</em>, <code>/swaggerapi</code>, che può essere usato per ottenere
le documentazione per le API di Kubernetes secondo le specifiche <a href=http://swagger.io/>Swagger v1.2</a> .
Questo <em>endpoint</em> è deprecato, ed è stato rimosso nella versione 1.14 di Kubernetes.</p><h2 id=versionamento-delle-api>Versionamento delle API</h2><p>Per facilitare l'eliminazione di campi specifici o la modifica della rappresentazione di una data risorsa, Kubernetes supporta molteplici versioni della stessa API disponibili attraverso differenti indirizzi, come ad esempio <code>/api/v1</code> oppure
<code>/apis/extensions/v1beta1</code>.</p><p>Abbiamo deciso di versionare a livello di API piuttosto che a livello di risorsa o di campo per assicurare che una data API rappresenti una chiara, consistente vista delle risorse di sistema e dei sui comportamenti, e per abilitare un controllo degli accessi sia per le API in via di decommissionamento che per quelle sperimentali.</p><p>Si noti che il versionamento delle API ed il versionamento del Software sono indirettamente collegati. La <a href=https://git.k8s.io/community/contributors/design-proposals/release/versioning.md>API and release versioning proposal</a> descrive la relazione tra le versioni delle API ed le versioni del Software.</p><p>Differenti versioni delle API implicano differenti livelli di stabilità e supporto. I criteri per ciascuno livello sono descritti in dettaglio nella <a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api_changes.md#alpha-beta-and-stable-versions>API Changes documentation</a>. Queste modifiche sono qui ricapitolate:</p><ul><li>Livello alpha:<ul><li>Il nome di versione contiene <code>alpha</code> (e.g. <code>v1alpha1</code>).</li><li>Potrebbe contenere dei <em>bug</em>. Abilitare questa funzionalità potrebbe esporre al rischio di <em>bugs</em>. Disabilitata di default.</li><li>Il supporto di questa funzionalità potrebbe essere rimosso in ogni momento senza previa notifica.</li><li>Questa API potrebbe cambiare in modo incompatibile in rilasci futuri del Software e senza previa notifica.</li><li>Se ne raccomandata l'utilizzo solo in <em>clusters</em> di test creati per un breve periodo di vita, a causa di potenziali <em>bugs</em> e delle mancanza di un supporto di lungo periodo.</li></ul></li><li>Livello beta:<ul><li>Il nome di versione contiene <code>beta</code> (e.g. <code>v2beta3</code>).</li><li>Il codice è propriamente testato. Abilitare la funzionalità è considerato sicuro. Abilitata di default.</li><li>Il supporto per la funzionalità nel suo complesso non sarà rimosso, tuttavia potrebbe subire delle modifiche.</li><li>Lo schema e/o la semantica delle risorse potrebbe cambiare in modo incompatibile in successivi rilasci beta o stabili. Nel caso questo dovesse verificarsi, verrano fornite istruzioni per la migrazione alla versione successiva. Questo potrebbe richiedere la cancellazione, modifica, e la ri-creazione degli oggetti supportati da questa API. Questo processo di modifica potrebbe richiedere delle valutazioni. La modifica potrebbe richiedere un periodo di non disponibilità dell'applicazione che utilizza questa funzionalità.</li><li>Raccomandata solo per applicazioni non critiche per la vostra impresa a causa dei potenziali cambiamenti incompatibili in rilasci successivi. Se avete più <em>clusters</em> che possono essere aggiornati separatamente, potreste essere in grado di gestire meglio questa limitazione.</li><li><strong>Per favore utilizzate le nostre versioni beta e forniteci riscontri relativamente ad esse! Una volta promosse a stabili, potrebbe non essere semplice apportare cambiamenti successivi.</strong></li></ul></li><li>Livello stabile:<ul><li>Il nome di versione è <code>vX</code> dove <code>X</code> è un intero.</li><li>Le funzionalità relative alle versioni stabili continueranno ad essere presenti per parecchie versioni successive.</li></ul></li></ul><h2 id=api-groups>API groups</h2><p>Per facilitare l'estendibilità delle API di Kubernetes, sono stati implementati gli <a href=https://git.k8s.io/community/contributors/design-proposals/api-machinery/api-group.md><em>API groups</em></a>.<br>L'<em>API group</em> è specificato nel percorso REST ed anche nel campo <code>apiVersion</code> di un oggetto serializzato.</p><p>Al momento ci sono diversi <em>API groups</em> in uso:</p><ol><li><p>Il gruppo <em>core</em>, spesso referenziato come il <em>legacy group</em>, è disponibile al percorso REST <code>/api/v1</code> ed utilizza <code>apiVersion: v1</code>.</p></li><li><p>I gruppi basati su un nome specifico sono disponibili attraverso il percorso REST <code>/apis/$GROUP_NAME/$VERSION</code>, ed usano <code>apiVersion: $GROUP_NAME/$VERSION</code> (e.g. <code>apiVersion: batch/v1</code>). La lista completa degli <em>API groups</em> supportati e' descritta nel documento <a href=/docs/reference/>Kubernetes API reference</a>.</p></li></ol><p>Vi sono due modi per supportati per estendere le API attraverso le <a href=/docs/concepts/api-extension/custom-resources/><em>custom resources</em></a>:</p><ol><li><a href=/docs/tasks/access-kubernetes-api/extend-api-custom-resource-definitions/>CustomResourceDefinition</a>
è pensato per utenti con esigenze CRUD basilari.</li><li>Utenti che necessitano di un nuovo completo set di API che utilizzi appieno la semantica di Kubernetes possono implementare il loro <em>apiserver</em> ed utilizzare l'<a href=/docs/tasks/access-kubernetes-api/configure-aggregation-layer/><em>aggregator</em></a>
per fornire ai propri utilizzatori la stessa esperienza a cui sono abituati con le API incluse nativamente in Kubernetes.</li></ol><h2 id=abilitare-o-disabilitare-gli-api-groups>Abilitare o disabilitare gli <em>API groups</em></h2><p>Alcune risorse ed <em>API groups</em> sono abilitati di default. Questi posso essere abilitati o disabilitati attraverso il settaggio/flag <code>--runtime-config</code>
applicato sull'<em>apiserver</em>. <code>--runtime-config</code> accetta valori separati da virgola. Per esempio: per disabilitare <code>batch/v1</code>, usa la seguente configurazione <code>--runtime-config=batch/v1=false</code>, per abilitare <code>batch/v2alpha1</code>, utilizzate <code>--runtime-config=batch/v2alpha1</code>.<br>Il <em>flag</em> accetta set di coppie <em>chiave/valore</em> separati da virgola che descrivono la configurazione a <em>runtime</em> dell'<em>apiserver</em>.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Abilitare o disabilitare risorse o gruppi richiede il riavvio dell'<em>apiserver</em> e del <em>controller-manager</em> affinché le modifiche specificate attraverso il flag <code>--runtime-config</code> abbiano effetto.</div><h2 id=abilitare-specifiche-risorse-nel-gruppo-extensions-v1beta1>Abilitare specifiche risorse nel gruppo extensions/v1beta1</h2><p>DaemonSets, Deployments, StatefulSet, NetworkPolicies, PodSecurityPolicies e ReplicaSets presenti nel gruppo di API <code>extensions/v1beta1</code> sono disabilitate di default.
Per esempio: per abilitare deployments and daemonsets, utilizza la seguente configurazione
<code>--runtime-config=extensions/v1beta1/deployments=true,extensions/v1beta1/daemonsets=true</code>.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Abilitare/disabilitare una singola risorsa è supportato solo per il gruppo di API <code>extensions/v1beta1</code> per ragioni storiche.</div></div><div class=td-content style=page-break-before:always><h1 id=pg-2bf36ccd6b3dbeafecf87c39761b07c7>3.2 - Architettura di Kubernetes</h1></div><div class=td-content><h1 id=pg-c0251def6da29b30afebfb04549f1703>3.2.1 - Comunicazione Control Plane - Nodo</h1><p>Questo documento cataloga le connessioni tra il piano di controllo (<em>control-plane</em>), in realtà l'apiserver, e il cluster Kubernetes. L'intento è di consentire agli utenti di personalizzare la loro installazione per rafforzare la configurazione di rete affinché il cluster possa essere eseguito su una rete pubblica (o su IP completamente pubblici resi disponibili da un fornitore di servizi cloud).</p><h2 id=dal-nodo-al-control-plane>Dal Nodo al control-plane</h2><p>Kubernetes adotta un pattern per le API di tipo <em>"hub-and-spoke"</em>. Tutte le chiamate delle API eseguite sui vari nodi sono effettuate verso l'apiserver (nessuno degli altri componenti principali è progettato per esporre servizi remoti). L'apiserver è configurato per l'ascolto di connessioni remote su una porta HTTPS protetta (443) con una o più forme di <a href=/docs/reference/access-authn-authz/authentication/>autenticazioni client</a> abilitate. Si dovrebbero abilitare una o più forme di <a href=/docs/reference/access-authn-authz/authorization/>autorizzazioni</a>, in particolare nel caso in cui siano ammesse <a href=/docs/reference/access-authn-authz/authentication/#anonymous-requests>richieste anonime</a> o <a href=/docs/reference/access-authn-authz/authentication/#service-account-tokens><em>token</em> legati ad un account di servizio (<em>service account</em>)</a>.</p><p>Il certificato pubblico (<em>public root certificate</em>) relativo al cluster corrente deve essere fornito ai vari nodi di modo che questi possano connettersi in modo sicuro all'apiserver insieme alle credenziali valide per uno specifico <em>client</em>. Ad esempio, nella configurazione predefinita di un cluster <a href="https://cloud.google.com/kubernetes-engine?hl=it">GKE</a>, le credenziali del client fornite al kubelet hanno la forma di un certificato client. Si veda
<a href=/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/>inizializzazione TLS del kubelet TLS</a> per la fornitura automatica dei certificati client al <em>kubelet</em>.</p><p>I Pod che desiderano connettersi all'apiserver possono farlo in modo sicuro sfruttando un account di servizio in modo che Kubernetes inserisca automaticamente il certificato pubblico di radice e un token valido al portatore (<em>bearer token</em>) all'interno Pod quando questo viene istanziato.
In tutti i namespace è configurato un <em>Service</em> con nome <code>kubernetes</code> con un indirizzo IP virtuale che viene reindirizzato (tramite <em>kube-proxy</em>) all'endpoint HTTPS dell'apiserver.</p><p>Anche i componenti del piano d controllo comunicano con l'apiserver del cluster su di una porta sicura esposta da quest'ultimo.</p><p>Di conseguenza, la modalità operativa predefinita per le connessioni dai nodi e dai Pod in esecuzione sui nodi verso il <em>control-plane</em> è protetta da un'impostazione predefinita
e può essere eseguita su reti non sicure e/o pubbliche.</p><h2 id=dal-control-plane-al-nodo>Dal control-plane al nodo</h2><p>Esistono due percorsi di comunicazione principali dal <em>control-plane</em> (apiserver) verso i nodi. Il primo è dall'apiserver verso il processo <em>kubelet</em> in esecuzione su ogni nodo nel cluster. Il secondo è dall'apiserver a ciascun nodo, Pod, o servizio attraverso la funzionalità proxy dell'apiserver.</p><h3 id=dall-apiserver-al-kubelet>Dall'apiserver al <em>kubelet</em></h3><p>Le connessioni dall'apiserver al <em>kubelet</em> vengono utilizzate per:</p><ul><li>Prendere i log relativi ai vari Pod.</li><li>Collegarsi (attraverso kubectl) ai Pod in esecuzione.</li><li>Fornire la funzionalità di <em>port-forwarding</em> per i <em>kubelet</em>.</li></ul><p>Queste connessioni terminano all'endpoint HTTPS del <em>kubelet</em>. Di default, l'apiserver non verifica il certificato servito dal <em>kubelet</em>, il che rende la connessione soggetta ad attacchi <em>man-in-the-middle</em>, e tale da essere considerato <strong>non sicuro (unsafe)</strong> se eseguito su reti non protette e/o pubbliche.</p><p>Per verificare questa connessione, si utilizzi il parametro <code>--kubelet-certificate-authority</code> al fine di fornire all'apiserver un insieme di certificati radice da utilizzare per verificare il
il certificato servito dal <em>kubelet</em>.</p><p>Se questo non è possibile, si usi un <a href=/docs/tasks/access-application-cluster/port-forward-access-application-cluster/>tunnel SSH</a> tra l'apiserver e il <em>kubelet</em>, se richiesto, per evitare il collegamento su una rete non protetta o pubblica.</p><p>In fine, l'<a href=/docs/admin/kubelet-authentication-authorization/>autenticazione e/o l'autorizzazione del kubelet</a> dovrebbe essere abilitate per proteggere le API esposte dal <em>kubelet</em>.</p><h3 id=dal-apiserver-ai-nodi-pod-servizi>Dall'apiserver ai nodi, Pod, e servizi</h3><p>Le connessioni dall'apiserver verso un nodo, Pod o servizio avvengono in modalità predefinita su semplice connessione HTTP e quindi non sono né autenticate né criptata. Queste connessioni possono essere eseguite su una connessione HTTPS sicura mediante il prefisso <code>https:</code> al nodo, Pod o nome del servizio nell'URL dell'API, ma non valideranno il certificato fornito dall'endpoint HTTPS né forniranno le credenziali del client così anche se la connessione verrà criptata, non fornirà alcuna garanzia di integrità. <strong>Non è attualmente sicuro</strong> eseguire queste connessioni su reti non protette e/o pubbliche.</p><h3 id=i-tunnel-ssh>I tunnel SSH</h3><p>Kubernetes supporta i <em>tunnel</em> SSH per proteggere la comunicazione tra il <em>control-plane</em> e i nodi. In questa configurazione, l'apiserver inizializza un tunnel SSH con ciascun nodo del cluster (collegandosi al server SSH in ascolto sulla porta 22) e fa passare tutto il traffico verso il <em>kubelet</em>, il nodo, il Pod, o il servizio attraverso questo tunnel. Questo tunnel assicura che il traffico non sia esposto al di fuori della rete su cui sono in esecuzioni i vari nodi.</p><p>I tunnel SSH sono al momento deprecati ovvero non dovrebbero essere utilizzati a meno che ci siano delle esigenze particolari. Il servizio <code>Konnectivity</code> è pensato per rimpiazzare questo canale di comunicazione.</p><h3 id=il-servizio-konnectivity>Il servizio <em>Konnectivity</em></h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.18 [beta]</code></div><p>Come rimpiazzo dei tunnel SSH, il servizio <em>Konnectivity</em> fornisce un proxy a livello TCP per la comunicazione tra il <em>control-plane</em> e il cluster. Il servizio <em>Konnectivity</em> consiste in due parti: il <em>Konnectivity</em> server e gli agenti <em>Konnectivity</em>, in esecuzione rispettivamente sul <em>control-plane</em> e sui vari nodi. Gli agenti <em>Konnectivity</em> inizializzano le connessioni verso il server <em>Konnectivity</em> e mantengono le connessioni di rete. Una volta abilitato il servizio <em>Konnectivity</em>, tutto il traffico tra il <em>control-plane</em> e i nodi passa attraverso queste connessioni.</p><p>Si può fare riferimento al <a href=/docs/tasks/extend-kubernetes/setup-konnectivity/>tutorial per il servizio <em>Konnectivity</em></a> per configurare il servizio <em>Konnectivity</em> all'interno del cluster</p></div><div class=td-content style=page-break-before:always><h1 id=pg-bc804b02614d67025b4c788f1ca87fbc>3.2.2 - Concetti alla base del Cloud Controller Manager</h1><p>Il concetto di CCM (cloud controller manager), da non confondere con il binario, è stato originariamente creato per consentire di sviluppare Kubernetes indipendentemente dall'implementazione dello specifico cloud provider. Il cloud controller manager viene eseguito insieme ad altri componenti principali come il Kubernetes controller manager, il server API e lo scheduler. Può anche essere avviato come addon di Kubernetes, nel qual caso viene eseguito su Kubernetes.</p><p>Il design del cloud controller manager è basato su un meccanismo di plug-in che consente ai nuovi provider cloud di integrarsi facilmente con Kubernetes creando un plug-in. Sono in atto programmi per l'aggiunta di nuovi provider di cloud su Kubernetes e per la migrazione dei provider che usano il vecchio metodo a questo nuovo metodo.</p><p>Questo documento discute i concetti alla base del cloud controller manager e fornisce dettagli sulle funzioni associate.</p><p>Ecco l'architettura di un cluster Kubernetes senza il gestore del controller cloud:</p><p><img src=/images/docs/pre-ccm-arch.png alt="Pre CCM Kube Arch"></p><h2 id=architettura>Architettura</h2><p>Nel diagramma precedente, Kubernetes e il provider cloud sono integrati attraverso diversi componenti:</p><ul><li>Kubelet</li><li>Kubernetes controller manager</li><li>Kubernetes API server</li></ul><p>Il CCM consolida tutta la logica dipendente dal cloud presente nei tre componenti precedenti, per creare un singolo punto di integrazione con il cloud. La nuova architettura con il CCM si presenta così:</p><p><img src=/images/docs/post-ccm-arch.png alt="CCM Kube Arch"></p><h2 id=componenti-del-ccm>Componenti del CCM</h2><p>Il CCM divide alcune funzionalità del Kubernetes controller manager (KCM) e le esegue in un differente processo. In particolare, toglie dal KCM le integrazioni con il cloud specifico. Il KCM ha i seguenti controller che dipendono dal cloud specifico:</p><ul><li>Node controller</li><li>Volume controller</li><li>Route controller</li><li>Service controller</li></ul><p>Nella versione 1.9, il CCM esegue i seguenti controller dall'elenco precedente:</p><ul><li>Node controller</li><li>Route controller</li><li>Service controller</li></ul><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> È stato deliberatamente deciso di non spostare il Volume controller nel CCM. Data la complessità del Volume controller e gli sforzi già fatti per astrarre le logiche specifiche dei singoli fornitori, è stato deciso che il Volume controller non verrà spostato nel CCM.</div><p>Il piano originale per supportare i volumi utilizzando il CCM era di utilizzare <a href=/docs/concepts/storage/volumes/#flexVolume>Flex</a> per supportare volumi collegabili. Tuttavia, una implementazione parallela, nota come <a href=/docs/concepts/storage/volumes/#csi>CSI</a> è stata designata per sostituire Flex.</p><p>Considerando queste evoluzioni, abbiamo deciso di adottare un approccio intermedio finché il CSI non è pronto.</p><h2 id=funzioni-del-ccm>Funzioni del CCM</h2><p>Il CCM eredita le sue funzioni da componenti di Kubernetes che dipendono da uno specifico provider di cloud. Questa sezione è strutturata sulla base di tali componenti.</p><h3 id=1-kubernetes-controller-manager>1. Kubernetes controller manager</h3><p>La maggior parte delle funzioni del CCM deriva dal KCM. Come menzionato nella sezione precedente, CCM esegue i seguenti cicli di controllo:</p><ul><li>Node controller</li><li>Route controller</li><li>Service controller</li></ul><h4 id=node-controller>Node controller</h4><p>Il Node controller è responsabile per l'inizializzazione di un nodo ottenendo informazioni sui nodi in esecuzione nel cluster dal provider cloud. Il controller del nodo esegue le seguenti funzioni:</p><ol><li>Inizializzare un nodo con le label zone/region specifiche per il cloud in uso.</li><li>Inizializzare un nodo con le specifiche, ad esempio, tipo e dimensione specifiche del cloud in uso.</li><li>Ottenere gli indirizzi di rete del nodo e l'hostname.</li><li>Nel caso in cui un nodo non risponda, controlla il cloud per vedere se il nodo è stato cancellato dal cloud.
Se il nodo è stato eliminato dal cloud, elimina l'oggetto Nodo di Kubernetes.</li></ol><h4 id=route-controller>Route controller</h4><p>Il Route controller è responsabile della configurazione delle route nel cloud in modo che i container su nodi differenti del cluster Kubernetes possano comunicare tra loro. Il Route controller è utilizzabile solo dai cluster su Google Compute Engine.</p><h4 id=service-controller>Service Controller</h4><p>Il Service Controller rimane in ascolto per eventi di creazione, aggiornamento ed eliminazione di servizi. In base allo stato attuale dei servizi in Kubernetes, configura i bilanciatori di carico forniti dal cloud (come gli ELB, i Google LB, o gli Oracle Cloud Infrastructure LB) per riflettere lo stato dei servizi in Kubernetes. Inoltre, assicura che i back-end dei bilanciatori di carico forniti dal cloud siano aggiornati.</p><h3 id=2-kubelet>2. Kubelet</h3><p>Il Node Controller contiene l'implementazione dipendente dal cloud della kubelet. Prima dell'introduzione del CCM, la kubelet era responsabile dell'inizializzazione di un nodo con dettagli dipendenti dallo specifico cloud come gli indirizzi IP, le label region/zone e le informazioni sul tipo di istanza. L'introduzione del CCM ha spostato questa operazione di inizializzazione dalla kubelet al CCM.</p><p>In questo nuovo modello, la kubelet inizializza un nodo senza informazioni specifiche del cloud. Tuttavia, aggiunge un blocco al nodo appena creato che rende il nodo non selezionabile per eseguire container finché il CCM non inizializza il nodo con le informazioni specifiche del cloud. Il CCM rimuove quindi questo blocco.</p><h2 id=sistema-a-plug-in>Sistema a plug-in</h2><p>Il cloud controller manager utilizza le interfacce di Go per consentire l'implementazione di implementazioni di qualsiasi cloud. In particolare, utilizza l'interfaccia CloudProvider definita <a href=https://github.com/kubernetes/cloud-provider/blob/9b77dc1c384685cb732b3025ed5689dd597a5971/cloud.go#L42-L62>qui</a>.</p><p>L'implementazione dei quattro controller generici evidenziati sopra, alcune strutture, l'interfaccia cloudprovider condivisa rimarranno nel core di Kubernetes. Le implementazioni specifiche per i vari cloud saranno costruite al di fuori del core e implementeranno le interfacce definite nel core.</p><p>Per ulteriori informazioni sullo sviluppo di plug-in, consultare <a href=/docs/tasks/administer-cluster/developing-cloud-controller-manager/>Developing Cloud Controller Manager</a>.</p><h2 id=autorizzazione>Autorizzazione</h2><p>Questa sezione dettaglia l'accesso richiesto dal CCM sui vari API objects per eseguire le sue operazioni.</p><h3 id=node-controller-1>Node controller</h3><p>Il Node controller funziona solo con oggetti di tipo Node. Richiede l'accesso completo per ottenere, elencare, creare, aggiornare, applicare patch, guardare ed eliminare oggetti di tipo Node.</p><p>v1/Node:</p><ul><li>Get</li><li>List</li><li>Create</li><li>Update</li><li>Patch</li><li>Watch</li><li>Delete</li></ul><h3 id=route-controller-1>Route controller</h3><p>Il Route controller ascolta la creazione dell'oggetto Node e configura le rotte in modo appropriato. Richiede l'accesso in lettura agli oggetti di tipo Node.</p><p>v1/Node:</p><ul><li>Get</li></ul><h3 id=service-controller-1>Service controller</h3><p>Il Service controller resta in ascolto per eventi di creazione, aggiornamento ed eliminazione di oggetti di tipo Servizi, e configura gli endpoint per tali Servizi in modo appropriato.</p><p>Per accedere ai Servizi, è necessario il permesso per list e watch. Per aggiornare i Servizi, sono necessari i permessi patch e update.</p><p>Per impostare gli endpoint per i Servizi, richiede i permessi create, list, get, watch, e update.</p><p>v1/Service:</p><ul><li>List</li><li>Get</li><li>Watch</li><li>Patch</li><li>Update</li></ul><h3 id=others>Others</h3><p>L'implementazione del core di CCM richiede l'accesso per creare eventi e, per garantire operazioni sicure, richiede l'accesso per creare ServiceAccounts.</p><p>v1/Event:</p><ul><li>Create</li><li>Patch</li><li>Update</li></ul><p>v1/ServiceAccount:</p><ul><li>Create</li></ul><p>L'RBAC ClusterRole per il CCM ha il seguente aspetto:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cloud-controller-manager<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- events<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- create<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- patch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- nodes<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#39;*&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- nodes/status<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- patch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- services<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- list<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- patch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- watch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- serviceaccounts<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- create<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- persistentvolumes<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- get<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- list<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- watch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- endpoints<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- create<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- get<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- list<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- watch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=vendor-implementations>Vendor Implementations</h2><p>I seguenti fornitori di cloud hanno una implementazione di CCM:</p><ul><li><a href=https://github.com/kubernetes/cloud-provider-alibaba-cloud>Alibaba Cloud</a></li><li><a href=https://github.com/kubernetes/cloud-provider-aws>AWS</a></li><li><a href=https://github.com/kubernetes/cloud-provider-azure>Azure</a></li><li><a href=https://github.com/baidu/cloud-provider-baiducloud>BaiduCloud</a></li><li><a href=https://github.com/digitalocean/digitalocean-cloud-controller-manager>DigitalOcean</a></li><li><a href=https://github.com/kubernetes/cloud-provider-gcp>GCP</a></li><li><a href=https://github.com/hetznercloud/hcloud-cloud-controller-manager>Hetzner</a></li><li><a href=https://github.com/linode/linode-cloud-controller-manager>Linode</a></li><li><a href=https://github.com/kubernetes/cloud-provider-openstack>OpenStack</a></li><li><a href=https://github.com/oracle/oci-cloud-controller-manager>Oracle</a></li><li><a href=https://github.com/TencentCloud/tencentcloud-cloud-controller-manager>TencentCloud</a></li></ul><h2 id=cluster-administration>Cluster Administration</h2><p>Le istruzioni complete per la configurazione e l'esecuzione del CCM sono fornite
<a href=/docs/tasks/administer-cluster/running-cloud-controller/#cloud-controller-manager>qui</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-ca8819042a505291540e831283da66df>3.2.3 - Controller</h1><p>Nella robotica e nell'automazione, un <em>circuito di controllo</em> (<em>control loop</em>) è un un'iterazione senza soluzione di continuità che regola lo stato di un sistema.</p><p>Ecco un esempio di un circuito di controllo: il termostato di una stanza.</p><p>Quando viene impostata la temperatura, si definisce attraverso il termostato lo <em>stato desiderato</em>. L'attuale temperatura nella stanza è invece lo <em>stato corrente</em>. Il termostato agisce per portare lo stato corrente il più vicino possibile allo stato desiderato accendendo e spegnendo le apparecchiature.</p>In Kubernetes, i <em>controller</em> sono circuiti di controllo che osservano lo stato del <a class=glossary-tooltip title="Un'insieme di macchine, chiamate nodi, che eseguono container gestiti da Kubernetes. Un cluster ha almeno un Worker Node." data-toggle=tooltip data-placement=top href='/it/docs/reference/glossary/?all=true#term-cluster' target=_blank aria-label=cluster>cluster</a>, e apportano o richiedono modifiche quando necessario. Ogni <em>controller</em> prova a portare lo stato corrente del cluster verso lo stato desiderato.<h2 id=il-modello-del-controller>Il modello del controller</h2><p>Un <em>controller</em> monitora almeno una tipo di risorsa registrata in Kubernetes.
Questi <a href=/docs/concepts/overview/working-with-objects/kubernetes-objects/#kubernetes-objects>oggetti</a> hanno una proprietà chiamata <em>spec</em> (specifica) che rappresenta lo stato desiderato. Il o i <em>controller</em> per quella risorsa sono responsabili di mantenere lo stato corrente il più simile possibile rispetto allo stato desiderato.</p><p>Il <em>controller</em> potrebbe eseguire l'azione relativa alla risorsa in questione da sé; più comunemente, in Kubernetes, un <em>controller</em> invia messaggi all'<a class=glossary-tooltip title='Componente della Control plane che serve le Kubernetes API.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-apiserver/ target=_blank aria-label='API server'>API server</a> che a sua volta li rende disponibili ad altri componenti nel cluster. Di seguito troverete esempi per questo scenario.</p><h3 id=controllo-attraverso-l-api-server>Controllo attraverso l'API server</h3><p>Il <a class=glossary-tooltip title='Uno o più lavori (task) che vengono eseguiti fino al loro completamento.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/jobs-run-to-completion target=_blank aria-label=Job>Job</a> <em>controller</em> è un esempio di un <em>controller</em> nativo in Kubernetes. I <em>controller</em> nativi gestiscono lo stato interagendo con l'API server presente nel cluster.</p><p>Il Job è una risorsa di Kubernetes che lancia uno o più <a class=glossary-tooltip title='Un Pod rappresenta un gruppo di container nel tuo cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a> per eseguire un lavoro (task) e poi fermarsi.</p><p>(Una volta che è stato <a href=/docs/concepts/scheduling-eviction/>schedulato</a>, un oggetto <em>Pod</em> diventa parte dello stato desisderato di un dato <em>kubelet</em>).</p><p>Quando il Job <em>controller</em> vede un nuovo lavoro da svolgere si assicura che, da qualche parte nel cluster, i <em>kubelet</em> anche sparsi su più nodi eseguano il numero corretto di <em>Pod</em> necessari per eseguire il lavoro richiesto. Il Job <em>controller</em> non esegue direttamente alcun <em>Pod</em> o <em>container</em> bensì chiede all'API server di creare o rimuovere i <em>Pod</em>. Altri componenti appartenenti al <a class=glossary-tooltip title="Lo strato per l'orchestrazione dei container che espone le API e interfaccie per definere, deploy, e gestione del ciclo di vita dei container." data-toggle=tooltip data-placement=top href='/it/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='control plane'>control plane</a> reagiscono in base alle nuove informazioni (ci sono nuovi <em>Pod</em> da creare e gestire) e cooperano al completamento del job.</p><p>Dopo che un nuovo Job è stato creato, lo stato desiderato per quel Job è il suo completamento. Il Job <em>controller</em> fa sì che lo stato corrente per quel Job sia il più vicino possibile allo stato desiderato: creare <em>Pod</em> che eseguano il lavoro che deve essere effettuato attraverso il Job, così che il Job sia prossimo al completamento.</p><p>I <em>controller</em> aggiornano anche gli oggetti che hanno configurato. Ad esempio: una volta che il lavoro relativo ad un dato Job è stato completato, il Job <em>controller</em> aggiorna l'oggetto Job segnandolo come <code>Finished</code>.</p><p>(Questo è simile allo scenario del termostato che spegne un certo led per indicare che ora la stanza ha raggiungo la temperatura impostata)</p><h3 id=controllo-diretto>Controllo diretto</h3><p>A differenza del Job, alcuni <em>controller</em> devono eseguire delle modifiche a parti esterne al cluster.</p><p>Per esempio, se viene usato un circuito di controllo per assicurare che ci sia un numero sufficiente di <a class=glossary-tooltip title='Un node è una macchina worker in Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/nodes/ target=_blank aria-label=Nodi>Nodi</a> nel cluster, allora il <em>controller</em> ha bisogno che qualcosa al di fuori del cluster configuri i nuovi <em>Nodi</em> quando sarà necessario.</p><p>I <em>controller</em> che interagiscono con un sistema esterno trovano il loro stato desiderato attraverso l'API server, quindi comunicano direttamente con un sistema esterno per portare il loro stato corrente più in linea possibile con lo stato desiderato</p><p>(In realtà c'è un <em>controller</em> che scala orizzontalmente i nodi nel cluster. Vedi <a href=/docs/tasks/administer-cluster/cluster-management/#cluster-autoscaling>Cluster autoscaling</a>).</p><h2 id=desiderato-vs-corrente>Stato desiderato versus corrente</h2><p>Kubernetes ha una visione <em>cloud-native</em> dei sistemi, ed è in grado di gestire continue modifiche.</p><p>Il cluster viene modificato continuamente durante la sua attività ed il <em>circuito di controllo</em> è in grado di risolvere automaticamente i possibili guasti.</p><p>Fino a che i <em>controller</em> del cluster sono in funzione ed in grado di apportare le dovute modifiche, non è rilevante che lo stato complessivo del cluster sia o meno stabile.</p><h2 id=progettazione>Progettazione</h2><p>Come cardine della sua progettazione, Kubernetes usa vari <em>controller</em> ognuno dei quali è responsabile per un particolare aspetto dello stato del cluster. Più comunemente, un dato <em>circuito di controllo</em> (<em>controller</em>) usa un tipo di risorsa per il suo stato desiderato, ed utilizza anche risorse di altro tipo per raggiungere questo stato desiderato. Per esempio il Job <em>controller</em> tiene traccia degli oggetti di tipo <em>Job</em> (per scoprire nuove attività da eseguire) e degli oggetti di tipo <em>Pod</em> (questi ultimi usati per eseguire i <em>Job</em>, e quindi per controllare quando il loro lavoro è terminato). In questo caso, qualcos'altro crea i <em>Job</em>, mentre il <em>Job</em> <em>controller</em> crea i <em>Pod</em>.</p><p>È utile avere semplici <em>controller</em> piuttosto che un unico, monolitico, <em>circuito di controllo</em>. I <em>controller</em> possono guastarsi, quindi Kubernetes è stato disegnato per gestire questa eventualità.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong><p>Ci possono essere diversi <em>controller</em> che creato o aggiornano lo stesso tipo di oggetti. Dietro le quinte, i <em>controller</em> di Kubernetes si preoccupano esclusivamente delle risorse (di altro tipo) collegate alla risorsa primaria da essi controllata.</p><p>Per esempio, si possono avere <em>Deployment</em> e <em>Job</em>; entrambe creano <em>Pod</em>. Il Job <em>controller</em> non distrugge i <em>Pod</em> creati da un <em>Deployment</em>, perché ci sono informazioni (<em><a class=glossary-tooltip title='Tags di oggetti con attributi identificativi che sono significativi e pertinenti per gli utenti.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/labels target=_blank aria-label=labels>labels</a></em>) che vengono usate dal <em>controller</em> per distinguere i <em>Pod</em>.</p></div><h2 id=eseguire-controller>I modi per eseguire i <em>controller</em></h2><p>Kubernetes annovera un insieme di <em>controller</em> nativi che sono in esecuzione all'interno del <a class=glossary-tooltip title='Componente della Control Plane che gestisce i controller.' data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-controller-manager/ target=_blank aria-label=kube-controller-manager>kube-controller-manager</a>. Questi <em>controller</em> nativi forniscono importanti funzionalità di base.</p><p>Il Deployment <em>controller</em> ed il Job <em>controller</em> sono esempi di <em>controller</em> che vengono forniti direttamente da Kubernetes stesso (ovvero <em>controller</em> "nativi").
Kubernetes consente di eseguire un <em>piano di controllo</em>(<em>control plane</em>) resiliente, di modo che se un dei <em>controller</em> nativi dovesse fallire, un'altra parte del piano di controllo si occuperà di eseguire quel lavoro.</p><p>Al fine di estendere Kubernetes, si possono avere <em>controller</em> in esecuzione al di fuori del piano di controllo. Oppure, se si desidera, è possibile scriversi un nuovo <em>controller</em>. È possibile eseguire il proprio controller come una serie di <em>Pod</em>, oppure esternamente rispetto a Kubernetes. Quale sia la soluzione migliore, dipende dalla responsabilità di un dato controller.</p><h2 id=voci-correlate>Voci correlate</h2><ul><li>Leggi in merito <a href=/docs/concepts/#kubernetes-control-plane>Kubernetes control plane</a></li><li>Scopri alcune delle basi degli <a href=/docs/concepts/#kubernetes-objects>oggetti di Kubernetes</a></li><li>Per saperne di più riguardo alle <a href=/docs/concepts/overview/kubernetes-api/>API di Kubernetes</a></li><li>Se vuoi creare un tuo <em>controller</em>, guarda <a href=/docs/concepts/extend-kubernetes/extend-cluster/#extension-patterns>i modelli per l'estensibilità</a> in Estendere Kubernetes.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-a5f7383c83ab9eb9cd0e3c4c020b3ae6>3.3 - Containers</h1><div class=lead>La tecnologia per distribuire un'applicazione insieme con le dipendenze necessarie per la sua esecuzione.</div><p>Ogni <em>container</em> che viene eseguito è riproducibile; la pratica di includere le dipendenze all'interno di ciascuno <em>container</em> permette di ottenere sempre lo stesso risultato ad ogni esecuzione del medesimo <em>container</em>.</p><p>I <em>Container</em> permettono di disaccoppiare le applicazioni dall'infrastruttura del host su cui vengono eseguite. Questo approccio rende più facile il <em>deployment</em> su cloud o sitemi operativi differenti tra loro.</p><h2 id=immagine-di-container>Immagine di container</h2><p>L'<a href=/docs/concepts/containers/images/>immagine di un container</a> e' un pacchetto software che contiene tutto ciò che serve per eseguire un'applicazione: il codice sorgente e ciascun <em>runtime</em> necessario, librerie applicative e di sistema, e le impostazioni predefinite per ogni configurazione necessaria.</p><p>Un <em>container</em> è immutabile per definizione: non è possibile modificare il codice di un <em>container</em> in esecuzione. Se si ha un'applicazione containerizzata e la si vuole modificare, si deve costruire un nuovo <em>container</em> che includa il cambiamento desiderato, e quindi ricreare il <em>container</em> partendo dalla nuova immagine aggiornata.</p><h2 id=container-runtimes>Container runtimes</h2><p>Il container runtime è il software che è responsabile per l'esecuzione dei container.</p><p>Kubernetes supporta diversi container runtimes: <a href=http://www.docker.com>Docker</a>,
<a href=https://containerd.io>containerd</a>, <a href=https://cri-o.io/>cri-o</a>,
<a href=https://github.com/kubernetes-incubator/rktlet>rktlet</a> e tutte le implementazioni di
<a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-node/container-runtime-interface.md>Kubernetes CRI (Container Runtime Interface)</a>.</p><h2 id=voci-correlate>Voci correlate</h2><ul><li>Leggi in merito <a href=/docs/concepts/containers/images/>immagine di container</a></li><li>Leggi in merito <a href=/docs/concepts/workloads/pods/>Pods</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-16042b4652ad19e565c7263824029a43>3.3.1 - Immagini</h1><p>L'immagine di un container rappresenta dati binari che incapsulano un'applicazione e
tutte le sue dipendenze software. Le immagini sono costituite da pacchetti software
eseguibili che possono essere avviati in modalità standalone e su cui si possono fare
ipotesi ben precise circa l'ambiente in cui vengono eseguiti.</p><p>Tipicamente viene creata un'immagine di un'applicazione ed effettuato il <em>push</em>
su un registry (un repository pubblico di immagini) prima di poterne fare riferimento esplicito in un
<a class=glossary-tooltip title='Un Pod rappresenta un gruppo di container nel tuo cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a></p><p>Questa pagina va a delineare nello specifico il concetto di immagine di un container.</p><h2 id=i-nomi-delle-immagini>I nomi delle immagini</h2><p>Alle immagini dei container vengono normalmente attribuiti nomi come <code>pause</code>, <code>example/mycontainer</code>, o <code>kube-apiserver</code>.
Le immagini possono anche contenere l'hostname del registry in cui le immagini sono pubblicate;
ad esempio: <code>registro.fittizio.esempio/nomeimmagine</code>,
ed è possibile che sia incluso nel nome anche il numero della porta; ad esempio: <code>registro.fittizio.esempio:10443/nomeimmagine</code>.</p><p>Se non si specifica l'hostname di un registry, Kubernetes assume che ci si riferisca al registry pubblico di Docker.</p><p>Dopo la parte relativa al nome dell'immagine si può aggiungere un <em>tag</em> (come comunemente avviene per comandi come <code>docker</code> e <code>podman</code>).
I tag permettono l'identificazione di differenti versioni della stessa serie di immagini.</p><p>I tag delle immagini sono composti da lettere minuscole e maiuscole, numeri, underscore (<code>_</code>),
punti (<code>.</code>), e trattini (<code>-</code>).<br>Esistono regole aggiuntive relative a dove i caratteri separatori (<code>_</code>, <code>-</code>, and <code>.</code>)
possano essere inseriti nel tag di un'immagine.
Se non si specifica un tag, Kubernetes assume il tag <code>latest</code> che va a definire l'immagine disponibile più recente.</p><div class="alert alert-warning caution callout" role=alert><strong>Attenzione:</strong><p>Evitate di utilizzare il tag <code>latest</code> quando si rilasciano dei container in produzione,
in quanto risulta difficile tracciare quale versione dell'immagine sia stata avviata e persino più difficile
effettuare un rollback ad una versione precente.</p><p>Invece, meglio specificare un tag specifico come ad esempio <code>v1.42.0</code>.</p></div><h2 id=aggiornamento-delle-immagini>Aggiornamento delle immagini</h2><p>Quando un <a class=glossary-tooltip title='Gestisce una applicazione replicata nel tuo cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Deployment>Deployment</a>,
<a class=glossary-tooltip title='Gestisce deployment e la scalabilità di un gruppo di Pod, con storage e identificativi persistenti per ogni Pod.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/statefulset/ target=_blank aria-label=StatefulSet>StatefulSet</a>, Pod, o qualsiasi altro
oggetto che includa un Pod template viene creato per la prima volta, la policy di default per il pull di tutti i container nel Pod
è impostata su <code>IfNotPresent</code> (se non presente) se non specificato diversamente.
Questa policy permette al
<a class=glossary-tooltip title='Un agente che è eseguito su ogni nodo del cluster. Si assicura che i container siano eseguiti in un pod.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a> di evitare di fare il pull
di un'immagine se questa è già presente.</p><p>Se necessario, si può forzare il pull in ogni occasione in uno dei seguenti modi:</p><ul><li>impostando <code>imagePullPolicy</code> (specifica per il pull delle immagini) del container su <code>Always</code> (sempre).</li><li>omettendo <code>imagePullPolicy</code> ed usando il tag <code>:latest</code> (più recente) per l'immagine da utilizzare;
Kubernetes imposterà la policy su <code>Always</code> (sempre).</li><li>omettendo <code>imagePullPolicy</code> ed il tag per l'immagine da utilizzare.</li><li>abilitando l'admission controller <a href=/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages>AlwaysPullImages</a>.</li></ul><div class="alert alert-info note callout" role=alert><strong>Nota:</strong><p>Il valore dell'impostazione <code>imagePullPolicy</code> del container è sempre presente quando l'oggetto viene creato per la prima volta
e non viene aggiornato se il tag dell'immagine dovesse cambiare successivamente.</p><p>Ad esempio, creando un Deployment con un'immagine il cui tag <em>non</em> è
<code>:latest</code>, e successivamente aggiornando il tag di quell'immagine a <code>:latest</code>, il campo
<code>imagePullPolicy</code> <em>non</em> cambierà su <code>Always</code>.
È necessario modificare manualmente la policy di pull di ogni oggetto dopo la sua creazione.</p></div><p>Quando <code>imagePullPolicy</code> è definito senza un valore specifico, esso è impostato su <code>Always</code>.</p><h2 id=multi-architecture-support-nelle-immagini>Multi-architecture support nelle immagini</h2><p>Oltre a fornire immagini binarie, un <em>container registry</em> può fornire un <a href=https://github.com/opencontainers/image-spec/blob/master/image-index.md>indice delle immagini disponibili per un container</a>.
L'indice di un'immagine può puntare a più <a href=https://github.com/opencontainers/image-spec/blob/master/manifest.md>file manifest</a> ciascuno per una versione specifica dell'architettura di un container.
L'idea è che si può avere un unico nome per una stessa immagine (ad esempio: <code>pause</code>, <code>example/mycontainer</code>, <code>kube-apiserver</code>) e permettere a diversi sistemi di recuperare l'immagine binaria corretta a seconda dell'architettura della macchina che la sta utilizzando.</p><p>Kubernetes stesso tipicamente nomina le immagini dei container tramite il suffisso <code>-$(ARCH)</code>.
Per la garantire la retrocompatibilità è meglio generare le vecchie immagini con dei suffissi.
L'idea è quella di generare, ad esempio, l'immagine <code>pause</code> con un manifest che include tutte le architetture supportate,
affiancata, ad esempio, da <code>pause-amd64</code> che è retrocompatibile per le vecchie configurazioni o per quei file YAML
in cui sono specificate le immagini con i suffissi.</p><h2 id=utilizzare-un-private-registry>Utilizzare un private registry</h2><p>I private registry possono richiedere l'utilizzo di chiavi per accedere alle immagini in essi contenute.<br>Le credenziali possono essere fornite in molti modi:</p><ul><li>configurando i nodi in modo tale da autenticarsi al private registry<ul><li>tutti i pod possono acquisire informazioni da qualsiasi private registry configurato</li><li>è necessario che l'amministratore del cluster configuri i nodi in tal senso</li></ul></li><li>tramite pre-pulled images (immagini pre-caricate sui nodi)<ul><li>tutti i pod possono accedere alle immagini salvate sulla cache del nodo a cui si riferiscono</li><li>è necessario effettuare l'accesso come root di sistema su ogni nodo per inserire questa impostazione</li></ul></li><li>specificando <em>ImagePullSecrets</em> su un determinato pod<ul><li>solo i pod che forniscono le proprie chiavi hanno la possibilità di accedere al private registry</li></ul></li><li>tramite estensioni locali o specifiche di un <em>Vendor</em><ul><li>se si sta utilizzando una configurazione personalizzata del nodo oppure se manualmente, o tramite il <em>cloud provider</em>,
si implementa un meccanismo di autenticazione del nodo presso il <em>container registry</em>.</li></ul></li></ul><p>Di seguito la spiegazione dettagliata di queste opzioni.</p><h3 id=configurazione-dei-nodi-per-l-autenticazione-ad-un-private-registry>Configurazione dei nodi per l'autenticazione ad un private registry</h3><p>Se si sta utilizzando Docker sui nodi, si può configurare il <em>Docker container runtime</em>
per autenticare il nodo presso un private container registry.</p><p>Questo è un approccio possibile se si ha il controllo sulle configurazioni del nodo.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Kubernetes di default supporta solo le sezioni <code>auths</code> e <code>HttpHeaders</code> nelle configurazioni relative a Docker.
Eventuali <em>helper</em> per le credenziali di Docker (<code>credHelpers</code> o <code>credsStore</code>) non sono supportati.</div><p>Docker salva le chiavi per i registri privati in <code>$HOME/.dockercfg</code> oppure nel file <code>$HOME/.docker/config.json</code>.
Inserendo lo stesso file nella lista seguente, kubelet lo utilizzerà per recuperare le credenziali quando deve fare il <em>pull</em> delle immagini.</p><ul><li><code>{--root-dir:-/var/lib/kubelet}/config.json</code></li><li><code>{cwd of kubelet}/config.json</code></li><li><code>${HOME}/.docker/config.json</code></li><li><code>/.docker/config.json</code></li><li><code>{--root-dir:-/var/lib/kubelet}/.dockercfg</code></li><li><code>{cwd of kubelet}/.dockercfg</code></li><li><code>${HOME}/.dockercfg</code></li><li><code>/.dockercfg</code></li></ul><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Potrebbe essere necessario impostare <code>HOME=/root</code> esplicitamente come variabile d'ambiente del processo <em>kubelet</em>.</div><p>Di seguito i passi consigliati per configurare l'utilizzo di un private registry da parte dei nodi del <em>cluster</em>.
In questo esempio, eseguire i seguenti comandi sul proprio desktop/laptop:</p><ol><li>Esegui <code>docker login [server]</code> per ogni <em>set</em> di credenziali che vuoi utilizzare. Questo comando aggiornerà <code>$HOME/.docker/config.json</code> sul tuo PC.</li><li>Controlla il file <code>$HOME/.docker/config.json</code> in un editor di testo per assicurarti che contenga le credenziali che tu voglia utilizzare.</li><li>Recupera la lista dei tuoi nodi; ad esempio:<ul><li>se vuoi utilizzare i nomi: <code>nodes=$( kubectl get nodes -o jsonpath='{range.items[*].metadata}{.name} {end}' )</code></li><li>se vuoi recuperare gli indirizzi IP: <code>nodes=$( kubectl get nodes -o jsonpath='{range .items[*].status.addresses[?(@.type=="ExternalIP")]}{.address} {end}' )</code></li></ul></li><li>Copia il tuo file locale <code>.docker/config.json</code> in uno dei path sopra riportati nella lista di ricerca.<ul><li>ad esempio, per testare il tutto: <code>for n in $nodes; do scp ~/.docker/config.json root@"$n":/var/lib/kubelet/config.json; done</code></li></ul></li></ol><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Per i cluster di produzione, utilizza un configuration management tool per poter applicare le impostazioni su tutti i nodi laddove necessario.</div><p>Puoi fare una verifica creando un Pod che faccia uso di un'immagine privata; ad esempio:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f - <span style=color:#b44>&lt;&lt;EOF
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: Pod
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: private-image-test-1
</span></span></span><span style=display:flex><span><span style=color:#b44>spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>  containers:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - name: uses-private-image
</span></span></span><span style=display:flex><span><span style=color:#b44>      image: $PRIVATE_IMAGE_NAME
</span></span></span><span style=display:flex><span><span style=color:#b44>      imagePullPolicy: Always
</span></span></span><span style=display:flex><span><span style=color:#b44>      command: [ &#34;echo&#34;, &#34;SUCCESS&#34; ]
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><pre tabindex=0><code>pod/private-image-test-1 created
</code></pre><p>Se tutto funziona correttamente, pochi istanti dopo, si può lanciare il comando:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl logs private-image-test-1
</span></span></code></pre></div><p>e verificare che il comando restituisca in output:</p><pre tabindex=0><code>SUCCESS
</code></pre><p>Qualora si sospetti che il comando sia fallito, si può eseguire:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe pods/private-image-test-1 | grep <span style=color:#b44>&#39;Failed&#39;</span>
</span></span></code></pre></div><p>In caso di fallimento, l'output sarà simile al seguente:</p><pre tabindex=0><code>  Fri, 26 Jun 2015 15:36:13 -0700    Fri, 26 Jun 2015 15:39:13 -0700    19    {kubelet node-i2hq}    spec.containers{uses-private-image}    failed        Failed to pull image &#34;user/privaterepo:v1&#34;: Error: image user/privaterepo:v1 not found
</code></pre><p>Bisogna assicurarsi che tutti i nodi nel cluster abbiano lo stesso file <code>.docker/config.json</code>.
Altrimenti i pod funzioneranno correttamente su alcuni nodi ma falliranno su altri.
Ad esempio, se si utilizza l'autoscaling per i nodi, il template di ogni istanza
devono includere il file <code>.docker/config.json</code> oppure montare un disco che lo contenga.</p><p>Tutti i pod avranno accesso in lettura alle immagini presenti nel private registry
una volta che le rispettive chiavi di accesso siano state aggiunte nel file <code>.docker/config.json</code>.</p><h3 id=immagini-pre-pulled>Immagini pre-pulled</h3><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Questo approccio è possibile se si ha il controllo sulla configurazione del nodo.
Non funzionerà qualora il cloud provider gestisca i nodi e li sostituisca automaticamente.</div><p>Kubelet di default prova a fare il pull di ogni immagine dal registry specificato.
Tuttavia, qualora la proprietà <code>imagePullPolicy</code> (specifica di pull dell'immagine) del container sia impostata su <code>IfNotPresent</code> (vale a dire, se non è già presente) oppure su <code>Never</code> (mai),
allora l'immagine locale è utilizzata (in via preferenziale o esclusiva, rispettivamente).</p><p>Se si vuole fare affidamento a immagini pre-scaricate per non dover incorrere in una fase di autenticazione presso il registry,
bisogna assicurarsi che tutti i nodi nel cluster abbiano scaricato le stesse versioni delle immagini.</p><p>Questa procedura può essere utilizzata per accelerare il processo di creazione delle istanze o come alternativa all'autenticazione presso un private registry.</p><p>Tutti i pod avranno accesso in lettura a qualsiasi immagine pre-scaricata.</p><h3 id=specificare-la-proprietà-imagepullsecrets-su-un-pod>Specificare la proprietà imagePullSecrets su un Pod</h3><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Questo approccio è quello consigliato per l'avvio di container a partire da immagini presenti in registri privati.</div><p>Kubernetes da la possibilità di specificare le chiavi del <em>container registry</em> su un Pod.</p><h4 id=creare-un-secret-tramite-docker-config>Creare un Secret tramite Docker config</h4><p>Esegui il comando seguente, sostituendo i valori riportati in maiuscolo con quelli corretti:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret docker-registry &lt;name&gt; --docker-server<span style=color:#666>=</span>DOCKER_REGISTRY_SERVER --docker-username<span style=color:#666>=</span>DOCKER_USER --docker-password<span style=color:#666>=</span>DOCKER_PASSWORD --docker-email<span style=color:#666>=</span>DOCKER_EMAIL
</span></span></code></pre></div><p>Se possiedi il file delle credenziali per Docker, anziché utilizzare il comando quì sopra
puoi importare il file di credenziali come un Kubernetes
<a class=glossary-tooltip title='Contiene informazioni sensibili, come passwords, token OAuth, e chiavi ssh.' data-toggle=tooltip data-placement=top href='/it/docs/reference/glossary/?all=true#term-secret' target=_blank aria-label=Secrets>Secrets</a>.<br><a href=/docs/tasks/configure-pod-container/pull-image-private-registry/#registry-secret-existing-credentials>Creare un Secret a partire da credenziali Docker</a> fornisce la spiegazione dettagliata su come fare.</p><p>Ciò è particolarmente utile se si utilizzano più <em>container registry</em> privati,
in quanto il comando <code>kubectl create secret docker-registry</code> genera un Secret che
funziona con un solo private registry.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> I Pod possono fare riferimento ai Secret per il pull delle immagini soltanto nel proprio <em>namespace</em>,
quindi questo procedimento deve essere svolto per ogni <em>namespace</em>.</div><h4 id=fare-riferimento-ad-imagepullsecrets-in-un-pod>Fare riferimento ad imagePullSecrets in un Pod</h4><p>È possibile creare pod che referenzino quel Secret aggiungendo la sezione <code>imagePullSecrets</code> alla definizione del Pod.</p><p>Ad esempio:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt; pod.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: Pod
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: foo
</span></span></span><span style=display:flex><span><span style=color:#b44>  namespace: awesomeapps
</span></span></span><span style=display:flex><span><span style=color:#b44>spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>  containers:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - name: foo
</span></span></span><span style=display:flex><span><span style=color:#b44>      image: janedoe/awesomeapp:v1
</span></span></span><span style=display:flex><span><span style=color:#b44>  imagePullSecrets:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - name: myregistrykey
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt;&gt; ./kustomization.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>resources:
</span></span></span><span style=display:flex><span><span style=color:#b44>- pod.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>Questo deve esser fatto per ogni Pod che utilizzi un private registry.</p><p>Comunque, le impostazioni relative a questo campo possono essere automatizzate inserendo la sezione <em>imagePullSecrets</em>
nella definizione della risorsa <a href=/docs/tasks/configure-pod-container/configure-service-account/>ServiceAccount</a>.</p><p>Visitare la pagina <a href=/docs/tasks/configure-pod-container/configure-service-account/#add-imagepullsecrets-to-a-service-account>Aggiungere ImagePullSecrets ad un Service Account</a> per istruzioni più dettagliate.</p><p>Puoi utilizzarlo in congiunzione al file <code>.docker/config.json</code> configurato per ogni nodo. In questo caso, si applicherà un <em>merge</em> delle credenziali.</p><h2 id=casi-d-uso>Casi d'uso</h2><p>Ci sono varie soluzioni per configurare i private registry. Di seguito, alcuni casi d'uso comuni e le soluzioni suggerite.</p><ol><li>Cluster in cui sono utilizzate soltanto immagini non proprietarie (ovvero <em>open-source</em>). In questo caso non sussiste il bisogno di nascondere le immagini.<ul><li>Utilizza immagini pubbliche da Docker hub.<ul><li>Nessuna configurazione richiesta.</li><li>Alcuni <em>cloud provider</em> mettono in <em>cache</em> o effettuano il <em>mirror</em> di immagini pubbliche, il che migliora la disponibilità delle immagini e ne riduce il tempo di <em>pull</em>.</li></ul></li></ul></li><li>Cluster con container avviati a partire da immagini proprietarie che dovrebbero essere nascoste a chi è esterno all'organizzazione, ma
visibili a tutti gli utenti abilitati nel cluster.<ul><li>Utilizza un private <a href=https://docs.docker.com/registry/>Docker registry</a>.<ul><li>Esso può essere ospitato da <a href=https://hub.docker.com/signup>Docker Hub</a>, o da qualche altra piattaforma.</li><li>Configura manualmente il file .docker/config.json su ogni nodo come descritto sopra.</li></ul></li><li>Oppure, avvia un private registry dietro il tuo firewall con accesso in lettura libero.<ul><li>Non è necessaria alcuna configurazione di Kubernetes.</li></ul></li><li>Utilizza un servizio di <em>container registry</em> che controlli l'accesso alle immagini<ul><li>Esso funzionerà meglio con una configurazione del cluster basata su <em>autoscaling</em> che con una configurazione manuale del nodo.</li></ul></li><li>Oppure, su un cluster dove la modifica delle configurazioni del nodo non è conveniente, utilizza <code>imagePullSecrets</code>.</li></ul></li><li>Cluster con immagini proprietarie, alcune delle quali richiedono un controllo sugli accessi.<ul><li>Assicurati che l'<em>admission controller</em> <a href=/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages>AlwaysPullImages</a> sia attivo. Altrimenti, tutti i Pod potenzialmente possono avere accesso a tutte le immagini.</li><li>Sposta i dati sensibili un un <em>Secret</em>, invece di inserirli in un'immagine.</li></ul></li><li>Un cluster multi-tenant dove ogni tenant necessiti di un private registry.<ul><li>Assicurati che l'<em>admission controller</em> <a href=/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages>AlwaysPullImages</a> sia attivo. Altrimenti, tutti i Pod di tutti i tenant potrebbero potenzialmente avere accesso a tutte le immagini.</li><li>Avvia un private registry che richieda un'autorizzazione all'accesso.</li><li>Genera delle credenziali di registry per ogni tenant, inseriscile in dei <em>Secret</em>, e popola i <em>Secret</em> per ogni <em>namespace</em> relativo ad ognuno dei tenant.</li><li>Il singolo tenant aggiunge così quel <em>Secret</em> all'impostazione <em>imagePullSecrets</em> di ogni <em>namespace</em>.</li></ul></li></ol><p>Se si ha la necessità di accedere a più registri, si può generare un <em>Secret</em> per ognuno di essi.
Kubelet farà il <em>merge</em> di ogni <code>imagePullSecrets</code> in un singolo file virtuale <code>.docker/config.json</code>.</p><h2 id=voci-correlate>Voci correlate</h2><ul><li>Leggi <a href=https://github.com/opencontainers/image-spec/blob/master/manifest.md>OCI Image Manifest Specification</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-643212488f778acf04bebed65ba34441>3.3.2 - Container Environment</h1><p>Questa pagina descrive le risorse disponibili nei Container eseguiti in Kubernetes.</p><h2 id=container-environment>Container environment</h2><p>Quando si esegue un Container in Kubernetes, le seguenti risorse sono rese disponibili:</p><ul><li>Un filesystem, composto dal file system dell'<a href=/docs/concepts/containers/images/>image</a> e da uno o più <a href=/docs/concepts/storage/volumes/>volumes</a>.</li><li>Una serie di informazioni sul Container stesso.</li><li>Una serie di informazioni sugli oggetti nel cluster.</li></ul><h3 id=informazioni-sul-container>Informazioni sul Container</h3><p>L' <em>hostname</em> di un Container è il nome del Pod all'interno del quale è eseguito il Container.
È consultabile tramite il comando <code>hostname</code> o tramite la funzione
<a href=http://man7.org/linux/man-pages/man2/gethostname.2.html><code>gethostname</code></a>
disponibile in libc.</p><p>Il nome del Pod e il namespace possono essere resi disponibili come environment variables attraverso l'uso
delle <a href=/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information/>downward API</a>.</p><p>Gli utenti possono aggiungere altre environment variables nella definizione del Pod; anche queste
saranno disponibili nel Container come tutte le altre environment variables definite staticamente nella
Docker image.</p><h3 id=informazioni-sul-cluster>Informazioni sul cluster</h3><p>Al momento della creazione del Container è generata una serie di environment variables con la lista di servizi in esecuzione nel cluster.
Queste environment variables rispettano la sintassi dei Docker links.</p><p>Per un servizio chiamato <em>foo</em> che è in esecuzione in un Container di nome <em>bar</em>,
le seguenti variabili sono generate:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#b8860b>FOO_SERVICE_HOST</span><span style=color:#666>=</span>&lt;host su cui il servizio è attivo&gt;
</span></span><span style=display:flex><span><span style=color:#b8860b>FOO_SERVICE_PORT</span><span style=color:#666>=</span>&lt;porta su cui il servizio è pubblicato&gt;
</span></span></code></pre></div><p>I servizi hanno un indirizzo IP dedicato e sono disponibili nei Container anche via DNS
se il <a href=http://releases.k8s.io/master/cluster/addons/dns/>DNS addon</a> è installato nel cluster.</p><h2 id=voci-correlate>Voci correlate</h2><ul><li>Approfondisci <a href=/docs/concepts/containers/container-lifecycle-hooks/>Container lifecycle hooks</a>.</li><li>Esegui un tutorial su come
<a href=/docs/tasks/configure-pod-container/attach-handler-lifecycle-event/>definire degli handlers per i Container lifecycle events</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-e6941d969d81540208a3e78bc56f43bc>3.3.3 - Container Lifecycle Hooks</h1><p>Questa pagina descrive come i Container gestiti con kubelet possono utilizzare il lifecycle
hook framework dei Container per l'esecuzione di codice eseguito in corrispondenza di alcuni
eventi durante il loro ciclo di vita.</p><h2 id=overview>Overview</h2><p>Analogamente a molti framework di linguaggi di programmazione che hanno degli hooks legati al ciclo di
vita dei componenti, come ad esempio Angular, Kubernetes fornisce ai Container degli hook legati al loro ciclo di
vita dei Container.
Gli hook consentono ai Container di essere consapevoli degli eventi durante il loro ciclo di
gestione ed eseguire del codice implementato in un handler quando il corrispondente hook viene
eseguito.</p><h2 id=container-hooks>Container hooks</h2><p>Esistono due tipi di hook che vengono esposti ai Container:</p><p><code>PostStart</code></p><p>Questo hook viene eseguito successivamente alla creazione del container.
Tuttavia, non vi è garanzia che questo hook venga eseguito prima dell'ENTRYPOINT del container.
Non vengono passati parametri all'handler.</p><p><code>PreStop</code></p><p>Questo hook viene eseguito prima della terminazione di un container a causa di una richiesta API o
di un evento di gestione, come ad esempio un fallimento delle sonde di liveness/startup, preemption,
risorse contese e altro. Una chiamata all'hook di <code>PreStop</code> fallisce se il container è in stato
terminated o completed e l'hook deve finire prima che possa essere inviato il segnale di TERM per
fermare il container. Il conto alla rovescia per la terminazione del Pod (grace period) inizia prima dell'esecuzione
dell'hook <code>PreStop</code>, quindi indipendentemente dall'esito dell'handler, il container terminerà entro
il grace period impostato. Non vengono passati parametri all'handler.</p><p>Una descrizione più dettagliata riguardante al processo di terminazione dei Pod può essere trovata in
<a href=/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination>Terminazione dei Pod</a>.</p><h3 id=implementazione-degli-hook-handler>Implementazione degli hook handler</h3><p>I Container possono accedere a un hook implementando e registrando un handler per tale hook.
Ci sono due tipi di handler che possono essere implementati per i Container:</p><ul><li>Exec - Esegue un comando specifico, tipo <code>pre-stop.sh</code>, all'interno dei cgroup e namespace del Container.
Le risorse consumate dal comando vengono contate sul Container.</li><li>HTTP - Esegue una richiesta HTTP verso un endpoint specifico del Container.</li></ul><h3 id=esecuzione-dell-hook-handler>Esecuzione dell'hook handler</h3><p>Quando viene richiamato l'hook legato al lifecycle del Container, il sistema di gestione di Kubernetes
esegue l'handler secondo l'azione dell'hook, <code>httpGet</code> e <code>tcpSocket</code> vengono eseguiti dal processo kubelet,
mentre <code>exec</code> è eseguito nel Container.</p><p>Le chiamate agli handler degli hook sono sincrone rispetto al contesto del Pod che contiene il Container.
Questo significa che per un hook <code>PostStart</code>, l'ENTRYPOINT e l'hook si attivano in modo asincrono.
Tuttavia, se l'hook impiega troppo tempo per essere eseguito o si blocca, il container non può raggiungere lo
stato di <code>running</code>.</p><p>Gli hook di <code>PreStop</code> non vengono eseguiti in modo asincrono dall'evento di stop del container; l'hook
deve completare la sua esecuzione prima che l'evento TERM possa essere inviato. Se un hook di <code>PreStop</code>
si blocca durante la sua esecuzione, la fase del Pod rimarrà <code>Terminating</code> finchè il Pod non sarà rimosso forzatamente
dopo la scadenza del suo <code>terminationGracePeriodSeconds</code>. Questo grace period si applica al tempo totale
necessario per effettuare sia l'esecuzione dell'hook di <code>PreStop</code> che per l'arresto normale del container.
Se, per esempio, il <code>terminationGracePeriodSeconds</code> è di 60, e l'hook impiega 55 secondi per essere completato,
e il container impiega 10 secondi per fermarsi normalmente dopo aver ricevuto il segnale, allora il container
verrà terminato prima di poter completare il suo arresto, poiché <code>terminationGracePeriodSeconds</code> è inferiore al tempo
totale (55+10) necessario perché queste due cose accadano.</p><p>Se un hook <code>PostStart</code> o <code>PreStop</code> fallisce, allora il container viene terminato.</p><p>Gli utenti dovrebbero mantenere i loro handler degli hook i più leggeri possibili.
Ci sono casi, tuttavia, in cui i comandi di lunga durata hanno senso,
come il salvataggio dello stato del container prima della sua fine.</p><h3 id=garanzia-della-chiamata-dell-hook>Garanzia della chiamata dell'hook</h3><p>La chiamata degli hook avviene <em>almeno una volta</em>, il che significa
che un hook può essere chiamato più volte da un dato evento, come per <code>PostStart</code>
o <code>PreStop</code>.
Sta all'implementazione dell'hook gestire correttamente questo aspetto.</p><p>Generalmente, vengono effettuate singole chiamate agli hook.
Se, per esempio, la destinazione di hook HTTP non è momentaneamente in grado di ricevere traffico,
non c'è alcun tentativo di re invio.
In alcuni rari casi, tuttavia, può verificarsi una doppia chiamata.
Per esempio, se un kubelet si riavvia nel mentre dell'invio di un hook, questo potrebbe essere
chiamato per una seconda volta dopo che il kubelet è tornato in funzione.</p><h3 id=debugging-hook-handlers>Debugging Hook handlers</h3><p>I log di un handler di hook non sono esposti negli eventi del Pod.
Se un handler fallisce per qualche ragione, trasmette un evento.
Per il <code>PostStart</code>, questo è l'evento di <code>FailedPostStartHook</code>,
e per il <code>PreStop</code>, questo è l'evento di <code>FailedPreStopHook</code>.
Puoi vedere questi eventi eseguendo <code>kubectl describe pod &lt;pod_name></code>.
Ecco alcuni esempi di output di eventi dall'esecuzione di questo comando:</p><pre tabindex=0><code>Events:
  FirstSeen  LastSeen  Count  From                                                   SubObjectPath          Type      Reason               Message
  ---------  --------  -----  ----                                                   -------------          --------  ------               -------
  1m         1m        1      {default-scheduler }                                                          Normal    Scheduled            Successfully assigned test-1730497541-cq1d2 to gke-test-cluster-default-pool-a07e5d30-siqd
  1m         1m        1      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}  spec.containers{main}  Normal    Pulling              pulling image &#34;test:1.0&#34;
  1m         1m        1      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}  spec.containers{main}  Normal    Created              Created container with docker id 5c6a256a2567; Security:[seccomp=unconfined]
  1m         1m        1      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}  spec.containers{main}  Normal    Pulled               Successfully pulled image &#34;test:1.0&#34;
  1m         1m        1      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}  spec.containers{main}  Normal    Started              Started container with docker id 5c6a256a2567
  38s        38s       1      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}  spec.containers{main}  Normal    Killing              Killing container with docker id 5c6a256a2567: PostStart handler: Error executing in Docker Container: 1
  37s        37s       1      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}  spec.containers{main}  Normal    Killing              Killing container with docker id 8df9fdfd7054: PostStart handler: Error executing in Docker Container: 1
  38s        37s       2      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}                         Warning   FailedSync           Error syncing pod, skipping: failed to &#34;StartContainer&#34; for &#34;main&#34; with RunContainerError: &#34;PostStart handler: Error executing in Docker Container: 1&#34;
  1m         22s       2      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}  spec.containers{main}  Warning   FailedPostStartHook
</code></pre><h2 id=voci-correlate>Voci correlate</h2><ul><li>Approfondisci <a href=/docs/concepts/containers/container-environment/>Container environment</a>.</li><li>Esegui un tutorial su come
<a href=/docs/tasks/configure-pod-container/attach-handler-lifecycle-event/>definire degli handlers per i Container lifecycle events</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-275bea454e1cf4c5adeca4058b5af988>3.4 - Configurazione</h1><div class=lead>Risorse che fornisce Kubernetes per configurare i Pods.</div></div><div class=td-content><h1 id=pg-6b5ccadd699df0904e8e9917c5450c4b>3.4.1 - ConfigMaps</h1><p><p>La ConfigMap è un oggetto API usato per memorizzare dati non riservati in coppie chiave-valore. I <a class=glossary-tooltip title='Un Pod rappresenta un gruppo di container nel tuo cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pods>Pods</a> possono utilizzare le ConfigMaps come variabili d'ambiente, argomenti da riga di comando, o come files di configurazione all'interno di un <a class=glossary-tooltip title="Una cartella contenente dati, accessibile dai containers all'interno del pod." data-toggle=tooltip data-placement=top href=/it/docs/concepts/storage/volumes/ target=_blank aria-label=Volume>Volume</a>.</p></p><p>La ConfigMap ti permette di disaccoppiare le configurazioni specifiche per ambiente dalle <a class=glossary-tooltip title="Istanza archiviata di un cointainer che contiene un insieme di software e librerie necessarie per eseguire l'applicazione." data-toggle=tooltip data-placement=top href='/it/docs/reference/glossary/?all=true#term-image' target=_blank aria-label='immagini del container'>immagini del container</a>, cosicchè le tue applicazioni siano facilmente portabili.</p><div class="alert alert-warning caution callout" role=alert><strong>Attenzione:</strong> La ConfigMap non fornisce riservatezza o cifratura dei dati. Se i dati che vuoi salvare sono confidenziali, usa un <a class=glossary-tooltip title='Contiene informazioni sensibili, come passwords, token OAuth, e chiavi ssh.' data-toggle=tooltip data-placement=top href='/it/docs/reference/glossary/?all=true#term-secret' target=_blank aria-label=Secret>Secret</a> piuttosto che una ConfigMap, o usa uno strumento di terze parti per tenere privati i tuoi dati.</div><h2 id=utilizzo>Utilizzo</h2><p>Usa una ConfigMap per tenere separati i dati di configurazione dal codice applicativo.</p><p>Per esempio, immagina che stai sviluppando un'applicazione che puoi eseguire sul tuo computer (per lo sviluppo) e sul cloud (per gestire il traffico reale). Puoi scrivere il codice puntando a una variabile d'ambiente chiamata <code>DATABASE_HOST</code>. Localmente, puoi settare quella variabile a <code>localhost</code>. Nel cloud, la puoi settare referenziando il <a class=glossary-tooltip title='A way to expose an application running on a set of Pods as a network service.' data-toggle=tooltip data-placement=top href=/docs/concepts/services-networking/service/ target=_blank aria-label=Service>Service</a> di Kubernetes che espone la componente del database sul tuo cluster. Ciò ti permette di andare a recuperare l'immagine del container eseguita nel cloud e fare il debug dello stesso codice localmente se necessario.</p><p>La ConfigMap non è pensata per sostenere una gran mole di dati. I dati memorizzati su una ConfigMap non possono superare 1 MiB. Se hai bisogno di memorizzare delle configurazioni che superano questo limite, puoi considerare di montare un volume oppure usare un database o un file service separato.</p><h2 id=oggetto-configmap>Oggetto ConfigMap</h2><p>La ConfigMap è un <a href=/docs/concepts/overview/working-with-objects/kubernetes-objects/>oggetto</a> API che ti permette di salvare configurazioni per poi poter essere riutilizzate da altri oggetti. A differenza di molti oggetti di Kubernetes che hanno una <code>spec</code>, la ConfigMap ha i campi <code>data</code> e <code>binaryData</code>. Questi campi accettano le coppie chiave-valore come valori. Entrambi i campi <code>data</code> e <code>binaryData</code> sono opzionali. Il campo <code>data</code> è pensato per contenere le stringhe UTF-8 mentre il campo <code>binaryData</code> è pensato per contenere dati binari come le stringhe codificate in base64.</p><p>Il nome di una ConfigMap deve essere un nome valido per un sottodominio DNS.</p><p>Ogni chiave sotto il campo <code>data</code> o <code>binaryData</code> deve consistere di caratteri alfanumerici, <code>-</code>, <code>_</code> o <code>.</code>. Le chiavi salvate sotto <code>data</code> non devono coincidere con le chiavi nel campo <code>binaryData</code>.</p><p>Partendo dalla versione 1.19, puoi aggiungere il campo <code>immutable</code> alla definizione di ConfigMap per creare una <a href=#configmap-immutable>ConfigMap immutabile</a>.</p><h2 id=configmaps-e-pods>ConfigMaps e Pods</h2><p>Puoi scrivere una <code>spec</code> del Pod che si riferisce a una ConfigMap e configurare il o i containers
in quel Pod sulla base dei dati presenti nella ConfigMap. Il Pod e la ConfigMap devono essere nello
stesso Namespace.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> La <code>spec</code> di un <a class=glossary-tooltip title='A pod managed directly by the kubelet daemon on a specific node.' data-toggle=tooltip data-placement=top href=/docs/tasks/configure-pod-container/static-pod/ target=_blank aria-label='Pod statico'>Pod statico</a> non può riferirsi a una ConfigMap
o ad altri oggetti API.</div><p>Questo è un esempio di una ConfigMap che ha alcune chiavi con valori semplici,
e altre chiavi dove il valore ha il formato di un frammento di configurazione.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>game-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># chiavi simili a proprietà; ogni chiave mappa un valore semplice</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>player_initial_lives</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;3&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ui_properties_file_name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;user-interface.properties&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># chiavi simili a files</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>game.properties</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    enemy.types=aliens,monsters
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    player.maximum-lives=5</span><span style=color:#bbb>    
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>user-interface.properties</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    color.good=purple
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    color.bad=yellow
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    allow.textmode=true</span><span style=color:#bbb>    
</span></span></span></code></pre></div><p>Ci sono quattro modi differenti con cui puoi usare una ConfigMap per configurare
un container all'interno di un Pod:</p><ol><li>Argomento da riga di comando come entrypoint di un container</li><li>Variabile d'ambiente di un container</li><li>Aggiungere un file in un volume di sola lettura, per fare in modo che l'applicazione lo legga</li><li>Scrivere il codice da eseguire all'interno del Pod che utilizza l'API di Kubernetes per leggere la ConfigMap</li></ol><p>Questi metodologie differenti permettono di utilizzare diversi metodi per modellare i dati che saranno consumati.
Per i primi tre metodi, il
<a class=glossary-tooltip title='Un agente che è eseguito su ogni nodo del cluster. Si assicura che i container siano eseguiti in un pod.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a> utilizza i dati della
ConfigMap quando lancia il container (o più) in un Pod.</p><p>Per il quarto metodo dovrai scrivere il codice per leggere la ConfigMap e i suoi dati.
Comunque, poiché stai utilizzando l'API di Kubernetes direttamente, la tua applicazione può
sottoscriversi per ottenere aggiornamenti ogniqualvolta la ConfigMap cambia, e reagire
quando ciò accade. Accedendo direttamente all'API di Kubernetes, questa
tecnica ti permette anche di accedere a una ConfigMap in namespace differenti.</p><p>Ecco un esempio di Pod che usa i valori da <code>game-demo</code> per configurare il container:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>configmap-demo-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>alpine<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;sleep&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;3600&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># Definire la variabile d&#39;ambiente</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>PLAYER_INITIAL_LIVES<span style=color:#bbb> </span><span style=color:#080;font-style:italic># Notare che il case qui è differente</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                                     </span><span style=color:#080;font-style:italic># dal nome della key nella ConfigMap.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>configMapKeyRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>game-demo          <span style=color:#bbb> </span><span style=color:#080;font-style:italic># La ConfigMap da cui proviene il valore.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>player_initial_lives<span style=color:#bbb> </span><span style=color:#080;font-style:italic># La chiave da recuperare.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>UI_PROPERTIES_FILE_NAME<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>configMapKeyRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>game-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>ui_properties_file_name<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/config&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># Settare i volumi al livello del Pod, in seguito montarli nei containers all&#39;interno del Pod</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>configMap</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># Fornire il nome della ConfigMap che vuoi montare.</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>game-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># Una lista di chiavi dalla ConfigMap per essere creata come file</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;game.properties&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;game.properties&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;user-interface.properties&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;user-interface.properties&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Una ConfigMap non differenzia tra le proprietà di una singola linea e un file con più linee e valori.
L'importante è il modo in cui i Pods e gli altri oggetti consumano questi valori.</p><p>Per questo esempio, definire un volume e montarlo all'interno del container <code>demo</code> come <code>/config</code> crea
due files,
<code>/config/game.properties</code> e <code>/config/user-interface.properties</code>,
sebbene ci siano quattro chiavi nella ConfigMap. Ciò avviene perché la definizione del Pod
specifica una lista di <code>items</code> nella sezione dei <code>volumes</code>.
Se ometti del tutto la lista degli <code>items</code>, ogni chiave nella ConfigMap diventerà
un file con lo stesso nome della chiave, e otterrai 4 files.</p><h2 id=usare-le-configmaps>Usare le ConfigMaps</h2><p>Le ConfigMaps possono essere montate come volumi. Le ConfigMaps possono anche essere utilizzate da
altre parti del sistema, senza essere direttamente esposte al Pod. Per esempio, le
ConfigMaps possono contenere l'informazione che altre parti del sistema utilizzeranno per la loro
configurazione.</p><p>La maniera più comune per usare le ConfigMaps è di configurare i containers che sono in esecuzione
in un Pod nello stesso namespace. Puoi anche utilizzare una ConfigMap separatamente.</p><p>Per esempio, potresti incontrare
<a class=glossary-tooltip title='Resources that extend the functionality of Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/concepts/cluster-administration/addons/ target=_blank aria-label=addons>addons</a>
o <a class=glossary-tooltip title='A specialized controller used to manage a custom resource' data-toggle=tooltip data-placement=top href=/docs/concepts/extend-kubernetes/operator/ target=_blank aria-label=operators>operators</a> che
adattano il loro comportamento in base a una ConfigMap.</p><h3 id=usare-le-configmaps-come-files-in-un-pod>Usare le ConfigMaps come files in un Pod</h3><p>Per utilizzare una ConfigMap in un volume all'interno di un Pod:</p><ol><li>Creare una ConfigMap o usarne una che già esiste. Più Pods possono utilizzare
la stessa ConfigMap.</li><li>Modificare la definizione del Pod per aggiungere un volume sotto <code>.spec.volumes[]</code>. Nominare
il volume in qualsiasi modo, e avere un campo <code>.spec.volumes[].configMap.name</code> configurato per
referenziare il tuo oggetto ConfigMap.</li><li>Aggiungere un <code>.spec.containers[].volumeMounts[]</code> a ogni container che necessiti di una
ConfigMap. Nello specifico <code>.spec.containers[].volumeMounts[].readOnly = true</code> e
<code>.spec.containers[].volumeMounts[].mountPath</code> in una cartella inutilizzata
dove vorresti che apparisse la ConfigMap.</li><li>Modificare l'immagine o il comando utilizzato così che il programma cerchi i files in
quella cartella. Ogni chiave nella sezione <code>data</code> della ConfigMap si converte in un file
sotto <code>mountPath</code>.</li></ol><p>Questo è un esempio di un Pod che monta una ConfigMap in un volume:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/foo&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>configMap</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myconfigmap<span style=color:#bbb>
</span></span></span></code></pre></div><p>Ogni ConfigMap che desideri utilizzare deve essere referenziata in <code>.spec.volumes</code>.</p><p>Se c'è più di un container nel Pod, allora ogni container necessita del suo
blocco <code>volumeMounts</code>, ma solamente un <code>.spec.volumes</code> è necessario ConfigMap.</p><h4 id=le-configmaps-montate-sono-aggiornate-automaticamente>Le ConfigMaps montate sono aggiornate automaticamente</h4><p>Quando una ConfigMap è utilizzata in un volume ed è aggiornata, anche le chiavi vengono aggiornate.
Il kubelet controlla se la ConfigMap montata è aggiornata ad ogni periodo di sincronizzazione.
Ad ogni modo, il kubelet usa la sua cache locale per ottenere il valore attuale della ConfigMap.
Il tipo di cache è configurabile usando il campo <code>ConfigMapAndSecretChangeDetectionStrategy</code> nel <a href=/docs/reference/config-api/kubelet-config.v1beta1/>KubeletConfiguration struct</a>.
Una ConfigMap può essere propagata per vista (default), ttl-based, o redirigendo
tutte le richieste direttamente all'API server.
Come risultato, il ritardo totale dal momento in cui la ConfigMap è aggiornata al momento in cui nuove chiavi sono propagate al Pod può essere tanto lungo quanto il periodo della sincronizzazione del kubelet + il ritardo della propagazione della cache, dove il ritardo della propagazione della cache dipende dal tipo di cache scelta
(è uguale rispettivamente al ritardo della propagazione, ttl della cache, o zero).</p><p>Le ConfigMaps consumate come variabili d'ambiente non sono aggiornate automaticamente e necessitano di un riavvio del pod.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Un container utilizzando una ConfigMap come un <a href=/docs/concepts/storage/volumes#using-subpath>subPath</a> volume mount non riceverà gli aggiornamenti della ConfigMap.</div><h2 id=configmap-immutable>ConfigMaps Immutabili</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.21 [stable]</code></div><p>La funzionalità di Kubernetes <em>Immutable Secrets and ConfigMaps</em> fornisce un'opzione per
configurare Secrets individuali e ConfigMaps come immutabili. Per clusters che usano le ConfigMaps come estensione (almeno decine o centinaia di ConfigMap uniche montate nel Pod), prevenire i cambiamenti nei loro dati ha i seguenti vantaggi:</p><ul><li>protezione da aggiornamenti accidentali (o non voluti) che potrebbero causare l'interruzione di applicazioni</li><li>miglioramento della performance del tuo cluster riducendo significativamente il carico sul kube-apiserver, chiudendo l'ascolto sulle ConfigMaps che sono segnate come immutabili.</li></ul><p>Questa funzionalità è controllata dal <code>ImmutableEphemeralVolumes</code>
<a href=/docs/reference/command-line-tools-reference/feature-gates/>feature gate</a>.
Puoi creare una ConfigMap immutabile settando il campo <code>immutable</code> a <code>true</code>.
Per esempio:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>immutable</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Una volta che una ConfigMap è segnata come immutabile, <em>non</em> è possibile invertire questo cambiamento né cambiare il contenuto del campo <code>data</code> o <code>binaryData</code> field. Puoi solamente cancellare e ricreare la ConfigMap. Poiché i Pods hanno un puntamento verso la ConfigMap eliminata, è raccomandato di ricreare quei Pods.</p><h2 id=voci-correlate>Voci correlate</h2><ul><li>Leggi in merito <a href=/docs/concepts/configuration/secret/>Secrets</a>.</li><li>Leggi <a href=/docs/tasks/configure-pod-container/configure-pod-configmap/>Configura un Pod per utilizzare una ConfigMap</a>.</li><li>Leggi in merito <a href=/docs/tasks/manage-kubernetes-objects/update-api-object-kubectl-patch/>Modificare una ConfigMap (o qualsiasi altro oggetto di Kubernetes)</a></li><li>Leggi <a href=https://12factor.net/>The Twelve-Factor App</a> per comprendere il motivo di separare
il codice dalla configurazione.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-285a3785fd3d20f437c28d87ca4dadca>3.5 - Amministrazione del Cluster</h1></div><div class=td-content><h1 id=pg-08e94e6a480e0d6b2de72d84a1b97617>3.5.1 - Proxy in Kubernetes</h1><p>Questa pagina spiega i proxy utilizzati con Kubernetes.</p><h2 id=proxy>Proxy</h2><p>Esistono diversi proxy che puoi incontrare quando usi Kubernetes:</p><ol><li>Il <a href=/docs/tasks/access-application-cluster/access-cluster/#direct-accessing-the-rest-api>kubectl proxy</a>:</li></ol><p>    - viene eseguito sul computer di un utente o in un pod
    - collega un localhost address all'apiserver di Kubernetes
    - il client comunica con il proxy in HTTP
    - il proxy comunica con l'apiserver in HTTPS
    - individua l'apiserver
    - aggiunge gli header di autenticazione</p><ol><li>L'<a href=/docs/tasks/access-application-cluster/access-cluster-services/#discovering-builtin-services>apiserver proxy</a>:</li></ol><p>    - è un proxy presente nell'apiserver
    - collega un utente al di fuori del cluster agli IP del cluster che altrimenti potrebbero non essere raggiungibili
    - è uno dei processi dell'apiserver
    - il client comunica con il proxy in HTTPS (o HTTP se l'apiserver è configurato in tal modo)
    - il proxy comunica con il target via HTTP o HTTPS come scelto dal proxy utilizzando le informazioni disponibili
    - può essere utilizzato per raggiungere un nodo, un pod o un servizio
    - esegue il bilanciamento del carico quando viene utilizzato per raggiungere un servizio</p><ol><li>Il <a href=/docs/concepts/services-networking/service/#ips-and-vips>kube proxy</a>:</li></ol><p>    - è eseguito su ciascun nodo
    - fa da proxy per comunicazioni UDP, TCP e SCTP
    - non gestisce il protocollo HTTP
    - esegue il bilanciamento del carico
    - è usato solo per raggiungere i servizi</p><ol><li>Un proxy/bilanciatore di carico di fronte agli apiserver:</li></ol><p>    - la sua esistenza e implementazione variano da cluster a cluster (ad esempio nginx)
    - si trova tra i client e uno o più apiserver
    - funge da bilanciatore di carico se ci sono più di un apiserver.</p><ol><li>Cloud Load Balancer su servizi esterni:</li></ol><p>    - sono forniti da alcuni fornitori di servizi cloud (ad es. AWS ELB, Google Cloud Load Balancer)
    - vengono creati automaticamente quando il servizio Kubernetes ha tipo <code>LoadBalancer</code>
    - solitamente supporta solo UDP / TCP
    - il supporto SCTP dipende dall'implementazione del bilanciatore di carico del provider cloud
    - l'implementazione varia a seconda del provider cloud.</p><p>Gli utenti di Kubernetes in genere non devono preoccuparsi alcun proxy, se non i primi due tipi. L'amministratore del cluster
in genere assicurerà che gli altri tipi di proxy siano impostati correttamente.</p><h2 id=richiedere-reindirizzamenti>Richiedere reindirizzamenti</h2><p>I proxy hanno sostituito le funzioni di reindirizzamento. I reindirizzamenti sono stati deprecati.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-4c31edff4063c7b31c556b3eb1405c65>3.6 - Esempio di modello di concetto</h1><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Assicurati anche di <a href=/docs/home/contribute/write-new-topic/#creating-an-entry-in-the-table-of-contents>creare una voce nel sommario</a> per il tuo nuovo documento.</div><p>Questa pagina spiega ...</p><h2 id=comprendendo>Comprendendo ...</h2><p>Kubernetes fornisce ...</p><h2 id=usando>Usando ...</h2><p>Usare</p><h2 id=voci-correlate>Voci correlate</h2><p><strong>[Sezione opzionale]</strong></p><ul><li>Ulteriori informazioni su <a href=/docs/home/contribuisci/scrivi-nuovo-argomento/>Scrivere un nuovo argomento</a>.</li><li>Vedi <a href=/docs/home/contribuis/page-templates/#concept_template>Uso dei modelli di pagina - Modello di concetto</a> su come utilizzare questo modello.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-68ec2370d0409cc27325be36693f9368>4 - Tutorials</h1><p>Questa sezione della documentazione di Kubernetes contiene i tutorials.
Un tutorial mostra come raggiungere un obiettivo più complesso di un singolo
<a href=/docs/tasks/>task</a>. Solitamente un tutorial ha diverse sezioni, ognuna delle quali
consiste in una sequenza di più task.
Prima di procedere con vari tutorial, raccomandiamo di aggiungere il
<a href=/docs/reference/glossary/>Glossario</a> ai tuoi bookmark per riferimenti successivi.</p><h2 id=per-cominciare>Per cominciare</h2><ul><li><p><a href=/docs/tutorials/kubernetes-basics/>Kubernetes Basics</a> è un approfondito tutorial che aiuta a capire cosa è Kubernetes e che permette di testare in modo interattivo alcune semplici funzionalità di Kubernetes.</p></li><li><p><a href=https://www.edx.org/course/introduction-kubernetes-linuxfoundationx-lfs158x#>Introduction to Kubernetes (edX)</a></p></li><li><p><a href=/docs/tutorials/hello-minikube/>Hello Minikube</a></p></li></ul><h2 id=configurazione>Configurazione</h2><ul><li><a href=/docs/tutorials/configuration/configure-redis-using-configmap/>Configurare Redis utilizzando una ConfigMap</a></li></ul><h2 id=stateless-applications>Stateless Applications</h2><ul><li><p><a href=/docs/tutorials/stateless-application/expose-external-ip-address/>Esporre un External IP Address per permettere l'accesso alle applicazioni nel Cluster</a></p></li><li><p><a href=/docs/tutorials/stateless-application/guestbook/>Esempio: Rilasciare l'applicazione PHP Guestbook con Redis</a></p></li></ul><h2 id=stateful-applications>Stateful Applications</h2><ul><li><p><a href=/docs/tutorials/stateful-application/basic-stateful-set/>StatefulSet Basics</a></p></li><li><p><a href=/docs/tutorials/stateful-application/mysql-wordpress-persistent-volume/>Esempio: WordPress e MySQL con i PersistentVolumes</a></p></li><li><p><a href=/docs/tutorials/stateful-application/cassandra/>Esempio: Rilasciare Cassandra con i StatefulSets</a></p></li><li><p><a href=/docs/tutorials/stateful-application/zookeeper/>Eseguire ZooKeeper, un sistema distribuito CP</a></p></li></ul><h2 id=clusters>Clusters</h2><ul><li><p><a href=/docs/tutorials/clusters/apparmor/>AppArmor</a></p></li><li><p><a href=/docs/tutorials/clusters/seccomp/>seccomp</a></p></li></ul><h2 id=servizi>Servizi</h2><ul><li><a href=/docs/tutorials/services/source-ip/>Utilizzare Source IP</a></li></ul><h2 id=voci-correlate>Voci correlate</h2><p>Se sei interessato a scrivere un tutorial, vedi
<a href=/docs/home/contribute/page-templates/>Utilizzare i Page Templates</a>
per informazioni su come creare una tutorial page e sul tutorial template.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-5e3051fff9e84735871d9fb5e7b93f33>4.1 - Hello Minikube</h1><p>Questo tutorial mostra come eseguire una semplice applicazione in Kubernetes
utilizzando <a href=/docs/setup/learning-environment/minikube>Minikube</a> e Katacoda.
Katacoda permette di operare su un'installazione di Kubernetes dal tuo browser.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Come alternativa, è possibile eseguire questo tutorial <a href=/docs/tasks/tools/install-minikube/>installando minikube</a> localmente.</div><h2 id=obbiettivi>Obbiettivi</h2><ul><li>Rilasciare una semplice applicazione su Minikube.</li><li>Eseguire l'applicazione.</li><li>Visualizzare i log dell'applicazione.</li></ul><h2 id=prima-di-cominciare>Prima di cominciare</h2><p>Questo tutorial fornisce una container image che utilizza NGINX per risponde a tutte le richieste
con un echo che visualizza i dati della richiesta stessa.</p><h2 id=crea-un-minikube-cluster>Crea un Minikube cluster</h2><ol><li><p>Click <strong>Launch Terminal</strong></p><script defer src=https://katacoda.com/embed.js></script>
<button class=button onclick=window.katacoda.init()>Launch Terminal</button><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Se hai installato Minikube localmente, esegui <code>minikube start</code>.</div></li><li><p>Apri la console di Kubernetes nel browser:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>minikube dashboard
</span></span></code></pre></div></li><li><p>Katacoda environment only: In alto alla finestra del terminale, fai click segno più, e a seguire click su <strong>Select port to view on Host 1</strong>.</p></li><li><p>Katacoda environment only: Inserisci <code>30000</code>, a seguire click su <strong>Display Port</strong>.</p></li></ol><h2 id=crea-un-deployment>Crea un Deployment</h2><p>Un Kubernetes <a href=/docs/concepts/workloads/pods/pod/><em>Pod</em></a> è un gruppo di uno o più Containers,
che sono uniti tra loro dal punto di vista amministrativo e che condividono lo stesso network.<br>Il Pod in questo tutorial ha un solo Container. Un Kubernetes
<a href=/docs/concepts/workloads/controllers/deployment/><em>Deployment</em></a> monitora lo stato del Pod ed
eventualmente provvedere a farlo ripartire nel caso questo termini. L'uso dei Deployments è la
modalità raccomandata per gestire la creazione e lo scaling dei Pods.</p><ol><li><p>Usa il comando <code>kubectl create</code> per creare un Deployment che gestisce un singolo Pod. Il Pod
eseguirà un Container basato sulla Docker image specificata.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create deployment hello-node --image<span style=color:#666>=</span>k8s.gcr.io/echoserver:1.4
</span></span></code></pre></div></li><li><p>Visualizza il Deployment:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get deployments
</span></span></code></pre></div><p>L'output del comando è simile a:</p><pre tabindex=0><code>NAME         READY   UP-TO-DATE   AVAILABLE   AGE
hello-node   1/1     1            1           1m
</code></pre></li><li><p>Visualizza il Pod creato dal Deployment:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods
</span></span></code></pre></div><p>L'output del comando è simile a:</p><pre tabindex=0><code>NAME                          READY     STATUS    RESTARTS   AGE
hello-node-5f76cf6ccf-br9b5   1/1       Running   0          1m
</code></pre></li><li><p>Visualizza gli eventi del cluster Kubernetes:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get events
</span></span></code></pre></div></li><li><p>Visualizza la configurazione di <code>kubectl</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config view
</span></span></code></pre></div></li></ol><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Per maggiori informazioni sui comandi di <code>kubectl</code>, vedi <a href=/docs/user-guide/kubectl-overview/>kubectl overview</a>.</div><h2 id=crea-un-service>Crea un Service</h2><p>Con le impostazioni di default, un Pod è accessibile solamente dagli indirizzi IP interni
al Kubernetes cluster. Per far si che il Container <code>hello-node</code> sia accessibile dall'esterno
del Kubernetes virtual network, è necessario esporre il Pod utilizzando un
Kubernetes <a href=/docs/concepts/services-networking/service/><em>Service</em></a>.</p><ol><li><p>Esponi il Pod su internet untilizzando il comando <code>kubectl expose</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl expose deployment hello-node --type<span style=color:#666>=</span>LoadBalancer --port<span style=color:#666>=</span><span style=color:#666>8080</span>
</span></span></code></pre></div><p>Il flag <code>--type=LoadBalancer</code> indica la volontà di esporre il Service
all'esterno del Kubernetes cluster.</p></li><li><p>Visualizza il Servizio appena creato:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get services
</span></span></code></pre></div><p>L'output del comando è simile a:</p><pre tabindex=0><code>NAME         TYPE           CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE
hello-node   LoadBalancer   10.108.144.78   &lt;pending&gt;     8080:30369/TCP   21s
kubernetes   ClusterIP      10.96.0.1       &lt;none&gt;        443/TCP          23m
</code></pre><p>Nei cloud providers che supportano i servizi di tipo load balancers,
viene fornito un indirizzo IP pubblico per permettere l'acesso al Service. Su Minikube,
il service type <code>LoadBalancer</code> rende il Service accessibile attraverso il comando <code>minikube service</code>.</p></li><li><p>Esegui il comando:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>minikube service hello-node
</span></span></code></pre></div></li><li><p>Katacoda environment only: Fai click segno più, e a seguire click su <strong>Select port to view on Host 1</strong>.</p></li><li><p>Katacoda environment only: Fai attenzione al numero di 5 cifre visualizzato a fianco di <code>8080</code> nell'output del comando. Questo port number è generato casualmente e può essere diverso nel tuo caso. Inserisci il tuo port number nella textbox, e a seguire fai click su Display Port. Nell'esempio precedente, avresti scritto <code>30369</code>.</p><p>Questo apre un finestra nel browser dove l'applicazione visuallizza l'echo delle richieste ricevute.</p></li></ol><h2 id=attiva-gli-addons>Attiva gli addons</h2><p>Minikube include un set <a class=glossary-tooltip title='Resources that extend the functionality of Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/concepts/cluster-administration/addons/ target=_blank aria-label=addons>addons</a> che possono essere attivati, disattivati o eseguti nel ambiente Kubernetes locale.</p><ol><li><p>Elenca gli addons disponibili:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>minikube addons list
</span></span></code></pre></div><p>L'output del comando è simile a:</p><pre tabindex=0><code>addon-manager: enabled
dashboard: enabled
default-storageclass: enabled
efk: disabled
freshpod: disabled
gvisor: disabled
helm-tiller: disabled
ingress: disabled
ingress-dns: disabled
logviewer: disabled
metrics-server: disabled
nvidia-driver-installer: disabled
nvidia-gpu-device-plugin: disabled
registry: disabled
registry-creds: disabled
storage-provisioner: enabled
storage-provisioner-gluster: disabled
</code></pre></li><li><p>Attiva un addon, per esempio, <code>metrics-server</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>minikube addons <span style=color:#a2f>enable</span> metrics-server
</span></span></code></pre></div><p>L'output del comando è simile a:</p><pre tabindex=0><code>metrics-server was successfully enabled
</code></pre></li><li><p>Visualizza i Pods ed i Service creati in precedenza:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod,svc -n kube-system
</span></span></code></pre></div><p>L'output del comando è simile a:</p><pre tabindex=0><code>NAME                                        READY     STATUS    RESTARTS   AGE
pod/coredns-5644d7b6d9-mh9ll                1/1       Running   0          34m
pod/coredns-5644d7b6d9-pqd2t                1/1       Running   0          34m
pod/metrics-server-67fb648c5                1/1       Running   0          26s
pod/etcd-minikube                           1/1       Running   0          34m
pod/influxdb-grafana-b29w8                  2/2       Running   0          26s
pod/kube-addon-manager-minikube             1/1       Running   0          34m
pod/kube-apiserver-minikube                 1/1       Running   0          34m
pod/kube-controller-manager-minikube        1/1       Running   0          34m
pod/kube-proxy-rnlps                        1/1       Running   0          34m
pod/kube-scheduler-minikube                 1/1       Running   0          34m
pod/storage-provisioner                     1/1       Running   0          34m

NAME                           TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)             AGE
service/metrics-server         ClusterIP   10.96.241.45    &lt;none&gt;        80/TCP              26s
service/kube-dns               ClusterIP   10.96.0.10      &lt;none&gt;        53/UDP,53/TCP       34m
service/monitoring-grafana     NodePort    10.99.24.54     &lt;none&gt;        80:30002/TCP        26s
service/monitoring-influxdb    ClusterIP   10.111.169.94   &lt;none&gt;        8083/TCP,8086/TCP   26s
</code></pre></li><li><p>Disabilita <code>metrics-server</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>minikube addons disable metrics-server
</span></span></code></pre></div><p>L'output del comando è simile a:</p><pre tabindex=0><code>metrics-server was successfully disabled
</code></pre></li></ol><h2 id=clean-up>Clean up</h2><p>Adesso puoi procedere a fare clean up delle risorse che hai creato nel tuo cluster:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete service hello-node
</span></span><span style=display:flex><span>kubectl delete deployment hello-node
</span></span></code></pre></div><p>Eventualmente, puoi stoppare la Minikube virtual machine (VM):</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>minikube stop
</span></span></code></pre></div><p>Eventualmente, puoi cancellare la Minikube VM:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>minikube delete
</span></span></code></pre></div><h2 id=voci-correlate>Voci correlate</h2><ul><li>Approfondisci la tua conoscenza dei <a href=/docs/concepts/workloads/controllers/deployment/>Deployments</a>.</li><li>Approfondisci la tua conoscenza di <a href=/docs/tasks/run-application/run-stateless-application-deployment/>Rilasciare applicazioni</a>.</li><li>Approfondisci la tua conoscenza dei <a href=/docs/concepts/services-networking/service/>Services</a>.</li></ul></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/it/docs/home/>Home</a>
<a class=text-white href=/it/blog/>Blog</a>
<a class=text-white href=/it/training/>Formazione</a>
<a class=text-white href=/it/partners/>Partner</a>
<a class=text-white href=/it/community/>Community</a>
<a class=text-white href=/it/case-studies/>Casi di Studio</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 Gli autori di Kubernetes | Documentazione distribuita sotto <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small><br><small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. Tutti i diritti riservati. The Linux Foundation ha marchi registrati e utilizza marchi commerciali. Per un elenco dei marchi di Linux Foundation, consulta la <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>pagina sull'utilizzo dei marchi</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>