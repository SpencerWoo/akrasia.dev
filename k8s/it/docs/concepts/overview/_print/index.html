<!doctype html><html lang=it class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=en href=https://kubernetes.io/docs/concepts/overview/><link rel=alternate hreflang=zh-cn href=https://kubernetes.io/zh-cn/docs/concepts/overview/><link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/concepts/overview/><link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/concepts/overview/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/concepts/overview/><link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/concepts/overview/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/concepts/overview/><link rel=alternate hreflang=pt-br href=https://kubernetes.io/pt-br/docs/concepts/overview/><link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/concepts/overview/><link rel=alternate hreflang=vi href=https://kubernetes.io/vi/docs/concepts/overview/><link rel=alternate hreflang=ru href=https://kubernetes.io/ru/docs/concepts/overview/><link rel=alternate hreflang=pl href=https://kubernetes.io/pl/docs/concepts/overview/><link rel=alternate hreflang=uk href=https://kubernetes.io/uk/docs/concepts/overview/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/it/docs/concepts/overview/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>Overview | Kubernetes</title><meta property="og:title" content="Overview"><meta property="og:description" content="Orchestrazione di Container in produzione"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/it/docs/concepts/overview/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="Overview"><meta itemprop=description content="Orchestrazione di Container in produzione"><meta name=twitter:card content="summary"><meta name=twitter:title content="Overview"><meta name=twitter:description content="Orchestrazione di Container in produzione"><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content><meta property="og:description" content><meta name=twitter:description content><meta property="og:url" content="https://kubernetes.io/it/docs/concepts/overview/"><meta property="og:title" content="Overview"><meta name=twitter:title content="Overview"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/it/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/it/docs/>Documentazione</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/it/blog/>Blog di Kubernetes</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/it/training/>Formazione</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/it/partners/>Partner</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/it/community/>Community</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/it/case-studies/>Casi di Studio</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Versions</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/it/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/it/docs/concepts/overview/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/it/docs/concepts/overview/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/it/docs/concepts/overview/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/it/docs/concepts/overview/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/it/docs/concepts/overview/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Italiano (Italian)</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/docs/concepts/overview/>English</a>
<a class=dropdown-item href=/zh-cn/docs/concepts/overview/>中文 (Chinese)</a>
<a class=dropdown-item href=/ko/docs/concepts/overview/>한국어 (Korean)</a>
<a class=dropdown-item href=/ja/docs/concepts/overview/>日本語 (Japanese)</a>
<a class=dropdown-item href=/fr/docs/concepts/overview/>Français (French)</a>
<a class=dropdown-item href=/de/docs/concepts/overview/>Deutsch (German)</a>
<a class=dropdown-item href=/es/docs/concepts/overview/>Español (Spanish)</a>
<a class=dropdown-item href=/pt-br/docs/concepts/overview/>Português (Portuguese)</a>
<a class=dropdown-item href=/id/docs/concepts/overview/>Bahasa Indonesia</a>
<a class=dropdown-item href=/vi/docs/concepts/overview/>Tiếng Việt (Vietnamese)</a>
<a class=dropdown-item href=/ru/docs/concepts/overview/>Русский (Russian)</a>
<a class=dropdown-item href=/pl/docs/concepts/overview/>Polski (Polish)</a>
<a class=dropdown-item href=/uk/docs/concepts/overview/>Українська (Ukrainian)</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>This is the multi-page printable view of this section.
<a href=# onclick="return print(),!1">Click here to print</a>.</p><p><a href=/it/docs/concepts/overview/>Return to the regular view of this page</a>.</p></div><h1 class=title>Overview</h1><ul><li>1: <a href=#pg-45bdca6129cf540121623e903c18ba46>Cos'è Kubernetes?</a></li><li>2: <a href=#pg-13b0f1dbe89228e3d76d2ac231e245f1>I componenti di Kubernetes</a></li><li>3: <a href=#pg-0c745f42e623d2b70a53bc0e6db73d95>Le API di Kubernetes</a></li></ul><div class=content></div></div><div class=td-content><h1 id=pg-45bdca6129cf540121623e903c18ba46>1 - Cos'è Kubernetes?</h1><div class=lead>Kubernetes è una piattaforma portatile, estensibile e open-source per la gestione di carichi di lavoro e servizi containerizzati, in grado di facilitare sia la configurazione dichiarativa che l'automazione. La piattaforma vanta un grande ecosistema in rapida crescita. Servizi, supporto e strumenti sono ampiamente disponibili nel mondo Kubernetes .</div><p>Questa pagina è una panoramica generale su Kubernetes.</p><p>Kubernetes è una piattaforma portatile, estensibile e open-source per la gestione di carichi di lavoro e servizi containerizzati, in grado di facilitare sia la configurazione dichiarativa che l'automazione. La piattaforma vanta un grande ecosistema in rapida crescita. Servizi, supporto e strumenti sono ampiamente disponibili nel mondo Kubernetes .</p><p>Il nome Kubernetes deriva dal greco, significa timoniere o pilota. Google ha reso open-source il progetto Kubernetes nel 2014. Kubernetes unisce <a href=/blog/2015/04/borg-predecessor-to-kubernetes/>oltre quindici anni di esperienza di Google</a> nella gestione di carichi di lavoro di produzione su scala mondiale con le migliori idee e pratiche della comunità.</p><h2 id=facciamo-un-piccolo-salto-indietro>Facciamo un piccolo salto indietro</h2><p>Diamo un'occhiata alla ragione per cui Kubernetes è così utile facendo un piccolo salto indietro nel tempo.</p><p><img src=/images/docs/Container_Evolution.svg alt="Deployment evolution"></p><p><strong>L'era del deployment tradizionale:</strong>
All'inizio, le organizzazioni eseguivano applicazioni su server fisici. Non c'era modo di definire i limiti delle risorse per le applicazioni in un server fisico e questo ha causato non pochi problemi di allocazione delle risorse. Ad esempio, se più applicazioni vengono eseguite sullo stesso server fisico, si possono verificare casi in cui un'applicazione assorbe la maggior parte delle risorse e, di conseguenza, le altre applicazioni non hanno le prestazioni attese. Una soluzione per questo sarebbe di eseguire ogni applicazione su un server fisico diverso. Ma questa non è una soluzione ideale, dal momento che le risorse vengono sottoutilizzate, inoltre, questa pratica risulta essere costosa per le organizzazioni, le quali devono mantenere numerosi server fisici.</p><p><strong>L'era del deployment virtualizzato:</strong>
Come soluzione venne introdotta la virtualizzazione. Essa consente di eseguire più macchine virtuali (VM) su una singola CPU fisica. La virtualizzazione consente di isolare le applicazioni in più macchine virtuali e fornisce un livello di sicurezza superiore, dal momento che le informazioni di un'applicazione non sono liberamente accessibili da un'altra applicazione.</p><p>La virtualizzazione consente un migliore utilizzo delle risorse riducendo i costi per l'hardware, permette una migliore scalabilità, dato che un'applicazione può essere aggiunta o aggiornata facilmente, e ha molti altri vantaggi.</p><p>Ogni VM è una macchina completa che esegue tutti i componenti, compreso il proprio sistema operativo, sopra all'hardware virtualizzato.</p><p><strong>L'era del deployment in container:</strong>
I container sono simili alle macchine virtuali, ma presentano un modello di isolamento più leggero, condividendo il sistema operativo (OS) tra le applicazioni. Pertanto, i container sono considerati più leggeri. Analogamente a una macchina virtuale, un container dispone di una segregazione di filesystem, CPU, memoria, PID e altro ancora. Poiché sono disaccoppiati dall'infrastruttura sottostante, risultano portabili tra differenti cloud e diverse distribuzioni.</p><p>I container sono diventati popolari dal momento che offrono molteplici vantaggi, ad esempio:</p><ul><li>Creazione e distribuzione di applicazioni in modalità Agile: maggiore facilità ed efficienza nella creazione di immagini container rispetto all'uso di immagini VM.</li><li>Adozione di pratiche per lo sviluppo/test/rilascio continuativo: consente la frequente creazione e la distribuzione di container image affidabili, dando la possibilità di fare rollback rapidi e semplici (grazie all'immutabilità dell'immagine stessa).</li><li>Separazione delle fasi di Dev e Ops: le container image vengono prodotte al momento della compilazione dell'applicativo piuttosto che nel momento del rilascio, permettendo così di disaccoppiare le applicazioni dall'infrastruttura sottostante.</li><li>L'osservabilità non riguarda solo le informazioni e le metriche del sistema operativo, ma anche lo stato di salute e altri segnali dalle applicazioni.</li><li>Coerenza di ambiente tra sviluppo, test e produzione: i container funzionano allo stesso modo su un computer portatile come nel cloud.</li><li>Portabilità tra cloud e sistemi operativi differenti: lo stesso container funziona su Ubuntu, RHEL, CoreOS, on-premise, nei più grandi cloud pubblici e da qualsiasi altra parte.</li><li>Gestione incentrata sulle applicazioni: Aumenta il livello di astrazione dall'esecuzione di un sistema operativo su hardware virtualizzato all'esecuzione di un'applicazione su un sistema operativo utilizzando risorse logiche.</li><li>Microservizi liberamente combinabili, distribuiti, ad alta scalabilità: le applicazioni sono suddivise in pezzi più piccoli e indipendenti che possono essere distribuite e gestite dinamicamente - niente stack monolitici che girano su una singola grande macchina.</li><li>Isolamento delle risorse: le prestazioni delle applicazioni sono prevedibili.</li><li>Utilizzo delle risorse: alta efficienza e densità.</li></ul><h2 id=perché-necessito-di-kubernetes-e-cosa-posso-farci>Perché necessito di Kubernetes e cosa posso farci</h2><p>I container sono un buon modo per distribuire ed eseguire le tue applicazioni. In un ambiente di produzione, è necessario gestire i container che eseguono le applicazioni e garantire che non si verifichino interruzioni dei servizi. Per esempio, se un container si interrompe, è necessario avviare un nuovo container. Non sarebbe più facile se questo comportamento fosse gestito direttamente da un sistema?</p><p>È proprio qui che Kubernetes viene in soccorso! Kubernetes ti fornisce un framework per far funzionare i sistemi distribuiti in modo resiliente. Kubernetes si occupa della scalabilità, failover, distribuzione delle tue applicazioni. Per esempio, Kubernetes può facilmente gestire i rilasci con modalità Canary deployment.</p><p>Kubernetes ti fornisce:</p><ul><li><strong>Scoperta dei servizi e bilanciamento del carico</strong>
Kubernetes può esporre un container usando un nome DNS o il suo indirizzo IP. Se il traffico verso un container è alto, Kubernetes è in grado di distribuire il traffico su più container in modo che il servizio rimanga stabile.</li><li><strong>Orchestrazione dello storage</strong>
Kubernetes ti permette di montare automaticamente un sistema di archiviazione di vostra scelta, come per esempio storage locale, dischi forniti da cloud pubblici, e altro ancora.</li><li><strong>Rollout e rollback automatizzati</strong>
Puoi utilizzare Kubernetes per descrivere lo stato desiderato per i propri container, e Kubernetes si occuperà di cambiare lo stato attuale per raggiungere quello desiderato ad una velocità controllata. Per esempio, puoi automatizzare Kubernetes per creare nuovi container per il tuo servizio, rimuovere i container esistenti e adattare le loro risorse a quelle richieste dal nuovo container.</li><li><strong>Ottimizzazione dei carichi</strong>
Fornisci a Kubernetes un cluster di nodi per eseguire i container. Puoi istruire Kubernetes su quanta CPU e memoria (RAM) ha bisogno ogni singolo container. Kubernetes allocherà i container sui nodi per massimizzare l'uso delle risorse a disposizione.</li><li><strong>Self-healing</strong>
Kubernetes riavvia i container che si bloccano, sostituisce container, termina i container che non rispondono agli health checks, e evita di far arrivare traffico ai container che non sono ancora pronti per rispondere correttamente.</li><li><strong>Gestione di informazioni sensibili e della configurazione</strong>
Kubernetes consente di memorizzare e gestire informazioni sensibili, come le password, i token OAuth e le chiavi SSH. Puoi distribuire e aggiornare le informazioni sensibili e la configurazione dell'applicazione senza dover ricostruire le immagini dei container e senza svelare le informazioni sensibili nella configurazione del tuo sistema.</li></ul><h2 id=cosa-non-è-kubernetes>Cosa non è Kubernetes</h2><p>Kubernetes non è un sistema PaaS (Platform as a Service) tradizionale e completo. Dal momento che Kubernetes opera a livello di container piuttosto che che a livello hardware, esso fornisce alcune caratteristiche generalmente disponibili nelle offerte PaaS, come la distribuzione, il ridimensionamento, il bilanciamento del carico, la registrazione e il monitoraggio. Tuttavia, Kubernetes non è monolitico, e queste soluzioni predefinite sono opzionali ed estensibili. Kubernetes fornisce gli elementi base per la costruzione di piattaforme di sviluppo, ma conserva le scelte dell'utente e la flessibilità dove è importante.</p><p>Kubernetes:</p><ul><li>Non limita i tipi di applicazioni supportate. Kubernetes mira a supportare una grande varietà di carichi di lavoro, compresi i carichi di lavoro stateless, stateful e elaborazione di dati. Se un'applicazione può essere eseguita in un container, dovrebbe funzionare alla grande anche su Kubernetes.</li><li>Non compila il codice sorgente e non crea i container. I flussi di Continuous Integration, Delivery, and Deployment (CI/CD) sono determinati dalla cultura e dalle preferenze dell'organizzazione e dai requisiti tecnici.</li><li>Non fornisce servizi a livello applicativo, come middleware (per esempio, bus di messaggi), framework di elaborazione dati (per esempio, Spark), database (per esempio, mysql), cache, né sistemi di storage distribuito (per esempio, Ceph) come servizi integrati. Tali componenti possono essere eseguiti su Kubernetes, e/o possono essere richiamati da applicazioni che girano su Kubernetes attraverso meccanismi come l'<a href=https://openservicebrokerapi.org/>Open Service Broker</a>.</li><li>Non impone soluzioni di logging, monitoraggio o di gestione degli alert. Fornisce alcune integrazioni come dimostrazione, e meccanismi per raccogliere ed esportare le metriche.</li><li>Non fornisce né rende obbligatorio un linguaggio/sistema di configurazione (per esempio, Jsonnet). Fornisce un'API dichiarativa che può essere richiamata da qualsiasi sistema.</li><li>Non fornisce né adotta alcun sistema di gestione completa della macchina, configurazione, manutenzione, gestione o sistemi di self healing.</li><li>Inoltre, Kubernetes non è un semplice sistema di orchestrazione. Infatti, questo sistema elimina la necessità di orchestrazione. La definizione tecnica di orchestrazione è l'esecuzione di un flusso di lavoro definito: prima si fa A, poi B, poi C. Al contrario, Kubernetes è composto da un insieme di processi di controllo indipendenti e componibili che guidano costantemente lo stato attuale verso lo stato desiderato. Non dovrebbe importare come si passa dalla A alla C. Anche il controllo centralizzato non è richiesto. Questo si traduce in un sistema più facile da usare, più potente, robusto, resiliente ed estensibile.</li></ul><h2 id=voci-correlate>Voci correlate</h2><ul><li>Dai un'occhiata alla pagina <a href=/docs/concepts/overview/components/>i componenti di Kubernetes</a></li><li>Sai già <a href=/docs/setup/>Come Iniziare</a>?</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-13b0f1dbe89228e3d76d2ac231e245f1>2 - I componenti di Kubernetes</h1><div class=lead>Un cluster di Kubernetes è costituito da un insieme di componenti che sono, come minimo, un Control Plane e uno o più sistemi di elaborazione, detti nodi.</div><p>Facendo il deployment di Kubernetes, ottieni un cluster.<p><p>Un cluster Kubernetes è un'insieme di macchine, chiamate nodi, che eseguono container gestiti da Kubernetes. Un cluster ha almeno un Worker Node.</p></p><p>Il/I Worker Node ospitano i Pod che eseguono i workload dell'utente. Il/I Control Plane Node gestiscono i Worker Node e tutto quanto accade all'interno del cluster. Per garantire la high-availability e la possibilità di failover del cluster, vengono utilizzati più Control Plane Node.</p></p><p>Questo documento descrive i diversi componenti che sono necessari per avere
un cluster Kubernetes completo e funzionante.</p><p>Questo è un diagramma di un cluster Kubernetes con tutti i componenti e le loro relazioni.</p><p><img src=/images/docs/components-of-kubernetes.png alt="I componenti di Kubernetes"></p><h2 id=componenti-della-control-plane>Componenti della Control Plane</h2><p>I componenti del Control Plane sono responsabili di tutte le decisioni globali sul cluster (ad esempio, lo scheduling) oltre che a rilevare e rispondere agli eventi del cluster (ad esempio, l'avvio di un nuovo <a class=glossary-tooltip title='Un Pod rappresenta un gruppo di container nel tuo cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=pod>pod</a> quando il valore <code>replicas</code> di un deployment non è soddisfatto).</p><p>I componenti della Control Plane possono essere eseguiti su qualsiasi nodo del cluster stesso. Solitamente, per semplicità, gli script di installazione tendono a eseguire tutti i componenti della Control Plane sulla stessa macchina, separando la Control Plane dai workload dell'utente.
Vedi <a href=/docs/admin/high-availability/>creare un cluster in High-Availability</a> per un esempio di un'installazione multi-master.</p><h3 id=kube-apiserver>kube-apiserver</h3><p>L'API server è un componente di Kubernetes
<a class=glossary-tooltip title="Lo strato per l'orchestrazione dei container che espone le API e interfaccie per definere, deploy, e gestione del ciclo di vita dei container." data-toggle=tooltip data-placement=top href='/it/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='control plane'>control plane</a> che espone le Kubernetes API.
L'API server è il front end del control plane di Kubernetes.</p><p>La principale implementazione di un server Kubernetes API è <a href=/docs/reference/generated/kube-apiserver/>kube-apiserver</a>.
kube-apiserver è progettato per scalare orizzontalmente, cioè scala aumentando il numero di istanze.
Puoi eseguire multiple istanze di kube-apiserver e bilanciare il traffico tra queste istanze.</p><h3 id=etcd>etcd</h3><p>È un database key-value ridondato, che è usato da Kubernetes per salvare tutte le informazioni del cluster.</p><p>Se il tuo cluster utilizza etcd per salvare le informazioni, assicurati di
avere una strategia di <a href=/docs/tasks/administer-cluster/configure-upgrade-etcd/#backing-up-an-etcd-cluster>backup</a> per questi dati.</p><p>Puoi trovare informazioni dettagliate su etcd sulla <a href=https://etcd.io/docs/>documentazione</a> ufficiale.</p><h3 id=kube-scheduler>kube-scheduler</h3><p>Componente della Control Plane che controlla i pod appena creati che non hanno un nodo assegnato, e dopo averlo identificato glielo assegna.</p><p>I fattori presi in considerazioni nell'individuare un nodo a cui assegnare l'esecuzione di un Pod includono la richiesta di risorse del Pod stesso e degli altri workload presenti nel sistema, i vincoli delle hardware/software/policy, le indicazioni di affinity e di anti-affinity, requisiti relativi alla disponibilità di dati/Volumes, le interferenze tra diversi workload e le scadenze.</p><h3 id=kube-controller-manager>kube-controller-manager</h3><p>Componente della Control Plane che gestisce <a class=glossary-tooltip title="Un software che implementa un circuito di controllo che osserva lo stato condiviso del cluster attraverso l'API server e apporta le modifiche necessarie per portate lo stato corrente verso lo stato desiderato." data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=controllers>controllers</a>.</p><p>Da un punto di vista logico, ogni <a class=glossary-tooltip title="Un software che implementa un circuito di controllo che osserva lo stato condiviso del cluster attraverso l'API server e apporta le modifiche necessarie per portate lo stato corrente verso lo stato desiderato." data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=controller>controller</a> è un processo separato, ma per ridurre la complessità, tutti i principali controller di Kubernetes vengono raggruppati in un unico container ed eseguiti in un singolo processo.</p><p>Alcuni esempi di controller gestiti dal kube-controller-manager sono:</p><ul><li>Node Controller: Responsabile del monitoraggio dei nodi del cluster, e.g. della gestione delle azioni da eseguire quando un nodo diventa non disponibile.</li><li>Replication Controller: Responsabile per il mantenimento del corretto numero di Pod per ogni ReplicaSet presente nel sistema</li><li>Endpoints Controller: Popola gli oggetti Endpoints (cioè, mette in relazioni i Pods con i Services).</li><li>Service Account & Token Controllers: Creano gli account di default e i token di accesso alle API per i nuovi namespaces.</li></ul><h3 id=cloud-controller-manager>cloud-controller-manager</h3>Un componente della <a class=glossary-tooltip title="Lo strato per l'orchestrazione dei container che espone le API e interfaccie per definere, deploy, e gestione del ciclo di vita dei container." data-toggle=tooltip data-placement=top href='/it/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='control plane'>control plane</a> di Kubernetes
che aggiunge logiche di controllo specifiche per il cloud. Il cloud-controller-manager ti permette di collegare il tuo
cluster con le API del cloud provider e separa le componenti che interagiscono
con la piattaforma cloud dai componenti che interagiscono solamente col cluster.<p>Il cloud-controller-manager esegue dei controller specifici del tuo cloud provider.
Se hai una installazione Kubernetes on premises, o un ambiente di laboratorio
nel tuo PC, il cluster non ha un cloud-controller-manager.</p><p>Come nel kube-controller-manager, il cloud-controller-manager combina diversi control loop
logicamente indipendenti in un singolo binario che puoi eseguire come un singolo processo. Tu puoi
scalare orizzontalmente (eseguire più di una copia) per migliorare la responsività o per migliorare la tolleranza ai fallimenti.</p><p>I seguenti controller hanno dipendenze verso implementazioni di specifici cloud provider:</p><ul><li>Node Controller: Per controllare se sul cloud provider i nodi che hanno smesso di rispondere sono stati cancellati</li><li>Route Controller: Per configurare le network route nella sottostante infrastruttura cloud</li><li>Service Controller: Per creare, aggiornare ed eliminare i load balancer del cloud provider</li></ul><h2 id=componenti-dei-nodi>Componenti dei Nodi</h2><p>I componenti del nodo vengono eseguiti su ogni nodo, mantenendo i pod in esecuzione e fornendo l'ambiente di runtime Kubernetes.</p><h3 id=kubelet>kubelet</h3><p>Un agente che è eseguito su ogni nodo del cluster. Si assicura che i container siano eseguiti in un pod.</p><p>La kubelet riceve un set di PodSpecs che vengono forniti attraverso vari meccanismi, e si assicura che i container descritti in questi PodSpecs funzionino correttamente e siano sani. La kubelet non gestisce i container che non sono stati creati da Kubernetes.</p><h3 id=kube-proxy>kube-proxy</h3><p><a href=/docs/reference/command-line-tools-reference/kube-proxy/>kube-proxy</a> è un
proxy eseguito su ogni nodo del cluster, responsabile della gestione dei
Kubernetes <a class=glossary-tooltip title='A way to expose an application running on a set of Pods as a network service.' data-toggle=tooltip data-placement=top href=/docs/concepts/services-networking/service/ target=_blank aria-label=Service>Service</a>.</p><p>I kube-proxy mantengono le regole di networking sui nodi.
Queste regole permettono la comunicazione verso gli altri nodi del cluster o l'esterno.</p><p>Il kube-proxy usa le librerie del sistema operativo quando possible; in caso contrario il kube-proxy gestisce il traffico direttamente.</p><h3 id=container-runtime>Container Runtime</h3><p>Il container runtime è il software che è responsabile per l'esecuzione dei container.</p><p>Kubernetes supporta diversi container runtimes: <a href=http://www.docker.com>Docker</a>,
<a href=https://containerd.io>containerd</a>, <a href=https://cri-o.io/>cri-o</a>,
<a href=https://github.com/kubernetes-incubator/rktlet>rktlet</a> e tutte le implementazioni di
<a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-node/container-runtime-interface.md>Kubernetes CRI (Container Runtime Interface)</a>.</p><h2 id=addons>Addons</h2><p>Gli Addons usano le risorse Kubernetes (<a class=glossary-tooltip title='Assicura che una copia di un Pod è attiva su tutti nodi di un cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/daemonset target=_blank aria-label=DaemonSet>DaemonSet</a>, <a class=glossary-tooltip title='Gestisce una applicazione replicata nel tuo cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Deployment>Deployment</a>, etc) per implementare funzionalità di cluster.
Dal momento che gli addons forniscono funzionalità a livello di cluster, le risorse che necessitano di un namespace, vengono collocate nel namespace <code>kube-system</code>.</p><p>Alcuni addons sono descritti di seguito; mentre per una più estesa lista di addons, per favore vedere <a href=/docs/concepts/cluster-administration/addons/>Addons</a>.</p><h3 id=dns>DNS</h3><p>Mentre gli altri addons non sono strettamente richiesti, tutti i cluster Kubernetes dovrebbero essere muniti di un <a href=/docs/concepts/services-networking/dns-pod-service/>DNS del cluster</a>, dal momento che molte applicazioni lo necessitano.</p><p>Il DNS del cluster è un server DNS aggiuntivo rispetto ad altri server DNS presenti nella rete, e si occupa specificatamente dei record DNS per i servizi Kubernetes.</p><p>I container eseguiti da Kubernetes automaticamente usano questo server per la risoluzione DNS.</p><h3 id=interfaccia-web-dashboard>Interfaccia web (Dashboard)</h3><p>La <a href=/docs/tasks/access-application-cluster/web-ui-dashboard/>Dashboard</a> è una interfaccia web per i cluster Kubernetes.
Permette agli utenti di gestire e fare troubleshooting delle applicazioni che girano nel cluster, e del cluster stesso.</p><h3 id=monitoraggio-dei-container>Monitoraggio dei Container</h3><p>Il <a href=/docs/tasks/debug-application-cluster/resource-usage-monitoring/>Monitoraggio dei Container</a> salva serie temporali di metriche generiche dei container in un database centrale e fornisce una interfaccia in cui navigare i dati stessi.</p><h3 id=log-a-livello-di-cluster>Log a livello di Cluster</h3><p>Un <a href=/docs/concepts/cluster-administration/logging/>log a livello di cluster</a> è responsabile per il salvataggio dei log dei container in un log centralizzato la cui interfaccia permette di cercare e navigare nei log.</p><h2 id=voci-correlate>Voci correlate</h2><ul><li>Scopri i concetti relativi ai <a href=/docs/concepts/architecture/nodes/>Nodi</a></li><li>Scopri i concetti relativi ai <a href=/docs/concepts/architecture/controller/>Controller</a></li><li>Scopri i concetti relativi al <a href=/docs/concepts/scheduling/kube-scheduler/>kube-scheduler</a></li><li>Leggi la <a href=https://etcd.io/docs/>documentazione</a> ufficiale di etcd</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-0c745f42e623d2b70a53bc0e6db73d95>3 - Le API di Kubernetes</h1><div class=lead>Le API di Kubernetes ti permettono di interrogare e manipolare lo stato degli oggetti in Kubernetes. Il cuore del Control Plane di Kubernetes è l'API server e le API HTTP che esso espone. Ogni entità o componente che si interfaccia con il cluster (gli utenti, le singole parti del tuo cluster, i componenti esterni), comunica attraverso l'API server.</div><p>Le convenzioni generali seguite dalle API sono descritte in <a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md>API conventions doc</a>.</p><p>Gli <em>endpoints</em> delle API, la lista delle risorse esposte ed i relativi esempi sono descritti in <a href=/docs/reference>API Reference</a>.</p><p>L'accesso alle API da remoto è discusso in <a href=/docs/reference/access-authn-authz/controlling-access/>Controllare l'accesso alle API</a>.</p><p>Le API di Kubernetes servono anche come riferimento per lo schema dichiarativo della configurazione del sistema stesso. Il comando <a href=/docs/reference/kubectl/overview/>kubectl</a> può essere usato per creare, aggiornare, cancellare ed ottenere le istanze delle risorse esposte attraverso le API.</p><p>Kubernetes assicura la persistenza del suo stato (al momento in <a href=https://coreos.com/docs/distributed-configuration/getting-started-with-etcd/>etcd</a>) usando la rappresentazione delle risorse implementata dalle API.</p><p>Kubernetes stesso è diviso in differenti componenti, i quali interagiscono tra loro attraverso le stesse API.</p><h2 id=evoluzione-delle-api>Evoluzione delle API</h2><p>In base alla nostra esperienza, ogni sistema di successo ha bisogno di evolvere ovvero deve estendersi aggiungendo funzionalità o modificare le esistenti per adattarle a nuovi casi d'uso. Le API di Kubernetes sono quindi destinate a cambiare e ad estendersi. In generale, ci si deve aspettare che nuove risorse vengano aggiunte di frequente cosi come nuovi campi possano altresì essere aggiunti a risorse esistenti. L'eliminazione di risorse o di campi devono seguire la <a href=/docs/reference/using-api/deprecation-policy/>politica di deprecazione delle API</a>.</p><p>In cosa consiste una modifica compatibile e come modificare le API è descritto dal <a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api_changes.md>API change document</a>.</p><h2 id=definizioni-openapi-e-swagger>Definizioni OpenAPI e Swagger</h2><p>La documentazione completa e dettagliata delle API è fornita attraverso la specifica <a href=https://www.openapis.org/>OpenAPI</a>.</p><p>Dalla versione 1.10 di Kubernetes, l'API server di Kubernetes espone le specifiche OpenAPI attraverso il seguente <em>endpoint</em> <code>/openapi/v2</code>. Attraverso i seguenti <em>headers</em> HTTP è possibile richiedere un formato specifico:</p><table><thead><tr><th>Header</th><th>Possibili Valori</th></tr></thead><tbody><tr><td>Accept</td><td><code>application/json</code>, <code>application/com.github.proto-openapi.spec.v2@v1.0+protobuf</code> (il content-type di default è <code>application/json</code> per <code>*/*</code> ovvero questo header può anche essere omesso)</td></tr><tr><td>Accept-Encoding</td><td><code>gzip</code> (questo header è facoltativo)</td></tr></tbody></table><p>Prima della versione 1.14, gli <em>endpoints</em> che includono il formato del nome all'interno del segmento (<code>/swagger.json</code>, <code>/swagger-2.0.0.json</code>, <code>/swagger-2.0.0.pb-v1</code>, <code>/swagger-2.0.0.pb-v1.gz</code>)
espongo le specifiche OpenAPI in formati differenti. Questi <em>endpoints</em> sono deprecati, e saranno rimossi dalla versione 1.14 di Kubernetes.</p><p><strong>Esempi per ottenere le specifiche OpenAPI</strong>:</p><table><thead><tr><th>Prima della 1.10</th><th>Dalla versione 1.10 di Kubernetes</th></tr></thead><tbody><tr><td>GET /swagger.json</td><td>GET /openapi/v2 <strong>Accept</strong>: application/json</td></tr><tr><td>GET /swagger-2.0.0.pb-v1</td><td>GET /openapi/v2 <strong>Accept</strong>: <a href=mailto:application/com.github.proto-openapi.spec.v2@v1.0>application/com.github.proto-openapi.spec.v2@v1.0</a>+protobuf</td></tr><tr><td>GET /swagger-2.0.0.pb-v1.gz</td><td>GET /openapi/v2 <strong>Accept</strong>: <a href=mailto:application/com.github.proto-openapi.spec.v2@v1.0>application/com.github.proto-openapi.spec.v2@v1.0</a>+protobuf <strong>Accept-Encoding</strong>: gzip</td></tr></tbody></table><p>Kubernetes implementa per le sue API anche una serializzazione alternativa basata sul formato Protobuf che è stato pensato principalmente per la comunicazione intra-cluster, documentato nella seguente <a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/protobuf.md>design proposal</a>, e i files IDL per ciascun schema si trovano nei <em>Go packages</em> che definisco i tipi delle API.</p><p>Prima della versione 1.14, l'<em>apiserver</em> di Kubernetes espone anche un'<em>endpoint</em>, <code>/swaggerapi</code>, che può essere usato per ottenere
le documentazione per le API di Kubernetes secondo le specifiche <a href=http://swagger.io/>Swagger v1.2</a> .
Questo <em>endpoint</em> è deprecato, ed è stato rimosso nella versione 1.14 di Kubernetes.</p><h2 id=versionamento-delle-api>Versionamento delle API</h2><p>Per facilitare l'eliminazione di campi specifici o la modifica della rappresentazione di una data risorsa, Kubernetes supporta molteplici versioni della stessa API disponibili attraverso differenti indirizzi, come ad esempio <code>/api/v1</code> oppure
<code>/apis/extensions/v1beta1</code>.</p><p>Abbiamo deciso di versionare a livello di API piuttosto che a livello di risorsa o di campo per assicurare che una data API rappresenti una chiara, consistente vista delle risorse di sistema e dei sui comportamenti, e per abilitare un controllo degli accessi sia per le API in via di decommissionamento che per quelle sperimentali.</p><p>Si noti che il versionamento delle API ed il versionamento del Software sono indirettamente collegati. La <a href=https://git.k8s.io/community/contributors/design-proposals/release/versioning.md>API and release versioning proposal</a> descrive la relazione tra le versioni delle API ed le versioni del Software.</p><p>Differenti versioni delle API implicano differenti livelli di stabilità e supporto. I criteri per ciascuno livello sono descritti in dettaglio nella <a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api_changes.md#alpha-beta-and-stable-versions>API Changes documentation</a>. Queste modifiche sono qui ricapitolate:</p><ul><li>Livello alpha:<ul><li>Il nome di versione contiene <code>alpha</code> (e.g. <code>v1alpha1</code>).</li><li>Potrebbe contenere dei <em>bug</em>. Abilitare questa funzionalità potrebbe esporre al rischio di <em>bugs</em>. Disabilitata di default.</li><li>Il supporto di questa funzionalità potrebbe essere rimosso in ogni momento senza previa notifica.</li><li>Questa API potrebbe cambiare in modo incompatibile in rilasci futuri del Software e senza previa notifica.</li><li>Se ne raccomandata l'utilizzo solo in <em>clusters</em> di test creati per un breve periodo di vita, a causa di potenziali <em>bugs</em> e delle mancanza di un supporto di lungo periodo.</li></ul></li><li>Livello beta:<ul><li>Il nome di versione contiene <code>beta</code> (e.g. <code>v2beta3</code>).</li><li>Il codice è propriamente testato. Abilitare la funzionalità è considerato sicuro. Abilitata di default.</li><li>Il supporto per la funzionalità nel suo complesso non sarà rimosso, tuttavia potrebbe subire delle modifiche.</li><li>Lo schema e/o la semantica delle risorse potrebbe cambiare in modo incompatibile in successivi rilasci beta o stabili. Nel caso questo dovesse verificarsi, verrano fornite istruzioni per la migrazione alla versione successiva. Questo potrebbe richiedere la cancellazione, modifica, e la ri-creazione degli oggetti supportati da questa API. Questo processo di modifica potrebbe richiedere delle valutazioni. La modifica potrebbe richiedere un periodo di non disponibilità dell'applicazione che utilizza questa funzionalità.</li><li>Raccomandata solo per applicazioni non critiche per la vostra impresa a causa dei potenziali cambiamenti incompatibili in rilasci successivi. Se avete più <em>clusters</em> che possono essere aggiornati separatamente, potreste essere in grado di gestire meglio questa limitazione.</li><li><strong>Per favore utilizzate le nostre versioni beta e forniteci riscontri relativamente ad esse! Una volta promosse a stabili, potrebbe non essere semplice apportare cambiamenti successivi.</strong></li></ul></li><li>Livello stabile:<ul><li>Il nome di versione è <code>vX</code> dove <code>X</code> è un intero.</li><li>Le funzionalità relative alle versioni stabili continueranno ad essere presenti per parecchie versioni successive.</li></ul></li></ul><h2 id=api-groups>API groups</h2><p>Per facilitare l'estendibilità delle API di Kubernetes, sono stati implementati gli <a href=https://git.k8s.io/community/contributors/design-proposals/api-machinery/api-group.md><em>API groups</em></a>.<br>L'<em>API group</em> è specificato nel percorso REST ed anche nel campo <code>apiVersion</code> di un oggetto serializzato.</p><p>Al momento ci sono diversi <em>API groups</em> in uso:</p><ol><li><p>Il gruppo <em>core</em>, spesso referenziato come il <em>legacy group</em>, è disponibile al percorso REST <code>/api/v1</code> ed utilizza <code>apiVersion: v1</code>.</p></li><li><p>I gruppi basati su un nome specifico sono disponibili attraverso il percorso REST <code>/apis/$GROUP_NAME/$VERSION</code>, ed usano <code>apiVersion: $GROUP_NAME/$VERSION</code> (e.g. <code>apiVersion: batch/v1</code>). La lista completa degli <em>API groups</em> supportati e' descritta nel documento <a href=/docs/reference/>Kubernetes API reference</a>.</p></li></ol><p>Vi sono due modi per supportati per estendere le API attraverso le <a href=/docs/concepts/api-extension/custom-resources/><em>custom resources</em></a>:</p><ol><li><a href=/docs/tasks/access-kubernetes-api/extend-api-custom-resource-definitions/>CustomResourceDefinition</a>
è pensato per utenti con esigenze CRUD basilari.</li><li>Utenti che necessitano di un nuovo completo set di API che utilizzi appieno la semantica di Kubernetes possono implementare il loro <em>apiserver</em> ed utilizzare l'<a href=/docs/tasks/access-kubernetes-api/configure-aggregation-layer/><em>aggregator</em></a>
per fornire ai propri utilizzatori la stessa esperienza a cui sono abituati con le API incluse nativamente in Kubernetes.</li></ol><h2 id=abilitare-o-disabilitare-gli-api-groups>Abilitare o disabilitare gli <em>API groups</em></h2><p>Alcune risorse ed <em>API groups</em> sono abilitati di default. Questi posso essere abilitati o disabilitati attraverso il settaggio/flag <code>--runtime-config</code>
applicato sull'<em>apiserver</em>. <code>--runtime-config</code> accetta valori separati da virgola. Per esempio: per disabilitare <code>batch/v1</code>, usa la seguente configurazione <code>--runtime-config=batch/v1=false</code>, per abilitare <code>batch/v2alpha1</code>, utilizzate <code>--runtime-config=batch/v2alpha1</code>.<br>Il <em>flag</em> accetta set di coppie <em>chiave/valore</em> separati da virgola che descrivono la configurazione a <em>runtime</em> dell'<em>apiserver</em>.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Abilitare o disabilitare risorse o gruppi richiede il riavvio dell'<em>apiserver</em> e del <em>controller-manager</em> affinché le modifiche specificate attraverso il flag <code>--runtime-config</code> abbiano effetto.</div><h2 id=abilitare-specifiche-risorse-nel-gruppo-extensions-v1beta1>Abilitare specifiche risorse nel gruppo extensions/v1beta1</h2><p>DaemonSets, Deployments, StatefulSet, NetworkPolicies, PodSecurityPolicies e ReplicaSets presenti nel gruppo di API <code>extensions/v1beta1</code> sono disabilitate di default.
Per esempio: per abilitare deployments and daemonsets, utilizza la seguente configurazione
<code>--runtime-config=extensions/v1beta1/deployments=true,extensions/v1beta1/daemonsets=true</code>.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Abilitare/disabilitare una singola risorsa è supportato solo per il gruppo di API <code>extensions/v1beta1</code> per ragioni storiche.</div></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/it/docs/home/>Home</a>
<a class=text-white href=/it/blog/>Blog</a>
<a class=text-white href=/it/training/>Formazione</a>
<a class=text-white href=/it/partners/>Partner</a>
<a class=text-white href=/it/community/>Community</a>
<a class=text-white href=/it/case-studies/>Casi di Studio</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 Gli autori di Kubernetes | Documentazione distribuita sotto <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small><br><small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. Tutti i diritti riservati. The Linux Foundation ha marchi registrati e utilizza marchi commerciali. Per un elenco dei marchi di Linux Foundation, consulta la <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>pagina sull'utilizzo dei marchi</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>