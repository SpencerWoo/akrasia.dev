<!doctype html><html lang=it class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=en href=https://kubernetes.io/docs/concepts/architecture/><link rel=alternate hreflang=zh-cn href=https://kubernetes.io/zh-cn/docs/concepts/architecture/><link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/concepts/architecture/><link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/concepts/architecture/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/concepts/architecture/><link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/concepts/architecture/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/concepts/architecture/><link rel=alternate hreflang=pt-br href=https://kubernetes.io/pt-br/docs/concepts/architecture/><link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/concepts/architecture/><link rel=alternate hreflang=vi href=https://kubernetes.io/vi/docs/concepts/architecture/><link rel=alternate hreflang=ru href=https://kubernetes.io/ru/docs/concepts/architecture/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/it/docs/concepts/architecture/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>Architettura di Kubernetes | Kubernetes</title><meta property="og:title" content="Architettura di Kubernetes"><meta property="og:description" content="Orchestrazione di Container in produzione"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/it/docs/concepts/architecture/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="Architettura di Kubernetes"><meta itemprop=description content="Orchestrazione di Container in produzione"><meta name=twitter:card content="summary"><meta name=twitter:title content="Architettura di Kubernetes"><meta name=twitter:description content="Orchestrazione di Container in produzione"><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content><meta property="og:description" content><meta name=twitter:description content><meta property="og:url" content="https://kubernetes.io/it/docs/concepts/architecture/"><meta property="og:title" content="Architettura di Kubernetes"><meta name=twitter:title content="Architettura di Kubernetes"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/it/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/it/docs/>Documentazione</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/it/blog/>Blog di Kubernetes</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/it/training/>Formazione</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/it/partners/>Partner</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/it/community/>Community</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/it/case-studies/>Casi di Studio</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Versions</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/it/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/it/docs/concepts/architecture/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/it/docs/concepts/architecture/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/it/docs/concepts/architecture/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/it/docs/concepts/architecture/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/it/docs/concepts/architecture/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Italiano (Italian)</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/docs/concepts/architecture/>English</a>
<a class=dropdown-item href=/zh-cn/docs/concepts/architecture/>中文 (Chinese)</a>
<a class=dropdown-item href=/ko/docs/concepts/architecture/>한국어 (Korean)</a>
<a class=dropdown-item href=/ja/docs/concepts/architecture/>日本語 (Japanese)</a>
<a class=dropdown-item href=/fr/docs/concepts/architecture/>Français (French)</a>
<a class=dropdown-item href=/de/docs/concepts/architecture/>Deutsch (German)</a>
<a class=dropdown-item href=/es/docs/concepts/architecture/>Español (Spanish)</a>
<a class=dropdown-item href=/pt-br/docs/concepts/architecture/>Português (Portuguese)</a>
<a class=dropdown-item href=/id/docs/concepts/architecture/>Bahasa Indonesia</a>
<a class=dropdown-item href=/vi/docs/concepts/architecture/>Tiếng Việt (Vietnamese)</a>
<a class=dropdown-item href=/ru/docs/concepts/architecture/>Русский (Russian)</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>This is the multi-page printable view of this section.
<a href=# onclick="return print(),!1">Click here to print</a>.</p><p><a href=/it/docs/concepts/architecture/>Return to the regular view of this page</a>.</p></div><h1 class=title>Architettura di Kubernetes</h1><ul><li>1: <a href=#pg-c0251def6da29b30afebfb04549f1703>Comunicazione Control Plane - Nodo</a></li><li>2: <a href=#pg-bc804b02614d67025b4c788f1ca87fbc>Concetti alla base del Cloud Controller Manager</a></li><li>3: <a href=#pg-ca8819042a505291540e831283da66df>Controller</a></li></ul><div class=content></div></div><div class=td-content><h1 id=pg-c0251def6da29b30afebfb04549f1703>1 - Comunicazione Control Plane - Nodo</h1><p>Questo documento cataloga le connessioni tra il piano di controllo (<em>control-plane</em>), in realtà l'apiserver, e il cluster Kubernetes. L'intento è di consentire agli utenti di personalizzare la loro installazione per rafforzare la configurazione di rete affinché il cluster possa essere eseguito su una rete pubblica (o su IP completamente pubblici resi disponibili da un fornitore di servizi cloud).</p><h2 id=dal-nodo-al-control-plane>Dal Nodo al control-plane</h2><p>Kubernetes adotta un pattern per le API di tipo <em>"hub-and-spoke"</em>. Tutte le chiamate delle API eseguite sui vari nodi sono effettuate verso l'apiserver (nessuno degli altri componenti principali è progettato per esporre servizi remoti). L'apiserver è configurato per l'ascolto di connessioni remote su una porta HTTPS protetta (443) con una o più forme di <a href=/docs/reference/access-authn-authz/authentication/>autenticazioni client</a> abilitate. Si dovrebbero abilitare una o più forme di <a href=/docs/reference/access-authn-authz/authorization/>autorizzazioni</a>, in particolare nel caso in cui siano ammesse <a href=/docs/reference/access-authn-authz/authentication/#anonymous-requests>richieste anonime</a> o <a href=/docs/reference/access-authn-authz/authentication/#service-account-tokens><em>token</em> legati ad un account di servizio (<em>service account</em>)</a>.</p><p>Il certificato pubblico (<em>public root certificate</em>) relativo al cluster corrente deve essere fornito ai vari nodi di modo che questi possano connettersi in modo sicuro all'apiserver insieme alle credenziali valide per uno specifico <em>client</em>. Ad esempio, nella configurazione predefinita di un cluster <a href="https://cloud.google.com/kubernetes-engine?hl=it">GKE</a>, le credenziali del client fornite al kubelet hanno la forma di un certificato client. Si veda
<a href=/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/>inizializzazione TLS del kubelet TLS</a> per la fornitura automatica dei certificati client al <em>kubelet</em>.</p><p>I Pod che desiderano connettersi all'apiserver possono farlo in modo sicuro sfruttando un account di servizio in modo che Kubernetes inserisca automaticamente il certificato pubblico di radice e un token valido al portatore (<em>bearer token</em>) all'interno Pod quando questo viene istanziato.
In tutti i namespace è configurato un <em>Service</em> con nome <code>kubernetes</code> con un indirizzo IP virtuale che viene reindirizzato (tramite <em>kube-proxy</em>) all'endpoint HTTPS dell'apiserver.</p><p>Anche i componenti del piano d controllo comunicano con l'apiserver del cluster su di una porta sicura esposta da quest'ultimo.</p><p>Di conseguenza, la modalità operativa predefinita per le connessioni dai nodi e dai Pod in esecuzione sui nodi verso il <em>control-plane</em> è protetta da un'impostazione predefinita
e può essere eseguita su reti non sicure e/o pubbliche.</p><h2 id=dal-control-plane-al-nodo>Dal control-plane al nodo</h2><p>Esistono due percorsi di comunicazione principali dal <em>control-plane</em> (apiserver) verso i nodi. Il primo è dall'apiserver verso il processo <em>kubelet</em> in esecuzione su ogni nodo nel cluster. Il secondo è dall'apiserver a ciascun nodo, Pod, o servizio attraverso la funzionalità proxy dell'apiserver.</p><h3 id=dall-apiserver-al-kubelet>Dall'apiserver al <em>kubelet</em></h3><p>Le connessioni dall'apiserver al <em>kubelet</em> vengono utilizzate per:</p><ul><li>Prendere i log relativi ai vari Pod.</li><li>Collegarsi (attraverso kubectl) ai Pod in esecuzione.</li><li>Fornire la funzionalità di <em>port-forwarding</em> per i <em>kubelet</em>.</li></ul><p>Queste connessioni terminano all'endpoint HTTPS del <em>kubelet</em>. Di default, l'apiserver non verifica il certificato servito dal <em>kubelet</em>, il che rende la connessione soggetta ad attacchi <em>man-in-the-middle</em>, e tale da essere considerato <strong>non sicuro (unsafe)</strong> se eseguito su reti non protette e/o pubbliche.</p><p>Per verificare questa connessione, si utilizzi il parametro <code>--kubelet-certificate-authority</code> al fine di fornire all'apiserver un insieme di certificati radice da utilizzare per verificare il
il certificato servito dal <em>kubelet</em>.</p><p>Se questo non è possibile, si usi un <a href=/docs/tasks/access-application-cluster/port-forward-access-application-cluster/>tunnel SSH</a> tra l'apiserver e il <em>kubelet</em>, se richiesto, per evitare il collegamento su una rete non protetta o pubblica.</p><p>In fine, l'<a href=/docs/admin/kubelet-authentication-authorization/>autenticazione e/o l'autorizzazione del kubelet</a> dovrebbe essere abilitate per proteggere le API esposte dal <em>kubelet</em>.</p><h3 id=dal-apiserver-ai-nodi-pod-servizi>Dall'apiserver ai nodi, Pod, e servizi</h3><p>Le connessioni dall'apiserver verso un nodo, Pod o servizio avvengono in modalità predefinita su semplice connessione HTTP e quindi non sono né autenticate né criptata. Queste connessioni possono essere eseguite su una connessione HTTPS sicura mediante il prefisso <code>https:</code> al nodo, Pod o nome del servizio nell'URL dell'API, ma non valideranno il certificato fornito dall'endpoint HTTPS né forniranno le credenziali del client così anche se la connessione verrà criptata, non fornirà alcuna garanzia di integrità. <strong>Non è attualmente sicuro</strong> eseguire queste connessioni su reti non protette e/o pubbliche.</p><h3 id=i-tunnel-ssh>I tunnel SSH</h3><p>Kubernetes supporta i <em>tunnel</em> SSH per proteggere la comunicazione tra il <em>control-plane</em> e i nodi. In questa configurazione, l'apiserver inizializza un tunnel SSH con ciascun nodo del cluster (collegandosi al server SSH in ascolto sulla porta 22) e fa passare tutto il traffico verso il <em>kubelet</em>, il nodo, il Pod, o il servizio attraverso questo tunnel. Questo tunnel assicura che il traffico non sia esposto al di fuori della rete su cui sono in esecuzioni i vari nodi.</p><p>I tunnel SSH sono al momento deprecati ovvero non dovrebbero essere utilizzati a meno che ci siano delle esigenze particolari. Il servizio <code>Konnectivity</code> è pensato per rimpiazzare questo canale di comunicazione.</p><h3 id=il-servizio-konnectivity>Il servizio <em>Konnectivity</em></h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.18 [beta]</code></div><p>Come rimpiazzo dei tunnel SSH, il servizio <em>Konnectivity</em> fornisce un proxy a livello TCP per la comunicazione tra il <em>control-plane</em> e il cluster. Il servizio <em>Konnectivity</em> consiste in due parti: il <em>Konnectivity</em> server e gli agenti <em>Konnectivity</em>, in esecuzione rispettivamente sul <em>control-plane</em> e sui vari nodi. Gli agenti <em>Konnectivity</em> inizializzano le connessioni verso il server <em>Konnectivity</em> e mantengono le connessioni di rete. Una volta abilitato il servizio <em>Konnectivity</em>, tutto il traffico tra il <em>control-plane</em> e i nodi passa attraverso queste connessioni.</p><p>Si può fare riferimento al <a href=/docs/tasks/extend-kubernetes/setup-konnectivity/>tutorial per il servizio <em>Konnectivity</em></a> per configurare il servizio <em>Konnectivity</em> all'interno del cluster</p></div><div class=td-content style=page-break-before:always><h1 id=pg-bc804b02614d67025b4c788f1ca87fbc>2 - Concetti alla base del Cloud Controller Manager</h1><p>Il concetto di CCM (cloud controller manager), da non confondere con il binario, è stato originariamente creato per consentire di sviluppare Kubernetes indipendentemente dall'implementazione dello specifico cloud provider. Il cloud controller manager viene eseguito insieme ad altri componenti principali come il Kubernetes controller manager, il server API e lo scheduler. Può anche essere avviato come addon di Kubernetes, nel qual caso viene eseguito su Kubernetes.</p><p>Il design del cloud controller manager è basato su un meccanismo di plug-in che consente ai nuovi provider cloud di integrarsi facilmente con Kubernetes creando un plug-in. Sono in atto programmi per l'aggiunta di nuovi provider di cloud su Kubernetes e per la migrazione dei provider che usano il vecchio metodo a questo nuovo metodo.</p><p>Questo documento discute i concetti alla base del cloud controller manager e fornisce dettagli sulle funzioni associate.</p><p>Ecco l'architettura di un cluster Kubernetes senza il gestore del controller cloud:</p><p><img src=/images/docs/pre-ccm-arch.png alt="Pre CCM Kube Arch"></p><h2 id=architettura>Architettura</h2><p>Nel diagramma precedente, Kubernetes e il provider cloud sono integrati attraverso diversi componenti:</p><ul><li>Kubelet</li><li>Kubernetes controller manager</li><li>Kubernetes API server</li></ul><p>Il CCM consolida tutta la logica dipendente dal cloud presente nei tre componenti precedenti, per creare un singolo punto di integrazione con il cloud. La nuova architettura con il CCM si presenta così:</p><p><img src=/images/docs/post-ccm-arch.png alt="CCM Kube Arch"></p><h2 id=componenti-del-ccm>Componenti del CCM</h2><p>Il CCM divide alcune funzionalità del Kubernetes controller manager (KCM) e le esegue in un differente processo. In particolare, toglie dal KCM le integrazioni con il cloud specifico. Il KCM ha i seguenti controller che dipendono dal cloud specifico:</p><ul><li>Node controller</li><li>Volume controller</li><li>Route controller</li><li>Service controller</li></ul><p>Nella versione 1.9, il CCM esegue i seguenti controller dall'elenco precedente:</p><ul><li>Node controller</li><li>Route controller</li><li>Service controller</li></ul><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> È stato deliberatamente deciso di non spostare il Volume controller nel CCM. Data la complessità del Volume controller e gli sforzi già fatti per astrarre le logiche specifiche dei singoli fornitori, è stato deciso che il Volume controller non verrà spostato nel CCM.</div><p>Il piano originale per supportare i volumi utilizzando il CCM era di utilizzare <a href=/docs/concepts/storage/volumes/#flexVolume>Flex</a> per supportare volumi collegabili. Tuttavia, una implementazione parallela, nota come <a href=/docs/concepts/storage/volumes/#csi>CSI</a> è stata designata per sostituire Flex.</p><p>Considerando queste evoluzioni, abbiamo deciso di adottare un approccio intermedio finché il CSI non è pronto.</p><h2 id=funzioni-del-ccm>Funzioni del CCM</h2><p>Il CCM eredita le sue funzioni da componenti di Kubernetes che dipendono da uno specifico provider di cloud. Questa sezione è strutturata sulla base di tali componenti.</p><h3 id=1-kubernetes-controller-manager>1. Kubernetes controller manager</h3><p>La maggior parte delle funzioni del CCM deriva dal KCM. Come menzionato nella sezione precedente, CCM esegue i seguenti cicli di controllo:</p><ul><li>Node controller</li><li>Route controller</li><li>Service controller</li></ul><h4 id=node-controller>Node controller</h4><p>Il Node controller è responsabile per l'inizializzazione di un nodo ottenendo informazioni sui nodi in esecuzione nel cluster dal provider cloud. Il controller del nodo esegue le seguenti funzioni:</p><ol><li>Inizializzare un nodo con le label zone/region specifiche per il cloud in uso.</li><li>Inizializzare un nodo con le specifiche, ad esempio, tipo e dimensione specifiche del cloud in uso.</li><li>Ottenere gli indirizzi di rete del nodo e l'hostname.</li><li>Nel caso in cui un nodo non risponda, controlla il cloud per vedere se il nodo è stato cancellato dal cloud.
Se il nodo è stato eliminato dal cloud, elimina l'oggetto Nodo di Kubernetes.</li></ol><h4 id=route-controller>Route controller</h4><p>Il Route controller è responsabile della configurazione delle route nel cloud in modo che i container su nodi differenti del cluster Kubernetes possano comunicare tra loro. Il Route controller è utilizzabile solo dai cluster su Google Compute Engine.</p><h4 id=service-controller>Service Controller</h4><p>Il Service Controller rimane in ascolto per eventi di creazione, aggiornamento ed eliminazione di servizi. In base allo stato attuale dei servizi in Kubernetes, configura i bilanciatori di carico forniti dal cloud (come gli ELB, i Google LB, o gli Oracle Cloud Infrastructure LB) per riflettere lo stato dei servizi in Kubernetes. Inoltre, assicura che i back-end dei bilanciatori di carico forniti dal cloud siano aggiornati.</p><h3 id=2-kubelet>2. Kubelet</h3><p>Il Node Controller contiene l'implementazione dipendente dal cloud della kubelet. Prima dell'introduzione del CCM, la kubelet era responsabile dell'inizializzazione di un nodo con dettagli dipendenti dallo specifico cloud come gli indirizzi IP, le label region/zone e le informazioni sul tipo di istanza. L'introduzione del CCM ha spostato questa operazione di inizializzazione dalla kubelet al CCM.</p><p>In questo nuovo modello, la kubelet inizializza un nodo senza informazioni specifiche del cloud. Tuttavia, aggiunge un blocco al nodo appena creato che rende il nodo non selezionabile per eseguire container finché il CCM non inizializza il nodo con le informazioni specifiche del cloud. Il CCM rimuove quindi questo blocco.</p><h2 id=sistema-a-plug-in>Sistema a plug-in</h2><p>Il cloud controller manager utilizza le interfacce di Go per consentire l'implementazione di implementazioni di qualsiasi cloud. In particolare, utilizza l'interfaccia CloudProvider definita <a href=https://github.com/kubernetes/cloud-provider/blob/9b77dc1c384685cb732b3025ed5689dd597a5971/cloud.go#L42-L62>qui</a>.</p><p>L'implementazione dei quattro controller generici evidenziati sopra, alcune strutture, l'interfaccia cloudprovider condivisa rimarranno nel core di Kubernetes. Le implementazioni specifiche per i vari cloud saranno costruite al di fuori del core e implementeranno le interfacce definite nel core.</p><p>Per ulteriori informazioni sullo sviluppo di plug-in, consultare <a href=/docs/tasks/administer-cluster/developing-cloud-controller-manager/>Developing Cloud Controller Manager</a>.</p><h2 id=autorizzazione>Autorizzazione</h2><p>Questa sezione dettaglia l'accesso richiesto dal CCM sui vari API objects per eseguire le sue operazioni.</p><h3 id=node-controller-1>Node controller</h3><p>Il Node controller funziona solo con oggetti di tipo Node. Richiede l'accesso completo per ottenere, elencare, creare, aggiornare, applicare patch, guardare ed eliminare oggetti di tipo Node.</p><p>v1/Node:</p><ul><li>Get</li><li>List</li><li>Create</li><li>Update</li><li>Patch</li><li>Watch</li><li>Delete</li></ul><h3 id=route-controller-1>Route controller</h3><p>Il Route controller ascolta la creazione dell'oggetto Node e configura le rotte in modo appropriato. Richiede l'accesso in lettura agli oggetti di tipo Node.</p><p>v1/Node:</p><ul><li>Get</li></ul><h3 id=service-controller-1>Service controller</h3><p>Il Service controller resta in ascolto per eventi di creazione, aggiornamento ed eliminazione di oggetti di tipo Servizi, e configura gli endpoint per tali Servizi in modo appropriato.</p><p>Per accedere ai Servizi, è necessario il permesso per list e watch. Per aggiornare i Servizi, sono necessari i permessi patch e update.</p><p>Per impostare gli endpoint per i Servizi, richiede i permessi create, list, get, watch, e update.</p><p>v1/Service:</p><ul><li>List</li><li>Get</li><li>Watch</li><li>Patch</li><li>Update</li></ul><h3 id=others>Others</h3><p>L'implementazione del core di CCM richiede l'accesso per creare eventi e, per garantire operazioni sicure, richiede l'accesso per creare ServiceAccounts.</p><p>v1/Event:</p><ul><li>Create</li><li>Patch</li><li>Update</li></ul><p>v1/ServiceAccount:</p><ul><li>Create</li></ul><p>L'RBAC ClusterRole per il CCM ha il seguente aspetto:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cloud-controller-manager<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- events<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- create<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- patch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- nodes<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#39;*&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- nodes/status<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- patch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- services<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- list<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- patch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- watch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- serviceaccounts<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- create<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- persistentvolumes<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- get<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- list<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- watch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- endpoints<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- create<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- get<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- list<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- watch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=vendor-implementations>Vendor Implementations</h2><p>I seguenti fornitori di cloud hanno una implementazione di CCM:</p><ul><li><a href=https://github.com/kubernetes/cloud-provider-alibaba-cloud>Alibaba Cloud</a></li><li><a href=https://github.com/kubernetes/cloud-provider-aws>AWS</a></li><li><a href=https://github.com/kubernetes/cloud-provider-azure>Azure</a></li><li><a href=https://github.com/baidu/cloud-provider-baiducloud>BaiduCloud</a></li><li><a href=https://github.com/digitalocean/digitalocean-cloud-controller-manager>DigitalOcean</a></li><li><a href=https://github.com/kubernetes/cloud-provider-gcp>GCP</a></li><li><a href=https://github.com/hetznercloud/hcloud-cloud-controller-manager>Hetzner</a></li><li><a href=https://github.com/linode/linode-cloud-controller-manager>Linode</a></li><li><a href=https://github.com/kubernetes/cloud-provider-openstack>OpenStack</a></li><li><a href=https://github.com/oracle/oci-cloud-controller-manager>Oracle</a></li><li><a href=https://github.com/TencentCloud/tencentcloud-cloud-controller-manager>TencentCloud</a></li></ul><h2 id=cluster-administration>Cluster Administration</h2><p>Le istruzioni complete per la configurazione e l'esecuzione del CCM sono fornite
<a href=/docs/tasks/administer-cluster/running-cloud-controller/#cloud-controller-manager>qui</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-ca8819042a505291540e831283da66df>3 - Controller</h1><p>Nella robotica e nell'automazione, un <em>circuito di controllo</em> (<em>control loop</em>) è un un'iterazione senza soluzione di continuità che regola lo stato di un sistema.</p><p>Ecco un esempio di un circuito di controllo: il termostato di una stanza.</p><p>Quando viene impostata la temperatura, si definisce attraverso il termostato lo <em>stato desiderato</em>. L'attuale temperatura nella stanza è invece lo <em>stato corrente</em>. Il termostato agisce per portare lo stato corrente il più vicino possibile allo stato desiderato accendendo e spegnendo le apparecchiature.</p>In Kubernetes, i <em>controller</em> sono circuiti di controllo che osservano lo stato del <a class=glossary-tooltip title="Un'insieme di macchine, chiamate nodi, che eseguono container gestiti da Kubernetes. Un cluster ha almeno un Worker Node." data-toggle=tooltip data-placement=top href='/it/docs/reference/glossary/?all=true#term-cluster' target=_blank aria-label=cluster>cluster</a>, e apportano o richiedono modifiche quando necessario. Ogni <em>controller</em> prova a portare lo stato corrente del cluster verso lo stato desiderato.<h2 id=il-modello-del-controller>Il modello del controller</h2><p>Un <em>controller</em> monitora almeno una tipo di risorsa registrata in Kubernetes.
Questi <a href=/docs/concepts/overview/working-with-objects/kubernetes-objects/#kubernetes-objects>oggetti</a> hanno una proprietà chiamata <em>spec</em> (specifica) che rappresenta lo stato desiderato. Il o i <em>controller</em> per quella risorsa sono responsabili di mantenere lo stato corrente il più simile possibile rispetto allo stato desiderato.</p><p>Il <em>controller</em> potrebbe eseguire l'azione relativa alla risorsa in questione da sé; più comunemente, in Kubernetes, un <em>controller</em> invia messaggi all'<a class=glossary-tooltip title='Componente della Control plane che serve le Kubernetes API.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-apiserver/ target=_blank aria-label='API server'>API server</a> che a sua volta li rende disponibili ad altri componenti nel cluster. Di seguito troverete esempi per questo scenario.</p><h3 id=controllo-attraverso-l-api-server>Controllo attraverso l'API server</h3><p>Il <a class=glossary-tooltip title='Uno o più lavori (task) che vengono eseguiti fino al loro completamento.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/jobs-run-to-completion target=_blank aria-label=Job>Job</a> <em>controller</em> è un esempio di un <em>controller</em> nativo in Kubernetes. I <em>controller</em> nativi gestiscono lo stato interagendo con l'API server presente nel cluster.</p><p>Il Job è una risorsa di Kubernetes che lancia uno o più <a class=glossary-tooltip title='Un Pod rappresenta un gruppo di container nel tuo cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a> per eseguire un lavoro (task) e poi fermarsi.</p><p>(Una volta che è stato <a href=/docs/concepts/scheduling-eviction/>schedulato</a>, un oggetto <em>Pod</em> diventa parte dello stato desisderato di un dato <em>kubelet</em>).</p><p>Quando il Job <em>controller</em> vede un nuovo lavoro da svolgere si assicura che, da qualche parte nel cluster, i <em>kubelet</em> anche sparsi su più nodi eseguano il numero corretto di <em>Pod</em> necessari per eseguire il lavoro richiesto. Il Job <em>controller</em> non esegue direttamente alcun <em>Pod</em> o <em>container</em> bensì chiede all'API server di creare o rimuovere i <em>Pod</em>. Altri componenti appartenenti al <a class=glossary-tooltip title="Lo strato per l'orchestrazione dei container che espone le API e interfaccie per definere, deploy, e gestione del ciclo di vita dei container." data-toggle=tooltip data-placement=top href='/it/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='control plane'>control plane</a> reagiscono in base alle nuove informazioni (ci sono nuovi <em>Pod</em> da creare e gestire) e cooperano al completamento del job.</p><p>Dopo che un nuovo Job è stato creato, lo stato desiderato per quel Job è il suo completamento. Il Job <em>controller</em> fa sì che lo stato corrente per quel Job sia il più vicino possibile allo stato desiderato: creare <em>Pod</em> che eseguano il lavoro che deve essere effettuato attraverso il Job, così che il Job sia prossimo al completamento.</p><p>I <em>controller</em> aggiornano anche gli oggetti che hanno configurato. Ad esempio: una volta che il lavoro relativo ad un dato Job è stato completato, il Job <em>controller</em> aggiorna l'oggetto Job segnandolo come <code>Finished</code>.</p><p>(Questo è simile allo scenario del termostato che spegne un certo led per indicare che ora la stanza ha raggiungo la temperatura impostata)</p><h3 id=controllo-diretto>Controllo diretto</h3><p>A differenza del Job, alcuni <em>controller</em> devono eseguire delle modifiche a parti esterne al cluster.</p><p>Per esempio, se viene usato un circuito di controllo per assicurare che ci sia un numero sufficiente di <a class=glossary-tooltip title='Un node è una macchina worker in Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/nodes/ target=_blank aria-label=Nodi>Nodi</a> nel cluster, allora il <em>controller</em> ha bisogno che qualcosa al di fuori del cluster configuri i nuovi <em>Nodi</em> quando sarà necessario.</p><p>I <em>controller</em> che interagiscono con un sistema esterno trovano il loro stato desiderato attraverso l'API server, quindi comunicano direttamente con un sistema esterno per portare il loro stato corrente più in linea possibile con lo stato desiderato</p><p>(In realtà c'è un <em>controller</em> che scala orizzontalmente i nodi nel cluster. Vedi <a href=/docs/tasks/administer-cluster/cluster-management/#cluster-autoscaling>Cluster autoscaling</a>).</p><h2 id=desiderato-vs-corrente>Stato desiderato versus corrente</h2><p>Kubernetes ha una visione <em>cloud-native</em> dei sistemi, ed è in grado di gestire continue modifiche.</p><p>Il cluster viene modificato continuamente durante la sua attività ed il <em>circuito di controllo</em> è in grado di risolvere automaticamente i possibili guasti.</p><p>Fino a che i <em>controller</em> del cluster sono in funzione ed in grado di apportare le dovute modifiche, non è rilevante che lo stato complessivo del cluster sia o meno stabile.</p><h2 id=progettazione>Progettazione</h2><p>Come cardine della sua progettazione, Kubernetes usa vari <em>controller</em> ognuno dei quali è responsabile per un particolare aspetto dello stato del cluster. Più comunemente, un dato <em>circuito di controllo</em> (<em>controller</em>) usa un tipo di risorsa per il suo stato desiderato, ed utilizza anche risorse di altro tipo per raggiungere questo stato desiderato. Per esempio il Job <em>controller</em> tiene traccia degli oggetti di tipo <em>Job</em> (per scoprire nuove attività da eseguire) e degli oggetti di tipo <em>Pod</em> (questi ultimi usati per eseguire i <em>Job</em>, e quindi per controllare quando il loro lavoro è terminato). In questo caso, qualcos'altro crea i <em>Job</em>, mentre il <em>Job</em> <em>controller</em> crea i <em>Pod</em>.</p><p>È utile avere semplici <em>controller</em> piuttosto che un unico, monolitico, <em>circuito di controllo</em>. I <em>controller</em> possono guastarsi, quindi Kubernetes è stato disegnato per gestire questa eventualità.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong><p>Ci possono essere diversi <em>controller</em> che creato o aggiornano lo stesso tipo di oggetti. Dietro le quinte, i <em>controller</em> di Kubernetes si preoccupano esclusivamente delle risorse (di altro tipo) collegate alla risorsa primaria da essi controllata.</p><p>Per esempio, si possono avere <em>Deployment</em> e <em>Job</em>; entrambe creano <em>Pod</em>. Il Job <em>controller</em> non distrugge i <em>Pod</em> creati da un <em>Deployment</em>, perché ci sono informazioni (<em><a class=glossary-tooltip title='Tags di oggetti con attributi identificativi che sono significativi e pertinenti per gli utenti.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/labels target=_blank aria-label=labels>labels</a></em>) che vengono usate dal <em>controller</em> per distinguere i <em>Pod</em>.</p></div><h2 id=eseguire-controller>I modi per eseguire i <em>controller</em></h2><p>Kubernetes annovera un insieme di <em>controller</em> nativi che sono in esecuzione all'interno del <a class=glossary-tooltip title='Componente della Control Plane che gestisce i controller.' data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-controller-manager/ target=_blank aria-label=kube-controller-manager>kube-controller-manager</a>. Questi <em>controller</em> nativi forniscono importanti funzionalità di base.</p><p>Il Deployment <em>controller</em> ed il Job <em>controller</em> sono esempi di <em>controller</em> che vengono forniti direttamente da Kubernetes stesso (ovvero <em>controller</em> "nativi").
Kubernetes consente di eseguire un <em>piano di controllo</em>(<em>control plane</em>) resiliente, di modo che se un dei <em>controller</em> nativi dovesse fallire, un'altra parte del piano di controllo si occuperà di eseguire quel lavoro.</p><p>Al fine di estendere Kubernetes, si possono avere <em>controller</em> in esecuzione al di fuori del piano di controllo. Oppure, se si desidera, è possibile scriversi un nuovo <em>controller</em>. È possibile eseguire il proprio controller come una serie di <em>Pod</em>, oppure esternamente rispetto a Kubernetes. Quale sia la soluzione migliore, dipende dalla responsabilità di un dato controller.</p><h2 id=voci-correlate>Voci correlate</h2><ul><li>Leggi in merito <a href=/docs/concepts/#kubernetes-control-plane>Kubernetes control plane</a></li><li>Scopri alcune delle basi degli <a href=/docs/concepts/#kubernetes-objects>oggetti di Kubernetes</a></li><li>Per saperne di più riguardo alle <a href=/docs/concepts/overview/kubernetes-api/>API di Kubernetes</a></li><li>Se vuoi creare un tuo <em>controller</em>, guarda <a href=/docs/concepts/extend-kubernetes/extend-cluster/#extension-patterns>i modelli per l'estensibilità</a> in Estendere Kubernetes.</li></ul></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/it/docs/home/>Home</a>
<a class=text-white href=/it/blog/>Blog</a>
<a class=text-white href=/it/training/>Formazione</a>
<a class=text-white href=/it/partners/>Partner</a>
<a class=text-white href=/it/community/>Community</a>
<a class=text-white href=/it/case-studies/>Casi di Studio</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 Gli autori di Kubernetes | Documentazione distribuita sotto <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small><br><small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. Tutti i diritti riservati. The Linux Foundation ha marchi registrati e utilizza marchi commerciali. Per un elenco dei marchi di Linux Foundation, consulta la <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>pagina sull'utilizzo dei marchi</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>