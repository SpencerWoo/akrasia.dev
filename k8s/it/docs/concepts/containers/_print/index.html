<!doctype html><html lang=it class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=en href=https://kubernetes.io/docs/concepts/containers/><link rel=alternate hreflang=zh-cn href=https://kubernetes.io/zh-cn/docs/concepts/containers/><link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/concepts/containers/><link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/concepts/containers/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/concepts/containers/><link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/concepts/containers/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/concepts/containers/><link rel=alternate hreflang=pt-br href=https://kubernetes.io/pt-br/docs/concepts/containers/><link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/concepts/containers/><link rel=alternate hreflang=vi href=https://kubernetes.io/vi/docs/concepts/containers/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/it/docs/concepts/containers/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>Containers | Kubernetes</title><meta property="og:title" content="Containers"><meta property="og:description" content="La tecnologia per distribuire un'applicazione insieme con le dipendenze necessarie per la sua esecuzione."><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/it/docs/concepts/containers/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="Containers"><meta itemprop=description content="La tecnologia per distribuire un'applicazione insieme con le dipendenze necessarie per la sua esecuzione."><meta name=twitter:card content="summary"><meta name=twitter:title content="Containers"><meta name=twitter:description content="La tecnologia per distribuire un'applicazione insieme con le dipendenze necessarie per la sua esecuzione."><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content="La tecnologia per distribuire un'applicazione insieme con le dipendenze necessarie per la sua esecuzione."><meta property="og:description" content="La tecnologia per distribuire un'applicazione insieme con le dipendenze necessarie per la sua esecuzione."><meta name=twitter:description content="La tecnologia per distribuire un'applicazione insieme con le dipendenze necessarie per la sua esecuzione."><meta property="og:url" content="https://kubernetes.io/it/docs/concepts/containers/"><meta property="og:title" content="Containers"><meta name=twitter:title content="Containers"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/it/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/it/docs/>Documentazione</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/it/blog/>Blog di Kubernetes</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/it/training/>Formazione</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/it/partners/>Partner</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/it/community/>Community</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/it/case-studies/>Casi di Studio</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Versions</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/it/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/it/docs/concepts/containers/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/it/docs/concepts/containers/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/it/docs/concepts/containers/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/it/docs/concepts/containers/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/it/docs/concepts/containers/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Italiano (Italian)</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/docs/concepts/containers/>English</a>
<a class=dropdown-item href=/zh-cn/docs/concepts/containers/>中文 (Chinese)</a>
<a class=dropdown-item href=/ko/docs/concepts/containers/>한국어 (Korean)</a>
<a class=dropdown-item href=/ja/docs/concepts/containers/>日本語 (Japanese)</a>
<a class=dropdown-item href=/fr/docs/concepts/containers/>Français (French)</a>
<a class=dropdown-item href=/de/docs/concepts/containers/>Deutsch (German)</a>
<a class=dropdown-item href=/es/docs/concepts/containers/>Español (Spanish)</a>
<a class=dropdown-item href=/pt-br/docs/concepts/containers/>Português (Portuguese)</a>
<a class=dropdown-item href=/id/docs/concepts/containers/>Bahasa Indonesia</a>
<a class=dropdown-item href=/vi/docs/concepts/containers/>Tiếng Việt (Vietnamese)</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>This is the multi-page printable view of this section.
<a href=# onclick="return print(),!1">Click here to print</a>.</p><p><a href=/it/docs/concepts/containers/>Return to the regular view of this page</a>.</p></div><h1 class=title>Containers</h1><div class=lead>La tecnologia per distribuire un'applicazione insieme con le dipendenze necessarie per la sua esecuzione.</div><ul><li>1: <a href=#pg-16042b4652ad19e565c7263824029a43>Immagini</a></li><li>2: <a href=#pg-643212488f778acf04bebed65ba34441>Container Environment</a></li><li>3: <a href=#pg-e6941d969d81540208a3e78bc56f43bc>Container Lifecycle Hooks</a></li></ul><div class=content><p>Ogni <em>container</em> che viene eseguito è riproducibile; la pratica di includere le dipendenze all'interno di ciascuno <em>container</em> permette di ottenere sempre lo stesso risultato ad ogni esecuzione del medesimo <em>container</em>.</p><p>I <em>Container</em> permettono di disaccoppiare le applicazioni dall'infrastruttura del host su cui vengono eseguite. Questo approccio rende più facile il <em>deployment</em> su cloud o sitemi operativi differenti tra loro.</p><h2 id=immagine-di-container>Immagine di container</h2><p>L'<a href=/docs/concepts/containers/images/>immagine di un container</a> e' un pacchetto software che contiene tutto ciò che serve per eseguire un'applicazione: il codice sorgente e ciascun <em>runtime</em> necessario, librerie applicative e di sistema, e le impostazioni predefinite per ogni configurazione necessaria.</p><p>Un <em>container</em> è immutabile per definizione: non è possibile modificare il codice di un <em>container</em> in esecuzione. Se si ha un'applicazione containerizzata e la si vuole modificare, si deve costruire un nuovo <em>container</em> che includa il cambiamento desiderato, e quindi ricreare il <em>container</em> partendo dalla nuova immagine aggiornata.</p><h2 id=container-runtimes>Container runtimes</h2><p>Il container runtime è il software che è responsabile per l'esecuzione dei container.</p><p>Kubernetes supporta diversi container runtimes: <a href=http://www.docker.com>Docker</a>,
<a href=https://containerd.io>containerd</a>, <a href=https://cri-o.io/>cri-o</a>,
<a href=https://github.com/kubernetes-incubator/rktlet>rktlet</a> e tutte le implementazioni di
<a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-node/container-runtime-interface.md>Kubernetes CRI (Container Runtime Interface)</a>.</p><h2 id=voci-correlate>Voci correlate</h2><ul><li>Leggi in merito <a href=/docs/concepts/containers/images/>immagine di container</a></li><li>Leggi in merito <a href=/docs/concepts/workloads/pods/>Pods</a></li></ul></div></div><div class=td-content style=page-break-before:always><h1 id=pg-16042b4652ad19e565c7263824029a43>1 - Immagini</h1><p>L'immagine di un container rappresenta dati binari che incapsulano un'applicazione e
tutte le sue dipendenze software. Le immagini sono costituite da pacchetti software
eseguibili che possono essere avviati in modalità standalone e su cui si possono fare
ipotesi ben precise circa l'ambiente in cui vengono eseguiti.</p><p>Tipicamente viene creata un'immagine di un'applicazione ed effettuato il <em>push</em>
su un registry (un repository pubblico di immagini) prima di poterne fare riferimento esplicito in un
<a class=glossary-tooltip title='Un Pod rappresenta un gruppo di container nel tuo cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a></p><p>Questa pagina va a delineare nello specifico il concetto di immagine di un container.</p><h2 id=i-nomi-delle-immagini>I nomi delle immagini</h2><p>Alle immagini dei container vengono normalmente attribuiti nomi come <code>pause</code>, <code>example/mycontainer</code>, o <code>kube-apiserver</code>.
Le immagini possono anche contenere l'hostname del registry in cui le immagini sono pubblicate;
ad esempio: <code>registro.fittizio.esempio/nomeimmagine</code>,
ed è possibile che sia incluso nel nome anche il numero della porta; ad esempio: <code>registro.fittizio.esempio:10443/nomeimmagine</code>.</p><p>Se non si specifica l'hostname di un registry, Kubernetes assume che ci si riferisca al registry pubblico di Docker.</p><p>Dopo la parte relativa al nome dell'immagine si può aggiungere un <em>tag</em> (come comunemente avviene per comandi come <code>docker</code> e <code>podman</code>).
I tag permettono l'identificazione di differenti versioni della stessa serie di immagini.</p><p>I tag delle immagini sono composti da lettere minuscole e maiuscole, numeri, underscore (<code>_</code>),
punti (<code>.</code>), e trattini (<code>-</code>).<br>Esistono regole aggiuntive relative a dove i caratteri separatori (<code>_</code>, <code>-</code>, and <code>.</code>)
possano essere inseriti nel tag di un'immagine.
Se non si specifica un tag, Kubernetes assume il tag <code>latest</code> che va a definire l'immagine disponibile più recente.</p><div class="alert alert-warning caution callout" role=alert><strong>Attenzione:</strong><p>Evitate di utilizzare il tag <code>latest</code> quando si rilasciano dei container in produzione,
in quanto risulta difficile tracciare quale versione dell'immagine sia stata avviata e persino più difficile
effettuare un rollback ad una versione precente.</p><p>Invece, meglio specificare un tag specifico come ad esempio <code>v1.42.0</code>.</p></div><h2 id=aggiornamento-delle-immagini>Aggiornamento delle immagini</h2><p>Quando un <a class=glossary-tooltip title='Gestisce una applicazione replicata nel tuo cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Deployment>Deployment</a>,
<a class=glossary-tooltip title='Gestisce deployment e la scalabilità di un gruppo di Pod, con storage e identificativi persistenti per ogni Pod.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/statefulset/ target=_blank aria-label=StatefulSet>StatefulSet</a>, Pod, o qualsiasi altro
oggetto che includa un Pod template viene creato per la prima volta, la policy di default per il pull di tutti i container nel Pod
è impostata su <code>IfNotPresent</code> (se non presente) se non specificato diversamente.
Questa policy permette al
<a class=glossary-tooltip title='Un agente che è eseguito su ogni nodo del cluster. Si assicura che i container siano eseguiti in un pod.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a> di evitare di fare il pull
di un'immagine se questa è già presente.</p><p>Se necessario, si può forzare il pull in ogni occasione in uno dei seguenti modi:</p><ul><li>impostando <code>imagePullPolicy</code> (specifica per il pull delle immagini) del container su <code>Always</code> (sempre).</li><li>omettendo <code>imagePullPolicy</code> ed usando il tag <code>:latest</code> (più recente) per l'immagine da utilizzare;
Kubernetes imposterà la policy su <code>Always</code> (sempre).</li><li>omettendo <code>imagePullPolicy</code> ed il tag per l'immagine da utilizzare.</li><li>abilitando l'admission controller <a href=/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages>AlwaysPullImages</a>.</li></ul><div class="alert alert-info note callout" role=alert><strong>Nota:</strong><p>Il valore dell'impostazione <code>imagePullPolicy</code> del container è sempre presente quando l'oggetto viene creato per la prima volta
e non viene aggiornato se il tag dell'immagine dovesse cambiare successivamente.</p><p>Ad esempio, creando un Deployment con un'immagine il cui tag <em>non</em> è
<code>:latest</code>, e successivamente aggiornando il tag di quell'immagine a <code>:latest</code>, il campo
<code>imagePullPolicy</code> <em>non</em> cambierà su <code>Always</code>.
È necessario modificare manualmente la policy di pull di ogni oggetto dopo la sua creazione.</p></div><p>Quando <code>imagePullPolicy</code> è definito senza un valore specifico, esso è impostato su <code>Always</code>.</p><h2 id=multi-architecture-support-nelle-immagini>Multi-architecture support nelle immagini</h2><p>Oltre a fornire immagini binarie, un <em>container registry</em> può fornire un <a href=https://github.com/opencontainers/image-spec/blob/master/image-index.md>indice delle immagini disponibili per un container</a>.
L'indice di un'immagine può puntare a più <a href=https://github.com/opencontainers/image-spec/blob/master/manifest.md>file manifest</a> ciascuno per una versione specifica dell'architettura di un container.
L'idea è che si può avere un unico nome per una stessa immagine (ad esempio: <code>pause</code>, <code>example/mycontainer</code>, <code>kube-apiserver</code>) e permettere a diversi sistemi di recuperare l'immagine binaria corretta a seconda dell'architettura della macchina che la sta utilizzando.</p><p>Kubernetes stesso tipicamente nomina le immagini dei container tramite il suffisso <code>-$(ARCH)</code>.
Per la garantire la retrocompatibilità è meglio generare le vecchie immagini con dei suffissi.
L'idea è quella di generare, ad esempio, l'immagine <code>pause</code> con un manifest che include tutte le architetture supportate,
affiancata, ad esempio, da <code>pause-amd64</code> che è retrocompatibile per le vecchie configurazioni o per quei file YAML
in cui sono specificate le immagini con i suffissi.</p><h2 id=utilizzare-un-private-registry>Utilizzare un private registry</h2><p>I private registry possono richiedere l'utilizzo di chiavi per accedere alle immagini in essi contenute.<br>Le credenziali possono essere fornite in molti modi:</p><ul><li>configurando i nodi in modo tale da autenticarsi al private registry<ul><li>tutti i pod possono acquisire informazioni da qualsiasi private registry configurato</li><li>è necessario che l'amministratore del cluster configuri i nodi in tal senso</li></ul></li><li>tramite pre-pulled images (immagini pre-caricate sui nodi)<ul><li>tutti i pod possono accedere alle immagini salvate sulla cache del nodo a cui si riferiscono</li><li>è necessario effettuare l'accesso come root di sistema su ogni nodo per inserire questa impostazione</li></ul></li><li>specificando <em>ImagePullSecrets</em> su un determinato pod<ul><li>solo i pod che forniscono le proprie chiavi hanno la possibilità di accedere al private registry</li></ul></li><li>tramite estensioni locali o specifiche di un <em>Vendor</em><ul><li>se si sta utilizzando una configurazione personalizzata del nodo oppure se manualmente, o tramite il <em>cloud provider</em>,
si implementa un meccanismo di autenticazione del nodo presso il <em>container registry</em>.</li></ul></li></ul><p>Di seguito la spiegazione dettagliata di queste opzioni.</p><h3 id=configurazione-dei-nodi-per-l-autenticazione-ad-un-private-registry>Configurazione dei nodi per l'autenticazione ad un private registry</h3><p>Se si sta utilizzando Docker sui nodi, si può configurare il <em>Docker container runtime</em>
per autenticare il nodo presso un private container registry.</p><p>Questo è un approccio possibile se si ha il controllo sulle configurazioni del nodo.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Kubernetes di default supporta solo le sezioni <code>auths</code> e <code>HttpHeaders</code> nelle configurazioni relative a Docker.
Eventuali <em>helper</em> per le credenziali di Docker (<code>credHelpers</code> o <code>credsStore</code>) non sono supportati.</div><p>Docker salva le chiavi per i registri privati in <code>$HOME/.dockercfg</code> oppure nel file <code>$HOME/.docker/config.json</code>.
Inserendo lo stesso file nella lista seguente, kubelet lo utilizzerà per recuperare le credenziali quando deve fare il <em>pull</em> delle immagini.</p><ul><li><code>{--root-dir:-/var/lib/kubelet}/config.json</code></li><li><code>{cwd of kubelet}/config.json</code></li><li><code>${HOME}/.docker/config.json</code></li><li><code>/.docker/config.json</code></li><li><code>{--root-dir:-/var/lib/kubelet}/.dockercfg</code></li><li><code>{cwd of kubelet}/.dockercfg</code></li><li><code>${HOME}/.dockercfg</code></li><li><code>/.dockercfg</code></li></ul><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Potrebbe essere necessario impostare <code>HOME=/root</code> esplicitamente come variabile d'ambiente del processo <em>kubelet</em>.</div><p>Di seguito i passi consigliati per configurare l'utilizzo di un private registry da parte dei nodi del <em>cluster</em>.
In questo esempio, eseguire i seguenti comandi sul proprio desktop/laptop:</p><ol><li>Esegui <code>docker login [server]</code> per ogni <em>set</em> di credenziali che vuoi utilizzare. Questo comando aggiornerà <code>$HOME/.docker/config.json</code> sul tuo PC.</li><li>Controlla il file <code>$HOME/.docker/config.json</code> in un editor di testo per assicurarti che contenga le credenziali che tu voglia utilizzare.</li><li>Recupera la lista dei tuoi nodi; ad esempio:<ul><li>se vuoi utilizzare i nomi: <code>nodes=$( kubectl get nodes -o jsonpath='{range.items[*].metadata}{.name} {end}' )</code></li><li>se vuoi recuperare gli indirizzi IP: <code>nodes=$( kubectl get nodes -o jsonpath='{range .items[*].status.addresses[?(@.type=="ExternalIP")]}{.address} {end}' )</code></li></ul></li><li>Copia il tuo file locale <code>.docker/config.json</code> in uno dei path sopra riportati nella lista di ricerca.<ul><li>ad esempio, per testare il tutto: <code>for n in $nodes; do scp ~/.docker/config.json root@"$n":/var/lib/kubelet/config.json; done</code></li></ul></li></ol><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Per i cluster di produzione, utilizza un configuration management tool per poter applicare le impostazioni su tutti i nodi laddove necessario.</div><p>Puoi fare una verifica creando un Pod che faccia uso di un'immagine privata; ad esempio:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f - <span style=color:#b44>&lt;&lt;EOF
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: Pod
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: private-image-test-1
</span></span></span><span style=display:flex><span><span style=color:#b44>spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>  containers:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - name: uses-private-image
</span></span></span><span style=display:flex><span><span style=color:#b44>      image: $PRIVATE_IMAGE_NAME
</span></span></span><span style=display:flex><span><span style=color:#b44>      imagePullPolicy: Always
</span></span></span><span style=display:flex><span><span style=color:#b44>      command: [ &#34;echo&#34;, &#34;SUCCESS&#34; ]
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><pre tabindex=0><code>pod/private-image-test-1 created
</code></pre><p>Se tutto funziona correttamente, pochi istanti dopo, si può lanciare il comando:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl logs private-image-test-1
</span></span></code></pre></div><p>e verificare che il comando restituisca in output:</p><pre tabindex=0><code>SUCCESS
</code></pre><p>Qualora si sospetti che il comando sia fallito, si può eseguire:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe pods/private-image-test-1 | grep <span style=color:#b44>&#39;Failed&#39;</span>
</span></span></code></pre></div><p>In caso di fallimento, l'output sarà simile al seguente:</p><pre tabindex=0><code>  Fri, 26 Jun 2015 15:36:13 -0700    Fri, 26 Jun 2015 15:39:13 -0700    19    {kubelet node-i2hq}    spec.containers{uses-private-image}    failed        Failed to pull image &#34;user/privaterepo:v1&#34;: Error: image user/privaterepo:v1 not found
</code></pre><p>Bisogna assicurarsi che tutti i nodi nel cluster abbiano lo stesso file <code>.docker/config.json</code>.
Altrimenti i pod funzioneranno correttamente su alcuni nodi ma falliranno su altri.
Ad esempio, se si utilizza l'autoscaling per i nodi, il template di ogni istanza
devono includere il file <code>.docker/config.json</code> oppure montare un disco che lo contenga.</p><p>Tutti i pod avranno accesso in lettura alle immagini presenti nel private registry
una volta che le rispettive chiavi di accesso siano state aggiunte nel file <code>.docker/config.json</code>.</p><h3 id=immagini-pre-pulled>Immagini pre-pulled</h3><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Questo approccio è possibile se si ha il controllo sulla configurazione del nodo.
Non funzionerà qualora il cloud provider gestisca i nodi e li sostituisca automaticamente.</div><p>Kubelet di default prova a fare il pull di ogni immagine dal registry specificato.
Tuttavia, qualora la proprietà <code>imagePullPolicy</code> (specifica di pull dell'immagine) del container sia impostata su <code>IfNotPresent</code> (vale a dire, se non è già presente) oppure su <code>Never</code> (mai),
allora l'immagine locale è utilizzata (in via preferenziale o esclusiva, rispettivamente).</p><p>Se si vuole fare affidamento a immagini pre-scaricate per non dover incorrere in una fase di autenticazione presso il registry,
bisogna assicurarsi che tutti i nodi nel cluster abbiano scaricato le stesse versioni delle immagini.</p><p>Questa procedura può essere utilizzata per accelerare il processo di creazione delle istanze o come alternativa all'autenticazione presso un private registry.</p><p>Tutti i pod avranno accesso in lettura a qualsiasi immagine pre-scaricata.</p><h3 id=specificare-la-proprietà-imagepullsecrets-su-un-pod>Specificare la proprietà imagePullSecrets su un Pod</h3><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> Questo approccio è quello consigliato per l'avvio di container a partire da immagini presenti in registri privati.</div><p>Kubernetes da la possibilità di specificare le chiavi del <em>container registry</em> su un Pod.</p><h4 id=creare-un-secret-tramite-docker-config>Creare un Secret tramite Docker config</h4><p>Esegui il comando seguente, sostituendo i valori riportati in maiuscolo con quelli corretti:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret docker-registry &lt;name&gt; --docker-server<span style=color:#666>=</span>DOCKER_REGISTRY_SERVER --docker-username<span style=color:#666>=</span>DOCKER_USER --docker-password<span style=color:#666>=</span>DOCKER_PASSWORD --docker-email<span style=color:#666>=</span>DOCKER_EMAIL
</span></span></code></pre></div><p>Se possiedi il file delle credenziali per Docker, anziché utilizzare il comando quì sopra
puoi importare il file di credenziali come un Kubernetes
<a class=glossary-tooltip title='Contiene informazioni sensibili, come passwords, token OAuth, e chiavi ssh.' data-toggle=tooltip data-placement=top href='/it/docs/reference/glossary/?all=true#term-secret' target=_blank aria-label=Secrets>Secrets</a>.<br><a href=/docs/tasks/configure-pod-container/pull-image-private-registry/#registry-secret-existing-credentials>Creare un Secret a partire da credenziali Docker</a> fornisce la spiegazione dettagliata su come fare.</p><p>Ciò è particolarmente utile se si utilizzano più <em>container registry</em> privati,
in quanto il comando <code>kubectl create secret docker-registry</code> genera un Secret che
funziona con un solo private registry.</p><div class="alert alert-info note callout" role=alert><strong>Nota:</strong> I Pod possono fare riferimento ai Secret per il pull delle immagini soltanto nel proprio <em>namespace</em>,
quindi questo procedimento deve essere svolto per ogni <em>namespace</em>.</div><h4 id=fare-riferimento-ad-imagepullsecrets-in-un-pod>Fare riferimento ad imagePullSecrets in un Pod</h4><p>È possibile creare pod che referenzino quel Secret aggiungendo la sezione <code>imagePullSecrets</code> alla definizione del Pod.</p><p>Ad esempio:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt; pod.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: Pod
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: foo
</span></span></span><span style=display:flex><span><span style=color:#b44>  namespace: awesomeapps
</span></span></span><span style=display:flex><span><span style=color:#b44>spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>  containers:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - name: foo
</span></span></span><span style=display:flex><span><span style=color:#b44>      image: janedoe/awesomeapp:v1
</span></span></span><span style=display:flex><span><span style=color:#b44>  imagePullSecrets:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - name: myregistrykey
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt;&gt; ./kustomization.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>resources:
</span></span></span><span style=display:flex><span><span style=color:#b44>- pod.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>Questo deve esser fatto per ogni Pod che utilizzi un private registry.</p><p>Comunque, le impostazioni relative a questo campo possono essere automatizzate inserendo la sezione <em>imagePullSecrets</em>
nella definizione della risorsa <a href=/docs/tasks/configure-pod-container/configure-service-account/>ServiceAccount</a>.</p><p>Visitare la pagina <a href=/docs/tasks/configure-pod-container/configure-service-account/#add-imagepullsecrets-to-a-service-account>Aggiungere ImagePullSecrets ad un Service Account</a> per istruzioni più dettagliate.</p><p>Puoi utilizzarlo in congiunzione al file <code>.docker/config.json</code> configurato per ogni nodo. In questo caso, si applicherà un <em>merge</em> delle credenziali.</p><h2 id=casi-d-uso>Casi d'uso</h2><p>Ci sono varie soluzioni per configurare i private registry. Di seguito, alcuni casi d'uso comuni e le soluzioni suggerite.</p><ol><li>Cluster in cui sono utilizzate soltanto immagini non proprietarie (ovvero <em>open-source</em>). In questo caso non sussiste il bisogno di nascondere le immagini.<ul><li>Utilizza immagini pubbliche da Docker hub.<ul><li>Nessuna configurazione richiesta.</li><li>Alcuni <em>cloud provider</em> mettono in <em>cache</em> o effettuano il <em>mirror</em> di immagini pubbliche, il che migliora la disponibilità delle immagini e ne riduce il tempo di <em>pull</em>.</li></ul></li></ul></li><li>Cluster con container avviati a partire da immagini proprietarie che dovrebbero essere nascoste a chi è esterno all'organizzazione, ma
visibili a tutti gli utenti abilitati nel cluster.<ul><li>Utilizza un private <a href=https://docs.docker.com/registry/>Docker registry</a>.<ul><li>Esso può essere ospitato da <a href=https://hub.docker.com/signup>Docker Hub</a>, o da qualche altra piattaforma.</li><li>Configura manualmente il file .docker/config.json su ogni nodo come descritto sopra.</li></ul></li><li>Oppure, avvia un private registry dietro il tuo firewall con accesso in lettura libero.<ul><li>Non è necessaria alcuna configurazione di Kubernetes.</li></ul></li><li>Utilizza un servizio di <em>container registry</em> che controlli l'accesso alle immagini<ul><li>Esso funzionerà meglio con una configurazione del cluster basata su <em>autoscaling</em> che con una configurazione manuale del nodo.</li></ul></li><li>Oppure, su un cluster dove la modifica delle configurazioni del nodo non è conveniente, utilizza <code>imagePullSecrets</code>.</li></ul></li><li>Cluster con immagini proprietarie, alcune delle quali richiedono un controllo sugli accessi.<ul><li>Assicurati che l'<em>admission controller</em> <a href=/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages>AlwaysPullImages</a> sia attivo. Altrimenti, tutti i Pod potenzialmente possono avere accesso a tutte le immagini.</li><li>Sposta i dati sensibili un un <em>Secret</em>, invece di inserirli in un'immagine.</li></ul></li><li>Un cluster multi-tenant dove ogni tenant necessiti di un private registry.<ul><li>Assicurati che l'<em>admission controller</em> <a href=/docs/reference/access-authn-authz/admission-controllers/#alwayspullimages>AlwaysPullImages</a> sia attivo. Altrimenti, tutti i Pod di tutti i tenant potrebbero potenzialmente avere accesso a tutte le immagini.</li><li>Avvia un private registry che richieda un'autorizzazione all'accesso.</li><li>Genera delle credenziali di registry per ogni tenant, inseriscile in dei <em>Secret</em>, e popola i <em>Secret</em> per ogni <em>namespace</em> relativo ad ognuno dei tenant.</li><li>Il singolo tenant aggiunge così quel <em>Secret</em> all'impostazione <em>imagePullSecrets</em> di ogni <em>namespace</em>.</li></ul></li></ol><p>Se si ha la necessità di accedere a più registri, si può generare un <em>Secret</em> per ognuno di essi.
Kubelet farà il <em>merge</em> di ogni <code>imagePullSecrets</code> in un singolo file virtuale <code>.docker/config.json</code>.</p><h2 id=voci-correlate>Voci correlate</h2><ul><li>Leggi <a href=https://github.com/opencontainers/image-spec/blob/master/manifest.md>OCI Image Manifest Specification</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-643212488f778acf04bebed65ba34441>2 - Container Environment</h1><p>Questa pagina descrive le risorse disponibili nei Container eseguiti in Kubernetes.</p><h2 id=container-environment>Container environment</h2><p>Quando si esegue un Container in Kubernetes, le seguenti risorse sono rese disponibili:</p><ul><li>Un filesystem, composto dal file system dell'<a href=/docs/concepts/containers/images/>image</a> e da uno o più <a href=/docs/concepts/storage/volumes/>volumes</a>.</li><li>Una serie di informazioni sul Container stesso.</li><li>Una serie di informazioni sugli oggetti nel cluster.</li></ul><h3 id=informazioni-sul-container>Informazioni sul Container</h3><p>L' <em>hostname</em> di un Container è il nome del Pod all'interno del quale è eseguito il Container.
È consultabile tramite il comando <code>hostname</code> o tramite la funzione
<a href=http://man7.org/linux/man-pages/man2/gethostname.2.html><code>gethostname</code></a>
disponibile in libc.</p><p>Il nome del Pod e il namespace possono essere resi disponibili come environment variables attraverso l'uso
delle <a href=/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information/>downward API</a>.</p><p>Gli utenti possono aggiungere altre environment variables nella definizione del Pod; anche queste
saranno disponibili nel Container come tutte le altre environment variables definite staticamente nella
Docker image.</p><h3 id=informazioni-sul-cluster>Informazioni sul cluster</h3><p>Al momento della creazione del Container è generata una serie di environment variables con la lista di servizi in esecuzione nel cluster.
Queste environment variables rispettano la sintassi dei Docker links.</p><p>Per un servizio chiamato <em>foo</em> che è in esecuzione in un Container di nome <em>bar</em>,
le seguenti variabili sono generate:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#b8860b>FOO_SERVICE_HOST</span><span style=color:#666>=</span>&lt;host su cui il servizio è attivo&gt;
</span></span><span style=display:flex><span><span style=color:#b8860b>FOO_SERVICE_PORT</span><span style=color:#666>=</span>&lt;porta su cui il servizio è pubblicato&gt;
</span></span></code></pre></div><p>I servizi hanno un indirizzo IP dedicato e sono disponibili nei Container anche via DNS
se il <a href=http://releases.k8s.io/master/cluster/addons/dns/>DNS addon</a> è installato nel cluster.</p><h2 id=voci-correlate>Voci correlate</h2><ul><li>Approfondisci <a href=/docs/concepts/containers/container-lifecycle-hooks/>Container lifecycle hooks</a>.</li><li>Esegui un tutorial su come
<a href=/docs/tasks/configure-pod-container/attach-handler-lifecycle-event/>definire degli handlers per i Container lifecycle events</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-e6941d969d81540208a3e78bc56f43bc>3 - Container Lifecycle Hooks</h1><p>Questa pagina descrive come i Container gestiti con kubelet possono utilizzare il lifecycle
hook framework dei Container per l'esecuzione di codice eseguito in corrispondenza di alcuni
eventi durante il loro ciclo di vita.</p><h2 id=overview>Overview</h2><p>Analogamente a molti framework di linguaggi di programmazione che hanno degli hooks legati al ciclo di
vita dei componenti, come ad esempio Angular, Kubernetes fornisce ai Container degli hook legati al loro ciclo di
vita dei Container.
Gli hook consentono ai Container di essere consapevoli degli eventi durante il loro ciclo di
gestione ed eseguire del codice implementato in un handler quando il corrispondente hook viene
eseguito.</p><h2 id=container-hooks>Container hooks</h2><p>Esistono due tipi di hook che vengono esposti ai Container:</p><p><code>PostStart</code></p><p>Questo hook viene eseguito successivamente alla creazione del container.
Tuttavia, non vi è garanzia che questo hook venga eseguito prima dell'ENTRYPOINT del container.
Non vengono passati parametri all'handler.</p><p><code>PreStop</code></p><p>Questo hook viene eseguito prima della terminazione di un container a causa di una richiesta API o
di un evento di gestione, come ad esempio un fallimento delle sonde di liveness/startup, preemption,
risorse contese e altro. Una chiamata all'hook di <code>PreStop</code> fallisce se il container è in stato
terminated o completed e l'hook deve finire prima che possa essere inviato il segnale di TERM per
fermare il container. Il conto alla rovescia per la terminazione del Pod (grace period) inizia prima dell'esecuzione
dell'hook <code>PreStop</code>, quindi indipendentemente dall'esito dell'handler, il container terminerà entro
il grace period impostato. Non vengono passati parametri all'handler.</p><p>Una descrizione più dettagliata riguardante al processo di terminazione dei Pod può essere trovata in
<a href=/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination>Terminazione dei Pod</a>.</p><h3 id=implementazione-degli-hook-handler>Implementazione degli hook handler</h3><p>I Container possono accedere a un hook implementando e registrando un handler per tale hook.
Ci sono due tipi di handler che possono essere implementati per i Container:</p><ul><li>Exec - Esegue un comando specifico, tipo <code>pre-stop.sh</code>, all'interno dei cgroup e namespace del Container.
Le risorse consumate dal comando vengono contate sul Container.</li><li>HTTP - Esegue una richiesta HTTP verso un endpoint specifico del Container.</li></ul><h3 id=esecuzione-dell-hook-handler>Esecuzione dell'hook handler</h3><p>Quando viene richiamato l'hook legato al lifecycle del Container, il sistema di gestione di Kubernetes
esegue l'handler secondo l'azione dell'hook, <code>httpGet</code> e <code>tcpSocket</code> vengono eseguiti dal processo kubelet,
mentre <code>exec</code> è eseguito nel Container.</p><p>Le chiamate agli handler degli hook sono sincrone rispetto al contesto del Pod che contiene il Container.
Questo significa che per un hook <code>PostStart</code>, l'ENTRYPOINT e l'hook si attivano in modo asincrono.
Tuttavia, se l'hook impiega troppo tempo per essere eseguito o si blocca, il container non può raggiungere lo
stato di <code>running</code>.</p><p>Gli hook di <code>PreStop</code> non vengono eseguiti in modo asincrono dall'evento di stop del container; l'hook
deve completare la sua esecuzione prima che l'evento TERM possa essere inviato. Se un hook di <code>PreStop</code>
si blocca durante la sua esecuzione, la fase del Pod rimarrà <code>Terminating</code> finchè il Pod non sarà rimosso forzatamente
dopo la scadenza del suo <code>terminationGracePeriodSeconds</code>. Questo grace period si applica al tempo totale
necessario per effettuare sia l'esecuzione dell'hook di <code>PreStop</code> che per l'arresto normale del container.
Se, per esempio, il <code>terminationGracePeriodSeconds</code> è di 60, e l'hook impiega 55 secondi per essere completato,
e il container impiega 10 secondi per fermarsi normalmente dopo aver ricevuto il segnale, allora il container
verrà terminato prima di poter completare il suo arresto, poiché <code>terminationGracePeriodSeconds</code> è inferiore al tempo
totale (55+10) necessario perché queste due cose accadano.</p><p>Se un hook <code>PostStart</code> o <code>PreStop</code> fallisce, allora il container viene terminato.</p><p>Gli utenti dovrebbero mantenere i loro handler degli hook i più leggeri possibili.
Ci sono casi, tuttavia, in cui i comandi di lunga durata hanno senso,
come il salvataggio dello stato del container prima della sua fine.</p><h3 id=garanzia-della-chiamata-dell-hook>Garanzia della chiamata dell'hook</h3><p>La chiamata degli hook avviene <em>almeno una volta</em>, il che significa
che un hook può essere chiamato più volte da un dato evento, come per <code>PostStart</code>
o <code>PreStop</code>.
Sta all'implementazione dell'hook gestire correttamente questo aspetto.</p><p>Generalmente, vengono effettuate singole chiamate agli hook.
Se, per esempio, la destinazione di hook HTTP non è momentaneamente in grado di ricevere traffico,
non c'è alcun tentativo di re invio.
In alcuni rari casi, tuttavia, può verificarsi una doppia chiamata.
Per esempio, se un kubelet si riavvia nel mentre dell'invio di un hook, questo potrebbe essere
chiamato per una seconda volta dopo che il kubelet è tornato in funzione.</p><h3 id=debugging-hook-handlers>Debugging Hook handlers</h3><p>I log di un handler di hook non sono esposti negli eventi del Pod.
Se un handler fallisce per qualche ragione, trasmette un evento.
Per il <code>PostStart</code>, questo è l'evento di <code>FailedPostStartHook</code>,
e per il <code>PreStop</code>, questo è l'evento di <code>FailedPreStopHook</code>.
Puoi vedere questi eventi eseguendo <code>kubectl describe pod &lt;pod_name></code>.
Ecco alcuni esempi di output di eventi dall'esecuzione di questo comando:</p><pre tabindex=0><code>Events:
  FirstSeen  LastSeen  Count  From                                                   SubObjectPath          Type      Reason               Message
  ---------  --------  -----  ----                                                   -------------          --------  ------               -------
  1m         1m        1      {default-scheduler }                                                          Normal    Scheduled            Successfully assigned test-1730497541-cq1d2 to gke-test-cluster-default-pool-a07e5d30-siqd
  1m         1m        1      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}  spec.containers{main}  Normal    Pulling              pulling image &#34;test:1.0&#34;
  1m         1m        1      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}  spec.containers{main}  Normal    Created              Created container with docker id 5c6a256a2567; Security:[seccomp=unconfined]
  1m         1m        1      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}  spec.containers{main}  Normal    Pulled               Successfully pulled image &#34;test:1.0&#34;
  1m         1m        1      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}  spec.containers{main}  Normal    Started              Started container with docker id 5c6a256a2567
  38s        38s       1      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}  spec.containers{main}  Normal    Killing              Killing container with docker id 5c6a256a2567: PostStart handler: Error executing in Docker Container: 1
  37s        37s       1      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}  spec.containers{main}  Normal    Killing              Killing container with docker id 8df9fdfd7054: PostStart handler: Error executing in Docker Container: 1
  38s        37s       2      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}                         Warning   FailedSync           Error syncing pod, skipping: failed to &#34;StartContainer&#34; for &#34;main&#34; with RunContainerError: &#34;PostStart handler: Error executing in Docker Container: 1&#34;
  1m         22s       2      {kubelet gke-test-cluster-default-pool-a07e5d30-siqd}  spec.containers{main}  Warning   FailedPostStartHook
</code></pre><h2 id=voci-correlate>Voci correlate</h2><ul><li>Approfondisci <a href=/docs/concepts/containers/container-environment/>Container environment</a>.</li><li>Esegui un tutorial su come
<a href=/docs/tasks/configure-pod-container/attach-handler-lifecycle-event/>definire degli handlers per i Container lifecycle events</a>.</li></ul></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/it/docs/home/>Home</a>
<a class=text-white href=/it/blog/>Blog</a>
<a class=text-white href=/it/training/>Formazione</a>
<a class=text-white href=/it/partners/>Partner</a>
<a class=text-white href=/it/community/>Community</a>
<a class=text-white href=/it/case-studies/>Casi di Studio</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 Gli autori di Kubernetes | Documentazione distribuita sotto <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small><br><small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. Tutti i diritti riservati. The Linux Foundation ha marchi registrati e utilizza marchi commerciali. Per un elenco dei marchi di Linux Foundation, consulta la <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>pagina sull'utilizzo dei marchi</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>