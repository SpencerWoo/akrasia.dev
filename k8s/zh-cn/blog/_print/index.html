<!doctype html><html lang=zh-cn class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=en href=https://kubernetes.io/blog/><link rel=alternate hreflang=ko href=https://kubernetes.io/ko/blog/><link rel=alternate hreflang=ja href=https://kubernetes.io/ja/blog/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/blog/><link rel=alternate hreflang=it href=https://kubernetes.io/it/blog/><link rel=alternate hreflang=de href=https://kubernetes.io/de/blog/><link rel=alternate hreflang=es href=https://kubernetes.io/es/blog/><link rel=alternate hreflang=pt-br href=https://kubernetes.io/pt-br/blog/><link rel=alternate hreflang=vi href=https://kubernetes.io/vi/blog/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/zh-cn/blog/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>Kubernetes 博客 | Kubernetes</title><meta property="og:title" content="Kubernetes 博客"><meta property="og:description" content="生产级别的容器编排系统"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/zh-cn/blog/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="Kubernetes 博客"><meta itemprop=description content="生产级别的容器编排系统"><meta name=twitter:card content="summary"><meta name=twitter:title content="Kubernetes 博客"><meta name=twitter:description content="生产级别的容器编排系统"><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content><meta property="og:description" content><meta name=twitter:description content><meta property="og:url" content="https://kubernetes.io/zh-cn/blog/"><meta property="og:title" content="Kubernetes 博客"><meta name=twitter:title content="Kubernetes 博客"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class="td-section td-blog"><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/zh-cn/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/zh-cn/docs/>文档</a></li><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/zh-cn/blog/>Kubernetes 博客</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/zh-cn/training/>培训</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/zh-cn/partners/>合作伙伴</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/zh-cn/community/>社区</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/zh-cn/case-studies/>案例分析</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>版本列表</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/zh-cn/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/zh-cn/blog/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/zh-cn/blog/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/zh-cn/blog/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/zh-cn/blog/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/zh-cn/blog/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>中文 (Chinese)</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/blog/>English</a>
<a class=dropdown-item href=/ko/blog/>한국어 (Korean)</a>
<a class=dropdown-item href=/ja/blog/>日本語 (Japanese)</a>
<a class=dropdown-item href=/fr/blog/>Français (French)</a>
<a class=dropdown-item href=/it/blog/>Italiano (Italian)</a>
<a class=dropdown-item href=/de/blog/>Deutsch (German)</a>
<a class=dropdown-item href=/es/blog/>Español (Spanish)</a>
<a class=dropdown-item href=/pt-br/blog/>Português (Portuguese)</a>
<a class=dropdown-item href=/vi/blog/>Tiếng Việt (Vietnamese)</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><div class="col-12 col-md-3 col-xl-2 td-sidebar d-print-none"></div><div class="d-none d-xl-block col-xl-2 td-toc d-print-none"></div><main class="col-12 col-md-9 col-xl-8 pl-md-5 pr-md-4" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>这是本节的多页打印视图。
<a href=# onclick="return print(),!1">点击此处打印</a>.</p><p><a href=/zh-cn/blog/>返回本页常规视图</a>.</p></div><h1 class=title>Kubernetes 博客</h1><ul><li><a href=#pg-bf1922b98ad8e8052822beae9a70a8f1>“Kubernetes 1.25：对使用用户名字空间运行 Pod 提供 Alpha 支持”</a></li><li><a href=#pg-5d5c76001e146e082623ca40ad0ba359>Kubernetes 1.25：应用滚动上线所用的两个特性进入稳定阶段</a></li><li><a href=#pg-79bc80ce5d06b354e44386fba11b7106>Kubernetes 1.25：Pod 新增 PodHasNetwork 状况</a></li><li><a href=#pg-78b325b506faa9abe768d023258f7b89>宣布自动刷新官方 Kubernetes CVE 订阅源</a></li><li><a href=#pg-4a31e9aec55e0ae90074e6bdd81b9c99>COSI 简介：使用 Kubernetes API 管理对象存储</a></li><li><a href=#pg-460a70fa1a527a4befb165f9afbce331>Kubernetes 1.25: cgroup v2 升级到 GA</a></li><li><a href=#pg-9a6e963a54a0d5c3b3703691e8590810>Kubernetes 1.25：CSI 内联存储卷正式发布</a></li><li><a href=#pg-a3bb67281fa7ebc302189d5e5eb02b04>PodSecurityPolicy：历史背景</a></li><li><a href=#pg-b5f27644a48ad744c65da1d34d09f77c>Kubernetes v1.25: Combiner</a></li><li><a href=#pg-9dcab9859b750938304bf4369e15f67a>聚焦 SIG Storage</a></li><li><a href=#pg-6b8174d24c6f88a481cba57441cd7410>认识我们的贡献者 - 亚太地区（中国地区）</a></li><li><a href=#pg-521cdf1f63dab59d99d9a50b588c602a>逐个 KEP 地增强 Kubernetes</a></li><li><a href=#pg-7b77bba01cdcca4f5618d16f23009b6f>Kubernetes 1.25 的移除说明和主要变更</a></li><li><a href=#pg-ba41c0ba8b1baf0695e430635c1306f4>聚光灯下的 SIG Docs</a></li><li><a href=#pg-4e212b6d4e0507f556831f8314597a09>Kubernetes Gateway API 进入 Beta 阶段</a></li><li><a href=#pg-8388f5963039f090e850aa2aadaf4ec0>2021 年度总结报告</a></li><li><a href=#pg-a8f52f99f57e5984533e9703dbe2a42d>Kubernetes 1.24: StatefulSet 的最大不可用副本数</a></li><li><a href=#pg-342dc824bcac7b757c55f79fd53485ba>Kubernetes 1.24 中的上下文日志记录</a></li><li><a href=#pg-a8249504f8ce0359f6802222747eebb2>Kubernetes 1.24: 避免为 Services 分配 IP 地址时发生冲突</a></li><li><a href=#pg-33c9972d97be5af36132098b388992f3>Kubernetes 1.24: 节点非体面关闭特性进入 Alpha 阶段</a></li><li><a href=#pg-894a207e64bf759d2c0ce0546c9e1924>Kubernetes 1.24: 防止未经授权的卷模式转换</a></li><li><a href=#pg-5d0426ad59853e102edd53c047df5d13>Kubernetes 1.24: 卷填充器功能进入 Beta 阶段</a></li><li><a href=#pg-dd40e01906fc4090cab819f78c9a43ca>Kubernetes 1.24：gRPC 容器探针功能进入 Beta 阶段</a></li><li><a href=#pg-2f41c2d51858c88d0bc62e0ba3cf0a05>Kubernetes 1.24 版本中存储容量跟踪特性进入 GA 阶段</a></li><li><a href=#pg-318f9ca753700673267096d658b4f32f>Kubernetes 1.24：卷扩充现在成为稳定功能</a></li><li><a href=#pg-fd94a70167eea241eb51d0090b4a042e>Dockershim：历史背景</a></li><li><a href=#pg-13ed1226f0c58b8693c0ff23815c2739>Kubernetes 1.24: 观星者</a></li><li><a href=#pg-a3a8e38826ac217e8cfceed08bf83370>Frontiers, fsGroups and frogs: Kubernetes 1.23 发布采访</a></li><li><a href=#pg-b89c2306f286f40e6771c44ce8ab6264>在 Ingress-NGINX v1.2.0 中提高安全标准</a></li><li><a href=#pg-5f94242fa4fe2e30e6eebfe3555070a2>Kubernetes 1.24 中的移除和弃用</a></li><li><a href=#pg-81f3d8301bdb049532c4ad2b4ec4ff6d>你的集群准备好使用 v1.24 版本了吗？</a></li><li><a href=#pg-f76def423bf5205897360a230eeaab4a>认识我们的贡献者 - 亚太地区（澳大利亚-新西兰地区）</a></li><li><a href=#pg-0fc668557182aa480318ef29b97df9df>更新：移除 Dockershim 的常见问题</a></li><li><a href=#pg-6641e303390355141422e9c742e5de74>SIG Node CI 子项目庆祝测试改进两周年</a></li><li><a href=#pg-9c346bff5d7ed8c4160c72f990d805de>关注 SIG Multicluster</a></li><li><a href=#pg-39e8f418525c9d53be1c8ba12d6d3e20>确保准入控制器的安全</a></li><li><a href=#pg-b0afb26877191fdd475bffa530d5db8c>认识我们的贡献者 - 亚太地区（印度地区）</a></li><li><a href=#pg-d18900dd436a926af5577de903624990>Kubernetes 即将移除 Dockershim：承诺和下一步</a></li><li><a href=#pg-9d7d32c3aa8ecd68fc6f5cdccad9c2e1>Security Profiles Operator v0.4.0 中的新功能</a></li><li><a href=#pg-60a172c0d67264e6951a7d3c15e8bd87>Kubernetes 1.23: StatefulSet PVC 自动删除 (alpha)</a></li><li><a href=#pg-7e6054db1f7d11e2716846cfabd96dd4>Kubernetes 1.23：树内存储向 CSI 卷迁移工作的进展更新</a></li><li><a href=#pg-002ba8f6565ae3adeaa159c95f0f0e5e>Kubernetes 1.23：IPv4/IPv6 双协议栈网络达到 GA</a></li><li><a href=#pg-157c2c70ed868b35cf1dbc8929b9a9ee>公布 2021 年指导委员会选举结果</a></li><li><a href=#pg-2e6026465182b38bab0f85ae052d3b0b>关注 SIG Node</a></li><li><a href=#pg-d273515f6d183364e8cf63510d4d166f>更新 NGINX-Ingress 以使用稳定的 Ingress API</a></li><li><a href=#pg-2e15afab69477e577a622023be9af007>聚焦 SIG Usability</a></li><li><a href=#pg-3c86e85f7813eea42a5800c5b7dacd46>卷健康监控的 Alpha 更新</a></li><li><a href=#pg-ea1371ce5ca79a0c65620b5bfa13e8b0>弃用 PodSecurityPolicy：过去、现在、未来</a></li><li><a href=#pg-89bf34261431a73d36cd93a22c4b1e31>一个编排高可用应用的 Kubernetes 自定义调度器</a></li><li><a href=#pg-c06e007d763ae4af520000567d5724c6>Kubernetes 1.20：CSI 驱动程序中的 Pod 身份假扮和短时卷</a></li><li><a href=#pg-ced3d9254f631ed8dfb689bd1dd7c259>Kubernetes 1.20: 最新版本</a></li><li><a href=#pg-d0001c21fb6f2f9b21c0faa11a149fae>别慌: Kubernetes 和 Docker</a></li><li><a href=#pg-4f7882145418a14c275e957b0e8979f4>弃用 Dockershim 的常见问题</a></li><li><a href=#pg-fcbc001800469c30982bca14879a3acb>为开发指南做贡献</a></li><li><a href=#pg-d9e35cec65c1d4e7fff2cc66f8423d52>结构化日志介绍</a></li><li><a href=#pg-e99acccbdb5593353cf25826879389e4>警告: 有用的预警</a></li><li><a href=#pg-3b8326c4fb648224fb9cbdd4289cf6e8>Docsy 带来更好的 Docs UX</a></li><li><a href=#pg-b510a26fb64945b86595c4992b051dbd>Kubernetes 1.18: Fit & Finish</a></li><li><a href=#pg-951c3eb34e5599cb9806fb380774663c>基于 MIPS 架构的 Kubernetes 方案</a></li><li><a href=#pg-9e22e84688a3e1e7622241facd484d8a>Kubernetes 1.17：稳定</a></li><li><a href=#pg-601488fd56d4096c09b2a9959d0e7a43>使用 Java 开发一个 Kubernetes controller</a></li><li><a href=#pg-b16b2be554bf6272235c07443e287255>使用 Microk8s 在 Linux 上本地运行 Kubernetes</a></li><li><a href=#pg-464e22d2595c073a96a61069f2fd202f>Kubernetes 文档最终用户调研</a></li><li><a href=#pg-fb4706cbf52d410fa926ccb78d30b84f>圣迭戈贡献者峰会日程公布！</a></li><li><a href=#pg-fc6fc922d4286e1fe8e3289d1094bdf8>2019 指导委员会选举结果</a></li><li><a href=#pg-aed805df2d0756cee0216566e206c2e0>San Diego 贡献者峰会开放注册！</a></li><li><a href=#pg-976a1c2afde41e47eb984e28c88c7085>机器可以完成这项工作，一个关于 kubernetes 测试、CI 和自动化贡献者体验的故事</a></li><li><a href=#pg-87d6b9119a0096eaf905a06844242333>OPA Gatekeeper：Kubernetes 的策略和管理</a></li><li><a href=#pg-037f0eed4d73549cc2f339290039e718>欢迎参加在上海举行的贡献者峰会</a></li><li><a href=#pg-61a7d410a8742331c4512c365210431d>壮大我们的贡献者研讨会</a></li><li><a href=#pg-d21acaf645c18e3c642d1cbc4482e575>如何参与 Kubernetes 文档的本地化工作</a></li><li><a href=#pg-d59cccde9a0772812b0e105b30f5b7c7>Kubernetes 1.14 稳定性改进中的进程ID限制</a></li><li><a href=#pg-19cd0c4556be5dfd65e562e60778ef83>Raw Block Volume 支持进入 Beta</a></li><li><a href=#pg-015d4916d80a01d1f89156ab0583fd6c>新贡献者工作坊上海站</a></li><li><a href=#pg-5193292ae0d55535d8029ff9a7566fca>Kubernetes 文档更新，国际版</a></li><li><a href=#pg-5acf5044e610fc3bc7a65c6616cdf99d>Kubernetes 2018 年北美贡献者峰会</a></li><li><a href=#pg-241e2cb43c3584096fd288edfdbbdebb>2018 年督导委员会选举结果</a></li><li><a href=#pg-f460d202f8a5ec9dfaefd832c33cfa7a>Kubernetes 中的拓扑感知数据卷供应</a></li><li><a href=#pg-744fea7e150e5cd9616530e5a9339c47>Kubernetes v1.12: RuntimeClass 简介</a></li><li><a href=#pg-cfe43151cb19b506570e75c8f0a61259>KubeDirector：在 Kubernetes 上运行复杂状态应用程序的简单方法</a></li><li><a href=#pg-e38db7f640df9065a21c341cfbe4705c>在 Kubernetes 上对 gRPC 服务器进行健康检查</a></li><li><a href=#pg-5cd188187bd5cac97e56eebd5891dd04>使用 CSI 和 Kubernetes 实现卷的动态扩容</a></li><li><a href=#pg-4ce1d602e0512565b4d1b6e9a57367e1>使用 Kubernetes 调整 PersistentVolume 的大小</a></li><li><a href=#pg-37f9b93223232a11f579d220e199b9d1>动态 Kubelet 配置</a></li><li><a href=#pg-4d1b8243b08fd75f7c6f7a1ee1b31e1c>用于 Kubernetes 集群 DNS 的 CoreDNS GA 正式发布</a></li><li><a href=#pg-ff1a9a29a39941763cf19d669d7fbbcc>基于 IPVS 的集群内部负载均衡</a></li><li><a href=#pg-56b1754609f34aa3b199a3e9af607d92>Airflow 在 Kubernetes 中的使用（第一部分）：一种不同的操作器</a></li><li><a href=#pg-416d1fed0ff270b6e7f8838c494f3117>Kubernetes 的动态 Ingress</a></li><li><a href=#pg-bfad75a93816a9020a268af7543370fe>Kubernetes 这四年</a></li><li><a href=#pg-819e0ad707ce8b6e6e6d031bb89f354d>向 Discuss Kubernetes 问好</a></li><li><a href=#pg-b1db29e1fa629592ea431f588f2145fc>在 Kubernetes 上开发</a></li><li><a href=#pg-0b6913088687941c6716b37e47562f16>Kubernetes 社区 - 2017 年开源排行榜榜首</a></li><li><a href=#pg-58315accba126f61921f8cdcf34ab405>“基于容器的应用程序设计原理”</a></li><li><a href=#pg-f018685bed3dd1eaad90e61436e60e10>Kubernetes 1.9 对 Windows Server 容器提供 Beta 版本支持</a></li><li><a href=#pg-bb3ab16fad15d53ca096effeae4cc253>Kubernetes 中自动缩放</a></li><li><a href=#pg-bccec10413bd4f89b97d497368323e1b>Kubernetes 1.8 的五天</a></li><li><a href=#pg-b7983d3e161ebbda5791cc9abf7d749d>Kubernetes 社区指导委员会选举结果</a></li><li><a href=#pg-0bdd9be1eea1fe9ccb870ef33266eb15>使用 Kubernetes Pet Sets 和 Datera Elastic Data Fabric 的 FlexVolume 扩展有状态的应用程序</a></li><li><a href=#pg-28828ac2d323ef978d2063693d4b7de1>SIG Apps: 为 Kubernetes 构建应用并在 Kubernetes 中进行运维</a></li><li><a href=#pg-e74a934a1afe2c3d5f1bb068f967c67f>Kubernetes 生日快乐。哦，这是你要去的地方！</a></li><li><a href=#pg-d0c04eabe8ccc353a49856a0440f8725>将端到端的 Kubernetes 测试引入 Azure （第二部分）</a></li><li><a href=#pg-1496574418064c58fdb070c88d97a679>Dashboard - Kubernetes 的全功能 Web 界面</a></li><li><a href=#pg-7bef62438e14fb0960709d89c1672c30>Citrix + Kubernetes = 全垒打</a></li><li><a href=#pg-9e91022359423a7a5fdefbcd200af963>容器中运行有状态的应用！？ Kubernetes 1.3 说 “是！”</a></li><li><a href=#pg-dfd7c2731ea9e6f52443db7ecb32aa82>CoreOS Fest 2016: CoreOS 和 Kubernetes 在柏林（和旧金山）社区见面会</a></li><li><a href=#pg-f5bc74c369fabdc9aabeb7ba9c4f3d42>SIG-ClusterOps: 提升 Kubernetes 集群的可操作性和互操作性</a></li><li><a href=#pg-d3f23f912c594dbbccd2c55d5b380e84>“SIG-Networking：1.3 版本引入 Kubernetes 网络策略 API”</a></li><li><a href=#pg-584fa2494155bf80b285f6d9e0dd5284>在 Rancher 中添加对 Kuernetes 的支持</a></li><li><a href=#pg-a59c3151a2598aa5539dd1e5f8b30666>KubeCon EU 2016：伦敦 Kubernetes 社区</a></li><li><a href=#pg-5c389f15f0500871a7419690797bb894>Kubernetes 社区会议记录 - 20160218</a></li><li><a href=#pg-ca2bb4aa037f8b34a465c33394c21026>Kubernetes 社区会议记录 - 20160204</a></li><li><a href=#pg-7b6c140fad77ba1f495571539d32b7aa>容器世界现状，2016 年 1 月</a></li><li><a href=#pg-eace1ed65ee850592eaf33f599130b33>Kubernetes 社区会议记录 - 20160114</a></li><li><a href=#pg-bf667c51e2011c6904d9968c4e0e4850>为什么 Kubernetes 不用 libnetwork</a></li><li><a href=#pg-f2fbd7b648c34ea2b5bc519080891738>Kubernetes 和 Docker 简单的 leader election</a></li><li><a href=#pg-9ead5345aff00f9fdaf83a1f428f0559>使用 Puppet 管理 Kubernetes Pod、Service 和 Replication Controller</a></li><li><a href=#pg-992cbdcc8b44baeab01f6bc0ef8b4eae>Kubernetes 1.1 性能升级，工具改进和社区不断壮大</a></li><li><a href=#pg-a5d839dbca2e85bc033ad97da511f701>Kubernetes 社区每周环聊笔记——2015 年 7 月 31 日</a></li><li><a href=#pg-c8d31fe28a6a2f2c0b717dd1b1f21835>宣布首个Kubernetes企业培训课程</a></li><li><a href=#pg-d3c0039c2d00bc08b5dbc16a4f7f29e2>幻灯片：Kubernetes 集群管理，爱丁堡大学演讲</a></li><li><a href=#pg-3b8bd1fa11dba03c4234640bf5bebd0d>OpenStack 上的 Kubernetes</a></li><li><a href=#pg-801e598fff1bb0a31a4322ac49bf5bf1>Kubernetes 社区每周聚会笔记- 2015年5月1日</a></li><li><a href=#pg-05680064b0bb19d48e280af9d6152529>通过 RKT 对 Kubernetes 的 AppC 支持</a></li><li><a href=#pg-c21afabad8ee96c94af485cfbcc582a5>Kubernetes 社区每周聚会笔记- 2015年4月24日</a></li><li><a href=#pg-cb033081886f937e8367cbdc7c9aa2f6>Borg: Kubernetes 的前身</a></li><li><a href=#pg-5a383598a2a3cf35ecf5f846ce0d2772>Kubernetes 社区每周聚会笔记- 2015年4月17日</a></li><li><a href=#pg-79141a7a1c693c72f0adcbe84b41d683>Kubernetes Release: 0.15.0</a></li><li><a href=#pg-1f81358fabb3f1915bb19a2c37312d39>每周 Kubernetes 社区例会笔记 - 2015 年 4 月 3 日</a></li><li><a href=#pg-6fac4a6542db8c1435843173a812efe8>Kubernetes 社区每周聚会笔记 - 2015 年 3 月 27 日</a></li><li><a href=#pg-64e10f0095f0c1f67ad7b47541c7860c>Kubernetes 采集视频</a></li><li><a href=#pg-38fe5117270c19dea659675ee7fa1a8a>欢迎来到 Kubernetes 博客!</a></li></ul><div class=content></div></div><div class=td-content><h1 id=pg-bf1922b98ad8e8052822beae9a70a8f1>“Kubernetes 1.25：对使用用户名字空间运行 Pod 提供 Alpha 支持”</h1><div class="td-byline mb-4"><time datetime=2022-10-03 class=text-muted>2022.10.03</time></div><p><strong>作者:</strong> Rodrigo Campos（Microsoft）、Giuseppe Scrivano（Red Hat）</p><p>Kubernetes v1.25 引入了对用户名字空间的支持。</p><p>这是在 Kubernetes 中运行安全工作负载的一项重大改进。
每个 Pod 只能访问系统上可用 UID 和 GID 的有限子集，
因此添加了一个新的安全层来保护 Pod 免受运行在同一系统上的其他 Pod 的影响。</p><h2 id=how-does-it-work>它是如何工作的？</h2><p>在 Linux 上运行的进程最多可以使用 4294967296 个不同的 UID 和 GID。</p><p>用户名字空间是 Linux 的一项特性，它允许将容器中的一组用户映射到主机中的不同用户，
从而限制进程可以实际使用的 ID。
此外，在新用户名字空间中授予的权能不适用于主机初始名字空间。</p><h2 id=why-is-it-important>它为什么如此重要？</h2><p>用户名字空间之所以重要，主要有两个原因：</p><ul><li><p>提高安全性。因为它们限制了 Pod 可以使用的 ID，
因此每个 Pod 都可以在其自己的具有唯一 ID 的单独环境中运行。</p></li><li><p>以更安全的方式使用 root 身份运行工作负载。</p></li></ul><p>在用户名字空间中，我们可以将 Pod 内的 root 用户映射到容器外的非零 ID，
容器将认为是 root 身份在运行，而从主机的角度来看，它们是常规的非特权 ID。</p><p>该进程可以保留通常仅限于特权 Pod 的功能，并以安全的方式执行这类操作，
因为在新用户名字空间中授予的功能不适用于主机初始名字空间。</p><h2 id=how-do-i-enable-user-namespaces>如何启用用户名字空间</h2><p>目前，对用户名字空间的支持是可选的，因此你必须在 Pod 规约部分将
<code>hostUsers</code> 设置为 <code>false</code> 以启用用户名字空间：</p><pre tabindex=0><code>apiVersion: v1
kind: Pod
spec:
  hostUsers: false
  containers:
  - name: nginx
    image: docker.io/nginx
</code></pre><p>该特性目前还处于 Alpha 阶段，默认是禁用的，因此在使用此新特性之前，
请确保启用了 <code>UserNamespacesStatelessPodsSupport</code> 特性门控。</p><p>此外，运行时也必须支持用户名字空间：</p><ul><li><p>Containerd：计划在 1.7 版本中提供支持。
进一步了解，请参阅 Containerd issue <a href=https://github.com/containerd/containerd/issues/7063>#7063</a>。</p></li><li><p>CRI-O：v1.25 支持用户名字空间。</p></li></ul><p><code>cri-dockerd</code> 对用户名字空间的支持<a href=https://github.com/Mirantis/cri-dockerd/issues/74>尚无计划</a>。</p><h2 id=how-do-i-get-involved>我如何参与？</h2><p>你可以通过多种方式联系 SIG Node：</p><ul><li><p>Slack: <a href=https://kubernetes.slack.com/messages/sig-node>#sig-node</a></p></li><li><p><a href=https://groups.google.com/forum/#!forum/kubernetes-sig-node>邮件列表</a></p></li><li><p><a href=https://github.com/kubernetes/community/labels/sig%2Fnode>开源社区 Issue/PR</a></p></li></ul><p>你也可以直接联系我们：</p><ul><li><p>GitHub / Slack: @rata @giuseppe</p></li><li><p><a href=https://github.com/kubernetes/community/labels/sig%2Fnode>开源社区 Issue/PR</a></p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-5d5c76001e146e082623ca40ad0ba359>Kubernetes 1.25：应用滚动上线所用的两个特性进入稳定阶段</h1><div class="td-byline mb-4"><time datetime=2022-09-15 class=text-muted>2022.09.15</time></div><p><strong>作者：</strong> Ravi Gudimetla (Apple)、Filip Křepinský (Red Hat)、Maciej Szulik (Red Hat)</p><p>这篇博客描述了两个特性，即用于 StatefulSet 的 <code>minReadySeconds</code> 以及用于 DaemonSet 的 <code>maxSurge</code>，
SIG Apps 很高兴宣布这两个特性在 Kubernetes 1.25 进入稳定阶段。</p><p>当 <code>.spec.updateStrategy</code> 字段设置为 <code>RollingUpdate</code> 时，
你可以设置 <code>minReadySeconds</code>， 通过让每个 Pod 等待一段预期时间来减缓 StatefulSet 的滚动上线。</p><p>当 <code>.spec.updateStrategy</code> 字段设置为 <code>RollingUpdate</code> 时，
<code>maxSurge</code> 允许 DaemonSet 工作负载在滚动上线期间在一个节点上运行同一 Pod 的多个实例。
这对于消费者而言有助于将 DaemonSet 的停机时间降到最低。</p><p>这两个特性也可用于 Deployment 和其他工作负载。此功能的提级有助于将这一功能在所有工作负载上对齐。</p><h2 id=what-problems-do-these-features-solve>这两个特性能解决什么问题？</h2><h3 id=solved-problem-statefulset-minreadyseconds>针对 StatefulSet 的 minReadySeconds</h3><p><code>minReadySeconds</code> 确保 StatefulSet 工作负载在给定的秒数内处于 <code>Ready</code>，
然后才会将该 Pod 报告为 <code>Available</code>。
处于 <code>Ready</code> 和 <code>Available</code> 状况的这种说法对工作负载相当重要。
例如 Prometheus 这些工作负载有多个 Alertmanager 实例，
只有 Alertmanager 的状态转换完成后才应该被视为 <code>Available</code>。
<code>minReadySeconds</code> 还有助于云驱动确定何时使用负载均衡器。
因为 Pod 应在给定的秒数内处于 <code>Ready</code>，所以这就提供了一段缓冲时间，
防止新 Pod 还没起来之前就在轮转过程中杀死了旧 Pod。</p><h3 id=how-use-daemonset-maxsurge>针对 DaemonSet 的 maxSurge</h3><p>CNI、CSI 这类 Kubernetes 系统级别的组件通常以 DaemonSet 方式运行。如果这些 DaemonSet 在升级期间瞬间挂掉，
对应的组件可能会影响工作负载的可用性。此特性允许 DaemonSet Pod 临时增加数量，以此确保 DaemonSet 的停机时间为零。</p><p>请注意在 DaemonSet 中不允许同时使用 <code>hostPort</code> 和 <code>maxSurge</code>，
因为 DaemonSet Pod 被捆绑到了一个节点，所以两个活跃的 Pod 无法共享同一节点上的相同端口。</p><h2 id=how-does-it-work>工作原理</h2><h3 id=how-does-statefulset-minreadyseconds-work>针对 StatefulSet 的 minReadySeconds</h3><p>StatefulSet 控制器监视 StatefulSet Pod 并统计特定的 Pod 已处于 <code>Running</code> 状态多长时间了，
如果这个值大于或等于 StatefulSet 的 <code>.spec.minReadySeconds</code> 字段中指定的时间，
StatefulSet 控制器将更新 StatefulSet 的状态中的 <code>AvailableReplicas</code> 字段。</p><h3 id=how-does-daemonset-maxsurge-work>针对 DaemonSet 的 maxSurge</h3><p>DaemonSet 控制器根据 <code>.spec.strategy.rollingUpdate.maxSurge</code> 中给出的值创建额外 Pod
（超出 DaemonSet 规约所设定的预期数量）。
这些 Pod 将运行在旧 DaemonSet Pod 运行所在的同一节点上，直到这个旧 Pod 被杀死为止。</p><ul><li>默认值为 0。</li><li>当 <code>MaxUnavailable</code> 为 0 时此值不能为 <code>0</code>。</li><li>此值可以指定为一个绝对的 Pod 个数或预期 Pod 总数的百分比（向上取整）。</li></ul><h2 id=how-do-i-use-it>我如何使用它？</h2><h3 id=how-use-statefulset-minreadyseconds>针对 StatefulSet 的 minReadySeconds</h3><p>执行以下命令为任意 StatefulSet 指定一个 <code>minReadySeconds</code> 值，
通过检验 <code>AvailableReplicas</code> 字段查看这些 Pod 是否可用：</p><pre tabindex=0><code>kubectl get statefulset/&lt;StatefulSet 名称&gt; -o yaml
</code></pre><p>请注意 <code>minReadySeconds</code> 的默认值为 0。</p><h3 id=how-use-daemonset-maxsurge>针对 DaemonSet 的 maxSurge</h3><p>为 <code>.spec.updateStrategy.rollingUpdate.maxSurge</code> 指定一个值并将
<code>.spec.updateStrategy.rollingUpdate.maxUnavailable</code> 设置为 <code>0</code>。</p><p>然后观察下一次滚动上线是不是更快，同时运行的 Pod 数量是不是更多。</p><pre tabindex=0><code>kubectl rollout restart daemonset &lt;name_of_the_daemonset&gt;
kubectl get pods -w
</code></pre><h2 id=how-can-i-learn-more>我如何才能了解更多？</h2><h3 id=learn-more-statefulset-minreadyseconds>针对 StatefulSet 的 minReadySeconds</h3><ul><li>文档： <a href=https://k8s.io/zh-cn/docs/concepts/workloads/controllers/statefulset/#minimum-ready-seconds>https://k8s.io/zh-cn/docs/concepts/workloads/controllers/statefulset/#minimum-ready-seconds</a></li><li>KEP： <a href=https://github.com/kubernetes/enhancements/issues/2599>https://github.com/kubernetes/enhancements/issues/2599</a></li><li>API 变更： <a href=https://github.com/kubernetes/kubernetes/pull/100842>https://github.com/kubernetes/kubernetes/pull/100842</a></li></ul><h3 id=learn-more-daemonset-maxsurge>针对 DaemonSet 的 maxSurge</h3><ul><li>文档： <a href=https://k8s.io/zh-cn/docs/tasks/manage-daemon/update-daemon-set/>https://k8s.io/zh-cn/docs/tasks/manage-daemon/update-daemon-set/</a></li><li>KEP： <a href=https://github.com/kubernetes/enhancements/issues/1591>https://github.com/kubernetes/enhancements/issues/1591</a></li><li>API 变更： <a href=https://github.com/kubernetes/kubernetes/pull/96375>https://github.com/kubernetes/kubernetes/pull/96375</a></li></ul><h2 id=how-do-i-get-involved>我如何参与？</h2><p>请通过 Slack <a href=https://kubernetes.slack.com/archives/C18NZM5K9>#sig-apps</a> 频道或通过 SIG Apps
邮件列表 <a href=https://groups.google.com/g/kubernetes-sig-apps>kubernetes-sig-apps@googlegroups.com</a> 联系我们。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-79bc80ce5d06b354e44386fba11b7106>Kubernetes 1.25：Pod 新增 PodHasNetwork 状况</h1><div class="td-byline mb-4"><time datetime=2022-09-14 class=text-muted>2022.09.14</time></div><p><strong>作者：</strong>
Deep Debroy (Apple)</p><p>Kubernetes 1.25 引入了对 kubelet 所管理的新的 Pod 状况 <code>PodHasNetwork</code> 的 Alpha 支持，
该状况位于 Pod 的 status 字段中 。对于工作节点，kubelet 将使用 <code>PodHasNetwork</code> 状况从容器运行时
（通常与 CNI 插件协作）创建 Pod 沙箱和网络配置的角度准确地了解 Pod 的初始化状态。
在 <code>PodHasNetwork</code> 状况的 status 设置为 <code>"True"</code> 后，kubelet 开始拉取容器镜像并启动独立的容器
（包括 Init 容器）。从集群基础设施的角度报告 Pod 初始化延迟的指标采集服务
（无需知道每个容器的镜像大小或有效负载等特征）就可以利用 <code>PodHasNetwork</code>
状况来准确生成服务水平指标（Service Level Indicator，SLI）。
某些管理底层 Pod 的 Operator 或控制器可以利用 <code>PodHasNetwork</code> 状况来优化 Pod 反复出现失败时要执行的操作。</p><h3 id=这与现在为-pod-所报告的-intialized-状况有何不同>这与现在为 Pod 所报告的 Intialized 状况有何不同？</h3><p>根据 Pod 中是否存在 Init 容器，kubelet 会设置在 Pod 的 status 字段中报告的 <code>Initialized</code> 状况的状态。</p><p>如果 Pod 指定了 Init 容器，则 Pod 状态中的 <code>Initialized</code> 状况的 status 将不会设置为 <code>"True"</code>，
直到该 Pod 的所有 Init 容器都成功为止。但是，用户配置的 Init 容器可能会出现错误（有效负载崩溃、无效镜像等），
并且 Pod 中配置的 Init 容器数量可能因工作负载不同而异。
因此，关于 Pod 初始化的集群范围基础设施 SLI 不能依赖于 Pod 的 <code>Initialized</code> 状况。</p><p>如果 Pod 未指定 Init 容器，则在 Pod 生命周期的早期，
Pod 状态中的 <code>Initialized</code> 状况的 status 会被设置为 <code>"True"</code>。
这一设置发生在 kubelet 开始创建 Pod 运行时沙箱及配置网络之前。
因此，即使容器运行时未能成功初始化 Pod 沙箱环境，没有 Init 容器的
Pod 也会将 <code>Initialized</code> 状况的 status 报告为 <code>"True"</code>。</p><p>相对于上述任何一种情况，<code>PodHasNetwork</code> 状况会在 Pod 运行时沙箱被初始化并配置了网络时能够提供更准确的数据，
这样 kubelet 可以继续在 Pod 中启动用户配置的容器（包括 Init 容器）。</p><h3 id=特殊场景>特殊场景</h3><p>如果一个 Pod 指定 <code>hostNetwork</code> 为 <code>"True"</code>，
系统会根据 Pod 沙箱创建操作是否成功来决定要不要将 <code>PodHasNetwork</code> 状况设置为 <code>"True"</code>，
设置此状况时会忽略 Pod 沙箱的网络配置状态。这是因为 Pod 的 <code>hostNetwork</code> 被设置为
<code>"True"</code> 时 CRI 实现通常会跳过所有 Pod 沙箱网络配置。</p><p>节点代理可以通过监视指定附加网络配置（例如 <code>k8s.v1.cni.cncf.io/networks</code>）的 Pod 注解变化，
来动态地为 Pod 重新配置网络接口。Pod 沙箱被 Kubelet 初始化（结合容器运行时）之后
Pod 网络配置的动态更新不反映在 <code>PodHasNetwork</code> 状况中。</p><h3 id=试用-pod-的-podhasnetwork-状况>试用 Pod 的 <code>PodHasNetwork</code> 状况</h3><p>为了让 kubelet 在 Pod 的 status 字段中报告 <code>PodHasNetwork</code> 状况，需在 kubelet 上启用
<code>PodHasNetworkCondition</code> 特性门控。</p><p>对于已成功创建运行时沙箱并已配置网络的 Pod，在 status 设置为 <code>"True"</code> 后，
kubelet 将报告 <code>PodHasNetwork</code> 状况：</p><pre tabindex=0><code>$ kubectl describe pod nginx1
Name:             nginx1
Namespace:        default
...
Conditions:
  Type              Status
  PodHasNetwork     True
  Initialized       True
  Ready             True
  ContainersReady   True
  PodScheduled      True
</code></pre><p>对于尚未创建运行时沙箱（也未配置网络）的 Pod，在 status 设置为 <code>"False"</code> 后，
kubelet 将报告 <code>PodHasNetwork</code> 状况：</p><pre tabindex=0><code>$ kubectl describe pod nginx2
Name:             nginx2
Namespace:        default
...
Conditions:
  Type              Status
  PodHasNetwork     False
  Initialized       True
  Ready             False
  ContainersReady   False
  PodScheduled      True
</code></pre><h3 id=下一步是什么>下一步是什么？</h3><p>Kubernetes 团队根据反馈和采用情况，计划在 1.26 或 1.27 中将 <code>PodHasNetwork</code> 状况的报告提升到 Beta 阶段。</p><h3 id=我如何了解更多信息>我如何了解更多信息？</h3><p>请查阅 <code>PodHasNetwork</code> 状况有关的<a href=/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/>文档</a>，
以了解有关该状况的更多信息以及它与其他 Pod 状况的关系。</p><h3 id=如何参与>如何参与？</h3><p>此特性由 SIG Node 社区驱动。请加入我们与社区建立联系，并就上述特性及其他问题分享你的想法和反馈。
我们期待你的回音！</p><h3 id=致谢>致谢</h3><p>我们要感谢以下人员围绕此特性对 KEP 和 PR 进行了极具洞察力和相当有助益的评审工作：
Derek Carr (@derekwaynecarr)、Mrunal Patel (@mrunalp)、Dawn Chen (@dchen1107)、
Qiutong Song (@qiutongs)、Ruiwen Zhao (@ruiwen-zhao)、Tim Bannister (@sftim)、
Danielle Lancashire (@endocrimes) 和 Agam Dua (@agamdua)。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-78b325b506faa9abe768d023258f7b89>宣布自动刷新官方 Kubernetes CVE 订阅源</h1><div class="td-byline mb-4"><time datetime=2022-09-12 class=text-muted>2022.09.12</time></div><p><strong>作者</strong>：Pushkar Joglekar (VMware)</p><p>Kubernetes 社区有一个长时间未解决的需求，即为最终用户提供一种编程方式来跟踪
Kubernetes 安全问题（也称为 “CVE”，这来自于跟踪不同产品和供应商的公共安全问题的数据库）。
随着 Kubernetes v1.25 的发布，我们很高兴地宣布以 <code>alpha</code>
特性的形式推出这样的<a href=/zh-cn/docs/reference/issues-security/official-cve-feed/>订阅源</a>。
在这篇博客中将介绍这项新服务的背景和范围。</p><h2 id=动机>动机</h2><p>随着关注 Kubernetes 的人越来越多，与 Kubernetes 相关的 CVE 数量也在增加。
尽管大多数直接地、间接地或传递性地影响 Kubernetes 的 CVE 都被定期修复，
但 Kubernetes 的最终用户没有一个地方能够以编程方式来订阅或拉取固定的 CVE 数据。
目前的一些数据源要么已损坏，要么不完整。</p><h2 id=范围>范围</h2><h3 id=能做什么>能做什么</h3><p>创建一个定期自动刷新的、人和机器可读的官方 Kubernetes CVE 列表。</p><h3 id=不能做什么>不能做什么</h3><ul><li>漏洞的分类和披露将继续由 SRC（Security Response Committee，安全响应委员会）完成。</li><li>不会列出在构建时依赖项和容器镜像中发现的 CVE。</li><li>只有 Kubernetes SRC 公布的官方 CVE 才会在订阅源中发布。</li></ul><h3 id=针对的受众>针对的受众</h3><ul><li><strong>最终用户</strong>：<strong>使用</strong> Kubernetes 部署他们的应用程序的个人或团队。</li><li><strong>平台提供商</strong>：<strong>管理</strong> Kubernetes 集群的个人或团队。</li><li><strong>维护人员</strong>：通过各种特别兴趣小组和委员会在 Kubernetes 社区中<strong>创建</strong>和<strong>支持</strong> Kubernetes
发布版本的个人或团队。</li></ul><h2 id=实现细节>实现细节</h2><p>发布了一个支持性的<a href=https://kubernetes.dev/blog/2022/09/12/k8s-cve-feed-alpha/>贡献者博客</a>,
深入讲述这个 CVE 订阅源是如何实现的，如何确保该订阅源得到合理的保护以免被篡改，
如何在一个新的 CVE 被公布后自动更新这个订阅源。</p><h2 id=下一步工作>下一步工作</h2><p>为了完善此功能，SIG Security 正在收集使用此 Alpha 订阅源的最终用户的反馈。</p><p>因此，为了在未来的 Kubernetes 版本中改进订阅源，如果你有任何反馈，请通过添加评论至
<a href=https://github.com/kubernetes/sig-security/issues/1>问题追踪</a>告诉我们，
或者在 <a href=https://kubernetes.slack.com/archives/C01CUSVMHPY>#sig-security-tooling</a>
Kubernetes Slack 频道上告诉我们（从<a href=https://slack.k8s.io>这里</a>加入 Kubernetes Slack) 。</p><p><strong>特别感谢 Neha Lohia
<a href=https://github.com/nehalohia27>(@nehalohia27)</a>
和 Tim Bannister <a href=https://github.com/sftim>(@sftim)</a>，
感谢他们几个月来从“构思到实现”此特性的出色合作。</strong></p></div><div class=td-content style=page-break-before:always><h1 id=pg-4a31e9aec55e0ae90074e6bdd81b9c99>COSI 简介：使用 Kubernetes API 管理对象存储</h1><div class="td-byline mb-4"><time datetime=2022-09-02 class=text-muted>2022.09.02</time></div><p><strong>作者：</strong> Sidhartha Mani (<a href=https://min.io>Minio, Inc</a>)</p><p>本文介绍了容器对象存储接口 (COSI)，它是在 Kubernetes 中制备和使用对象存储的一个标准。
它是 Kubernetes v1.25 中的一个 Alpha 功能。</p><p>文件和块存储通过 <a href=https://kubernetes.io/blog/2019/01/15/container-storage-interface-ga/>Container Storage Interface</a> (CSI)
被视为 Kubernetes 生态系统中的一等公民。
使用 CSI 卷的工作负载可以享受跨供应商和跨 Kubernetes 集群的可移植性优势，
而无需更改应用程序清单。对象存储不存在等效标准。</p><p>近年来，对象存储作为文件系统和块设备的替代存储形式越来越受欢迎。
对象存储范式促进了计算和存储的分解，这是通过网络而不是本地提供数据来完成的。
分解的架构允许计算工作负载是无状态的，从而使它们更易于管理、扩展和自动化。</p><h2 id=cosi>COSI</h2><p>COSI 旨在标准化对象存储的使用，以提供以下好处：</p><ul><li>Kubernetes 原生 - 使用 Kubernetes API 来制备、配置和管理 Bucket</li><li>自助服务 - 明确划分管理和运营 (DevOps)，为 DevOps 人员赋予自助服务能力</li><li>可移植性 - 通过跨 Kubernetes 集群和跨对象存储供应商的可移植性实现供应商中立性</li></ul><p><strong>跨供应商的可移植性只有在两家供应商都支持通用数据路径 API 时才有可能。
例如，可以从 AWS S3 移植到 Ceph，或从 AWS S3 移植到 MinIO 以及反向操作，因为它们都使用 S3 API。
但是无法从 AWS S3 和 Google Cloud 的 GCS 移植，反之亦然。</strong></p><h2 id=架构>架构</h2><p>COSI 由三个部分组成：</p><ul><li>COSI 控制器管理器</li><li>COSI 边车</li><li>COSI 驱动程序</li></ul><p>COSI 控制器管理器充当处理 COSI API 对象更改的主控制器，它负责处理 Bucket 创建、更新、删除和访问管理的请求。
每个 Kubernetes 集群都需要一个控制器管理器实例。即使集群中使用了多个对象存储提供程序，也只需要一个。</p><p>COSI 边车充当 COSI API 请求和供应商特定 COSI 驱动程序之间的转换器。
该组件使用供应商驱动程序应满足的标准化 gRPC 协议。</p><p>COSI 驱动程序是供应商特定组件，它接收来自 sidecar 的请求并调用适当的供应商 API 以创建 Bucket、
管理其生命周期及对它们的访问。</p><h2 id=接口>接口</h2><p>COSI 接口 以 Bucket 为中心，因为 Bucket 是对象存储的抽象单元。COSI 定义了三个旨在管理它们的 Kubernetes API</p><ul><li>Bucket</li><li>BucketClass</li><li>BucketClaim</li></ul><p>此外，还定义了另外两个用于管理对 Bucket 的访问的 API：</p><ul><li>BucketAccess</li><li>BucketAccessClass</li></ul><p>简而言之，Bucket 和 BucketClaim 可以认为分别类似于 PersistentVolume 和 PersistentVolumeClaim。
BucketClass 在文件/块设备世界中对应的是 StorageClass。</p><p>由于对象存储始终通过网络进行身份验证，因此需要访问凭证才能访问 Bucket。
BucketAccess 和 BucketAccessClass 这两个 API 用于表示访问凭证和身份验证策略。
有关这些 API 的更多信息可以在官方 COSI 提案中找到 - <a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-storage/1979-object-storage-support>https://github.com/kubernetes/enhancements/tree/master/keps/sig-storage/1979-object-storage-support</a></p><h2 id=自助服务>自助服务</h2><p>除了提供 kubernetes-API 驱动的 Bucket 管理之外，COSI 还旨在使 DevOps 人员能够自行配置和管理 Bucket，
而无需管理员干预。这进一步使开发团队能够实现更快的周转时间和更快的上市时间。</p><p>COSI 通过在两个不同的利益相关者（即管理员（admin）和集群操作员）之间划分 Bucket 配置步骤来实现这一点。
管理员将负责就如何配置 Bucket 以及如何获取 Bucket 的访问权限设置广泛的策略和限制。
集群操作员可以在管理员设置的限制内自由创建和使用 Bucket。</p><p>例如，集群操作员可以使用管理策略将最大预置容量限制为 100GB，并且允许开发人员创建 Bucket 并将数据存储到该限制。
同样对于访问凭证，管理员将能够限制谁可以访问哪些 Bucket，并且开发人员将能够访问他们可用的所有 Bucket。</p><h2 id=可移植性>可移植性</h2><p>COSI 的第三个目标是实现 Bucket 管理的供应商中立性。COSI 支持两种可移植性：</p><ul><li>跨集群</li><li>跨提供商</li></ul><p>跨集群可移植性允许在一个集群中配置的 Bucket 在另一个集群中可用。这仅在对象存储后端本身可以从两个集群访问时才有效。</p><p>跨提供商可移植性是指允许组织或团队无缝地从一个对象存储提供商迁移到另一个对象存储提供商，
而无需更改应用程序定义（PodTemplates、StatefulSets、Deployment 等）。这只有在源和目标提供者使用相同的数据时才有可能。</p><p><strong>COSI 不处理数据迁移，因为它超出了其范围。如果提供者之间的移植也需要迁移数据，则需要采取其他措施来确保数据可用性。</strong></p><h2 id=接下来>接下来</h2><p>令人惊叹的 sig-storage-cosi 社区一直在努力将 COSI 标准带入 Alpha 状态。
我们期待很多供应商加入编写 COSI 驱动程序并与 COSI 兼容！</p><p>我们希望为 COSI Bucket 添加更多身份验证机制，我们正在设计高级存储桶共享原语、多集群存储桶管理等等。
未来有很多伟大的想法和机会！</p><p>请继续关注接下来的内容，如果你有任何问题、意见或建议分解的架构允许计算工作负载是无状态</p><ul><li>在 Kubernetes 上与我们讨论 <a href=https://kubernetes.slack.com/archives/C017EGC1C6N>Slack:#sig-storage-cosi</a></li><li>参加我们的 <a href="https://zoom.us/j/614261834?pwd=Sk1USmtjR2t0MUdjTGVZeVVEV1BPQT09">Zoom 会议</a>，每周四太平洋时间 10:00</li><li>参与 <a href=https://github.com/kubernetes/enhancements/pull/2813>bucket API 提案 PR</a> 提出你的想法、建议等。</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-460a70fa1a527a4befb165f9afbce331>Kubernetes 1.25: cgroup v2 升级到 GA</h1><div class="td-byline mb-4"><time datetime=2022-08-31 class=text-muted>2022.08.31</time></div><p><strong>作者</strong>: David Porter (Google), Mrunal Patel (Red Hat)</p><p>Kubernetes 1.25 将 cgroup v2 正式发布（GA），
让 <a href=/zh-cn/docs/concepts/overview/components/#kubelet>kubelet</a> 使用最新的容器资源管理能力。</p><h2 id=什么是-cgroup>什么是 cgroup？</h2><p>有效的<a href=/zh-cn/docs/concepts/configuration/manage-resources-containers/>资源管理</a>是 Kubernetes 的一个关键方面。
这涉及管理节点中的有限资源，例如 CPU、内存和存储。</p><p><strong>cgroups</strong> 是一种可建立资源管理功能的 Linux 内核能力，
例如为正在运行的进程限制 CPU 使用率或设置内存限制。</p><p>当你使用 Kubernetes 中的资源管理能力时，例如配置
<a href=/zh-cn/docs/concepts/configuration/manage-resources-containers/#requests-and-limits>Pod 和容器的请求和限制</a>，
Kubernetes 会使用 cgroups 来强制执行你的资源请求和限制。</p><p>Linux 内核提供了两个版本的 cgroup：cgroup v1 和 cgroup v2。</p><h2 id=什么是-cgroup-v2>什么是 cgroup v2？</h2><p>cgroup v2 是 Linux cgroup API 的最新版本,
提供了一个具有增强的资源管理能力的统一控制系统。</p><p>自 2016 年以来，cgroup v2 一直在 Linux 内核中进行开发，
近年来在整个容器生态系统中已经成熟。在 Kubernetes 1.25 中，
对 cgroup v2 的支持已升级为正式发布。</p><p>默认情况下，许多最新版本的 Linux 发行版已切换到 cgroup v2，
因此 Kubernetes 继续在这些新更新的发行版上正常运行非常重要。</p><p>cgroup v2 对 cgroup v1 进行了多项改进，例如：</p><ul><li>API 中单个统一的层次结构设计</li><li>为容器提供更安全的子树委派能力</li><li><a href=https://www.kernel.org/doc/html/latest/accounting/psi.html>压力阻塞信息</a>等新功能</li><li>增强的资源分配管理和跨多个资源的隔离<ul><li>统一核算不同类型的内存分配（网络和内核内存等）</li><li>考虑非即时资源更改，例如页面缓存回写</li></ul></li></ul><p>一些 Kubernetes 特性专门使用 cgroup v2 来增强资源管理和隔离。
例如，<a href=/blog/2021/11/26/qos-memory-resources/>MemoryQoS 特性</a>提高了内存利用率并依赖
cgroup v2 功能来启用它。kubelet 中的新资源管理特性也将利用新的 cgroup v2 特性向前发展。</p><h2 id=如何使用-cgroup-v2>如何使用 cgroup v2?</h2><p>许多 Linux 发行版默认切换到 cgroup v2；
你可能会在下次更新控制平面和节点的 Linux 版本时开始使用它！</p><p>推荐使用默认使用 cgroup v2 的 Linux 发行版。
一些使用 cgroup v2 的流行 Linux 发行版包括：</p><ul><li>Container-Optimized OS（从 M97 开始）</li><li>Ubuntu（从 21.10 开始，推荐 22.04+）</li><li>Debian GNU/Linux（从 Debian 11 Bullseye 开始）</li><li>Fedora（从 31 开始）</li><li>Arch Linux（从 2021 年 4 月开始）</li><li>RHEL 和类似 RHEL 的发行版（从 9 开始）</li></ul><p>要检查你的发行版是否默认使用 cgroup v2，
请参阅你的发行版文档或遵循<a href=/zh-cn/docs/concepts/architecture/cgroups/#check-cgroup-version>识别 Linux 节点上的 cgroup 版本</a>。</p><p>如果你使用的是托管 Kubernetes 产品，请咨询你的提供商以确定他们如何采用 cgroup v2，
以及你是否需要采取行动。</p><p>要将 cgroup v2 与 Kubernetes 一起使用，必须满足以下要求：</p><ul><li>你的 Linux 发行版在内核版本 5.8 或更高版本上启用 cgroup v2</li><li>你的容器运行时支持 cgroup v2。例如：<ul><li><a href=https://containerd.io/>containerd</a> v1.4 或更高版本</li><li><a href=https://cri-o.io/>cri-o</a> v1.20 或更高版本</li></ul></li><li>kubelet 和容器运行时配置为使用 <a href=/zh-cn/docs/setup/production-environment/container-runtimes#systemd-cgroup-driver>systemd cgroup 驱动程序</a></li></ul><p>kubelet 和容器运行时使用 <a href=/zh-cn/docs/setup/production-environment/container-runtimes#cgroup-drivers>cgroup 驱动</a>
来设置 cgroup 参数。使用 cgroup v2 时，强烈建议 kubelet 和你的容器运行时都使用
<a href=/zh-cn/docs/setup/production-environment/container-runtimes#systemd-cgroup-driver>systemd cgroup 驱动程序</a>，
以便系统上只有一个 cgroup 管理员。要配置 kubelet 和容器运行时以使用该驱动程序，
请参阅 <a href=/zh-cn/docs/setup/production-environment/container-runtimes#systemd-cgroup-driver>systemd cgroup 驱动程序文档</a>。</p><h2 id=迁移到-cgroup-v2>迁移到 cgroup v2</h2><p>当你使用启用 cgroup v2 的 Linux 发行版运行 Kubernetes 时，只要你满足要求，
kubelet 应该会自动适应而无需任何额外的配置。</p><p>在大多数情况下，除非你的用户直接访问 cgroup 文件系统，
否则当你切换到使用 cgroup v2 时，不会感知到用户体验有什么不同。</p><p>如果你在节点上或从容器内直接访问 cgroup 文件系统的应用程序，
你必须更新应用程序以使用 cgroup v2 API 而不是 cgroup v1 API。</p><p>你可能需要更新到 cgroup v2 的场景包括：</p><ul><li>如果你运行依赖于 cgroup 文件系统的第三方监控和安全代理，请将代理更新到支持 cgroup v2 的版本。</li><li>如果你将 <a href=https://github.com/google/cadvisor>cAdvisor</a> 作为独立的 DaemonSet 运行以监控 Pod 和容器，
请将其更新到 v0.43.0 或更高版本。</li><li>如果你使用 JDK 部署 Java 应用程序，首选使用<a href=https://bugs.openjdk.org/browse/JDK-8230305>完全支持 cgroup v2</a>
的 JDK 11.0.16 及更高版本或 JDK 15 及更高版本。</li></ul><h2 id=进一步了解>进一步了解</h2><ul><li>阅读 <a href=/zh-cn/docs/concepts/architecture/cgroups/>Kubernetes cgroup v2 文档</a></li><li>阅读增强提案 <a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/2254-cgroup-v2/README.md>KEP 2254</a></li><li>学习更多关于 Linux 手册页上的 <a href=https://man7.org/linux/man-pages/man7/cgroups.7.html>cgroups</a> 和 Linux 内核文档上的
<a href=https://docs.kernel.org/admin-guide/cgroup-v2.html>cgroup v2</a></li></ul><h2 id=参与其中>参与其中</h2><p>随时欢迎你的反馈！SIG Node 定期开会，可在 Kubernetes <a href=https://slack.k8s.io/>Slack</a>的
<code>#sig-node</code> 频道中获得，或使用 SIG <a href=https://github.com/kubernetes/community/tree/master/sig-node#contact>邮件列表</a>。</p><p>cgroup v2 经历了漫长的旅程，是整个行业开源社区协作的一个很好的例子，
因为它需要跨堆栈的工作，从 Linux 内核到 systemd 到各种容器运行时，当然还有 Kubernetes。</p><h2 id=致谢>致谢</h2><p>我们要感谢 <a href=https://github.com/giuseppe>Giuseppe Scrivano</a> 在 Kubernetes 中发起对 cgroup v2 的支持，
还要感谢 SIG Node 社区主席 <a href=https://github.com/dchen1107>Dawn Chen</a> 和
<a href=https://github.com/derekwaynecarr>Derek Carr</a> 所作的审查和领导工作。</p><p>我们还要感谢 Docker、containerd 和 CRI-O 等容器运行时的维护者，
以及支持多种容器运行时的 <a href=https://github.com/google/cadvisor>cAdvisor</a> 和
<a href=https://github.com/opencontainers/runc>runc, libcontainer</a> 等组件的维护者。
最后，如果没有 systemd 和上游 Linux 内核维护者的支持，这将是不可能的。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-9a6e963a54a0d5c3b3703691e8590810>Kubernetes 1.25：CSI 内联存储卷正式发布</h1><div class="td-byline mb-4"><time datetime=2022-08-29 class=text-muted>2022.08.29</time></div><p><strong>作者：</strong> Jonathan Dobson (Red Hat)</p><p>CSI 内联存储卷是在 Kubernetes 1.15 中作为 Alpha 功能推出的，并从 1.16 开始成为 Beta 版本。
我们很高兴地宣布，这项功能在 Kubernetes 1.25 版本中正式发布（GA）。</p><p>CSI 内联存储卷与其他类型的临时卷相似，如 <code>configMap</code>、<code>downwardAPI</code> 和 <code>secret</code>。
重要的区别是，存储是由 CSI 驱动提供的，它允许使用第三方供应商提供的临时存储。
卷被定义为 Pod 规约的一部分，并遵循 Pod 的生命周期，这意味着卷随着 Pod 的调度而创建，并随着 Pod 的销毁而销毁。</p><h2 id=1-25-版本有什么新内容>1.25 版本有什么新内容？</h2><p>1.25 版本修复了几个与 CSI 内联存储卷相关的漏洞，
并且 <a href=/zh-cn/docs/reference/command-line-tools-reference/feature-gates/>CSIInlineVolume 特性门控</a>
已正式发布，锁定为 <code>True</code>。
因为没有新的 API 变化，所以除了这些错误修复外，使用该功能 Beta 版本的用户应该不会注意到任何重大变化。</p><ul><li><a href=https://github.com/kubernetes/kubernetes/issues/89290>#89290 - CSI inline volumes should support fsGroup</a></li><li><a href=https://github.com/kubernetes/kubernetes/issues/79980>#79980 - CSI volume reconstruction does not work for ephemeral volumes</a></li></ul><h2 id=何时使用此功能>何时使用此功能</h2><p>CSI 内联存储卷是为简单的本地卷准备的，这种本地卷应该跟随 Pod 的生命周期。
它们对于使用 CSI 驱动为 Pod 提供 Secret、配置数据或其他特殊用途的存储可能很有用。</p><p>在以下情况下，CSI 驱动不适合内联使用：</p><ul><li>卷需要持续的时间超过 Pod 的生命周期</li><li>卷快照、克隆或卷扩展是必需的</li><li>CSI 驱动需要 <code>volumeAttributes</code> 字段，此字段应该限制给管理员使用</li></ul><h2 id=如何使用此功能>如何使用此功能</h2><p>为了使用这个功能，<code>CSIDriver</code> 规约必须明确将 <code>Ephemeral</code> 列举为 <code>volumeLifecycleModes</code> 的参数之一。
下面是一个来自 <a href=https://github.com/kubernetes-sigs/secrets-store-csi-driver>Secrets Store CSI Driver</a> 的简单例子。</p><pre tabindex=0><code>apiVersion: storage.k8s.io/v1
kind: CSIDriver
metadata:
  name: secrets-store.csi.k8s.io
spec:
  podInfoOnMount: true
  attachRequired: false
  volumeLifecycleModes:
  - Ephemeral
</code></pre><p>所有 Pod 规约都可以引用该 CSI 驱动来创建一个内联卷，如下例所示。</p><pre tabindex=0><code>kind: Pod
apiVersion: v1
metadata:
  name: my-csi-app-inline
spec:
  containers:
    - name: my-frontend
      image: busybox
      volumeMounts:
      - name: secrets-store-inline
        mountPath: &#34;/mnt/secrets-store&#34;
        readOnly: true
      command: [ &#34;sleep&#34;, &#34;1000000&#34; ]
  volumes:
    - name: secrets-store-inline
      csi:
        driver: secrets-store.csi.k8s.io
        readOnly: true
        volumeAttributes:
          secretProviderClass: &#34;my-provider&#34;
</code></pre><p>如果驱动程序支持一些卷属性，你也可以将这些属性作为 Pod <code>spec</code> 的一部分。</p><pre tabindex=0><code>      csi:
        driver: block.csi.vendor.example
        volumeAttributes:
          foo: bar
</code></pre><h2 id=使用案例示例>使用案例示例</h2><p>支持 <code>Ephemeral</code> 卷生命周期模式的两个现有 CSI 驱动是 Secrets Store CSI 驱动和 Cert-Manager CSI 驱动。</p><p><a href=https://github.com/kubernetes-sigs/secrets-store-csi-driver>Secrets Store CSI Driver</a>
允许用户将 Secret 作为内联卷从外部挂载到一个 Pod 中。
当密钥存储在外部管理服务或 Vault 实例中时，这可能很有用。</p><p><a href=https://github.com/cert-manager/csi-driver>Cert-Manager CSI Driver</a> 与 <a href=https://cert-manager.io/>cert-manager</a> 协同工作，
无缝地请求和挂载证书密钥对到一个 Pod 中。这使得证书可以在应用 Pod 中自动更新。</p><h2 id=安全考虑因素>安全考虑因素</h2><p>应特别考虑哪些 CSI 驱动可作为内联卷使用。
<code>volumeAttributes</code> 通常通过 <code>StorageClass</code> 控制，并可能包含应限制给集群管理员的属性。
允许 CSI 驱动用于内联临时卷意味着任何有权限创建 Pod 的用户也可以通过 Pod 规约向驱动提供 <code>volumeAttributes</code> 字段。</p><p>集群管理员可以选择从 CSIDriver 规约中的 <code>volumeLifecycleModes</code> 中省略（或删除） <code>Ephemeral</code>，
以防止驱动被用作内联临时卷，或者使用<a href=/zh-cn/docs/reference/access-authn-authz/extensible-admission-controllers/>准入 Webhook</a> 来限制驱动的使用。</p><h2 id=参考资料>参考资料</h2><p>关于此功能的更多信息，请参阅：</p><ul><li><a href=/zh-cn/docs/concepts/storage/ephemeral-volumes/#csi-ephemeral-volumes>Kubernetes 文档</a></li><li><a href=https://kubernetes-csi.github.io/docs/ephemeral-local-volumes.html>CSI 文档</a></li><li><a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-storage/596-csi-inline-volumes/README.md>KEP-596</a></li><li><a href=https://kubernetes.io/blog/2020/01/21/csi-ephemeral-inline-volumes/>CSI 内联存储卷的 Beta 阶段博客文章</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-a3bb67281fa7ebc302189d5e5eb02b04>PodSecurityPolicy：历史背景</h1><div class="td-byline mb-4"><time datetime=2022-08-23 class=text-muted>2022.08.23</time></div><p><strong>作者：</strong> Mahé Tardy (Quarkslab)</p><p>从 Kubernetes v1.25 开始，PodSecurityPolicy (PSP) 准入控制器已被移除。
在为 Kubernetes v1.21 发布的博文 <a href=/blog/2021/04/06/podsecuritypolicy-deprecation-past-present-and-future/>PodSecurityPolicy 弃用：过去、现在和未来</a>
中，已经宣布并详细说明了它的弃用情况。</p><p>本文旨在提供 PSP 诞生和演变的历史背景，解释为什么从未使该功能达到稳定状态，并说明为什么它被移除并被 Pod 安全准入控制取代。</p><p>PodSecurityPolicy 与其他专门的准入控制插件一样，作为内置的策略 API，对有关 Pod 安全设置的特定字段提供细粒度的权限。
它承认集群管理员和集群用户通常不是同一个人，并且以 Pod 形式或任何将创建 Pod 的资源的形式创建工作负载的权限不应该等同于“集群上的 root 账户”。
它还可以通过变更配置来应用更安全的默认值，并将底层 Linux 安全决策与部署过程分离来促进最佳实践。</p><h2 id=podsecuritypolicy-的诞生>PodSecurityPolicy 的诞生</h2><p>PodSecurityPolicy 源自 OpenShift 的 SecurityContextConstraints (SCC)，
它出现在 Red Hat OpenShift 容器平台的第一个版本中，甚至在 Kubernetes 1.0 之前。PSP 是 SCC 的精简版。</p><p>PodSecurityPolicy 的创建起源很难追踪，特别是因为它主要是在 Kubernetes 增强提案 (KEP) 流程之前添加的，
当时仍在使用设计提案（Design Proposal）。事实上，最终<a href=https://github.com/kubernetes/design-proposals-archive/blob/main/auth/pod-security-policy.md>设计提案</a>的存档仍然可以找到。
尽管如此，<a href=https://github.com/kubernetes/enhancements/issues/5>编号为 5 的 KEP</a>
是在合并第一个拉取请求后创建的。</p><p>在添加创建 PSP 的第一段代码之前，两个主要的拉取请求被合并到 Kubernetes 中，
<a href=https://github.com/kubernetes/kubernetes/pull/7343><code>SecurityContext</code> 子资源</a>
定义了 Pod 容器上的新字段，以及 <a href=https://github.com/kubernetes/kubernetes/pull/7101>ServiceAccount</a>
API 的第一次迭代。</p><p>Kubernetes 1.0 于 2015 年 7 月 10 日发布，除了 Alpha 阶段的 SecurityContextDeny 准入插件
（当时称为 <code>scdeny</code>）之外，
没有任何机制来限制安全上下文和工作负载的敏感选项。
<a href=https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#securitycontextdeny>SecurityContextDeny 插件</a>
今天仍存在于 Kubernetes 中（作为 Alpha 特性），负责创建一个准入控制器，以防止在安全上下文中使用某些字段。</p><p>PodSecurityPolicy 的根源是<a href=https://github.com/kubernetes/kubernetes/pull/7893>早期关于安全策略的一个拉取请求</a>，
它以 SCC（安全上下文约束）为基础，增加了新的 PSP 对象的设计方案。这是一个长达 9 个月的漫长讨论，
基于 OpenShift 的 SCC 反复讨论，
多次变动，并重命名为 PodSecurityPolicy，最终在 2016 年 2 月进入上游 Kubernetes。
现在 PSP 对象已经创建，下一步是添加一个可以执行这些政策的准入控制器。
第一步是添加<a href=https://github.com/kubernetes/kubernetes/pull/7893#issuecomment-180410539>不考虑用户或组</a>
的准入控制。
2016 年 5 月，一个特定的<a href=https://github.com/kubernetes/kubernetes/issues/23217>使 PodSecurityPolicy 达到可用状态的问题</a>被添加进来，
以跟踪进展，并在<a href=https://github.com/kubernetes/kubernetes/pull/24600>名为 PSP 准入的拉取请求</a>中合并了准入控制器的第一个版本。
然后大约两个月后，发布了 Kubernetes 1.3。</p><p>下面是一个时间表，它以 1.0 和 1.3 版本作为参考点，回顾了 PodSecurityPolicy 及其准入控制器诞生的主要拉取请求。</p><figure><img src=./timeline.svg alt="Timeline of the PodSecurityPolicy creation pull requests"></figure><p>之后，PSP 准入控制器通过添加最初被搁置的内容进行了增强。
在 2016 年 11 月上旬合并<a href=https://github.com/kubernetes/kubernetes/pull/33080>鉴权机制</a>，
允许管理员在集群中使用多个策略，为不同类型的用户授予不同级别的访问权限。
后来，2017 年 10 月合并的一个<a href=https://github.com/kubernetes/kubernetes/pull/52849>拉取请求</a>
修复了 PodSecurityPolicies 在变更和字母顺序之间冲突的<a href=https://github.com/kubernetes/kubernetes/issues/36184>设计问题</a>，
并继续构建我们所知道的 PSP 准入。之后，进行了许多改进和修复，以构建最近 Kubernetes 版本的 PodSecurityPolicy 功能。</p><h2 id=pod-安全准入的兴起>Pod 安全准入的兴起</h2><p>尽管 PodSecurityPolicy 试图解决的是一个关键问题，但它却包含一些重大缺陷：</p><ul><li><strong>有缺陷的鉴权模式</strong> - 如果用户针对 PSP 具有执行 <strong>use</strong> 动作的权限，而此 PSP 准许该 Pod
或者该 Pod 的服务帐户对 PSP 执行 <strong>use</strong> 操作，则用户可以创建一个 Pod。</li><li><strong>难以推广</strong> - PSP 失败关闭。也就是说，在没有策略的情况下，所有 Pod 都会被拒绝。
这主要意味着默认情况下无法启用它，并且用户必须在启用该功能之前为所有工作负载添加 PSP，
因此没有提供审计模式来发现哪些 Pod 会不被新策略所允许。
这种采纳模式还导致测试覆盖率不足，并因跨特性不兼容而经常出现故障。
而且与 RBAC 不同的是，还不存在在项目中交付 PSP 清单的强大文化。</li><li><strong>不一致的无边界 API</strong> - API 的发展有很多不一致的地方，特别是由于许多小众场景的请求：
如标签、调度、细粒度的卷控制等。它的可组合性很差，优先级模型较弱，会导致意外的变更优先级。
这使得 PSP 与其他第三方准入控制器的结合真的很困难。</li><li><strong>需要安全知识</strong> - 有效使用 PSP 仍然需要了解 Linux 的安全原语。
例如：MustRunAsNonRoot + AllowPrivilegeEscalation。</li></ul><p>PodSecurityPolicy 的经验得出的结论是，大多数用户关心两个或三个策略，这导致了
<a href=/zh-cn/docs/concepts/security/pod-security-standards/>Pod 安全标准</a>的创建，它定义了三个策略：</p><ul><li><strong>Privileged（特权的）</strong> - 策略不受限制。</li><li><strong>Baseline（基线的）</strong> - 策略限制很少，允许默认 Pod 配置。</li><li><strong>Restricted（受限的）</strong> - 安全最佳实践策略。</li></ul><p>作为 PSP 的替代品，新的 <a href=/zh-cn/docs/concepts/security/pod-security-admission/>Pod 安全准入</a>是
Kubernetes v1.25 的树内稳定的准入插件，用于在命名空间级别强制执行这些标准。
无需深入的安全知识，就可以更轻松地实施基本的 Pod 安全性。
对于更复杂的用例，你可能需要一个可以轻松与 Pod 安全准入结合的第三方解决方案。</p><h2 id=下一步是什么>下一步是什么</h2><p>有关 SIG Auth 流程的更多详细信息，包括 PodSecurityPolicy 删除和 Pod 安全准入的创建，
请参阅在 KubeCon NA 2021 的
<a href="https://www.youtube.com/watch?v=SFtHRmPuhEw">SIG auth update at KubeCon NA 2019</a> 和
<a href="https://www.youtube.com/watch?v=HsRRmlTJpls">PodSecurityPolicy Replacement: Past, Present, and Future</a>
演示录像。</p><p>特别是在 PSP 移除方面，<a href=/blog/2021/04/06/podsecuritypolicy-deprecation-past-present-and-future/>PodSecurityPolicy 弃用：过去、现在和未来</a>博客文章仍然是准确的。</p><p>对于新的 Pod 安全许可，<a href=/zh-cn/docs/concepts/security/pod-security-admission/>可以访问文档</a>。
此外，博文 <a href=/blog/2021/12/09/pod-security-admission-beta/>Kubernetes 1.23: Pod Security Graduers to Beta</a>
以及 KubeCon EU 2022 演示文稿 <a href="https://www.youtube.com/watch?v=gcz5VsvOYmI">the Hitchhicker’s Guide to Pod Security</a>
提供了很好的实践教程来学习。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-b5f27644a48ad744c65da1d34d09f77c>Kubernetes v1.25: Combiner</h1><div class="td-byline mb-4"><time datetime=2022-08-23 class=text-muted>2022.08.23</time></div><p><strong>作者</strong>: <a href=https://github.com/kubernetes/sig-release/blob/master/releases/release-1.25/release-team.md>Kubernetes 1.25 发布团队</a></p><p>宣布 Kubernetes v1.25 的发版！</p><p>这个版本总共包括 40 项增强功能。
其中 15 项增强功能进入 Alpha，10 项进入 Beta，13 项进入 Stable。
我们也废弃/移除了两个功能。</p><h2 id=版本主题和徽标>版本主题和徽标</h2><p><strong>Kubernetes 1.25: Combiner</strong></p><figure class=release-logo><img src=/images/blog/2022-08-23-kubernetes-1.25-release/kubernetes-1.25.png alt="Combiner logo"></figure><p>Kubernetes v1.25 的主题是 <strong>Combiner</strong>，即组合器。</p><p>Kubernetes 项目本身是由特别多单独的组件组成的，这些组件组合起来就形成了你今天看到的这个项目。
同时它也是由许多个人建立和维护的，这些人拥有不同的技能、经验、历史和兴趣，
他们不仅作为发布团队成员，而且作为许多 SIG 成员，常年通力合作支持项目和社区。</p><p>通过这次发版，我们希望向协作和开源的精神致敬，
这种精神使我们从分散在世界各地的独立开发者、作者和用户变成了能够改变世界的联合力量。
Kubernetes v1.25 包含了惊人的 40 项增强功能，
如果没有我们在一起工作时拥有的强大力量，这些增强功能都不会存在。</p><p>受我们的发布负责人的儿子 Albert Song 的启发，Kubernetes v1.25 是以你们每一个人命名的，
无论你们选择如何作为 Kubernetes 的联合力量贡献自己的独有力量。</p><h2 id=新增内容-主要主题>新增内容（主要主题）</h2><h3 id=pod-security-changes>移除 PodSecurityPolicy；Pod Security Admission 成长为 Stable</h3><p>PodSecurityPolicy 是在 <a href=/blog/2021/04/06/podsecuritypolicy-deprecation-past-present-and-future/>1.21 版本中被弃用</a>，到 1.25 版本被移除。
因为提升其可用性的变更会带来破坏性的变化，所以有必要将其删除，以支持一个更友好的替代品。
这个替代品就是 <a href=/zh-cn/docs/concepts/security/pod-security-admission/>Pod Security Admission</a>，它在这个版本里成长为 Stable。
如果你最近依赖于 PodSecurityPolicy，请参考 <a href=/zh-cn/docs/tasks/configure-pod-container/migrate-from-psp/>Pod Security Admission 迁移说明</a>。</p><h3 id=ephemeral-containers-成长为-stable>Ephemeral Containers 成长为 Stable</h3><p><a href=/zh-cn/docs/concepts/workloads/pods/ephemeral-containers/>临时容器</a>是在现有的 Pod 中存在有限时间的容器。
当你需要检查另一个容器，但因为该容器已经崩溃或其镜像缺乏调试工具不能使用 <code>kubectl exec</code> 时，它对故障排除特别有用。
临时容器在 Kubernetes v1.23 中成长为 Beta，并在这个版本中，该功能成长为 Stable。</p><h3 id=对-cgroups-v2-的支持进入-stable-阶段>对 cgroups v2 的支持进入 Stable 阶段</h3><p>自 Linux 内核 cgroups v2 API 宣布稳定以来，已经有两年多的时间了。
随着一些发行版现在默认使用该 API，Kubernetes 必须支持它以继续在这些发行版上运行。
cgroups v2 比 cgroups v1 提供了一些改进，更多信息参见 <a href=/zh-cn/docs/concepts/architecture/cgroups/>cgroups v2</a> 文档。
虽然 cgroups v1 将继续受到支持，但这一改进使我们能够为其最终的废弃和替代做好准备。</p><h3 id=改善对-windows-系统的支持>改善对 Windows 系统的支持</h3><ul><li><a href="http://perf-dash.k8s.io/#/?jobname=soak-tests-capz-windows-2019">性能仪表板</a>增加了对 Windows 系统的支持</li><li><a href=https://github.com/kubernetes/kubernetes/issues/51540>单元测试</a>增加了对 Windows 系统的支持</li><li><a href=https://github.com/kubernetes/kubernetes/pull/108592>一致性测试</a>增加了对 Windows 系统的支持</li><li>为 <a href=https://github.com/kubernetes-sigs/windows-operational-readiness>Windows Operational Readiness</a> 创建了新的 GitHub 仓库</li></ul><h3 id=将容器注册服务从-k8s-gcr-io-迁移至-registry-k8s-io>将容器注册服务从 k8s.gcr.io 迁移至 registry.k8s.io</h3><p><a href=https://github.com/kubernetes/kubernetes/pull/109938>将容器注册服务从 k8s.gcr.io 迁移至 registry.k8s.io</a> 的 PR 已经被合并。
更多细节参考 <a href=https://github.com/kubernetes/k8s.io/wiki/New-Registry-url-for-Kubernetes-(registry.k8s.io)>wiki 页面</a>，
同时<a href=https://groups.google.com/a/kubernetes.io/g/dev/c/DYZYNQ_A6_c/m/oD9_Q8Q9AAAJ>公告</a>已发送到 kubernetes 开发邮件列表。</p><h3 id=seccompdefault-升级为-beta>SeccompDefault 升级为 Beta</h3><p>SeccompDefault 升级为 Beta，
更多细节参考教程<a href=/zh-cn/docs/tutorials/security/seccomp/#enable-the-use-of-runtimedefault-as-the-default-seccomp-profile-for-all-workloads>用 seccomp 限制一个容器的系统调用</a>。</p><h3 id=网络策略中-endport-升级为-stable>网络策略中 endPort 升级为 Stable</h3><p><a href=/zh-cn/docs/concepts/services-networking/network-policies/#targeting-a-range-of-ports>网络策略</a>中的
<code>endPort</code> 已经迎来 GA 正式发布。
支持 <code>endPort</code> 字段的网络策略提供程序现在可使用该字段来指定端口范围，应用网络策略。
在之前的版本中，每个网络策略只能指向单一端口。</p><p>请注意，网络策略提供程序 <strong>必须支持</strong> <code>endPort</code> 字段。
如果提供程序不支持 <code>endPort</code>，又在网络策略中指定了此字段，
则会创建出仅覆盖端口字段（单端口）的网络策略。</p><h3 id=本地临时容器存储容量隔离升级为-stable>本地临时容器存储容量隔离升级为 Stable</h3><p><a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-storage/361-local-ephemeral-storage-isolation>本地临时存储容量隔离功能</a>已经迎来 GA 正式发布版本。
该功能在 1.8 版中作为 alpha 版本引入，在 1.10 中升级为 beta，现在终于成为了稳定功能。
它提供了对 Pod 之间本地临时存储容量隔离的支持，如 <code>EmptyDir</code>，
因此，如果一个 Pod 对本地临时存储容量的消耗超过该限制，就可以通过驱逐 Pod 来硬性限制其对共享资源的消耗。</p><h3 id=核心-csi-迁移为稳定版>核心 CSI 迁移为稳定版</h3><p><a href=https://kubernetes.io/blog/2021/12/10/storage-in-tree-to-csi-migration-status-update/#quick-recap-what-is-csi-migration-and-why-migrate>CSI 迁移</a>是 SIG Storage 在之前多个版本中做出的持续努力。
目标是将树内数据卷插件转移到树外 CSI 驱动程序并最终移除树内数据卷插件。
此次<a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-storage/625-csi-migration>核心 CSI 迁移</a>已迎来 GA。
同样，GCE PD 和 AWS EBS 的 CSI 迁移也进入 GA 阶段。
vSphere 的 CSI 迁移仍为 beta（但也默认启用）。
Portworx 的 CSI 迁移同样处于 beta 阶段（但默认不启用）。</p><h3 id=csi-临时数据卷升级为稳定版>CSI 临时数据卷升级为稳定版</h3><p><a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-storage/596-csi-inline-volumes>CSI 临时数据卷</a>
功能允许在临时使用的情况下在 Pod 里直接指定 CSI 数据卷。
因此可以直接用它们在使用挂载卷的 Pod 内注入任意状态，如配置、秘密、身份、变量或类似信息。
这个功能最初是作为 alpha 功能在 1.15 版本中引入，现在已升级为 GA 通用版。
某些 CSI 驱动程序会使用此功能，例如<a href=https://github.com/kubernetes-sigs/secrets-store-csi-driver>存储密码的 CSI 驱动程序</a>。</p><h3 id=crd-验证表达式语言升级为-beta>CRD 验证表达式语言升级为 Beta</h3><p><a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-api-machinery/2876-crd-validation-expression-language/README.md>CRD 验证表达式语言</a>已升级为 beta 版本，
这使得声明如何使用<a href=https://github.com/google/cel-spec>通用表达式语言（CEL）</a>验证自定义资源成为可能。
请参考<a href=https://kubernetes.io/zh-cn/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#validation-rules>验证规则</a>指导。</p><h3 id=服务器端未知字段验证升级为-beta>服务器端未知字段验证升级为 Beta</h3><p><code>ServerSideFieldValidation</code> 特性门控已升级为 beta（默认开启）。
它允许在检测到未知字段时，有选择地触发 API 服务器上的模式验证机制。
因此这允许从 kubectl 中移除客户端验证的同时保持相同的核心功能，即对包含未知或无效字段的请求进行错误处理。</p><h3 id=引入-kms-v2-api>引入 KMS v2 API</h3><p>引入 KMS v2 alpha1 API 以提升性能，实现轮替与可观察性改进。
此 API 使用 AES-GCM 替代了 AES-CBC，通过 DEK 实现静态数据（即 Kubernetes Secrets）加密。
过程中无需额外用户操作，而且仍然支持通过 AES-GCM 和 AES-CBC 进行读取。
更多信息参考<a href=/zh-cn/docs/tasks/administer-cluster/kms-provider/>使用 KMS provider 进行数据加密</a>指南。</p><h3 id=kube-proxy-镜像当前基于无发行版镜像>Kube-proxy 镜像当前基于无发行版镜像</h3><p>在以前的版本中，kube-proxy 的容器镜像是以 Debian 作为基础镜像构建的。
从这个版本开始，其镜像现在使用 <a href=https://github.com/GoogleContainerTools/distroless>distroless</a> 来构建。
这一改变将镜像的大小减少了近 50%，并将安装的软件包和文件的数量减少到只有 kube-proxy 工作所需的那些。</p><h2 id=其他更新>其他更新</h2><h3 id=稳定版升级>稳定版升级</h3><p>1.25 版本共包含 13 项升级至稳定版的增强功能：</p><ul><li><a href=https://github.com/kubernetes/enhancements/issues/277>临时容器</a></li><li><a href=https://github.com/kubernetes/enhancements/issues/361>本地临时存储资源管理</a></li><li><a href=https://github.com/kubernetes/enhancements/issues/596>CSI 临时数据卷</a></li><li><a href=https://github.com/kubernetes/enhancements/issues/625>CSI 迁移 -- 核心</a></li><li><a href=https://github.com/kubernetes/enhancements/issues/785>kube-scheduler ComponentConfig 升级为 GA 通用版</a></li><li><a href=https://github.com/kubernetes/enhancements/issues/1487>CSI 迁移 -- AWS</a></li><li><a href=https://github.com/kubernetes/enhancements/issues/1488>CSI 迁移 -- GCE</a></li><li><a href=https://github.com/kubernetes/enhancements/issues/1591>DaemonSets 支持 MaxSurge</a></li><li><a href=https://github.com/kubernetes/enhancements/issues/2079>网络策略端口范围</a></li><li><a href=https://github.com/kubernetes/enhancements/issues/2254>cgroups v2</a></li><li><a href=https://github.com/kubernetes/enhancements/issues/2579>Pod Security Admission</a></li><li><a href=https://github.com/kubernetes/enhancements/issues/2599>Statefulsets 增加 <code>minReadySeconds</code></a></li><li><a href=https://github.com/kubernetes/enhancements/issues/2802>在 API 准入层级权威识别 Windows Pod</a></li></ul><h3 id=弃用和移除>弃用和移除</h3><p>1.25 版本<a href=/blog/2022/08/04/upcoming-changes-in-kubernetes-1-25/>废弃/移除</a>两个功能。</p><ul><li><a href=https://github.com/kubernetes/enhancements/issues/5>移除 PodSecurityPolicy</a></li><li><a href=https://github.com/kubernetes/enhancements/issues/3446>从树内驱动程序移除 GlusterFS 插件</a></li></ul><h3 id=发行版说明>发行版说明</h3><p>Kubernetes 1.25 版本的完整信息可参考<a href=https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG/CHANGELOG-1.25.md>发行版说明</a>。</p><h3 id=获取>获取</h3><p>Kubernetes 1.25 版本可在 <a href=https://github.com/kubernetes/kubernetes/releases/tag/v1.25.0>GitHub</a> 下载获取。
开始使用 Kubernetes 请查看这些<a href=/zh-cn/docs/tutorials/>交互式教程</a>或者使用
<a href=https://kind.sigs.k8s.io/>kind</a> 把容器当作 “节点” 来运行本地 Kubernetes 集群。
你也可以使用 <a href=/zh-cn/docs/setup/independent/create-cluster-kubeadm/>kubeadm</a> 来简单的安装 1.25 版本。</p><h3 id=发布团队>发布团队</h3><p>Kubernetes 的发展离不开其社区的支持、承诺和辛勤工作。
每个发布团队都是由专门的社区志愿者组成的，他们共同努力，建立了许多模块，这些模块结合起来，就构成了你所依赖的 Kubernetes。
从代码本身到文档和项目管理，这需要我们社区每一个人的专业技能。</p><h3 id=重要用户>重要用户</h3><ul><li>Finleap Connect 在一个高度规范的环境中运作。
<a href=https://www.cncf.io/case-studies/finleap-connect/>2019年，他们有五个月的时间在其集群的所有服务中实施交互 TLS（mTLS），以使其业务代码符合新的欧洲 PSD2 支付指令</a>。</li><li>PNC 试图开发一种方法，以确保新的代码能够自动满足安全标准和审计合规性要求--取代他们现有的 30 天的繁琐的人工流程。
使用 Knative，<a href=https://www.cncf.io/case-studies/pnc-bank/>PNC 开发了内部工具来自动检查新代码和对修改现有代码</a>。</li><li>Nexxiot 公司需要高可用、安全、高性能以及低成本的
Kubernetes 集群。<a href=https://www.cncf.io/case-studies/nexxiot/>他们求助于 Cilium 作为 CNI 来锁定他们的集群，并通过可靠的 Day2 操作实现弹性网络</a>。</li><li>因为创建网络安全策略的过程是一个复杂的多步骤过程，
At-Bay 试图通过使用基于异步消息的通信模式/设施来改善运营。<a href=https://www.cncf.io/case-studies/at-bay/>他们确定 Dapr 满足了其所需的要求清单，且远超预期</a>。</li></ul><h3 id=生态系统更新>生态系统更新</h3><ul><li>2022 北美 KubeCon + CloudNativeCon 将于 2022 年 10 月 24 - 28 日在密歇根州的底特律举行!
你可以在<a href=https://events.linuxfoundation.org/kubecon-cloudnativecon-north-america/>活动网站</a>找到更多关于会议和注册的信息。</li><li>KubeDay 系列活动将于 12 月 7 日在日本 KubeDay 拉开帷幕!
在<a href=https://events.linuxfoundation.org/kubeday-japan/>活动网站</a>上注册或提交提案。</li><li>在 <a href=https://www.cncf.io/announcements/2022/02/10/cncf-sees-record-kubernetes-and-container-adoption-in-2021-cloud-native-survey/>2021 云原生调查</a>中，CNCF 看见了创纪录的 Kubernetes 和容器应用。
请参考<a href=https://www.cncf.io/reports/cncf-annual-survey-2021/>调查结果</a>。</li></ul><h3 id=项目进度>项目进度</h3><p><a href="https://k8s.devstats.cncf.io/d/12/dashboards?orgId=1&refresh=15m">CNCF K8s DevStats</a> 项目汇集了大量关于
Kubernetes 和各种子项目研发进度相关性的有趣的数据点。
其中包括从个人贡献到参与贡献的公司数量的全面信息，
并证明了为发展 Kubernetes 生态系统所做努力的深度和广度。</p><p>在 1.25 版本的发布周期中，
该周期<a href=https://github.com/kubernetes/sig-release/tree/master/releases/release-1.25>运行了 14 周</a> (May 23 to August 23)，
我们看到来着 <a href="https://k8s.devstats.cncf.io/d/9/companies-table?orgId=1&var-period_name=v1.24.0%20-%20v1.25.0&var-metric=contributions">1065 家公司</a>
以及 <a href="https://k8s.devstats.cncf.io/d/66/developer-activity-counts-by-companies?orgId=1&var-period_name=v1.24.0%20-%20v1.25.0&var-metric=contributions&var-repogroup_name=Kubernetes&var-country_name=All&var-companies=All&var-repo_name=kubernetes%2Fkubernetes">1620 位个人</a>所做出的贡献。</p><h2 id=即将举行的网络发布研讨会>即将举行的网络发布研讨会</h2><p>加入 Kubernetes 1.25 版本发布团队的成员，将于 2022 年 9 月 22 日星期四上午 10 点至 11 点(太平洋时间)了解该版本的主要功能，
以及弃用和删除的内容，以帮助制定升级计划。
欲了解更多信息和注册，请访问<a href=https://community.cncf.io/events/details/cncf-cncf-online-programs-presents-cncf-live-webinar-kubernetes-v125-release/>活动页面</a>。</p><h2 id=参与其中>参与其中</h2><p>参与 Kubernetes 最简单的方法就是加入众多<a href=https://github.com/kubernetes/community/blob/master/sig-list.md>特殊兴趣小组</a>(SIGs) 中你感兴趣的一个。
你有什么东西想要跟 Kubernetes 社区沟通吗？
来我们每周的<a href=https://github.com/kubernetes/community/tree/master/communication>社区会议</a>分享你的想法，并参考一下渠道：</p><ul><li>在 <a href=https://www.kubernetes.dev/>Kubernetes 贡献者</a>网站了解更多关于为 Kubernetes 做贡献的信息。</li><li>在 Twitter <a href=https://twitter.com/kubernetesio>@Kubernetesio</a> 上关注我们，了解最新动态。</li><li>在 <a href=https://discuss.kubernetes.io/>Discuss</a> 上加入社区讨论。</li><li>在 <a href=http://slack.k8s.io/>Slack</a> 上加入社区。</li><li>在 <a href=https://serverfault.com/questions/tagged/kubernetes>Server Fault</a> 上发布问题（或者回答问题）。</li><li>分享你的 Kubernetes <a href=https://docs.google.com/a/linuxfoundation.org/forms/d/e/1FAIpQLScuI7Ye3VQHQTwBASrgkjQDSS5TP0g3AXfFhwSM9YpHgxRKFA/viewform>故事</a></li><li>在<a href=https://kubernetes.io/blog/>博客</a>上阅读更多关于 Kubernetes 的情况。</li><li>了解更多关于 <a href=https://github.com/kubernetes/sig-release/tree/master/release-team>Kubernetes 发布团队</a>的信息。</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-9dcab9859b750938304bf4369e15f67a>聚焦 SIG Storage</h1><div class="td-byline mb-4"><time datetime=2022-08-22 class=text-muted>2022.08.22</time></div><p><strong>作者</strong>：Frederico Muñoz (SAS)</p><p>自 Kubernetes 诞生之初，持久数据以及如何解决有状态应用程序的需求一直是一个重要的话题。
对无状态部署的支持是很自然的、从一开始就存在的，并引起了人们的关注，变得众所周知。
从早期开始，我们也致力于更好地支持有状态应用程序，每个版本都增加了可以在 Kubernetes 上运行的范围。</p><p>消息队列、数据库、集群文件系统：这些是具有不同存储要求的解决方案的一些示例，
如今这些解决方案越来越多地部署在 Kubernetes 中。
处理来自许多不同供应商的临时和持久存储（本地或远程、文件或块），同时考虑如何提供用户期望的所需弹性和数据一致性，
所有这些都在 SIG Storage 的整体负责范围之内。</p><p>在这次 SIG Storage 采访报道中，<a href=https://twitter.com/fredericomunoz>Frederico Muñoz</a>
（SAS 的云和架构负责人）与 VMware 技术负责人兼 SIG Storage 联合主席
<a href=https://twitter.com/2000xyang>Xing Yang</a>，讨论了 SIG 的组织方式、当前的挑战是什么以及如何进行参与和贡献。</p><h2 id=关于-sig-storage>关于 SIG Storage</h2><p><strong>Frederico (FSM)</strong>：你好，感谢你给我这个机会了解更多关于 SIG Storage 的情况。
你能否介绍一下你自己、你的角色以及你是如何参与 SIG Storage 的。</p><p><strong>Xing Yang (XY)</strong>：我是 VMware 的技术主管，从事云原生存储方面的工作。我也是 SIG Storage 的联合主席。
我从 2017 年底开始参与 K8s SIG Storage，开始为
<a href=https://kubernetes.io/zh-cn/docs/concepts/storage/volume-snapshots/>VolumeSnapshot</a> 项目做贡献。
那时，VolumeSnapshot 项目仍处于实验性的 pre-alpha 阶段。它需要贡献者。所以我自愿提供帮助。
然后我与其他社区成员合作，在 2018 年的 K8s 1.12 版本中将 VolumeSnapshot 带入 Alpha，
2019 年在 K8s 1.17 版本中带入 Beta，并最终在 2020 年在 1.20 版本中带入 GA。</p><p><strong>FSM</strong>：仅仅阅读 <a href=https://github.com/kubernetes/community/blob/master/sig-storage/charter.md>SIG Storage 章程</a>
就可以看出，SIG Storage 涵盖了很多领域，你能描述一下 SIG 的组织方式吗？</p><p><strong>XY</strong>：在 SIG Storage 中，有两位联合主席和两位技术主管。来自 Google 的 Saad Ali 和我是联合主席。
来自 Google 的 Michelle Au 和来自 Red Hat 的 Jan Šafránek 是技术主管。</p><p>我们每两周召开一次会议，讨论我们正在为每个特定版本开发的功能，获取状态，确保每个功能都有开发人员和审阅人员在处理它，
并提醒人们发布截止日期等。有关 SIG 的更多信息，请查阅<a href=https://github.com/kubernetes/community/tree/master/sig-storage>社区页面</a>。
人们还可以将需要关注的 PR、需要讨论的设计提案和其他议题添加到会议议程文档中。
我们将在项目跟踪完成后对其进行审查。</p><p>我们还举行其他的定期会议，如 CSI 实施会议，Object Bucket API 设计会议，以及在需要时针对特定议题的一次性会议。
还有一个由 SIG Storage 和 SIG Apps 赞助的
<a href=https://github.com/kubernetes/community/blob/master/wg-data-protection/README.md>K8s 数据保护工作组</a>。
SIG Storage 拥有或共同拥有数据保护工作组正在讨论的功能特性。</p><h2 id=存储和-kubernetes>存储和 Kubernetes</h2><p><strong>FSM</strong>：存储是很多模块的基础组件，尤其是 Kubernetes：你认为 Kubernetes 在存储管理方面的具体挑战是什么?</p><p><strong>XY</strong>：在 Kubernetes 中，卷操作涉及多个组件。例如，创建一个使用 PVC 的 Pod 涉及多个组件。
有 Attach Detach Controller 和 external-attacher 负责将 PVC 连接到 Pod。
还有 Kubelet 可以将 PVC 挂载到 Pod 上。当然，CSI 驱动程序也参与其中。
在多个组件之间进行协调时，有时可能会出现竞争状况。</p><p>另一个挑战是关于核心与 <a href=https://kubernetes.io/zh-cn/docs/concepts/extend-kubernetes/api-extension/custom-resources/>Custom Resource Definitions</a>（CRD），
这并不是特定于存储的。CRD 是一种扩展 Kubernetes 功能的好方法，同时又不会向 Kubernetes 核心本身添加太多代码。
然而，这也意味着运行 Kubernetes 集群时需要许多外部组件。</p><p>在 SIG Storage 方面，一个最好的例子是卷快照。卷快照 API 被定义为 CRD。
API 定义和控制器是 out-of-tree。有一个通用的快照控制器和一个快照验证 Webhook
应该部署在控制平面上，类似于 kube-controller-manager 的部署方式。
虽然 Volume Snapshot 是一个 CRD，但它是 SIG Storage 的核心特性。
建议 K8s 集群发行版部署卷快照 CRD、快照控制器和快照验证 Webhook，然而，大多数时候我们没有看到发行版部署它们。
因此，这对存储供应商来说就成了一个问题：现在部署这些非驱动程序特定的通用组件成为他们的责任。
如果客户需要使用多个存储系统，且部署多个 CSI 驱动，可能会导致冲突。</p><p><strong>FSM</strong>：不仅要考虑单个存储系统的复杂性，还要考虑它们在 Kubernetes 中如何一起使用？</p><p><strong>XY</strong>：是的，有许多不同的存储系统可以为 Kubernetes 中的容器提供存储。它们的工作方式不同。找到适合所有人的解决方案是具有挑战性的。</p><p><strong>FSM</strong>：Kubernetes 中的存储还涉及与外部解决方案的交互，可能比 Kubernetes 的其他部分更多。
这种与供应商和外部供应商的互动是否具有挑战性？它是否以任何方式随着时间而演变？</p><p><strong>XY</strong>：是的，这绝对是具有挑战性的。最初 Kubernetes 存储具有 in-tree 卷插件接口。
多家存储供应商实现了 in-tree 接口，并在 Kubernetes 核心代码库中拥有卷插件。这引起了很多问题。
如果卷插件中存在错误，它会影响整个 Kubernetes 代码库。所有卷插件必须与 Kubernetes 一起发布。
如果存储供应商需要修复其插件中的错误或希望与他们自己的产品版本保持一致，这是不灵活的。</p><p><strong>FSM</strong>：这就是 CSI 加入的原因？</p><p><strong>XY</strong>：没错，接下来就是<a href=https://kubernetes-csi.github.io/docs/>容器存储接口</a>（CSI）。
这是一个试图设计通用存储接口的行业标准，以便存储供应商可以编写一个插件并让它在一系列容器编排系统（CO）中工作。
现在 Kubernetes 是主要的 CO，但是在 CSI 刚开始的时候，除了 Kubernetes 之外，还有 Docker、Mesos、Cloud Foundry。
CSI 驱动程序是 out-of-tree 的，因此可以按照自己的节奏进行错误修复和发布。</p><p>与 in-tree 卷插件相比，CSI 绝对是一个很大的改进。CSI 的 Kubernetes
实现<a href=https://kubernetes.io/blog/2019/01/15/container-storage-interface-ga/>自 1.13 版本以来</a>就达到 GA。
它已经发展了很长时间。SIG Storage 一直致力于将 in-tree 卷插件迁移到 out-of-tree 的 CSI 驱动，已经有几个版本了。</p><p><strong>FSM</strong>：将驱动程序从 Kubernetes 主仓移到 CSI 中是一项重要的改进。</p><p><strong>XY</strong>： CSI 接口是对 in-tree 卷插件接口的改进，但是仍然存在挑战。有很多存储系统。
目前在 <a href=https://kubernetes-csi.github.io/docs/drivers.html>CSI 驱动程序文档中列出了 100 多个 CSI 驱动程序</a>。
这些存储系统也非常多样化。因此，很难设计一个适用于所有人的通用 API。
我们在 CSI 驱动层面引入了功能，但当同一驱动配置的卷具有不同的行为时，我们也会面临挑战。
前几天我们刚刚开会讨论每种卷 CSI 驱动程序功能。
当同一个驱动程序同时支持块卷和文件卷时，我们在区分某些 CSI 驱动程序功能时遇到了问题。
我们将召开后续会议来讨论这个问题。</p><h2 id=持续的挑战>持续的挑战</h2><p><strong>FSM</strong>：具体来说，对于 <a href=https://github.com/kubernetes/sig-release/tree/master/releases/release-1.25>1.25 版本</a>
们可以看到管道中有一些与存储相关的 <a href=https://bit.ly/k8s125-enhancements>KEPs</a>。
你是否认为这个版本对 SIG 特别重要？</p><p><strong>XY</strong>：我不会说一个版本比其他版本更重要。在任何给定的版本中，我们都在做一些非常重要的事情。</p><p><strong>FSM</strong>：确实如此，但你是否想指出 1.25 版本的特定特性和亮点呢？</p><p><strong>XY</strong>：好的。对于 1.25 版本，我想强调以下几点：</p><ul><li><a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-storage/625-csi-migration>CSI 迁移</a>
是一项持续的工作，SIG Storage 已经工作了几个版本了。目标是将 in-tree 卷插件移动到 out-of-tree 的
CSI 驱动程序，并最终删除 in-tree 卷插件。在 1.25 版本中，有 7 个 KEP 与 CSI 迁移有关。
有一个核心 KEP 用于通用的 CSI 迁移功能。它的目标是在 1.25 版本中达到 GA。
GCE PD 和 AWS EBS 的 CSI 迁移以 GA 为目标。vSphere 的 CSI 迁移的目标是在默认情况下启用特性门控，
在 1.25 版本中达到 Beta。Ceph RBD 和 PortWorx 的目标是达到 Beta，默认关闭特性门控。
Ceph FS 的目标是达到 Alpha。</li></ul><ul><li>我要强调的第二个是 <a href=https://github.com/kubernetes-sigs/container-object-storage-interface-spec>COSI，容器对象存储接口</a>。
这是 SIG Storage 下的一个子项目。COSI 提出对象存储 Kubernetes API 来支持 Kubernetes 工作负载的对象存储操作的编排。
它还为对象存储提供商引入了 gRPC 接口，以编写驱动程序来配置存储桶。COSI 团队已经在这个项目上工作两年多了。
COSI 功能的目标是 1.25 版本中达到 Alpha。KEP 刚刚合入。COSI 团队正在根据更新后的 KEP 更新实现。</li></ul><ul><li>我要提到的另一个功能是 <a href=https://github.com/kubernetes/enhancements/issues/596>CSI 临时卷</a>支持。
此功能允许在临时用例的 Pod 规约中直接指定 CSI 卷。它们可用于使用已安装的卷直接在 Pod 内注入任意状态，
例如配置、Secrets、身份、变量或类似信息。这最初是在 1.15 版本中作为一个 Alpha 功能引入的，现在它的目标是在 1.25 版本中达到 GA。</li></ul><p><strong>FSM</strong>：如果你必须单独列出一些内容，那么 SIG 正在研究的最紧迫的领域是什么?</p><p><strong>XY</strong>：CSI 迁移绝对是 SIG 投入大量精力的领域之一，并且现在已经进行了多个版本。它还涉及来自多个云提供商和存储供应商的工作。</p><h2 id=社区参与>社区参与</h2><p><strong>FSM</strong>：Kubernetes 是一个社区驱动的项目。对任何希望参与 SIG Storage 工作的人有什么建议吗？他们应该从哪里开始？</p><p><strong>XY</strong>：查看 <a href=https://github.com/kubernetes/community/tree/master/sig-storage>SIG Storage 社区页面</a>，
它有很多关于如何开始的信息。<a href=https://github.com/kubernetes/community/blob/master/sig-storage/annual-report-2021.md>SIG 年度报告</a>告诉你我们每年做了什么。
查看贡献指南。它有一些演示的链接，可以帮助你熟悉 Kubernetes 存储概念。</p><p>参加我们<a href=https://github.com/kubernetes/community/tree/master/sig-storage#meetings>在星期四举行的双周会议</a>。
了解 SIG 的运作方式以及我们为每个版本所做的工作。找到你感兴趣的项目并提供贡献。
正如我之前提到的，我通过参与 Volume Snapshot 项目开始了 SIG Storage。</p><p><strong>FSM</strong>：你有什么要补充的结束语吗？</p><p><strong>XY</strong>：SIG Storage 总是欢迎新的贡献者。
我们需要贡献者来帮助构建新功能、修复错误、进行代码审查、编写测试、监控测试网格的健康状况以及改进文档等。</p><p><strong>FSM</strong>：非常感谢你抽出宝贵时间让我们深入了解 SIG Storage！</p></div><div class=td-content style=page-break-before:always><h1 id=pg-6b8174d24c6f88a481cba57441cd7410>认识我们的贡献者 - 亚太地区（中国地区）</h1><div class="td-byline mb-4"><time datetime=2022-08-15 class=text-muted>2022.08.15</time></div><p><strong>作者和受访者：</strong> <a href=https://github.com/AvineshTripathi>Avinesh Tripathi</a>、
<a href=https://github.com/Debanitrkl>Debabrata Panigrahi</a>、
<a href=https://github.com/jayesh-srivastava>Jayesh Srivastava</a>、
<a href=https://github.com/Priyankasaggu11929/>Priyanka Saggu</a>、
<a href=https://github.com/PurneswarPrasad>Purneswar Prasad</a>、
<a href=https://github.com/vedant-kakde>Vedant Kakde</a></p><hr><p>大家好 👋</p><p>欢迎来到亚太地区的 “认识我们的贡献者” 博文系列第三期。</p><p>这篇博文介绍了四名来自中国的优秀贡献者，他们在上游 Kubernetes 项目中扮演了不同的领导角色和社区角色。</p><p>闲话少说，让我们直接进入正文。</p><h2 id=andy-zhang-https-github-com-andyzhangx><a href=https://github.com/andyzhangx>Andy Zhang</a></h2><p>Andy Zhang 目前就职于微软中国上海办事处，他主要关注 Kubernetes 存储驱动。
Andy 大约在 5 年前开始为 Kubernetes 做贡献。</p><p>他说由于自己为 Azure Kubernetes Service 团队工作，所以大部分时间都在为 Kubernetes 社区项目做贡献。
现在他是很多 Kubernetes 子项目的主要贡献者，例如 Kubernetes cloud-provider 仓库的代码。</p><p>他的开源贡献主要是出于自我激励。在过去的两年里，他通过 LFX Mentorship 计划指导了一些学生为 Kubernetes 做贡献，
其中一些学生凭借 Kubernetes 项目积累的专业知识和贡献经历而找到了工作。</p><p>Andy 是 Kubernetes 中国社区的活跃成员。
他补充说，Kubernetes 社区对如何成为 Member、Code Reviewer、Approver 有完善的指导说明，
后来他发现一些开源项目还处于非常早期的阶段，他积极地为这些项目做了贡献并成为了项目维护者。</p><h2 id=shiming-zhang-https-github-com-wzshiming><a href=https://github.com/wzshiming>Shiming Zhang</a></h2><p>Shiming Zhang 是一名软件工程师，供职于中国上海道客网络科技。</p><p>他主要以 Reviewer 的身份参与 SIG Node。他的主要贡献集中在当下的
<a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-node/2712-pod-priority-based-graceful-node-shutdown>KEP</a>
的漏洞修复和功能优化，这些工作全部围绕 SIG Node 展开。</p><p>他发起的一些主要 PR 有
<a href=https://github.com/kubernetes/kubernetes/pull/100326>fixing watchForLockfileContention memory leak</a>、
<a href=https://github.com/kubernetes/kubernetes/pull/101093>fixing startupProbe behaviour</a>、
<a href=https://github.com/kubernetes/enhancements/pull/2661>adding Field status.hostIPs for Pod</a>。</p><h2 id=paco-xu-https-github-com-pacoxu><a href=https://github.com/pacoxu>Paco Xu</a></h2><p>Paco Xu 就职于上海的一家云原生公司：道客网络科技。
他与基础设施和开源团队合作，专注于基于 Kubernetes 的企业云原生平台。</p><p>他在 2017 年初开始使用 Kubernetes，他的第一个贡献是在 2018 年 3 月。
他的贡献始于自己发现的一个漏洞，但当时他的解决方案不是那么优雅，因此没有被接受。
然后他从一些 Good First Issue 开始做贡献，这在很大程度上帮助了他。
除此之外，在 2016 到 2017 年间，他还对 Docker 做出了一些小贡献。</p><p>目前，Paco 是 <code>kubeadm</code>（一个 SIG Cluster Lifecycle 产品）和 SIG Node 的 Reviewer。</p><p>Paco 说大家应该为自己使用的开源项目做贡献。
对他来说，开源项目就像一本要学习的书，通过与项目维护者们讨论可以获得启发。</p><blockquote><p>在我看来，对我来说最好的方式是学习项目所有者如何处理项目。</p></blockquote><h2 id=jintao-zhang-https-github-com-tao12345666333><a href=https://github.com/tao12345666333>Jintao Zhang</a></h2><p>Jintao Zhang 目前受聘于 API7，他专注于 Ingress 和服务网格。</p><p>2017 年，他遇到了一个引发社区讨论的问题，并开始了对 Kubernetes 做贡献。
在为 Kubernetes 做贡献之前，Jintao 是 Docker 相关开源项目的长期贡献者。</p><p>目前 Jintao 是 <a href=https://kubernetes.github.io/ingress-nginx/>ingress-nginx</a> 项目的 Reviewer。</p><p>他建议关注开源公司的工作机会，这样你就可以找到一个可以让你全职贡献的机会。
对于新的贡献者们，Jintao 表示如果有人想为一个开源项目做重大贡献，
那么应该根据自己的兴趣选择项目，然后应该慷慨地投入时间。</p><hr><p>如果你对我们下一步应该采访谁有任何想法/建议，请在
<a href=https://kubernetes.slack.com/archives/C1TU9EB9S>#sig-contribex 频道</a>中告知我们。
我们很高兴有其他人帮助我们接触社区中更优秀的人。我们将不胜感激。</p><p>我们下期见。最后，祝大家都能快乐地为社区做贡献！👋</p></div><div class=td-content style=page-break-before:always><h1 id=pg-521cdf1f63dab59d99d9a50b588c602a>逐个 KEP 地增强 Kubernetes</h1><div class="td-byline mb-4"><time datetime=2022-08-11 class=text-muted>2022.08.11</time></div><p><strong>作者：</strong> Ryler Hockenbury（Mastercard）</p><p>你是否知道 Kubernetes v1.24 有
<a href=https://kubernetes.io/zh-cn/blog/2022/05/03/kubernetes-1-24-release-announcement/>46 个增强特性</a>？
在为期 4 个月的发布周期内包含了大量新特性。
Kubernetes 发布团队协调发布的后勤工作，从修复测试问题到发布更新的文档。他们需要完成成吨的工作，但发布团队总是能按期交付。</p><p>发布团队由大约 30 人组成，分布在六个子团队：Bug Triage、CI Signal、Enhancements、Release Notes、Communications 和 Docs。
每个子团队负责管理发布的一个组件。这篇博文将重点介绍增强子团队的角色以及你如何能够参与其中。</p><h2 id=增强子团队是什么>增强子团队是什么？</h2><p>好问题。我们稍后会讨论这个问题，但首先让我们谈谈 Kubernetes 中是如何管理功能特性的。</p><p>每个新特性都需要一个 <a href=https://github.com/kubernetes/enhancements/blob/master/keps/README.md>Kubernetes 增强提案</a>，
简称为 KEP。KEP 是一些小型结构化设计文档，提供了一种提出和协调新特性的方法。
KEP 作者描述其提案动机、设计理念（和替代方案）、风险和测试，然后社区成员会提供反馈以达成共识。</p><p>你可以通过 <a href=https://github.com/kubernetes/enhancements>Kubernetes/enhancements 仓库</a>的拉取请求（PR）工作流来提交和更新 KEP。
每个功能特性始于 Alpha 阶段，随着不断成熟，经由毕业流程进入 Beta 和 Stable 阶段。
这里有一个很酷的 KEP 例子，是关于 <a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-windows/1981-windows-privileged-container-support/kep.yaml>Windows Server 上的特权容器支持</a>。
这个 KEP 在 Kubernetes v1.22 中作为 Alpha 引入，并在 v1.23 中进入 Beta 阶段。</p><p>现在回到上一个问题：增强子团队如何协调每个版本的 KEP 生命周期跟踪。
每个 KEP 都必须满足一组清晰具体的要求，才能被纳入一个发布版本中。
增强子团队负责验证每个 KEP 的要求并跟踪其状态。</p><p>在一个发行版本启动时，各个 <a href=https://github.com/kubernetes/community/blob/master/sig-list.md>Kubernetes 特别兴趣小组</a> (SIG)
会提交各自的增强特性以进入某版本发布。通常一个版本最初可能有 60 到 90 个增强特性。随后，许多增强特性会被过滤掉。
这是因为有些不完全符合 KEP 要求，而另一些还未完成代码的实现。最初选择加入的 KEP 中大约有 60% - 70% 将进入最终发布。</p><h2 id=增强子团队做什么>增强子团队做什么？</h2><p>这是另一个很好的问题，切中了要点！增强特性的团队在每个版本中会涉及两个重要的里程碑：增强特性冻结和代码冻结。</p><h4 id=增强特性冻结>增强特性冻结</h4><p>增强特性冻结是一个 KEP 按序完成增强特性并纳入一个发布版本的最后期限。
这是一个质量门控，用于强制对齐与 KEP 维护和更新相关的事项。
最值得注意的要求是
(1) <a href=https://github.com/kubernetes/community/blob/master/sig-architecture/production-readiness.md>生产就绪审查</a>(PRR)
和 (2) 附带完整测试计划和毕业标准的 <a href=https://github.com/kubernetes/enhancements/tree/master/keps/NNNN-kep-template>KEP 文件</a>。</p><p>增强子团队通过在 Github 上对 KEP 问题发表评论与每位 KEP 作者进行沟通。
作为第一步，子团队成员将检查 KEP 状态并确认其是否符合要求。
KEP 在满足要求后被标记为已被跟踪（Tracked）；否则，它会被认为有风险。
如果在增强特性冻结生效时 KEP 仍然存在风险，该 KEP 将被从发布版本中移除。</p><p>在发布周期的这个阶段，增强子团队通常是最繁忙的，因为他们要梳理大量的 KEP，可能需要反复审查每个 KEP 才能验证某个 KEP 是否满足要求。</p><h4 id=代码冻结>代码冻结</h4><p>代码冻结是从代码上实现所有增强特性的最后期限。
如果某增强特性的代码需要更改或更新，则必须在这个时间节点完成所有代码实现、代码审查和代码合并工作。
版本发布的最后三个工作专注于稳定代码库：修复测试问题，解决各种回归并准备文档。而在此之前，所有代码必须就位。</p><p>增强子团队将验证某增强特性相关的所有 PR 均已合并到 <a href=https://github.com/kubernetes/kubernetes>Kubernetes 代码库</a> (k/k)。
在此期间，子团队将联系 KEP 作者以了解哪些 PR 是 KEP 的一部分，检查这些 PR 是否已合并，然后更新 KEP 的状态。
如果在代码冻结的最后期限之前这些代码还未全部合并，该增强特性将从发布版本中移除。</p><h2 id=我如何才能参与发布团队>我如何才能参与发布团队？</h2><p>很高兴你提出这个问题。
最直接的方式就是申请成为一名<a href=https://github.com/kubernetes/sig-release/blob/master/release-team/shadows.md>发布团队影子</a>。
影子角色是一个见习职位，旨在帮助个人在发布团队中担任领导职位做好准备。许多影子角色是非技术性的，且不需要事先对 Kubernetes 代码库做出贡献。</p><p>Kubernetes 每年发布 3 个版本，每个版本大约有 25 个影子，发布团队总是需要愿意做出贡献的人。
在每个发布周期之前，发布团队都会为影子计划打开申请渠道。当申请渠道上线时，
会公布在 <a href=https://groups.google.com/a/kubernetes.io/g/dev>Kubernetes 开发邮件清单</a>中。
你可以订阅该列表中的通知（或定期查看！），以了解申请渠道何时开通。该公告通常会在 4 月中旬、7 月中旬和 12 月中旬发布，
或者在每个版本开始前大约一个月时发布。</p><h2 id=我怎样才能找到更多信息>我怎样才能找到更多信息？</h2><p>如果你对所有 Kubernetes 发布子团队的详情感到好奇，
请查阅<a href=https://github.com/kubernetes/sig-release/tree/master/release-team/role-handbooks>角色手册</a>。
这些手册记录了每个子团队的后勤工作，包括每周对子团队活动的细分任务。这是更好地了解每个团队的绝佳参考。</p><p>你还可以查看与发布相关的 Kubernetes slack 频道，特别是 #release、#sig-release 和 #sig-arch。
这些频道围绕发布的许多方面进行了讨论和更新。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-7b77bba01cdcca4f5618d16f23009b6f>Kubernetes 1.25 的移除说明和主要变更</h1><div class="td-byline mb-4"><time datetime=2022-08-04 class=text-muted>2022.08.04</time></div><p><strong>作者</strong>：Kat Cosgrove、Frederico Muñoz、Debabrata Panigrahi</p><p>随着 Kubernetes 成长和日趋成熟，为了此项目的健康发展，某些功能特性可能会被弃用、移除或替换为优化过的功能特性。
Kubernetes v1.25 包括几个主要变更和一个主要移除。</p><h2 id=the-kubernetes-api-removal-and-deprecation-process>Kubernetes API 移除和弃用流程</h2><p>Kubernetes 项目对功能特性有一个文档完备的<a href=/zh-cn/docs/reference/using-api/deprecation-policy/>弃用策略</a>。
该策略规定，只有当较新的、稳定的相同 API 可用时，原有的稳定 API 才可能被弃用，每个稳定级别的 API 都有一个最短的生命周期。
弃用的 API 指的是已标记为将在后续发行某个 Kubernetes 版本时移除的 API；
移除之前该 API 将继续发挥作用（从弃用起至少一年时间），但使用时会显示一条警告。
移除的 API 将在当前版本中不再可用，此时你必须迁移以使用替换的 API。</p><ul><li>正式发布（GA）或稳定的 API 版本可能被标记为已弃用，但只有在 Kubernetes 大版本更新时才会移除。</li><li>测试版（Beta）或预发布 API 版本在弃用后必须支持 3 个版本。</li><li>Alpha 或实验性 API 版本可能会在任何版本中被移除，恕不另行通知。</li></ul><p>无论一个 API 是因为某功能特性从 Beta 进入稳定阶段而被移除，还是因为该 API 根本没有成功，
所有移除均遵从上述弃用策略。无论何时移除一个 API，文档中都会列出迁移选项。</p><h2 id=a-note-about-podsecuritypolicy>有关 PodSecurityPolicy 的说明</h2><p><a href=/blog/2021/04/06/podsecuritypolicy-deprecation-past-present-and-future/>继 PodSecurityPolicy 在 v1.21 弃用后</a>，
Kubernetes v1.25 将移除 PodSecurityPolicy。PodSecurityPolicy 曾光荣地为我们服务，
但由于其复杂和经常令人困惑的使用方式，让大家觉得有必要进行修改，但很遗憾这种修改将会是破坏性的。
为此我们移除了 PodSecurityPolicy，取而代之的是 Pod Security Admission（即 PodSecurity 安全准入控制器），
后者在本次发行中也进入了稳定阶段。
如果你目前正依赖 PodSecurityPolicy，请遵循指示说明<a href=/zh-cn/docs/tasks/configure-pod-container/migrate-from-psp/>迁移到 PodSecurity 准入控制器</a>。</p><h2 id=major-changes-for-kubernetes-v1.25>Kubernetes v1.25 的主要变更</h2><p>Kubernetes v1.25 除了移除 PodSecurityPolicy 之外，还将包括以下几个主要变更。</p><h3 id=csi-migration-https-github-com-kubernetes-enhancements-issues-625><a href=https://github.com/kubernetes/enhancements/issues/625>CSI Migration</a></h3><p>将树内卷插件迁移到树外 CSI 驱动的努力还在继续，核心的 CSI Migration 特性在 v1.25 进入 GA 阶段。
对于全面移除树内卷插件而言，这是重要的一步。</p><h3 id=deprecations-and-removals-for-storage-drivers>存储驱动的弃用和移除</h3><p>若干卷插件将被弃用或移除。</p><p><a href=https://github.com/kubernetes/enhancements/issues/3446>GlusterFS 将在 v1.25</a> 中被弃用。
虽然为其构建了 CSI 驱动，但未曾得到维护。
社区<a href=https://github.com/kubernetes/kubernetes/issues/100897>曾讨论</a>迁移到一个兼容 CSI 驱动的可能性，
但最终决定开始从树内驱动中弃用 GlusterFS 插件。
本次发行还会弃用 <a href=https://github.com/kubernetes/enhancements/issues/2589>Portworx 树内卷插件</a>。
Flocker、Quobyte 和 StorageOS 树内卷插件将被移除。</p><p><a href=https://github.com/kubernetes/kubernetes/pull/111618>Flocker</a>、
<a href=https://github.com/kubernetes/kubernetes/pull/111619>Quobyte</a> 和
<a href=https://github.com/kubernetes/kubernetes/pull/111620>StorageOS</a> 树内卷插件将作为
<a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-storage/625-csi-migration>CSI Migration</a>
的一部分在 v1.25 中移除。</p><h3 id=对-vsphere-版本支持的变更-https-github-com-kubernetes-kubernetes-pull-111255><a href=https://github.com/kubernetes/kubernetes/pull/111255>对 vSphere 版本支持的变更</a></h3><p>从 Kubernetes v1.25 开始，树内 vSphere 卷驱动将不支持任何早于 7.0u2 的 vSphere 版本。
查阅 v1.25 详细发行说明，了解如何处理这种状况的更多建议。</p><h3 id=清理-iptables-链的所有权-https-github-com-kubernetes-enhancements-issues-3178><a href=https://github.com/kubernetes/enhancements/issues/3178>清理 IPTables 链的所有权</a></h3><p>在 Linux 上，Kubernetes（通常）创建 iptables 链来确保这些网络数据包到达，
尽管这些链及其名称已成为内部实现的细节，但某些工具已依赖于此行为。
将仅支持内部 Kubernetes 使用场景。
从 v1.25 开始，Kubelet 将逐渐迁移为不在 <code>nat</code> 表中创建以下 iptables 链：</p><ul><li><code>KUBE-MARK-DROP</code></li><li><code>KUBE-MARK-MASQ</code></li><li><code>KUBE-POSTROUTING</code></li></ul><p>此项变更将通过 <code>IPTablesCleanup</code> 特性门控分阶段完成。
尽管这不是正式的弃用，但某些最终用户已开始依赖 <code>kube-proxy</code> 特定的内部行为。
Kubernetes 项目总体上希望明确表示不支持依赖这些内部细节，并且未来的实现将更改它们在此处的行为。</p><h2 id=looking-ahead>展望未来</h2><p><a href=/zh-cn/docs/reference/using-api/deprecation-guide/#v1-26>Kubernetes 1.26 计划移除的 API 的正式列表</a>为：</p><ul><li>Beta 版 FlowSchema 和 PriorityLevelConfiguration API（flowcontrol.apiserver.k8s.io/v1beta1）</li><li>Beta 版 HorizontalPodAutoscaler API（autoscaling/v2beta2）</li></ul><h3 id=want-to-know-more>了解更多</h3><p>Kubernetes 发行说明公布了弃用信息。你可以在以下版本的发行说明中查看待弃用特性的公告：</p><ul><li><a href=https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG/CHANGELOG-1.21.md#deprecation>Kubernetes 1.21</a></li><li><a href=https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG/CHANGELOG-1.22.md#deprecation>Kubernetes 1.22</a></li><li><a href=https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG/CHANGELOG-1.23.md#deprecation>Kubernetes 1.23</a></li><li><a href=https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG/CHANGELOG-1.24.md#deprecation>Kubernetes 1.24</a></li><li>我们将正式宣布 <a href=https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG/CHANGELOG-1.25.md#deprecation>Kubernetes 1.25</a>
的弃用信息，作为该版本 CHANGELOG 的一部分。</li></ul><p>有关弃用和移除流程的信息，请查阅 Kubernetes
官方<a href=/zh-cn/docs/reference/using-api/deprecation-policy/#deprecating-parts-of-the-api>弃用策略</a>文档。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-ba41c0ba8b1baf0695e430635c1306f4>聚光灯下的 SIG Docs</h1><div class="td-byline mb-4"><time datetime=2022-08-02 class=text-muted>2022.08.02</time></div><p><strong>作者：</strong> Purneswar Prasad</p><h2 id=简介>简介</h2><p>官方文档是所有开源项目的首选资料源。对于 Kubernetes，它是一个持续演进的特别兴趣小组 (SIG)，
人们持续不断努力制作详实的项目资料，让新贡献者和用户更容易取用这些文档。
SIG Docs 在 <a href=https://kubernetes.io>kubernetes.io</a> 上发布官方文档，
包括但不限于 Kubernetes 版本发布时附带的核心 API 文档、核心架构细节和 CLI 工具文档。</p><p>为了了解 SIG Docs 的工作及其在塑造社区未来方面的更多信息，我总结了自己与联合主席
<a href=https://twitter.com/Divya_Mohan02>Divya Mohan</a>（下称 DM）、
<a href=https://twitter.com/reylejano>Rey Lejano</a>（下称 RL）和 Natali Vlatko（下称 NV）的谈话，
他们讲述了 SIG 的目标以及其他贡献者们如何从旁协助。</p><h2 id=谈话汇总>谈话汇总</h2><h3 id=你能告诉我们-sig-docs-具体做什么吗>你能告诉我们 SIG Docs 具体做什么吗？</h3><p>SIG Docs 是 kubernetes.io 上针对 Kubernetes 项目文档的特别兴趣小组，
为 Kubernetes API、kubeadm 和 kubectl 制作参考指南，并维护官方网站的基础设施和数据分析。
他们的工作范围还包括文档发布、文档翻译、改进并向现有文档添加新功能特性、推送和审查官方 Kubernetes 博客的内容，
并在每个发布周期与发布团队合作以审查文档和博客。</p><h3 id=docs-下有-2-个子项目-博客和本地化-社区如何从中受益-你想强调的这些团队是否侧重于某些贡献>Docs 下有 2 个子项目：博客和本地化。社区如何从中受益？你想强调的这些团队是否侧重于某些贡献？</h3><p><strong>博客</strong>：这个子项目侧重于介绍新的或毕业的 Kubernetes 增强特性、社区报告、SIG 更新或任何与 Kubernetes
社区相关的新闻，例如思潮引领、教程和项目更新，例如即将在 1.25 版本中移除 Dockershim 和 PodSecurityPolicy。
Tim Bannister 是 SIG Docs 技术负责人之一，他做得工作非常出色，是推动文档和博客贡献的主力人物。</p><p><strong>本地化</strong>：通过这个子项目，Kubernetes 社区能够在用户和贡献者之间实现更大的包容性和多样性。
自几年前以来，这也帮助该项目获得了更多的贡献者，尤其是学生们。
主要亮点之一是即将到来的本地化版本：印地语和孟加拉语。印地语的本地化工作目前由印度的学生们牵头。</p><p>除此之外，还有另外两个子项目：<a href=https://github.com/kubernetes-sigs/reference-docs>reference-docs</a> 和
<a href=https://github.com/kubernetes/website>website</a>，后者采用 Hugo 构建，是 Kubernetes 拥有的一个重要阵地。</p><h3 id=dockershim-removal>最近有很多关于 Kubernetes 生态系统以及业界对最新 1.24 版本中移除 Dockershim 的讨论。SIG Docs 如何帮助该项目确保最终用户们平滑变更？</h3><p>与 Dockershim 移除有关的文档工作是一项艰巨的任务，需要修改现有文档并就弃用工作与各种利益相关方进行沟通。
这需要社区的努力，因此在 1.24 版本发布之前，SIG Docs 与 Docs and Comms 垂直行业、来自发布团队的发布负责人以及
CNCF 建立合作关系，帮助在全网宣传。设立了每周例会和 GitHub 项目委员会，以跟踪进度、审查问题和批准 PR，
并保持更新 Kubernetes 网站。这也有助于新的贡献者们了解这次弃用，因此如果出现任何 good-first-issue，
新的贡献者也可以参与进来。开通了专用的 Slack 频道用于交流会议更新、邀请反馈或就悬而未决的问题和 PR 寻求帮助。
每周例会在 1.24 发布后也持续了一个月，以审查并修复相关问题。
非常感谢 <a href=https://twitter.com/celeste_horgan>Celeste Horgan</a>，与他的顺畅交流贯穿了这个弃用过程的前前后后。</p><h3 id=为什么新老贡献者都应该考虑加入这个-sig>为什么新老贡献者都应该考虑加入这个 SIG？</h3><p>Kubernetes 是一个庞大的项目，起初可能会让很多人难以找到切入点。
任何开源项目的优劣总能从文档质量略窥一二，SIG Docs 的目标是建设一个欢迎新贡献者加入并对其有帮助的地方。
希望所有人可以轻松参与该项目的文档，并能从阅读中受益。他们还可以带来自己的新视角，以制作和改进文档。
从长远来看，如果他们坚持参与 SIG Docs，就可以拾阶而上晋升成为维护者。
这将有助于使 Kubernetes 这样的大型项目更易于解析和导航。</p><h3 id=你如何帮助新的贡献者入门-加入有什么前提条件吗>你如何帮助新的贡献者入门？加入有什么前提条件吗？</h3><p>开始为 Docs 做贡献没有这样的前提条件。但肯定有一个很棒的对文档做贡献的指南，这个指南始终尽可能保持更新和贴合实际，
希望新手们多多阅读并将其放在趁手的地方。此外，社区 Slack 频道
<a href=https://kubernetes.slack.com/archives/C1J0BPD2M>#sig-docs</a> 中有很多有用的便贴和书签。
kubernetes/website 仓库中带有 good-first-issue 标签的那些 GitHub 问题是创建你的第一个 PR 的好地方。
现在，SIG Docs 在每月的第一个星期二配合第一任 New Contributor Ambassador（新贡献者大使）角色
<a href=https://twitter.com/RinkiyaKeDad>Arsh Sharma</a> 召开月度 New Contributor Meet and Greet（新贡献者见面会）。
这有助于在 SIG 内为新的贡献者建立一个更容易参与的联络形式。</p><h3 id=你是否有任何真正自豪的-sig-相关成绩>你是否有任何真正自豪的 SIG 相关成绩？</h3><p><strong>DM & RL</strong> ：鉴于来自不同国家的贡献者们做出的所有出色工作，
过去几个月本地化子项目的正式推行对 SIG Docs 来说是一个巨大的胜利。
早些时候，本地化工作还没有任何流水线的流程，过去几个月的重点是通过起草一份 KEP 为本地化正式成为一个子项目提供一个框架，
这项工作计划在第三个季度结束时完成。</p><p><strong>DM</strong>：另一个取得很大成功的领域是 New Contributor Ambassador（新贡献者大使）角色，
这个角色有助于为新贡献者参与项目提供更便捷的联系形式。</p><p><strong>NV</strong>：对于每个发布周期，SIG Docs 都必须在短时间内评审突出介绍发布更新的发布文档和功能特性博客。
这对于文档和博客审阅者来说，始终需要付出巨大的努力。</p><h3 id=你是否有一些关于-sig-docs-未来令人兴奋的举措想让社区知道>你是否有一些关于 SIG Docs 未来令人兴奋的举措想让社区知道？</h3><p>SIG Docs 现在期望设计一个路线图，建立稳定的人员流转机制以期推动对文档的改进，
简化社区参与 Issue 评判和已提交 PR 的评审工作。
为了建立一个这样由贡献者和 Reviewer 组成的群体，我们正在设立一项辅导计划帮助当前的贡献者们成为 Reviewer。
这绝对是一项值得关注的举措！</p><h2 id=结束语>结束语</h2><p>SIG Docs 在 KubeCon + CloudNativeCon North America 2021
期间举办了一次<a href="https://www.youtube.com/watch?v=GDfcBF5et3Q">深度访谈</a>，涵盖了他们很棒的 SIG 主题。
他们非常欢迎想要为 Kubernetes 项目做贡献的新人，对这些新人而言 SIG Docs 已成为加入 Kubernetes 的起跳板。
欢迎加入 <a href=https://github.com/kubernetes/community/blob/master/sig-docs/README.md>SIG 会议</a>，
了解最新的研究成果、来年的计划以及如何作为贡献者参与上游 Docs 团队！</p></div><div class=td-content style=page-break-before:always><h1 id=pg-4e212b6d4e0507f556831f8314597a09>Kubernetes Gateway API 进入 Beta 阶段</h1><div class="td-byline mb-4"><time datetime=2022-07-13 class=text-muted>2022.07.13</time></div><p><strong>作者：</strong> Shane Utt (Kong)、Rob Scott (Google)、Nick Young (VMware)、Jeff Apple (HashiCorp)</p><p>我们很高兴地宣布 Gateway API 的 v0.5.0 版本发布。
我们最重要的几个 Gateway API 资源首次进入 Beta 阶段。
此外，我们正在启动一项新的倡议，探索如何将 Gateway API 用于网格，还引入了 URL 重写等新的实验性概念。
下文涵盖了这部分内容和更多说明。</p><h2 id=什么是-gateway-api>什么是 Gateway API？</h2><p>Gateway API 是以 <a href=https://gateway-api.sigs.k8s.io/api-types/gateway/>Gateway</a> 资源（代表底层网络网关/代理服务器）为中心的资源集合，
Kubernetes 服务网络的健壮性得益于众多供应商实现、得到广泛行业支持且极具表达力、可扩展和面向角色的各个接口。</p><p>Gateway API 最初被认为是知名 <a href=/zh-cn/docs/reference/kubernetes-api/service-resources/ingress-v1/>Ingress</a> API 的继任者，
Gateway API 的好处包括（但不限于）对许多常用网络协议的显式支持
（例如 <code>HTTP</code>、<code>TLS</code>、<code>TCP </code>、<code>UDP</code>) 以及对传输层安全 (TLS) 的紧密集成支持。
特别是 <code>Gateway</code> 资源能够实现作为 Kubernetes API 来管理网络网关的生命周期。</p><p>如果你是对 Gateway API 的某些优势感兴趣的终端用户，我们邀请你加入并找到适合你的实现方式。
值此版本发布之时，对于流行的 API 网关和服务网格有十多种<a href=https://gateway-api.sigs.k8s.io/implementations/>实现</a>，还提供了操作指南便于快速开始探索。</p><h3 id=入门>入门</h3><p>Gateway API 是一个类似 <a href=/zh-cn/docs/concepts/services-networking/ingress/>Ingress</a>
的正式 Kubernetes API。Gateway API 代表了 Ingress 功能的一个父集，使得一些更高级的概念成为可能。
与 Ingress 类似，Kubernetes 中没有内置 Gateway API 的默认实现。
相反，有许多不同的<a href=https://gateway-api.sigs.k8s.io/implementations/>实现</a>可用，在提供一致且可移植体验的同时，还在底层技术方面提供了重要的选择。</p><p>查看 <a href=https://gateway-api.sigs.k8s.io/concepts/api-overview/>API 概念文档</a> 并查阅一些<a href=https://gateway-api.sigs.k8s.io/guides/getting-started/>指南</a>以开始熟悉这些 API 及其工作方式。
当你准备好一个实用的应用程序时，
请打开<a href=https://gateway-api.sigs.k8s.io/implementations/>实现页面</a>并选择属于你可能已经熟悉的现有技术或集群提供商默认使用的技术（如果适用）的实现。
Gateway API 是一个基于 <a href=/zh-cn/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/>CRD</a> 的 API，因此你将需要<a href=https://gateway-api.sigs.k8s.io/guides/getting-started/#install-the-crds>安装 CRD</a> 到集群上才能使用该 API。</p><p>如果你对 Gateway API 做贡献特别有兴趣，我们非常欢迎你的加入！
你可以随时在仓库上<a href=https://github.com/kubernetes-sigs/gateway-api/issues/new/choose>提一个新的 issue</a>，或<a href=https://github.com/kubernetes-sigs/gateway-api/discussions>加入讨论</a>。
另请查阅<a href=https://gateway-api.sigs.k8s.io/contributing/community/>社区页面</a>以了解 Slack 频道和社区会议的链接。</p><h2 id=发布亮点>发布亮点</h2><h3 id=进入-beta-阶段>进入 Beta 阶段</h3><p><code>v0.5.0</code> 版本特别具有历史意义，因为它标志着一些关键 API 成长至 Beta API 版本（<code>v1beta1</code>）：</p><ul><li><a href=https://gateway-api.sigs.k8s.io/api-types/gatewayclass/>GatewayClass</a></li><li><a href=https://gateway-api.sigs.k8s.io/api-types/gateway/>Gateway</a></li><li><a href=https://gateway-api.sigs.k8s.io/api-types/httproute/>HTTPRoute</a></li></ul><p>这一成就的标志是达到了以下几个进入标准：</p><ul><li>API 已<a href=https://gateway-api.sigs.k8s.io/implementations/>广泛实现</a>。</li><li>合规性测试基本覆盖了所有资源且可以让多种实现通过测试。</li><li>大多数 API 接口正被积极地使用。</li><li>Kubernetes SIG Network API 评审团队已批准其进入 Beta 阶段。</li></ul><p>有关 Gateway API 版本控制的更多信息，请参阅<a href=https://gateway-api.sigs.k8s.io/concepts/versioning/>官方文档</a>。
要查看未来版本的计划，请查看<a href=#next-steps>下一步</a>。</p><h3 id=发布渠道>发布渠道</h3><p>此版本引入了 <code>experimental</code> 和 <code>standard</code> <a href=https://gateway-api.sigs.k8s.io/concepts/versioning/#release-channels-eg-experimental-standard>发布渠道</a>，
这样能够更好地保持平衡，在确保稳定性的同时，还能支持实验和迭代开发。</p><p><code>standard</code> 发布渠道包括：</p><ul><li>已进入 Beta 阶段的资源</li><li>已进入 standard 的字段（不再被视为 experimental）</li></ul><p><code>experimental</code> 发布渠道包括 <code>standard</code> 发布渠道的所有内容，另外还有：</p><ul><li><code>alpha</code> API 资源</li><li>视为 experimental 且还未进入 <code>standard</code> 渠道的字段</li></ul><p>使用发布渠道能让内部实现快速流转的迭代开发，且能让外部实现者和最终用户标示功能稳定性。</p><p>本次发布新增了以下实验性的功能特性：</p><ul><li><a href=https://gateway-api.sigs.k8s.io/geps/gep-957/>路由通过指定端口号可以挂接到 Gateway</a></li><li><a href=https://gateway-api.sigs.k8s.io/geps/gep-726/>URL 重写和路径重定向</a></li></ul><h3 id=其他改进>其他改进</h3><p>有关 <code>v0.5.0</code> 版本中包括的完整变更清单，请参阅
<a href=https://github.com/kubernetes-sigs/gateway-api/releases/tag/v0.5.0>v0.5.0 发布说明</a>。</p><h2 id=适用于服务网格的-gateway-api-gamma-倡议>适用于服务网格的 Gateway API：GAMMA 倡议</h2><p>某些服务网格项目<a href=https://gateway-api.sigs.k8s.io/implementations/>已实现对 Gateway API 的支持</a>。
服务网格接口 (Service Mesh Interface，SMI) API 和 Gateway API 之间的显著重叠
<a href=https://github.com/servicemeshinterface/smi-spec/issues/249>已激发了 SMI 社区讨论</a>可能的集成方式。</p><p>我们很高兴地宣布，来自 Cilium Service Mesh、Consul、Istio、Kuma、Linkerd、NGINX Service Mesh
和 Open Service Mesh 等服务网格社区的代表汇聚一堂组成
<a href=https://gateway-api.sigs.k8s.io/contributing/gamma/>GAMMA 倡议小组</a>，
这是 Gateway API 子项目内一个专门的工作流，专注于网格管理所用的 Gateway API。</p><p>这个小组将交付<a href=https://gateway-api.sigs.k8s.io/v1beta1/contributing/gep/>增强提案</a>，
包括对网格和网格相关用例适用的 Gateway API 规约的资源、添加和修改。</p><p>这项工作已从
<a href="https://docs.google.com/document/d/1T_DtMQoq2tccLAtJTpo3c0ohjm25vRS35MsestSL9QU/edit#heading=h.jt37re3yi6k5">探索针对服务间流量使用 Gateway API</a>
开始，并将继续增强身份验证和鉴权策略等领域。</p><h2 id=下一步>下一步</h2><p>随着我们不断完善用于生产用例的 API，以下是我们将为下一个 Gateway API 版本所做的一些重点工作：</p><ul><li>针对 <a href=https://grpc.io/>gRPC</a> 流量路由的 <a href=https://github.com/kubernetes-sigs/gateway-api/blob/master/site-src/geps/gep-1016.md>GRPCRoute</a></li><li><a href=https://github.com/kubernetes-sigs/gateway-api/pull/1085>路由代理</a></li><li>4 层 API 成熟度：<a href=https://github.com/kubernetes-sigs/gateway-api/blob/main/apis/v1alpha2/tcproute_types.go>TCPRoute</a>、<a href=https://github.com/kubernetes-sigs/gateway-api/blob/main/apis/v1alpha2/udproute_types.go>UDPRoute</a> 和 <a href=https://github.com/kubernetes-sigs/gateway-api/blob/main/apis/v1alpha2/tlsroute_types.go>TLSRoute</a> 正进入 Beta 阶段</li><li><a href=https://gateway-api.sigs.k8s.io/contributing/gamma/>GAMMA 倡议</a> - 针对服务网格的 Gateway API</li></ul><p>如果你想参与此列表中的某些工作，或者你想倡导加入路线图的内容不在此列表中，
请通过 Kubernetes Slack 的 #sig-network-gateway-api 频道或我们每周的
<a href=https://gateway-api.sigs.k8s.io/contributing/community/#meetings>社区电话会议</a>加入我们。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-8388f5963039f090e850aa2aadaf4ec0>2021 年度总结报告</h1><div class="td-byline mb-4"><time datetime=2022-06-01 class=text-muted>2022.06.01</time></div><p><strong>作者：</strong> Paris Pittman（指导委员会）</p><p>去年，我们发布了第一期
<a href=/blog/2021/06/28/announcing-kubernetes-community-group-annual-reports/>2020 年度总结报告</a>，
现在已经是时候发布第二期了！</p><p><a href=https://www.cncf.io/reports/kubernetes-annual-report-2021/>2021 年度总结报告</a></p><p>这份总结反映了 2021 年已完成的工作以及 2022 下半年置于台面上的倡议。
请将这份总结转发给正参与上游活动、计划云原生战略和寻求帮助的那些组织和个人。
若要查阅特定社区小组的完整报告，请访问
<a href=https://github.com/kubernetes/community>kubernetes/community 仓库</a>查找各小组的文件夹。例如：
<a href=https://github.com/kubernetes/community/blob/master/sig-api-machinery/annual-report-2021.md>sig-api-machinery/annual-report-2021.md</a></p><p>你将看到这份总结报告本身涵盖的领域在增长。我们准备和制作这份报告大约用了 6 个月的时间。
作为一个随着长短期需求而快速发展的项目，这么长的制作周期对任何人来说可能帮助都不大，
报告的价值也有所缩水。我等苦思无良策，请诸君不吝赐教：
<a href=https://github.com/kubernetes/steering/issues/242>https://github.com/kubernetes/steering/issues/242</a></p><p>参考：
<a href=https://github.com/kubernetes/community/blob/master/committee-steering/governance/annual-reports.md>年度报告文献</a></p></div><div class=td-content style=page-break-before:always><h1 id=pg-a8f52f99f57e5984533e9703dbe2a42d>Kubernetes 1.24: StatefulSet 的最大不可用副本数</h1><div class="td-byline mb-4"><time datetime=2022-05-27 class=text-muted>2022.05.27</time></div><p><strong>作者：</strong> Mayank Kumar (Salesforce)</p><p>Kubernetes <a href=/zh-cn/docs/concepts/workloads/controllers/statefulset/>StatefulSet</a>，
自 1.5 版本中引入并在 1.9 版本中变得稳定以来，已被广泛用于运行有状态应用。它提供固定的 Pod 身份标识、
每个 Pod 的持久存储以及 Pod 的有序部署、扩缩容和滚动更新功能。你可以将 StatefulSet
视为运行复杂有状态应用程序的原子构建块。随着 Kubernetes 的使用增多，需要 StatefulSet 的场景也越来越多。
当 StatefulSet 的 Pod 管理策略为 <code>OrderedReady</code> 时，其中许多场景需要比当前所支持的一次一个 Pod
的更新更快的滚动更新。</p><p>这里有些例子：</p><ul><li>我使用 StatefulSet 来编排一个基于缓存的多实例应用程序，其中缓存的规格很大。
缓存冷启动，需要相当长的时间才能启动容器。所需要的初始启动任务有很多。在应用程序完全更新之前，
此 StatefulSet 上的 RollingUpdate 将花费大量时间。如果 StatefulSet 支持一次更新多个 Pod，
那么更新速度会快得多。</li></ul><ul><li>我的有状态应用程序由 leader 和 follower 或者一个 writer 和多个 reader 组成。
我有多个 reader 或 follower，并且我的应用程序可以容忍多个 Pod 同时出现故障。
我想一次更新这个应用程序的多个 Pod，特别是当我的应用程序实例数量很多时，这样我就能快速推出新的更新。
注意，我的应用程序仍然需要每个 Pod 具有唯一标识。</li></ul><p>为了支持这样的场景，Kubernetes 1.24 提供了一个新的 alpha 特性。在使用新特性之前，必须启用
<code>MaxUnavailableStatefulSet</code> 特性标志。一旦启用，就可以指定一个名为 <code>maxUnavailable</code> 的新字段，
这是 StatefulSet <code>spec</code> 的一部分。例如：</p><pre tabindex=0><code>apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: web
  namespace: default
spec:
  podManagementPolicy: OrderedReady  # 你必须设为 OrderedReady
  replicas: 5
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - image: k8s.gcr.io/nginx-slim:0.8
        imagePullPolicy: IfNotPresent
        name: nginx
  updateStrategy:
    rollingUpdate:
      maxUnavailable: 2 # 这是 alpha 特性的字段，默认值是 1
      partition: 0
    type: RollingUpdate
</code></pre><p>如果你启用了新特性，但没有在 StatefulSet 中指定 <code>maxUnavailable</code> 的值，Kubernetes
会默认设置 <code>maxUnavailable: 1</code>。这与你不启用新特性时看到的行为是一致的。</p><p>我将基于该示例清单做场景演练，以演示此特性是如何工作的。我将部署一个有 5 个副本的 StatefulSet，
<code>maxUnavailable</code> 设置为 2 并将 <code>partition</code> 设置为 0。</p><p>我可以通过将镜像更改为 <code>k8s.gcr.io/nginx-slim:0.9</code> 来触发滚动更新。一旦开始滚动更新，
就可以看到一次更新 2 个 Pod，因为 <code>maxUnavailable</code> 的当前值是 2。
下面的输出显示了一个时间段内的结果，但并不是完整过程。<code>maxUnavailable</code> 可以是绝对数值（例如 2）或所需 Pod
的百分比（例如 10%），绝对数是通过百分比计算结果进行四舍五入得出的。</p><pre tabindex=0><code>kubectl get pods --watch 
</code></pre><pre tabindex=0><code>NAME    READY   STATUS    RESTARTS   AGE
web-0   1/1     Running   0          85s
web-1   1/1     Running   0          2m6s
web-2   1/1     Running   0          106s
web-3   1/1     Running   0          2m47s
web-4   1/1     Running   0          2m27s
web-4   1/1     Terminating   0          5m43s ----&gt; start terminating 4
web-3   1/1     Terminating   0          6m3s  ----&gt; start terminating 3
web-3   0/1     Terminating   0          6m7s
web-3   0/1     Pending       0          0s
web-3   0/1     Pending       0          0s
web-4   0/1     Terminating   0          5m48s
web-4   0/1     Terminating   0          5m48s
web-3   0/1     ContainerCreating   0          2s
web-3   1/1     Running             0          2s
web-4   0/1     Pending             0          0s
web-4   0/1     Pending             0          0s
web-4   0/1     ContainerCreating   0          0s
web-4   1/1     Running             0          1s
web-2   1/1     Terminating         0          5m46s ----&gt; start terminating 2 (only after both 4 and 3 are running)
web-1   1/1     Terminating         0          6m6s  ----&gt; start terminating 1
web-2   0/1     Terminating         0          5m47s
web-1   0/1     Terminating         0          6m7s
web-1   0/1     Pending             0          0s
web-1   0/1     Pending             0          0s
web-1   0/1     ContainerCreating   0          1s
web-1   1/1     Running             0          2s
web-2   0/1     Pending             0          0s
web-2   0/1     Pending             0          0s
web-2   0/1     ContainerCreating   0          0s
web-2   1/1     Running             0          1s
web-0   1/1     Terminating         0          6m6s ----&gt; start terminating 0 (only after 2 and 1 are running)
web-0   0/1     Terminating         0          6m7s
web-0   0/1     Pending             0          0s
web-0   0/1     Pending             0          0s
web-0   0/1     ContainerCreating   0          0s
web-0   1/1     Running             0          1s
</code></pre><p>注意，滚动更新一开始，4 和 3（两个最高序号的 Pod）同时开始进入 <code>Terminating</code> 状态。
Pod 4 和 3 会按照自身节奏进行更新。一旦 Pod 4 和 3 更新完毕后，Pod 2 和 1 会同时进入
<code>Terminating</code> 状态。当 Pod 2 和 1 都准备完毕处于 <code>Running</code> 状态时，Pod 0 开始进入 <code>Terminating</code> 状态</p><p>在 Kubernetes 中，StatefulSet 更新 Pod 时遵循严格的顺序。在此示例中，更新从副本 4 开始，
然后是副本 3，然后是副本 2，以此类推，一次更新一个 Pod。当一次只更新一个 Pod 时，
副本 3 不可能在副本 4 之前准备好进入 <code>Running</code> 状态。当 <code>maxUnavailable</code> 值
大于 1 时（在示例场景中我设置 <code>maxUnavailable</code> 值为 2），副本 3 可能在副本 4 之前准备好并运行，
这是没问题的。如果你是开发人员并且设置 <code>maxUnavailable</code> 值大于 1，你应该知道可能出现这种情况，
并且如果有这种情况的话，你必须确保你的应用程序能够处理发生的此类顺序问题。当你设置 <code>maxUnavailable</code>
值大于 1 时，更新 Pod 的批次之间会保证顺序。该保证意味着在批次 0（副本 4 和 3）中的 Pod
准备好之前，更新批次 2（副本 2 和 1）中的 Pod 无法开始更新。</p><p>尽管 Kubernetes 将这些称为<strong>副本</strong>，但你的有状态应用程序可能不这样理解，StatefulSet 的每个
Pod 可能持有与其他 Pod 完全不同的数据。重要的是，StatefulSet 的更新是分批进行的，
你现在让批次大小大于 1（作为 alpha 特性）。</p><p>还要注意，上面的行为采用的 Pod 管理策略是 <code>podManagementPolicy: OrderedReady</code>。
如果你的 StatefulSet 的 Pod 管理策略是 <code>podManagementPolicy: Parallel</code>，
那么不仅是 <code>maxUnavailable</code> 数量的副本同时被终止，还会导致 <code>maxUnavailable</code> 数量的副本同时在
<code>ContainerCreating</code> 阶段。这就是所谓的突发（Bursting）。</p><p>因此，现在你可能有很多关于以下方面的问题：</p><ul><li>当设置 <code>podManagementPolicy:Parallel</code> 时，会产生什么行为？</li><li>将 <code>partition</code> 设置为非 <code>0</code> 值时会发生什么？</li></ul><p>自己试试看可能会更好。这是一个 alpha 特性，Kubernetes 贡献者正在寻找有关此特性的反馈。
这是否有助于你实现有状态的场景？你是否发现了一个 bug，或者你认为实现的行为不直观易懂，
或者它可能会破坏应用程序或让他们感到吃惊？请<a href=https://github.com/kubernetes/kubernetes/issues>登记一个 issue</a>
告知我们。</p><h2 id=next-steps>进一步阅读和后续步骤</h2><ul><li><a href=/zh-cn/docs/concepts/workloads/controllers/statefulset/#maximum-unavailable-pods>最多不可用 Pod 数</a></li><li><a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-apps/961-maxunavailable-for-statefulset>KEP for MaxUnavailable for StatefulSet</a></li><li><a href=https://github.com/kubernetes/kubernetes/pull/82162/files>代码实现</a></li><li><a href=https://github.com/kubernetes/enhancements/issues/961>增强跟踪 Issue</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-342dc824bcac7b757c55f79fd53485ba>Kubernetes 1.24 中的上下文日志记录</h1><div class="td-byline mb-4"><time datetime=2022-05-25 class=text-muted>2022.05.25</time></div><p><strong>作者:</strong> Patrick Ohly (Intel)</p><p><a href=https://github.com/kubernetes/community/blob/master/wg-structured-logging/README.md>结构化日志工作组</a>
在 Kubernetes 1.24 中为日志基础设施添加了新功能。这篇博文解释了开发者如何利用这些功能使日志输出更有用，
以及他们如何参与改进 Kubernetes。</p><h2 id=结构化日志记录>结构化日志记录</h2><p><a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-instrumentation/1602-structured-logging/README.md>结构化日志</a>
记录的目标是用具有明确定义的语法的日志条目来取代 C 风格的格式化和由此产生的不透明的日志字符串，用于分别存储消息和参数，例如，作为一个 JSON 结构。</p><p>当使用传统的 klog 文本输出格式进行结构化日志调用时，字符串最初使用 <code>\n</code> 转义序列打印，除非嵌入到结构中。
对于结构体，日志条目仍然可以跨越多行，没有干净的方法将日志流拆分为单独的条目：</p><pre tabindex=0><code>I1112 14:06:35.783529  328441 structured_logging.go:51] &#34;using InfoS&#34; longData={Name:long Data:Multiple
lines
with quite a bit
of text. internal:0}
I1112 14:06:35.783549  328441 structured_logging.go:52] &#34;using InfoS with\nthe message across multiple lines&#34; int=1 stringData=&#34;long: Multiple\nlines\nwith quite a bit\nof text.&#34; str=&#34;another value&#34;
</code></pre><p>现在，<code>&lt;</code> 和 <code>></code> 标记以及缩进用于确保在行首的 klog 标头处拆分是可靠的，并且生成的输出是人类可读的：</p><pre tabindex=0><code>I1126 10:31:50.378204  121736 structured_logging.go:59] &#34;using InfoS&#34; longData=&lt;
	{Name:long Data:Multiple
	lines
	with quite a bit
	of text. internal:0}
 &gt;
I1126 10:31:50.378228  121736 structured_logging.go:60] &#34;using InfoS with\nthe message across multiple lines&#34; int=1 stringData=&lt;
	long: Multiple
	lines
	with quite a bit
	of text.
 &gt; str=&#34;another value&#34;
</code></pre><p>请注意，日志消息本身带有引号。它是一个用于标识日志条目的固定字符串，因此应避免使用换行符。</p><p>在 Kubernetes 1.24 之前，kube-scheduler 中的一些日志调用仍然使用 <code>klog.Info</code> 处理多行字符串，
以避免不可读的输出。现在所有日志调用都已更新以支持结构化日志记录。</p><h2 id=上下文日志记录>上下文日志记录</h2><p><a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-instrumentation/3077-contextual-logging/README.md>上下文日志</a>
基于 <a href=https://github.com/go-logr/logr#a-minimal-logging-api-for-go>go-logr API</a>。
关键的想法是，库被其调用者传递给一个记录器实例，并使用它来记录，而不是访问一个全局记录器。
二进制文件决定了日志的实现，而不是库。go-logr API 是围绕着结构化的日志记录而设计的，并支持将额外的信息附加到一个记录器上。</p><p>这使得以下用例成为可能：</p><ul><li><p>调用者可以将附加信息附加到记录器：</p><ul><li><a href=https://pkg.go.dev/github.com/go-logr/logr#Logger.WithName><code>WithName</code></a> 添加前缀</li><li><a href=https://pkg.go.dev/github.com/go-logr/logr#Logger.WithValues><code>WithValues</code></a> 添加键/值对</li></ul><p>当将此扩展记录器传递给函数并且函数使用它而不是全局记录器时，附加信息随后将包含在所有日志条目中，而无需修改生成日志条目的代码。
这在高度并行的应用程序中很有用，在这些应用程序中，由于不同操作的输出会交错，因此很难识别某个操作的所有日志条目。</p></li></ul><ul><li>运行单元测试时，可以将日志输出与当前测试关联起来。当测试失败时，<code>go test</code> 只显示失败测试的日志输出。
默认情况下，该输出也可以更详细，因为它不会显示成功的测试。这些测试可以在不交错输出的情况下并行运行。</li></ul><p>上下文日志记录的设计决策之一是允许将记录器作为值附加到 <code>context.Context</code>。
由于记录器封装了调用的预期记录的所有方面，它是上下文的<strong>部分</strong>，而不仅仅是<strong>使用</strong>它。
一个实际的优势是许多 API 已经有一个 <code>ctx</code> 参数，或者添加一个具有其他优势，例如能够摆脱函数内部的 <code>context.TODO()</code> 调用。</p><p>另一个决定是不破坏与 klog v2 的兼容性：</p><ul><li>在已设置上下文日志记录的二进制文件中使用传统 klog 日志记录调用的库将通过二进制文件选择的日志记录后端工作和记录。
但是，这样的日志输出不会包含额外的信息，并且在单元测试中不能很好地工作，因此应该修改库以支持上下文日志记录。
结构化日志记录的<a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-instrumentation/migration-to-structured-logging.md>迁移指南</a>
已扩展为也涵盖上下文日志记录。</li></ul><ul><li>当一个库支持上下文日志并从其上下文中检索一个记录器时，它仍将在不初始化上下文日志的二进制文件中工作，
因为它将获得一个通过 klog 记录的记录器。</li></ul><p>在 Kubernetes 1.24 中，上下文日志是一个新的 Alpha 特性，以 <code>ContextualLogging</code> 作为特性门控。
禁用时（默认），用于上下文日志记录的新 klog API 调用（见下文）变为无操作，以避免性能或功能回归。</p><p>尚未转换任何 Kubernetes 组件。 Kubernetes 存储库中的<a href=https://github.com/kubernetes/kubernetes/blob/v1.24.0-beta.0/staging/src/k8s.io/component-base/logs/example/cmd/logger.go>示例程序</a>
演示了如何在一个二进制文件中启用上下文日志记录，以及输出如何取决于该二进制文件的参数：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:navy;font-weight:700>$</span> <span style=color:#a2f>cd</span> <span style=color:#b8860b>$GOPATH</span>/src/k8s.io/kubernetes/staging/src/k8s.io/component-base/logs/example/cmd/
</span></span><span style=display:flex><span><span style=color:navy;font-weight:700>$</span> go run . --help
</span></span><span style=display:flex><span><span style=color:#888>...
</span></span></span><span style=display:flex><span><span style=color:#888>      --feature-gates mapStringBool  A set of key=value pairs that describe feature gates for alpha/experimental features. Options are:
</span></span></span><span style=display:flex><span><span style=color:#888>                                     AllAlpha=true|false (ALPHA - default=false)
</span></span></span><span style=display:flex><span><span style=color:#888>                                     AllBeta=true|false (BETA - default=false)
</span></span></span><span style=display:flex><span><span style=color:#888>                                     ContextualLogging=true|false (ALPHA - default=false)
</span></span></span><span style=display:flex><span><span style=color:#888></span><span style=color:navy;font-weight:700>$</span> go run . --feature-gates <span style=color:#b8860b>ContextualLogging</span><span style=color:#666>=</span><span style=color:#a2f>true</span>
</span></span><span style=display:flex><span><span style=color:#888>...
</span></span></span><span style=display:flex><span><span style=color:#888>I0404 18:00:02.916429  451895 logger.go:94] &#34;example/myname: runtime&#34; foo=&#34;bar&#34; duration=&#34;1m0s&#34;
</span></span></span><span style=display:flex><span><span style=color:#888>I0404 18:00:02.916447  451895 logger.go:95] &#34;example: another runtime&#34; foo=&#34;bar&#34; duration=&#34;1m0s&#34;
</span></span></span></code></pre></div><p><code>example</code> 前缀和 <code>foo="bar"</code> 是由记录 <code>runtime</code> 消息和 <code>duration="1m0s"</code> 值的函数的调用者添加的。</p><p>针对 klog 的示例代码包括一个单元测试<a href=https://github.com/kubernetes/klog/blob/v2.60.1/ktesting/example/example_test.go>示例</a>
以及每个测试的输出。</p><h2 id=klog-增强功能>klog 增强功能</h2><h3 id=上下文日志-api>上下文日志 API</h3><p>以下调用管理记录器的查找：</p><p><a href=https://pkg.go.dev/k8s.io/klog/v2#FromContext><code>FromContext</code></a>
：来自 <code>context</code> 参数，回退到全局记录器</p><p><a href=https://pkg.go.dev/k8s.io/klog/v2#Background><code>Background</code></a>
：全局后备，无意支持上下文日志记录</p><p><a href=https://pkg.go.dev/k8s.io/klog/v2#TODO><code>TODO</code></a>
：全局回退，但仅作为一个临时解决方案，直到该函数得到扩展能够通过其参数接受一个记录器</p><p><a href=https://pkg.go.dev/k8s.io/klog/v2#SetLoggerWithOptions><code>SetLoggerWithOptions</code></a>
：更改后备记录器；当使用<a href=https://pkg.go.dev/k8s.io/klog/v2#ContextualLogger><code>ContextualLogger(true)</code></a> 调用时,
记录器已准备好被直接调用，在这种情况下，记录将无需执行通过 klog</p><p>为了支持 Kubernetes 中的特性门控机制，klog 对相应的 go-logr 调用进行了包装调用，并使用了一个全局布尔值来控制它们的行为：</p><ul><li><a href=https://pkg.go.dev/k8s.io/klog/v2#LoggerWithName><code>LoggerWithName</code></a></li><li><a href=https://pkg.go.dev/k8s.io/klog/v2#LoggerWithValues><code>LoggerWithValues</code></a></li><li><a href=https://pkg.go.dev/k8s.io/klog/v2#NewContext><code>NewContext</code></a></li><li><a href=https://pkg.go.dev/k8s.io/klog/v2#EnableContextualLogging><code>EnableContextualLogging</code></a></li></ul><p>在 Kubernetes 代码中使用这些函数是通过 linter 检查强制执行的。
上下文日志的 klog 默认是启用该功能，因为它在 klog 中被认为是稳定的。
只有在 Kubernetes 二进制文件中，该默认值才会被覆盖，并且（在某些二进制文件中）通过 <code>--feature-gate</code> 参数进行控制。</p><h3 id=ktesting-记录器>ktesting 记录器</h3><p>新的 <a href=https://pkg.go.dev/k8s.io/klog/v2@v2.60.1/ktesting>ktesting</a>
包使用 klog 的文本输出格式通过 <code>testing.T</code> 实现日志记录。它有一个 <a href=https://pkg.go.dev/k8s.io/klog/v2@v2.60.1/ktesting#NewTestContext>single API call</a>
用于检测测试用例和<a href=https://pkg.go.dev/k8s.io/klog/v2@v2.60.1/ktesting/init>支持命令行标志</a>。</p><h3 id=klogr>klogr</h3><p><a href=https://pkg.go.dev/k8s.io/klog/v2@v2.60.1/klogr><code>klog/klogr</code></a> 继续受支持，默认行为不变：
它使用其格式化结构化日志条目拥有自己的自定义格式并通过 klog 打印结果。</p><p>但是，不鼓励这种用法，因为这种格式既不是机器可读的（与 zapr 生成的真实 JSON 输出相比，Kubernetes 使用的 go-logr 实现）也不是人类友好的（与 klog 文本格式相比）。</p><p>相反，应该使用选择 klog 文本格式的 <a href=https://pkg.go.dev/k8s.io/klog/v2@v2.60.1/klogr#WithFormat><code>WithFormat(FormatKlog)</code></a>
创建一个 klogr 实例。 一个更简单但结果相同的构造方法是新的 <a href=https://pkg.go.dev/k8s.io/klog/v2#NewKlogr><code>klog.NewKlogr</code></a>。
这是 klog 在未配置任何其他内容时作为后备返回的记录器。</p><h3 id=可重用输出测试>可重用输出测试</h3><p>许多 go-logr 实现都有非常相似的单元测试，它们检查某些日志调用的结果。
如果开发人员不知道某些警告，例如调用时会出现恐慌的 <code>String</code> 函数，那么很可能缺少对此类警告的处理和单元测试。</p><p><a href=https://pkg.go.dev/k8s.io/klog/v2@v2.60.1/test><code>klog.test</code></a> 是一组可重用的测试用例，可应用于 go-logr 实现。</p><h3 id=输出刷新>输出刷新</h3><p>klog 用于在 <code>init</code> 期间无条件地启动一个 goroutine，它以硬编码的时间间隔刷新缓冲数据。
现在 goroutine 仅按需启动（即当写入具有缓冲的文件时）并且可以使用 <a href=https://pkg.go.dev/k8s.io/klog/v2#StopFlushDaemon><code>StopFlushDaemon</code></a>
和 <a href=https://pkg.go.dev/k8s.io/klog/v2#StartFlushDaemon><code>StartFlushDaemon</code></a>。</p><p>当 go-logr 实现缓冲数据时，可以通过使用 <a href=https://pkg.go.dev/k8s.io/klog/v2#FlushLogger><code>FlushLogger</code></a>
选项注册记录器来将刷新该数据集成到 <a href=https://pkg.go.dev/k8s.io/klog/v2#Flush><code>klog.Flush</code></a> 中。</p><h3 id=其他各种变化>其他各种变化</h3><p>有关所有其他增强功能的描述，请参见 <a href=https://github.com/kubernetes/klog/releases>发行说明</a>。</p><h2 id=日志检查>日志检查</h2><p>最初设计为结构化日志调用的 linter，[<code>logcheck</code>] 工具已得到增强，还支持上下文日志记录和传统的 klog 日志调用。
这些增强检查已经在 Kubernetes 中发现了错误，例如使用格式字符串和参数调用 <code>klog.Info</code> 而不是 <code>klog.Infof</code>。</p><p>它可以作为插件包含在 <code>golangci-lint</code> 调用中，这就是
<a href=https://github.com/kubernetes/kubernetes/commit/17e3c555c5115f8c9176bae10ba45baa04d23a7b>Kubernetes 现在使用它的方式</a>，或者单独调用。</p><p>我们正在 <a href=https://github.com/kubernetes/klog/issues/312>移动工具</a>
到一个新的存储库中，因为它与 klog 没有真正的关系，并且应该正确跟踪和标记它的发布。</p><h2 id=下一步>下一步</h2><p><a href=https://github.com/kubernetes/community/tree/master/wg-structured-logging>Structured Logging WG</a>
一直在寻找新的贡献者。 从 C 风格的日志记录迁移现在将一步一步地针对结构化的上下文日志记录，
以减少整体代码流失和 PR 数量。 更改日志调用是对 Kubernetes 的良好贡献，也是了解各个不同领域代码的机会。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-a8249504f8ce0359f6802222747eebb2>Kubernetes 1.24: 避免为 Services 分配 IP 地址时发生冲突</h1><div class="td-byline mb-4"><time datetime=2022-05-23 class=text-muted>2022.05.23</time></div><p><strong>作者：</strong> Antonio Ojea (Red Hat)</p><p>在 Kubernetes 中，<a href=/zh-cn/docs/concepts/services-networking/service/>Services</a>
是一种抽象，用来暴露运行在一组 Pod 上的应用。
Service 可以有一个集群范围的虚拟 IP 地址（使用 <code>type: ClusterIP</code> 的 Service）。
客户端可以使用该虚拟 IP 地址进行连接， Kubernetes 为对该 Service 的访问流量提供负载均衡，以访问不同的后端 Pod。</p><h2 id=service-clusterip-是如何分配的>Service ClusterIP 是如何分配的？</h2><p>Service <code>ClusterIP</code> 有如下分配方式：</p><p><strong>动态</strong>
：群集的控制平面会自动从配置的 IP 范围内为 <code>type:ClusterIP</code> 的 Service 选择一个空闲 IP 地址。</p><p><strong>静态</strong>
：你可以指定一个来自 Service 配置的 IP 范围内的 IP 地址。</p><p>在整个集群中，每个 Service 的 <code>ClusterIP</code> 必须是唯一的。
尝试创建一个已经被分配了的 <code>ClusterIP</code> 的 Service 将会返回错误。</p><h2 id=为什么需要预留-service-cluster-ip>为什么需要预留 Service Cluster IP？</h2><p>有时，你可能希望让 Service 运行在众所周知的 IP 地址上，以便集群中的其他组件和用户可以使用它们。</p><p>最好的例子是集群的 DNS Service。一些 Kubernetes 安装程序将 Service IP 范围中的第 10 个地址分配给 DNS Service。
假设你配置集群 Service IP 范围是 10.96.0.0/16，并且希望 DNS Service IP 为 10.96.0.10，
那么你必须创建一个如下所示的 Service：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>k8s-app</span>:<span style=color:#bbb> </span>kube-dns<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/cluster-service</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/name</span>:<span style=color:#bbb> </span>CoreDNS<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>kube-dns<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clusterIP</span>:<span style=color:#bbb> </span><span style=color:#666>10.96.0.10</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dns<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>53</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>UDP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>53</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dns-tcp<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>53</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>53</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>k8s-app</span>:<span style=color:#bbb> </span>kube-dns<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>ClusterIP<span style=color:#bbb>
</span></span></span></code></pre></div><p>但正如我之前解释的，IP 地址 10.96.0.10 没有被保留；
如果其他 Service 在动态分配之前创建或与动态分配并行创建，则它们有可能分配此 IP 地址，
因此，你将无法创建 DNS Service，因为它将因冲突错误而失败。</p><h2 id=avoid-ClusterIP-conflict>如何避免 Service ClusterIP 冲突？</h2><p>在 Kubernetes 1.24 中，你可以启用一个新的特性门控 <code>ServiceIPStaticSubrange</code>。
启用此特性允许你为 Service 使用不同的 IP 分配策略，减少冲突的风险。</p><p><code>ClusterIP</code> 范围将根据公式 <code>min(max(16, cidrSize / 16), 256)</code> 进行划分，
该公式可描述为 “在不小于 16 且不大于 256 之间有一个步进量（Graduated Step）”。</p><p>分配默认使用上半段地址，当上半段地址耗尽后，将使用下半段地址范围。
这将允许用户使用下半段地址中静态分配的地址并且降低冲突的风险。</p><p>举例：</p><h4 id=service-ip-cidr-地址段-10-96-0-0-24>Service IP CIDR 地址段： 10.96.0.0/24</h4><p>地址段大小：2<sup>8</sup> - 2 = 254<br>地址段偏移：<code>min(max(16, 256/16), 256)</code> = <code>min(16, 256)</code> = 16<br>静态地址段起点：10.96.0.1<br>静态地址段终点：10.96.0.16<br>地址范围终点：10.96.0.254</p><figure><div class=mermaid>pie showData
title 10.96.0.0/24
"静态" : 16
"动态" : 238</div></figure><noscript><div class="alert alert-secondary callout" role=alert><em class=javascript-required>必须<a href=https://www.enable-javascript.com/>启用</a> JavaScript 才能查看此页内容</em></div></noscript><h4 id=service-ip-cidr-地址段-10-96-0-0-20>Service IP CIDR 地址段： 10.96.0.0/20</h4><p>地址段大小：2<sup>12</sup> - 2 = 4094<br>地址段偏移：<code>min(max(16, 4096/16), 256)</code> = <code>min(256, 256)</code> = 256<br>静态地址段起点：10.96.0.1<br>静态地址段终点：10.96.1.0<br>地址范围终点：10.96.15.254</p><figure><div class=mermaid>pie showData
title 10.96.0.0/20
"静态" : 256
"动态" : 3838</div></figure><noscript><div class="alert alert-secondary callout" role=alert><em class=javascript-required>必须<a href=https://www.enable-javascript.com/>启用</a> JavaScript 才能查看此页内容</em></div></noscript><h4 id=service-ip-cidr-地址段-10-96-0-0-16>Service IP CIDR 地址段： 10.96.0.0/16</h4><p>地址段大小：2<sup>16</sup> - 2 = 65534<br>地址段偏移：<code>min(max(16, 65536/16), 256)</code> = <code>min(4096, 256)</code> = 256<br>静态地址段起点：10.96.0.1<br>静态地址段终点：10.96.1.0<br>地址范围终点：10.96.255.254</p><figure><div class=mermaid>pie showData
title 10.96.0.0/16
"静态" : 256
"动态" : 65278</div></figure><noscript><div class="alert alert-secondary callout" role=alert><em class=javascript-required>必须<a href=https://www.enable-javascript.com/>启用</a> JavaScript 才能查看此页内容</em></div></noscript><h2 id=加入-sig-network>加入 SIG Network</h2><p>当前 SIG-Network 在 GitHub 上的 <a href=https://github.com/orgs/kubernetes/projects/10>KEPs</a> 和
<a href="https://github.com/kubernetes/kubernetes/issues?q=is%3Aopen+is%3Aissue+label%3Asig%2Fnetwork">issues</a>
表明了该 SIG 的重点领域。</p><p><a href=https://github.com/kubernetes/community/tree/master/sig-network>SIG Network 会议</a>是一个友好、热情的场所，
你可以与社区联系并分享你的想法。期待你的回音！</p></div><div class=td-content style=page-break-before:always><h1 id=pg-33c9972d97be5af36132098b388992f3>Kubernetes 1.24: 节点非体面关闭特性进入 Alpha 阶段</h1><div class="td-byline mb-4"><time datetime=2022-05-20 class=text-muted>2022.05.20</time></div><p><strong>作者</strong>：Xing Yang 和 Yassine Tijani (VMware)</p><p>Kubernetes v1.24 引入了对<a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-storage/2268-non-graceful-shutdown>节点非体面关闭</a>
（Non-Graceful Node Shutdown）的 Alpha 支持。
此特性允许有状态工作负载在原节点关闭或处于不可恢复状态（如硬件故障或操作系统损坏）后，故障转移到不同的节点。</p><h2 id=这与节点体面关闭有何不同>这与节点体面关闭有何不同</h2><p>你可能听说过 Kubernetes 的<a href=/zh-cn/docs/concepts/architecture/nodes/#graceful-node-shutdown>节点体面关闭</a>特性，
并且想知道节点非体面关闭特性与之有何不同。节点体面关闭允许 Kubernetes 检测节点何时完全关闭，并适当地处理这种情况。
只有当 kubelet 在实际关闭之前检测到节点关闭动作时，节点关闭才是“体面（graceful）”的。
但是，在某些情况下，kubelet 可能检测不到节点关闭操作。
这可能是因为 shutdown 命令没有触发 kubelet 所依赖的 systemd 抑制锁机制，
或者是因为配置错误（<code>ShutdownGracePeriod</code> 和 <code>ShutdownGracePeriodCriticalPods</code> 配置不正确）。</p><p>节点体面关闭依赖于特定 Linux 的支持。
kubelet 不监视 Windows 节点上即将关闭的情况（这可能在未来的 Kubernetes 版本中会有所改变）。</p><p>当一个节点被关闭但 kubelet 没有检测到时，该节点上的 Pod 也会非体面地关闭。
对于无状态应用程序，这通常不是问题（一旦集群检测到受影响的节点或 Pod 出现故障，ReplicaSet 就会添加一个新的 Pod）。
对于有状态的应用程序，情况要复杂得多。如果你使用一个 StatefulSet，
并且该 StatefulSet 中的一个 Pod 在某个节点上发生了不干净故障，则该受影响的 Pod 将被标记为终止（Terminating）；
StatefulSet 无法创建替换 Pod，因为该 Pod 仍存在于集群中。
因此，在 StatefulSet 上运行的应用程序可能会降级甚至离线。
如果已关闭的原节点再次出现，该节点上的 kubelet 会执行报到操作，删除现有的 Pod，
并且控制平面会在不同的运行节点上为该 StatefulSet 生成一个替换 Pod。
如果原节点出现故障并且没有恢复，这些有状态的 Pod 将处于终止状态且无限期地停留在该故障节点上。</p><pre tabindex=0><code>$ kubectl get pod -o wide
NAME    READY   STATUS        RESTARTS   AGE   IP           NODE                      NOMINATED NODE   READINESS GATES
web-0   1/1     Running       0          100m   10.244.2.4   k8s-node-876-1639279816   &lt;none&gt;           &lt;none&gt;
web-1   1/1     Terminating   0          100m   10.244.1.3   k8s-node-433-1639279804   &lt;none&gt;           &lt;none&gt;
</code></pre><h2 id=尝试新的非体面关闭处理>尝试新的非体面关闭处理</h2><p>要使用节点非体面关闭处理，你必须为 <code>kube-controller-manager</code> 组件启用
<code>NodeOutOfServiceVolumeDetach</code> <a href=/zh-cn/docs/reference/command-line-tools-reference/feature-gates/>特性门控</a>。</p><p>在节点关闭的情况下，你可以手动为该节点标记污点，标示其已停止服务。
在添加污点之前，你应该确保节点确实关闭了（不是在重启过程中）。
你可以在发生了节点关闭事件，且该事件没有被 kubelet 提前检测和处理的情况下，在节点关闭之后添加污点；
你可以使用该污点的另一种情况是当节点由于硬件故障或操作系统损坏而处于不可恢复状态时。
你可以为该污点设置的值是 <code>node.kubernetes.io/out-of-service=nodeshutdown: "NoExecute"</code> 或
<code>node.kubernetes.io/out-of-service=nodeshutdown: "NoSchedule"</code>。
如果你已经启用了前面提到的特性门控，在节点上设置 out-of-service 污点意味着节点上的 Pod 将被删除，
除非 Pod 上设置有与之匹配的容忍度。原来挂接到已关闭节点的持久卷（Persistent volume）将被解除挂接，
对于 StatefulSet，系统将在不同的运行节点上成功创建替换 Pod。</p><pre tabindex=0><code>$ kubectl taint nodes &lt;node-name&gt; node.kubernetes.io/out-of-service=nodeshutdown:NoExecute

$ kubectl get pod -o wide
NAME    READY   STATUS    RESTARTS   AGE    IP           NODE                      NOMINATED NODE   READINESS GATES
web-0   1/1     Running   0          150m   10.244.2.4   k8s-node-876-1639279816   &lt;none&gt;           &lt;none&gt;
web-1   1/1     Running   0          10m    10.244.1.7   k8s-node-433-1639279804   &lt;none&gt;           &lt;none&gt;
</code></pre><p>注意：在应用 out-of-service 污点之前，你<strong>必须</strong>确认节点是否已经处于关闭或断电状态（不是在重新启动过程中），
节点关闭的原因可能是用户有意将其关闭，也可能是节点由于硬件故障、操作系统问题等而关闭。</p><p>一旦关联到无法提供服务的节点的所有工作负载 Pod 都被移动到新的运行中的节点，并且关闭了的节点也已恢复，
你应该在节点恢复后删除受影响节点上的污点。如果你知道该节点不会恢复服务，则可以改为从集群中删除该节点。</p><h2 id=下一步是什么>下一步是什么？</h2><p>根据反馈和采用情况，Kubernetes 团队计划在 1.25 或 1.26 版本中将节点非体面关闭实现推送到 Beta 阶段。</p><p>此功能需要用户手动向节点添加污点以触发工作负载故障转移，并要求用户在节点恢复后移除污点。
未来，我们计划寻找方法来自动检测和隔离已关闭的或已失败的节点，并自动将工作负载故障转移到另一个节点。</p><h2 id=怎样才能了解更多>怎样才能了解更多？</h2><p>查看节点非体面关闭相关<a href=/zh-cn/docs/concepts/architecture/nodes/#non-graceful-node-shutdown>文档</a>。</p><h2 id=如何参与>如何参与？</h2><p>此功能特性由来已久。Yassine Tijani（<a href=https://github.com/yastij>yastij</a>）在两年多前启动了这个 KEP。
Xing Yang（<a href=https://github.com/xing-yang>xing-yang</a>）继续推动这项工作。
SIG-Storage、SIG-Node 和 API 评审人员们进行了多次讨论，以确定设计细节。
Ashutosh Kumar（<a href=https://github.com/sonasingh46>sonasingh46</a>）
完成了大部分实现并在 Kubernetes 1.24 版本中将其引进到 Alpha 阶段。</p><p>我们要感谢以下人员的评审：Tim Hockin（<a href=https://github.com/thockin>thockin</a>）对设计的指导；
来自 SIG-Storage 的 Jing Xu（<a href=https://github.com/jingxu97>jingxu97</a>）、
Hemant Kumar（<a href=https://github.com/gnufied>gnufied</a>）
和 Michelle Au（<a href=https://github.com/msau42>msau42</a>）的评论；
以及 Mrunal Patel（<a href=https://github.com/mrunalp>mrunalp</a>）、
David Porter（<a href=https://github.com/bobbypage>bobbypage</a>）、
Derek Carr（<a href=https://github.com/derekwaynecarr>derekwaynecarr</a>）
和 Danielle Endocrimes（<a href=https://github.com/endocrimes>endocrimes</a>）来自 SIG-Node 方面的评论。</p><p>在此过程中，有很多人帮助审查了设计和实现。我们要感谢所有为此做出贡献的人，
包括在过去几年中审核 <a href=https://github.com/kubernetes/enhancements/pull/1116>KEP</a> 和实现的大约 30 人。</p><p>此特性是 SIG-Storage 和 SIG-Node 之间的协作。
对于那些有兴趣参与 Kubernetes Storage 系统任何部分的设计和开发的人，
请加入 <a href=https://github.com/kubernetes/community/tree/master/sig-storage>Kubernetes 存储特别兴趣小组</a>（SIG-Storage）。
对于那些有兴趣参与支持 Pod 和主机资源之间受控交互的组件的设计和开发的人，
请加入 <a href=https://github.com/kubernetes/community/tree/master/sig-node>Kubernetes Node SIG</a>。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-894a207e64bf759d2c0ce0546c9e1924>Kubernetes 1.24: 防止未经授权的卷模式转换</h1><div class="td-byline mb-4"><time datetime=2022-05-18 class=text-muted>2022.05.18</time></div><p><strong>作者：</strong> Raunak Pradip Shah (Mirantis)</p><p>Kubernetes v1.24 引入了一个新的 alpha 级特性，可以防止未经授权的用户修改基于 Kubernetes
集群中已有的 <a href=/zh-cn/docs/concepts/storage/volume-snapshots/><code>VolumeSnapshot</code></a>
创建的 <a href=/zh-cn/docs/concepts/storage/persistent-volumes/><code>PersistentVolumeClaim</code></a> 的卷模式。</p><h3 id=问题>问题</h3><p><a href=/zh-cn/docs/concepts/storage/persistent-volumes/#volume-mode>卷模式</a>确定卷是格式化为文件系统还是显示为原始块设备。</p><p>用户可以使用自 Kubernetes v1.20 以来就稳定的 <code>VolumeSnapshot</code> 功能，
基于 Kubernetes 集群中的已有的 <code>VolumeSnapshot</code> 创建一个 <code>PersistentVolumeClaim</code> (简称 PVC )。
PVC 规约包括一个 <code>dataSource</code> 字段，它可以指向一个已有的 <code>VolumeSnapshot</code> 实例。
查阅<a href=/zh-cn/docs/concepts/storage/persistent-volumes/#create-persistent-volume-claim-from-volume-snapshot>基于卷快照创建 PVC</a>
获取更多详细信息。</p><p>当使用上述功能时，没有逻辑来验证快照所在的原始卷的模式是否与新创建的卷的模式匹配。</p><p>这引起了一个安全漏洞，允许恶意用户潜在地利用主机操作系统中的未知漏洞。</p><p>为了提高效率，许多流行的存储备份供应商在备份操作过程中转换卷模式，
这使得 Kubernetes 无法完全阻止该操作，并在区分受信任用户和恶意用户方面带来挑战。</p><h3 id=防止未经授权的用户转换卷模式>防止未经授权的用户转换卷模式</h3><p>在这种情况下，授权用户是指有权对 <code>VolumeSnapshotContents</code>（集群级资源）执行 <code>Update</code>
或 <code>Patch</code> 操作的用户。集群管理员只能向受信任的用户或应用程序（如备份供应商）提供这些权限。</p><p>如果在 <code>snapshot-controller</code>、<code>snapshot-validation-webhook</code> 和
<code>external-provisioner</code> 中<a href=https://kubernetes-csi.github.io/docs/>启用</a>了这个 alpha
特性，则基于 <code>VolumeSnapshot</code> 创建 PVC 时，将不允许未经授权的用户修改其卷模式。</p><p>如要转换卷模式，授权用户必须执行以下操作：</p><ol><li><p>确定要用作给定命名空间中新创建 PVC 的数据源的 <code>VolumeSnapshot</code>。</p></li><li><p>确定绑定到上面 <code>VolumeSnapshot</code> 的 <code>VolumeSnapshotContent</code>。</p><pre tabindex=0><code>   kubectl get volumesnapshot -n &lt;namespace&gt;
</code></pre></li></ol><ol start=3><li>给 <code>VolumeSnapshotContent</code> 添加
<a href=/zh-cn/docs/reference/labels-annotations-taints/#snapshot-storage-kubernetes-io-allowvolumemodechange><code>snapshot.storage.kubernetes.io/allowVolumeModeChange</code></a>
注解。</li></ol><ol start=4><li><p>此注解可通过软件添加或由授权用户手动添加。<code>VolumeSnapshotContent</code> 注解必须类似于以下清单片段：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>   </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>VolumeSnapshotContent<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>       </span>- <span style=color:green;font-weight:700>snapshot.storage.kubernetes.io/allowVolumeModeChange</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span>...<span style=color:#bbb>
</span></span></span></code></pre></div></li></ol><p><strong>注意</strong>：对于预先制备的 <code>VolumeSnapshotContents</code>，你必须采取额外的步骤设置 <code>spec.sourceVolumeMode</code>
字段为 <code>Filesystem</code> 或 <code>Block</code>，这取决于快照所在卷的模式。</p><p>如下为一个示例：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>   </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>snapshot.storage.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>VolumeSnapshotContent<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span>- <span style=color:green;font-weight:700>snapshot.storage.kubernetes.io/allowVolumeModeChange</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>new-snapshot-content-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>deletionPolicy</span>:<span style=color:#bbb> </span>Delete<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>driver</span>:<span style=color:#bbb> </span>hostpath.csi.k8s.io<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>source</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>       </span><span style=color:green;font-weight:700>snapshotHandle</span>:<span style=color:#bbb> </span>7bdd0de3-aaeb-11e8-9aae-0242ac110002<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>sourceVolumeMode</span>:<span style=color:#bbb> </span>Filesystem<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>volumeSnapshotRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>       </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>new-snapshot-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>       </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span></code></pre></div><p>对于在备份或恢复操作期间需要转换卷模式的所有 <code>VolumeSnapshotContents</code>，重复步骤 1 到 3。</p><p>如果 <code>VolumeSnapshotContent</code> 对象上存在上面步骤 4 中显示的注解，Kubernetes 将不会阻止转换卷模式。
用户在尝试将注解添加到任何 <code>VolumeSnapshotContent</code> 之前，应该记住这一点。</p><h3 id=接下来>接下来</h3><p><a href=https://kubernetes-csi.github.io/docs/>启用此特性</a>并让我们知道你的想法!</p><p>我们希望此功能不会中断现有工作流程，同时防止恶意用户利用集群中的安全漏洞。</p><p>若有任何问题，请在 #sig-storage slack 频道中创建一个会话，
或在 CSI 外部快照存储<a href=https://github.com/kubernetes-csi/external-snapshotter>仓库</a>中报告一个 issue。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-5d0426ad59853e102edd53c047df5d13>Kubernetes 1.24: 卷填充器功能进入 Beta 阶段</h1><div class="td-byline mb-4"><time datetime=2022-05-16 class=text-muted>2022.05.16</time></div><p><strong>作者：</strong>
Ben Swartzlander (NetApp)</p><p>卷填充器功能现在已经经历两个发行版本并进入 Beta 阶段！
在 Kubernetes v1.24 中 <code>AnyVolumeDataSource</code> 特性门控默认被启用。
这意味着用户可以指定任何自定义资源作为 PVC 的数据源。</p><p><a href=/blog/2021/08/30/volume-populators-redesigned/>之前的一篇博客</a>详细介绍了卷填充器功能的工作原理。
简而言之，集群管理员可以在集群中安装 CRD 和相关的填充器控制器，
任何可以创建 CR 实例的用户都可以利用填充器创建预填充卷。</p><p>出于不同的目的，可以一起安装多个填充器。存储 SIG 社区已经有了一些公开的实现，更多原型应该很快就会出现。</p><p><strong>强烈建议</strong>集群管理人员在安装任何填充器之前安装 volume-data-source-validator 控制器和相关的
<code>VolumePopulator</code> CRD，以便用户可以获得有关无效 PVC 数据源的反馈。</p><h2 id=新功能>新功能</h2><p>构建填充器的 <a href=https://github.com/kubernetes-csi/lib-volume-populator>lib-volume-populator</a>
库现在包含可帮助操作员监控和检测问题的指标。这个库现在是 beta 阶段，最新版本是 v1.0.1。</p><p><a href=https://github.com/kubernetes-csi/volume-data-source-validator>卷数据源校验器</a>控制器也添加了指标支持，
处于 beta 阶段。<code>VolumePopulator</code> CRD 是 beta 阶段，最新版本是 v1.0.1。</p><h2 id=尝试一下>尝试一下</h2><p>要查看它是如何工作的，你可以安装 “hello” 示例填充器并尝试一下。</p><p>首先安装 volume-data-source-validator 控制器。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://raw.githubusercontent.com/kubernetes-csi/volume-data-source-validator/v1.0.1/client/config/crd/populator.storage.k8s.io_volumepopulators.yaml
</span></span><span style=display:flex><span>kubectl apply -f https://raw.githubusercontent.com/kubernetes-csi/volume-data-source-validator/v1.0.1/deploy/kubernetes/rbac-data-source-validator.yaml
</span></span><span style=display:flex><span>kubectl apply -f https://raw.githubusercontent.com/kubernetes-csi/volume-data-source-validator/v1.0.1/deploy/kubernetes/setup-data-source-validator.yaml
</span></span></code></pre></div><p>接下来安装 hello 示例填充器。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://raw.githubusercontent.com/kubernetes-csi/lib-volume-populator/v1.0.1/example/hello-populator/crd.yaml
</span></span><span style=display:flex><span>kubectl apply -f https://raw.githubusercontent.com/kubernetes-csi/lib-volume-populator/87a47467b86052819e9ad13d15036d65b9a32fbb/example/hello-populator/deploy.yaml
</span></span></code></pre></div><p>你的集群现在有一个新的 CustomResourceDefinition，它提供了一个名为 Hello 的测试 API。
创建一个 <code>Hello</code> 自定义资源的实例，内容如下：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>hello.example.com/v1alpha1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Hello<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example-hello<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>fileName</span>:<span style=color:#bbb> </span>example.txt<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>fileContents</span>:<span style=color:#bbb> </span>Hello, world!<span style=color:#bbb>
</span></span></span></code></pre></div><p>创建一个将该 CR 引用为其数据源的 PVC。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example-pvc<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- ReadWriteOnce<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>10Mi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>dataSourceRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>hello.example.com<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Hello<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example-hello<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeMode</span>:<span style=color:#bbb> </span>Filesystem<span style=color:#bbb>
</span></span></span></code></pre></div><p>接下来，运行一个读取 PVC 中文件的 Job。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>batch/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Job<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example-job<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:latest<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- cat<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- /mnt/example.txt<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>vol<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/mnt<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>vol<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>persistentVolumeClaim</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>claimName</span>:<span style=color:#bbb> </span>example-pvc<span style=color:#bbb>
</span></span></span></code></pre></div><p>等待 Job 完成（包括其所有依赖项）。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>wait</span> --for<span style=color:#666>=</span><span style=color:#b8860b>condition</span><span style=color:#666>=</span>Complete job/example-job
</span></span></code></pre></div><p>最后检查 Job 中的日志。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl logs job/example-job
</span></span></code></pre></div><p>输出应该是：</p><pre tabindex=0><code class=language-terminal data-lang=terminal>Hello, world!
</code></pre><p>请注意，该卷已包含一个文本文件，其中包含来自 CR 的字符串内容。这只是最简单的例子。
实际填充器可以将卷设置为包含任意内容。</p><h2 id=如何编写自己的卷填充器>如何编写自己的卷填充器</h2><p>鼓励有兴趣编写新的填充器的开发人员使用
<a href=https://github.com/kubernetes-csi/lib-volume-populator>lib-volume-populator</a> 库，
只提供一个小型控制器，以及一个能够连接到卷并向卷写入适当数据的 Pod 镜像。</p><p>单个填充器非常通用，它们可以与所有类型的 PVC 一起使用，
或者如果卷是来自同一供应商的特定 CSI 驱动程序供应的，
它们可以执行供应商特定的的操作以快速用数据填充卷，例如，通过通信直接使用该卷的存储。</p><h2 id=我怎样才能了解更多>我怎样才能了解更多？</h2><p>增强提案，
<a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-storage/1495-volume-populators>卷填充器</a>，
包含有关此功能的历史和技术实现的许多详细信息。</p><p><a href=/zh-cn/docs/concepts/storage/persistent-volumes/#volume-populators-and-data-sources>卷填充器与数据源</a>,
在有关持久卷的文档主题中，解释了如何在集群中使用此功能。</p><p>请加入 Kubernetes 的存储 SIG，帮助我们增强这一功能。这里已经有很多好的主意了，我们很高兴能有更多！</p></div><div class=td-content style=page-break-before:always><h1 id=pg-dd40e01906fc4090cab819f78c9a43ca>Kubernetes 1.24：gRPC 容器探针功能进入 Beta 阶段</h1><div class="td-byline mb-4"><time datetime=2022-05-13 class=text-muted>2022.05.13</time></div><p><strong>作者</strong>：Sergey Kanzhelev (Google)</p><p>在 Kubernetes 1.24 中，gRPC 探针（probe）功能进入了 beta 阶段，默认情况下可用。
现在，你可以为 gRPC 应用程序配置启动、活跃和就绪探测，而无需公开任何 HTTP 端点，
也不需要可执行文件。Kubernetes 可以通过 gRPC 直接连接到你的工作负载并查询其状态。</p><h2 id=一些历史>一些历史</h2><p>让管理你的工作负载的系统检查应用程序是否健康、启动是否正常，以及应用程序是否认为自己可以接收流量，是很有用的。
在添加 gRPC 探针支持之前，Kubernetes 已经允许你通过从容器镜像内部运行可执行文件、发出 HTTP
请求或检查 TCP 连接是否成功来检查健康状况。</p><p>对于大多数应用程序来说，这些检查就足够了。如果你的应用程序提供了用于运行状况（或准备就绪）检查的
gRPC 端点，则很容易重新调整 <code>exec</code> 探针的用途，将其用于 gRPC 运行状况检查。
在博文<a href=/zh-cn/blog/2018/10/01/health-checking-grpc-servers-on-kubernetes/>在 Kubernetes 上对 gRPC 服务器进行健康检查</a>中，
Ahmet Alp Balkan 描述了如何做到这一点 —— 这种机制至今仍在工作。</p><p>2018 年 8 月 21 日所<a href=https://github.com/grpc-ecosystem/grpc-health-probe/commit/2df4478982e95c9a57d5fe3f555667f4365c025d>创建</a>的一种常用工具可以启用此功能，
工具于 <a href=https://github.com/grpc-ecosystem/grpc-health-probe/releases/tag/v0.1.0-alpha.1>2018 年 9 月 19 日</a>首次发布。</p><p>这种 gRPC 应用健康检查的方法非常受欢迎。使用 GitHub 上的基本搜索，发现了带有 <code>grpc_health_probe</code>
的 <a href="https://github.com/search?l=Dockerfile&q=grpc_health_probe&type=code">3,626 个 Dockerfile 文件</a>和
<a href="https://github.com/search?l=YAML&q=grpc_health_probe&type=Code">6,621 个 yaml 文件</a>（在撰写本文时）。
这很好地表明了该工具的受欢迎程度，以及对其本地支持的需求。</p><p>Kubernetes v1.23 引入了一个 alpha 质量的实现，原生支持使用 gRPC 查询工作负载状态。
因为这是一个 alpha 特性，所以在 1.23 版中默认是禁用的。</p><h2 id=使用该功能>使用该功能</h2><p>我们用与其他探针类似的方式构建了 gRPC 健康检查，相信如果你熟悉 Kubernetes 中的其他探针类型，
它会<a href=/zh-cn/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#define-a-grpc-liveness-probe>很容易使用</a>。
与涉及 <code>grpc_health_probe</code> 可执行文件的解决办法相比，原生支持的健康探针有许多好处。</p><p>有了原生 gRPC 支持，你不需要在镜像中下载和携带 <code>10MB</code> 的额外可执行文件。
Exec 探针通常比 gRPC 调用慢，因为它们需要实例化一个新进程来运行可执行文件。
当 Pod 在最大资源下运行并且在实例化新进程时遇到困难时，它还使得对边界情况的检查变得不那么智能。</p><p>不过有一些限制。由于为探针配置客户端证书很难，因此不支持依赖客户端身份验证的服务。
内置探针也不检查服务器证书，并忽略相关问题。</p><p>内置检查也不能配置为忽略某些类型的错误（<code>grpc_health_probe</code> 针对不同的错误返回不同的退出代码），
并且不能“串接”以在单个探测中对多个服务运行健康检查。</p><p>但是所有这些限制对于 gRPC 来说都是相当标准的，并且有简单的解决方法。</p><h2 id=自己试试>自己试试</h2><h3 id=集群级设置>集群级设置</h3><p>你现在可以尝试这个功能。要尝试原生 gRPC 探针，你可以自己启动一个启用了
<code>GRPCContainerProbe</code> 特性门控的 Kubernetes 集群，可用的<a href=/zh-cn/docs/tasks/tools/>工具</a>有很多。</p><p>由于特性门控 <code>GRPCContainerProbe</code> 在 1.24 版本中是默认启用的，因此许多供应商支持此功能开箱即用。
因此，你可以在自己选择的平台上创建 1.24 版本集群。一些供应商允许在 1.23 版本集群上启用 alpha 特性。</p><p>例如，在编写本文时，你可以在 GKE 上运行测试集群来进行快速测试。
其他供应商可能也有类似的功能，尤其是当你在 Kubernetes 1.24 版本发布很久后才阅读这篇博客时。</p><p>在 GKE 上使用以下命令（注意，版本是 <code>1.23</code>，并且指定了 <code>enable-kubernetes-alpha</code>）。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>gcloud container clusters create test-grpc <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    --enable-kubernetes-alpha <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    --no-enable-autorepair <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    --no-enable-autoupgrade <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    --release-channel<span style=color:#666>=</span>rapid <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    --cluster-version<span style=color:#666>=</span>1.23
</span></span></code></pre></div><p>你还需要配置 kubectl 来访问集群：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>gcloud container clusters get-credentials test-grpc
</span></span></code></pre></div><h3 id=试用该功能>试用该功能</h3><p>让我们创建 Pod 来测试 gRPC 探针是如何工作的。对于这个测试，我们将使用 <code>agnhost</code> 镜像。
这是一个 k8s 维护的镜像，可用于各种工作负载测试。例如，它有一个有用的
<a href=https://github.com/kubernetes/kubernetes/blob/b2c5bd2a278288b5ef19e25bf7413ecb872577a4/test/images/agnhost/README.md#grpc-health-checking>grpc-health-checking</a>
模块，该模块暴露了两个端口：一个是提供健康检查服务的端口，另一个是对 <code>make-serving</code> 和
<code>make-not-serving</code> 命令做出反应的 http 端口。</p><p>下面是一个 Pod 定义示例。它启用 <code>grpc-health-checking</code> 模块，暴露 5000 和 8080 端口，并配置 gRPC 就绪探针：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-grpc<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>agnhost<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>k8s.gcr.io/e2e-test-images/agnhost:2.35<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;/agnhost&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;grpc-health-checking&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>5000</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>readinessProbe</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>grpc</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>5000</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>如果文件名为 <code>test.yaml</code>，你可以用以下命令创建 Pod，并检查它的状态。如输出片段所示，Pod 将处于就绪状态。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f test.yaml
</span></span><span style=display:flex><span>kubectl describe test-grpc
</span></span></code></pre></div><p>输出将包含如下内容：</p><pre tabindex=0><code>Conditions:
  Type              Status
  Initialized       True
  Ready             True
  ContainersReady   True
  PodScheduled      True
</code></pre><p>现在让我们将健康检查端点状态更改为 <code>NOT_SERVING</code>。为了调用 Pod 的 http 端口，让我们创建一个端口转发：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl port-forward test-grpc 8080:8080
</span></span></code></pre></div><p>你可以用 <code>curl</code> 来调用这个命令。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl http://localhost:8080/make-not-serving
</span></span></code></pre></div><p>几秒钟后，端口状态将切换到未就绪。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe pod test-grpc
</span></span></code></pre></div><p>现在的输出将显示：</p><pre tabindex=0><code>Conditions:
  Type              Status
  Initialized       True
  Ready             False
  ContainersReady   False
  PodScheduled      True

...

  Warning  Unhealthy  2s (x6 over 42s)  kubelet            Readiness probe failed: service unhealthy (responded with &#34;NOT_SERVING&#34;)
</code></pre><p>一旦切换回来，Pod 将在大约一秒钟后恢复到就绪状态：</p><pre tabindex=0><code class=language-bsh data-lang=bsh>curl http://localhost:8080/make-serving
kubectl describe test-grpc
</code></pre><p>输出表明 Pod 恢复为 <code>Ready</code>：</p><pre tabindex=0><code>Conditions:
  Type              Status
  Initialized       True
  Ready             True
  ContainersReady   True
  PodScheduled      True
</code></pre><p>Kubernetes 上这种新的内置 gRPC 健康探测，使得通过 gRPC 实现健康检查比依赖使用额外的 <code>exec</code>
探测的旧方法更容易。请阅读官方
<a href=/zh-cn/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#define-a-grpc-liveness-probe>文档</a>
了解更多信息并在该功能正式发布（GA）之前提供反馈。</p><h2 id=总结>总结</h2><p>Kubernetes 是一个流行的工作负载编排平台，我们根据反馈和需求添加功能。
像 gRPC 探针支持这样的特性是一个小的改进，它将使许多应用程序开发人员的生活更容易，应用程序更有弹性。
在该功能 GA（正式发布）之前，现在就试试，并给出反馈。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-2f41c2d51858c88d0bc62e0ba3cf0a05>Kubernetes 1.24 版本中存储容量跟踪特性进入 GA 阶段</h1><div class="td-byline mb-4"><time datetime=2022-05-06 class=text-muted>2022.05.06</time></div><p><strong>作者:</strong> Patrick Ohly（Intel）</p><p>在 Kubernetes v1.24 版本中，<a href=/zh-cn/docs/concepts/storage/storage-capacity/>存储容量</a>跟踪已经成为一项正式发布的功能。</p><h2 id=已经解决的问题>已经解决的问题</h2><p>如<a href=/blog/2021/04/14/local-storage-features-go-beta/>上一篇关于此功能的博文</a>中所详细介绍的，
存储容量跟踪允许 CSI 驱动程序发布有关剩余容量的信息。当 Pod 仍然有需要配置的卷时，
kube-scheduler 使用该信息为 Pod 选择合适的节点。</p><p>如果没有这些信息，Pod 可能会被卡住，而不会被调度到合适节点，这是因为 kube-scheduler
只能盲目地选择节点。由于 CSI 驱动程序管理的下层存储系统没有足够的容量，
kube-scheduler 常常会选择一个无法为其配置卷的节点。</p><p>因为 CSI 驱动程序发布的这些存储容量信息在被使用的时候可能已经不是最新的信息了，
所以最终选择的节点无法正常工作的情况仍然可能会发生。
卷配置通过通知调度程序需要在其他节点上重试来恢复。</p><p>升级到 GA 版本后重新进行的<a href=https://github.com/kubernetes-csi/csi-driver-host-path/blob/master/docs/storage-capacity-tracking.md>负载测试</a>证实，
集群中部署了存储容量跟踪功能的 Pod 可以使用所有的存储，而没有部署此功能的 Pod 就会被卡住。</p><h2 id=尚未-解决的问题><em>尚未</em>解决的问题</h2><p>如果尝试恢复一个制备失败的卷，存在一个已知的限制：
如果 Pod 使用两个卷并且只能制备其中一个，那么所有将来的调度决策都受到已经制备的卷的限制。
如果该卷是节点的本地卷，并且另一个卷无法被制备，则 Pod 会卡住。
此问题早在存储容量跟踪功能之前就存在，虽然苛刻的附加条件使这种情况不太可能发生，
但是无法完全避免，当然每个 Pod 仅使用一个卷的情况除外。</p><p><a href=https://github.com/kubernetes/enhancements/pull/1703>KEP 草案</a>中提出了一个解决此问题的想法：
已制备但尚未被使用的卷不能包含任何有价值的数据，因此可以在其他地方释放并且再次被制备。
SIG Storage 正在寻找对此感兴趣并且愿意继续从事此工作的开发人员。</p><p>另一个没有解决的问题是 Cluster Autoscaler 对包含卷的 Pod 的支持。
对于具有存储容量跟踪功能的 CSI 驱动程序，我们开发了一个原型并在此
<a href=https://github.com/kubernetes/autoscaler/pull/3887>PR</a> 中进行了讨论。
此原型旨在与任意 CSI 驱动程序协同工作，但这种灵活性使其难以配置并减慢了扩展操作：
因为自动扩展程序无法模拟卷制备操作，它一次只能将集群扩展一个节点，这是此方案的不足之处。</p><p>因此，这个 PR 没有被合入，需要另一种不同的方法，在自动缩放器和 CSI 驱动程序之间实现更紧密的耦合。
为此，需要更好地了解哪些本地存储 CSI 驱动程序与集群自动缩放结合使用。如果这会引出新的 KEP，
那么用户将不得不在实践中尝试实现，然后才能迁移到 beta 版本或 GA 版本中。
如果你对此主题感兴趣，请联系 SIG Storage。</p><h2 id=致谢>致谢</h2><p>非常感谢为此功能做出贡献或提供反馈的 <a href=https://github.com/kubernetes/community/tree/master/sig-scheduling>SIG Scheduling</a>、
<a href=https://github.com/kubernetes/community/tree/master/sig-autoscaling>SIG Autoscaling</a>
和 <a href=https://github.com/kubernetes/community/tree/master/sig-storage>SIG Storage</a> 成员！</p></div><div class=td-content style=page-break-before:always><h1 id=pg-318f9ca753700673267096d658b4f32f>Kubernetes 1.24：卷扩充现在成为稳定功能</h1><div class="td-byline mb-4"><time datetime=2022-05-05 class=text-muted>2022.05.05</time></div><p><strong>作者：</strong> Hemant Kumar (Red Hat)</p><p>卷扩充在 Kubernetes 1.8 作为 Alpha 功能引入，
在 Kubernetes 1.11 进入了 Beta 阶段。
在 Kubernetes 1.24 中，我们很高兴地宣布卷扩充正式发布（GA）。</p><p>此功能允许 Kubernetes 用户简单地编辑其 <code>PersistentVolumeClaim</code> 对象，
并在 PVC Spec 中指定新的大小，Kubernetes 将使用存储后端自动扩充卷，
同时也会扩充 Pod 使用的底层文件系统，使得无需任何停机时间成为可能。</p><h3 id=如何使用卷扩充>如何使用卷扩充</h3><p>通过编辑 PVC 的 <code>spec</code> 字段，指定不同的（和更大的）存储请求，
可以触发 PersistentVolume 的扩充。
例如，给定以下 PVC：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myclaim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>1Gi<span style=color:#bbb> </span><span style=color:#080;font-style:italic># 在此处指定新的大小</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>你可以指定新的值来替代旧的 <code>1Gi</code> 大小来请求扩充下层 PersistentVolume。
一旦你更改了请求的大小，可以查看 PVC 的 <code>status.conditions</code> 字段，
确认卷大小的调整是否已完成。</p><p>当 Kubernetes 开始扩充卷时，它会给 PVC 添加 <code>Resizing</code> 状况。
一旦扩充结束，这个状况会被移除。通过监控与 PVC 关联的事件，
还可以获得更多关于扩充操作进度的信息：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl describe pvc &lt;pvc&gt;
</span></span></code></pre></div><h3 id=存储驱动支持>存储驱动支持</h3><p>然而，并不是每种卷类型都默认支持扩充。
某些卷类型（如树内 hostpath 卷）不支持扩充。
对于 CSI 卷，
CSI 驱动必须在控制器或节点服务（如果合适，二者兼备）
中具有 <code>EXPAND_VOLUME</code> 能力。
请参阅 CSI 驱动的文档，了解其是否支持卷扩充。</p><p>有关支持卷扩充的树内（intree）卷类型，
请参阅卷扩充文档：<a href=/zh-cn/docs/concepts/storage/persistent-volumes/#expanding-persistent-volumes-claims>扩充 PVC 申领</a>。</p><p>通常，为了对可扩充的卷提供某种程度的控制，
只有在存储类将 <code>allowVolumeExpansion</code> 参数设置为 <code>true</code> 时，
动态供应的 PVC 才是可扩充的。</p><p>Kubernetes 集群管理员必须编辑相应的 StorageClass 对象，
并将 <code>allowVolumeExpansion</code> 字段设置为 <code>true</code>。例如：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>gp2-default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/aws-ebs<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>secretNamespace</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>allowVolumeExpansion</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=在线扩充与离线扩充比较>在线扩充与离线扩充比较</h3><p>默认情况下，Kubernetes 会在用户请求调整大小后立即尝试扩充卷。
如果一个或多个 Pod 正在使用该卷，
Kubernetes 会尝试通过在线调整大小来扩充该卷；
因此，卷扩充通常不需要应用停机。
节点上的文件系统也可以在线扩充，因此不需要关闭任何正在使用 PVC 的 Pod。</p><p>如果要扩充的 PersistentVolume 未被使用，Kubernetes 会用离线方式调整卷大小
（而且，由于该卷未使用，所以也不会造成工作负载中断）。</p><p>但在某些情况下，如果底层存储驱动只能支持离线扩充，
则 PVC 用户必须先停止 Pod，才能让扩充成功。
请参阅存储提供商的文档，了解其支持哪种模式的卷扩充。</p><p>当卷扩充作为 Alpha 功能引入时，
Kubernetes 仅支持在节点上进行离线的文件系统扩充，
因此需要用户重新启动 Pod，才能完成文件系统的大小调整。
今天，用户的行为已经被改变，无论底层 PersistentVolume 是在线还是离线，
Kubernetes 都会尽最大努力满足任何调整大小的请求。
如果你的存储提供商支持在线扩充，则无需重启 Pod 即可完成卷扩充。</p><h2 id=下一步>下一步</h2><p>尽管卷扩充在最近的 v1.24 发行版中成为了稳定版本，
但 SIG Storage 团队仍然在努力让 Kubernetes 用户扩充其持久性存储变得更简单。
Kubernetes 1.23 引入了卷扩充失败后触发恢复机制的功能特性，
允许用户在大小调整失败后尝试自助修复。
更多详细信息，请参阅<a href=/zh-cn/docs/concepts/storage/persistent-volumes/#recovering-from-failure-when-expanding-volumes>处理扩充卷过程中的失败</a>。</p><p>Kubernetes 贡献者社区也在讨论有状态（StatefulSet）驱动的存储扩充的潜力。
这个提议的功能特性将允许用户通过直接编辑 StatefulSet 对象，
触发为 StatefulSet 提供存储的所有底层 PV 的扩充。
更多详细信息，请参阅<a href=https://github.com/kubernetes/enhancements/issues/661>通过 StatefulSet 支持卷扩充</a>的改善提议。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-fd94a70167eea241eb51d0090b4a042e>Dockershim：历史背景</h1><div class="td-byline mb-4"><time datetime=2022-05-03 class=text-muted>2022.05.03</time></div><p><strong>作者：</strong> Kat Cosgrove</p><p>自 Kubernetes v1.24 起，Dockershim 已被删除，这对项目来说是一个积极的举措。
然而，背景对于充分理解某事很重要，无论是社交还是软件开发，这值得更深入的审查。
除了 Kubernetes v1.24 中的 dockershim 移除之外，
我们在社区中看到了一些混乱（有时处于恐慌级别）和对这一决定的不满，
主要是由于缺乏有关此删除背景的了解。弃用并最终从 Kubernetes 中删除
dockershim 的决定并不是迅速或轻率地做出的。
尽管如此，它已经工作了很长时间，以至于今天的许多用户都比这个决定更新，
更不用提当初为何引入 dockershim 了。</p><p>那么 dockershim 是什么，为什么它会消失呢？</p><p>在 Kubernetes 的早期，我们只支持一个容器运行时，那个运行时就是 Docker Engine。
那时，并没有太多其他选择，而 Docker 是使用容器的主要工具，所以这不是一个有争议的选择。
最终，我们开始添加更多的容器运行时，比如 rkt 和 hypernetes，很明显 Kubernetes
用户希望选择最适合他们的运行时。因此，Kubernetes 需要一种方法来允许集群操作员灵活地使用他们选择的任何运行时。</p><p><a href=/blog/2016/12/container-runtime-interface-cri-in-kubernetes/>容器运行时接口</a> (CRI)
已发布以支持这种灵活性。 CRI 的引入对项目和用户来说都很棒，但它确实引入了一个问题：Docker Engine
作为容器运行时的使用早于 CRI，并且 Docker Engine 不兼容 CRI。 为了解决这个问题，在 kubelet
组件中引入了一个小型软件 shim (dockershim)，专门用于填补 Docker Engine 和 CRI 之间的空白，
允许集群操作员继续使用 Docker Engine 作为他们的容器运行时基本上不间断。</p><p>然而，这个小软件 shim 从来没有打算成为一个永久的解决方案。 多年来，它的存在给
kubelet 本身带来了许多不必要的复杂性。由于这个 shim，Docker
的一些集成实现不一致，导致维护人员的负担增加，并且维护特定于供应商的代码不符合我们的开源理念。
为了减少这种维护负担并朝着支持开放标准的更具协作性的社区迈进，
<a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-node/2221-remove-dockershim>引入了 KEP-2221</a>，
建议移除 dockershim。随着 Kubernetes v1.20 的发布，正式弃用。</p><p>我们没有很好地传达这一点，不幸的是，弃用公告在社区内引起了一些恐慌。关于这对
Docker作为一家公司意味着什么，Docker 构建的容器镜像是否仍然可以运行，以及
Docker Engine 究竟是什么导致了社交媒体上的一场大火，人们感到困惑。
这是我们的错；我们应该更清楚地传达当时发生的事情和原因。为了解决这个问题，
我们发布了<a href=/zh-cn/blog/2020/12/02/dont-panic-kubernetes-and-docker/>一篇博客</a>和<a href=/zh-cn/blog/2020/12/02/dockershim-faq/>相应的 FAQ</a>
以减轻社区的恐惧并纠正对 Docker 是什么以及容器如何在 Kubernetes 中工作的一些误解。
由于社区的关注，Docker 和 Mirantis 共同决定继续以
<a href=https://www.mirantis.com/blog/the-future-of-dockershim-is-cri-dockerd/>cri-dockerd</a>
的形式支持 dockershim 代码，允许你在需要时继续使用 Docker Engine 作为容器运行时。
对于想要尝试其他运行时（如 containerd 或 cri-o）的用户，
<a href=/zh-cn/docs/tasks/administer-cluster/migrating-from-dockershim/change-runtime-containerd/>已编写迁移文档</a>。</p><p>我们后来<a href=https://kubernetes.io/blog/2021/11/12/are-you-ready-for-dockershim-removal/>调查了社区</a><a href=/zh-cn/blog/2022/01/07/kubernetes-is-moving-on-from-dockershim>发现还有很多用户有疑问和顾虑</a>。
作为回应，Kubernetes 维护人员和 CNCF 承诺通过扩展文档和其他程序来解决这些问题。
事实上，这篇博文是这个计划的一部分。随着如此多的最终用户成功迁移到其他运行时，以及改进的文档，
我们相信每个人现在都为迁移铺平了道路。</p><p>Docker 不会消失，无论是作为一种工具还是作为一家公司。它是云原生社区的重要组成部分，
也是 Kubernetes 项目的历史。没有他们，我们就不会是现在的样子。也就是说，从 kubelet
中删除 dockershim 最终对社区、生态系统、项目和整个开源都有好处。
这是我们所有人齐心协力支持开放标准的机会，我们很高兴在 Docker 和社区的帮助下这样做。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-13ed1226f0c58b8693c0ff23815c2739>Kubernetes 1.24: 观星者</h1><div class="td-byline mb-4"><time datetime=2022-05-03 class=text-muted>2022.05.03</time></div><p><strong>作者</strong>: <a href=https://git.k8s.io/sig-release/releases/release-1.24/release-team.md>Kubernetes 1.24 发布团队</a></p><p>我们很高兴地宣布 Kubernetes 1.24 的发布，这是 2022 年的第一个版本！</p><p>这个版本包括 46 个增强功能：14 个增强功能已经升级到稳定版，15 个增强功能正在进入 Beta 版，
13 个增强功能正在进入 Alpha 阶段。另外，有两个功能被废弃了，还有两个功能被删除了。</p><h2 id=主要议题>主要议题</h2><h3 id=从-kubelet-中删除-dockershim>从 kubelet 中删除 Dockershim</h3><p>在 v1.20 版本中被废弃后，dockershim 组件已被从 Kubernetes v1.24 版本的 kubelet 中移除。
从 v1.24 开始，如果你依赖 Docker Engine 作为容器运行时，
则需要使用其他<a href=/zh-cn/docs/setup/production-environment/container-runtimes/>受支持的运行时</a>之一
（如 containerd 或 CRI-O）或使用 CRI dockerd。
有关确保集群已准备好进行此删除的更多信息，请参阅<a href=/zh-cn/blog/2022/03/31/ready-for-dockershim-removal/>本指南</a>。</p><h3 id=默认情况下关闭-beta-api>默认情况下关闭 Beta API</h3><p><a href=https://github.com/kubernetes/enhancements/issues/3136>新的 beta API 默认不会在集群中启用</a>。
默认情况下，现有 Beta API 和及其更新版本将继续被启用。</p><h3 id=签署发布工件>签署发布工件</h3><p>发布工件使用 <a href=https://github.com/sigstore/cosign>cosign</a> 签名进行<a href=https://github.com/kubernetes/enhancements/issues/3031>签名</a>，
并且有<a href=/zh-cn/docs/tasks/administer-cluster/verify-signed-images/>验证图像签名</a>的实验性支持。
发布工件的签名和验证是<a href=https://github.com/kubernetes/enhancements/issues/3027>提高 Kubernetes 发布过程的软件供应链安全性</a>
的一部分。</p><h3 id=openapi-v3>OpenAPI v3</h3><p>Kubernetes 1.24 提供了以 <a href=https://github.com/kubernetes/enhancements/issues/2896>OpenAPI v3 格式</a>发布其 API 的 Beta 支持。</p><h3 id=存储容量和卷扩展普遍可用>存储容量和卷扩展普遍可用</h3><p><a href=https://github.com/kubernetes/enhancements/issues/1472>存储容量跟踪</a>支持通过
<a href=/zh-cn/docs/concepts/storage/storage-capacity/#api>CSIStorageCapacity 对象</a>公开当前可用的存储容量，
并增强使用具有后期绑定的 CSI 卷的 Pod 的调度。</p><p><a href=https://github.com/kubernetes/enhancements/issues/284>卷的扩展</a>增加了对调整现有持久性卷大小的支持。</p><h3 id=nonpreemptingpriority-到稳定>NonPreemptingPriority 到稳定</h3><p>此功能<a href=https://github.com/kubernetes/enhancements/issues/902>为 PriorityClasses 添加了一个新选项</a>，可以启用或禁用 Pod 抢占。</p><h3 id=存储插件迁移>存储插件迁移</h3><p>目前正在进行<a href=https://github.com/kubernetes/enhancements/issues/625>迁移树内存储插件的内部组件</a>工作，
以便在保持原有 API 的同时调用 CSI 插件。<a href=https://github.com/kubernetes/enhancements/issues/1490>Azure Disk</a>
和 <a href=https://github.com/kubernetes/enhancements/issues/1489>OpenStack Cinder</a> 插件都已迁移。</p><h3 id=grpc-探针升级到-beta>gRPC 探针升级到 Beta</h3><p>在 Kubernetes 1.24 中，<a href=https://github.com/kubernetes/enhancements/issues/2727>gRPC 探测功能</a>
已进入测试版，默认可用。现在，你可以在 Kubernetes 中为你的 gRPC
应用程序原生地<a href=/zh-cn/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#configure-probes>配置启动、存活和就绪性探测</a>，
而无需暴露 HTTP 端点或使用额外的可执行文件。</p><h3 id=kubelet-凭证提供者毕业至-beta>Kubelet 凭证提供者毕业至 Beta</h3><p>kubelet 最初在 Kubernetes 1.20 中作为 Alpha 发布，现在它对<a href=/zh-cn/docs/tasks/kubelet-credential-provider/kubelet-credential-provider/>镜像凭证提供者</a>
的支持已升级到 Beta。这允许 kubelet 使用 exec 插件动态检索容器镜像仓库的凭据，而不是将凭据存储在节点的文件系统上。</p><h3 id=alpha-中的上下文日志记录>Alpha 中的上下文日志记录</h3><p>Kubernetes 1.24 引入了<a href=https://github.com/kubernetes/enhancements/issues/3077>上下文日志</a>
这使函数的调用者能够控制日志记录的所有方面（输出格式、详细程度、附加值和名称）。</p><h3 id=避免-ip-分配给服务的冲突>避免 IP 分配给服务的冲突</h3><p>Kubernetes 1.24 引入了一项新的选择加入功能，
允许你<a href=/zh-cn/docs/concepts/services-networking/service/#service-ip-static-sub-range>为服务的静态 IP 地址分配软保留范围</a>。
通过手动启用此功能，集群将更喜欢从服务 IP 地址池中自动分配，从而降低冲突风险。</p><p>服务的 <code>ClusterIP</code> 可以按照以下两种方式分配：</p><ul><li>动态，这意味着集群将自动在配置的服务 IP 范围内选择一个空闲 IP。</li><li>静态，这意味着用户将在配置的服务 IP 范围内设置一个 IP。</li></ul><p>服务 <code>ClusterIP</code> 是唯一的；因此，尝试使用已分配的 <code>ClusterIP</code> 创建服务将返回错误。</p><h3 id=从-kubelet-中移除动态-kubelet-配置>从 Kubelet 中移除动态 Kubelet 配置</h3><p>在 Kubernetes 1.22 中被弃用后，动态 Kubelet 配置已从 kubelet 中移除。
该功能将从 Kubernetes 1.26 的 API 服务器中移除。</p><h2 id=cni-版本相关的重大更改>CNI 版本相关的重大更改</h2><p>在升级到 Kubernetes 1.24 之前，请确认你正在使用/升级到经过测试可以在此版本中正常工作的容器运行时。</p><p>例如，以下容器运行时正在为 Kubernetes 准备，或者已经准备好了。</p><ul><li>containerd v1.6.4 及更高版本，v1.5.11 及更高版本</li><li>CRI-O 1.24 及更高版本</li></ul><p>当 CNI 插件尚未升级和/或 CNI 配置版本未在 CNI 配置文件中声明时，在 containerd v1.6.0–v1.6.3
中存在 Pod CNI 网络设置和拆除的服务问题。containerd 团队报告说，“这些问题在 containerd v1.6.4 中得到解决。”</p><p>在 containerd v1.6.0-v1.6.3 版本中，如果你不升级 CNI 插件和/或声明 CNI 配置版本，
你可能会遇到以下 “Incompatible CNI versions” 或 “Failed to destroy network for sandbox” 的错误情况。</p><h2 id=csi-快照>CSI 快照</h2><p><strong>此信息是在首次发布后添加的。</strong></p><p><a href=https://github.com/kubernetes/enhancements/issues/177>VolumeSnapshot v1beta1 CRD 已被移除</a>。
Kubernetes 和容器存储接口 (CSI) 的卷快照和恢复功能，提供标准化的 API 设计 (CRD) 并添加了对 CSI 卷驱动程序的
PV 快照/恢复支持，在 v1.20 中升级至 GA。VolumeSnapshot v1beta1 在 v1.20 中被弃用，现在不受支持。
有关详细信息，请参阅 <a href=https://git.k8s.io/enhancements/keps/sig-storage/177-volume-snapshot#kep-177-csi-snapshot>KEP-177: CSI 快照</a>
和<a href=/blog/2020/12/10/kubernetes-1.20-volume-snapshot-moves-to-ga/>卷快照 GA 博客</a>。</p><h2 id=其他更新>其他更新</h2><h3 id=毕业到稳定版>毕业到稳定版</h3><p>在此版本中，有 14 项增强功能升级为稳定版：</p><ul><li><a href=https://github.com/kubernetes/enhancements/issues/284>容器存储接口（CSI）卷扩展</a></li><li><a href=https://github.com/kubernetes/enhancements/issues/688>Pod 开销</a>: 核算与 Pod 沙箱绑定的资源，但不包括特定的容器。</li><li><a href=https://github.com/kubernetes/enhancements/issues/902>向 PriorityClass 添加非抢占选项</a></li><li><a href=https://github.com/kubernetes/enhancements/issues/1472>存储容量跟踪</a></li><li><a href=https://github.com/kubernetes/enhancements/issues/1489>OpenStack Cinder In-Tree 到 CSI 驱动程序迁移</a></li><li><a href=https://github.com/kubernetes/enhancements/issues/1490>Azure 磁盘树到 CSI 驱动程序迁移</a></li><li><a href=https://github.com/kubernetes/enhancements/issues/1904>高效的监视恢复</a>：
kube-apiserver 重新启动后，可以高效地恢复监视。</li><li><a href=https://github.com/kubernetes/enhancements/issues/1959>Service Type=LoadBalancer 类字段</a>：
引入新的服务注解 <code>service.kubernetes.io/load-balancer-class</code>，
允许在同一个集群中提供 <code>type: LoadBalancer</code> 服务的多个实现。</li><li><a href=https://github.com/kubernetes/enhancements/issues/2214>带索引的 Job</a>：为带有固定完成计数的 Job 的 Pod 添加完成索引。</li><li><a href=https://github.com/kubernetes/enhancements/issues/2232>在 Job API 中增加 suspend 字段</a>：
在 Job API 中增加一个 suspend 字段，允许协调者在创建作业时对 Pod 的创建进行更多控制。</li><li><a href=https://github.com/kubernetes/enhancements/issues/2249>Pod 亲和性 NamespaceSelector</a>：
为 Pod 亲和性/反亲和性规约添加一个 <code>namespaceSelector</code> 字段。</li><li><a href=https://github.com/kubernetes/enhancements/issues/2436>控制器管理器的领导者迁移</a>：
kube-controller-manager 和 cloud-controller-manager 可以在 HA 控制平面中重新分配新的控制器到控制器管理器，而无需停机。</li><li><a href=https://github.com/kubernetes/enhancements/issues/2784>CSR 期限</a>：
用一种机制来扩展证书签名请求 API，允许客户为签发的证书请求一个特定的期限。</li></ul><h3 id=主要变更>主要变更</h3><p>此版本有两个主要变更：</p><ul><li><a href=https://github.com/kubernetes/enhancements/issues/2221>移除 Dockershim</a></li><li><a href=https://github.com/kubernetes/enhancements/issues/3136>默认关闭 Beta API</a></li></ul><h3 id=发行说明>发行说明</h3><p>在我们的<a href=https://git.k8s.io/kubernetes/CHANGELOG/CHANGELOG-1.24.md>发行说明</a> 中查看 Kubernetes 1.24 版本的完整详细信息。</p><h3 id=可用性>可用性</h3><p>Kubernetes 1.24 可在 <a href=https://github.com/kubernetes/kubernetes/releases/tag/v1.24.0>GitHub</a> 上下载。
要开始使用 Kubernetes，请查看这些<a href=/zh-cn/docs/tutorials/>交互式教程</a>或在本地运行。
使用 <a href=https://kind.sigs.k8s.io/>kind</a>，可以将容器作为 Kubernetes 集群的 “节点”。
你还可以使用 <a href=/zh-cn/docs/setup/independent/create-cluster-kubeadm/>kubeadm</a> 轻松安装 1.24。</p><h3 id=发布团队>发布团队</h3><p>如果没有 Kubernetes 1.24 发布团队每个人做出的共同努力，这个版本是不可能实现的。
该团队齐心协力交付每个 Kubernetes 版本中的所有组件，包括代码、文档、发行说明等。</p><p>特别感谢我们的发布负责人 James Laverack 指导我们完成了一个成功的发布周期，
并感谢所有发布团队成员投入时间和精力为 Kubernetes 社区提供 v1.24 版本。</p><h3 id=发布主题和徽标>发布主题和徽标</h3><p><strong>Kubernetes 1.24: 观星者</strong></p><figure class=release-logo><img src=/images/blog/2022-05-03-kubernetes-release-1.24/kubernetes-1.24.png></figure><p>Kubernetes 1.24 的主题是<strong>观星者（Stargazer）</strong>。</p><p>古代天文学家到建造 James Webb 太空望远镜的科学家，几代人都怀着敬畏和惊奇的心情仰望星空。
是这些星辰启发了我们，点燃了我们的想象力，引导我们在艰难的海上度过了漫长的夜晚。</p><p>通过此版本，我们向上凝视，当我们的社区聚集在一起时可能发生的事情。
Kubernetes 是全球数百名贡献者和数千名最终用户支持的成果，
是一款为数百万人服务的应用程序。每个人都是我们天空中的一颗星星，帮助我们规划路线。</p><p>发布标志由 <a href=https://www.instagram.com/artsyfie/>Britnee Laverack</a> 制作，
描绘了一架位于星空和<a href=https://en.wikipedia.org/wiki/Pleiades>昴星团</a>的望远镜，在神话中通常被称为“七姐妹”。
数字 7 对于 Kubernetes 项目特别吉祥，是对我们最初的“项目七”名称的引用。</p><p>这个版本的 Kubernetes 为那些仰望夜空的人命名——为所有的观星者命名。 ✨</p><h3 id=用户亮点>用户亮点</h3><ul><li>了解领先的零售电子商务公司
<a href=https://www.cncf.io/case-studies/la-redoute/>La Redoute 如何使用 Kubernetes 以及其他 CNCF 项目来转变和简化</a>
其从开发到运营的软件交付生命周期。</li><li>为了确保对 API 调用的更改不会导致任何中断，<a href=https://www.cncf.io/case-studies/salt-security/>Salt Security 完全在 Kubernetes 上构建了它的微服务，
它通过 gRPC 进行通信，而 Linkerd 确保消息是加密的</a>。</li><li>为了从私有云迁移到公共云，<a href=https://www.cncf.io/case-studies/allianz/>Alllainz Direct 工程师在短短三个月内重新设计了其 CI/CD 管道，
同时设法将 200 个工作流压缩到 10-15 个</a>。</li><li>看看<a href=https://www.cncf.io/case-studies/bink/>英国金融科技公司 Bink 是如何用 Linkerd 更新其内部的 Kubernetes 分布，以建立一个云端的平台，
根据需要进行扩展，同时允许他们密切关注性能和稳定性</a>。</li><li>利用Kubernetes，荷兰组织 <a href=http://www.stichtingopennederland.nl/>Stichting Open Nederland</a>
在短短一个半月内创建了一个测试门户网站，以帮助安全地重新开放荷兰的活动。
<a href=https://www.testenvoortoegang.org/>入门测试 (Testen voor Toegang)</a>
平台<a href=https://www.cncf.io/case-studies/true/>利用 Kubernetes 的性能和可扩展性来帮助个人每天预订超过 400,000 个 COVID-19 测试预约</a>。</li><li>与 SparkFabrik 合作并利用 Backstage，<a href=https://www.cncf.io/case-studies/santagostino/>Santagostino 创建了开发人员平台 Samaritan 来集中服务和文档，
管理服务的整个生命周期，并简化 Santagostino 开发人员的工作</a>。</li></ul><h3 id=生态系统更新>生态系统更新</h3><ul><li>KubeCon + CloudNativeCon Europe 2022 于 2022 年 5 月 16 日至 20 日在西班牙巴伦西亚举行！
你可以在<a href=https://events.linuxfoundation.org/kubecon-cloudnativecon-europe/>活动网站</a>上找到有关会议和注册的更多信息。</li><li>在 <a href=https://www.cncf.io/announcements/2022/02/10/cncf-sees-record-kubernetes-and-container-adoption-in-2021-cloud-native-survey/>2021 年云原生调查</a>
中，CNCF 看到了创纪录的 Kubernetes 和容器采用。参阅<a href=https://www.cncf.io/reports/cncf-annual-survey-2021/>调查结果</a>。</li><li><a href=https://www.linuxfoundation.org/>Linux 基金会</a>和<a href=https://www.cncf.io/>云原生计算基金会</a> (CNCF)
宣布推出新的 <a href="https://training.linuxfoundation.org/training/cloudnativedev-bootcamp/?utm_source=lftraining&utm_medium=pr&utm_campaign=clouddevbc0322">云原生开发者训练营</a>
为参与者提供设计、构建和部署云原生应用程序的知识和技能。查看<a href=https://www.cncf.io/announcements/2022/03/15/new-cloud-native-developer-bootcamp-provides-a-clear-path-to-cloud-native-careers/>公告</a>以了解更多信息。</li></ul><h3 id=项目速度>项目速度</h3><p>The <a href="https://k8s.devstats.cncf.io/d/12/dashboards?orgId=1&refresh=15m">CNCF K8s DevStats</a> 项目
汇总了许多与 Kubernetes 和各种子项目的速度相关的有趣数据点。这包括从个人贡献到做出贡献的公司数量的所有内容，
并且说明了为发展这个生态系统而付出的努力的深度和广度。</p><p>在<a href=https://github.com/kubernetes/sig-release/tree/master/releases/release-1.24>运行 17 周</a>
（ 1 月 10 日至 5 月 3 日）的 v1.24 发布周期中，我们看到 <a href="https://k8s.devstats.cncf.io/d/9/companies-table?orgId=1&var-period_name=v1.23.0%20-%20v1.24.0&var-metric=contributions">1029 家公司</a>
和 <a href="https://k8s.devstats.cncf.io/d/66/developer-activity-counts-by-companies?orgId=1&var-period_name=v1.23.0%20-%20v1.24.0&var-metric=contributions&var-repogroup_name=Kubernetes&var-country_name=All&var-companies=All&var-repo_name=kubernetes%2Fkubernetes">1179 人</a> 的贡献。</p><h2 id=即将发布的网络研讨会>即将发布的网络研讨会</h2><p>在太平洋时间 2022 年 5 月 24 日星期二上午 9:45 至上午 11 点加入 Kubernetes 1.24 发布团队的成员，
了解此版本的主要功能以及弃用和删除，以帮助规划升级。有关更多信息和注册，
请访问 CNCF 在线计划网站上的<a href=https://community.cncf.io/e/mck3kd/>活动页面</a>。</p><h2 id=参与进来>参与进来</h2><p>参与 Kubernetes 的最简单方法是加入符合你兴趣的众多<a href=https://git.k8s.io/community/sig-list.md>特别兴趣组</a>（SIG）之一。
你有什么想向 Kubernetes 社区广播的内容吗？
在我们的每周的<a href=https://git.k8s.io/community/communication>社区会议</a>上分享你的声音，并通过以下渠道：</p><ul><li>在 <a href=https://www.kubernetes.dev/>Kubernetes Contributors</a> 网站上了解有关为 Kubernetes 做出贡献的更多信息</li><li>在 Twitter 上关注我们 <a href=https://twitter.com/kubernetesio>@Kubernetesio</a> 以获取最新更新</li><li>加入社区讨论 <a href=https://discuss.kubernetes.io/>Discuss</a></li><li>加入 <a href=http://slack.k8s.io/>Slack</a> 社区</li><li>在 <a href=https://serverfault.com/questions/tagged/kubernetes>Server Fault</a> 上发布问题（或回答问题）。</li><li>分享你的 Kubernetes <a href=https://docs.google.com/a/linuxfoundation.org/forms/d/e/1FAIpQLScuI7Ye3VQHQTwBASrgkjQDSS5TP0g3AXfFhwSM9YpHgxRKFA/viewform>故事</a></li><li>在<a href=/zh-cn/blog/>博客</a>上阅读有关 Kubernetes 正在发生的事情的更多信息</li><li>详细了解 <a href=https://git.k8s.io/sig-release/release-team>Kubernetes 发布团队</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-a3a8e38826ac217e8cfceed08bf83370>Frontiers, fsGroups and frogs: Kubernetes 1.23 发布采访</h1><div class="td-byline mb-4"><time datetime=2022-04-29 class=text-muted>2022.04.29</time></div><p><strong>作者</strong>: Craig Box (Google)</p><p>举办每周一次的<a href=https://kubernetespodcast.com/>来自 Google 的 Kubernetes 播客</a>
的亮点之一是与每个新 Kubernetes 版本的发布经理交谈。发布团队不断刷新。许多人从小型文档修复开始，逐步晋升为影子角色，然后最终领导发布。</p><p>在我们为下周发布的 1.24 版本做准备时，<a href="https://www.google.com/search?q=%22release+interview%22+site%3Akubernetes.io%2Fblog">按照长期以来的传统</a>，
很高兴带大家回顾一下 1.23 的故事。该版本由 SUSE 的现场工程师 <a href=https://twitter.com/reylejano>Rey Lejano</a> 领导。
在 12 月<a href=https://kubernetespodcast.com/episode/167-kubernetes-1.23/>我与 Rey 交谈过</a>，当时他正在等待他的第一个孩子的出生。</p><p>请确保你<a href=https://kubernetespodcast.com/subscribe/>订阅，无论你在哪里获得你的播客</a>，
以便你听到我们所有来自云原生社区的故事，包括下周 1.24 的故事。</p><p><strong>为清晰起见本稿件经过了简单的编辑和浓缩。</strong></p><hr><p><strong>CRAIG BOX：我想从现在每个人最关心的问题开始。让我们谈谈非洲爪蛙！</strong></p><p>REY LEJANO：[笑]哦，你是说 <a href=https://en.wikipedia.org/wiki/African_clawed_frog>Xenopus lavis</a>，非洲爪蛙的学名？</p><p><strong>CRAIG BOX：当然。</strong></p><p>REY LEJANO：知道的人不多，但我曾就读于戴維斯加利福尼亚大学的微生物学专业。
我在生物化学实验室做了大约四年的生物化学研究，并且我<a href=https://www.sciencedirect.com/science/article/pii/>确实发表了一篇研究论文</a>。
它实际上是在糖蛋白上，特别是一种叫做“皮质颗粒凝集素”的东西。我们使用青蛙，因为它们会产生大量的蛋，我们可以从中提取蛋白质。
这种蛋白质可以防止多精症。当精子进入卵子时，卵子会向细胞膜释放一种糖蛋白，即皮质颗粒凝集素，并阻止任何其他精子进入卵子。</p><p><strong>CRAIG BOX：你是否能够从我们对青蛙进行的测试中汲取任何东西并将其推广到更高阶的哺乳动物？</strong></p><p>REY LEJANO：是的。由于哺乳动物也有皮质颗粒凝集素，我们能够分析收敛和进化模式，不仅来自多种青蛙，还包括哺乳动物。</p><p><strong>CRAIG BOX：现在，这里有几个不同的线索需要解开。当你年轻的时候，是什么引导你进入生物学领域，可以侧重介绍技术方面的内容吗？</strong></p><p>REY LEJANO：我认为这主要来自家庭，因为我在医学领域确实有可以追溯到几代人的家族史。所以我觉得那是进入大学的自然路径。</p><p><strong>CRAIG BOX：现在，你正在一个更抽象的技术领域工作。是什么让你离开了微生物学？</strong></p><p>REY LEJANO：[笑]嗯，我一直对科技很感兴趣。我年轻的时候自学了一点编程，在高中之前，做了一些网络开发的东西。
只是在实验室里有点焦头烂额了，实际上是在地下室。我有一个很好的机会加入了一家专门从事 <a href=https://www.axelos.com/certifications/itil-service-management/what-is-itil>ITIL</a>
的咨询公司。实际上，我从应用性能管理开始，进入监控，进入运营管理和 ITIL，也就是把你的 IT 资产管理和服务管理与商业服务结合起来。实际上，我在这方面做了很多年。</p><p><strong>CRAIG BOX：这很有趣，当人们描述他们所经历的事情以及他们所从事的技术时，你几乎可以确定他们的年龄。
现在有很多人进入科技行业，但从未听说过 ITIL。他们不知道那是什么。它基本上和 SRE 类似，只是过程更加复杂。</strong></p><p>REY LEJANO：是的，一点没错。它不是非常云原生的。[笑]</p><p><strong>CRAIG BOX：一点也不。</strong></p><p>REY LEJANO：在云原生环境中，你并没有真正听说过它。毫无疑问，如果有人专门从事过 ITIL 工作或之前曾与 ITIL 合作过，你肯定可以看出他们已经在该领域工作了一段时间。</p><p><strong>CRAIG BOX：你提到你想离开地下室。这的确是程序员常待的地方。他们只是在新的地下室里给了你一点光吗？</strong></p><p>REY LEJANO：[笑]他们确实给了我们更好的照明。有时也能获得一些维生素 D。</p><p><strong>CRAIG BOX：总结一下你的过往职业经历：在过去的一年里，随着全球各地的发展变化，我认为如今微生物学技能可能比你在校时更受欢迎？</strong></p><p>REY LEJANO：哦，当然。我肯定能看到进入这个领域的人数大增。此外，阅读当前世界正在发生的事情也会带回我过去所学的所有教育。</p><p><strong>CRAIG BOX：你和当时的同学还在保持联系吗？</strong></p><p>REY LEJANO：只是一些亲密的朋友，但不是在微生物学领域。</p><p><strong>CRAIG BOX：我认为，这次的全球疫情可能让人们对科学、技术、工程和数学领域重新产生兴趣。
看看这对整个社会有什么影响，将是很有趣的。</strong></p><p>REY LEJANO：是的。我认为那会很棒。</p><p><strong>CRAIG BOX：你提到在一家咨询公司工作，从事 IT 管理、应用程序性能监控等工作。Kubernetes 是什么时候进入你的职业生涯的？</strong></p><p>REY LEJANO：在我工作的公司，我的一位好朋友于 2015 年年中离职。他去了一家非常热衷于 Docker 的公司。
他教了我一点东西。我在 2015 年左右，也许是 2016 年，做了我的第一次 “docker run”。
然后，我们用于 ITIL 框架的一个应用程序在 2018 年左右被容器化了，也在 Kubernetes 中。
那个时候，它是有些问题的。那是我第一次接触 Kubernetes 和容器化应用程序。</p><p>然后我离开了那家公司，实际上我加入了我在 <a href=https://rx-m.com/>RX-M</a> 的朋友，这是一家云原生咨询和培训公司。
他们专门从事 Docker 和 Kubernetes 的工作。我能够让我脚踏实地。我拿到了 CKD 和 CKA 证书。
他们在鼓励我们学习更多关于 Kubernetes 的知识和参与社区活动方面真的非常棒。</p><p><strong>CRAIG BOX：然后，你将看到人们采用 Kubernetes 和容器化的整个生命周期，通过你自己的初始旅程，然后通过帮助客户。你如何描述这段旅程从早期到今天的变化？</strong></p><p>REY LEJANO：我认为早期有很多问题，为什么我必须容器化？为什么我不能只使用虚拟机？</p><p><strong>CRAIG BOX：这是你的简历上的一个条目。</strong></p><p>REY LEJANO：[笑]是的。现在，我认为人们知道使用容器的价值，以及使用 Kubernetes 编排容器的价值。我不想说“赶上潮流”，但它已经成为编排容器的事实标准。</p><p><strong>CRAIG BOX：这不是咨询公司需要走出去向客户推销他们应该做的事情。他们只是把它当作会发生的事情，并开始在这条路上走得更远一些，也许。</strong></p><p>REY LEJANO：当然。</p><p><strong>CRAIG BOX：在这样的咨询公司工作，你有多少时间致力于改善流程，也许是为多个客户，然后研究如何将这项工作推向上游，而不是每次只为单个客户做有偿工作？</strong></p><p>REY LEJANO：那时，情况会有所不同。他们帮我介绍了自己，我也了解了很多关于云原生环境和 Kubernetes 本身的情况。
他们帮助我了解如何将云原生环境及其周围的工具一起使用。我在那家公司的老板，Randy，实际上他鼓励我们开始向上游做贡献，
并鼓励我加入发布团队。他只是说，这是个很好的机会。这对我在早期就开始做贡献有很大的帮助。</p><p><strong>CRAIG BOX：发布团队是你参与上游 Kubernetes 贡献的方式吗？</strong></p><p>REY LEJANO：实际上，没有。我的第一个贡献是 SIG Docs。我认识了 Taylor Dolezal——他是 1.19 的发布团队负责人，但他也参与了 SIG Docs。
我在 KubeCon 2019 遇到了他，在午餐时我坐在他的桌子旁。我记得 Paris Pittman 在万豪酒店主持了这次午餐会。
Taylor 说他参与了 SIG Docs。他鼓励我加入。我开始参加会议，开始做一些路过式的 PR。
这就是我们所说的 - 驱动式 - 小错字修复。然后做更多的事情，开始发送更好或更高质量的拉取请求，并审查 PR。</p><p><strong>CRAIG BOX：你第一次正式担任发布团队的角色是什么时候？</strong></p><p>REY LEJANO：那是在 12月的 <a href=https://github.com/kubernetes/sig-release/blob/master/releases/release-1.18/release_team.md>1.18</a>。
当时我的老板鼓励我去申请。我申请了，很幸运地被录取了，成为发布说明的影子。然后从那里开始，我在发布说明中呆了几个周期，
然后去了文档，自然而然地领导了文档，然后去了增强版，现在我是 1.23 的发行负责人。</p><p><strong>CRAIG BOX：我不知道很多人都会考虑到一个好的发行说明需要什么。你说什么才是呢？</strong></p><p>REY LEJANO：[笑]你必须告诉最终用户发生了什么变化，或者他们在发行说明中可能看到什么效果。
它不必是高度技术性的。它可以只是几行字，只是说有什么变化，如果他们也必须做任何事情，他们必须做什么。</p><p><strong>CRAIG BOX：我不知道很多人会考虑一个好的发布说明的内容。你会说什么？</strong></p><p>REY LEJANO：当我是这个周期的发布负责人时，我说过几次。你从发布团队得到的东西和你投入的东西一样多，或者说它直接与你投入的东西相一致。
我学到了很多东西。我在进入发布团队时就有这样的心态：向角色领导学习，也向其他影子学习。
这实际上是我的第一个角色负责人告诉我的一句话。我仍然铭记于心，那是在 1.18 中。那是 Eddie，在我们第一次见面时，我仍然牢记在心。</p><p><strong>CRAIG BOX：当然，你是 <a href=https://github.com/kubernetes/sig-release/tree/master/releases/release-1.23>1.23 的发布负责人</a>。首先，祝贺发布。</strong></p><p>REY LEJANO：非常感谢。</p><p><strong>CRAIG BOX：这个版本的主题是<a href=https://kubernetes.io/blog/2021/12/07/kubernetes-1-23-release-announcement/>最后战线</a>。
请告诉我我们是如何确定主题和标志的故事。</strong></p><p>REY LEJANO：最后战线代表了几件事。它不仅代表了此版本的下一个增强功能，而且 Kubernetes 本身也有《星际迷航》的参考历史。
Kubernetes 的原始代号是 Project Seven，指的是最初来自《星际迷航》中的 Seven of Nine。
在 Kubernetes 的 logo 中掌舵的七根辐条也是如此。当然，还有 Kubernetes 的前身 Borg。</p><p>最后战线继续星际迷航参考。这是星际迷航宇宙中两个标题的融合。一个是<a href=https://en.wikipedia.org/wiki/Star_Trek_V:_The_Final_Frontier>星际迷航 5：最后战线</a>，还有星际迷航：下一代。</p><p><strong>CRAIG BOX：你对《星际迷航 5》是一部奇数电影有什么看法，而且它们<a href=https://screenrant.com/star-trek-movies-odd-number-curse-explained/>通常被称为比偶数电影票房少</a>？</strong></p><p>REY LEJANO：我不能说，因为我是一个科幻书呆子，我喜欢他们所有的人，尽管他们很糟糕。即使是《下一代》系列之后的电影，我仍然喜欢所有的电影，尽管我知道有些并不那么好。</p><p><strong>CRAIG BOX：我记得星际迷航 5 是由 William Shatner 执导对吗？</strong></p><p>REY LEJANO：是的，对的。</p><p><strong>CRAIG BOX：我认为这说明了一切。</strong></p><p>REY LEJANO：[笑]是的。</p><p><strong>CRAIG BOX：现在，我明白了，主题来自于 <a href=https://github.com/kubernetes/community/blob/master/sig-release/charter.md>SIG 发布章程</a>？</strong></p><p>REY LEJANO：是的。SIG 发布章程中有一句话，“确保有一个一致的社区成员小组来支持不同时期的发布过程。”
在发布团队中，我们每一个发布周期都有新的影子加入。有了这个，我们与这个社区一起成长。我们正在壮大发布团队的成员。
我们正在增加 SIG 版本。我们正在发展 Kubernetes 社区本身。对于很多人来说，这是他们第一次为开源做出贡献，所以我说这是他们新的开源前沿。</p><p><strong>CRAIG BOX：而这个标志显然是受《星际迷航》的启发。让我感到惊讶的是，花了那么长时间才有人走这条路</strong></p><p>REY LEJANO：我也很惊讶。我不得不重新学习 Adobe Illustrator 来创建标志。</p><p><strong>CRAIG BOX：这是你自己的作品，是吗？</strong></p><p>REY LEJANO：这是我自己的作品。</p><p><strong>CRAIG BOX：非常好。</strong></p><p>REY LEJANO：谢谢。有趣的是，相对于飞船，银河系实际上花了我最长的时间。我花了几天时间才把它弄正确。
我一直在对它进行微调，所以在真正发布时可能会有最后的改变。</p><p><strong>CRAIG BOX：没有边界是真正的终结。</strong></p><p>REY LEJANO：是的，非常正确。</p><p><strong>CRAIG BOX：现在从发布的主题转到实质内容，也许，1.23 中有什么新内容？</strong></p><p>REY LEJANO：我们有 47 项增强功能。我将运行大部分稳定的，甚至全部的，一些关键的 Beta 版，以及一些 1.23 版的 Alpha 增强。</p><p>其中一个关键的改进是<a href=https://github.com/kubernetes/enhancements/issues/563>双堆栈 IPv4/IPv6</a>，它在 1.23 版本中采用了 GA。</p><p>一些背景信息：双堆栈在 1.15 中作为 Alpha 引入。你可能在 KubeCon 2019 上看到了一个主题演讲。
那时，双栈的工作方式是，你需要两个服务--你需要每个IP家族的服务。你需要一个用于 IPv4 的服务和一个用于 IPv6 的服务。
它在 1.20 版本中被重构了。在 1.21 版本中，它处于测试阶段；默认情况下，集群被启用为双堆栈。</p><p>然后在 1.23 版本中，我们确实删除了 IPv6 双栈功能标志。这不是强制性的使用双栈。它实际上仍然不是 "默认"的。
Pod，服务仍然默认为单栈。要使用双栈，有一些要求。节点必须可以在 IPv4 和 IPv6 网络接口上进行路由。
你需要一个支持双栈的 CNI 插件。Pod 本身必须被配置为双栈。而服务需要 ipFamilyPolicy 字段来指定喜欢双栈或要求双栈。</p><p><strong>CRAIG BOX：这听起来暗示仍然需要 v4。你是否看到了一个我们实际上可以转移到仅有 v6 的集群的世界？？</strong></p><p>REY LEJANO：我认为在未来很多很多年里，我们都会谈论 IPv4 和 IPv6。我记得很久以前，他们一直在说 "这将全部是 IPv6"，而那是几十年前的事了。</p><p><strong>CRAIG BOX：我想我之前可能在节目中提到过，Vint Cerf <a href="https://www.youtube.com/watch?v=AEaJtZVimqs">在伦敦参加了一个会议</a>，
他当时做了一个公开演讲说，现在是v6的时代了。那是至少 10 年前的事了。现在还不是 v6 的时代，我的电脑桌面上还没有一天拥有 Linux。</strong></p><p>REY LEJANO：[笑]在我看来，这是 1.23 版稳定的一大关键功能。</p><p>1.23 版的另一个亮点是 <a href=/blog/2021/12/09/pod-security-admission-beta/>Pod 安全许可进入 Beta 版</a>。
我知道这个功能将进入 Beta 版，但我强调这一点是因为有些人可能知道，PodSecurityPolicy 在 1.21 版本中被废弃，目标是在 1.25 版本中被移除。
Pod 安全接纳取代了 Pod 安全策略。它是一个准入控制器。它根据预定义的 Pod 安全标准集对 Pod 进行评估，以接纳或拒绝 Pod 的运行。</p><p>Pod 安全标准分为三个级别。特权，这是完全开放的。基线，已知的特权升级被最小化。或者 限制级，这是强化的。而且你可以将 Pod 安全标准设置为以三种模式运行，
即强制：拒绝任何违规的 Pod；审计：允许创建 Pod，但记录违规行为；或警告：它会向用户发送警告消息，并且允许该 Pod。</p><p><strong>CRAIG BOX：你提到 PodSecurityPolicy 将在两个版本的时间内被弃用。我们是否对这些功能进行了排列，以便届时 Pod 安全接纳将成为 GA？</strong></p><p>REY LEJANO：是的。当然可以。我稍后也会为另一个功能谈谈这个问题。还有另一个功能也进入了 GA。这是一个归入 GA 的 API，
因此 Beta 版的 API 现在被废弃了。我稍稍讲一下这个问题。</p><p><strong>CRAIG BOX：好吧。让我们来谈谈名单上的下一个问题。</strong></p><p>REY LEJANO：让我们继续讨论更稳定的增强功能。一种是 <a href=https://github.com/kubernetes/enhancements/issues/592>TTL 控制器</a>。
它在作业完成后清理作业和 Pod。有一个 TTL 计时器在作业或 Pod 完成后开始计时。此 TTL 控制器监视所有作业，
并且需要设置 ttlSecondsAfterFinished。该控制器将查看 ttlSecondsAfterFinished，结合最后的过渡时间，如果它大于现在。
如果是，那么它将删除该作业和该作业的 Pod。</p><p><strong>CRAIG BOX：粗略地说，它可以称为垃圾收集器吗？</strong></p><p>REY LEJANO：是的。用于 Pod 和作业，或作业和 Pod 的垃圾收集器。</p><p><strong>CRAIG BOX：如果 Kubernetes 真正成为一种编程语言，它当然必须实现垃圾收集器。</strong></p><p>REY LEJANO：是的。还有另一个，也将在 Alpha 中出现。[笑]</p><p><strong>CRAIG BOX：告诉我。</strong></p><p>REY LEJANO： 那个是在 Alpha 中出现的。这实际上是我最喜欢的功能之一，今天我只想强调几个。
<a href=https://github.com/kubernetes/enhancements/issues/1847>StafeulSet 的 PVC 将被清理</a>。
当你删除那个 StatefulSet 时，它将自动删除由 StatefulSets 创建的 PVC。</p><p><strong>CRAIG BOX：我们的稳定功能之旅的下一步是什么？</strong></p><p>REY LEJANO：下一个是，<a href=https://github.com/kubernetes/enhancements/issues/695>跳过卷所有权更改进入稳定状态</a>。
这是来自 SIG 存储。有的时候，当你运行一个有状态的应用程序时，就像许多数据库一样，它们对下面的权限位变化很敏感。
目前，当一个卷被绑定安装在容器内时，该卷的权限将递归更改。这可能需要很长时间。
--></p><p>现在，有一个字段，即 fsGroupChangePolicy，它允许你作为用户告诉 Kubernetes 你希望如何更改该卷的权限和所有权。
你可以将其设置为总是、始终更改权限，或者只是在不匹配的情况下，只在顶层的权限所有权变化与预期不同的情况下进行。</p><p><strong>CRAIG BOX：确实感觉很多这些增强功能都来自一个非常特殊的用例，有人说，“嘿，这对我来说不起作用，我已经研究了一个功能，它可以完全满足我需要的东西”</strong></p><p>REY LEJANO：当然可以。人们为这些问题创建问题，然后创建 Kubernetes 增强提案，然后被列为发布目标。</p><p><strong>CRAIG BOX：此版本中的另一个 GA 功能--临时卷。</strong></p><p>REY LEJANO：我们一直能够将空目录用于临时卷，但现在我们实际上可以拥有[临时内联卷] (<a href=https://github.com/kubernetes/enhancements/issues/1698>https://github.com/kubernetes/enhancements/issues/1698</a>)，
这意味着你可以使用标准 CSI 驱动程序并能够与它一起使用临时卷。</p><p><strong>CRAIG BOX：而且，很长一段时间，<a href=https://github.com/kubernetes/enhancements/issues/19>CronJobs</a>。</strong></p><p>REY LEJANO：CronJobs 很有趣，因为它在 1.23 之前是稳定的。对于 1.23，它仍然被跟踪，但它只是清理了一些旧控制器。
使用 CronJobs，有一个 v2 控制器。1.23 中清理的只是旧的 v1 控制器。</p><p><strong>CRAIG BOX：在这个版本中，是否有任何其他的重复或重大的清理工作值得注意？</strong></p><p>REY LEJANO：是的。有几个你可能会在主要的主题中看到。其中一个有点棘手，围绕 FlexVolumes。这是 SIG 存储公司的努力之一。
他们正在努力将树内插件迁移到 CSI 驱动。这有点棘手，因为 FlexVolumes 实际上是在 2020 年 11 月被废弃的。我们
<a href=https://github.com/kubernetes/community/blob/master/sig-storage/volume-plugin-faq.md#kubernetes-volume-plugin-faq-for-storage-vendors>在 1.23 中正式宣布</a>。</p><p><strong>CRAIG BOX：在我看来，FlexVolumes 比 CSI 这个概念还要早。所以现在是时候摆脱它们了。</strong></p><p>REY LEJANO：是的。还有另一个弃用，只是一些 <a href=https://kubernetes.io/docs/concepts/cluster-administration/system-logs/#klog>klog 特定标志</a>，但除此之外，1.23 中没有其他大的弃用。</p><p><strong>CRAIG BOX：上一届 KubeCon 的流行语，在某种程度上也是过去 12 个月的主题，是安全的软件供应链。Kubernetes 在这一领域做了哪些改进工作？</strong></p><p>REY LEJANO：对于 1.23 版本，Kubernetes 现在符合 SLSA 的 1 级标准，这意味着描述发布过程中分期和发布阶段的证明文件对于 SLSA 框架来说是令人满意的。</p><p><strong>CRAIG BOX：需要做什么才能提升到更高的水平？</strong></p><p>REY LEJANO：级别 1 意味着一些事情——构建是脚本化的；出处是可用的，这意味着工件是经过验证，并且已从一个阶段移交到下一个阶段；
并描述了工件是如何产生的。级别 2 意味着源是受版本控制的，也就是说，源是经过身份验证的，源是服务生成的，并且存在构建服务。SLSA 的合规性分为四个级别。</p><p><strong>CRAIG BOX：看起来这些水平在很大程度上受到了建立这样一个大型安全项目的影响。例如，似乎不需要很多额外的工作来提升到可验证的出处。
可能只需要几行脚本即可满足其中许多要求。</strong></p><p>REY LEJANO：当然。我觉得我们就快成功了；我们会看到 1.24 版本会出现什么。我确实想对 SIG 发布和发布工程部大加赞赏，
主要是 Adolfo García Veytia，他在 GitHub 和 Slack 上又名 Puerco。 他一直在推动这一进程。</p><p><strong>CRAIG BOX：你提到了一些 API 正在及时升级以替换其已弃用的版本。告诉我有关新 HPA API 的信息。</strong></p><p>REY LEJANO：<a href=https://github.com/kubernetes/enhancements/issues/2702>horizontal pod autoscaler v2 API</a>，
现已稳定，这意味着 v2beta2 API 已弃用。众所周知，v1 API 并未被弃用。不同之处在于 v2 添加了对用于 HPA 的多个和自定义指标的支持。</p><p><strong>CRAIG BOX：现在还可以使用表达式语言验证我的 CRD。</strong></p><p>REY LEJANO：是的。你可以使用 <a href=https://github.com/google/cel-spec>通用表达式语言，或 CEL</a>
来验证你的 CRD，因此你不再需要使用 webhook。这也使 CRD 更加自包含和声明性，因为规则现在保存在 CRD 对象定义中。</p><p><strong>CRAIG BOX：哪些新功能（可能是 Alpha 版或 Beta 版）引起了你的兴趣？</strong></p><p>REY LEJANO：除了 Pod 安全策略，我真的很喜欢支持 kubectl 调试的<a href=https://github.com/kubernetes/enhancements/issues/277>临时容器</a>。
它启动一个临时容器和一个正在运行的 Pod，共享这些 Pod 命名空间，你只需运行 kubectl debug 即可完成所有故障排除。</p><p><strong>CRAIG BOX：使用 kubectl 处理事件的方式也发生了一些有趣的变化。</strong></p><p>REY LEJANO：是的。kubectl events 总是有一些问题，比如事情没有排序。
<a href=https://github.com/kubernetes/enhancements/issues/1440>kubectl 事件得到了改进</a>，
所以现在你可以使用 <code>--watch</code>，它也可以使用 <code>--watch</code> 选项进行排序。那是新事物。
你实际上可以组合字段和自定义列。此外，你可以在时间线中列出最后 N 分钟的事件。你还可以使用其他标准对事件进行排序。</p><p><strong>CRAIG BOX：你是 SUSE 的一名现场工程师。有什么事情是你所处理的个别客户所要注意的吗？</strong></p><p>REY LEJANO：更多我期待帮助客户的东西。</p><p><strong>CRAIG BOX：好吧。</strong></p><p>REY LEJANO：我真的很喜欢 kubectl 事件。真的很喜欢用 StatefulSets 清理的 PVC。其中大部分是出于自私的原因，它将改进故障排除工作。[笑]</p><p><strong>CRAIG BOX：我一直希望发布团队负责人对我说：“是的，我有自私的理由。我终于得到了我想要的东西。”</strong></p><p>REY LEJANO：[大笑]</p><p><strong>CRAIG BOX：也许我应该竞选发布团队的负责人，这样我就可以最终让 Init 容器一劳永逸地得到修复。</strong></p><p>REY LEJANO：哦，Init 容器，我一直在寻找它。实际上，我已经制作了 GIF 动画，介绍了 Init 容器将如何与那个 Kubernetes 增强提案一起运行，但目前已经停止了。</p><p><strong>CRAIG BOX：有一天。</strong></p><p>REY LEJANO：总有一天。也许我不应该停下来。</p><p><strong>CRAIG BOX：你提到的显然是你所关注的事情。是否有任何即将推出的东西，可能是 Alpha 功能，甚至可能只是你最近看到的建议，你个人真的很期待看到它们的发展方向？</strong></p><p>REY LEJANO：是的。Oone 是一个非常有趣的问题，它影响了整个社区，所以这不仅仅是出于个人原因。
正如你可能已经知道的，Dockershim 已经被废弃了。而且我们确实发布了一篇博客，说它将在 1.24 中被删除。</p><p><strong>CRAIG BOX：吓坏了一群人。</strong></p><p>REY LEJANO：吓坏了一群人。从一项调查中，我们看到很多人仍在使用 Docker 和 Dockershim。
1.23 的增强功能之一是 <a href=https://github.com/kubernetes/enhancements/issues/2040>kubelet CRI 进入 Beta 版</a>。
这促进了 CRI API 的发展，而这是必需的。 这必须是 Beta 版才能在 1.24 中删除 Dockershim。</p><p>**CRAIG BOX：现在，在最后一次发布团队领导访谈中，<a href=https://kubernetespodcast.com/episode/157-kubernetes-1.22/>我们与 Savitha Raghunathan 进行了交谈</a>，
她谈到了作为她的继任者她会给你什么建议。她说要关注团队成员的心理健康。你是如何采纳这个建议的？</p><p>REY LEJANO：Savitha 的建议很好。我在每次发布团队会议上都记录了一些事情。
每次发布团队会议后，我都会停止录制，因为我们确实会录制所有会议并将其发布到 YouTube 上。
我向任何想要说任何未记录的内容的人开放发言，这不会出现在议程上。此外，我告诉人们不要在周末工作。
我曾经打破过这个规则，但除此之外，我告诉人们它可以等待。只要注意你的心理健康。</p><p><strong>CRAIG BOX：刚刚宣布<a href=https://twitter.com/JamesLaverack/status/1466834312993644551>来自 Jetstack 的 James Laverack</a>
将成为 1.24 的发布团队负责人。James 和我在 San Diego 的最后一届 KubeCon 上分享了一顿有趣的墨西哥晚餐。</strong></p><p>REY LEJANO：哦，不错。我不知道你认识 James。</p><p><strong>CRAIG BOX：英国科技界。我们是一个非常小的世界。你对 James 的建议是什么？</strong></p><p>REY LEJANO：对于 1.24，我要告诉 James 的是在发布团队会议中使用教学时刻。当你第一次成为影子时，这是非常令人生畏的。
这非常困难，因为你不知道存储库。你不知道发布过程。周围的每个人似乎都知道发布过程，并且非常熟悉发布过程是什么。
但作为第一次出现的影子，你并不了解社区的所有白话。我只是建议使用教学时刻。在发布团队会议上花几分钟时间，让新影子更容易上手并熟悉发布过程。</p><p><strong>CRAIG BOX：在你参与的这段时间里，这个过程是否有重大演变？或者你认为它正在有效地做它需要做的事情？</strong></p><p>REY LEJANO：它总是在不断发展。我记得我第一次做发布说明时，1.18，我们说我们的目标是自动化和编程，这样我们就不再有发行说明团队了。
这改变了很多[笑]。尽管 Adolfo 和 James 在发布说明过程中取得了重大进展，但他们在 krel 中创建了一个子命令来生成发行说明。</p><p>但如今，他们所有的发行说明都更加丰富了。在自动化过程中，仍然没有达到。每个发布周期，都有一点不同的东西。
对于这个发布周期，我们有一个生产就绪审查截止日期。这是一个软期限。生产就绪审查是社区中几个人的审查。
实际上从 1.21 开始就需要它，它确保增强是可观察的、可扩展的、可支持的，并且在生产中运行是安全的，也可以被禁用或回滚。
在 1.23 中，我们有一个截止日期，要求在特定日期之前完成生产就绪审查。</p><p><strong>CRAIG BOX：你如何发现每年发布三个版本，而不是四个版本？</strong></p><p>REY LEJANO：从一年四个版本转为三个版本，在我看来是一种进步，因为我们支持最后三个版本，
现在我们实际上可以支持在一个日历年内的最后一个版本，而不是在 12 个月中只有 9 个月。</p><p><strong>CRAIG BOX：日历上的下一个活动是下周一开始的 <a href=https://www.kubernetes.dev/events/kcc2021/>Kubernetes 贡献者庆典</a>。我们可以从活动中期待什么？</strong></p><p>REY LEJANO：这是我们第二次举办这个虚拟活动。这是一个虚拟的庆祝活动，以表彰整个社区和我们今年的所有成就，以及贡献者。
在这周的庆典中有许多活动。它从 12 月 13 日的那一周开始。</p><p>有像 Kubernetes 贡献者奖这样的活动，SIG 对社区和贡献者的辛勤工作进行表彰和奖励。
也有一个 DevOps 聚会游戏。还有一个云原生的烘烤活动。我强烈建议人们去
<a href=https://www.kubernetes.dev/events/past-events/2021/kcc2021/>kubernetes.dev/celebration</a>
了解更多。</p><p><strong>CRAIG BOX： 究竟如何评判一个虚拟的烘焙比赛呢？</strong></p><p>REY LEJANO：那我不知道。[笑]</p><p><strong>CRAIG BOX：我尝了尝我的烤饼。我认为他们是最好的。我给他们打了 10 分（满分 10 分）。</strong></p><p>REY LEJANO：是的。这是很难做到的。我不得不说，这道菜可能是什么，它与 Kubernetes 或开源或与 CNCF 的关系有多密切。
有几个评委。我知道 Josh Berkus 和 Rin Oliver 是主持烘焙比赛的几个评委。</p><p><strong>CRAIG BOX：是的。我们与 Josh 谈到了他对厨房的热爱，因此他似乎非常适合这个角色。</strong></p><p>REY LEJANO：他是。</p><p><strong>CRAIG BOX：最后，你的妻子和你自己将在一月份迎来你们的第一个孩子。你是否为此进行过生产准备审查？</strong></p><p>REY LEJANO：我认为我们没有通过审查。[笑]</p><p><strong>CRAIG BOX：还有时间。</strong></p><p>REY LEJANO：我们正在努力重构。我们将在 12 月进行一些重构，然后再次使用 <code>--apply</code>。</p><hr><p><strong><a href=https://twitter.com/reylejano>Rey Lejano</a> 是 SUSE 的一名现场工程师，来自 Rancher Labs，并且是 Kubernetes 1.23 的发布团队负责人。
他现在也是 SIG Docs 的联合主席。他的儿子 Liam 现在 3 个半月大。</strong></p><p><strong>你可以在 Twitter 上的 <a href=https://twitter.com/KubernetesPod>@KubernetesPod</a>
找到<a href=http://www.kubernetespodcast.com/>来自谷歌的 Kubernetes 播客</a>，
你也可以<a href=https://kubernetespodcast.com/subscribe/>订阅</a>，这样你就不会错过任何一集。</strong></p></div><div class=td-content style=page-break-before:always><h1 id=pg-b89c2306f286f40e6771c44ce8ab6264>在 Ingress-NGINX v1.2.0 中提高安全标准</h1><div class="td-byline mb-4"><time datetime=2022-04-28 class=text-muted>2022.04.28</time></div><p><strong>作者：</strong> Ricardo Katz (VMware), James Strong (Chainguard)</p><p><a href=/zh-cn/docs/concepts/services-networking/ingress/>Ingress</a> 可能是 Kubernetes 最容易受攻击的组件之一。
Ingress 通常定义一个 HTTP 反向代理，暴露在互联网上，包含多个网站，并具有对 Kubernetes API
的一些特权访问（例如读取与 TLS 证书及其私钥相关的 Secret）。</p><p>虽然它是架构中的一个风险组件，但它仍然是正常公开服务的最流行方式。</p><p>Ingress-NGINX 一直是安全评估的重头戏，这类评估会发现我们有着很大的问题：
在将配置转换为 <code>nginx.conf</code> 文件之前，我们没有进行所有适当的清理，这可能会导致信息泄露风险。</p><p>虽然我们了解此风险以及解决此问题的真正需求，但这并不是一个容易的过程，
因此我们在当前(v1.2.0)版本中采取了另一种方法来减少（但不是消除！）这种风险。</p><h2 id=了解-ingress-nginx-v1-2-0-和-chrooted-nginx-进程>了解 Ingress NGINX v1.2.0 和 chrooted NGINX 进程</h2><p>主要挑战之一是 Ingress-NGINX 运行着 Web 代理服务器（NGINX），并与 Ingress 控制器一起运行
（后者是一个可以访问 Kubernetes API 并创建 <code>nginx.conf</code> 的组件）。</p><p>因此，NGINX 对控制器的文件系统（和 Kubernetes 服务帐户令牌，以及容器中的其他配置）具有相同的访问权限。
虽然拆分这些组件是我们的最终目标，但该项目需要快速响应；这让我们想到了使用 <code>chroot()</code>。</p><p>让我们看一下 Ingress-NGINX 容器在此更改之前的样子：</p><p><img src=ingress-pre-chroot.png alt="Ingress NGINX pre chroot"></p><p>正如我们所见，用来提供 HTTP Proxy 的容器（不是 Pod，是容器！）也是是监视 Ingress
对象并将数据写入容器卷的容器。</p><p>现在，见识一下新架构：</p><p><img src=ingress-post-chroot.png alt="Ingress NGINX post chroot"></p><p>这一切意味着什么？一个基本的总结是：我们将 NGINX 服务隔离为控制器容器内的容器。</p><p>虽然这并不完全正确，但要了解这里所做的事情，最好了解 Linux 容器（以及内核命名空间等底层机制）是如何工作的。
你可以在 Kubernetes 词汇表中阅读有关 cgroup 的信息：<a href="/zh-cn/docs/reference/glossary/?fundamental=true#term-cgroup"><code>cgroup</code></a>，
并在 NGINX 项目文章<a href=https://www.nginx.com/blog/what-are-namespaces-cgroups-how-do-they-work/>什么是命名空间和 cgroup，以及它们如何工作？</a>
中了解有关 cgroup 与命名空间交互的更多信息。（当你阅读时，请记住 Linux 内核命名空间与
<a href=/zh-cn/docs/concepts/overview/working-with-objects/namespaces/>Kubernetes 命名空间</a>不同）。</p><h2 id=跳过谈话-我需要什么才能使用这种新方法>跳过谈话，我需要什么才能使用这种新方法？</h2><p>虽然这增加了安全性，但我们在这个版本中把这个功能作为一个选项，这样你就可以有时间在你的环境中做出正确的调整。
此新功能仅在 Ingress-NGINX 控制器的 v1.2.0 版本中可用。</p><p>要使用这个功能，在你的部署中有两个必要的改变：</p><ul><li>将后缀 "-chroot" 添加到容器镜像名称中。例如：<code>gcr.io/k8s-staging-ingress-nginx/controller-chroot:v1.2.0</code></li><li>在你的 Ingress 控制器的 Pod 模板中，找到添加 <code>NET_BIND_SERVICE</code> 权能的位置并添加 <code>SYS_CHROOT</code> 权能。
编辑清单后，你将看到如下代码段：</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>capabilities</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>drop</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- ALL<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>add</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- NET_BIND_SERVICE<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- SYS_CHROOT<span style=color:#bbb>
</span></span></span></code></pre></div><p>如果你使用官方 Helm Chart 部署控制器，则在 <code>values.yaml</code> 中更改以下设置：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>controller</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>chroot</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Ingress 控制器通常部署在集群作用域（IngressClass API 是集群作用域的）。
如果你管理 Ingress-NGINX 控制器但你不是整个集群的操作员，
请在部署中启用它<strong>之前</strong>与集群管理员确认你是否可以使用 <code>SYS_CHROOT</code> 功能。</p><h2 id=好吧-但这如何能提高我的-ingress-控制器的安全性呢>好吧，但这如何能提高我的 Ingress 控制器的安全性呢？</h2><p>以下面的配置片段为例，想象一下，由于某种原因，它被添加到你的 <code>nginx.conf</code> 中：</p><pre tabindex=0><code>location /randomthing/ {
      alias /;
      autoindex on;
}
</code></pre><p>如果你部署了这种配置，有人可以调用 <code>http://website.example/randomthing</code> 并获取对 Ingress 控制器的整个文件系统的一些列表（和访问权限）。</p><p>现在，你能在下面的列表中发现 chroot 处理过和未经 chroot 处理过的 Nginx 之间的区别吗？</p><table><thead><tr><th>不额外调用 <code>chroot()</code></th><th>额外调用 <code>chroot()</code></th></tr></thead><tbody><tr><td><code>bin</code></td><td><code>bin</code></td></tr><tr><td><code>dev</code></td><td><code>dev</code></td></tr><tr><td><code>etc</code></td><td><code>etc</code></td></tr><tr><td><code>home</code></td><td></td></tr><tr><td><code>lib</code></td><td><code>lib</code></td></tr><tr><td><code>media</code></td><td></td></tr><tr><td><code>mnt</code></td><td></td></tr><tr><td><code>opt</code></td><td><code>opt</code></td></tr><tr><td><code>proc</code></td><td><code>proc</code></td></tr><tr><td><code>root</code></td><td></td></tr><tr><td><code>run</code></td><td><code>run</code></td></tr><tr><td><code>sbin</code></td><td></td></tr><tr><td><code>srv</code></td><td></td></tr><tr><td><code>sys</code></td><td></td></tr><tr><td><code>tmp</code></td><td><code>tmp</code></td></tr><tr><td><code>usr</code></td><td><code>usr</code></td></tr><tr><td><code>var</code></td><td><code>var</code></td></tr><tr><td><code>dbg</code></td><td></td></tr><tr><td><code>nginx-ingress-controller</code></td><td></td></tr><tr><td><code>wait-shutdown</code></td><td></td></tr></tbody></table><p>左侧的那个没有 chroot 处理。所以 NGINX 可以完全访问文件系统。右侧的那个经过 chroot 处理，
因此创建了一个新文件系统，其中只有使 NGINX 工作所需的文件。</p><h2 id=此版本中的其他安全改进如何>此版本中的其他安全改进如何？</h2><p>我们知道新的 <code>chroot()</code> 机制有助于解决部分风险，但仍然有人可以尝试注入命令来读取，例如 <code>nginx.conf</code> 文件并提取敏感信息。</p><p>所以，这个版本的另一个变化（可选择取消）是 <strong>深度探测（Deep Inspector）</strong>。
我们知道某些指令或正则表达式可能对 NGINX 造成危险，因此深度探测器会检查 Ingress 对象中的所有字段
（在其协调期间，并且还使用<a href=/zh-cn/docs/reference/access-authn-authz/admission-controllers/#validatingadmissionwebhook>验证准入 webhook</a>)
验证是否有任何字段包含这些危险指令。</p><p>Ingress 控制器已经通过注解做了这个工作，我们的目标是把现有的验证转移到深度探测中，作为未来版本的一部分。</p><p>你可以在 <a href=https://github.com/kubernetes/ingress-nginx/blob/main/internal/ingress/inspector/rules.go>https://github.com/kubernetes/ingress-nginx/blob/main/internal/ingress/inspector/rules.go</a> 中查看现有规则。</p><p>由于检查和匹配相关 Ingress 对象中的所有字符串的性质，此新功能可能会消耗更多 CPU。
你可以通过使用命令行参数 <code>--deep-inspect=false</code> 运行 Ingress 控制器来禁用它。</p><h2 id=下一步是什么>下一步是什么?</h2><p>这不是我们的最终目标。我们的最终目标是拆分控制平面和数据平面进程。
事实上，这样做也将帮助我们实现 <a href=https://gateway-api.sigs.k8s.io/>Gateway</a> API 实现，
因为一旦它“知道”要提供什么，我们可能会有不同的控制器 数据平面（我们需要一些帮助！！）</p><p>Kubernetes 中的其他一些项目已经采用了这种方法（如 <a href=https://github.com/kubernetes-sigs/kpng>KPNG</a>，
建议替换 <code>kube-proxy</code>），我们计划与他们保持一致，并为 Ingress-NGINX 获得相同的体验。</p><h2 id=延伸阅读>延伸阅读</h2><p>如果你想了解如何在 Ingress NGINX 中完成 chrooting，请查看
<a href=https://github.com/kubernetes/ingress-nginx/pull/8337>https://github.com/kubernetes/ingress-nginx/pull/8337</a>。
包含所有更改的版本 v1.2.0 可以在以下位置找到
<a href=https://github.com/kubernetes/ingress-nginx/releases/tag/controller-v1.2.0>https://github.com/kubernetes/ingress-nginx/releases/tag/controller-v1.2.0</a></p></div><div class=td-content style=page-break-before:always><h1 id=pg-5f94242fa4fe2e30e6eebfe3555070a2>Kubernetes 1.24 中的移除和弃用</h1><div class="td-byline mb-4"><time datetime=2022-04-07 class=text-muted>2022.04.07</time></div><p><strong>作者</strong>：Mickey Boxell (Oracle)</p><p>随着 Kubernetes 的发展，一些特性和 API 会被定期重检和移除。
新特性可能会提供替代或改进的方法，来解决现有的问题，从而激励团队移除旧的方法。</p><p>我们希望确保你了解 Kubernetes 1.24 版本的变化。该版本将 <strong>弃用</strong> 一些（测试版/beta）API，
转而支持相同 API 的稳定版本。Kubernetes 1.24
版本的主要变化是<a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-node/2221-remove-dockershim>移除 Dockershim</a>。
这将在下面讨论，并将在发布时更深入地探讨。
要提前了解 Kubernetes 1.24 中的更改，请查看正在更新中的
<a href=https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG/CHANGELOG-1.24.md>CHANGELOG</a>。</p><h2 id=a-note-about-dockershim>关于 Dockershim</h2><p>可以肯定地说，随着 Kubernetes 1.24 的发布，最受关注的是移除 Dockershim。
Dockershim 在 1.20 版本中已被弃用。如
<a href=https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG/CHANGELOG-1.20.md#deprecation>Kubernetes 1.20 变更日志</a>中所述：
"Docker support in the kubelet is now deprecated and will be removed in a future release. The kubelet
uses a module called "dockershim" which implements CRI support for Docker and it has seen maintenance
issues in the Kubernetes community."
随着即将发布的 Kubernetes 1.24，Dockershim 将最终被移除。</p><p>在文章<a href=/zh-cn/blog/2020/12/02/dont-panic-kubernetes-and-docker/>别慌: Kubernetes 和 Docker</a> 中，
作者简洁地记述了变化的影响，并鼓励用户保持冷静：</p><blockquote><p>弃用 Docker 这个底层运行时，转而支持符合为 Kubernetes 创建的容器运行接口
Container Runtime Interface (CRI) 的运行时。
Docker 构建的镜像，将在你的集群的所有运行时中继续工作，一如既往。</p></blockquote><p>已经有一些文档指南，提供了关于从 dockershim 迁移到与 Kubernetes 直接兼容的容器运行时的有用信息。
你可以在 Kubernetes 文档中的<a href=/zh-cn/docs/tasks/administer-cluster/migrating-from-dockershim/>从 dockershim 迁移</a>
页面上找到它们。</p><p>有关 Kubernetes 为何不再使用 dockershim 的更多信息，
请参见：<a href=/zh-cn/blog/2022/01/07/kubernetes-is-moving-on-from-dockershim/>Kubernetes 即将移除 Dockershim</a>
和<a href=/zh-cn/blog/2022/02/17/dockershim-faq/>最新的弃用 Dockershim 的常见问题</a>。</p><p>查看<a href=/zh-cn/blog/2022/03/31/ready-for-dockershim-removal/>你的集群准备好使用 v1.24 版本了吗？</a> 一文，
了解如何确保你的集群在从 1.23 版本升级到 1.24 版本后继续工作。</p><h2 id=the-Kubernetes-api-removal-and-deprecation-process>Kubernetes API 移除和弃用流程</h2><p>Kubernetes 包含大量随时间演变的组件。在某些情况下，这种演变会导致 API、标志或整个特性被移除。
为了防止用户面对重大变化，Kubernetes 贡献者采用了一项特性<a href=/zh-cn/docs/reference/using-api/deprecation-policy/>弃用策略</a>。
此策略确保仅当同一 API 的较新稳定版本可用并且
API 具有以下稳定性级别所指示的最短生命周期时，才可能弃用稳定版本 API：</p><ul><li>正式发布 (GA) 或稳定的 API 版本可能被标记为已弃用，但不得在 Kubernetes 的主版本中移除。</li><li>测试版（beta）或预发布 API 版本在弃用后必须支持 3 个版本。</li><li>Alpha 或实验性 API 版本可能会在任何版本中被移除，恕不另行通知。</li></ul><p>移除遵循相同的弃用政策，无论 API 是由于 测试版（beta）功能逐渐稳定还是因为该
API 未被证明是成功的而被移除。
Kubernetes 将继续确保在移除 API 时提供用来迁移的文档。</p><p><strong>弃用的</strong> API 是指那些已标记为在未来 Kubernetes 版本中移除的 API。
<strong>移除的</strong> API 是指那些在被弃用后不再可用于当前受支持的 Kubernetes 版本的 API。
这些移除的 API 已被更新的、稳定的/普遍可用的 (GA) API 所取代。</p><h2 id=api-removals-deprecations-and-other-changes-for-kubernetes-1.24>Kubernetes 1.24 的 API 移除、弃用和其他更改</h2><ul><li><a href=https://github.com/kubernetes/enhancements/issues/281>动态 kubelet 配置</a>: <code>DynamicKubeletConfig</code>
用于启用 kubelet 的动态配置。Kubernetes 1.22 中弃用 <code>DynamicKubeletConfig</code> 标志。
在 1.24 版本中，此特性门控将从 kubelet 中移除。请参阅<a href=/zh-cn/docs/tasks/administer-cluster/reconfigure-kubelet/>重新配置 kubelet</a>。
更多详细信息，请参阅<a href=https://github.com/kubernetes/enhancements/issues/281>“移除动态 kubelet 配置” 的 KEP</a>。</li></ul><ul><li><a href=https://github.com/kubernetes/kubernetes/pull/107207>动态日志清洗</a>：实验性的动态日志清洗功能已被弃用，
将在 1.24 版本中被移除。该功能引入了一个日志过滤器，可以应用于所有 Kubernetes 系统组件的日志，
以防止各种类型的敏感信息通过日志泄漏。有关更多信息和替代方法，请参阅
<a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-instrumentation/1753-logs-sanitization#deprecation>KEP-1753: Kubernetes 系统组件日志清洗</a>。</li></ul><ul><li><a href=https://github.com/kubernetes/enhancements/issues/2221>从 kubelet 中移除 Dockershim</a>：Docker
的容器运行时接口(CRI)（即 Dockershim）目前是 kubelet 代码中内置的容器运行时。它在 1.20 版本中已被弃用。
从 1.24 版本开始，kubelet 已经移除 dockershim。查看这篇博客，
<a href=/blog/2022/03/31/ready-for-dockershim-removal/>了解你需要为 1.24 版本做些什么</a>。</li></ul><ul><li><a href=https://github.com/kubernetes/enhancements/issues/1472>Pod 调度的存储容量追踪</a>：CSIStorageCapacity API
支持通过 CSIStorageCapacity 对象暴露当前可用的存储容量，并增强了使用带有延迟绑定的 CSI 卷的 Pod 的调度。
CSIStorageCapacity API 自 1.24 版本起提供稳定版本。升级到稳定版的 API 将弃用 v1beta1 CSIStorageCapacity API。
更多信息请参见 <a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-storage/1472-storage-capacity-tracking>Pod 调度存储容量约束 KEP</a>。</li></ul><ul><li><a href=https://github.com/kubernetes/kubernetes/pull/107533>kubeadm 控制面节点上不再存在 <code>master</code> 标签</a>。
对于新集群，控制平面节点将不再添加 'node-role.kubernetes.io/master' 标签，
只会添加 'node-role.kubernetes.io/control-plane' 标签。更多信息请参考
<a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-cluster-lifecycle/kubeadm/2067-rename-master-label-taint>KEP-2067：重命名 kubeadm “master” 标签和污点</a>。</li></ul><ul><li><a href=https://github.com/kubernetes/enhancements/issues/177>VolumeSnapshot v1beta1 CRD 在 1.24 版本中将被移除</a>。
Kubernetes 和 <a href=https://github.com/container-storage-interface/spec/blob/master/spec.md>Container Storage Interface</a> (CSI)
的卷快照和恢复功能，在 1.20 版本中进入测试版。该功能提供标准化 API 设计 (CRD ) 并为 CSI 卷驱动程序添加了 PV 快照/恢复支持，
VolumeSnapshot v1beta1 在 1.21 版本中已被弃用，现在不受支持。更多信息请参考
<a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-storage/177-volume-snapshot#kep-177-csi-snapshot>KEP-177：CSI 快照</a>和
<a href=https://github.com/kubernetes-csi/external-snapshotter/releases/tag/v4.1.0>kubernetes-csi/external-snapshotter</a>。</li></ul><h2 id=what-to-do>需要做什么</h2><h3 id=dockershim-removal>移除 Dockershim</h3><p>如前所述，有一些关于从 <a href=/zh-cn/docs/tasks/administer-cluster/migrating-from-dockershim/>dockershim 迁移</a>的指南。
你可以<a href=/zh-cn/docs/tasks/administer-cluster/migrating-from-dockershim/find-out-runtime-you-use/>从查明节点上所使用的容器运行时</a>开始。
如果你的节点使用 dockershim，则还有其他可能的 Docker Engine 依赖项，
例如 Pod 或执行 Docker 命令的第三方工具或 Docker 配置文件中的私有镜像库。
你可以按照<a href=/zh-cn/docs/tasks/administer-cluster/migrating-from-dockershim/check-if-dockershim-removal-affects-you/>检查移除 Dockershim 是否对你有影响</a>
的指南来查看可能的 Docker 引擎依赖项。在升级到 1.24 版本之前，你决定要么继续使用 Docker Engine 并
<a href=/zh-cn/docs/tasks/administer-cluster/migrating-from-dockershim/migrate-dockershim-dockerd/>将 Docker Engine 节点从 dockershim 迁移到 cri-dockerd</a>，
要么迁移到与 CRI 兼容的运行时。这是<a href=/zh-cn/docs/tasks/administer-cluster/migrating-from-dockershim/change-runtime-containerd/>将节点上的容器运行时从 Docker Engine 更改为 containerd</a> 的指南。</p><h3 id=kubectl-convert><code>kubectl convert</code></h3><p>kubectl 的 <a href=/zh-cn/docs/tasks/tools/included/kubectl-convert-overview/><code>kubectl convert</code></a>
插件有助于解决弃用 API 的迁移问题。该插件方便了不同 API 版本之间清单的转换，
例如，从弃用的 API 版本到非弃用的 API 版本。
关于 API 迁移过程的更多信息可以在<a href=/zh-cn/docs/reference/using-api/deprecation-guide/>已弃用 API 的迁移指南</a>中找到。
按照<a href=/zh-cn/docs/tasks/tools/install-kubectl-linux/#install-kubectl-convert-plugin>安装 <code>kubectl convert</code> 插件</a>
文档下载并安装 <code>kubectl-convert</code> 二进制文件。</p><h3 id=looking-ahead>展望未来</h3><p>计划在今年晚些时候发布的 Kubernetes 1.25 和 1.26 版本，将停止提供一些
Kubernetes API 的 Beta 版本，这些 API 当前为稳定版。1.25 版本还将移除 PodSecurityPolicy，
它已在 Kubernetes 1.21 版本中被弃用，并且不会升级到稳定版。有关详细信息，请参阅
<a href=/blog/2021/04/06/podsecuritypolicy-deprecation-past-present-and-future/>PodSecurityPolicy 弃用：过去、现在和未来</a>。</p><p><a href=/zh-cn/docs/reference/using-api/deprecation-guide/#v1-25>Kubernetes 1.25 计划移除的 API 的官方列表</a>是：</p><ul><li>Beta CronJob API (batch/v1beta1)</li><li>Beta EndpointSlice API (discovery.k8s.io/v1beta1)</li><li>Beta Event API (events.k8s.io/v1beta1)</li><li>Beta HorizontalPodAutoscaler API (autoscaling/v2beta1)</li><li>Beta PodDisruptionBudget API (policy/v1beta1)</li><li>Beta PodSecurityPolicy API (policy/v1beta1)</li><li>Beta RuntimeClass API (node.k8s.io/v1beta1)</li></ul><p><a href=/zh-cn/docs/reference/using-api/deprecation-guide/#v1-26>Kubernetes 1.26 计划移除的 API 的官方列表</a>是：</p><ul><li>Beta FlowSchema 和 PriorityLevelConfiguration API (flowcontrol.apiserver.k8s.io/v1beta1)</li><li>Beta HorizontalPodAutoscaler API (autoscaling/v2beta2)</li></ul><h3 id=want-to-know-more>了解更多</h3><p>Kubernetes 发行说明中宣告了弃用信息。你可以在以下版本的发行说明中看到待弃用的公告：</p><ul><li><a href=https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG/CHANGELOG-1.21.md#deprecation>Kubernetes 1.21</a></li><li><a href=https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG/CHANGELOG-1.22.md#deprecation>Kubernetes 1.22</a></li><li><a href=https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG/CHANGELOG-1.23.md#deprecation>Kubernetes 1.23</a></li><li>我们将正式宣布 <a href=https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG/CHANGELOG-1.24.md#deprecation>Kubernetes 1.24</a> 的弃用信息，
作为该版本 CHANGELOG 的一部分。</li></ul><p>有关弃用和移除过程的信息，请查看 Kubernetes 官方<a href=/zh-cn/docs/reference/using-api/deprecation-policy/#deprecating-parts-of-the-api>弃用策略</a>文档。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-81f3d8301bdb049532c4ad2b4ec4ff6d>你的集群准备好使用 v1.24 版本了吗？</h1><div class="td-byline mb-4"><time datetime=2022-03-31 class=text-muted>2022.03.31</time></div><p><strong>作者:</strong> Kat Cosgrove</p><p>早在 2020 年 12 月，Kubernetes 就宣布<a href=/zh-cn/blog/2020/12/02/dont-panic-kubernetes-and-docker/>弃用 Dockershim</a>。
在 Kubernetes 中，dockershim 是一个软件 shim，
它允许你将整个 Docker 引擎用作 Kubernetes 中的容器运行时。
在即将发布的 v1.24 版本中，我们将移除 Dockershim -
在宣布弃用之后到彻底移除这段时间内，我们至少预留了一年的时间继续支持此功能，
这符合相关的<a href=/zh-cn/docs/reference/using-api/deprecation-policy/>项目策略</a>。
如果你是集群操作员，则该指南包含你在此版本中需要了解的实际情况。
另外还包括你需要做些什么来确保你的集群不会崩溃！</p><h2 id=首先-这对你有影响吗>首先，这对你有影响吗？</h2><p>如果你正在管理自己的集群或不确定此删除是否会影响到你，
请保持安全状态并<a href=/zh-cn/docs/tasks/administer-cluster/migrating-from-dockershim/check-if-dockershim-removal-affects-you/>检查你对 Docker Engine 是否有依赖</a>。
请注意，使用 Docker Desktop 构建应用程序容器并不算是集群对 Docker 有依赖。
Docker 创建的容器镜像符合 <a href=https://opencontainers.org/>Open Container Initiative (OCI)</a> 规范，
而 OCI 是 Linux 基金会的一种治理架构，负责围绕容器格式和运行时定义行业标准。
这些镜像可以在 Kubernetes 支持的任何容器运行时上正常工作。</p><p>如果你使用的是云服务提供商管理的 Kubernetes 服务，
并且你确定没有更改过容器运行时，那么你可能不需要做任何事情。
Amazon EKS、Azure AKS 和 Google GKE 现在都默认使用 containerd，
但如果你的集群中有任何自定义的节点，你要确保它们不需要被更新。
要检查节点的运行时，请参考<a href=/zh-cn/docs/tasks/administer-cluster/migrating-from-dockershim/find-out-runtime-you-use/>查明节点上所使用的容器运行时</a>。</p><p>无论你是在管理自己的集群还是使用云服务提供商管理的 Kubernetes 服务，
你可能都需要<a href=/zh-cn/docs/tasks/administer-cluster/migrating-from-dockershim/migrating-telemetry-and-security-agents/>迁移依赖 Docker Engine 的遥测或安全代理</a>。</p><h2 id=我对-docker-有依赖-现在该怎么办>我对 Docker 有依赖。现在该怎么办？</h2><p>如果你的 Kubernetes 集群对 Docker Engine 有依赖，
并且你打算升级到 Kubernetes v1.24 版本（出于安全和类似原因，你最终应该这样做），
你需要将容器运行时从 Docker Engine 更改为其他方式或使用 <a href=https://github.com/Mirantis/cri-dockerd>cri-dockerd</a>。
由于 <a href=https://containerd.io/>containerd</a> 是一个已经毕业的 CNCF 项目，
并且是 Docker 本身的运行时，因此用它作为容器运行时的替代方式是一个安全的选择。
幸运的是，Kubernetes 项目已经以 containerd 为例，
提供了<a href=/zh-cn/docs/tasks/administer-cluster/migrating-from-dockershim/change-runtime-containerd/>更改节点容器运行时</a>的过程文档。
切换到其它支持的运行时的操作指令与此类似。</p><h2 id=我想升级-kubernetes-并且我需要保持与-docker-作为运行时的兼容性-我有哪些选择>我想升级 Kubernetes，并且我需要保持与 Docker 作为运行时的兼容性。我有哪些选择？</h2><p>别担心，你不会被冷落，也不必冒着安全风险继续使用旧版本的 Kubernetes。
Mirantis 和 Docker 已经联合发布并正在维护 dockershim 的替代品。
这种替代品称为 <a href=https://github.com/Mirantis/cri-dockerd>cri-dockerd</a>。
如果你确实需要保持与 Docker 作为运行时的兼容性，请按照项目文档中的说明安装 cri-dockerd。</p><h2 id=这样就可以了吗>这样就可以了吗？</h2><p>是的。只要你深入了解此版本所做的变更和你自己集群的详细信息，
并确保与你的开发团队进行清晰的沟通，它的不确定性就会降到最低。
你可能需要对集群、应用程序代码或脚本进行一些更改，但所有这些要求都已经有说明指导。
从使用 Docker Engine 作为运行时，切换到使用<a href=/zh-cn/docs/setup/production-environment/container-runtimes/>其他任何一种支持的容器运行时</a>，
这意味着移除了中间层的组件，因为 dockershim 的作用是访问 Docker 本身使用的容器运行时。
从实际角度长远来看，这种移除对你和 Kubernetes 维护者都更有好处。</p><p>如果你仍有疑问，请先查看<a href=/zh-cn/blog/2022/02/17/dockershim-faq/>弃用 Dockershim 的常见问题</a>。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-f76def423bf5205897360a230eeaab4a>认识我们的贡献者 - 亚太地区（澳大利亚-新西兰地区）</h1><div class="td-byline mb-4"><time datetime=2022-03-16 class=text-muted>2022.03.16</time></div><p><strong>作者和采访者：</strong>
<a href=https://github.com/anubha-v-ardhan>Anubhav Vardhan</a>、
<a href=https://github.com/Atharva-Shinde>Atharva Shinde</a>、
<a href=https://github.com/AvineshTripathi>Avinesh Tripathi</a>、
<a href=https://github.com/bradmccoydev>Brad McCoy</a>、
<a href=https://github.com/Debanitrkl>Debabrata Panigrahi</a>、
<a href=https://github.com/jayesh-srivastava>Jayesh Srivastava</a>、
<a href=https://github.com/verma-kunal>Kunal Verma</a>、
<a href=https://github.com/PranshuSrivastava>Pranshu Srivastava</a>、
<a href=github.com/Priyankasaggu11929/>Priyanka Saggu</a>、
<a href=https://github.com/PurneswarPrasad>Purneswar Prasad</a>、
<a href=https://github.com/vedant-kakde>Vedant Kakde</a></p><hr><p>大家好👋</p><p>欢迎来到亚太地区的”认识我们的贡献者”博文系列第二期。</p><p>这篇文章将介绍来自澳大利亚和新西兰地区的四位杰出贡献者，
他们在上游 Kubernetes 项目中承担着不同子项目的领导者和社区贡献者的角色。</p><p>闲话少说，让我们直接进入主题。</p><h2 id=caleb-woodbine-https-github-com-bobymcbobs><a href=https://github.com/BobyMCbobs>Caleb Woodbine</a></h2><p>Caleb Woodbine 目前是 ii.nz 组织的成员。</p><p>他于 2018 年作为 Kubernetes Conformance 工作组的成员开始为 Kubernetes 项目做贡献。
他积极向上，他从一位来自新西兰的贡献者 <a href=https://github.com/hh>Hippie Hacker</a> 的早期指导中受益匪浅。</p><p>他在 <code>SIG k8s-infra</code> 和 <code>k8s-conformance</code> 工作组为 Kubernetes 项目做出了重大贡献。</p><p>Caleb 也是 <a href=https://www.meetup.com/cloudnative-nz/>CloudNative NZ</a>
社区活动的联合组织者，该活动旨在扩大 Kubernetes 项目在整个新西兰的影响力，以鼓励科技教育和改善就业机会。</p><blockquote><p>亚太地区需要更多的外联活动，教育工作者和大学必须学习 Kubernetes，因为他们非常缓慢，
而且已经落后了8年多。新西兰倾向于在海外付费，而不是教育当地人最新的云技术。</p></blockquote><h2 id=dylan-graham-https-github-com-dylangraham><a href=https://github.com/DylanGraham>Dylan Graham</a></h2><p>Dylan Graham 是来自澳大利亚 Adeliade 的云计算工程师。自 2018 年以来，他一直在为上游 Kubernetes 项目做出贡献。</p><p>他表示，成为如此大项目的一份子，最初压力是比较大的，但社区的友好和开放帮助他度过了难关。</p><p>开始在项目文档方面做贡献，现在主要致力于为亚太地区提供社区支持。</p><p>他相信，持续参加社区/项目会议，承担项目任务，并在需要时寻求社区指导，可以帮助有抱负的新开发人员成为有效的贡献者。</p><blockquote><p>成为大社区的一份子感觉真的很特别。我遇到了一些了不起的人，甚至是在现实生活中疫情发生之前。</p></blockquote><h2 id=hippie-hacker-https-github-com-hh><a href=https://github.com/hh>Hippie Hacker</a></h2><p>Hippie 来自新西兰，曾在 CNCF.io 作为战略计划承包商工作 5 年多。他是 k8s-infra、
API 一致性测试、云提供商一致性提交以及上游 Kubernetes 和 CNCF 项目 apisnoop.cncf.io 域的积极贡献者。</p><p>他讲述了他们早期参与 Kubernetes 项目的情况，该项目始于大约 5 年前，当时他们的公司 ii.nz
演示了<a href=https://ii.nz/post/bringing-the-cloud-to-your-community/>使用 PXE 从 Raspberry Pi 启动网络，并在集群中运行Gitlab，以便在服务器上安装 Kubernetes</a></p><p>他描述了自己的贡献经历：一开始，他试图独自完成所有艰巨的任务，但最终看到了团队协作贡献的好处，
分工合作减少了过度疲劳，这让人们能够凭借自己的动力继续前进。</p><p>他建议新的贡献者结对编程。</p><blockquote><p>针对一个项目，多人关注和交叉交流往往比单独的评审、批准 PR 能产生更大的效果。</p></blockquote><h2 id=nick-young-https-github-com-youngnick><a href=https://github.com/youngnick>Nick Young</a></h2><p>Nick Young 在 VMware 工作，是 CNCF 入口控制器 Contour 的技术负责人。
他从一开始就积极参与上游 Kubernetes 项目，最终成为 LTS 工作组的主席，
他提倡关注用户。他目前是 SIG Network Gateway API 子项目的维护者。</p><p>他的贡献之路是引人注目的，因为他很早就在 Kubernetes 项目的主要领域工作，这改变了他的轨迹。</p><p>他断言，一个新贡献者能做的最好的事情就是“开始贡献”。当然，如果与他的工作息息相关，那好极了;
然而，把非工作时间投入到贡献中去，从长远来看可以在工作上获得回报。
他认为，应该鼓励新的贡献者，特别是那些目前是 Kubernetes 用户的人，参与到更高层次的项目讨论中来。</p><blockquote><p>只要积极主动，做出贡献，你就可以走很远。一旦你活跃了一段时间，你会发现你能够解答别人的问题，
这意味着会有人请教你或和你讨论，在你意识到这一点之前，你就已经是专家了。</p></blockquote><hr><p>如果你对我们接下来应该采访的人有任何意见/建议，请在 #sig-contribex 中告知我们。
非常感谢你的建议。我们很高兴有更多的人帮助我们接触到社区中更优秀的人。</p><p>我们下期再见。祝你有个愉快的贡献之旅!👋</p></div><div class=td-content style=page-break-before:always><h1 id=pg-0fc668557182aa480318ef29b97df9df>更新：移除 Dockershim 的常见问题</h1><div class="td-byline mb-4"><time datetime=2022-02-17 class=text-muted>2022.02.17</time></div><p><strong>本文是针对 2020 年末发布的<a href=/zh-cn/blog/2020/12/02/dockershim-faq/>弃用 Dockershim 的常见问题</a>的博客更新。
本文包括 Kubernetes v1.24 版本的更新。</strong></p><hr><p>本文介绍了一些关于从 Kubernetes 中移除 <em>dockershim</em> 的常见问题。
该移除最初是作为 Kubernetes v1.20
版本的一部分<a href=/zh-cn/blog/2020/12/08/kubernetes-1-20-release-announcement/>宣布</a>的。
Kubernetes 在 <a href=/releases/#release-v1-24>v1.24 版</a>移除了 dockershim。</p><p>关于细节请参考博文
<a href=/zh-cn/blog/2020/12/02/dont-panic-kubernetes-and-docker/>别慌: Kubernetes 和 Docker</a>。</p><p>要确定移除 dockershim 是否会对你或你的组织的影响，可以查阅：
<a href=/zh-cn/docs/tasks/administer-cluster/migrating-from-dockershim/check-if-dockershim-removal-affects-you/>检查弃用 Dockershim 对你的影响</a>
这篇文章。</p><p>在 Kubernetes 1.24 发布之前的几个月和几天里，Kubernetes
贡献者努力试图让这个过渡顺利进行。</p><ul><li>一篇详细说明<a href=/blog/2022/01/07/kubernetes-is-moving-on-from-dockershim/>承诺和后续操作</a>的博文。</li><li>检查是否存在迁移到其他 <a href=/zh-cn/docs/setup/production-environment/container-runtimes/#container-runtimes>容器运行时</a> 的主要障碍。</li><li>添加 <a href=/docs/tasks/administer-cluster/migrating-from-dockershim/>从 dockershim 迁移</a>的指南。</li><li>创建了一个<a href=/zh-cn/docs/reference/node/topics-on-dockershim-and-cri-compatible-runtimes/>有关 dockershim 移除和使用 CRI 兼容运行时的列表</a>。
该列表包括一些已经提到的文档，还涵盖了选定的外部资源（包括供应商指南）。</li></ul><h3 id=why-was-the-dockershim-removed-from-kubernetes>为什么会从 Kubernetes 中移除 dockershim ？</h3><p>Kubernetes 的早期版本仅适用于特定的容器运行时：Docker Engine。
后来，Kubernetes 增加了对使用其他容器运行时的支持。<a href=/blog/2016/12/container-runtime-interface-cri-in-kubernetes/>创建</a> CRI
标准是为了实现编排器（如 Kubernetes）和许多不同的容器运行时之间交互操作。
Docker Engine 没有实现（CRI）接口，因此 Kubernetes 项目创建了特殊代码来帮助过渡，
并使 dockershim 代码成为 Kubernetes 的一部分。</p><p>dockershim 代码一直是一个临时解决方案（因此得名：shim）。
你可以阅读 <a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-node/2221-remove-dockershim>Kubernetes 移除 Dockershim 增强方案</a>
以了解相关的社区讨论和计划。
事实上，维护 dockershim 已经成为 Kubernetes 维护者的沉重负担。</p><p>此外，在较新的 CRI 运行时中实现了与 dockershim 不兼容的功能，例如 cgroups v2 和用户命名空间。
从 Kubernetes 中移除 dockershim 允许在这些领域进行进一步的开发。</p><h3 id=are-docker-and-containers-the-same-thing>Docker 和容器一样吗？</h3><p>Docker 普及了 Linux 容器模式，并在开发底层技术方面发挥了重要作用，但是 Linux
中的容器已经存在了很长时间，容器生态系统已经发展到比 Docker 广泛得多。
OCI 和 CRI 等标准帮助许多工具在我们的生态系统中发展壮大，其中一些替代了 Docker
的某些方面，而另一些则增强了现有功能。</p><h3 id=will-my-existing-container-images-still-work>我现有的容器镜像是否仍然有效？</h3><p>是的，从 <code>docker build</code> 生成的镜像将适用于所有 CRI 实现，
现有的所有镜像仍将完全相同。</p><h4 id=what-about-private-images>私有镜像呢？</h4><p>当然可以，所有 CRI 运行时都支持在 Kubernetes 中使用的相同的 pull secrets
配置，无论是通过 PodSpec 还是 ServiceAccount。</p><h3 id=can-i-still-use-docker-engine-in-kubernetes-1-23>在 Kubernetes 1.23 版本中还可以使用 Docker Engine 吗？</h3><p>可以使用，在 1.20 版本中唯一的改动是，如果使用 Docker Engine，
在 <a href=/zh-cn/docs/reference/command-line-tools-reference/kubelet/>kubelet</a>
启动时会打印一个警告日志。
你将在 1.23 版本及以前版本看到此警告，dockershim 已在 Kubernetes 1.24 版本中移除 。</p><p>如果你运行的是 Kubernetes v1.24 或更高版本，请参阅
<a href=#can-i-still-use-docker-engine-as-my-container-runtime>我仍然可以使用 Docker Engine 作为我的容器运行时吗？</a>
（如果你使用任何支持 dockershim 的版本，可以随时切换离开；从版本 v1.24
开始，因为 Kubernetes 不再包含 dockershim，你<strong>必须</strong>切换）。</p><h3 id=which-cri-implementation-should-i-use>我应该用哪个 CRI 实现？</h3><p>这是一个复杂的问题，依赖于许多因素。
如果你正在使用 Docker Engine，迁移到 containerd
应该是一个相对容易地转换，并将获得更好的性能和更少的开销。
然而，我们鼓励你探索 <a href="https://landscape.cncf.io/card-mode?category=container-runtime&grouping=category">CNCF landscape</a> 提供的所有选项，做出更适合你的选择。</p><h4 id=can-i-still-use-docker-engine-as-my-container-runtime>我还可以使用 Docker Engine 作为我的容器运行时吗？</h4><p>首先，如果你在自己的电脑上使用 Docker 用来做开发或测试容器：它将与之前没有任何变化。
无论你为 Kubernetes 集群使用什么容器运行时，你都可以在本地使用 Docker。容器使这种交互成为可能。</p><p>Mirantis 和 Docker 已<a href=https://www.mirantis.com/blog/mirantis-to-take-over-support-of-kubernetes-dockershim-2/>承诺</a>
为 Docker Engine 维护一个替代适配器，
并在 dockershim 从 Kubernetes 移除后维护该适配器。
替代适配器名为 <a href=https://github.com/Mirantis/cri-dockerd><code>cri-dockerd</code></a>。</p><p>你可以安装 <code>cri-dockerd</code> 并使用它将 kubelet 连接到 Docker Engine。
阅读<a href=/docs/tasks/administer-cluster/migrating-from-dockershim/migrate-dockershim-dockerd/>将 Docker Engine 节点从 dockershim 迁移到 cri-dockerd</a>
以了解更多信息。</p><h3 id=are-there-examples-of-folks-using-other-runtimes-in-production-today>现在是否有在生产系统中使用其他运行时的例子？</h3><p>Kubernetes 所有项目在所有版本中出产的工件（Kubernetes 二进制文件）都经过了验证。</p><p>此外，<a href=https://kind.sigs.k8s.io/>kind</a> 项目使用 containerd 已经有一段时间了，并且提高了其用例的稳定性。
Kind 和 containerd 每天都会被多次使用来验证对 Kubernetes 代码库的任何更改。
其他相关项目也遵循同样的模式，从而展示了其他容器运行时的稳定性和可用性。
例如，OpenShift 4.x 从 2019 年 6 月以来，就一直在生产环境中使用 <a href=https://cri-o.io/>CRI-O</a> 运行时。</p><p>至于其他示例和参考资料，你可以查看 containerd 和 CRI-O 的使用者列表，
这两个容器运行时是云原生基金会（<a href=https://cncf.io>CNCF</a>）下的项目。</p><ul><li><a href=https://github.com/containerd/containerd/blob/master/ADOPTERS.md>containerd</a></li><li><a href=https://github.com/cri-o/cri-o/blob/master/ADOPTERS.md>CRI-O</a></li></ul><h3 id=people-keep-referencing-oci-what-is-that>人们总在谈论 OCI，它是什么？</h3><p>OCI 是 <a href=https://opencontainers.org/about/overview/>Open Container Initiative</a> 的缩写，
它标准化了容器工具和底层实现之间的大量接口。
它们维护了打包容器镜像（OCI image）和运行时（OCI runtime）的标准规范。
它们还以 <a href=https://github.com/opencontainers/runc>runc</a> 的形式维护了一个 runtime-spec 的真实实现，
这也是 <a href=https://containerd.io/>containerd</a> 和 <a href=https://cri-o.io/>CRI-O</a> 依赖的默认运行时。
CRI 建立在这些底层规范之上，为管理容器提供端到端的标准。</p><h3 id=what-should-i-look-out-for-when-changing-cri-implementations>当切换 CRI 实现时，应该注意什么？</h3><p>虽然 Docker 和大多数 CRI（包括 containerd）之间的底层容器化代码是相同的，
但其周边部分却存在差异。迁移时要考虑如下常见事项：</p><ul><li>日志配置</li><li>运行时的资源限制</li><li>调用 docker 或通过其控制套接字使用 Docker Engine 的节点配置脚本</li><li>需要 <code>docker</code> 命令或 Docker Engine 控制套接字的 <code>kubectl</code> 插件</li><li>需要直接访问 Docker Engine 的 Kubernetes 工具（例如：已弃用的 'kube-imagepuller' 工具）</li><li>配置 <code>registry-mirrors</code> 和不安全的镜像仓库等功能</li><li>保障 Docker Engine 可用、且运行在 Kubernetes 之外的脚本或守护进程（例如：监视或安全代理）</li><li>GPU 或特殊硬件，以及它们如何与你的运行时和 Kubernetes 集成</li></ul><p>如果你只是用了 Kubernetes 资源请求/限制或基于文件的日志收集 DaemonSet，它们将继续稳定工作，
但是如果你用了自定义了 dockerd 配置，则可能需要为新的容器运行时做一些适配工作。</p><p>另外还有一个需要关注的点，那就是当创建镜像时，系统维护或嵌入容器方面的任务将无法工作。
对于前者，可以用 <a href=https://github.com/kubernetes-sigs/cri-tools><code>crictl</code></a> 工具作为临时替代方案
(参阅<a href=/zh-cn/docs/tasks/debug/debug-cluster/crictl/#mapping-from-docker-cli-to-crictl>从 docker cli 到 crictl 的映射</a>)。
对于后者，可以用新的容器创建选项，例如
<a href=https://github.com/genuinetools/img>img</a>、
<a href=https://github.com/containers/buildah>buildah</a>、
<a href=https://github.com/GoogleContainerTools/kaniko>kaniko</a> 或
<a href=https://github.com/vmware-tanzu/buildkit-cli-for-kubectl>buildkit-cli-for-kubectl</a>，
他们都不需要 Docker。</p><p>对于 containerd，你可查阅有关它的<a href=https://github.com/containerd/cri/blob/master/docs/registry.md>文档</a>，
获取迁移时可用的配置选项。</p><p>有关如何在 Kubernetes 中使用 containerd 和 CRI-O 的说明，
请参阅 <a href=/docs/setup/production-environment/container-runtimes/>Kubernetes 相关文档</a>。</p><h3 id=what-if-i-have-more-questions>我还有其他问题怎么办？</h3><p>如果你使用了供应商支持的 Kubernetes 发行版，你可以咨询供应商他们产品的升级计划。
对于最终用户的问题，请把问题发到我们的最终用户社区的<a href=https://discuss.kubernetes.io/>论坛</a>。</p><p>你可以通过专用 <a href=https://github.com/kubernetes/kubernetes/issues/106917>GitHub 问题</a>
讨论删除 dockershim 的决定。</p><p>你也可以看看这篇优秀的博客文章：<a href=https://dev.to/inductor/wait-docker-is-deprecated-in-kubernetes-now-what-do-i-do-e4m>等等，Docker 被 Kubernetes 弃用了?</a>
对这些变化进行更深入的技术讨论。</p><h3 id=is-there-any-tooling-that-can-help-me-find-dockershim-in-use>是否有任何工具可以帮助我找到正在使用的 dockershim？</h3><p>是的！ <a href=https://github.com/aws-containers/kubectl-detector-for-docker-socket>Docker Socket 检测器 (DDS)</a> 是一个 kubectl 插件，
你可以安装它用于检查你的集群。 DDS 可以检测运行中的 Kubernetes
工作负载是否将 Docker Engine 套接字 (<code>docker.sock</code>) 作为卷挂载。
在 DDS 项目的 <a href=https://github.com/aws-containers/kubectl-detector-for-docker-socket>README</a> 中查找更多详细信息和使用方法。</p><h3 id=can-i-have-a-hug>我可以加入吗？</h3><p>当然，只要你愿意，随时随地欢迎。🤗🤗🤗</p></div><div class=td-content style=page-break-before:always><h1 id=pg-6641e303390355141422e9c742e5de74>SIG Node CI 子项目庆祝测试改进两周年</h1><div class="td-byline mb-4"><time datetime=2022-02-16 class=text-muted>2022.02.16</time></div><p><strong>作者：</strong> Sergey Kanzhelev (Google), Elana Hashman (Red Hat)</p><p>保证 SIG 节点上游代码的可靠性是一项持续的工作，需要许多贡献者在幕后付出大量努力。
Kubernetes、基础操作系统、容器运行时和测试基础架构的频繁发布，导致了一个复杂的矩阵，
需要关注和稳定的投资来“保持灯火通明”。2020 年 5 月，Kubernetes Node 特殊兴趣小组
（“SIG Node”）为节点相关代码和测试组织了一个新的持续集成（CI）子项目。自成立以来，SIG Node CI
子项目每周举行一次会议，即使一整个小时通常也不足以完成对所有缺陷、测试相关的 PR 和问题的分类，
并讨论组内所有相关的正在进行的工作。</p><p>在过去两年中，我们修复了阻塞合并和阻塞发布的测试，由于减少了测试缺陷，缩短了合并 Kubernetes
贡献者的拉取请求的时间。通过我们的努力，任务通过率由开始时 42% 提高至稳定大于 90% 。我们已经解决了 144 个测试失败问题，
并在 kubernetes/kubernetes 中合并了 176 个拉取请求。
我们还帮助子项目参与者提升了 Kubernetes 贡献者的等级，新增了 3 名组织成员、6 名评审员和 2 名审批员。</p><p>Node CI 子项目是一个可入门的第一站，帮助新参与者开始使用 SIG Node。对于新贡献者来说，
解决影响较大的缺陷和测试修复的门槛很低，尽管贡献者要攀登整个贡献者阶梯还有很长的路要走：
为该团队培养了两个新的审批人花了一年多的时间。为 Kubernetes 节点及其测试基础设施提供动力的所有
不同组件的复杂性要求开发人员在很长一段时间内进行持续投资，
以深入了解整个系统，从宏观到微观。</p><p>虽然在我们的会议上有几个比较固定的贡献者；但是我们的评审员和审批员仍然很少。
我们的目标是继续增加贡献者，以确保工作的可持续分配，而不仅仅是少数关键批准者。</p><p>SIG 中的子项目如何形成、运行和工作并不总是显而易见的。每一个都是其背后的 SIG 所独有的，
并根据该小组打算支持的项目量身定制。作为一个欢迎了许多第一次 SIG Node 贡献者的团队，
我们想分享过去两年的一些细节和成就，帮助揭开我们内部工作的神秘面纱，并庆祝我们所有专注贡献者的辛勤工作！</p><!--## Timeline--><h2 id=时间线>时间线</h2><p><em><strong>2020 年 5 月</strong></em> SIG Node CI 组于 2020 年 5 月 11 日成立，超过
<a href="https://docs.google.com/document/d/1fb-ugvgdSVIkkuJ388_nhp2pBTy_4HEVg5848Xy7n5U/edit#bookmark=id.vsb8pqnf4gib">30 名志愿者</a>
注册，以改进 SIG Node CI 信号和整体可观测性。
Victor Pickard 专注于让 <a href=https://testgrid.k8s.io/sig-node>testgrid 可以运行</a> ，
当时 Ning Liao 建议围绕这项工作组建一个小组，并提出
<a href="https://docs.google.com/document/d/1yS-XoUl6GjZdjrwxInEZVHhxxLXlTIX2CeWOARmD8tY/edit#heading=h.te6sgum6s8uf">最初的小组章程文件</a> 。
SIG Node 赞助成立以 Victor 作为子项目负责人的小组。Sergey Kanzhelev 不久后就加入 Victor，担任联合领导人。</p><p>在启动会议上，我们讨论了应该首先集中精力修复哪些测试，并讨论了阻塞合并和阻塞发布的测试，
其中许多测试由于基础设施问题或错误的测试代码而失败。</p><p>该子项目每周召开一小时的会议，讨论正在进行的工作会谈和分类。</p><p><em><strong>2020 年 6 月</strong></em> Morgan Bauer 、 Karan Goel 和 Jorge Alarcon Ochoa
因其贡献而被公认为 SIG Node CI 小组的评审员，为该子项目的早期阶段提供了重要帮助。
David Porter 和 Roy Yang 也加入了 SIG 检测失败的 GitHub 测试团队。</p><p><em><strong>2020 年 8 月</strong></em> 所有的阻塞合并和阻塞发布的测试都通过了，伴有一些逻辑问题。
然而，只有 42% 的 SIG Node 测试作业是绿色的，
因为有许多逻辑错误和失败的测试。</p><p><em><strong>2020 年 10 月</strong></em> Amim Knabben 因对子项目的贡献成为 Kubernetes 组织成员。</p><p><em><strong>2021 年 1 月</strong></em> 随着健全的预提交和关键定期工作的通过，子项目讨论了清理其余定期测试并确保其顺利通过的目标。</p><p>Elana Hashman 加入了这个子项目，在 Victor 离开后帮助领导该项目。</p><p><em><strong>2021 年 2 月</strong></em> Artyom Lukianov 因其对子项目的贡献成为 Kubernetes 组织成员。</p><p><em><strong>2021 年 8 月</strong></em> 在 SIG Node 成功运行 <a href=https://groups.google.com/g/kubernetes-dev/c/w2ghO4ihje0/m/VeEql1LJBAAJ>bug scrub</a>
以清理其累积的缺陷之后，会议的范围扩大到包括缺陷分类以提高整体可靠性，
在问题影响 CI 信号之前预测问题。</p><p>子项目负责人 Elana Hashman 和 Sergey Kanzhelev 都被认为是所有节点测试代码的审批人，由 SIG node 和 SIG Testing 支持。</p><p><em><strong>2021 年 9 月</strong></em> 在 Francesco Romani 牵头的 1.22 版本系列测试取得重大进展后，
该子项目设定了一个目标，即在 1.23 发布日期之前让串行任务完全通过。</p><p>Mike Miranda 因其对子项目的贡献成为 Kubernetes 组织成员。</p><p><em><strong>2021 年 11 月</strong></em> 在整个 2021 年， SIG Node 没有合并或发布的测试失败。
过去版本中的许多古怪测试都已从阻止发布的仪表板中删除，因为它们已被完全清理。</p><p>Danielle Lancashire 被公认为 SIG Node 子组测试代码的评审员。</p><p>最终节点系列测试已完全修复。系列测试由许多中断性和缓慢的测试组成，这些测试往往是碎片化的，很难排除故障。
到 1.23 版本冻结时，最后一次系列测试已修复，作业顺利通过。</p><p><a href=https://kubernetes.slack.com/archives/C0BP8PW9G/p1638211041322900><img src=serial-tests-green.png alt=宣布系列测试为绿色></a></p><p>1.23 版本在测试质量和 CI 信号方面得到了特别的关注。SIG Node CI 子项目很自豪能够为这样一个高质量的发布做出贡献，
部分原因是我们在识别和修复节点内外的碎片方面所做的努力。</p><p><a href=https://kubernetes.slack.com/archives/C92G08FGD/p1637175755023200><img src=release-mostly-green.png alt="Slack 大声宣布发布的版本大多是绿色的"></a></p><p><em><strong>2021 年 12 月</strong></em> 在 1.23 版本发布时，估计有 90% 的测试工作通过了测试（2020 年 8 月为 42%）。</p><p>Dockershim 代码已从 Kubernetes 中删除。这影响了 SIG Node 近一半的测试作业，
SIG Node CI 子项目反应迅速，并重新确定了所有测试的目标。
SIG Node 是第一个完成 dockershim 外测试迁移的 SIG ，为其他受影响的 SIG 提供了示例。
绝大多数新工作在引入时都已通过，无需进一步修复。
从 Kubernetes 中<a href=https://k8s.io/dockershim>将 dockershim 除名的工作</a> 正在进行中。
随着我们发现 dockershim 对 dockershim 的依赖性越来越大，dockershim 的删除仍然存在一些问题，
但我们计划在 1.24 版本之前确保所有测试任务稳定。</p><!--## Statistics--><h2 id=统计数据>统计数据</h2><p>我们过去几个月的定期会议与会者和子项目参与者：</p><ul><li>Aditi Sharma</li><li>Artyom Lukianov</li><li>Arnaud Meukam</li><li>Danielle Lancashire</li><li>David Porter</li><li>Davanum Srinivas</li><li>Elana Hashman</li><li>Francesco Romani</li><li>Matthias Bertschy</li><li>Mike Miranda</li><li>Paco Xu</li><li>Peter Hunt</li><li>Ruiwen Zhao</li><li>Ryan Phillips</li><li>Sergey Kanzhelev</li><li>Skyler Clark</li><li>Swati Sehgal</li><li>Wenjun Wu</li></ul><p><a href=https://github.com/kubernetes/test-infra/>kubernetes/test-infra</a> 源代码存储库包含测试定义。该存储库中的节点 PR 数：</p><ul><li>2020 年 PR（自 5 月起）：<a href="https://github.com/kubernetes/test-infra/pulls?q=is%3Apr+is%3Aclosed+label%3Asig%2Fnode+created%3A2020-05-01..2020-12-31+-author%3Ak8s-infra-ci-robot+">183</a></li><li>2021 年 PR：<a href="https://github.com/kubernetes/test-infra/pulls?q=is%3Apr+is%3Aclosed+label%3Asig%2Fnode+created%3A2021-01-01..2021-12-31+-author%3Ak8s-infra-ci-robot+">264</a></li></ul><p>CI 委员会上的问题和 PRs 分类（包括子组范围之外的分类）：</p><ul><li>2020 年（自 5 月起）：<a href="https://github.com/issues?q=project%3Akubernetes%2F43+created%3A2020-05-01..2020-12-31">132</a></li><li>2021 年：<a href="https://github.com/issues?q=project%3Akubernetes%2F43+created%3A2021-01-01..2021-12-31+">532</a></li></ul><!--## Future--><h2 id=未来>未来</h2><p>只是“保持灯亮”是一项大胆的任务，我们致力于改善这种体验。
我们正在努力简化 SIG Node 的分类和审查流程。</p><p>具体来说，我们正在致力于更好的测试组织、命名和跟踪：</p><ul><li><a href=https://github.com/kubernetes/enhancements/pull/3042>https://github.com/kubernetes/enhancements/pull/3042</a></li><li><a href=https://github.com/kubernetes/test-infra/issues/24641>https://github.com/kubernetes/test-infra/issues/24641</a></li><li><a href="https://docs.google.com/spreadsheets/d/1IwONkeXSc2SG_EQMYGRSkfiSWNk8yWLpVhPm-LOTbGM/edit#gid=0">Kubernetes SIG Node CI 测试网格跟踪器</a></li></ul><p>我们还在改进测试的可调试性和去剥落方面不断取得进展。</p><p>如果你对此感兴趣，我们很乐意您能加入我们！
在调试测试失败中有很多东西需要学习，它将帮助你熟悉 SIG Node 维护的代码。</p><p>你可以在 <a href=https://github.com/kubernetes/community/tree/master/sig-node>SIG Node</a> 页面上找到有关该组的信息。
我们在我们的维护者轨道会议上提供组更新，例如：
<a href=https://kccnceu2021.sched.com/event/iE8E/kubernetes-sig-node-intro-and-deep-dive-elana-hashman-red-hat-sergey-kanzhelev-google>KubeCon + CloudNativeCon Europe 2021</a> 和
<a href="https://kccncna2021.sched.com/event/lV9D/kubenetes-sig-node-intro-and-deep-dive-elana-hashman-derek-carr-red-hat-sergey-kanzhelev-dawn-chen-google?iframe=no&w=100%25&sidebar=yes&bg=no">KubeCon + CloudNative North America 2021</a>。
加入我们的使命，保持 kubelet 和其他 SIG Node 组件的可靠性，确保顺顺利利发布！</p></div><div class=td-content style=page-break-before:always><h1 id=pg-9c346bff5d7ed8c4160c72f990d805de>关注 SIG Multicluster</h1><div class="td-byline mb-4"><time datetime=2022-02-07 class=text-muted>2022.02.07</time></div><p><strong>作者：</strong> Dewan Ahmed (Aiven) 和 Chris Short (AWS)</p><h2 id=简介>简介</h2><p><a href=https://github.com/kubernetes/community/tree/master/sig-multicluster>SIG Multicluster</a>
是专注于如何拓展 Kubernetes 的概念并将其用于集群边界之外的 SIG。
以往 Kubernetes 资源仅在 Kubernetes Resource Universe (KRU) 这个边界内进行交互，其中 KRU 不是一个实际的 Kubernetes 概念。
即使是现在，Kubernetes 集群对自身或其他集群并不真正了解。集群标识符的缺失就是一个例子。
随着多云和多集群部署日益普及，SIG Multicluster 所做的工作越来越受到关注。
在这篇博客中，<a href=https://twitter.com/jeremyot>来自 Google 的 Jeremy Olmsted-Thompson</a> 和
<a href=https://twitter.com/ChrisShort>来自 AWS 的 Chris Short</a> 讨论了 SIG Multicluster
正在解决的一些有趣的问题和以及大家如何参与其中。
为简洁起见，下文将使用他们两位的首字母 <strong>JOT</strong> 和 <strong>CS</strong>。</p><h2 id=谈话总结>谈话总结</h2><p><strong>CS</strong>：SIG Multicluster 存在多久了？SIG 在起步阶段情况如何？你参与这个 SIG 多长时间了？</p><p><strong>JOT</strong>：我在 SIG Multicluster 工作了将近两年。我所知道的关于初创时期的情况都来自传说，但即使在早期，也一直是为了解决相同的问题。
早期工作的例子之一是 <a href=https://github.com/kubernetes-sigs/kubefed>KubeFed</a>。
我认为仍然有一些人在使用 KubeFed，但它只是一小部分。
那时，我认为人们在部署大量 Kubernetes 集群时，还没有达到我们拥有大量实际具体用例的地步。
像 KubeFed 和 <a href=https://github.com/kubernetes-retired/cluster-registry>Cluster Registry</a>
这样的项目就是在那个时候开发的，当时的需求可以与这些项目相关联。
这些项目的动机是如何解决我们认为在开始扩展到多个集群时 <strong>会遇到的问题</strong>。
老实说，在某些方面，当时它试图做得太多了。</p><p><strong>CS</strong>：KubeFed 与 SIG Multicluster 的现状有何不同？<strong>初创期</strong> 与 <strong>现在</strong> 有何不同？</p><p><strong>JOT</strong>：嗯嗯，这就像总是要预防潜在问题而不是解决眼前具体的问题。我认为在 2019 年底，
SIG Multicluster 工作有所放缓，我们通过最近最活跃的项目之一
<a href=https://github.com/kubernetes-sigs/mcs-api>SIG Multicluster services (MCS)</a> 将其重新拾起。</p><p>现在我们向解决实际的具体问题开始转变。比如说。</p><blockquote><p>我的工作负载分布在多个集群中，我需要它们相互通信。</p></blockquote><p>好吧，这是非常直接的，我们也知道需要解决这个问题。
首先，让我们确保这些项目可以在一个通用的 API 上协同工作，这样你就可以获得与 Kubernetes 相同的可移植性。</p><p>目前有一些 MCS API 的实现，并且更多的实现正在开发中。但是，我们没有建立一个实现，
因为取决于你的部署方式不同，可能会有数百种实现。
只要你所需要的基本的多集群服务功能，它就可以在你想要的任何背景下工作，无论是 Submariner、GKE 还是服务网格。</p><p>我最喜欢的“过去与现在“的例子是集群 ID。几年前曾经有过定义集群 ID 的尝试。
针对这个概念，有很多非常好的想法。例如，我们如何使集群 ID 在多个集群中是唯一的。
我们如何使这个 ID 全球范围内唯一，以便它在各个通讯中发挥作用？
假设有团队被收购或合并 - 集群 ID 对于这些团队仍然是唯一的吗？</p><p>在 Multicluster 服务的相关工作中，我们发现需要一个实际的集群 ID，并且这一需求非常具体。
为了满足这一特定需求，我们不再考虑一个个 Kubernetes 集群，而是考虑 ClusterSets — 在某种范围内协同工作的集群分组。
与考虑所有时间点和所有空间位置上存在的集群相比，这一范畴要窄得多。
这一概念还让实现者具备了定义边界（ClusterSet）的灵活性，在该边界之外，该集群 ID 将不再是唯一的。</p><p><strong>CS</strong>：你对 SIG Multicluster 的现状有何看法，你希望未来达到什么样的目标？</p><p><strong>JOT</strong>：有一些项目正在起步，例如 Work API。 在未来，我认为围绕着如何跨集群部署应用的一些共同做法将会发展起来。</p><blockquote><p>如果我的集群部署在不同的地区，那么最好的方式是什么？</p></blockquote><p>答案几乎总是“视情况而定”。你为什么要这样做？是因为某种合规性使你关注位置吗？是性能问题吗？是可用性吗？</p><p>我认为，在我们有了集群 ID 之后，重新审视注册表模式可能是很自然的一步，也就是说，
你如何将这些集群真正关联在一起？也许你有一个分布式部署，你在世界各地的数据中心运行。
我想随着多集群特性的进一步开发，扩展该领域的 API 将变得很重要。
这实际上取决于社区开始使用这些工具做什么。</p><p><strong>CS</strong>：在 Kubernetes 的早期，我们只有寥寥几个大型的 Kubernetes 集群，而现在我们面对的是大量的小型 Kubernetes 集群，就像我自己所在的开发环境中就使用了多个集群。
这种从几个大集群到许多小集群的转变对 SIG 有何影响？它是否加快了工作进度或在某种程度上使得问题变得更困难？</p><p><strong>JOT</strong>：我认为它带来了很多需要解决的歧义。最初，你可能拥有一个 dev 集群、一个 staging 集群和一个 prod 集群。
当引入了多区域的考量时，我们开始在每个区域部署 dev/staging/prod 集群。
再后来，有时由于合规性或某些法规问题，集群确实需要更多的隔离。
因此，我们最终会有很多集群。我认为在你究竟应该有多少个集群上找到平衡是很重要的。Kubernetes 的强大之处在于能够部署由单个控制平面管理的大量事物。
因此，并不是每个被部署的工作负载都应该在自己的集群中。
但是，我认为同样很明显的是，我们不能将所有工作负载都放在一个集群中。</p><p><strong>CS</strong>：你最喜欢 SIG 的哪些方面？</p><p><strong>JOT</strong>：问题的复杂性、人的因素和领域的新颖性。我们还没有正确的答案，我们必须找到正确的答案。
一开始，我们甚至无法考虑多集群，因为无法跨集群连接服务。
现在我们开始着手解决这些问题，我认为这是一个非常有趣的地方，因为我预计 SIG 在未来几年会变得更加繁忙。
这是一个协作很密切的团体，我们绝对希望更多的人参与、加入我们，提出他们的问题和想法。</p><p><strong>CS</strong>：你认为是什么让人们留在这个群体中？疫情对你有何影响？</p><p><strong>JOT</strong>：我认为在疫情期间这个群体肯定会变得安静一些。但在大多数情况下，这是一个非常分散的小组，
因此无论你在会议室或者在家中参加我们的每周会议，都不会产生太大的影响。在疫情期间，很多人有时间专注于他们接下来的规模和增长。
我认为这就是让人们留在团队中的原因 - 我们有真正的问题需要解决，这些问题在这个领域是非常新颖的、有趣的。</p><h2 id=结束语>结束语</h2><p><strong>CS</strong>：这就是我们今天的全部内容，感谢 Jeremy 的时间。</p><p><strong>JOT</strong>：谢谢 Chris。我们的<a href=https://github.com/kubernetes/community/tree/master/sig-multicluster#meetings>双周会议</a>
欢迎所有人参加。我们希望尽可能多的人前来，并欢迎所有问题与想法。
这是一个新的领域，如果能让社区发展起来，那就太好了。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-39e8f418525c9d53be1c8ba12d6d3e20>确保准入控制器的安全</h1><div class="td-byline mb-4"><time datetime=2022-01-19 class=text-muted>2022.01.19</time></div><p><strong>作者:</strong> Rory McCune (Aqua Security)</p><p><a href=/zh-cn/docs/reference/access-authn-authz/admission-controllers/>准入控制</a>和认证、授权都是 Kubernetes 安全性的关键部分。
Webhook 准入控制器被广泛用于以多种方式帮助提高 Kubernetes 集群的安全性，
包括限制工作负载权限和确保部署到集群的镜像满足组织安全要求。</p><p>然而，与添加到集群中的任何其他组件一样，安全风险也会随之出现。
一个安全风险示例是没有正确处理准入控制器的部署和管理。
为了帮助准入控制器用户和设计人员适当地管理这些风险，
SIG Security 的<a href=https://github.com/kubernetes/community/tree/master/sig-security#security-docs>安全文档</a>小组
花费了一些时间来开发一个<a href=https://github.com/kubernetes/sig-security/tree/main/sig-security-docs/papers/admission-control>准入控制器威胁模型</a>。
这种威胁模型着眼于由于不正确使用准入控制器而产生的可能的风险，可能允许绕过安全策略，甚至允许攻击者未经授权访问集群。</p><p>基于这个威胁模型，我们开发了一套安全最佳实践。
你应该采用这些实践来确保集群操作员可以获得准入控制器带来的安全优势，同时避免使用它们带来的任何风险。</p><h2 id=准入控制器和安全的良好做法>准入控制器和安全的良好做法</h2><p>基于这个威胁模型，围绕着如何确保准入控制器的安全性出现了几个主题。</p><h3 id=安全的-webhook-配置>安全的 webhook 配置</h3><p>确保集群中的任何安全组件都配置良好是很重要的，在这里准入控制器也并不例外。
使用准入控制器时需要考虑几个安全最佳实践：</p><ul><li><strong>为所有 webhook 流量正确配置了 TLS</strong>。
API 服务器和准入控制器 webhook 之间的通信应该经过身份验证和加密，以确保处于网络中查看或修改此流量的攻击者无法查看或修改。
要实现此访问，API 服务器和 webhook 必须使用来自受信任的证书颁发机构的证书，以便它们可以验证相互的身份。</li></ul><ul><li><strong>只允许经过身份验证的访问</strong>。
如果攻击者可以向准入控制器发送大量请求，他们可能会压垮服务导致其失败。
确保所有访问都需要强身份验证可以降低这种风险。</li></ul><ul><li><strong>准入控制器关闭失败</strong>。
这是一种需要权衡的安全实践，集群操作员是否要对其进行配置取决于集群的威胁模型。
如果一个准入控制器关闭失败，当 API 服务器无法从它得到响应时，所有的部署都会失败。
这可以阻止攻击者通过禁用准入控制器绕过准入控制器，但可能会破坏集群的运行。
由于集群可以有多个 webhook，因此一种折中的方法是对关键控制允许故障关闭，
并允许不太关键的控制进行故障打开。</li></ul><ul><li><strong>定期审查 webhook 配置</strong>。
配置错误可能导致安全问题，因此检查准入控制器 webhook 配置以确保设置正确非常重要。
这种审查可以由基础设施即代码扫描程序自动完成，也可以由管理员手动完成。</li></ul><h3 id=为准入控制保护集群配置>为准入控制保护集群配置</h3><p>在大多数情况下，集群使用的准入控制器 webhook 将作为工作负载安装在集群中。
因此，确保正确配置了可能影响其操作的 Kubernetes 安全特性非常重要。</p><ul><li><strong>限制 <a href=/zh-cn/docs/reference/access-authn-authz/rbac/>RBAC</a> 权限</strong>。
任何有权修改 webhook 对象的配置或准入控制器使用的工作负载的用户都可以破坏其运行。
因此，确保只有集群管理员拥有这些权限非常重要。</li></ul><ul><li><strong>防止特权工作负载</strong>。
容器系统的一个现实是，如果工作负载被赋予某些特权，
则有可能逃逸到下层的集群节点并影响该节点上的其他容器。
如果准入控制器服务在它们所保护的集群上运行，
一定要确保对特权工作负载的所有请求都要经过仔细审查并尽可能地加以限制。</li></ul><ul><li><strong>严格控制外部系统访问</strong>。
作为集群中的安全服务，准入控制器系统将有权访问敏感信息，如凭证。
为了降低此信息被发送到集群外的风险，
应使用<a href=/zh-cn/docs/concepts/services-networking/network-policies/>网络策略</a>
来限制准入控制器服务对外部网络的访问。</li></ul><ul><li><strong>每个集群都有一个专用的 webhook</strong>。
虽然可能让准入控制器 webhook 服务于多个集群的，
但在使用该模型时存在对 webhook 服务的攻击会对共享它的地方产生更大影响的风险。
此外，在多个集群使用准入控制器的情况下，复杂性和访问要求也会增加，从而更难保护其安全。</li></ul><h3 id=准入控制器规则>准入控制器规则</h3><p>对于用于 Kubernetes 安全的所有准入控制器而言，一个关键元素是它使用的规则库。
规则需要能够准确地满足其目标，避免假阳性和假阴性结果。</p><ul><li><strong>定期测试和审查规则</strong>。
需要测试准入控制器规则以确保其准确性。
还需要定期审查，因为 Kubernetes API 会随着每个新版本而改变，
并且需要在每个 Kubernetes 版本中评估规则，以了解使他们保持最新版本所需要做的任何改变。</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-b0afb26877191fdd475bffa530d5db8c>认识我们的贡献者 - 亚太地区（印度地区）</h1><div class="td-byline mb-4"><time datetime=2022-01-10 class=text-muted>2022.01.10</time></div><p><strong>作者和采访者：</strong> <a href=https://github.com/anubha-v-ardhan>Anubhav Vardhan</a>、
<a href=https://github.com/Atharva-Shinde>Atharva Shinde</a>、
<a href=https://github.com/AvineshTripathi>Avinesh Tripathi</a>、
<a href=https://github.com/Debanitrkl>Debabrata Panigrahi</a>、
<a href=https://github.com/verma-kunal>Kunal Verma</a>、
<a href=https://github.com/PranshuSrivastava>Pranshu Srivastava</a>、
<a href=https://github.com/CIPHERTron>Pritish Samal</a>、
<a href=https://github.com/PurneswarPrasad>Purneswar Prasad</a>、
<a href=https://github.com/vedant-kakde>Vedant Kakde</a></p><p><strong>编辑：</strong> <a href=https://psaggu.com>Priyanka Saggu</a></p><hr><p>大家好 👋</p><p>欢迎来到亚太地区的“认识我们的贡献者”博文系列第一期。</p><p>在这篇文章中，我们将向你介绍来自印度地区的五位优秀贡献者，他们一直在以各种方式积极地为上游 Kubernetes 项目做贡献，同时也是众多社区倡议的领导者和维护者。</p><p>💫 <em>闲话少说，我们开始吧。</em></p><h2 id=arsh-sharma-https-github-com-rinkiyakedad><a href=https://github.com/RinkiyaKeDad>Arsh Sharma</a></h2><p>Arsh 目前在 Okteto 公司中担任开发者体验工程师职务。作为一名新的贡献者，他意识到一对一的指导机会让他在开始上游项目中受益匪浅。</p><p>他目前是 Kubernetes 1.23 版本团队的 CI Signal 经理。他还致力于为 SIG Testing 和 SIG Docs 项目提供贡献，并且在 SIG Architecture 项目中负责 <a href=https://github.com/cert-manager/infrastructure>证书管理器</a> 工具的开发工作。</p><p>对于新人来说，Arsh 帮助他们可持续地计划早期贡献。</p><blockquote><p>我鼓励大家以可持续的方式为社区做贡献。
我的意思是，一个人很容易在早期的时候非常有热情，并且承担了很多超出个人实际能力的事情。
这通常会导致后期的倦怠。迭代地处理事情会让大家对社区的贡献变得可持续。</p></blockquote><h2 id=kunal-kushwaha-https-github-com-kunal-kushwaha><a href=https://github.com/kunal-kushwaha>Kunal Kushwaha</a></h2><p>Kunal Kushwaha 是 Kubernetes 营销委员会的核心成员。他同时也是 <a href=https://community.cncf.io/cloud-native-students/>CNCF 学生计划</a> 的创始人之一。他还在 1.22 版本周期中担任通信经理一职。</p><p>在他的第一年结束时，Kunal 开始为 <a href=https://github.com/fabric8io/kubernetes-client>fabric8io kubernetes-client</a> 项目做贡献。然后，他被推选从事同一项目，此项目是 Google Summer of Code 的一部分。Kunal 在 Google Summer of Code、Google Code-in 等项目中指导过很多人。</p><p>作为一名开源爱好者，他坚信，社区的多元化参与是非常有益的，因为他引入了新的观念和观点，并尊重自己的伙伴。它曾参与过各种开源项目，他在这些社区中的参与对他作为开发者的发展有很大帮助。</p><blockquote><p>我相信，如果你发现自己在一个了解不多的项目当中，那是件好事，
因为现在你可以一边贡献一边学习，社区也会帮助你。
它帮助我获得了很多技能，认识了来自世界各地的人，也帮助了他们。
你可以在这个过程中学习，自己不一定必须是专家。
请重视非代码贡献，因为作为初学者这是一项技能，你可以为组织带来新的视角。</p></blockquote><h2 id=madhav-jivarajani-https-github-com-madhavjivrajani><a href=https://github.com/MadhavJivrajani>Madhav Jivarajani</a></h2><p>Madhav Jivarajani 在 VMware 上游 Kubernetes 稳定性团队工作。他于 2021 年 1 月开始为 Kubernetes 项目做贡献，此后在 SIG Architecture、SIG API Machinery 和 SIG ContribEx（贡献者经验）等项目的几个工作领域做出了重大贡献。</p><p>在这几个重要项目中，他最近致力于<a href=https://github.com/kubernetes/community/issues/6055>设计方案</a>的存档工作，
重构 k8s-infra 存储库下的 <a href=https://github.com/kubernetes/k8s.io/pull/2713>"组"代码库</a>，
使其具有可模拟性和可测试性，以及改进 <a href=https://github.com/kubernetes/test-infra/issues/23129>GitHub k8s 机器人</a>的功能。</p><p>除了在技术方面的贡献，Madhav 还监督许多旨在帮助新贡献者的项目。
他每两周组织一次的 “KEP 阅读俱乐部” 会议，帮助新人了解添加新功能、
摒弃旧功能以及对上游项目进行其他关键更改的过程。他还致力于开发
<a href=https://github.com/kubernetes-sigs/contributor-katacoda>Katacoda 场景</a>，
以帮助新的贡献者在为 k/k 做贡献的过程更加熟练。目前除了每周与社区成员会面外，
他还组织了几个<a href="https://www.youtube.com/watch?v=FgsXbHBRYIc">新贡献者讲习班（NCW）</a>。</p><blockquote><p>一开始我对 Kubernetes 了解并不多。我加入社区是因为社区超级友好。
但让我留下来的不仅仅是人，还有项目本身。我在社区中不会感到不知所措，
这是因为我能够在感兴趣的和正在讨论的主题中获得尽可能多的背景和知识。
因此，我将继续深入探讨 Kubernetes 及其设计。
我是一个系统迷，kubernetes 对我来说绝对是一个金矿。</p></blockquote><h2 id=rajas-kakodkar-https-github-com-rajaskakodkar><a href=https://github.com/rajaskakodkar>Rajas Kakodkar</a></h2><p>Rajas Kakodkar 目前在 VMware 担任技术人员。自 2019 年以来，他一直多方面地从事上游 kubernetes 项目。</p><p>他现在是 Testing 特别兴趣小组的关键贡献者。他还活跃在 SIG Network 社区。最近，Rajas 为 <a href=https://docs.google.com/document/d/1AtWQy2fNa4qXRag9cCp5_HsefD7bxKe3ea2RPn8jnSs/>NetworkPolicy++</a> 和 <a href=https://github.com/kubernetes-sigs/kpng><code>kpng</code></a> 子项目做出了重大贡献。</p><p>他遇到的第一个挑战是，他所处的时区与上游项目的日常会议时间不同。不过，社区论坛上的异步交互逐渐解决了这个问题。</p><blockquote><p>我喜欢为 kubernetes 做出贡献，不仅因为我可以从事尖端技术工作，
更重要的是，我可以和优秀的人一起工作，并帮助解决现实问题。</p></blockquote><h2 id=rajula-vineet-reddy-https-github-com-rajula96reddy><a href=https://github.com/rajula96reddy>Rajula Vineet Reddy</a></h2><p>Rajula Vineet Reddy，CERN 的初级工程师，是 SIG ContribEx 项目下营销委员会的成员。在 Kubernetes 1.22 和 1.23 版本周期中，他还担任 SIG Release 的版本经理。</p><p>在他的一位教授的帮助下，他开始将 kubernetes 项目作为大学项目的一部分。慢慢地，他花费了大量的时间阅读项目的文档、Slack 讨论、GitHub issues 和博客，这有助于他更好地掌握 kubernetes 项目，并激发了他对上游项目做贡献的兴趣。他的主要贡献之一是他在SIG ContribEx上游营销子项目中协助实现了自动化。</p><p>Rajas 说，参与项目会议和跟踪各种项目角色对于了解社区至关重要。</p><blockquote><p>我发现社区非常有帮助，而且总是“你得到的回报和你贡献的一样多”。
你参与得越多，你就越会了解、学习和贡献新东西。</p><p>“挺身而出”的第一步是艰难的。但在那之后一切都会顺利的。勇敢地参与进来吧。</p></blockquote><hr><p>如果你对我们下一步应该采访谁有任何意见/建议，请在 #sig-contribex 中告知我们。我们很高兴有其他人帮助我们接触社区中更优秀的人。我们将不胜感激。</p><p>我们下期见。最后，祝大家都能快乐地为社区做贡献！👋</p></div><div class=td-content style=page-break-before:always><h1 id=pg-d18900dd436a926af5577de903624990>Kubernetes 即将移除 Dockershim：承诺和下一步</h1><div class="td-byline mb-4"><time datetime=2022-01-07 class=text-muted>2022.01.07</time></div><p><strong>作者：</strong> Sergey Kanzhelev (Google), Jim Angel (Google), Davanum Srinivas (VMware), Shannon Kularathna (Google), Chris Short (AWS), Dawn Chen (Google)</p><p>Kubernetes 将在即将发布的 1.24 版本中移除 dockershim。我们很高兴能够通过支持开源容器运行时、支持更小的
kubelet 以及为使用 Kubernetes 的团队提高工程速度来重申我们的社区价值。
如果你<a href=/zh-cn/docs/tasks/administer-cluster/migrating-from-dockershim/find-out-runtime-you-use/>使用 Docker Engine 作为 Kubernetes 集群的容器运行时</a>，
请准备好在 1.24 中迁移！要检查你是否受到影响，
请参考<a href=/zh-cn/docs/tasks/administer-cluster/migrating-from-dockershim/check-if-dockershim-removal-affects-you/>检查移除 Dockershim 对你的影响</a>。</p><h2 id=why-we-re-moving-away-from-dockershim>为什么我们要离开 dockershim</h2><p>Docker 是 Kubernetes 使用的第一个容器运行时。
这也是许多 Kubernetes 用户和爱好者如此熟悉 Docker 的原因之一。
对 Docker 的支持被硬编码到 Kubernetes 中——一个被项目称为 dockershim 的组件。</p><p>随着容器化成为行业标准，Kubernetes 项目增加了对其他运行时的支持。
最终实现了容器运行时接口（CRI），让系统组件（如 kubelet）以标准化的方式与容器运行时通信。
因此，dockershim 成为了 Kubernetes 项目中的一个异常现象。</p><p>对 Docker 和 dockershim 的依赖已经渗透到 CNCF 生态系统中的各种工具和项目中，这导致了代码脆弱。</p><p>通过删除 dockershim CRI，我们拥抱了 CNCF 的第一个价值：
“<a href=https://github.com/cncf/foundation/blob/master/charter.md#3-values>快比慢好</a>”。
请继续关注未来关于这个话题的交流!</p><h2 id=deprecation-timeline>弃用时间线</h2><p>我们<a href=/zh-cn/blog/2020/12/08/kubernetes-1-20-release-announcement/>正式宣布</a>于
2020 年 12 月弃用 dockershim。目标是在 2022 年 4 月，
Kubernetes 1.24 中完全移除 dockershim。
此时间线与我们的<a href=/zh-cn/docs/reference/using-api/deprecation-policy/#deprecating-a-feature-or-behavior>弃用策略</a>一致，
即规定已弃用的行为必须在其宣布弃用后至少运行 1 年。</p><p>包括 dockershim 的 Kubernetes 1.23 版本，在 Kubernetes 项目中将再支持一年。
对于托管 Kubernetes 的供应商，供应商支持可能会持续更长时间，但这取决于公司本身。
无论如何，我们相信所有集群操作都有时间进行迁移。如果你有更多关于 dockershim 移除的问题，
请参考<a href=/zh-cn/blog/2020/12/02/dockershim-faq/>弃用 Dockershim 的常见问题</a>。</p><p>在这个<a href=/blog/2021/11/12/are-you-ready-for-dockershim-removal/>你是否为 dockershim 的删除做好了准备</a>的调查中，
我们询问你是否为 dockershim 的迁移做好了准备。我们收到了 600 多个回复。
感谢所有花时间填写调查问卷的人。</p><p>结果表明，在帮助你顺利迁移方面，我们还有很多工作要做。
存在其他容器运行时，并且已被广泛推广。但是，许多用户告诉我们他们仍然依赖 dockershim，
并且有时需要重新处理依赖项。其中一些依赖项超出控制范围。
根据收集到的反馈，我们采取了一些措施提供帮助。</p><h2 id=our-next-steps>我们的下一个步骤</h2><p>根据提供的反馈：</p><ul><li>CNCF 和 1.24 版本团队致力于及时交付 1.24 版本的文档。这包括像本文这样的包含更多信息的博客文章，
更新现有的代码示例、教程和任务，并为集群操作人员生成迁移指南。</li><li>我们正在联系 CNCF 社区的其他成员，帮助他们为这一变化做好准备。</li></ul><p>如果你是依赖 dockershim 的项目的一部分，或者如果你有兴趣帮助参与迁移工作，请加入我们！
无论是我们的迁移工具还是我们的文档，总是有更多贡献者的空间。
作为起步，请在 <a href=https://slack.kubernetes.io/>Kubernetes Slack</a> 上的
<a href=https://kubernetes.slack.com/archives/C0BP8PW9G>#sig-node</a> 频道打个招呼！</p><h2 id=final-thoughts>最终想法</h2><p>作为一个项目，我们已经看到集群运营商在 2021 年之前越来越多地采用其他容器运行时。
我们相信迁移没有主要障碍。我们为改善迁移体验而采取的步骤将为你指明更清晰的道路。</p><p>我们知道，从 dockershim 迁移是你可能需要执行的另一项操作，以保证你的 Kubernetes 基础架构保持最新。
对于你们中的大多数人来说，这一步将是简单明了的。在某些情况下，你会遇到问题。
社区已经详细讨论了推迟 dockershim 删除是否会有所帮助。
例如，我们最近在 <a href="https://docs.google.com/document/d/1Ne57gvidMEWXR70OxxnRkYquAoMpt56o75oZtg-OeBg/edit#bookmark=id.r77y11bgzid">11 月 11 日的 SIG Node 讨论</a>和
<a href="https://docs.google.com/document/d/1qazwMIHGeF3iUh5xMJIJ6PDr-S3bNkT8tNLRkSiOkOU/edit#bookmark=id.m0ir406av7jx">12 月 6 日 Kubernetes Steering 举行的委员会会议</a>谈到了它。
我们已经在 2021 年<a href=https://github.com/kubernetes/enhancements/pull/2481/>推迟</a>它一次，
因为其他运行时的采用率低于我们的预期，这也给了我们更多的时间来识别潜在的阻塞问题。</p><p>在这一点上，我们相信你（和 Kubernetes）从移除 dockershim 中获得的价值可以弥补你将要进行的迁移工作。
现在就开始计划以避免出现意外。在 Kubernetes 1.24 发布之前，我们将提供更多更新信息和指南。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-9d7d32c3aa8ecd68fc6f5cdccad9c2e1>Security Profiles Operator v0.4.0 中的新功能</h1><div class="td-byline mb-4"><time datetime=2021-12-17 class=text-muted>2021.12.17</time></div><p><strong>作者:</strong> Jakub Hrozek, Juan Antonio Osorio, Paulo Gomes, Sascha Grunert</p><hr><p><a href=https://sigs.k8s.io/security-profiles-operator>Security Profiles Operator (SPO)</a>
是一种树外 Kubernetes 增强功能，用于更方便、更便捷地管理 <a href=https://en.wikipedia.org/wiki/Seccomp>seccomp</a>、
<a href=https://zh.wikipedia.org/wiki/%E5%AE%89%E5%85%A8%E5%A2%9E%E5%BC%BA%E5%BC%8FLinux>SELinux</a> 和
<a href=https://zh.wikipedia.org/wiki/AppArmor>AppArmor</a> 配置文件。
我们很高兴地宣布，我们最近<a href=https://github.com/kubernetes-sigs/security-profiles-operator/releases/tag/v0.4.0>发布了 v0.4.0</a>
的 Operator，其中包含了大量的新功能、缺陷修复和可用性改进。</p><h2 id=有哪些新特性>有哪些新特性</h2><p>距离上次的 <a href=https://github.com/kubernetes-sigs/security-profiles-operator/releases/tag/v0.3.0>v0.3.0</a>
的发布已经有一段时间了。在过去的半年里，我们增加了新的功能，对现有的功能进行了微调，
并且在过去的半年里，我们通过 290 个提交重新编写了文档。</p><p>亮点之一是我们现在能够使用 Operator 的<a href=https://github.com/kubernetes-sigs/security-profiles-operator/blob/71b3915/installation-usage.md#log-enricher-based-recording>日志增强组件</a>
记录 seccomp 和 SELinux 的配置文件。
这使我们能够减少配置文件记录所需的依赖事项，使得仅剩的依赖变为在节点上运行
<a href=https://linux.die.net/man/8/auditd>auditd</a> 或 <a href=https://en.wikipedia.org/wiki/Syslog>syslog</a>（作为一种回退机制）。
通过使用 <code>ProfileRecording</code> CRD 及其对应的<a href=/zh-cn/concepts/overview/working-with-objects/labels>标签选择算符</a>，
Operator 中的所有配置文件记录都以相同的方式工作。
日志增强组件本身也可用于获得有关节点上的 seccomp 和 SELinux 消息的有意义的洞察。
查看<a href=https://github.com/kubernetes-sigs/security-profiles-operator/blob/71b3915/installation-usage.md#using-the-log-enricher>官方文档</a>
了解更多信息。</p><h3 id=与-seccomp-有关的改进>与 seccomp 有关的改进</h3><p>除了基于日志丰富器的记录之外，我们现在还使用 <a href=https://ebpf.io>ebpf</a>
作为记录 seccomp 配置文件的一种替代方法。可以通过将 <code>enableBpfRecorder</code> 设置为 <code>true</code> 来启用此可选功能。
启用之后会导致一个专用的容器被启动运行；该容器在每个节点上提供一个自定义 bpf 模块以收集容器的系统调用。
它甚至支持默认不公开 <a href=https://www.kernel.org/doc/html/latest/bpf/btf.html>BPF 类型格式 (BTF)</a>
的旧内核版本以及 <code>amd64</code> 和 <code>arm64</code> 架构。查看 <a href=https://github.com/kubernetes-sigs/security-profiles-operator/blob/71b3915/installation-usage.md#ebpf-based-recording>我们的文档</a>
以查看它的实际效果。顺便说一句，我们现在也将记录器主机的 seccomp 配置文件体系结构添加到记录的配置文件中。</p><p>我们还将 seccomp 配置文件 API 从 <code>v1alpha1</code> 升级到 <code>v1beta1</code>。
这符合我们随着时间的推移稳定 CRD API 的总体目标。
唯一改变的是 seccomp 配置文件类型 <code>Architectures</code> 现在指向 <code>[]Arch</code> 而不是 <code>[]*Arch</code>。</p><h3 id=selinux-增强功能>SELinux 增强功能</h3><p>管理 SELinux 策略（相当于使用通常在单个服务器上调用的 <code>semodule</code> ）不是由 SPO 本身完成的，
而是由另一个名为 selinuxd 的容器完成，以提供更好的隔离。此版本将所使用的 selinuxd
容器镜像从个人仓库迁移到位于<a href=https://quay.io/organization/security-profiles-operator>我们团队的 quay.io 仓库</a>下的镜像。
selinuxd 仓库也已移至<a href=https://github.com/containers/selinuxd>GitHub 组织 containers</a>。</p><p>请注意，selinuxd 动态链接到 libsemanage 并挂载节点上的 SELinux 目录，
这意味着 selinuxd 容器必须与集群节点运行相同的发行版。SPO 默认使用基于 CentOS-8 的容器，
但我们也构建基于 Fedora 的容器。如果你使用其他发行版并希望我们添加对它的支持，
请<a href=https://github.com/containers/selinuxd/issues>针对 selinuxd 提交 issue</a>。</p><h4 id=配置文件记录>配置文件记录</h4><p>此版本（0.4.0）增加了记录 SELinux 配置文件的支持。记录本身是通过 <code>ProfileRecording</code> 自定义资源的实例管理的，
如我们仓库中的<a href=https://github.com/kubernetes-sigs/security-profiles-operator/blob/main/examples/profilerecording-selinux-logs.yaml>示例</a>
所示。从用户的角度来看，它的工作原理与记录 seccomp 配置文件几乎相同。</p><p>在后台，为了知道工作负载在做什么，SPO 安装了一个名为 <a href=https://github.com/kubernetes-sigs/security-profiles-operator/blob/main/deploy/base/profiles/selinuxrecording.cil>selinuxrecording</a>
的、限制宽松的策略，允许执行所有操作并将所有 AVC 记录到 <code>audit.log</code> 中。
这些 AVC 消息由日志增强组件抓取，当所记录的工作负载退出时，该策略被创建。</p><h4 id=selinuxprofile-crd-毕业><code>SELinuxProfile</code> CRD 毕业</h4><p>我们引入了 <code>SelinuxProfile</code> 对象的 <code>v1alpha2</code> 版本。
这个版本从对象中删除了原始的通用中间语言 (CIL)，并添加了一种简单的策略语言来简化编写和解析体验。</p><p>此外，我们还引入了 <code>RawSelinuxProfile</code> 对象。该对象包含策略的包装和原始表示。
引入此对象是为了让人们能够尽快将他们现有的策略付诸实现。但是，策略的验证是在这里完成的。</p><h3 id=apparmor-支持>AppArmor 支持</h3><p>0.4.0 版本引入了对 AppArmor 的初始支持，允许用户通过使用新的
<a href=https://github.com/kubernetes-sigs/security-profiles-operator/blob/main/deploy/base/crds/apparmorprofile.yaml>AppArmorProfile</a>
在集群节点中 CRD 加载或卸载 AppArmor 配置文件。</p><p>要启用 AppArmor 支持，请使用 SPO 配置的 <a href=https://github.com/kubernetes-sigs/security-profiles-operator/blob/main/examples/config.yaml#L10>enableAppArmor 特性门控</a>开关。
然后使用我们的 <a href=https://github.com/kubernetes-sigs/security-profiles-operator/blob/main/examples/apparmorprofile.yaml>apparmor 示例</a> 在集群中部署你第一个配置文件。</p><h3 id=指标>指标</h3><p>Operator 现在能够公开在我们的新<a href=https://github.com/kubernetes-sigs/security-profiles-operator/blob/71b3915/installation-usage.md#using-metrics>指标文档</a>中详细描述的指标。
我们决定使用 <a href=https://github.com/brancz/kube-rbac-proxy>kube-rbac-proxy</a> 来保护指标检索过程，
同时我们提供了一个额外的 <code>spo-metrics-client</code> 集群角色（和绑定）以从集群内检索指标。
如果你使用 <a href=https://www.redhat.com/en/technologies/cloud-computing/openshift>OpenShift</a>，
那么我们提供了一个开箱即用的 <a href=https://github.com/kubernetes-sigs/security-profiles-operator/blob/71b3915/installation-usage.md#automatic-servicemonitor-deployment><code>ServiceMonitor</code></a>
来访问指标。</p><h4 id=可调试性和稳健性>可调试性和稳健性</h4><p>除了所有这些新功能外，我们还决定在内部重组安全配置文件操作程序的部分内容，使其更易于调试和更稳健。
例如，我们现在维护了一个内部 <a href=https://grpc.io>gRPC</a> API，以便在 Operator 内部跨不同功能组件进行通信。
我们还提高了日志增强组件的性能，现在它可以缓存结果，以便更快地检索日志数据。
Operator 可以通过将 <code>verbosity</code> 设置从 <code>0</code> 改为 <code>1</code>，启用更详细的日志模式(<a href=https://github.com/kubernetes-sigs/security-profiles-operator/blob/71b3915/installation-usage.md#set-logging-verbosity>https://github.com/kubernetes-sigs/security-profiles-operator/blob/71b3915/installation-usage.md#set-logging-verbosity</a>)。</p><p>我们还在启动时打印所使用的 <code>libseccomp</code> 和 <code>libbpf</code> 版本，
并通过 <a href=https://github.com/kubernetes-sigs/security-profiles-operator/blob/71b3915/installation-usage.md#enable-cpu-and-memory-profiling><code>enableProfiling</code> 选项</a>
公开每个容器的 CPU 和内存性能分析端点。
Operator 守护程序内部的专用的存活态探测和启动探测现在能进一步改善 Operator 的生命周期管理。</p><h2 id=总结>总结</h2><p>感谢你阅读这次更新。我们期待着 Operater 的未来改进，并希望得到你对最新版本的反馈。
欢迎通过 Kubernetes slack <a href=https://kubernetes.slack.com/messages/security-profiles-operator>#security-profiles-operator</a>
与我们联系，提出任何反馈或问题。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-60a172c0d67264e6951a7d3c15e8bd87>Kubernetes 1.23: StatefulSet PVC 自动删除 (alpha)</h1><div class="td-byline mb-4"><time datetime=2021-12-16 class=text-muted>2021.12.16</time></div><p><strong>作者:</strong> Matthew Cary (谷歌)</p><p>Kubernetes v1.23 为 <a href=/zh-cn/docs/concepts/workloads/controllers/statefulset/>StatefulSets</a>
引入了一个新的 alpha 级策略，用来控制由 StatefulSet 规约模板生成的
<a href=/zh-cn/docs/concepts/storage/persistent-volumes/>PersistentVolumeClaims</a> (PVCs) 的生命周期，
用于当删除 StatefulSet 或减少 StatefulSet 中的 Pods 数量时 PVCs 应该被自动删除的场景。</p><h2 id=它解决了什么问题>它解决了什么问题？</h2><p>StatefulSet 规约中可以包含 Pod 和 PVC 的模板。当副本先被创建时，如果 PVC 还不存在，
Kubernetes 控制面会为该副本自动创建一个 PVC。在 Kubernetes 1.23 版本之前，
控制面不会删除 StatefulSet 创建的 PVCs——这依赖集群管理员或你需要部署一些额外的适用的自动化工具来处理。
管理 PVC 的常见模式是通过手动或使用 Helm 等工具，PVC 的具体生命周期由管理它的工具跟踪。
使用 StatefulSet 时必须自行确定 StatefulSet 创建哪些 PVC，以及它们的生命周期应该是什么。</p><p>在这个新特性之前，当一个 StatefulSet 管理的副本消失时，无论是因为 StatefulSet 减少了它的副本数，
还是因为它的 StatefulSet 被删除了，PVC 及其下层的卷仍然存在，需要手动删除。
当存储数据比较重要时，这样做是合理的，但在许多情况下，这些 PVC 中的持久化数据要么是临时的，
要么可以从另一个源端重建。在这些情况下，删除 StatefulSet 或减少副本后留下的 PVC 及其下层的卷是不必要的，
还会产生成本，需要手动清理。</p><h2 id=新的-statefulset-pvc-保留策略>新的 StatefulSet PVC 保留策略</h2><p>如果你启用这个新 alpha 特性，StatefulSet 规约中就可以包含 PersistentVolumeClaim 的保留策略。
该策略用于控制是否以及何时删除基于 StatefulSet 的 <code>volumeClaimTemplate</code> 属性所创建的 PVCs。
保留策略的首次迭代包含两种可能删除 PVC 的情况。</p><p>第一种情况是 StatefulSet 资源被删除时（这意味着所有副本也被删除），这由 <code>whenDeleted</code> 策略控制的。
第二种情况是 StatefulSet 缩小时，即删除 StatefulSet 部分副本，这由 <code>whenScaled</code> 策略控制。
在这两种情况下，策略即可以是 <code>Retain</code> 不涉及相应 PVCs 的改变，也可以是 <code>Delete</code> 即删除对应的 PVCs。
删除是通过普通的<a href=/zh-cn/docs/concepts/architecture/garbage-collection/>对象删除</a>完成的，
因此，的所有保留策略都会被遵照执行。</p><p>该策略形成包含四种情况的矩阵。我将逐一介绍，并为每一种情况给出一个例子。</p><ul><li><strong><code>whenDeleted</code> 和 <code>whenScaled</code> 都是 <code>Retain</code>。</strong> 这与 StatefulSets 的现有行为一致，
即不删除 PVCs。 这也是默认的保留策略。它适用于 StatefulSet
卷上的数据是不可替代的且只能手动删除的情况。</li></ul><ul><li><strong><code>whenDeleted</code> 是 <code>Delete</code> 但 <code>whenScaled</code> 是 <code>Retain</code>。</strong> 在这种情况下，
只有当整个 StatefulSet 被删除时，PVCs 才会被删除。
如果减少 StatefulSet 副本，PVCs 不会删除，这意味着如果增加副本时，可以从前一个副本重新连接所有数据。
这可能用于临时的 StatefulSet，例如在 CI 实例或 ETL 管道中，
StatefulSet 上的数据仅在 StatefulSet 生命周期内才需要，但在任务运行时数据不易重构。
任何保留状态对于所有先缩小后扩大的副本都是必需的。</li></ul><ul><li><strong><code>whenDeleted</code> 和 <code>whenScaled</code> 都是 <code>Delete</code>。</strong> 当其副本不再被需要时，PVCs 会立即被删除。
注意，这并不包括 Pod 被删除且有新版本被调度的情况，例如当节点被腾空而 Pod 需要迁移到别处时。
只有当副本不再被需要时，如按比例缩小或删除 StatefulSet 时，才会删除 PVC。
此策略适用于数据生命周期短于副本生命周期的情况。即数据很容易重构，
且删除未使用的 PVC 所节省的成本比快速增加副本更重要，或者当创建一个新的副本时，
来自以前副本的任何数据都不可用，必须重新构建。</li></ul><ul><li><strong><code>whenDeleted</code> 是 <code>Retain</code> 但 <code>whenScaled</code> 是 <code>Delete</code>。</strong> 这与前一种情况类似，
在增加副本时用保留的 PVCs 快速重构几乎没有什么益处。例如 Elasticsearch 集群就是使用的这种方式。
通常，你需要增大或缩小工作负载来满足业务诉求，同时确保最小数量的副本（例如：3）。
当减少副本时，数据将从已删除的副本迁移出去，保留这些 PVCs 没有任何用处。
但是，这对临时关闭整个 Elasticsearch 集群进行维护时是很有用的。
如果需要使 Elasticsearch 系统脱机，可以通过临时删除 StatefulSet 来实现，
然后通过重新创建 StatefulSet 来恢复 Elasticsearch 集群。
保存 Elasticsearch 数据的 PVCs 不会被删除，新的副本将自动使用它们。</li></ul><p>查阅<a href=/zh-cn/docs/concepts/workloads/controllers/statefulset/#persistentvolumeclaim-policies>文档</a>
获取更多详细信息。</p><h2 id=下一步是什么>下一步是什么？</h2><p>启用该功能并尝试一下！在集群上启用 <code>StatefulSetAutoDeletePVC</code> 功能，然后使用新策略创建 StatefulSet。
测试一下，告诉我们你的体验！</p><p>我很好奇这个属主引用机制在实践中是否有效。例如，我们意识到 Kubernetes 中没有可以知道谁设置了引用的机制，
因此 StatefulSet 控制器可能会与设置自己的引用的自定义控制器发生冲突。
幸运的是，维护现有的保留行为不涉及任何新属主引用，因此默认行为是兼容的。</p><p>请用标签 <code>sig/apps</code> 标记你报告的任何问题，并将它们分配给 Matthew Cary
(在 GitHub上 <a href=https://github.com/mattcary>@mattcary</a>)。</p><p>尽情体验吧！</p></div><div class=td-content style=page-break-before:always><h1 id=pg-7e6054db1f7d11e2716846cfabd96dd4>Kubernetes 1.23：树内存储向 CSI 卷迁移工作的进展更新</h1><div class="td-byline mb-4"><time datetime=2021-12-10 class=text-muted>2021.12.10</time></div><p><strong>作者</strong>: Jiawei Wang（谷歌）</p><p>自 Kubernetes v1.14 引入容器存储接口（<a href=/blog/2019/01/15/container-storage-interface-ga/>Container Storage Interface, CSI</a>）的工作达到 alpha 阶段后，自 v1.17 起，Kubernetes 树内存储插件（in-tree storage plugin）向 CSI 的迁移基础设施已步入 <a href=/blog/2019/12/09/kubernetes-1-17-feature-csi-migration-beta/>beta 阶段</a>。</p><p>自那时起，Kubernetes 存储特别兴趣组（special interest groups, SIG）及其他 Kubernetes 特别兴趣组就在努力确保这一功能的稳定性和兼容性，为正式发布做准备。
本文旨在介绍该功能的最新开发进展，以及 Kubernetes v1.17 到 v1.23 之间的变化。此外，我还将介绍每个存储插件的 CSI 迁移功能达到正式发布阶段的未来路线图。</p><h2 id=quick-recap-what-is-csi-migration-and-why-migrate>快速回顾：CSI 迁移功能是什么？为什么要迁移？</h2><p>容器存储接口旨在帮助 Kubernetes 取代其现有的树内存储驱动机制──特别是供应商的特定插件。自 v1.13 起，Kubernetes 对<a href=https://github.com/container-storage-interface/spec/blob/master/spec.md#README>容器存储接口</a>的支持工作已达到<a href=/blog/2019/01/15/container-storage-interface-ga/>正式发布阶段</a>。引入对 CSI 驱动的支持，将使得 Kubernetes 和存储后端技术之间的集成工作更易建立和维护。使用 CSI 驱动可以实现更好的可维护性（驱动作者可以决定自己的发布周期和支持生命周期）、减少出现漏洞的机会（得益于更少的树内代码，出现错误的风险会降低。另外，集群操作员可以只选择集群需要的存储驱动）。</p><p>随着更多的 CSI 驱动诞生并进入生产就绪阶段，Kubernetes 存储特别兴趣组希望所有 Kubernetes 用户都能从 CSI 模型中受益──然而，我们不应破坏与现有存储 API 类型的 API 兼容性。对此，我们给出的解决方案是 CSI 迁移：该功能实现将树内存储 API 翻译成等效的 CSI API，并把操作委托给一个替换的 CSI 驱动来完成。</p><p>CSI 迁移工作使存储后端现有的树内存储插件（如 <code>kubernetes.io/gce-pd</code> 或 <code>kubernetes.io/aws-ebs</code>）能够被相应的 <a href=https://kubernetes-csi.github.io/docs/introduction.html>CSI 驱动</a> 所取代。如果 CSI 迁移功能正确发挥作用，Kubernetes 终端用户应该不会注意到有什么变化。现有的 <code>StorageClass</code>、<code>PersistentVolume</code> 和 <code>PersistentVolumeClaim</code> 对象应继续工作。当 Kubernetes 集群管理员更新集群以启用 CSI 迁移功能时，利用到 PVCs<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>（由树内存储插件支持）的现有工作负载将继续像以前一样运作──不过在幕后，Kubernetes 将所有存储管理操作（以前面向树内存储驱动的）交给 CSI 驱动控制。</p><p>举个例子。假设你是 <code>kubernetes.io/gce-pd</code> 用户，在启用 CSI 迁移功能后，你仍然可以使用 <code>kubernetes.io/gce-pd</code> 来配置新卷、挂载现有的 GCE-PD 卷或删除现有卷。所有现有的 API/接口 仍将正常工作──只不过，底层功能调用都将通向 <a href=https://github.com/kubernetes-sigs/gcp-compute-persistent-disk-csi-driver>GCE PD CSI 驱动</a>，而不是 Kubernetes 的树内存储功能。</p><p>这使得 Kubernetes 终端用户可以顺利过渡。另外，对于存储插件的开发者，我们可以减少他们维护树内存储插件的负担，并最终将这些插件从 Kubernetes 核心的二进制中移除。</p><h2 id=what-has-been-changed-and-what-s-new>改进与更新</h2><p>在 Kubernetes v1.17 及更早的工作基础上，此后的发布有了以下一系列改变：</p><h3 id=new-feature-gates>新的特性门控（feature gate）</h3><p>Kubernetes v1.21 弃用了 <code>CSIMigration{provider}Complete</code> 特性参数（feature flag），它们不再生效。取而代之的是名为 <code>InTreePlugin{vendor}Unregister</code> 的新特性参数，它们保留了 <code>CSIMigration{provider}Complete</code> 提供的所有功能。</p><p><code>CSIMigration{provider}Complete</code> 是作为 CSI 迁移功能在所有节点上启用后的补充特性门控于之前引入的。这个参数可注销参数名称中 <code>{provider}</code> 部分所指定的树内存储插件。</p><p>当你启用该特性门控时，你的集群不再使用树内驱动代码，而是直接选择并使用相应的 CSI 驱动。同时，集群并不检查节点上 CSI 迁移功能是否启用，以及 CSI 驱动是否实际部署。</p><p>虽然这一特性门控是一个很好的帮手，但 Kubernetes 存储特别兴趣组（以及，我相信还有很多集群操作员）同样希望有一个特性门控可以让你即使在不启用 CSI 迁移功能时，也能禁用树内存储插件。例如，你可能希望在一个 GCE 集群上禁用 EBS 存储插件，因为 EBS 卷是其他供应商的云（AWS）所专有的。</p><p>为了使这成为可能，Kubernetes v1.21 引入了一个新的特性参数集合：<code>InTreePlugin{vendor}Unregister</code>。</p><p><code>InTreePlugin{vendor}Unregister</code> 是一种特性门控，可以独立于 CSI 迁移功能来启用或禁用。当启用此种特性门控时，组件将不会把相应的树内存储插件注册到支持的列表中。如果集群操作员只启用了这种参数，终端用户将在使用该插件的 PVC<sup id=fnref1:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> 处遇到错误，提示其找不到插件。如果集群操作员不想支持过时的树内存储 API，只支持 CSI，那么他们可能希望启用这种特性门控而不考虑 CSI 迁移功能。</p><h3 id=observability>可观察性</h3><p>Kubernetes v1.21 引入了跟踪 CSI 迁移功能的<a href=https://github.com/kubernetes/kubernetes/issues/98279>指标</a>。你可以使用这些指标来观察你的集群是如何使用存储服务的，以及对该存储的访问使用的是传统的树内驱动还是基于 CSI 的替代。</p><table><thead><tr><th>组件</th><th>指标</th><th>注释</th></tr></thead><tbody><tr><td>Kube-Controller-Manager</td><td>storage_operation_duration_seconds</td><td>一个新的标签 <code>migrated</code> 被添加到指标中，以表明该存储操作是否由 CSI 迁移功能操作（字符串值为 <code>true</code> 表示启用，<code>false</code> 表示未启用）。</td></tr><tr><td>Kubelet</td><td>csi_operations_seconds</td><td>新的指标提供的标签包括 <code>driver_name</code>、<code>method_name</code>、<code>grpc_status_code</code> 和 <code>migrated</code>。这些标签的含义与 <code>csi_sidecar_operations_seconds</code> 相同。</td></tr><tr><td>CSI Sidecars(provisioner, attacher, resizer)</td><td>csi_sidecar_operations_seconds</td><td>一个新的标签 <code>migrated</code> 被添加到指标中，以表明该存储操作是否由 CSI 迁移功能操作（字符串值为 <code>true</code> 表示启用，<code>false</code> 表示未启用）。</td></tr></tbody></table><h3 id=bug-fixes-and-feature-improvement>错误修复和功能改进</h3><p>籍由 beta 测试人员的帮助，我们修复了许多错误──如悬空附件、垃圾收集、拓扑标签错误等。</p><h3 id=cloud-provider-cluster-lifecycle-collaboration>与 Kubernetes 云提供商特别兴趣组、集群生命周期特别兴趣组的合作</h3><p>Kubernetes 存储特别兴趣组与云提供商特别兴趣组和集群生命周期特别兴趣组，正为了 CSI 迁移功能上线而密切合作。</p><p>如果你采用托管 Kubernetes 服务，请询问你的供应商是否有什么工作需要完成。在许多情况下，供应商将管理迁移，你不需要做额外的工作。</p><p>如果你使用的是 Kubernetes 的发行版，请查看其官方文档，了解对该功能的支持情况。对于已进入正式发布阶段的 CSI 迁移功能，Kubernetes 存储特别兴趣组正与Kubernetes 集群生命周期特别兴趣组合作，以便在这些功能于 Kubernetes 中可用时，使迁移机制也进入到周边工具（如 kubeadm）中。</p><h2 id=timeline-and-status>时间计划及当前状态</h2><p>各驱动的当前发布及目标发布如下表所示：</p><table><thead><tr><th>驱动</th><th>Alpha</th><th>Beta（启用树内插件）</th><th>Beta（默认启用）</th><th>正式发布</th><th>目标：移除“树内存储插件”</th></tr></thead><tbody><tr><td>AWS EBS</td><td>1.14</td><td>1.17</td><td>1.23</td><td>1.24 (Target)</td><td>1.26 (Target)</td></tr><tr><td>GCE PD</td><td>1.14</td><td>1.17</td><td>1.23</td><td>1.24 (Target)</td><td>1.26 (Target)</td></tr><tr><td>OpenStack Cinder</td><td>1.14</td><td>1.18</td><td>1.21</td><td>1.24 (Target)</td><td>1.26 (Target)</td></tr><tr><td>Azure Disk</td><td>1.15</td><td>1.19</td><td>1.23</td><td>1.24 (Target)</td><td>1.26 (Target)</td></tr><tr><td>Azure File</td><td>1.15</td><td>1.21</td><td>1.24 (Target)</td><td>1.25 (Target)</td><td>1.27 (Target)</td></tr><tr><td>vSphere</td><td>1.18</td><td>1.19</td><td>1.24 (Target)</td><td>1.25 (Target)</td><td>1.27 (Target)</td></tr><tr><td>Ceph RBD</td><td>1.23</td><td></td><td></td><td></td><td></td></tr><tr><td>Portworx</td><td>1.23</td><td></td><td></td><td></td><td></td></tr></tbody></table><p>以下存储驱动将不会支持 CSI 迁移功能。其中 ScaleIO 驱动已经被移除；其他驱动都被弃用，并将从 Kubernetes 核心中删除。</p><table><thead><tr><th>驱动</th><th>被弃用</th><th>代码移除</th></tr></thead><tbody><tr><td>ScaleIO</td><td>1.16</td><td>1.22</td></tr><tr><td>Flocker</td><td>1.22</td><td>1.25 (Target)</td></tr><tr><td>Quobyte</td><td>1.22</td><td>1.25 (Target)</td></tr><tr><td>StorageOS</td><td>1.22</td><td>1.25 (Target)</td></tr></tbody></table><h2 id=what-s-next>下一步的计划</h2><p>随着更多的 CSI 驱动进入正式发布阶段，我们希望尽快将整个 CSI 迁移功能标记为正式发布状态。我们计划在 Kubernetes v1.26 和 v1.27 之前移除云提供商树内存储插件的代码。</p><h2 id=what-should-i-do-as-a-user>作为用户，我应该做什么？</h2><p>请注意，Kubernetes 存储系统的所有新功能（如卷快照）将只被添加到 CSI 接口。因此，如果你正在启动一个新的集群、首次创建有状态的应用程序，或者需要这些新功能，我们建议你在本地使用 CSI 驱动（而不是树内卷插件 API）。遵循<a href=https://kubernetes-csi.github.io/docs/drivers.html>最新的 CSI 驱动用户指南</a>并使用新的 CSI API。</p><p>然而，如果您选择沿用现有集群或继续使用传统卷 API 的规约，CSI 迁移功能将确保我们通过新 CSI 驱动继续支持这些部署。但是，如果您想利用快照等新功能，则需要进行手动迁移，将现有的树内持久卷重新导入为 CSI 持久卷。</p><h2 id=how-do-i-get-involved>我如何参与其中？</h2><p>Kubernetes Slack 频道 <a href=https://kubernetes.slack.com/messages/csi-migration>#csi-migration</a> 以及任何一个标准的 <a href=https://github.com/kubernetes/community/blob/master/sig-storage/README.md#contact>SIG Storage 通信频道</a>都是与 Kubernetes 存储特别兴趣组和迁移工作组团队联系的绝佳媒介。</p><p>该项目，和其他所有 Kubernetes 项目一样，是许多来自不同背景的贡献者共同努力的结果。我们非常感谢在过去几个季度里挺身而出帮助推动项目发展的贡献者们：</p><ul><li>Michelle Au (msau42)</li><li>Jan Šafránek (jsafrane)</li><li>Hemant Kumar (gnufied)</li></ul><p>特别感谢以下人士对 CSI 迁移功能的精辟评论、全面考虑和宝贵贡献：</p><ul><li>Andy Zhang (andyzhangz)</li><li>Divyen Patel (divyenpatel)</li><li>Deep Debroy (ddebroy)</li><li>Humble Devassy Chirammal (humblec)</li><li>Jing Xu (jingxu97)</li><li>Jordan Liggitt (liggitt)</li><li>Matthew Cary (mattcary)</li><li>Matthew Wong (wongma7)</li><li>Neha Arora (nearora-msft)</li><li>Oksana Naumov (trierra)</li><li>Saad Ali (saad-ali)</li><li>Tim Bannister (sftim)</li><li>Xing Yang (xing-yang)</li></ul><p>有兴趣参与 CSI 或 Kubernetes 存储系统任何部分的设计和开发的人，请加入 <a href=https://github.com/kubernetes/community/tree/master/sig-storage>Kubernetes 存储特别兴趣组</a>。我们正在迅速成长，并一直欢迎新的贡献者。</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>持久卷申领（PersistentVolumeClaim，PVC）&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref1:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><div class=td-content style=page-break-before:always><h1 id=pg-002ba8f6565ae3adeaa159c95f0f0e5e>Kubernetes 1.23：IPv4/IPv6 双协议栈网络达到 GA</h1><div class="td-byline mb-4"><time datetime=2021-12-08 class=text-muted>2021.12.08</time></div><p><strong>作者:</strong> Bridget Kromhout (微软)</p><p>“Kubernetes 何时支持 IPv6？” 自从 k8s v1.9 版本中首次添加对 IPv6 的 alpha 支持以来，这个问题的讨论越来越频繁。
虽然 Kubernetes 从 v1.18 版本开始就支持纯 IPv6 集群，但当时还无法支持 IPv4 迁移到 IPv6。
<a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-network/563-dual-stack/>IPv4/IPv6 双协议栈网络</a>
在 Kubernetes v1.23 版本中进入正式发布（GA）阶段。</p><p>让我们来看看双协议栈网络对你来说意味着什么？</p><h2 id=更新-service-api>更新 Service API</h2><p><a href=/zh-cn/docs/concepts/services-networking/service/>Services</a> 在 1.20 版本之前是单协议栈的，
因此，使用两个 IP 协议族意味着需为每个 IP 协议族创建一个 Service。在 1.20 版本中对用户体验进行简化，
重新实现了 Service 以支持两个 IP 协议族，这意味着一个 Service 就可以处理 IPv4 和 IPv6 协议。
对于 Service 而言，任意的 IPv4 和 IPv6 协议组合都可以实现负载均衡。</p><p>Service API 现在有了支持双协议栈的新字段，取代了单一的 ipFamily 字段。</p><ul><li>你可以通过将 <code>ipFamilyPolicy</code> 字段设置为 <code>SingleStack</code>、<code>PreferDualStack</code> 或
<code>RequireDualStack</code> 来设置 IP 协议族。Service 可以在单协议栈和双协议栈之间进行转换(在某些限制内)。</li><li>设置 <code>ipFamilies</code> 为指定的协议族列表，可用来设置使用协议族的顺序。</li><li>'clusterIPs' 的能力在涵盖了之前的 'clusterIP'的情况下，还允许设置多个 IP 地址。
所以不再需要运行重复的 Service，在两个 IP 协议族中各运行一个。你可以在两个 IP 协议族中分配集群 IP 地址。</li></ul><p>请注意，Pods 也是双协议栈的。对于一个给定的 Pod，不可能在同一协议族中设置多个 IP 地址。</p><h2 id=默认行为仍然是单协议栈>默认行为仍然是单协议栈</h2><p>从 1.20 版本开始，重新实现的双协议栈服务处于 Alpha 阶段，无论集群是否配置了启用双协议栈的特性标志，
Kubernetes 的底层网络都已经包括了双协议栈。</p><p>Kubernetes 1.23 删除了这个特性标志，说明该特性已经稳定。
如果你想要配置双协议栈网络，这一能力总是存在的。
你可以将集群网络设置为 IPv4 单协议栈 、IPv6 单协议栈或 IPV4/IPV6 双协议栈 。</p><p>虽然 Service 是根据你的配置设置的，但 Pod 默认是由 CNI 插件设置的。
如果你的 CNI 插件分配单协议栈 IP，那么就是单协议栈，除非 <code>ipFamilyPolicy</code> 设置为 <code>PreferDualStack</code> 或 <code>RequireDualStack</code>。
如果你的 CNI 插件分配双协议栈 IP，则 <code>pod.status.PodIPs</code> 默认为双协议栈。</p><p>尽管双协议栈是可用的，但并不强制你使用它。
在<a href=/zh-cn/docs/concepts/services-networking/dual-stack/#dual-stack-service-configuration-scenarios>双协议栈服务配置</a>
文档中的示例列出了可能出现的各种场景.</p><h2 id=现在尝试双协议栈>现在尝试双协议栈</h2><p>虽然现在上游 Kubernetes 支持<a href=/zh-cn/docs/concepts/services-networking/dual-stack/>双协议栈网络</a>
作为 GA 或稳定特性，但每个提供商对双协议栈 Kubernetes 的支持可能会有所不同。节点需要提供可路由的 IPv4/IPv6 网络接口。
Pod 需要是双协议栈的。<a href=/zh-cn/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/>网络插件</a>
是用来为 Pod 分配 IP 地址的，所以集群需要支持双协议栈的网络插件。一些容器网络接口（CNI）插件支持双协议栈，例如 kubenet。</p><p>支持双协议栈的生态系统在不断壮大；你可以使用
<a href=/zh-cn/docs/setup/production-environment/tools/kubeadm/dual-stack-support/>kubeadm 创建双协议栈集群</a>,
在本地尝试用 <a href=https://kind.sigs.k8s.io/docs/user/configuration/#ip-family>KIND 创建双协议栈集群</a>，
还可以将双协议栈集群部署到云上（在查阅 CNI 或 kubenet 可用性的文档之后）</p><h2 id=加入-network-sig>加入 Network SIG</h2><p>SIG-Network 希望从双协议栈网络的社区体验中学习，以了解更多不断变化的需求和你的用例信息。
<a href="https://www.youtube.com/watch?v=uZ0WLxpmBbY&list=PLj6h78yzYM2Nd1U4RMhv7v88fdiFqeYAP&index=4">SIG-network 更新了来自 KubeCon 2021 北美大会的视频</a>
总结了 SIG 最近的更新，包括双协议栈将在 1.23 版本中稳定。</p><p>当前 SIG-Network 在 GitHub 上的 <a href=https://github.com/orgs/kubernetes/projects/10>KEPs</a> 和
<a href="https://github.com/kubernetes/kubernetes/issues?q=is%3Aopen+is%3Aissue+label%3Asig%2Fnetwork">issues</a>
说明了该 SIG 的重点领域。<a href=https://github.com/kubernetes/enhancements/issues/2438>双协议栈 API 服务器</a>
是一个考虑贡献的方向。</p><p><a href=https://github.com/kubernetes/community/tree/master/sig-network#meetings>SIG-Network 会议</a>
是一个友好、热情的场所，你可以与社区联系并分享你的想法。期待你的加入！</p><h2 id=致谢>致谢</h2><p>许多 Kubernetes 贡献者为双协议栈网络做出了贡献。感谢所有贡献了代码、经验报告、文档、代码审查以及其他工作的人。
Bridget Kromhout 在 <a href=https://containerjournal.com/features/dual-stack-networking-in-kubernetes/>Kubernetes的双协议栈网络</a>
中详细介绍了这项社区工作。Tim Hockin 和 Khaled (Kal) Henidak 在 2019 年的 KubeCon 大会演讲
（<a href="https://www.youtube.com/watch?v=o-oMegdZcg4">Kubernetes 通往 IPv4/IPv6 双协议栈的漫漫长路</a>）
和 Lachlan Evenson 在 2021 年演讲（<a href="https://www.youtube.com/watch?v=o-oMegdZcg4">我们来啦，Kubernetes 双协议栈网络</a>）
中讨论了双协议栈的发展旅程，耗时 5 年和海量代码。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-157c2c70ed868b35cf1dbc8929b9a9ee>公布 2021 年指导委员会选举结果</h1><div class="td-byline mb-4"><time datetime=2021-11-08 class=text-muted>2021.11.08</time></div><p><strong>作者</strong>：Kaslin Fields</p><p><a href=https://github.com/kubernetes/community/tree/master/events/elections/2021>2021 年指导委员会选举</a>现已完成。
Kubernetes 指导委员会由 7 个席位组成，其中 4 个席位将在 2021 年进行选举。
新任委员会成员任期 2 年，所有成员均由 Kubernetes 社区选举产生。</p><p>这个社区机构非常重要，因为它监督整个 Kubernetes 项目的治理。
你可以在其<a href=https://github.com/kubernetes/steering/blob/master/charter.md>章程</a>中了解更多关于指导委员会的角色。</p><h2 id=选举结果>选举结果</h2><p>祝贺当选的委员会成员，他们的两年任期即刻生效（按 GitHub handle 字母排序）:</p><ul><li><strong>Christoph Blecker（<a href=https://github.com/cblecker>@cblecker</a>）， 红帽</strong></li><li><strong>Stephen Augustus（<a href=https://github.com/justaugustus>@justaugustus</a>）， 思科</strong></li><li><strong>Paris Pittman（<a href=https://github.com/parispittman>@parispittman</a>)， 苹果</strong></li><li><strong>Tim Pepper（<a href=https://github.com/tpepper>@tpepper</a>）， VMware</strong></li></ul><p>他们加入永久成员：</p><ul><li><strong>Davanum Srinivas（<a href=https://github.com/dims>@dims</a>）， VMware</strong></li><li><strong>Jordan Liggitt （<a href=https://github.com/liggitt>@liggitt</a>）， 谷歌</strong></li><li><strong>Bob Killen （<a href=https://github.com/mrbobbytables>@mrbobbytables</a>）， 谷歌</strong></li></ul><p>Paris Pittman 和 Christoph Blecker 将回到指导委员会。</p><h2 id=非常感谢>非常感谢</h2><p>感谢并祝贺完成本轮成功选举的选举官们:</p><ul><li>Alison Dowdney, (<a href=https://github.com/alisondy>@alisondy</a>)</li><li>Noah Kantrowitz (<a href=https://github.com/coderanger>@coderanger</a>)</li><li>Josh Berkus (<a href=https://github.com/jberkus>@jberkus</a>)</li></ul><p>特别感谢 k8s-infra 联络员 Arnaud Meukam（<a href=https://github.com/ameukam>@ameukam</a>），
他在社区的基础设施上启动了我们的投票软件。</p><p>感谢荣誉退休的指导委员会成员。对你们之前对社区的贡献表示感谢:</p><ul><li>Derek Carr (<a href=https://github.com/derekwaynecarr>@derekwaynecarr</a>)</li><li>Nikhita Raghunath (<a href=https://github.com/nikhita>@nikhita</a>)</li></ul><p>感谢所有前来参加竞选的候选人。</p><h2 id=参与指导委员会>参与指导委员会</h2><p>与所有 Kubernetes 一样，这个管理机构对所有人开放。
你可以查看指导委员会的<a href=https://github.com/kubernetes/steering/projects/1>待办事项</a>，
通过在他们的 <a href=https://github.com/kubernetes/steering>repo</a>
中提交一个 issue 或创建一个 PR 来参与讨论。
他们在<a href=https://github.com/kubernetes/steering>每月的第一个星期一上午 9:30</a> 举行公开会议，
并定期参加会见我们的贡献者活动。也可以通过他们的公共邮件列表 <a href=mailto:steering@kubernetes.io>steering@kubernetes.io</a> 联系他们。</p><p>你可以在 <a href="https://www.youtube.com/playlist?list=PL69nYSiGNLP1yP1B_nd9-drjoxp0Q14qM">YouTube 播放列表</a>
上观看之前的会议视频，了解指导委员会的会议讨论内容。</p><hr><p><em>本文是由<a href=https://github.com/kubernetes/community/tree/master/communication/marketing-team#contributor-marketing>上游营销工作组</a>撰写的。
如果你想撰写有关 Kubernetes 社区的故事，请了解更多关于我们的信息。</em></p></div><div class=td-content style=page-break-before:always><h1 id=pg-2e6026465182b38bab0f85ae052d3b0b>关注 SIG Node</h1><div class="td-byline mb-4"><time datetime=2021-09-27 class=text-muted>2021.09.27</time></div><p><strong>Author:</strong> Dewan Ahmed, Red Hat</p><h2 id=介绍>介绍</h2><p>在 Kubernetes 中，一个 <em>Node</em> 是你集群中的某台机器。
<a href=https://github.com/kubernetes/community/tree/master/sig-node>SIG Node</a> 负责这一非常重要的 Node 组件并支持各种子项目，
如 Kubelet, Container Runtime Interface (CRI) 以及其他支持 Pod 和主机资源间交互的子项目。
在这篇文章中，我们总结了和 <a href=https://twitter.com/ehashdn>Elana Hashman (EH)</a> & <a href=https://twitter.com/SergeyKanzhelev>Sergey Kanzhelev (SK)</a> 的对话，是他们带领我们了解作为此 SIG 一份子的各个方面，并分享一些关于其他人如何参与的见解。</p><h2 id=我们的对话总结>我们的对话总结</h2><h3 id=你能告诉我们一些关于-sig-node-的工作吗>你能告诉我们一些关于 SIG Node 的工作吗？</h3><p>SK：SIG Node 是一个垂直 SIG，负责支持 Pod 和主机资源之间受控互动的组件。我们管理被调度到节点上的 Pod 的生命周期。
这个 SIG 的重点是支持广泛的工作负载类型，包括具有硬件特性或性能敏感要求的工作负载。同时保持节点上 Pod 之间的隔离边界，以及 Pod 和主机的隔离边界。
这个 SIG 维护了相当多的组件，并有许多外部依赖（如容器运行时间或操作系统功能），这使得我们处理起来十分复杂。但我们战胜了这种复杂度，旨在不断提高节点的可靠性。</p><h3 id=你能再解释一下-sig-node-是一种垂直-sig-的含义吗>你能再解释一下 “SIG Node 是一种垂直 SIG” 的含义吗？</h3><p>EH：有两种 SIG：横向和垂直。横向 SIG 关注 Kubernetes 中每个组件的特定功能：例如，SIG Security 考虑 Kubernetes 中每个组件的安全方面，或者 SIG Instrumentation 关注 Kubernetes 中每个组件的日志、度量、跟踪和事件。
这样的 SIG 并不太会拥有大量的代码。</p><p>相反，垂直 SIG 拥有一个单一的组件，并负责批准和合并该代码库的补丁。
SIG Node 拥有 "Node" 的垂直性，与 kubelet 和它的生命周期有关。这包括 kubelet 本身的代码，以及节点控制器、容器运行时接口和相关的子项目，比如节点问题检测器。</p><h3 id=ci-子项目是如何开始的-这是专门针对-sig-node-的吗-它对-sig-有什么帮助>CI 子项目是如何开始的？这是专门针对 SIG Node 的吗？它对 SIG 有什么帮助？</h3><p>SK：该子项目是在其中一个版本因关键测试的大量测试失败而受阻后开始跟进的。
这些测试并不是一下子就开始下降的，而是持续的缺乏关注导致了测试质量的缓慢下降。
SIG Node 一直将质量和可靠性放在首位，组建这个子项目是强调这一优先事项的一种方式。</p><h3 id=作为-issue-和-pr-数量第三大的-sig-你们-sig-是如何兼顾这么多工作的>作为 issue 和 PR 数量第三大的 SIG，你们 SIG 是如何兼顾这么多工作的？</h3><p>EH：这归功于有组织性。当我在 2021 年 1 月增加对 SIG 的贡献时，我发现自己被大量的 PR 和 issue 淹没了，不知道该从哪里开始。
我们已经在 CI 子项目板上跟踪与测试有关的 issue 和 PR 请求，但这缺少了很多 bug 修复和功能工作。
因此，我开始为我们剩余的 PR 建立一个分流板，这使我能够根据状态和采取的行动对其进行分类，并为其他贡献者记录它的用途。
在过去的两个版本中，我们关闭或合并了超过 500 个 issue 和 PR。Kubernetes devstats 显示，我们的速度因此而大大提升。</p><p>6月，我们进行了第一次 bug 清除活动，以解决针对 SIG Node 的积压问题，确保它们被正确归类。
在这次 48 小时的全球活动中，我们关闭了 130 多个问题，但截至发稿时，我们仍有 333 个问题没有解决。</p><h3 id=为什么新的和现有的贡献者应该考虑加入-node-兴趣小组呢>为什么新的和现有的贡献者应该考虑加入 Node 兴趣小组呢？</h3><p>SK：作为 SIG Node 的贡献者会带给你有意义且有用的技能和认可度。
了解 Kubelet 的内部结构有助于构建更好的应用程序，调整和优化这些应用程序，并在 issue 排查上获得优势。
如果你是一个新手贡献者，SIG Node 为你提供了基础知识，这是理解其他 Kubernetes 组件的设计方式的关键。
现在的贡献者可能会受益于许多功能都需要 SIG Node 的这种或那种变化。所以成为 SIG Node 的贡献者有助于更快地建立其他 SIG 的功能。</p><p>SIG Node 维护着许多组件，其中许多组件都依赖于外部项目或操作系统功能。这使得入职过程相当冗长和苛刻。
但如果你愿意接受挑战，总有一个地方适合你，也有一群人支持你。</p><h3 id=你是如何帮助新手贡献者开始工作的>你是如何帮助新手贡献者开始工作的？</h3><p>EH：在 SIG Node 的起步工作可能是令人生畏的，因为有太多的工作要做，我们的 SIG 会议非常大，而且很难找到一个开始的地方。</p><p>我总是鼓励新手贡献者在他们已经有一些投入的方向上更进一步。
在 SIG Node 中，这可能意味着自愿帮助修复一个只影响到你个人的 bug，或者按优先级去分流你关心的 bug。</p><p>为了尽快了解任何开源代码库，你可以采取两种策略：从深入探索一个特定的问题开始，然后根据需要扩展你的知识边缘，或者单纯地尽可能多的审查 issues 和变更请求，以了解更高层次的组件工作方式。
最终，如果你想成为一名 Node reviewer 或 approver，两件事是不可避免的。</p><p><a href=https://twitter.com/dims>Davanum Srinivas</a> 和我各自举办了一次小组辅导，以帮助教导新手贡献者成为 Node reviewer 的技能，如果有兴趣，我们可以努力寻找一个导师来举办另一次会议。
我也鼓励新手贡献者参加我们的 Node CI 子项目会议：它的听众较少，而且我们不记录分流会议，所以它可以是一个比较温和的方式来开始 SIG 之旅。</p><h3 id=有什么特别的技能者是你想招募的吗-对-sig-可用性的贡献者可能会学到什么技能>有什么特别的技能者是你想招募的吗？对 SIG 可用性的贡献者可能会学到什么技能？</h3><p>SK：SIG Node 在大相径庭的领域从事许多工作流。所有这些领域都是系统级的。
对于典型的代码贡献，你需要对建立和善用低级别的 API 以及编写高性能和可靠的组件有热情。
作为一个贡献者，你将学习如何调试和排除故障，剖析和监控这些组件，以及由这些组件运行的用户工作负载。
通常情况下，由于节点正在运行生产工作负载，所以对节点的访问是有限的，甚至是没有的。</p><p>另一种贡献方式是帮助记录 SIG Node 的功能。这种类型的贡献需要对功能有深刻的理解，并有能力用简单的术语解释它们。</p><p>最后，我们一直在寻找关于如何最好地运行你的工作负载的反馈。来解释一下它的具体情况，以及 SIG Node 组件中的哪些功能可能有助于更好地运行它。</p><h3 id=你在哪些方面得到了积极的反馈-以及-sig-node-的下一步计划是什么>你在哪些方面得到了积极的反馈，以及 SIG Node 的下一步计划是什么？</h3><p>EH：在过去的一年里，SIG Node 采用了一些新的流程来帮助管理我们的功能开发和 Kubernetes 增强提议，其他 SIG 也向我们寻求在管理大型工作负载方面的灵感。
我希望这是一个我们可以继续领导并进一步迭代的领域。</p><p>现在，我们在新功能和废弃功能之间保持了很好的平衡。
废弃未使用或难以维护的功能有助于我们控制技术债务和维护负荷，例子包括 dockershim 和 DynamicKubeletConfiguration 的废弃。
新功能将在终端用户的集群中释放更多的功能，包括令人兴奋的功能，如支持 cgroups v2、交换内存、优雅的节点关闭和设备管理策略。</p><h3 id=最后你有什么想法-资源要分享吗>最后你有什么想法/资源要分享吗？</h3><p>SK/EH：进入任何开源社区都需要时间和努力。一开始 SIG Node 可能会因为参与者的数量、工作量和项目范围而让你不知所措。但这是完全值得的。
请加入我们这个热情的社区! <a href=https://github.com/kubernetes/community/tree/master/sig-node>SIG Node GitHub Repo</a>
包含许多有用的资源，包括 Slack、邮件列表和其他联系信息。</p><h2 id=总结>总结</h2><p>SIG Node 举办了一场 <a href="https://www.youtube.com/watch?v=z5aY4e2RENA">KubeCon + CloudNativeCon Europe 2021 talk</a>，对他们强大的 SIG 进行了介绍和深入探讨。
加入 SIG 的会议，了解最新的研究成果，未来一年的计划是什么，以及如何作为贡献者参与到上游的 Node 团队中!</p></div><div class=td-content style=page-break-before:always><h1 id=pg-d273515f6d183364e8cf63510d4d166f>更新 NGINX-Ingress 以使用稳定的 Ingress API</h1><div class="td-byline mb-4"><time datetime=2021-07-26 class=text-muted>2021.07.26</time></div><p><strong>作者：</strong> James Strong, Ricardo Katz</p><p>对于所有 Kubernetes API，一旦它们被正式发布（GA），就有一个创建、维护和最终弃用它们的过程。
networking.k8s.io API 组也不例外。
即将发布的 Kubernetes 1.22 版本将移除几个与网络相关的已弃用 API：</p><ul><li><a href=/zh-cn/docs/concepts/services-networking/ingress/#ingress-class>IngressClass</a> 的 <code>networking.k8s.io/v1beta1</code> API 版本</li><li><a href=/zh-cn/docs/concepts/services-networking/ingress/>Ingress</a> 的所有 Beta 版本: <code>extensions/v1beta1</code> 和 <code>networking.k8s.io/v1beta1</code></li></ul><p>在 v1.22 Kubernetes 集群上，你能够通过稳定版本（v1）的 API 访问 Ingress 和 IngressClass 对象，
但无法通过其 Beta API 访问。</p><p>自 <a href=https://github.com/kubernetes/kubernetes/issues/43214>2017</a>、
<a href=https://kubernetes.io/blog/2019/07/18/api-deprecations-in-1-16/>2019</a>
以来一直讨论关于 Kubernetes 1.16 弃用 API 的更改，
最近的讨论是在 KEP-1453：<a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-network/1453-ingress-api#122>Ingress API 毕业到 GA</a>。</p><p>在社区会议中，网络特别兴趣小组决定继续支持带有 0.47.0 版本 Ingress-NGINX 的早于 1.22 版本的 Kubernetes。
在 Kubernetes 1.22 发布后，对 Ingress-NGINX 的支持将持续六个月。
团队会根据需要解决 Ingress-NGINX 的额外错误修复和 CVE 问题。</p><p>Ingress-NGINX 将拥有独立的分支和发布版本来支持这个模型，与 Kubernetes 项目流程相一致。
Ingress-NGINX 项目的未来版本将跟踪和支持最新版本的 Kubernetes。</p><table><caption style=display:none>Kubernetes 各版本支持的 Ingress NGINX 版本</caption><thead><tr><th style=text-align:left>Kubernetes 版本</th><th style=text-align:left>Ingress-NGINX 版本</th><th style=text-align:left>公告</th></tr></thead><tbody><tr><td style=text-align:left>v1.22</td><td style=text-align:left>v1.0.0-alpha.2</td><td style=text-align:left>新特性，以及错误修复。</td></tr><tr><td style=text-align:left>v1.21</td><td style=text-align:left>v0.47.x</td><td style=text-align:left>仅修复安全问题或系统崩溃的错误。没有宣布终止支持日期。</td></tr><tr><td style=text-align:left>v1.20</td><td style=text-align:left>v0.47.x</td><td style=text-align:left>仅修复安全问题或系统崩溃的错误。没有宣布终止支持日期。</td></tr><tr><td style=text-align:left>v1.19</td><td style=text-align:left>v0.47.x</td><td style=text-align:left>仅修复安全问题或系统崩溃的错误。仅在 Kubernetes v1.22.0 发布后的 6 个月内提供修复支持。</td></tr></tbody></table><p>由于 Kubernetes 1.22 中的更新，<strong>v0.47.0</strong> 将无法与 Kubernetes 1.22 一起使用。</p><h2 id=你需要做什么>你需要做什么</h2><p>团队目前正在升级 Ingress-NGINX 以支持向 v1 的迁移，
你可以在<a href=https://github.com/kubernetes/ingress-nginx/pull/7156>此处</a>跟踪进度。
在对 Ingress v1 的支持完成之前，
我们不会对功能进行改进。</p><p>同时，团队会确保没有兼容性问题：</p><ul><li>更新到最新的 Ingress-NGINX 版本，
目前是 <a href=https://github.com/kubernetes/ingress-nginx/releases/tag/controller-v0.47.0>v0.47.0</a>。</li></ul><ul><li>Kubernetes 1.22 发布后，请确保使用的是支持 Ingress 和 IngressClass 稳定 API 的最新版本的 Ingress-NGINX。</li></ul><ul><li>使用集群版本 >= 1.19 测试 Ingress-NGINX 版本 v1.0.0-alpha.2，并将任何问题报告给项目 GitHub 页面。</li></ul><p>欢迎社区对此工作的反馈和支持。
Ingress-NGINX 子项目定期举行社区会议，
我们会讨论这个问题以及项目面临的其他问题。
有关子项目的更多信息，请参阅 <a href=https://github.com/kubernetes/community/tree/master/sig-network>SIG Network</a>。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-2e15afab69477e577a622023be9af007>聚焦 SIG Usability</h1><div class="td-byline mb-4"><time datetime=2021-07-15 class=text-muted>2021.07.15</time></div><p><strong>作者：</strong> Kunal Kushwaha、Civo</p><h2 id=介绍>介绍</h2><p>你是否有兴趣了解 <a href=https://github.com/kubernetes/community/tree/master/sig-usability>SIG Usability</a> 做什么？
你是否想知道如何参与？那你来对地方了。
SIG Usability 旨在让 Kubernetes 更易于触达新的伙伴，其主要活动是针对社区实施用户调研。
在本博客中，我们总结了与 Gaby Moreno 的对话，
他向我们介绍了成为 SIG 成员的各个方面，并分享了一些关于其他人如何参与的见解。</p><p>Gaby 是 SIG Usability 的联合负责人。
她在 IBM 担任产品设计师，
喜欢研究 Kubernetes、OpenShift、Terraform 和 Cloud Foundry 等开放式混合云技术的用户体验。</p><h2 id=我们谈话的摘要>我们谈话的摘要</h2><h3 id=问-你能告诉我们一些关于-sig-usability-的事情吗>问：你能告诉我们一些关于 SIG Usability 的事情吗？</h3><p>答：简单而言，启动 SIG Usability 的原因是那时 Kubernetes 没有专门的用户体验团队。
SIG Usability 的关注领域集中在为 Kubernetes 项目最终客户提供的易用性上。
主要活动是社区的用户调研，包括对 Kubernetes 用户宣讲。</p><p>所涉及的包括用户体验和可访问性等方面。
SIG 的目标是确保 Kubernetes 项目能够最大限度地被具有各类不同基础和能力的人使用，
例如引入文档的国际化并确保其开放性。</p><h3 id=问-为什么新的和现有的贡献者应该考虑加入-sig-usability>问：为什么新的和现有的贡献者应该考虑加入 SIG Usability？</h3><p>答：新的贡献者可以在很多领域着手。例如：</p><ul><li>用户研究项目可以让人们帮助了解最终用户体验的可用性，包括错误消息、端到端任务等。</li></ul><ul><li>Kubernetes 社区组件的可访问性指南，包括：文档的国际化、色盲人群的颜色选择、
确保与屏幕阅读器技术的兼容性、核心 UI 组件的用户界面设计等等。</li></ul><h3 id=问-如何帮助新的贡献者入门>问：如何帮助新的贡献者入门？</h3><p>答：新的贡献者们刚开始可以旁观参与其中一个用户访谈，浏览用户访谈记录，分析这些记录并设计调查过程。</p><p>SIG Usability 也对新的项目想法持开放态度。
如果你有想法，我们将尽我们所能支持它。
我们有定期的 SIG 会议，人们可以现场提问。
这些会议也会录制会议视频，方便那些可能无法参会的人。
与往常一样，你也可以在 Slack 上与我们联系。</p><h3 id=问-调查包括什么>问：调查包括什么？</h3><p>答：简单来说，调查会收集人们如何使用 Kubernetes 的信息，
例如学习部署新系统的趋势、他们收到的错误消息和工作流程。</p><p>我们的目标之一是根据需要对反馈进行标准化。
最终目标是分析那些需求没有得到满足的重要用户故事的调查反馈。</p><h3 id=问-招募贡献者时你希望他们具备什么特别的技能吗-sig-usability-的贡献者可能要学习哪些技能>问：招募贡献者时你希望他们具备什么特别的技能吗？SIG Usability 的贡献者可能要学习哪些技能？</h3><p>答：虽然为 SIG Usability 做贡献没有任何先决条件，
但用户研究、定性研究的经验或之前如何进行访谈的经验将是很好的加分项。
定量研究，如调查设计和筛选，也很有帮助，也是我们希望贡献者学习的东西。</p><h3 id=问-您在哪些方面获得了积极的反馈-以及-sig-usability-接下来会发生什么>问：您在哪些方面获得了积极的反馈，以及 SIG Usability 接下来会发生什么？</h3><p>答：我们一直有新成员加入并经常参加月度会议，并表现出对成为贡献者和帮助社区的兴趣。
我们也有很多人通过 Slack 与我们联系，表达他们对 SIG 的兴趣。</p><p>目前，我们正专注于完成我们<a href="https://www.youtube.com/watch?v=Byn0N_ZstE0">演讲</a>中提到的调研，
也是我们今年的项目。我们总是很高兴有新的贡献者加入我们。</p><h3 id=问-在结束之前-你还有什么想法-资源要分享吗>问：在结束之前，你还有什么想法/资源要分享吗？</h3><p>答：我们喜欢结识新的贡献者并帮助他们研究不同的 Kubernetes 项目领域。
我们将与其他 SIG 合作，以促进与最终用户的互动，开展调研，并帮助他们将可访问的设计实践整合到他们的开发实践中。</p><p>这里有一些资源供你入门：</p><ul><li><a href=https://github.com/kubernetes/community/tree/master/sig-usability>GitHub</a></li><li><a href=https://groups.google.com/g/kubernetes-sig-usability>邮件列表</a></li><li><a href=https://github.com/kubernetes/community/labels/sig%2Fusability>Open Community Issues/PRs</a></li><li><a href=https://slack.k8s.io/>Slack</a></li><li><a href=https://kubernetes.slack.com/archives/CLC5EF63T>Slack 频道 #sig-usability</a></li></ul><h2 id=总结>总结</h2><p>SIG Usability 举办了一个关于调研 Kubernetes 用户体验的 <a href="https://www.youtube.com/watch?v=Byn0N_ZstE0">KubeCon 演讲</a>。
演讲的重点是用户调研项目的更新，了解谁在使用 Kubernetes、他们试图实现什么、项目如何满足他们的需求、以及我们需要改进项目和客户体验的地方。
欢迎加入 SIG 的更新，了解最新的调研成果、来年的计划以及如何作为贡献者参与上游可用性团队！</p></div><div class=td-content style=page-break-before:always><h1 id=pg-3c86e85f7813eea42a5800c5b7dacd46>卷健康监控的 Alpha 更新</h1><div class="td-byline mb-4"><time datetime=2021-04-16 class=text-muted>2021.04.16</time></div><p><strong>作者：</strong> Xing Yang (VMware)</p><p>最初在 1.19 中引入的 CSI 卷健康监控功能在 1.21 版本中进行了大规模更新。</p><h2 id=为什么要向-kubernetes-添加卷健康监控>为什么要向 Kubernetes 添加卷健康监控？</h2><p>如果没有卷健康监控，在 PVC 被 Pod 配置和使用后，Kubernetes 将不知道存储系统的底层卷的状态。
在 Kubernetes 中配置卷后，底层存储系统可能会发生很多事情。
例如，卷可能在 Kubernetes 之外被意外删除、卷所在的磁盘可能发生故障、容量不足、磁盘可能被降级而影响其性能等等。
即使卷被挂载到 Pod 上并被应用程序使用，以后也可能会出现诸如读/写 I/O 错误、文件系统损坏、在 Kubernetes 之外被意外卸载卷等问题。
当发生这样的事情时，调试和检测根本原因是非常困难的。</p><p>卷健康监控对 Kubernetes 用户非常有益。
它可以与 CSI 驱动程序通信以检索到底层存储系统检测到的错误。
用户可以收到报告上来的 PVC 事件继而采取行动。
例如，如果卷容量不足，他们可以请求卷扩展以获得更多空间。</p><h2 id=什么是卷健康监控>什么是卷健康监控？</h2><p>CSI 卷健康监控允许 CSI 驱动程序检测来自底层存储系统的异常卷状况，并将其作为 PVC 或 Pod 上的事件报送。</p><p>监控卷和使用卷健康信息报送事件的 Kubernetes 组件包括：</p><ul><li>Kubelet 除了收集现有的卷统计信息外，还将观察该节点上 PVC 的卷健康状况。
如果 PVC 的健康状况异常，则会在使用 PVC 的 Pod 对象上报送事件。
如果多个 Pod 使用相同的 PVC，则将在使用该 PVC 的所有 Pod 上报送事件。</li></ul><ul><li>一个<a href=https://github.com/kubernetes-csi/external-health-monitor>外部卷健康监视控制器</a>监视 PVC 的卷健康并报告 PVC 上的事件。</li></ul><p>请注意，在 Kubernetes 1.19 版本中首次引入此功能时，节点侧卷健康监控逻辑是一个外部代理。
在 Kubernetes 1.21 中，节点侧卷健康监控逻辑从外部代理移至 Kubelet，以避免 CSI 函数重复调用。
随着 1.21 中的这一变化，为 Kubelet 中的卷健康监控逻辑引入了一个新的 alpha <a href=/zh-cn/docs/reference/command-line-tools-reference/feature-gates/>特性门</a> <code>CSIVolumeHealth</code>。</p><p>目前，卷健康监控功能仅供参考，因为它只报送 PVC 或 Pod 上的异常卷健康事件。
用户将需要检查这些事件并手动修复问题。
此功能可作为 Kubernetes 未来以编程方式检测和解决卷健康问题的基石。</p><h2 id=如何在-kubernetes-集群上使用卷健康>如何在 Kubernetes 集群上使用卷健康？</h2><p>要使用卷健康功能，首先确保你使用的 CSI 驱动程序支持此功能。
请参阅此 <a href=https://kubernetes-csi.github.io/docs/drivers.html>CSI 驱动程序文档</a>以了解哪些 CSI 驱动程序支持此功能。</p><p>要从节点侧启用卷健康监控，需要启用 alpha 特性门 <code>CSIVolumeHealth</code>。</p><p>如果 CSI 驱动程序支持控制器端的卷健康监控功能，则有关异常卷条件的事件将记录在 PVC 上。</p><p>如果 CSI 驱动程序支持控制器端的卷健康监控功能，
当部署外部健康监控控制器时 <code>enable-node-watcher</code> 标志设置为 true，用户还可以获得有关节点故障的事件。
当检测到节点故障事件时，会在 PVC 上报送一个事件，指示使用该 PVC 的 Pod 在故障节点上。</p><p>如果 CSI 驱动程序支持节点端的卷健康监控功能，则有关异常卷条件的事件将使用 PVC 记录在 Pod 上。</p><h2 id=作为存储供应商-如何向-csi-驱动程序添加对卷健康的支持>作为存储供应商，如何向 CSI 驱动程序添加对卷健康的支持？</h2><p>卷健康监控包括两个部分：</p><ul><li>外部卷健康监控控制器从控制器端监控卷健康。</li><li>Kubelet 从节点端监控卷的健康状况。</li></ul><p>有关详细信息，请参阅 <a href=https://github.com/container-storage-interface/spec/blob/master/spec.md>CSI 规约</a>
和 <a href=https://kubernetes-csi.github.io/docs/volume-health-monitor.html>Kubernetes-CSI 驱动开发者指南</a>。</p><p><a href=https://github.com/kubernetes-csi/csi-driver-host-path>CSI 主机路径驱动程序</a>中有一个卷健康的示例实现。</p><h3 id=控制器端卷健康监控>控制器端卷健康监控</h3><p>要了解如何部署外部卷健康监控控制器，
请参阅 CSI 文档中的 <a href=https://kubernetes-csi.github.io/docs/external-health-monitor-controller.html>CSI external-health-monitor-controller</a>。</p><p>如果检测到异常卷条件，
外部健康监视器控制器调用 <code>ListVolumes</code> 或者 <code>ControllerGetVolume</code> CSI RPC 并报送 VolumeConditionAbnormal 事件以及 PVC 上的消息。
只有具有 <code>LIST_VOLUMES</code> 和 <code>VOLUME_CONDITION</code> 控制器能力、
或者具有 <code>GET_VOLUME</code> 和 <code>VOLUME_CONDITION</code> 能力的 CSI 驱动程序才支持外部控制器中的卷健康监控。</p><p>要从控制器端实现卷健康功能，CSI 驱动程序<strong>必须</strong>添加对新控制器功能的支持。</p><p>如果 CSI 驱动程序支持 <code>LIST_VOLUMES</code> 和 <code>VOLUME_CONDITION</code> 控制器功能，它<strong>必须</strong>实现控制器 RPC <code>ListVolumes</code> 并在响应中报送卷状况。</p><p>如果 CSI 驱动程序支持 <code>GET_VOLUME</code> 和 <code>VOLUME_CONDITION</code> 控制器功能，它<strong>必须</strong>实现控制器 PRC <code>ControllerGetVolume</code> 并在响应中报送卷状况。</p><p>如果 CSI 驱动程序支持 <code>LIST_VOLUMES</code>、<code>GET_VOLUME</code> 和 <code>VOLUME_CONDITION</code> 控制器功能，则外部健康监视控制器将仅调用 <code>ListVolumes</code> CSI RPC。</p><h3 id=节点侧卷健康监控>节点侧卷健康监控</h3><p>如果检测到异常的卷条件，
Kubelet 会调用 <code>NodeGetVolumeStats</code> CSI RPC 并报送 VolumeConditionAbnormal 事件以及 Pod 上的信息。
只有具有 <code>VOLUME_CONDITION</code> 节点功能的 CSI 驱动程序才支持 Kubelet 中的卷健康监控。</p><p>要从节点端实现卷健康功能，CSI 驱动程序<strong>必须</strong>添加对新节点功能的支持。</p><p>如果 CSI 驱动程序支持 <code>VOLUME_CONDITION</code> 节点能力，它<strong>必须</strong>在节点 RPC <code>NodeGetVoumeStats</code> 中报送卷状况。</p><h2 id=下一步是什么>下一步是什么？</h2><p>根据反馈和采纳情况，Kubernetes 团队计划在 1.22 或 1.23 中将 CSI 卷健康实施推向 beta。</p><p>我们还在探索如何在 Kubernetes 中使用卷健康信息进行编程检测和自动协调。</p><h2 id=如何了解更多>如何了解更多？</h2><p>要了解卷健康监控的设计细节，请阅读<a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-storage/1432-volume-health-monitor>卷健康监控</a>增强提案。</p><p>卷健康检测控制器源代码位于：
<a href=https://github.com/kubernetes-csi/external-health-monitor>https://github.com/kubernetes-csi/external-health-monitor</a>。</p><p><a href=https://kubernetes-csi.github.io/docs/>容器存储接口文档</a>中还有关于卷健康检查的更多详细信息。</p><h2 id=如何参与>如何参与？</h2><p><a href=https://kubernetes.slack.com/messages/csi>Kubernetes Slack 频道 #csi</a>
和任何<a href=https://github.com/kubernetes/community/blob/master/sig-storage/README.md#contact>标准 SIG Storage 通信频道</a>都是联系 SIG Storage 和 CSI 团队的绝佳媒介。</p><p>我们非常感谢在 1.21 中帮助发布此功能的贡献者。
我们要感谢 Yuquan Ren (<a href=https://github.com/nickrenren>NickrenREN</a>) 在外部健康监控仓库中实现了初始卷健康监控控制器和代理，
感谢 Ran Xu (<a href=https://github.com/fengzixu>fengzixu</a>) 在 1.21 中将卷健康监控逻辑从外部代理转移到 Kubelet，
我们特别感谢以下人员的深刻评论：
David Ashpole (<a href=https://github.com/dashpole>dashpole</a>)、
Michelle Au (<a href=https://github.com/msau42>msau42</a>)、
David Eads (<a href=https://github.com/deads2k>deads2k</a>)、
Elana Hashman (<a href=https://github.com/ehashman>ehashman</a>)、
Seth Jennings (<a href=https://github.com/sjenning>sjenning</a>) 和 Jiawei Wang (<a href=https://github.com/Jiawei0227>Jiawei0227</a>)</p><p>那些有兴趣参与 CSI 或 Kubernetes 存储系统任何部分的设计和开发的人，
请加入 <a href=https://github.com/kubernetes/community/tree/master/sig-storage>Kubernetes Storage 特殊兴趣小组</a>（SIG）。
我们正在迅速发展，并且欢迎新的贡献者。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-ea1371ce5ca79a0c65620b5bfa13e8b0>弃用 PodSecurityPolicy：过去、现在、未来</h1><div class="td-byline mb-4"><time datetime=2021-04-06 class=text-muted>2021.04.06</time></div><p>作者：Tabitha Sable（Kubernetes SIG Security）</p><p>PodSecurityPolicy (PSP) 在 Kubernetes 1.21 中被弃用。
PSP 日后会被移除，但目前不会改变任何其他内容。在移除之前，PSP 将继续在后续多个版本中完全正常运行。
与此同时，我们正在开发 PSP 的替代品，希望可以更轻松、更可持续地覆盖关键用例。</p><p>什么是 PSP？为什么需要 PSP？为什么要弃用，未来又将如何发展？
这对你有什么影响？当我们准备告别 PSP，这些关键问题浮现在脑海中，
所以让我们一起来讨论吧。本文首先概述 Kubernetes 如何移除一些特性。</p><h2 id=kubernetes-中的弃用是什么意思>Kubernetes 中的弃用是什么意思？</h2><p>每当 Kubernetes 决定弃用某项特性时，我们会遵循<a href=/zh-cn/docs/reference/using-api/deprecation-policy/>弃用策略</a>。
首先将该特性标记为已弃用，然后经过足够长的时间后，最终将其移除。</p><p>Kubernetes 1.21 启动了 PodSecurityPolicy 的弃用流程。与弃用任何其他功能一样，
PodSecurityPolicy 将继续在后续几个版本中完全正常运行。目前的计划是在 1.25 版本中将其移除。</p><p>在彻底移除之前，PSP 仍然是 PSP。至少在未来一年时间内，最新的 Kubernetes
版本仍将继续支持 PSP。大约两年之后，PSP 才会在所有受支持的 Kubernetes 版本中彻底消失。</p><h2 id=什么是-podsecuritypolicy>什么是 PodSecurityPolicy？</h2><p><a href=/zh-cn/docs/concepts/security/pod-security-policy/>PodSecurityPolicy</a>
是一个内置的<a href=/blog/2019/03/21/a-guide-to-kubernetes-admission-controllers/>准入控制器</a>，
允许集群管理员控制 Pod 规约中涉及安全的敏感内容。</p><p>首先，在集群中创建一个或多个 PodSecurityPolicy 资源来定义 Pod 必须满足的要求。
然后，创建 RBAC 规则来决定为特定的 Pod 应用哪个 PodSecurityPolicy。
如果 Pod 满足其 PSP 的要求，则照常被允许进入集群。
在某些情况下，PSP 还可以修改 Pod 字段，有效地为这些字段创建新的默认值。
如果 Pod 不符合 PSP 要求，则被拒绝进入集群，并且无法运行。</p><p>关于 PodSecurityPolicy，还需要了解：它与
<a href=/zh-cn/docs/reference/kubernetes-api/workload-resources/pod-v1/#security-context>PodSecurityContext</a> 不同。</p><p>作为 Pod 规约的一部分，PodSecurityContext（及其每个容器对应的 <code>SecurityContext</code>）
是一组字段的集合，这些字段为 Pod 指定了与安全相关的许多设置。
安全上下文指示 kubelet 和容器运行时究竟应该如何运行 Pod。
相反，PodSecurityPolicy 仅约束可能在安全上下文中设置的值（或设置默认值）。</p><p>弃用 PSP 不会以任何方式影响 PodSecurityContext。</p><h2 id=以前为什么需要-podsecuritypolicy>以前为什么需要 PodSecurityPolicy？</h2><p>在 Kubernetes 中，我们定义了 Deployment、StatefulSet 和 Service 等资源。
这些资源代表软件应用程序的构建块。Kubernetes 集群中的各种控制器根据这些资源做出反应，
创建更多的 Kubernetes 资源或配置一些软件或硬件来实现我们的目标。</p><p>在大多数 Kubernetes 集群中，由 RBAC（基于角色的访问控制）<a href=/zh-cn/docs/reference/access-authn-authz/rbac/#role-and-clusterrole>规则</a>
控制对这些资源的访问。 <code>list</code>、<code>get</code>、<code>create</code>、<code>edit</code> 和 <code>delete</code> 是 RBAC 关心的 API 操作类型，
但 <strong>RBAC 不考虑其所控制的资源中加入了哪些设置</strong>。例如，
Pod 几乎可以是任何东西，例如简单的网络服务器，或者是特权命令提示（提供对底层服务器节点和所有数据的完全访问权限）。
这对 RBAC 来说都是一样的：Pod 就是 Pod 而已。</p><p>要控制集群中定义的资源允许哪些类型的设置，除了 RBAC 之外，还需要准入控制。
从 Kubernetes 1.3 开始，内置 PodSecurityPolicy 一直被作为 Pod 安全相关字段的准入控制机制。
使用 PodSecurityPolicy，可以防止“创建 Pod”这个能力自动变成“每个集群节点上的 root 用户”，
并且无需部署额外的外部准入控制器。</p><h2 id=现在为什么-podsecuritypolicy-要消失>现在为什么 PodSecurityPolicy 要消失？</h2><p>自从首次引入 PodSecurityPolicy 以来，我们已经意识到 PSP 存在一些严重的可用性问题，
只有做出断裂式的改变才能解决。</p><p>实践证明，PSP 应用于 Pod 的方式让几乎所有尝试使用它们的人都感到困惑。
很容易意外授予比预期更广泛的权限，并且难以查看某种特定情况下应用了哪些 PSP。
“更改 Pod 默认值”功能很方便，但仅支持某些 Pod 设置，而且无法明确知道它们何时会或不会应用于的 Pod。
如果没有“试运行”或审计模式，将 PSP 安全地改造并应用到现有集群是不切实际的，并且永远都不可能默认启用 PSP。</p><p>有关这些问题和其他 PSP 困难的更多信息，请查看
KubeCon NA 2019 的 SIG Auth 维护者频道会议记录：<div class=youtube-quote-sm><iframe src="https://www.youtube.com/embed/SFtHRmPuhEw?start=953" allowfullscreen title="YouTube Video"></iframe></div></p><p>如今，你不再局限于部署 PSP 或编写自己的自定义准入控制器。
有几个外部准入控制器可用，它们结合了从 PSP 中吸取的经验教训以提供更好的用户体验。
<a href=https://github.com/cruise-automation/k-rail>K-Rail</a>、
<a href=https://github.com/kyverno/kyverno/>Kyverno</a>、
<a href=https://github.com/open-policy-agent/gatekeeper/>OPA/Gatekeeper</a> 都家喻户晓，各有粉丝。</p><p>尽管现在还有其他不错的选择，但我们认为，提供一个内置的准入控制器供用户选择，仍然是有价值的事情。
考虑到这一点，以及受 PSP 经验的启发，我们转向下一步。</p><h2 id=下一步是什么>下一步是什么？</h2><p>Kubernetes SIG Security、SIG Auth 和其他社区成员几个月来一直在倾力合作，确保接下来的方案能令人惊叹。
我们拟定了 Kubernetes 增强提案（<a href=https://github.com/kubernetes/enhancements/issues/2579>KEP 2579</a>）
以及一个新功能的原型，目前称之为“PSP 替代策略”。
我们的目标是在 Kubernetes 1.22 中发布 Alpha 版本。</p><p>PSP 替代策略始于，我们认识到已经有一个强大的外部准入控制器生态系统可用，
所以，PSP 的替代品不需要满足所有人的所有需求。与外部 Webhook 相比，
部署和采用的简单性是内置准入控制器的关键优势。我们专注于如何最好地利用这一优势。</p><p>PSP 替代策略旨在尽可能简单，同时提供足够的灵活性以支撑大规模生产场景。
它具有柔性上线能力，以便于将其改装到现有集群，并且新的策略是可配置的，可以设置为默认启用。
PSP 替代策略可以被部分或全部禁用，以便在高级使用场景中与外部准入控制器共存。</p><h2 id=这对你意味着什么>这对你意味着什么？</h2><p>这一切对你意味着什么取决于你当前的 PSP 情况。如果已经在使用 PSP，那么你有足够的时间来计划下一步行动。
请查看 PSP 替代策略 KEP 并考虑它是否适合你的使用场景。</p><p>如果你已经在通过众多 PSP 和复杂的绑定规则深度利用 PSP 的灵活性，你可能会发现 PSP 替代策略的简单性有太多限制。
此时，建议你在接下来的一年中评估一下生态系统中的其他准入控制器选择。有些资源可以让这种过渡更容易，
比如 <a href=https://github.com/open-policy-agent/gatekeeper-library>Gatekeeper Policy Library</a>。</p><p>如果只是使用 PSP 的基础功能，只用几个策略并直接绑定到每个命名空间中的服务帐户，
你可能会发现 PSP 替代策略非常适合你的需求。
对比 Kubernetes <a href=/zh-cn/docs/concepts/security/pod-security-standards/>Pod 安全标准</a> 评估你的 PSP，
了解可以在哪些情形下使用限制策略、基线策略和特权策略。
欢迎关注或为 KEP 和后续发展做出贡献，并在可用时试用 PSP 替代策略的 Alpha 版本。</p><p>如果刚刚开始 PSP 之旅，你可以通过保持简单来节省时间和精力。
你可以使用 Pod 安全标准的 PSP 来获得和目前 PSP 替代策略相似的功能。
如果你将基线策略或限制策略绑定到 <code>system:serviceaccounts</code> 组来设置集群默认值，
然后<a href=/zh-cn/docs/concepts/policy/pod-security-policy/#run-another-pod>使用 ServiceAccount 绑定</a>
在某些命名空间下根据需要制定更宽松的策略，就可以避免许多 PSP 陷阱并轻松迁移到 PSP 替代策略。
如果你的需求比这复杂得多，那么建议将精力花在采用比上面提到的功能更全的某个外部准入控制器。</p><p>我们致力于使 Kubernetes 成为我们可以做到的最好的容器编排工具，
有时这意味着我们需要删除长期存在的功能，以便为更好的特性腾出空间。
发生这种情况时，Kubernetes 弃用策略可确保你有足够的时间来计划下一步行动。
对于 PodSecurityPolicy，有几个选项可以满足一系列需求和用例。
现在就开始为 PSP 的最终移除提前制定计划，请考虑为它的替换做出贡献！</p><p><strong>致谢：</strong> 研发优秀的软件需要优秀的团队。感谢为 PSP 替代工作做出贡献的所有人，
尤其是（按字母顺序）Tim Allclair、Ian Coldwater 和 Jordan Liggitt。
和你们共事非常愉快。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-89bf34261431a73d36cd93a22c4b1e31>一个编排高可用应用的 Kubernetes 自定义调度器</h1><div class="td-byline mb-4"><time datetime=2020-12-21 class=text-muted>2020.12.21</time></div><p><strong>作者</strong>: Chris Seto (Cockroach Labs)</p><p>只要你愿意遵守规则，那么在 Kubernetes 上的部署和探索可以是相当愉快的。更多时候，事情会 "顺利进行"。
然而，如果一个人对与必须保持存活的鳄鱼一起旅行或者是对必须保持可用的数据库进行扩展有兴趣，
情况可能会变得更复杂一点。
相较于这个问题，建立自己的飞机或数据库甚至还可能更容易一些。撇开与鳄鱼的旅行不谈，扩展一个高可用的有状态系统也不是一件小事。</p><p>任何系统的扩展都有两个主要组成部分。</p><ol><li>增加或删除系统将运行的基础架构，以及</li><li>确保系统知道如何处理自身额外实例的添加和删除。</li></ol><p>大多数无状态系统，例如网络服务器，在创建时不需要意识到对等实例。而有状态的系统，包括像 CockroachDB 这样的数据库，
必须与它们的对等实例协调，并对数据进行 shuffle。运气好的话，CockroachDB 可以处理数据的再分布和复制。
棘手的部分是在确保数据和实例分布在许多故障域（可用性区域）的操作过程中能够容忍故障的发生。</p><p>Kubernetes 的职责之一是将 "资源"（如磁盘或容器）放入集群中，并满足其请求的约束。
例如。"我必须在可用性区域 <em>A</em>"（见<a href=/zh-cn/docs/setup/best-practices/multiple-zones/#nodes-are-labeled>在多个区域运行</a>），
或者 "我不能被放置到与某个 Pod 相同的节点上"
（见<a href=/zh-cn/docs/setup/best-practices/multiple-zones/#nodes-are-labeled>亲和与反亲和</a>）。</p><p>作为对这些约束的补充，Kubernetes 提供了 <a href=/zh-cn/docs/concepts/workloads/controllers/statefulset/>StatefulSets</a>，
为 Pod 提供身份，以及 "跟随" 这些指定 Pod 的持久化存储。
在 StatefulSet 中，身份是由 Pod 名称末尾一个呈增序的整数处理的。
值得注意的是，这个整数必须始终是连续的：在一个 StatefulSet 中，
如果 Pod 1 和 3 存在，那么 Pod 2 也必须存在。</p><p>在架构上，CockroachCloud 将 CockroachDB 的每个区域作为 StatefulSet 部署在自己的 Kubernetes 集群中 --
参见 <a href=https://www.cockroachlabs.com/docs/stable/orchestrate-cockroachdb-with-kubernetes.html>Orchestrate CockroachDB in a Single Kubernetes Cluster</a>。
在这篇文章中，我将着眼于一个单独的区域，一个 StatefulSet 和一个至少分布有三个可用区的 Kubernetes 集群。</p><p>一个三节点的 CockroachCloud 集群如下所示：</p><p><img src=image01.png alt="3-node, multi-zone cockroachdb cluster"></p><p>在向集群增加额外的资源时，我们也会将它们分布在各个区域。
为了获得最快的用户体验，我们同时添加所有 Kubernetes 节点，然后扩大 StatefulSet 的规模。</p><p><img src=image02.png alt="illustration of phases: adding Kubernetes nodes to the multi-zone cockroachdb cluster"></p><p>请注意，无论 Pod 被分配到 Kubernetes 节点的顺序如何，都会满足反亲和性。
在这个例子中，Pod 0、1、2 分别被分配到 A、B、C 区，但 Pod 3 和 4 以不同的顺序被分配到 B 和 A 区。
反亲和性仍然得到满足，因为 Pod 仍然被放置在不同的区域。</p><p>要从集群中移除资源，我们以相反的顺序执行这些操作。</p><p>我们首先缩小 StatefulSet 的规模，然后从集群中移除任何缺少 CockroachDB Pod 的节点。</p><p><img src=image03.png alt="illustration of phases: scaling down pods in a multi-zone cockroachdb cluster in Kubernetes"></p><p>现在，请记住，规模为 <em>n</em> 的 StatefulSet 中的 Pods 一定具有 <code>[0,n)</code> 范围内的 id。
当把一个 StatefulSet 规模缩减了 <em>m</em> 时，Kubernetes 会移除 <em>m</em> 个 Pod，从最高的序号开始，向最低的序号移动，
<a href=/zh-cn/docs/concepts/workloads/controllers/statefulset/#deployment-and-scaling-guarantees>与它们被添加的顺序相反</a>。
考虑一下下面的集群拓扑结构。</p><p><img src=image04.png alt="illustration: cockroachdb cluster: 6 nodes distributed across 3 availability zones"></p><p>当从这个集群中移除 5 号到 3 号 Pod 时，这个 StatefulSet 仍然横跨三个可用区。</p><p><img src=image05.png alt="illustration: removing 3 nodes from a 6-node, 3-zone cockroachdb cluster"></p><p>然而，Kubernetes 的调度器并不像我们一开始预期的那样 <em>保证</em> 上面的分布。</p><p>我们对以下内容的综合认识是导致这种误解的原因。</p><ul><li>Kubernetes <a href=/zh-cn/docs/setup/best-practices/multiple-zones/#pods-are-spread-across-zones>自动跨区分配 Pod</a> 的能力</li><li>一个有 <em>n</em> 个副本的 StatefulSet，当 Pod 被部署时，它们会按照 <code>{0...n-1}</code> 的顺序依次创建。
更多细节见 <a href=/zh-cn/docs/concepts/workloads/controllers/statefulset/#deployment-and-scaling-guarantees>StatefulSet</a>。</li></ul><p>考虑以下拓扑结构：</p><p><img src=image06.png alt="illustration: 6-node cockroachdb cluster distributed across 3 availability zones"></p><p>这些 Pod 是按顺序创建的，它们分布在集群里所有可用区。当序号 5 到 3 的 Pod 被终止时，
这个集群将从 C 区消失!</p><p><img src=image07.png alt="illustration: terminating 3 nodes in 6-node cluster spread across 3 availability zones, where 2/2 nodes in the same availability zone are terminated, knocking out that AZ"></p><p>更糟糕的是，在这个时候，我们的自动化机制将删除节点 A-2，B-2，和 C-2。
并让 CRDB-1 处于未调度状态，因为持久性卷只在其创建时所处的区域内可用。</p><p>为了纠正后一个问题，我们现在采用了一种“狩猎和啄食”的方法来从集群中移除机器。
与其盲目地从集群中移除 Kubernetes 节点，不如只移除没有 CockroachDB Pod 的节点。
更为艰巨的任务是管理 Kubernetes 的调度器。</p><h2 id=一场头脑风暴后我们有了-3-个选择>一场头脑风暴后我们有了 3 个选择。</h2><h3 id=1-升级到-kubernetes-1-18-并利用-pod-拓扑分布约束>1. 升级到 kubernetes 1.18 并利用 Pod 拓扑分布约束</h3><p>虽然这似乎是一个完美的解决方案，但在写这篇文章的时候，Kubernetes 1.18 在公有云中两个最常见的
托管 Kubernetes 服务（ EKS 和 GKE ）上是不可用的。
此外，<a href=/zh-cn/docs/concepts/scheduling-eviction/topology-spread-constraints/>Pod 拓扑分布约束</a>在 1.18 中仍是测试版功能，
这意味着即使在 v1.18 可用时，它<a href=https://cloud.google.com/kubernetes-engine/docs/concepts/types-of-clusters#kubernetes_feature_choices>也不能保证在托管集群中可用</a>。
整个努力让人联想到在 Internet Explorer 8 还存在的时候访问 <a href=https://caniuse.com/>caniuse.com</a>。</p><h3 id=2-在每个区部署一个-statefulset>2. 在每个区部署一个 StatefulSet。</h3><p>与跨所有可用区部署一个 StatefulSet 相比，在每个区部署一个带有节点亲和性的 StatefulSet 可以实现手动控制分区拓扑结构。
我们的团队过去曾考虑过这个选项，我们也倾向此选项。
但最终，我们决定放弃这个方案，因为这需要对我们的代码库进行大规模的修改，而且在现有的客户集群上进行迁移也是一个同样大的工程。</p><h3 id=3-编写一个自定义的-kubernetes-调度器>3. 编写一个自定义的 Kubernetes 调度器</h3><p>感谢 <a href=https://github.com/kelseyhightower/scheduler>Kelsey Hightower</a> 的例子和
<a href=https://banzaicloud.com/blog/k8s-custom-scheduler/>Banzai Cloud</a> 的博文，我们决定投入进去，编写自己的<a href=/zh-cn/docs/tasks/extend-kubernetes/configure-multiple-schedulers/>自定义 Kubernetes 调度器</a>。
一旦我们的概念验证被部署和运行，我们很快就发现，Kubernetes 的调度器也负责将持久化卷映射到它所调度的 Pod 上。
<a href=/zh-cn/docs/tasks/extend-kubernetes/configure-multiple-schedulers/#verifying-that-the-pods-wer-scheduled-using-the-desired-schedulers><code>kubectl get events</code></a>
的输出让我们相信有另一个系统在发挥作用。
在我们寻找负责存储声明映射的组件的过程中，我们发现了
<a href=/zh-cn/docs/concepts/scheduling-eviction/scheduling-framework/>kube-scheduler 插件系统</a>。
我们的下一个 POC 是一个"过滤器"插件，它通过 Pod 的序号来确定适当的可用区域，并且工作得非常完美。</p><p>我们的<a href=https://github.com/cockroachlabs/crl-scheduler>自定义调度器插件</a>是开源的，并在我们所有的 CockroachCloud 集群中运行。
对 StatefulSet Pod 的调度方式有掌控力，让我们有信心扩大规模。
一旦 GKE 和 EKS 中的 Pod 拓扑分布约束可用，我们可能会考虑让我们的插件退役，但其维护的开销出乎意料地低。
更好的是：该插件的实现与我们的业务逻辑是横向的。部署它，或取消它，就像改变 StatefulSet 定义中的 "schedulerName" 字段一样简单。</p><hr><p><a href=https://twitter.com/_ostriches>Chris Seto</a> 是 Cockroach 实验室的一名软件工程师，负责
<a href=https://cockroachlabs.cloud>CockroachCloud</a> CockroachDB 的 Kubernetes 自动化。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-c06e007d763ae4af520000567d5724c6>Kubernetes 1.20：CSI 驱动程序中的 Pod 身份假扮和短时卷</h1><div class="td-byline mb-4"><time datetime=2020-12-18 class=text-muted>2020.12.18</time></div><p><strong>作者</strong>: Shihang Zhang（谷歌）</p><p>通常，当 <a href=https://github.com/container-storage-interface/spec/blob/baa71a34651e5ee6cb983b39c03097d7aa384278/spec.md>CSI</a> 驱动程序挂载
诸如 Secret 和证书之类的凭据时，它必须通过存储提供者的身份认证才能访问这些凭据。
然而，对这些凭据的访问是根据 Pod 的身份而不是 CSI 驱动程序的身份来控制的。
因此，CSI 驱动程序需要某种方法来取得 Pod 的服务帐户令牌。</p><p>当前，有两种不是那么理想的方法来实现这一目的，要么通过授予 CSI 驱动程序使用 TokenRequest API 的权限，要么直接从主机文件系统中读取令牌。</p><p>两者都存在以下缺点：</p><ul><li>违反最少特权原则</li><li>每个 CSI 驱动程序都需要重新实现获取 Pod 的服务帐户令牌的逻辑</li></ul><p>第二种方式问题更多，因为：</p><ul><li>令牌的受众默认为 kube-apiserver</li><li>该令牌不能保证可用（例如，<code>AutomountServiceAccountToken=false</code>）</li><li>该方法不适用于以与 Pod 不同的（非 root 用户）用户身份运行的 CSI 驱动程序。请参见
<a href=https://github.com/kubernetes/enhancements/blob/f40c24a5da09390bd521be535b38a4dbab09380c/keps/sig-storage/20180515-svcacct-token-volumes.md#file-permission>服务帐户令牌的文件许可权部分</a></li><li>该令牌可能是旧的 Kubernetes 服务帐户令牌，如果 <code>BoundServiceAccountTokenVolume=false</code>，该令牌不会过期。</li></ul><p>Kubernetes 1.20 引入了一个内测功能 <code>CSIServiceAccountToken</code> 以改善安全状况。这项新功能允许 CSI 驱动程序接收 Pod 的<a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-auth/1205-bound-service-account-tokens/README.md>绑定服务帐户令牌</a>。</p><p>此功能还提供了一个重新发布卷的能力，以便可以刷新短时卷。</p><h2 id=pod-身份假扮>Pod 身份假扮</h2><h3 id=使用-gcp-apis>使用 GCP APIs</h3><p>使用 <a href=https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity>Workload Identity</a>，Kubernetes 服务帐户可以在访问 Google Cloud API 时验证为 Google 服务帐户。
如果 CSI 驱动程序要代表其为挂载卷的 Pod 访问 GCP API，则可以使用 Pod 的服务帐户令牌来
<a href=https://cloud.google.com/iam/docs/reference/sts/rest>交换 GCP 令牌</a>。启用功能 <code>CSIServiceAccountToken</code> 后，
可通过 <code>NodePublishVolume</code> RPC 调用中的卷上下文来访问 Pod 的服务帐户令牌。例如：通过 <a href=https://github.com/GoogleCloudPlatform/secrets-store-csi-driver-provider-gcp>Secret 存储 CSI 驱动</a>
访问 <a href=https://cloud.google.com/secret-manager/>Google Secret Manager</a>。</p><h3 id=使用vault>使用Vault</h3><p>如果用户将 <a href=https://www.vaultproject.io/docs/auth/kubernetes>Kubernetes 作为身份验证方法</a>配置，
则 Vault 使用 <code>TokenReview</code> API 来验证 Kubernetes 服务帐户令牌。
对于使用 Vault 作为资源提供者的 CSI 驱动程序，它们需要将 Pod 的服务帐户提供给 Vault。
例如，<a href=https://github.com/hashicorp/secrets-store-csi-driver-provider-vault>Secret 存储 CSI 驱动</a>和
<a href=https://github.com/jetstack/cert-manager-csi>证书管理器 CSI 驱动</a>。</p><h2 id=短时卷>短时卷</h2><p>为了使诸如证书之类的短时卷保持有效，CSI 驱动程序可以在其 <code>CSIDriver</code> 对象中指定 <code>RequiresRepublish=true</code>，
以使 kubelet 定期针对已挂载的卷调用 <code>NodePublishVolume</code>。
这些重新发布操作使 CSI 驱动程序可以确保卷内容是最新的。</p><h2 id=下一步>下一步</h2><p>此功能是 Alpha 版，预计将在 1.21 版中移至 Beta 版。 请参阅以下 KEP 和 CSI 文档中的更多内容：</p><ul><li><a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-storage/1855-csi-driver-service-account-token/README.md>KEP-1855: CSI 驱动程序的服务帐户令牌</a></li><li><a href=https://kubernetes-csi.github.io/docs/token-requests.html>令牌请求</a></li></ul><p>随时欢迎您提供反馈!</p><ul><li>SIG-Auth <a href=https://github.com/kubernetes/community/tree/master/sig-auth#meetings>定期开会</a>，可以通过 <a href=https://github.com/kubernetes/community/tree/master/sig-auth#contact>Slack 和邮件列表</a>加入</li><li>SIG-Storage <a href=https://github.com/kubernetes/community/tree/master/sig-storage#meetings>定期开会</a>，可以通过 <a href=https://github.com/kubernetes/community/tree/master/sig-storage#contact>Slack 和邮件列表</a>加入</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-ced3d9254f631ed8dfb689bd1dd7c259>Kubernetes 1.20: 最新版本</h1><div class="td-byline mb-4"><time datetime=2020-12-08 class=text-muted>2020.12.08</time></div><p><strong>作者:</strong> <a href=https://github.com/kubernetes/sig-release/blob/master/releases/release-1.20/release_team.md>Kubernetes 1.20 发布团队</a></p><p>我们很高兴地宣布 Kubernetes 1.20 的发布，这是我们 2020 年的第三个也是最后一个版本！此版本包含 42 项增强功能：11 项增强功能已升级到稳定版，15 项增强功能正在进入测试版，16 项增强功能正在进入 Alpha 版。</p><p>1.20 发布周期在上一个延长的发布周期之后恢复到 11 周的正常节奏。这是一段时间以来功能最密集的版本之一：Kubernetes 创新周期仍呈上升趋势。此版本具有更多的 Alpha 而非稳定的增强功能，表明云原生生态系统仍有许多需要探索的地方。</p><h2 id=major-themes>主题</h2><h3 id=volume-snapshot-operations-goes-stable>Volume 快照操作变得稳定</h3><p>此功能提供了触发卷快照操作的标准方法，并允许用户以可移植的方式在任何 Kubernetes 环境和支持的存储提供程序上合并快照操作。</p><p>此外，这些 Kubernetes 快照原语充当基本构建块，解锁为 Kubernetes 开发高级企业级存储管理功能的能力，包括应用程序或集群级备份解决方案。</p><p>请注意，快照支持要求 Kubernetes 分销商捆绑 Snapshot 控制器、Snapshot CRD 和验证 webhook。还必须在集群上部署支持快照功能的 CSI 驱动程序。</p><h3 id=kubectl-debug-graduates-to-beta>Kubectl Debug 功能升级到 Beta</h3><p><code>kubectl alpha debug</code> 功能在 1.20 中升级到测试版，成为 <code>kubectl debug</code>. 该功能直接从 kubectl 提供对常见调试工作流的支持。此版本的 kubectl 支持的故障排除场景包括：</p><ul><li>通过创建使用不同容器映像或命令的 pod 副本，对在启动时崩溃的工作负载进行故障排除。</li><li>通过在 pod 的新副本或使用临时容器中添加带有调试工具的新容器来对 distroless 容器进行故障排除。（临时容器是默认未启用的 alpha 功能。）</li><li>通过创建在主机命名空间中运行并可以访问主机文件系统的容器来对节点进行故障排除。</li></ul><p>请注意，作为新的内置命令，<code>kubectl debug</code> 优先于任何名为 “debug” 的 kubectl 插件。你必须重命名受影响的插件。</p><p><code>kubectl alpha debug</code> 现在不推荐使用，并将在后续版本中删除。更新你的脚本以使用 <code>kubectl debug</code>。 有关更多信息 <code>kubectl debug</code>，请参阅[调试正在运行的 Pod]((<a href=https://kubernetes.io/zh-cn/docs/tasks/debug/debug-application/debug-running-pod/>https://kubernetes.io/zh-cn/docs/tasks/debug/debug-application/debug-running-pod/</a>)。</p><h3 id=测试版-api-优先级和公平性-beta-api-priority-and-fairness>测试版：API 优先级和公平性 {#beta-api-priority-and-fairness)</h3><p>Kubernetes 1.20 由 1.18 引入，现在默认启用 API 优先级和公平性 (APF)。这允许 <code>kube-apiserver</code> 按优先级对传入请求进行分类。</p><h3 id=alpha-with-updates-ipv4-ipv6>Alpha 更新：IPV4/IPV6</h3><p>基于用户和社区反馈，重新实现了 IPv4/IPv6 双栈以支持双栈服务。
这允许将 IPv4 和 IPv6 服务集群 IP 地址分配给单个服务，还允许服务从单 IP 堆栈转换为双 IP 堆栈，反之亦然。</p><h3 id=ga-process-pid-limiting-for-stability>GA：进程 PID 稳定性限制</h3><p>进程 ID (pid) 是 Linux 主机上的基本资源。达到任务限制而不达到任何其他资源限制并导致主机不稳定是很可能发生的。</p><p>管理员需要机制来确保用户 pod 不会导致 pid 耗尽，从而阻止主机守护程序（运行时、kubelet 等）运行。此外，重要的是要确保 pod 之间的 pid 受到限制，以确保它们对节点上的其他工作负载的影响有限。
默认启用一年后，SIG Node 在 <code>SupportNodePidsLimit</code>（节点到 Pod PID 隔离）和 <code>SupportPodPidsLimit</code>（限制每个 Pod 的 PID 的能力）上都将 PID 限制升级为 GA。</p><h3 id=alpha-graceful-node-shutdown>Alpha：节点体面地关闭</h3><p>用户和集群管理员希望 Pod 遵守预期的 Pod 生命周期，包括 Pod 终止。目前，当一个节点关闭时，Pod 不会遵循预期的 Pod 终止生命周期，也不会正常终止，这可能会导致某些工作负载出现问题。
该 <code>GracefulNodeShutdown</code> 功能现在处于 Alpha 阶段。<code>GracefulNodeShutdown</code> 使 kubelet 知道节点系统关闭，从而在系统关闭期间正常终止 pod。</p><h2 id=major-changes>主要变化</h2><h3 id=dockershim-deprecation>Dockershim 弃用</h3><p>Dockershim，Docker 的容器运行时接口 (CRI) shim 已被弃用。不推荐使用对 Docker 的支持，并将在未来版本中删除。由于 Docker 映像遵循开放容器计划 (OCI) 映像规范，因此 Docker 生成的映像将继续在具有所有 CRI 兼容运行时的集群中工作。
Kubernetes 社区写了一篇关于弃用的详细<a href=https://blog.k8s.io/2020/12/02/dont-panic-kubernetes-and-docker/>博客文章</a>，并为其提供了一个专门的常见问题<a href=https://blog.k8s.io/2020/12/02/dockershim-faq/>解答页面</a>。</p><h3 id=exec-probe-timeout-handling>Exec 探测超时处理</h3><p>一个关于 exec 探测超时的长期错误可能会影响现有的 pod 定义，已得到修复。在此修复之前，exec 探测器不考虑 <code>timeoutSeconds</code> 字段。相反，探测将无限期运行，甚至超过其配置的截止日期，直到返回结果。
通过此更改，如果未指定值，将应用默认值 <code>1 second</code>，并且如果探测时间超过一秒，现有 pod 定义可能不再足够。
新引入的 <code>ExecProbeTimeout</code> 特性门控所提供的修复使集群操作员能够恢复到以前的行为，但这种行为将在后续版本中锁定并删除。为了恢复到以前的行为，集群运营商应该将此特性门控设置为 <code>false</code>。</p><p>有关更多详细信息，请查看有关配置探针的<a href=/zh-cn/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#configure-probes>更新文档</a>。</p><h2 id=other-updates>其他更新</h2><h3 id=graduated-to-stable>稳定版</h3><ul><li><a href=https://github.com/kubernetes/enhancements/issues/585>RuntimeClass</a></li><li><a href=https://github.com/kubernetes/enhancements/issues/1929>内置 API 类型默认值</a></li><li><a href=https://github.com/kubernetes/enhancements/issues/950>添加了对 Pod 层面启动探针和活跃性探针的扼制</a></li><li><a href=https://github.com/kubernetes/enhancements/issues/1001>在 Windows 上支持 CRI-ContainerD</a></li><li><a href=https://github.com/kubernetes/enhancements/issues/614>SCTP 对 Services 的支持</a></li><li><a href=https://github.com/kubernetes/enhancements/issues/1507>将 AppProtocol 添加到 Services 和 Endpoints 上</a></li></ul><h3 id=notable-feature-updates>值得注意的功能更新</h3><ul><li><a href=https://github.com/kubernetes/enhancements/issues/19>CronJobs</a></li></ul><h1 id=release-notes>发行说明</h1><p>你可以在<a href=https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG/CHANGELOG-1.20.md>发行说明</a>中查看 1.20 发行版的完整详细信息。</p><h1 id=availability-of-release>可用的发布</h1><p>Kubernetes 1.20 可在 <a href=https://github.com/kubernetes/kubernetes/releases/tag/v1.20.0>GitHub</a> 上下载。有一些很棒的资源可以帮助你开始使用 Kubernetes。你可以在 Kubernetes 主站点上查看一些<a href=https://kubernetes.io/docs/tutorials/>交互式教程</a>，或者使用 <a href=https://kind.sigs.k8s.io>kind</a> 的 Docker 容器在你的机器上运行本地集群。如果你想尝试从头开始构建集群，请查看 Kelsey Hightower 的 <a href=https://github.com/kelseyhightower/kubernetes-the-hard-way>Kubernetes the Hard Way</a> 教程。</p><h1 id=release-team>发布团队</h1><p>这个版本是由一群非常敬业的人促成的，他们在世界上发生的许多事情的时段作为一个团队走到了一起。
非常感谢发布负责人 Jeremy Rickard 以及发布团队中的其他所有人，感谢他们相互支持，并努力为社区发布 1.20 版本。</p><h1 id=release-logo>发布 Logo</h1><p><img src=/images/blog/2020-12-08-kubernetes-1.20-release-announcement/laser.png alt="Kubernetes 1.20 Release Logo"></p><p><a href=https://www.dictionary.com/browse/rad>raddest</a>: <em>adjective</em>, Slang. excellent; wonderful; cool:</p><blockquote><p>Kubernetes 1.20 版本是迄今为止最激动人心的版本。</p></blockquote><p>2020 年对我们中的许多人来说都是充满挑战的一年，但 Kubernetes 贡献者在此版本中提供了创纪录的增强功能。这是一项了不起的成就，因此发布负责人希望以一点轻松的方式结束这一年，并向 <a href=https://github.com/kubernetes/sig-release/tree/master/releases/release-1.14>Kubernetes 1.14 - Caturnetes</a> 和一只名叫 Humphrey 的 “rad” 猫致敬。</p><p>Humphrey是发布负责人的猫，有一个永久的 <code>blep</code>. 在 1990 年代，<em>Rad</em> 是美国非常普遍的俚语，激光背景也是如此。Humphrey 在 1990 年代风格的学校照片中感觉像是结束这一年的有趣方式。希望 Humphrey 和它的 <em>blep</em> 在 2020 年底给你带来一点快乐！</p><p>发布标志由 <a href=https://www.instagram.com/robotdancebattle/>Henry Hsu - @robotdancebattle</a> 创建。</p><h1 id=user-highlights>用户亮点</h1><ul><li>Apple 正在世界各地的数据中心运行数千个节点的 Kubernetes 集群。观看 <a href=https://youtu.be/Tx8qXC-U3KM>Alena Prokarchyk</a> 的 KubeCon NA 主题演讲，了解有关他们的云原生之旅的更多信息。</li></ul><h1 id=project-velocity>项目速度</h1><p><a href=https://k8s.devstats.cncf.io/>CNCF K8S DevStats 项目</a>聚集了许多有关Kubernetes和各分项目的速度有趣的数据点。这包括从个人贡献到做出贡献的公司数量的所有内容，并且清楚地说明了为发展这个生态系统所做的努力的深度和广度。</p><p>在持续 11 周（9 月 25 日至 12 月 9 日）的 v1.20 发布周期中，我们看到了来自 <a href="https://k8s.devstats.cncf.io/d/50/countries-stats?orgId=1&from=1601006400000&to=1607576399000&var-period_name=Quarter&var-countries=All&var-repogroup_name=Kubernetes&var-metric=rcommitters&var-cum=countries">26 个国家/地区</a> 的 <a href="https://k8s.devstats.cncf.io/d/9/companies-table?orgId=1&var-period_name=v1.19.0%20-%20now&var-metric=contributions">967 家公司</a> 和 <a href="https://k8s.devstats.cncf.io/d/66/developer-activity-counts-by-companies?orgId=1&var-period_name=v1.19.0%20-%20now&var-metric=contributions&var-repogroup_name=Kubernetes&var-country_name=All&var-companies=All">1335 名个人</a>（其中 <a href="https://k8s.devstats.cncf.io/d/52/new-contributors?orgId=1&from=1601006400000&to=1607576399000&var-repogroup_name=Kubernetes">44 人</a>首次为 Kubernetes 做出贡献）的贡献。</p><h1 id=ecosystem-updates>生态系统更新</h1><ul><li>KubeCon North America 三周前刚刚结束，这是第二个虚拟的此类活动！现在所有演讲都可以<a href="https://www.youtube.com/playlist?list=PLj6h78yzYM2Pn8RxfLh2qrXBDftr6Qjut">点播</a>，供任何需要赶上的人使用！</li><li>6 月，Kubernetes 社区成立了一个新的工作组，作为对美国各地发生的 Black Lives Matter 抗议活动的直接回应。WG Naming 的目标是尽可能彻底地删除 Kubernetes 项目中有害和不清楚的语言，并以可移植到其他 CNCF 项目的方式进行。在 <a href=https://sched.co/eukp>KubeCon 2020 North America</a> 上就这项重要工作及其如何进行进行了精彩的介绍性演讲，这项工作的初步影响<a href=https://github.com/kubernetes/enhancements/issues/2067>实际上可以在 v1.20 版本中看到</a>。</li><li>此前于今年夏天宣布，在 Kubecon NA 期间发布了经认证的 <a href=https://www.cncf.io/announcements/2020/11/17/kubernetes-security-specialist-certification-now-available/>Kubernetes 安全专家 (CKS) 认证</a> ，以便立即安排！遵循 CKA 和 CKAD 的模型，CKS 是一项基于性能的考试，侧重于以安全为主题的能力和领域。该考试面向当前的 CKA 持有者，尤其是那些想要完善其在保护云工作负载方面的基础知识的人（这是我们所有人，对吧？）。</li></ul><h1 id=event-updates>活动更新</h1><p>KubeCon + CloudNativeCon Europe 2021 将于 2021 年 5 月 4 日至 7 日举行！注册将于 1 月 11 日开放。你可以在<a href=https://events.linuxfoundation.org/kubecon-cloudnativecon-europe/>此处</a>找到有关会议的更多信息。
请记住，<a href=https://events.linuxfoundation.org/kubecon-cloudnativecon-europe/program/cfp/>CFP</a> 将于太平洋标准时间 12 月 13 日星期日晚上 11:59 关闭！</p><h1 id=upcoming-release-webinar>即将发布的网络研讨会</h1><p>请继续关注今年 1 月即将举行的发布网络研讨会。</p><h1 id=get-involved>参与其中</h1><p>如果你有兴趣为 Kubernetes 社区做出贡献，那么特别兴趣小组 (SIG) 是一个很好的起点。其中许多可能符合你的兴趣！如果你有什么想与社区分享的内容，你可以参加每周的社区会议，或使用以下任一渠道：</p><ul><li>在新的 <a href=https://www.kubernetes.dev/>Kubernetes Contributor 网站</a>上了解更多关于为Kubernetes 做出贡献的信息</li><li>在 Twitter <a href=https://twitter.com/kubernetesio>@Kubernetesio</a> 上关注我们以获取最新更新</li><li>加入关于讨论的<a href=https://discuss.kubernetes.io/>社区</a>讨论</li><li>加入 <a href=http://slack.k8s.io/>Slack 社区</a></li><li>分享你的 <a href=https://docs.google.com/a/linuxfoundation.org/forms/d/e/1FAIpQLScuI7Ye3VQHQTwBASrgkjQDSS5TP0g3AXfFhwSM9YpHgxRKFA/viewform>Kubernetes 故事</a></li><li>在<a href=https://kubernetes.io/blog/>博客</a>上阅读更多关于 Kubernetes 发生的事情</li><li>了解有关 <a href=https://github.com/kubernetes/sig-release/tree/master/release-team>Kubernetes 发布团队</a>的更多信息</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-d0001c21fb6f2f9b21c0faa11a149fae>别慌: Kubernetes 和 Docker</h1><div class="td-byline mb-4"><time datetime=2020-12-02 class=text-muted>2020.12.02</time></div><p><strong>作者：</strong> Jorge Castro, Duffie Cooley, Kat Cosgrove, Justin Garrison, Noah Kantrowitz, Bob Killen, Rey Lejano, Dan “POP” Papandrea, Jeffrey Sica, Davanum “Dims” Srinivas</p><p><strong>更新</strong>：Kubernetes 通过 <code>dockershim</code> 对 Docker 的支持现已移除。
有关更多信息，请阅读<a href=/zh-cn/dockershim>移除 FAQ</a>。
你还可以通过专门的 <a href=https://github.com/kubernetes/kubernetes/issues/106917>GitHub issue</a> 讨论弃用。</p><p>Kubernetes 从版本 v1.20 之后，<a href=https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG/CHANGELOG-1.20.md#deprecation>弃用 Docker</a>
这个容器运行时。</p><p><strong>不必慌张，这件事并没有听起来那么吓人。</strong></p><p>弃用 Docker 这个底层运行时，转而支持符合为 Kubernetes 创建的容器运行接口
<a href=https://kubernetes.io/blog/2016/12/container-runtime-interface-cri-in-kubernetes/>Container Runtime Interface (CRI)</a>
的运行时。
Docker 构建的镜像，将在你的集群的所有运行时中继续工作，一如既往。</p><p>如果你是 Kubernetes 的终端用户，这对你不会有太大影响。
这事并不意味着 Docker 已死、也不意味着你不能或不该继续把 Docker 用作开发工具。
Docker 仍然是构建容器的利器，使用命令 <code>docker build</code> 构建的镜像在 Kubernetes 集群中仍然可以运行。</p><p>如果你正在使用 GKE、EKS、或 AKS 这类托管 Kubernetes 服务，
你需要在 Kubernetes 后续版本移除对 Docker 支持之前，
确认工作节点使用了被支持的容器运行时。
如果你的节点被定制过，你可能需要根据你自己的环境和运行时需求更新它们。
请与你的服务供应商协作，确保做出适当的升级测试和计划。</p><p>如果你正在运营你自己的集群，那还应该做些工作，以避免集群中断。
在 v1.20 版中，你仅会得到一个 Docker 的弃用警告。
当对 Docker 运行时的支持在 Kubernetes 某个后续发行版（<del>目前的计划是 2021 年晚些时候的 1.22 版</del>）中被移除时，
你需要切换到 containerd 或 CRI-O 等兼容的容器运行时。
只要确保你选择的运行时支持你当前使用的 Docker 守护进程配置（例如 logging）。</p><h2 id=so-why-the-confusion-and-what-is-everyone-freaking-out-about>那为什么会有这样的困惑，为什么每个人要害怕呢？</h2><p>我们在这里讨论的是两套不同的环境，这就是造成困惑的根源。
在你的 Kubernetes 集群中，有一个叫做容器运行时的东西，它负责拉取并运行容器镜像。
Docker 对于运行时来说是一个流行的选择（其他常见的选择包括 containerd 和 CRI-O），
但 Docker 并非设计用来嵌入到 Kubernetes，这就是问题所在。</p><p>你看，我们称之为 “Docker” 的物件实际上并不是一个物件——它是一个完整的技术堆栈，
它其中一个叫做 “containerd” 的部件本身，才是一个高级容器运行时。
Docker 既酷炫又实用，因为它提供了很多用户体验增强功能，而这简化了我们做开发工作时的操作，
Kubernetes 用不到这些增强的用户体验，毕竟它并非人类。</p><p>因为这个用户友好的抽象层，Kubernetes 集群不得不引入一个叫做 Dockershim 的工具来访问它真正需要的 containerd。
这不是一件好事，因为这引入了额外的运维工作量，而且还可能出错。
实际上正在发生的事情就是：Dockershim 将在不早于 v1.23 版中从 kubelet 中被移除，也就取消对 Docker 容器运行时的支持。
你心里可能会想，如果 containerd 已经包含在 Docker 堆栈中，为什么 Kubernetes 需要 Dockershim。</p><p>Docker 不兼容 CRI，
<a href=https://kubernetes.io/blog/2016/12/container-runtime-interface-cri-in-kubernetes/>容器运行时接口</a>。
如果支持，我们就不需要这个 shim 了，也就没问题了。
但这也不是世界末日，你也不需要恐慌——你唯一要做的就是把你的容器运行时从 Docker 切换到其他受支持的容器运行时。</p><p>要注意一点：如果你依赖底层的 Docker 套接字(<code>/var/run/docker.sock</code>)，作为你集群中工作流的一部分，
切换到不同的运行时会导致你无法使用它。
这种模式经常被称之为嵌套 Docker（Docker in Docker）。
对于这种特殊的场景，有很多选项，比如：
<a href=https://github.com/GoogleContainerTools/kaniko>kaniko</a>、
<a href=https://github.com/genuinetools/img>img</a>、和
<a href=https://github.com/containers/buildah>buildah</a>。</p><h2 id=what-does-this-change-mean-for-developers>那么，这一改变对开发人员意味着什么？我们还要写 Dockerfile 吗？还能用 Docker 构建镜像吗？</h2><p>此次改变带来了一个不同的环境，这不同于我们常用的 Docker 交互方式。
你在开发环境中用的 Docker 和你 Kubernetes 集群中的 Docker 运行时无关。
我们知道这听起来让人困惑。
对于开发人员，Docker 从所有角度来看仍然有用，就跟这次改变之前一样。
Docker 构建的镜像并不是 Docker 特有的镜像——它是一个
OCI（<a href=https://opencontainers.org/>开放容器标准</a>）镜像。
任一 OCI 兼容的镜像，不管它是用什么工具构建的，在 Kubernetes 的角度来看都是一样的。
<a href=https://containerd.io/>containerd</a> 和
<a href=https://cri-o.io/>CRI-O</a>
两者都知道怎么拉取并运行这些镜像。
这就是我们制定容器标准的原因。</p><p>所以，改变已经发生。
它确实带来了一些问题，但这不是一个灾难，总的说来，这还是一件好事。
根据你操作 Kubernetes 的方式的不同，这可能对你不构成任何问题，或者也只是意味着一点点的工作量。
从一个长远的角度看，它使得事情更简单。
如果你还在困惑，也没问题——这里还有很多事情；
Kubernetes 有很多变化中的功能，没有人是100%的专家。
我们鼓励你提出任何问题，无论水平高低、问题难易。
我们的目标是确保所有人都能在即将到来的改变中获得足够的了解。
我们希望这已经回答了你的大部分问题，并缓解了一些焦虑！❤️</p><p>还在寻求更多答案吗？请参考我们附带的
<a href=/zh-cn/blog/2020/12/02/dockershim-faq/>移除 Dockershim 的常见问题</a> <em>(2022年2月更新)</em>。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-4f7882145418a14c275e957b0e8979f4>弃用 Dockershim 的常见问题</h1><div class="td-byline mb-4"><time datetime=2020-12-02 class=text-muted>2020.12.02</time></div><p><em><strong>更新</strong>：本文有<a href=/zh-cn/blog/2022/02/17/dockershim-faq/>较新版本</a>。</em></p><p>本文回顾了自 Kubernetes v1.20 版宣布弃用 Dockershim 以来所引发的一些常见问题。
关于 Kubernetes kubelets 从容器运行时的角度弃用 Docker 的细节以及这些细节背后的含义，请参考博文
<a href=/blog/2020/12/02/dont-panic-kubernetes-and-docker/>别慌: Kubernetes 和 Docker</a>。</p><p>此外，你可以阅读<a href=/zh-cn/docs/tasks/administer-cluster/migrating-from-dockershim/check-if-dockershim-removal-affects-you/>检查 Dockershim 移除是否影响你</a>以检查它是否会影响你。</p><h3 id=why-is-dockershim-being-deprecated>为什么弃用 dockershim</h3><p>维护 dockershim 已经成为 Kubernetes 维护者肩头一个沉重的负担。
创建 CRI 标准就是为了减轻这个负担，同时也可以增加不同容器运行时之间平滑的互操作性。
但反观 Docker 却至今也没有实现 CRI，所以麻烦就来了。</p><p>Dockershim 向来都是一个临时解决方案（因此得名：shim）。
你可以进一步阅读
<a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-node/2221-remove-dockershim>移除 Dockershim 这一 Kubernetes 增强方案</a>
以了解相关的社区讨论和计划。</p><p>此外，与 dockershim 不兼容的一些特性，例如：控制组（cgoups）v2 和用户名字空间（user namespace），已经在新的 CRI 运行时中被实现。
移除对 dockershim 的支持将加速这些领域的发展。</p><h3 id=can-I-still-use-docker-in-kubernetes-1.20>在 Kubernetes 1.20 版本中，我还可以用 Docker 吗？</h3><p>当然可以，在 1.20 版本中仅有的改变就是：如果使用 Docker 运行时，启动
<a href=/zh-cn/docs/reference/command-line-tools-reference/kubelet/>kubelet</a>
的过程中将打印一条警告日志。</p><h3 id=when-will-dockershim-be-removed>什么时候移除 dockershim</h3><p>考虑到此改变带来的影响，我们使用了一个加长的废弃时间表。
在 Kubernetes 1.22 版之前，它不会被彻底移除；换句话说，dockershim 被移除的最早版本会是 2021 年底发布的 1.23 版。
<em>更新</em>：dockershim 计划在 Kubernetes 1.24 版被移除，
请参阅<a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-node/2221-remove-dockershim>移除 Dockershim 这一 Kubernetes 增强方案</a>。
我们将与供应商以及其他生态团队紧密合作，确保顺利过渡，并将依据事态的发展评估后续事项。</p><h3 id=can-i-still-use-dockershim-after-it-is-removed-from-kubernetes>从 Kubernetes 中移除后我还能使用 dockershim 吗？</h3><p>更新：Mirantis 和 Docker <a href=https://www.mirantis.com/blog/mirantis-to-take-over-support-of-kubernetes-dockershim-2/>已承诺</a>在 dockershim 从 Kubernetes
中删除后对其进行维护。</p><h3 id=will-my-existing-docker-image-still-work>我现有的 Docker 镜像还能正常工作吗？</h3><p>当然可以，<code>docker build</code> 创建的镜像适用于任何 CRI 实现。
所有你的现有镜像将和往常一样工作。</p><h3 id=what-about-private-images>私有镜像呢？</h3><p>当然可以。所有 CRI 运行时均支持 Kubernetes 中相同的拉取（pull）Secret 配置，
不管是通过 PodSpec 还是通过 ServiceAccount 均可。</p><h3 id=are-docker-and-containers-the-same-thing>Docker 和容器是一回事吗？</h3><p>虽然 Linux 的容器技术已经存在了很久，
但 Docker 普及了 Linux 容器这种技术模式，并在开发底层技术方面发挥了重要作用。
容器的生态相比于单纯的 Docker，已经进化到了一个更宽广的领域。
像 OCI 和 CRI 这类标准帮助许多工具在我们的生态中成长和繁荣，
其中一些工具替代了 Docker 的某些部分，另一些增强了现有功能。</p><h3 id=are-there-example-of-folks-using-other-runtimes-in-production-today>现在是否有在生产系统中使用其他运行时的例子？</h3><p>Kubernetes 所有项目在所有版本中出产的工件（Kubernetes 二进制文件）都经过了验证。</p><p>此外，<a href=https://kind.sigs.k8s.io/>kind</a> 项目使用 containerd 已经有年头了，
并且在这个场景中，稳定性还明显得到提升。
Kind 和 containerd 每天都会做多次协调，以验证对 Kubernetes 代码库的所有更改。
其他相关项目也遵循同样的模式，从而展示了其他容器运行时的稳定性和可用性。
例如，OpenShift 4.x 从 2019 年 6 月以来，就一直在生产环境中使用 <a href=https://cri-o.io/>CRI-O</a> 运行时。</p><p>至于其他示例和参考资料，你可以查看 containerd 和 CRI-O 的使用者列表，
这两个容器运行时是云原生基金会（<a href=https://cncf.io>CNCF</a>）下的项目。</p><ul><li><a href=https://github.com/containerd/containerd/blob/master/ADOPTERS.md>containerd</a></li><li><a href=https://github.com/cri-o/cri-o/blob/master/ADOPTERS.md>CRI-O</a></li></ul><h3 id=people-keep-referenceing-oci-what-is-that>人们总在谈论 OCI，那是什么？</h3><p>OCI 代表<a href=https://opencontainers.org/about/overview/>开放容器标准</a>，
它标准化了容器工具和底层实现（technologies）之间的大量接口。
他们维护了打包容器镜像（OCI image-spec）和运行容器（OCI runtime-spec）的标准规范。
他们还以 <a href=https://github.com/opencontainers/runc>runc</a>
的形式维护了一个 runtime-spec 的真实实现，
这也是 <a href=https://containerd.io/>containerd</a> 和 <a href=https://cri-o.io/>CRI-O</a> 依赖的默认运行时。
CRI 建立在这些底层规范之上，为管理容器提供端到端的标准。</p><h3 id=which-cri-implementation-should-I-use>我应该用哪个 CRI 实现？</h3><p>这是一个复杂的问题，依赖于许多因素。
在 Docker 工作良好的情况下，迁移到 containerd 是一个相对容易的转换，并将获得更好的性能和更少的开销。
然而，我们建议你先探索 <a href="https://landscape.cncf.io/card-mode?category=container-runtime&grouping=category">CNCF 全景图</a>
提供的所有选项，以做出更适合你的环境的选择。</p><h3 id=what-should-I-look-out-for-when-changing-CRI-implementation>当切换 CRI 底层实现时，我应该注意什么？</h3><p>Docker 和大多数 CRI（包括 containerd）的底层容器化代码是相同的，但其周边部分却存在一些不同。
迁移时一些常见的关注点是：</p><ul><li>日志配置</li><li>运行时的资源限制</li><li>直接访问 docker 命令或通过控制套接字调用 Docker 的节点供应脚本</li><li>需要访问 docker 命令或控制套接字的 kubectl 插件</li><li>需要直接访问 Docker 的 Kubernetes 工具（例如：kube-imagepuller）</li><li>配置像 <code>registry-mirrors</code> 和不安全的镜像仓库等功能</li><li>需要 Docker 保持可用、且运行在 Kubernetes 之外的，其他支持脚本或守护进程（例如：监视或安全代理）</li><li>GPU 或特殊硬件，以及它们如何与你的运行时和 Kubernetes 集成</li></ul><p>如果你只是用了 Kubernetes 资源请求/限制或基于文件的日志收集 DaemonSet，它们将继续稳定工作，
但是如果你用了自定义了 dockerd 配置，则可能需要为新容器运行时做一些适配工作。</p><p>另外还有一个需要关注的点，那就是当创建镜像时，系统维护或嵌入容器方面的任务将无法工作。
对于前者，可以用 <a href=https://github.com/kubernetes-sigs/cri-tools><code>crictl</code></a> 工具作为临时替代方案
(参见<a href=/zh-cn/docs/reference/tools/map-crictl-dockercli/>从 docker 命令映射到 crictl</a>)；
对于后者，可以用新的容器创建选项，比如
<a href=https://github.com/kubernetes-sigs/cri-tools>cr</a>、
<a href=https://github.com/genuinetools/img>img</a>、
<a href=https://github.com/containers/buildah>buildah</a>、
<a href=https://github.com/GoogleContainerTools/kaniko>kaniko</a>、或
<a href=https://github.com/vmware-tanzu/buildkit-cli-for-kubectl>buildkit-cli-for-kubectl</a>，
他们均不需要访问 Docker。</p><p>对于 containerd，你可以从它们的
<a href=https://github.com/containerd/cri/blob/master/docs/registry.md>文档</a>
开始，看看在迁移过程中有哪些配置选项可用。</p><p>对于如何协同 Kubernetes 使用 containerd 和 CRI-O 的说明，参见 Kubernetes 文档中这部分：
<a href=/zh-cn/docs/setup/production-environment/container-runtimes>容器运行时</a>。</p><h3 id=what-if-I-have-more-questions>我还有问题怎么办？</h3><p>如果你使用了一个有供应商支持的 Kubernetes 发行版，你可以咨询供应商他们产品的升级计划。
对于最终用户的问题，请把问题发到我们的最终用户社区的<a href=https://discuss.kubernetes.io/>论坛</a>。</p><p>你也可以看看这篇优秀的博文：
<a href=https://dev.to/inductor/wait-docker-is-deprecated-in-kubernetes-now-what-do-i-do-e4m>等等，Docker 刚刚被 Kubernetes 废掉了？</a>
一个对此变化更深入的技术讨论。</p><h3 id=can-I-have-a-hug>我可以加入吗？</h3><p>只要你愿意，随时随地欢迎加入！</p></div><div class=td-content style=page-break-before:always><h1 id=pg-fcbc001800469c30982bca14879a3acb>为开发指南做贡献</h1><div class=lead>一位新的贡献者描述了编写和提交对 Kubernetes 开发指南的修改的经验。</div><div class="td-byline mb-4">By <b>Erik L. Arneson</b> |
<time datetime=2020-10-01 class=text-muted>2020.10.01</time></div><p>当大多数人想到为一个开源项目做贡献时，我猜想他们可能想到的是贡献代码修改、新功能和错误修复。作为一个软件工程师和一个长期的开源用户和贡献者，这也正是我的想法。
虽然我已经在不同的工作流中写了不少文档，但规模庞大的 Kubernetes 社区是一种新型 "客户"。我只是不知道当 Google 要求我和 <a href=https://lionswaycontent.com/>Lion's Way</a> 的同胞们对 Kubernetes 开发指南进行必要更新时会发生什么。</p><p><em>本文最初出现在 <a href=https://www.kubernetes.dev/blog/2020/09/28/contributing-to-the-development-guide/>Kubernetes Contributor Community blog</a>。</em></p><h2 id=与社区合作的乐趣>与社区合作的乐趣</h2><p>作为专业的写手，我们习惯了受雇于他人去书写非常具体的项目。我们专注于技术服务，产品营销，技术培训以及文档编制，范围从相对宽松的营销邮件到针对 IT 和开发人员的深层技术白皮书。
在这种专业服务下，每一个可交付的项目往往都有可衡量的投资回报。我知道在从事开源文档工作时不会出现这个指标，但我不确定它将如何改变我与项目的关系。</p><p>我们的写作和传统客户之间的关系有一个主要的特点，就是我们在一个公司里面总是有一两个主要的对接人。他们负责审查我们的文稿，并确保文稿内容符合公司的声明且对标于他们正在寻找的受众。
这随之而来的压力--正好解释了为什么我很高兴我的写作伙伴、鹰眼审稿人同时也是嗜血编辑的 <a href=https://twitter.com/JoelByronBarker>Joel</a> 处理了大部分的客户联系。</p><p>在与 Kubernetes 社区合作时，所有与客户接触的压力都消失了，这让我感到惊讶和高兴。</p><p>"我必须得多仔细？如果我搞砸了怎么办？如果我让开发商生气了怎么办？如果我树敌了怎么办？"。
当我第一次加入 Kubernetes Slack 上的 "#sig-contribex " 频道并宣布我将编写 <a href=https://github.com/kubernetes/community/blob/master/contributors/devel/development.md>开发指南</a> 时，这些问题都在我脑海中奔腾，让我感觉如履薄冰。</p><div class="card rounded p-2 td-post-card mb-4 mt-4" style=max-width:810px><img class=card-img-top src=/zh-cn/blog/2020/10/01/%E4%B8%BA%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97%E5%81%9A%E8%B4%A1%E7%8C%AE/jorge-castro-code-of-conduct_hu5bc3c30874931ced96ecf71d135c93d2_143155_800x450_fit_q75_catmullrom.jpg width=800 height=450><div class="card-body px-0 pt-2 pb-0"><p class=card-text>"Kubernetes 编码准则已经生效，让我们共同勉励。" &mdash; Jorge
Castro, SIG ContribEx co-chair</p></div></div><p>事实上我的担心是多虑的。很快，我就感觉到自己是被欢迎的。我倾向于认为这不仅仅是因为我正在从事一项急需的任务，而是因为 Kubernetes 社区充满了友好、热情的人们。
在每周的 SIG ContribEx 会议上，我们关于开发指南进展情况的报告会被立即纳入其中。此外，会议的领导会一直强调 <a href=https://www.kubernetes.dev/resources/code-of-conduct/>Kubernetes</a> 编码准则，我们应该像 Bill 和 Ted 一样，相互进步。</p><h2 id=这并不意味着这一切都很简单>这并不意味着这一切都很简单</h2><p>开发指南需要一次全面检查。当我们拿到它的时候，它已经捆绑了大量的信息和很多新开发者需要经历的步骤，但随着时间的推移和被忽视，它变得相当陈旧。
文档的确需要全局观，而不仅仅是点与点的修复。结果，最终我向这个项目提交了一个巨大的 pull 请求。<a href=https://github.com/kubernetes/community>社区仓库</a>：新增 267 行，删除 88 行。</p><p>pull 请求的周期需要一定数量的 Kubernetes 组织成员审查和批准更改后才能合并。这是一个很好的做法，因为它使文档和代码都保持在相当不错的状态，
但要哄骗合适的人花时间来做这样一个赫赫有名的审查是很难的。
因此，那次大规模的 PR 从我第一次提交到最后合并，用了 26 天。 但最终，<a href=https://github.com/kubernetes/community/pull/5003>它是成功的</a>.</p><p>由于 Kubernetes 是一个发展相当迅速的项目，而且开发人员通常对编写文档并不十分感兴趣，所以我也遇到了一个问题，那就是有时候，
描述 Kubernetes 子系统工作原理的秘密珍宝被深埋在 <a href=https://github.com/amwat>天才工程师的迷宫式思维</a> 中，而不是用单纯的英文写在 Markdown 文件中。
当我要更新端到端（e2e）测试的入门文档时，就一头撞上了这个问题。</p><p>这段旅程将我带出了编写文档的领域，进入到一些未完成软件的全新用户角色。最终我花了很多心思与新的 <a href=https://github.com/kubernetes-sigs/kubetest2>kubetest2`框架</a> 的开发者之一合作，
记录了最新 e2e 测试的启动和运行过程。
你可以通过查看我的 <a href=https://github.com/kubernetes/community/pull/5045>已完成的 pull request</a> 来自己判断结果。</p><h2 id=没有人是老板-每个人都给出反馈>没有人是老板，每个人都给出反馈。</h2><p>但当我暗自期待混乱的时候，为 Kubernetes 开发指南做贡献以及与神奇的 Kubernetes 社区互动的过程却非常顺利。
没有争执，我也没有树敌。每个人都非常友好和热情。这是令人<em>愉快的</em>。</p><p>对于一个开源项目，没人是老板。Kubernetes 项目，一个近乎巨大的项目，被分割成许多不同的特殊兴趣小组（SIG）、工作组和社区。
每个小组都有自己的定期会议、职责分配和主席推选。我的工作与 SIG ContribEx（负责监督并寻求改善贡献者体验）和 SIG Testing（负责测试）的工作有交集。
事实证明，这两个 SIG 都很容易合作，他们渴望贡献，而且都是非常友好和热情的人。</p><p>在 Kubernetes 这样一个活跃的、有生命力的项目中，文档仍然需要与代码库一起进行维护、修订和测试。
开发指南将继续对 Kubernetes 代码库的新贡献者起到至关重要的作用，正如我们的努力所显示的那样，该指南必须与 Kubernetes 项目的发展保持同步。</p><p>Joel 和我非常喜欢与 Kubernetes 社区互动并为开发指南做出贡献。我真的很期待，不仅能继续做出更多贡献，还能继续与过去几个月在这个庞大的开源社区中结识的新朋友进行合作。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-d9e35cec65c1d4e7fff2cc66f8423d52>结构化日志介绍</h1><div class="td-byline mb-4"><time datetime=2020-09-04 class=text-muted>2020.09.04</time></div><p><strong>作者：</strong> Marek Siarkowicz（谷歌），Nathan Beach（谷歌）</p><p>日志是可观察性的一个重要方面，也是调试的重要工具。 但是Kubernetes日志传统上是非结构化的字符串，因此很难进行自动解析，以及任何可靠的后续处理、分析或查询。</p><p>在Kubernetes 1.19中，我们添加结构化日志的支持，该日志本身支持（键，值）对和对象引用。 我们还更新了许多日志记录调用，以便现在将典型部署中超过99％的日志记录量迁移为结构化格式。</p><p>为了保持向后兼容性，结构化日志仍将作为字符串输出，其中该字符串包含这些“键” =“值”对的表示。 从1.19的Alpha版本开始，日志也可以使用<code>--logging-format = json</code>标志以JSON格式输出。</p><h2 id=使用结构化日志>使用结构化日志</h2><p>我们在klog库中添加了两个新方法：InfoS和ErrorS。 例如，InfoS的此调用：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span>klog.<span style=color:#00a000>InfoS</span>(<span style=color:#b44>&#34;Pod status updated&#34;</span>, <span style=color:#b44>&#34;pod&#34;</span>, klog.<span style=color:#00a000>KObj</span>(pod), <span style=color:#b44>&#34;status&#34;</span>, status)
</span></span></code></pre></div><p>将得到下面的日志输出：</p><pre tabindex=0><code>I1025 00:15:15.525108       1 controller_utils.go:116] &#34;Pod status updated&#34; pod=&#34;kube-system/kubedns&#34; status=&#34;ready&#34;
</code></pre><p>或者, 如果 --logging-format=json 模式被设置, 将会产生如下结果:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;ts&#34;</span>: <span style=color:#666>1580306777.04728</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;msg&#34;</span>: <span style=color:#b44>&#34;Pod status updated&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;pod&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;coredns&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;namespace&#34;</span>: <span style=color:#b44>&#34;kube-system&#34;</span>
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;status&#34;</span>: <span style=color:#b44>&#34;ready&#34;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这意味着下游日志记录工具可以轻松地获取结构化日志数据，而无需使用正则表达式来解析非结构化字符串。这也使处理日志更容易，查询日志更健壮，并且分析日志更快。</p><p>使用结构化日志，所有对Kubernetes对象的引用都以相同的方式进行结构化，因此您可以过滤输出并且仅引用特定Pod的日志条目。您还可以发现指示调度程序如何调度Pod，如何创建Pod，监测Pod的运行状况以及Pod生命周期中的所有其他更改的日志。</p><p>假设您正在调试Pod的问题。使用结构化日志，您可以只过滤查看感兴趣的Pod的日志条目，而无需扫描可能成千上万条日志行以找到相关的日志行。</p><p>结构化日志不仅在手动调试问题时更有用，而且还启用了更丰富的功能，例如日志的自动模式识别或日志和所跟踪数据的更紧密关联性（分析）。</p><p>最后，结构化日志可以帮助降低日志的存储成本，因为大多数存储系统比非结构化字符串更有效地压缩结构化键值数据。</p><h2 id=参与其中>参与其中</h2><p>虽然在典型部署中，我们已按日志量更新了99％以上的日志条目，但仍有数千个日志需要更新。 选择一个您要改进的文件或目录，然后<a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-instrumentation/migration-to-structured-logging.md>迁移现有的日志调用以使用结构化日志</a>。这是对Kubernetes做出第一笔贡献的好方法!</p></div><div class=td-content style=page-break-before:always><h1 id=pg-e99acccbdb5593353cf25826879389e4>警告: 有用的预警</h1><div class="td-byline mb-4"><time datetime=2020-09-03 class=text-muted>2020.09.03</time></div><p><strong>作者</strong>: <a href=https://github.com/liggitt>Jordan Liggitt</a> (Google)</p><p>作为 Kubernetes 维护者，我们一直在寻找在保持兼容性的同时提高可用性的方法。
在开发功能、分类 Bug、和回答支持问题的过程中，我们积累了有助于 Kubernetes 用户了解的信息。
过去，共享这些信息仅限于发布说明、公告电子邮件、文档和博客文章等带外方法。
除非有人知道需要寻找这些信息并成功找到它们，否则他们不会从中受益。</p><p>在 Kubernetes v1.19 中，我们添加了一个功能，允许 Kubernetes API
服务器<a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-api-machinery/1693-warnings>向 API 客户端发送警告</a>。
警告信息使用<a href=https://tools.ietf.org/html/rfc7234#section-5.5>标准 <code>Warning</code> 响应头</a>发送，
因此它不会以任何方式更改状态代码或响应体。
这一设计使得服务能够发送任何 API 客户端都可以轻松读取的警告，同时保持与以前的客户端版本兼容。</p><p>警告在 <code>kubectl</code> v1.19+ 的 <code>stderr</code> 输出中和 <code>k8s.io/client-go</code> v0.19.0+ 客户端库的日志中出现。
<code>k8s.io/client-go</code> 行为可以<a href=#customize-client-handling>在进程或客户端层面重载</a>。</p><h2 id=deprecation-warnings>弃用警告</h2><p>我们第一次使用此新功能是针对已弃用的 API 调用发送警告。</p><p>Kubernetes 是一个<a href=https://www.cncf.io/cncf-kubernetes-project-journey/#development-velocity>大型、快速发展的项目</a>。
跟上每个版本的<a href=https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG/CHANGELOG-1.19.md#changelog-since-v1180>变更</a>可能是令人生畏的，
即使对于全职从事该项目的人来说也是如此。一种重要的变更是 API 弃用。
随着 Kubernetes 中的 API 升级到 GA 版本，预发布的 API 版本会被弃用并最终被删除。</p><p>即使有<a href=/zh-cn/docs/reference/using-api/deprecation-policy/>延长的弃用期</a>，
并且<a href=https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG/CHANGELOG-1.19.md#deprecation>在发布说明中</a>也包含了弃用信息，
他们仍然很难被追踪。在弃用期内，预发布 API 仍然有效，
允许多个版本过渡到稳定的 API 版本。
然而，我们发现用户往往甚至没有意识到他们依赖于已弃用的 API 版本，
直到升级到不再提供相应服务的新版本。</p><p>从 v1.19 开始，系统每当收到针对已弃用的 REST API 的请求时，都会返回警告以及 API 响应。
此警告包括有关 API 将不再可用的版本以及替换 API 版本的详细信息。</p><p>因为警告源自服务器端，并在客户端层级被拦截，所以它适用于所有 kubectl 命令，
包括像 <code>kubectl apply</code> 这样的高级命令，以及像 <code>kubectl get --raw</code> 这样的低级命令：</p><p><img alt="kubectl 执行一个清单文件, 然后显示警告信息 'networking.k8s.io/v1beta1 Ingress is deprecated in v1.19+, unavailable in v1.22+; use networking.k8s.io/v1 Ingress'。" src=kubectl-warnings.png style=width:637px;max-width:100%></p><p>这有助于受弃用影响的人们知道他们所请求的API已被弃用，
他们有多长时间来解决这个问题，以及他们应该使用什么 API。
这在用户应用不是由他们创建的清单文件时特别有用，
所以他们有时间联系作者要一个更新的版本。</p><p>我们还意识到<strong>使用</strong>已弃用的 API 的人通常不是负责升级集群的人，
因此，我们添加了两个面向管理员的工具来帮助跟踪已弃用的 API 的使用情况并确定何时升级安全。</p><h3 id=metrics>度量指标</h3><p>从 Kubernetes v1.19 开始，当向已弃用的 REST API 端点发出请求时，
在 kube-apiserver 进程中，<code>apiserver_requested_deprecated_apis</code> 度量指标会被设置为 <code>1</code>。
该指标具有 API <code>group</code>、<code>version</code>、<code>resource</code> 和 <code>subresource</code> 的标签，
和一个 <code>removed_release</code> 标签，表明不再提供 API 的 Kubernetes 版本。</p><p>下面是一个使用 <code>kubectl</code> 的查询示例，<a href=https://github.com/prometheus/prom2json>prom2json</a>
和 <a href=https://stedolan.github.io/jq/>jq</a> 用来确定当前 API
服务器实例上收到了哪些对已弃用的 API 请求：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl get --raw /metrics | prom2json | jq <span style=color:#b44>&#39;
</span></span></span><span style=display:flex><span><span style=color:#b44>  .[] | select(.name==&#34;apiserver_requested_deprecated_apis&#34;).metrics[].labels
</span></span></span><span style=display:flex><span><span style=color:#b44>&#39;</span>
</span></span></code></pre></div><p>输出：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;group&#34;</span>: <span style=color:#b44>&#34;extensions&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;removed_release&#34;</span>: <span style=color:#b44>&#34;1.22&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;resource&#34;</span>: <span style=color:#b44>&#34;ingresses&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;subresource&#34;</span>: <span style=color:#b44>&#34;&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;version&#34;</span>: <span style=color:#b44>&#34;v1beta1&#34;</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;group&#34;</span>: <span style=color:#b44>&#34;rbac.authorization.k8s.io&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;removed_release&#34;</span>: <span style=color:#b44>&#34;1.22&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;resource&#34;</span>: <span style=color:#b44>&#34;clusterroles&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;subresource&#34;</span>: <span style=color:#b44>&#34;&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;version&#34;</span>: <span style=color:#b44>&#34;v1beta1&#34;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>输出展示在此服务器上请求了已弃用的 <code>extensions/v1beta1</code> Ingress 和 <code>rbac.authorization.k8s.io/v1beta1</code>
ClusterRole API，这两个 API 都将在 v1.22 中被删除。</p><p>我们可以将该信息与 <code>apiserver_request_total</code> 指标结合起来，以获取有关这些 API 请求的更多详细信息：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl get --raw /metrics | prom2json | jq <span style=color:#b44>&#39;
</span></span></span><span style=display:flex><span><span style=color:#b44>  # set $deprecated to a list of deprecated APIs
</span></span></span><span style=display:flex><span><span style=color:#b44>  [
</span></span></span><span style=display:flex><span><span style=color:#b44>    .[] | 
</span></span></span><span style=display:flex><span><span style=color:#b44>    select(.name==&#34;apiserver_requested_deprecated_apis&#34;).metrics[].labels |
</span></span></span><span style=display:flex><span><span style=color:#b44>    {group,version,resource}
</span></span></span><span style=display:flex><span><span style=color:#b44>  ] as $deprecated 
</span></span></span><span style=display:flex><span><span style=color:#b44>  
</span></span></span><span style=display:flex><span><span style=color:#b44>  |
</span></span></span><span style=display:flex><span><span style=color:#b44>  
</span></span></span><span style=display:flex><span><span style=color:#b44>  # select apiserver_request_total metrics which are deprecated
</span></span></span><span style=display:flex><span><span style=color:#b44>  .[] | select(.name==&#34;apiserver_request_total&#34;).metrics[] |
</span></span></span><span style=display:flex><span><span style=color:#b44>  select(.labels | {group,version,resource} as $key | $deprecated | index($key))
</span></span></span><span style=display:flex><span><span style=color:#b44>&#39;</span>
</span></span></code></pre></div><p>输出：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;labels&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;code&#34;</span>: <span style=color:#b44>&#34;0&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;component&#34;</span>: <span style=color:#b44>&#34;apiserver&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;contentType&#34;</span>: <span style=color:#b44>&#34;application/vnd.kubernetes.protobuf;stream=watch&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;dry_run&#34;</span>: <span style=color:#b44>&#34;&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;group&#34;</span>: <span style=color:#b44>&#34;extensions&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;resource&#34;</span>: <span style=color:#b44>&#34;ingresses&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;scope&#34;</span>: <span style=color:#b44>&#34;cluster&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;subresource&#34;</span>: <span style=color:#b44>&#34;&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;verb&#34;</span>: <span style=color:#b44>&#34;WATCH&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;version&#34;</span>: <span style=color:#b44>&#34;v1beta1&#34;</span>
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;value&#34;</span>: <span style=color:#b44>&#34;21&#34;</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;labels&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;code&#34;</span>: <span style=color:#b44>&#34;200&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;component&#34;</span>: <span style=color:#b44>&#34;apiserver&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;contentType&#34;</span>: <span style=color:#b44>&#34;application/vnd.kubernetes.protobuf&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;dry_run&#34;</span>: <span style=color:#b44>&#34;&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;group&#34;</span>: <span style=color:#b44>&#34;extensions&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;resource&#34;</span>: <span style=color:#b44>&#34;ingresses&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;scope&#34;</span>: <span style=color:#b44>&#34;cluster&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;subresource&#34;</span>: <span style=color:#b44>&#34;&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;verb&#34;</span>: <span style=color:#b44>&#34;LIST&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;version&#34;</span>: <span style=color:#b44>&#34;v1beta1&#34;</span>
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;value&#34;</span>: <span style=color:#b44>&#34;1&#34;</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;labels&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;code&#34;</span>: <span style=color:#b44>&#34;200&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;component&#34;</span>: <span style=color:#b44>&#34;apiserver&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;contentType&#34;</span>: <span style=color:#b44>&#34;application/json&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;dry_run&#34;</span>: <span style=color:#b44>&#34;&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;group&#34;</span>: <span style=color:#b44>&#34;rbac.authorization.k8s.io&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;resource&#34;</span>: <span style=color:#b44>&#34;clusterroles&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;scope&#34;</span>: <span style=color:#b44>&#34;cluster&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;subresource&#34;</span>: <span style=color:#b44>&#34;&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;verb&#34;</span>: <span style=color:#b44>&#34;LIST&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;version&#34;</span>: <span style=color:#b44>&#34;v1beta1&#34;</span>
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;value&#34;</span>: <span style=color:#b44>&#34;1&#34;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面的输出展示，对这些 API 发出的都只是读请求，并且大多数请求都用来监测已弃用的 Ingress API。</p><p>你还可以通过以下 Prometheus 查询获取这一信息，
该查询返回关于已弃用的、将在 v1.22 中删除的 API 请求的信息：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-promql data-lang=promql><span style=display:flex><span><span style=color:#b8860b>apiserver_requested_deprecated_apis</span>{<span style=color:#a0a000>removed_release</span><span style=color:#666>=</span>&#34;<span style=color:#b44>1.22</span>&#34;}<span style=color:#bbb> </span><span style=color:#666>*</span><span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>on</span><span style=color:#666>(</span><span style=color:#a2f;font-weight:700>group</span>,<span style=color:#b8860b>version</span>,<span style=color:#b8860b>resource</span>,<span style=color:#b8860b>subresource</span><span style=color:#666>)</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#a2f;font-weight:700>group_right</span><span style=color:#666>()</span><span style=color:#bbb> </span><span style=color:#b8860b>apiserver_request_total</span><span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=audit-annotations>审计注解</h3><p>度量指标是检查是否正在使用已弃用的 API 以及使用率如何的快速方法，
但它们没有包含足够的信息来识别特定的客户端或 API 对象。
从 Kubernetes v1.19 开始，
对已弃用的 API 的请求进行审计时，<a href=/zh-cn/docs/tasks/debug/debug-cluster/audit/>审计事件</a>中会包括
审计注解 <code>"k8s.io/deprecated":"true"</code>。
管理员可以使用这些审计事件来识别需要更新的特定客户端或对象。</p><h2 id=custom-resource-definitions>自定义资源定义</h2><p>除了 API 服务器对已弃用的 API 使用发出警告的能力外，从 v1.19 开始，CustomResourceDefinition
可以指示<a href=/zh-cn/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definition-versioning/#version-deprecation>它定义的资源的特定版本已被弃用</a>。
当对自定义资源的已弃用的版本发出 API 请求时，将返回一条警告消息，与内置 API 的行为相匹配。</p><p>CustomResourceDefinition 的作者还可以根据需要自定义每个版本的警告。
这允许他们在需要时提供指向迁移指南的信息或其他信息。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiextensions.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>CustomResourceDefinition<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>crontabs.example.com<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>versions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>v1alpha1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 这表示 v1alpha1 版本的自定义资源已经废弃了。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 对此版本的 API 请求会在服务器响应中收到警告。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>deprecated</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 这会把返回给发出 v1alpha1 API 请求的客户端的默认警告覆盖。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>deprecationWarning</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;example.com/v1alpha1 CronTab is deprecated; use example.com/v1 CronTab (see http://example.com/v1alpha1-v1)&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>v1beta1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 这表示 v1beta1 版本的自定义资源已经废弃了。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 对此版本的 API 请求会在服务器响应中收到警告。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 此版本返回默认警告消息。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>deprecated</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=admission-webhooks>准入 Webhook</h2><p><a href=/zh-cn/docs/reference/access-authn-authz/extensible-admission-controllers>准入 Webhook</a>是将自定义策略或验证与
Kubernetes 集成的主要方式。
从 v1.19 开始，Admission Webhook 可以<a href=/zh-cn/docs/reference/access-authn-authz/extensible-admission-controllers/#response>返回警告消息</a>，
传递给发送请求的 API 客户端。警告可以与允许或拒绝的响应一起返回。</p><p>例如，允许请求但警告已知某个配置无法正常运行时，准入 Webhook 可以发送以下响应：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;admission.k8s.io/v1&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;AdmissionReview&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;response&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;uid&#34;</span>: <span style=color:#b44>&#34;&lt;value from request.uid&gt;&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;allowed&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;warnings&#34;</span>: [
</span></span><span style=display:flex><span>      <span style=color:#b44>&#34;.spec.memory: requests &gt;1GB do not work on Fridays&#34;</span>
</span></span><span style=display:flex><span>    ]
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如果你在实现一个返回警告消息的 Webhook，这里有一些提示：</p><ul><li>不要在消息中包含 “Warning:” 前缀（由客户端在输出时添加）</li><li>使用警告消息来正确描述能被发出 API 请求的客户端纠正或了解的问题</li><li>保持简洁；如果可能，将警告限制为 120 个字符以内</li></ul><p>准入 Webhook 可以通过多种方式使用这个新功能，我期待看到大家想出来的方法。
这里有一些想法可以帮助你入门：</p><ul><li>添加 “complain” 模式的 Webhook 实现，它们返回警告而不是拒绝，
允许在开始执行之前尝试策略以验证它是否按预期工作</li><li>“lint” 或 “vet” 风格的 Webhook，检查对象并在未遵循最佳实践时显示警告</li></ul><h2 id=customize-client-handling>自定义客户端处理方式</h2><p>使用 <code>k8s.io/client-go</code> 库发出 API 请求的应用程序可以定制如何处理从服务器返回的警告。
默认情况下，收到的警告会以日志形式输出到 stderr，
但<a href=https://godoc.org/k8s.io/client-go/rest#SetDefaultWarningHandler>在进程层面</a>或[客户端层面]
(<a href=https://godoc.org/k8s.io/client-go/rest#Config>https://godoc.org/k8s.io/client-go/rest#Config</a>)均可定制这一行为。</p><p>这个例子展示了如何让你的应用程序表现得像 <code>kubectl</code>，
在进程层面重载整个消息处理逻辑以删除重复的警告，
并在支持的情况下使用彩色输出突出显示消息：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a2f;font-weight:700>import</span> (
</span></span><span style=display:flex><span>  <span style=color:#b44>&#34;os&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#b44>&#34;k8s.io/client-go/rest&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#b44>&#34;k8s.io/kubectl/pkg/util/term&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#666>...</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>main</span>() {
</span></span><span style=display:flex><span>  rest.<span style=color:#00a000>SetDefaultWarningHandler</span>(
</span></span><span style=display:flex><span>    rest.<span style=color:#00a000>NewWarningWriter</span>(os.Stderr, rest.WarningWriterOptions{
</span></span><span style=display:flex><span>        <span style=color:#080;font-style:italic>// only print a given warning the first time we receive it
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>        Deduplicate: <span style=color:#a2f;font-weight:700>true</span>,
</span></span><span style=display:flex><span>        <span style=color:#080;font-style:italic>// highlight the output with color when the output supports it
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>        Color: term.<span style=color:#00a000>AllowsColorOutput</span>(os.Stderr),
</span></span><span style=display:flex><span>      },
</span></span><span style=display:flex><span>    ),
</span></span><span style=display:flex><span>  )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#666>...</span>
</span></span></code></pre></div><p>下一个示例展示如何构建一个忽略警告的客户端。
这对于那些操作所有资源类型（使用发现 API 在运行时动态发现）
的元数据并且不会从已弃用的特定资源的警告中受益的客户端很有用。
对于需要使用特定 API 的客户端，不建议抑制弃用警告。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a2f;font-weight:700>import</span> (
</span></span><span style=display:flex><span>  <span style=color:#b44>&#34;k8s.io/client-go/rest&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:#b44>&#34;k8s.io/client-go/kubernetes&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>func</span> <span style=color:#00a000>getClientWithoutWarnings</span>(config <span style=color:#666>*</span>rest.Config) (kubernetes.Interface, <span style=color:#0b0;font-weight:700>error</span>) {
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>// copy to avoid mutating the passed-in config
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>  config = rest.<span style=color:#00a000>CopyConfig</span>(config)
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>// set the warning handler for this client to ignore warnings
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>  config.WarningHandler = rest.NoWarnings{}
</span></span><span style=display:flex><span>  <span style=color:#080;font-style:italic>// construct and return the client
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>  <span style=color:#a2f;font-weight:700>return</span> kubernetes.<span style=color:#00a000>NewForConfig</span>(config)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=kubectl-strict-mode>Kubectl 强制模式</h2><p>如果你想确保及时注意到弃用问题并立即着手解决它们，
<code>kubectl</code> 在 v1.19 中添加了 <code>--warnings-as-errors</code> 选项。使用此选项调用时，
<code>kubectl</code> 将从服务器收到的所有警告视为错误，并以非零码退出：</p><p><img alt="kubectl 在设置 --warnings-as-errors 标记的情况下执行一个清单文件, 返回警告消息和非零退出码。" src=kubectl-warnings-as-errors.png style=width:637px;max-width:100%></p><p>这可以在 CI 作业中用于将清单文件应用到当前服务器，
其中要求通过零退出码才能使 CI 作业成功。</p><h2 id=future-possibilities>未来的可能性</h2><p>现在我们有了一种在上下文中向用户传达有用信息的方法，
我们已经在考虑使用其他方法来改善人们使用 Kubernetes 的体验。
我们接下来要研究的几个领域是关于<a href=http://issue.k8s.io/64841#issuecomment-395141013>已知有问题的值</a>的警告。
出于兼容性原因，我们不能直接拒绝，而应就使用已弃用的字段或字段值
（例如使用 beta os/arch 节点标签的选择器，
<a href=/zh-cn/docs/reference/labels-annotations-taints/#beta-kubernetes-io-arch-deprecated>在 v1.14 中已弃用</a>）
给出警告。
我很高兴看到这方面的进展，继续让 Kubernetes 更容易使用。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-3b8326c4fb648224fb9cbdd4289cf6e8>Docsy 带来更好的 Docs UX</h1><div class="td-byline mb-4"><time datetime=2020-06-15 class=text-muted>2020.06.15</time></div><p><strong>作者：</strong> Zach Corleissen，Cloud Native Computing Foundation</p><p><strong>编者注：Zach 是 Kubernetes 文档特别兴趣小组（SIG Docs）的主席之一。</strong></p><p>我很高兴地宣布 <a href=https://kubernetes.io>Kubernetes 网站</a>现在采用了 <a href=https://docsy.dev>Docsy Hugo 主题</a>。</p><p>Docsy 主题改进了网站的组织结构和导航性能，并开辟了改进 API 参考的途径。
在 4 年多的时间里，尽管对用户体验方面的改进不多，但 Docsy 针对技术内容实现了一些最佳实践。
该主题使 Kubernetes 网站更易于阅读，并使各个页面更易于导航。
它大大改进了网站所需的外在形象。</p><p>例如：添加用于在页面上导航主题的右侧栏。无需再向上滚动导航！</p><p>该主题为网站的未来改进开辟了道路。
我最兴奋的 Docsy 功能是主题的 <a href=https://www.docsy.dev/docs/adding-content/shortcodes/#swaggerui><code>swaggerui</code> shortcode</a>，
它为从 OpenAPI 规范生成 API 引用提供了本地支持。
CNCF 正在与 <a href=https://developers.google.com/season-of-docs>Google Season of Docs</a>（GSoD）合作，希望在今年第四季度实现更好的 API 参考。
我们很有希望被选中，我们期待着谷歌在 8 月 16 日公布的项目清单。
自从我 2017 年第一次开始使用 SIG Docs 以来，更好的 API 参考一直是我的个人目标。
看到这个目标触手可及，真是令人兴奋。</p><p>作为 SIG Docs 的技术负责人之一，<a href=https://github.com/kbhawkey>Karen Bradshaw</a> 做了很多繁重的工作来解决广泛的网站兼容性问题，
包括在 2018 年我们从 <a href=2018-05-05-hugo-migration/>Jekyll 迁移到 Hugo</a> 时修复的最后一个<a href=https://github.com/kubernetes/website/pull/21359>遗留问题</a>。
我们的其他技术负责人，<a href=https://github.com/sftim>Tim Bannister</a> 和 <a href=https://github.com/onlydole>Taylor Dolezal</a> 提出过很多意见。</p><p>还要感谢 <a href=https://bep.is/>Björn-Erik Pedersen</a>，他提供了关于如何在 <a href=https://gohugo.io/news/0.60.0-relnotes/>0.60.0 版本</a>之后进行 Hugo 升级的宝贵建议。</p><p>CNCF 与不列颠哥伦比亚省维多利亚市的 <a href=https://gearboxbuilt.com/>Gearbox</a> 签约，将主题应用于该网站。
感谢 Aidan、Troy 和团队其他成员的所有工作！</p></div><div class=td-content style=page-break-before:always><h1 id=pg-b510a26fb64945b86595c4992b051dbd>Kubernetes 1.18: Fit & Finish</h1><div class="td-byline mb-4"><time datetime=2020-03-25 class=text-muted>2020.03.25</time></div><p><strong>作者:</strong> <a href=https://github.com/kubernetes/sig-release/blob/master/releases/release-1.18/release_team.md>Kubernetes 1.18 发布团队</a></p><p>我们很高兴宣布 Kubernetes 1.18 版本的交付，这是我们 2020 年的第一版！Kubernetes
1.18 包含 38 个增强功能：15 项增强功能已转为稳定版，11 项增强功能处于 beta
阶段，12 项增强功能处于 alpha 阶段。</p><p>Kubernetes 1.18 是一个近乎 “完美” 的版本。为了改善 beta 和稳定的特性，已进行了大量工作，
以确保用户获得更好的体验。我们在增强现有功能的同时也增加了令人兴奋的新特性，这些有望进一步增强用户体验。</p><p>对 alpha、beta 和稳定版进行几乎同等程度的增强是一项伟大的成就。它展现了社区在提高
Kubernetes 的可靠性以及继续扩展其现有功能方面所做的巨大努力。</p><h2 id=主要内容>主要内容</h2><h3 id=kubernetes-拓扑管理器-topology-manager-进入-beta-阶段-对齐>Kubernetes 拓扑管理器（Topology Manager）进入 Beta 阶段 - 对齐！</h3><p>Kubernetes 在 1.18 版中的 Beta 阶段功能<a href=https://github.com/nolancon/website/blob/f4200307260ea3234540ef13ed80de325e1a7267/content/en/docs/tasks/administer-cluster/topology-manager.md>拓扑管理器特性</a>启用
CPU 和设备（例如 SR-IOV VF）的 NUMA 对齐，这将使你的工作负载在针对低延迟而优化的环境中运行。
在引入拓扑管理器之前，CPU 和设备管理器将做出彼此独立的资源分配决策。
这可能会导致在多处理器系统上非预期的资源分配结果，从而导致对延迟敏感的应用程序的性能下降。</p><h3 id=serverside-apply-推出-beta-2>Serverside Apply 推出 Beta 2</h3><p>Serverside Apply 在1.16 中进入 Beta 阶段，但现在在 1.18 中进入了第二个 Beta 阶段。
这个新版本将跟踪和管理所有新 Kubernetes 对象的字段更改，从而使你知道什么更改了资源以及何时发生了更改。</p><h3 id=使用-ingressclass-扩展-ingress-并用-ingressclass-替换已弃用的注释>使用 IngressClass 扩展 Ingress 并用 IngressClass 替换已弃用的注释</h3><p>在 Kubernetes 1.18 中，Ingress 有两个重要的补充：一个新的 <code>pathType</code> 字段和一个新的
<code>IngressClass</code> 资源。<code>pathType</code> 字段允许指定路径的匹配方式。除了默认的
<code>ImplementationSpecific</code> 类型外，还有新的 <code>Exact</code> 和 <code>Prefix</code> 路径类型。</p><p><code>IngressClass</code> 资源用于描述 Kubernetes 集群中 Ingress 的类型。Ingress 对象可以通过在
Ingress 资源类型上使用新的 <code>ingressClassName</code> 字段来指定与它们关联的类。
这个新的资源和字段替换了不再建议使用的 <code>kubernetes.io/ingress.class</code> 注解。</p><h3 id=sig-cli-引入了-kubectl-alpha-debug>SIG-CLI 引入了 kubectl alpha debug</h3><p>SIG-CLI 一直在争论着调试工具的必要性。随着<a href=https://kubernetes.io/docs/concepts/workloads/pods/ephemeral-containers/>临时容器</a>的发展，
我们如何使用基于 <code>kubectl exec</code> 的工具来支持开发人员的必要性变得越来越明显。
<a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-cli/20190805-kubectl-debug.md><code>kubectl alpha debug</code> 命令</a>的增加，
（由于是 alpha 阶段，非常欢迎你反馈意见），使开发人员可以轻松地在集群中调试 Pod。
我们认为这个功能的价值非常高。此命令允许创建一个临时容器，该容器在要尝试检查的
Pod 旁边运行，并且还附加到控制台以进行交互式故障排除。</p><h3 id=为-kubernetes-引入-windows-csi-支持-alpha>为 Kubernetes 引入 Windows CSI 支持（Alpha）</h3><p>用于 Windows 的 CSI 代理的 Alpha 版本随 Kubernetes 1.18 一起发布。CSI 代理通过允许
Windows 中的容器执行特权存储操作来启用 Windows 上的 CSI 驱动程序。</p><h2 id=其它更新>其它更新</h2><h3 id=毕业转为稳定版>毕业转为稳定版</h3><ul><li><a href=https://github.com/kubernetes/enhancements/issues/166>基于污点的逐出操作</a></li><li><a href=https://github.com/kubernetes/enhancements/issues/491><code>kubectl diff</code></a></li><li><a href=https://github.com/kubernetes/enhancements/issues/565>CSI 块存储支持</a></li><li><a href=https://github.com/kubernetes/enhancements/issues/576>API 服务器 dry run</a></li><li><a href=https://github.com/kubernetes/enhancements/issues/603>在 CSI 调用中传递 Pod 信息</a></li><li><a href=https://github.com/kubernetes/enhancements/issues/670>支持树外 vSphere 云驱动</a></li><li><a href=https://github.com/kubernetes/enhancements/issues/689>对 Windows 负载支持 GMSA</a></li><li><a href=https://github.com/kubernetes/enhancements/issues/770>对不可挂载的CSI卷跳过挂载</a></li><li><a href=https://github.com/kubernetes/enhancements/issues/989>PVC 克隆</a></li><li><a href=https://github.com/kubernetes/enhancements/issues/1020>移动 kubectl 包代码到 staging</a></li><li><a href=https://github.com/kubernetes/enhancements/issues/1043>Windows 的 RunAsUserName</a></li><li><a href=https://github.com/kubernetes/enhancements/issues/1507>服务和端点的 AppProtocol</a></li><li><a href=https://github.com/kubernetes/enhancements/issues/1539>扩展 Hugepage 特性</a></li><li><a href=https://github.com/kubernetes/enhancements/issues/1601>client-go signature refactor to standardize options and context handling</a></li><li><a href=https://github.com/kubernetes/enhancements/issues/1024>Node-local DNS cache</a></li></ul><h3 id=主要变化>主要变化</h3><ul><li><a href=https://github.com/kubernetes/enhancements/issues/752>EndpointSlice API</a></li><li><a href=https://github.com/kubernetes/enhancements/issues/1020>Moving kubectl package code to staging</a></li><li><a href=https://github.com/kubernetes/enhancements/issues/1513>CertificateSigningRequest API</a></li><li><a href=https://github.com/kubernetes/enhancements/issues/1539>Extending Hugepage Feature</a></li><li><a href=https://github.com/kubernetes/enhancements/issues/1601>client-go 的调用规范重构来标准化选项和管理上下文</a></li></ul><h3 id=发布说明>发布说明</h3><p>在我们的<a href=https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG/CHANGELOG-1.18.md>发布文档</a>中查看
Kubernetes 1.18 发行版的完整详细信息。</p><h3 id=下载安装>下载安装</h3><p>Kubernetes 1.18 可以在 <a href=https://github.com/kubernetes/kubernetes/releases/tag/v1.18.0>GitHub</a>
上下载。要开始使用 Kubernetes，请查看这些<a href=https://kubernetes.io/docs/tutorials/>交互教程</a>或通过
<a href=https://kind.sigs.k8s.io/>kind</a> 使用 Docker 容器运行本地 kubernetes 集群。你还可以使用
<a href=https://kubernetes.io/docs/setup/independent/create-cluster-kubeadm/>kubeadm</a> 轻松安装 1.18。</p><h3 id=发布团队>发布团队</h3><p>通过数百位贡献了技术和非技术内容的个人的努力，使本次发行成为可能。
特别感谢由 Searchable AI 的网站可靠性工程师 Jorge Alarcon Ochoa
领导的<a href=https://github.com/kubernetes/sig-release/blob/master/releases/release-1.18/release_team.md>发布团队</a>。
34 位发布团队成员协调了发布的各个方面，从文档到测试、验证和功能完整性。</p><p>随着 Kubernetes 社区的发展壮大，我们的发布过程很好地展示了开源软件开发中的协作。
Kubernetes 继续快速获取新用户。这种增长创造了一个积极的反馈回路，
其中有更多的贡献者提交了代码，从而创建了更加活跃的生态系统。迄今为止，Kubernetes 已有
<a href="https://k8s.devstats.cncf.io/d/24/overall-project-statistics?orgId=1">40,000 独立贡献者</a>和一个超过 3000 人的活跃社区。</p><h3 id=发布-logo>发布 logo</h3><p><img src=/images/blog/2020-03-25-kubernetes-1.18-release-announcement/release-logo.png alt="Kubernetes 1.18 发布图标"></p><h4 id=为什么是-lhc>为什么是 LHC</h4><p>LHC 是世界上最大，功能最强大的粒子加速器。它是由来自世界各地成千上万科学家合作的结果，
所有这些合作都是为了促进科学的发展。以类似的方式，Kubernetes
已经成为一个聚集了来自数百个组织的数千名贡献者–所有人都朝着在各个方面改善云计算的相同目标努力的项目！
发布名称 “A Bit Quarky” 的意思是提醒我们，非常规的想法可以带来巨大的变化，对开放性保持开放态度将有助于我们进行创新。</p><h4 id=关于设计者>关于设计者</h4><p>Maru Lango 是目前居住在墨西哥城的设计师。她的专长是产品设计，她还喜欢使用 CSS + JS
进行品牌、插图和视觉实验，为技术和设计社区的多样性做贡献。你可能会在大多数社交媒体上以
@marulango 的身份找到她，或查看她的网站： <a href=https://marulango.com>https://marulango.com</a></p><h3 id=高光用户>高光用户</h3><ul><li>爱立信正在使用 Kubernetes 和其他云原生技术来交付<a href=https://www.cncf.io/case-study/ericsson/>高标准的 5G 网络</a>，
这可以在 CI/CD 上节省多达 90％ 的支出。</li><li>Zendesk 正在使用 Kubernetes <a href=https://www.cncf.io/case-study/zendesk/>运行其现有应用程序的约 70％</a>。
它还正在使所构建的所有新应用都可以在 Kubernetes 上运行，从而节省时间、提高灵活性并加快其应用程序开发的速度。</li><li>LifeMiles 因迁移到 Kubernetes 而<a href=https://www.cncf.io/case-study/lifemiles/>降低了 50% 的基础设施开支</a>。
Kubernetes 还使他们可以将其可用资源容量增加一倍。</li></ul><h3 id=生态系统更新>生态系统更新</h3><ul><li>CNCF 发布了<a href=https://www.cncf.io/blog/2020/03/04/2019-cncf-survey-results-are-here-deployments-are-growing-in-size-and-speed-as-cloud-native-adoption-becomes-mainstream/>年度调查</a>的结果，
表明 Kubernetes 在生产中的使用正在飞速增长。调查发现，有 78％ 的受访者在生产中使用 Kubernetes，而去年这一比例为 58％。</li><li>CNCF 举办的 “Kubernetes 入门” 课程有<a href=https://www.cncf.io/announcement/2020/01/28/cloud-native-computing-foundation-announces-introduction-to-kubernetes-course-surpasses-100000-registrations/>超过 100,000 人注册</a>。</li></ul><h3 id=项目速度>项目速度</h3><p>CNCF 继续完善 DevStats。这是一个雄心勃勃的项目，旨在对项目中的无数贡献数据进行可视化展示。
<a href="https://k8s.devstats.cncf.io/d/12/dashboards?orgId=1">K8s DevStats</a> 展示了主要公司贡献者的贡献细目，
以及一系列令人印象深刻的预定义的报告，涉及从贡献者个人的各方面到 PR 生命周期的各个方面。</p><p>在过去的一个季度中，641 家不同的公司和超过 6,409 个个人为 Kubernetes 作出贡献。
<a href="https://k8s.devstats.cncf.io/d/11/companies-contributing-in-repository-groups?orgId=1&var-period=m&var-repogroup_name=All">查看 DevStats</a>
以了解有关 Kubernetes 项目和社区发展速度的信息。</p><h3 id=活动信息>活动信息</h3><p>Kubecon + CloudNativeCon EU 2020 已经推迟 - 有关最新信息，
请查看<a href=https://events.linuxfoundation.org/kubecon-cloudnativecon-europe/attend/novel-coronavirus-update/>新型肺炎发布页面</a>。</p><h3 id=即将到来的发布的线上会议>即将到来的发布的线上会议</h3><p>在 2020 年 4 月 23 日，和 Kubernetes 1.18 版本团队一起了解此版本的主要功能，
包括 kubectl debug、拓扑管理器、Ingress 毕业为 V1 版本以及 client-go。
在此处注册： <a href=https://www.cncf.io/webinars/kubernetes-1-18/>https://www.cncf.io/webinars/kubernetes-1-18/</a> 。</p><h3 id=如何参与>如何参与</h3><p>参与 Kubernetes 的最简单方法是加入众多与你的兴趣相关的<a href=https://github.com/kubernetes/community/blob/master/sig-list.md>特别兴趣小组</a>（SIGs）之一。
你有什么想向 Kubernetes 社区发布的内容吗？参与我们的每周<a href=https://github.com/kubernetes/community/tree/master/communication>社区会议</a>，
并通过以下渠道分享你的声音。感谢你一直以来的反馈和支持。</p><ul><li>在 Twitter 上关注我们 <a href=https://twitter.com/kubernetesio>@Kubernetesio</a>，了解最新动态</li><li>在 <a href=https://discuss.kubernetes.io/>Discuss</a> 上参与社区讨论</li><li>加入 <a href=http://slack.k8s.io/>Slack</a> 上的社区</li><li>在 <a href=http://stackoverflow.com/questions/tagged/kubernetes>Stack Overflow</a> 提问（或回答）</li><li>分享你的 Kubernetes <a href=https://docs.google.com/a/linuxfoundation.org/forms/d/e/1FAIpQLScuI7Ye3VQHQTwBASrgkjQDSS5TP0g3AXfFhwSM9YpHgxRKFA/viewform>故事</a></li><li>通过 <a href=https://kubernetes.io/blog/>blog</a> 了解更多关于 Kubernetes 的新鲜事</li><li>了解更多关于 <a href=https://github.com/kubernetes/sig-release/tree/master/release-team>Kubernetes 发布团队</a>的信息</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-951c3eb34e5599cb9806fb380774663c>基于 MIPS 架构的 Kubernetes 方案</h1><div class="td-byline mb-4"><time datetime=2020-01-15 class=text-muted>2020.01.15</time></div><p><strong>作者:</strong> 石光银，尹东超，展望，江燕，蔡卫卫，高传集，孙思清（浪潮）</p><h2 id=背景>背景</h2><p><a href=https://zh.wikipedia.org/wiki/MIPS%E6%9E%B6%E6%A7%8B>MIPS</a> (Microprocessor without Interlocked Pipelined Stages) 是一种采取精简指令集（RISC）的处理器架构 (ISA)，出现于 1981 年，由 MIPS 科技公司开发。如今 MIPS 架构被广泛应用于许多电子产品上。</p><p><a href=https://kubernetes.io>Kubernetes</a> 官方目前支持众多 CPU 架构诸如 x86, arm/arm64, ppc64le, s390x 等。然而目前还不支持 MIPS 架构，始终是一个遗憾。随着云原生技术的广泛应用，MIPS 架构下的用户始终对 Kubernetes on MIPS 有着迫切的需求。</p><h2 id=成果>成果</h2><p>多年来，为了丰富开源社区的生态，我们一直致力于在 MIPS 架构下适配 Kubernetes。随着 MIPS CPU 的不断迭代优化和性能的提升，我们在 mips64el 平台上取得了一些突破性的进展。</p><p>多年来，我们一直积极投入 Kubernetes 社区，在 Kubernetes 技术应用和优化方面具备了丰富的经验。最近，我们在研发过程中尝试将 Kubernetes 适配到 MIPS 架构平台，并取得了阶段性成果。成功完成了 Kubernetes 以及相关组件的迁移适配，不仅搭建出稳定高可用的 MIPS 集群，同时完成了 Kubernetes v1.16.2 版本的一致性测试。</p><p><img src=/images/blog/2020-01-15-Kubernetes-on-MIPS/kubernetes-on-mips.png alt="Kubernetes on MIPS"></p><p><em>图一 Kubernetes on MIPS</em></p><h2 id=k8s-mips-组件构建>K8S-MIPS 组件构建</h2><p>几乎所有的 Kubernetes 相关的云原生组件都没有提供 MIPS 版本的安装包或镜像，在 MIPS 平台上部署 Kubernetes 的前提是自行编译构建出全部所需组件。这些组件主要包括：</p><ul><li>golang</li><li>docker-ce</li><li>hyperkube</li><li>pause</li><li>etcd</li><li>calico</li><li>coredns</li><li>metrics-server</li></ul><p>得益于 Golang 优秀的设计以及对于 MIPS 平台的良好支持，极大地简化了上述云原生组件的编译过程。首先，我们在 mips64el 平台编译出了最新稳定的 golang, 然后通过源码构建的方式编译完成了上述大部分组件。</p><p>在编译过程中，我们不可避免地遇到了很多平台兼容性的问题，比如关于 golang 系统调用 (syscall) 的兼容性问题, syscall.Stat_t 32 位 与 64 位类型转换，EpollEvent 修正位缺失等等。</p><p>构建 K8S-MIPS 组件主要使用了交叉编译技术。构建过程包括集成 QEMU 工具来实现 MIPS CPU 指令的转换。同时修改 Kubernetes 和 E2E 镜像的构建脚本，构建了 Hyperkube 和 MIPS 架构的 E2E 测试镜像。</p><p>成功构建出以上组件后，我们使用工具完成 Kubernetes 集群的搭建，比如 kubespray、kubeadm 等。</p><table><thead><tr><th>名称</th><th>版本</th><th>MIPS 镜像仓库</th></tr></thead><tbody><tr><td>MIPS 版本 golang</td><td>1.12.5</td><td>-</td></tr><tr><td>MIPS 版本 docker-ce</td><td>18.09.8</td><td>-</td></tr><tr><td>MIPS 版本 CKE 构建 metrics-server</td><td>0.3.2</td><td><code>registry.inspurcloud.cn/library/cke/kubernetes/metrics-server-mips64el:v0.3.2</code></td></tr><tr><td>MIPS 版本 CKE 构建 etcd</td><td>3.2.26</td><td><code>registry.inspurcloud.cn/library/cke/etcd/etcd-mips64el:v3.2.26</code></td></tr><tr><td>MIPS 版本 CKE 构建 pause</td><td>3.1</td><td><code>registry.inspurcloud.cn/library/cke/kubernetes/pause-mips64el:3.1</code></td></tr><tr><td>MIPS 版本 CKE 构建 hyperkube</td><td>1.14.3</td><td><code>registry.inspurcloud.cn/library/cke/kubernetes/hyperkube-mips64el:v1.14.3</code></td></tr><tr><td>MIPS 版本 CKE 构建 coredns</td><td>1.6.5</td><td><code>registry.inspurcloud.cn/library/cke/kubernetes/coredns-mips64el:v1.6.5</code></td></tr><tr><td>MIPS 版本 CKE 构建 calico</td><td>3.8.0</td><td><code>registry.inspurcloud.cn/library/cke/calico/cni-mips64el:v3.8.0</code> <code>registry.inspurcloud.cn/library/cke/calico/ctl-mips64el:v3.8.0</code> <code>registry.inspurcloud.cn/library/cke/calico/node-mips64el:v3.8.0</code> <code>registry.inspurcloud.cn/library/cke/calico/kube-controllers-mips64el:v3.8.0</code></td></tr></tbody></table><p><strong>注</strong>: CKE 是浪潮推出的一款基于 Kubernetes 的容器云服务引擎</p><p><img src=/images/blog/2020-01-15-Kubernetes-on-MIPS/k8s-mips-cluster-components.png alt="K8S-MIPS Cluster Components"></p><p><em>图二 K8S-MIPS 集群组件</em></p><p><img src=/images/blog/2020-01-15-Kubernetes-on-MIPS/cpu-architecture.png alt="CPU Architecture"></p><p><em>图三 CPU 架构</em></p><p><img src=/images/blog/2020-01-15-Kubernetes-on-MIPS/cluster-node-information.png alt="Cluster Node Information"></p><p><em>图四 集群节点信息</em></p><h2 id=运行-k8s-一致性测试>运行 K8S 一致性测试</h2><p>验证 K8S-MIP 集群稳定性和可用性最简单直接的方式是运行 Kubernetes 的 <a href=https://github.com/kubernetes/kubernetes/blob/v1.16.2/cluster/images/conformance/README.md>一致性测试</a>。</p><p>一致性测试是一个独立的容器，用于启动 Kubernetes 端到端的一致性测试。</p><p>当执行一致性测试时，测试程序会启动许多 Pod 进行各种端到端的行为测试，这些 Pod 使用的镜像源码大部分来自于 <code>kubernetes/test/images</code> 目录下，构建的镜像位于 <code>gcr.io/kubernetes-e2e-test-images/</code>。由于镜像仓库中目前并不存在 MIPS 架构的镜像，我们要想运行 E2E 测试，必须首先构建出测试所需的全部镜像。</p><h3 id=构建测试所需镜像>构建测试所需镜像</h3><p>第一步是找到测试所需的所有镜像。我们可以执行 <code>sonobuoy images-p e2e</code> 命令来列出所有镜像，或者我们可以在 <a href=https://github.com/kubernetes/kubernetes/blob/master/test/utils/image/manifest.go>/test/utils/image/manifest.go</a> 中找到这些镜像。尽管 Kubernetes 官方提供了完整的 Makefile 和 shell 脚本，为构建测试映像提供了命令，但是仍然有许多与体系结构相关的问题未能解决，比如基础映像和依赖包的不兼容问题。因此，我们无法通过直接执行这些构建命令来制作 mips64el 架构镜像。</p><p>多数测试镜像都是使用 golang 编写，然后编译出二进制文件，并基于相应的 Dockerfile 制作出镜像。这些镜像对我们来说可以轻松地制作出来。但是需要注意一点：测试镜像默认使用的基础镜像大多是 alpine, 目前 <a href=https://www.alpinelinux.org/>Alpine</a> 官方并不支持 mips64el 架构，我们暂时未能自己制作出 mips64el 版本的 alpine 础镜像，只能将基础镜像替换为我们目前已有的 mips64el 基础镜像，比如 debian-stretch,fedora, ubuntu 等。替换基础镜像的同时也需要替换安装依赖包的命令，甚至依赖包的版本等。</p><p>有些测试所需镜像的源码并不在 <code>kubernetes/test/images</code> 下,比如 <code>gcr.io/google-samples/gb-frontend:v6</code> 等，没有明确的文档说明这类镜像来自于何方，最终还是在 <a href=github.com/GoogleCloudPlatform/kubernetes-engine-samples>github.com/GoogleCloudPlatform/kubernetes-engine-samples</a> 这个仓库找到了原始的镜像源代码。但是很快我们遇到了新的问题，为了制作这些镜像，还要制作它依赖的基础镜像，甚至基础镜像的基础镜像，比如 <code>php:5-apache</code>、<code>redis</code>、<code>perl</code> 等等。</p><p>经过漫长庞杂的的镜像重制工作，我们完成了总计约 40 个镜像的制作 ，包括测试镜像以及直接和间接依赖的基础镜像。
最终我们将所有镜像在集群内准备妥当，并确保测试用例内所有 Pod 的镜像拉取策略设置为 <code>imagePullPolicy: ifNotPresent</code>。</p><p>这是我们构建出的部分镜像列表：</p><ul><li><code>docker.io/library/busybox:1.29</code></li><li><code>docker.io/library/nginx:1.14-alpine</code></li><li><code>docker.io/library/nginx:1.15-alpine</code></li><li><code>docker.io/library/perl:5.26</code></li><li><code>docker.io/library/httpd:2.4.38-alpine</code></li><li><code>docker.io/library/redis:5.0.5-alpine</code></li><li><code>gcr.io/google-containers/conformance:v1.16.2</code></li><li><code>gcr.io/google-containers/hyperkube:v1.16.2</code></li><li><code>gcr.io/google-samples/gb-frontend:v6</code></li><li><code>gcr.io/kubernetes-e2e-test-images/agnhost:2.6</code></li><li><code>gcr.io/kubernetes-e2e-test-images/apparmor-loader:1.0</code></li><li><code>gcr.io/kubernetes-e2e-test-images/dnsutils:1.1</code></li><li><code>gcr.io/kubernetes-e2e-test-images/echoserver:2.2</code></li><li><code>gcr.io/kubernetes-e2e-test-images/ipc-utils:1.0</code></li><li><code>gcr.io/kubernetes-e2e-test-images/jessie-dnsutils:1.0</code></li><li><code>gcr.io/kubernetes-e2e-test-images/kitten:1.0</code></li><li><code>gcr.io/kubernetes-e2e-test-images/metadata-concealment:1.2</code></li><li><code>gcr.io/kubernetes-e2e-test-images/mounttest-user:1.0</code></li><li><code>gcr.io/kubernetes-e2e-test-images/mounttest:1.0</code></li><li><code>gcr.io/kubernetes-e2e-test-images/nautilus:1.0</code></li><li><code>gcr.io/kubernetes-e2e-test-images/nonewprivs:1.0</code></li><li><code>gcr.io/kubernetes-e2e-test-images/nonroot:1.0</code></li><li><code>gcr.io/kubernetes-e2e-test-images/resource-consumer-controller:1.0</code></li><li><code>gcr.io/kubernetes-e2e-test-images/resource-consumer:1.5</code></li><li><code>gcr.io/kubernetes-e2e-test-images/sample-apiserver:1.10</code></li><li><code>gcr.io/kubernetes-e2e-test-images/test-webserver:1.0</code></li><li><code>gcr.io/kubernetes-e2e-test-images/volume/gluster:1.0</code></li><li><code>gcr.io/kubernetes-e2e-test-images/volume/iscsi:2.0</code></li><li><code>gcr.io/kubernetes-e2e-test-images/volume/nfs:1.0</code></li><li><code>gcr.io/kubernetes-e2e-test-images/volume/rbd:1.0.1</code></li><li><code>k8s.gcr.io/etcd:3.3.15</code></li><li><code>k8s.gcr.io/pause:3.1</code></li></ul><p>最终我们执行一致性测试并且得到了测试报告，包括 <code>e2e.log</code>，显示我们通过了全部的测试用例。此外，我们将测试结果以 <a href=https://github.com/cncf/k8s-conformance/pull/779>pull request</a> 的形式提交给了 <a href=https://github.com/cncf/k8s-conformance>k8s-conformance</a> 。</p><p><img src=/images/blog/2020-01-15-Kubernetes-on-MIPS/pull-request-for-conformance-test-results.png alt="Pull request for conformance test results"></p><p><em>图五 一致性测试结果的 PR</em></p><h2 id=后续计划>后续计划</h2><p>我们手动构建了 K8S-MIPS 组件以及执行了 E2E 测试，验证了 Kubernetes on MIPS 的可行性，极大的增强了我们对于推进 Kubernetes 支持 MIPS 架构的信心。</p><p>后续，我们将积极地向社区贡献我们的工作经验以及成果，提交 PR 以及 Patch For MIPS 等， 希望能够有更多的来自社区的力量加入进来，共同推进 Kubernetes for MIPS 的进程。</p><p>后续开源贡献计划：</p><ul><li>贡献构建 E2E 测试镜像代码</li><li>贡献构建 MIPS 版本 hyperkube 代码</li><li>贡献构建 MIPS 版本 kubeadm 等集群部署工具</li></ul><hr></div><div class=td-content style=page-break-before:always><h1 id=pg-9e22e84688a3e1e7622241facd484d8a>Kubernetes 1.17：稳定</h1><div class="td-byline mb-4"><time datetime=2019-12-09 class=text-muted>2019.12.09</time></div><p><strong>作者:</strong> <a href=https://github.com/kubernetes/sig-release/blob/master/releases/release-1.17/release_team.md>Kubernetes 1.17发布团队</a></p><p>我们高兴的宣布Kubernetes 1.17版本的交付，它是我们2019年的第四个也是最后一个发布版本。Kubernetes v1.17包含22个增强功能：有14个增强已经逐步稳定(stable)，4个增强功能已经进入公开测试版(beta)，4个增强功能刚刚进入内部测试版(alpha)。</p><h2 id=主要的主题>主要的主题</h2><h3 id=云服务提供商标签基本可用>云服务提供商标签基本可用</h3><p>作为公开测试版特性添加到 v1.2 ，v1.17 中可以看到云提供商标签达到基本可用。</p><h3 id=卷快照进入公开测试版>卷快照进入公开测试版</h3><p>在 v1.17 中，Kubernetes卷快照特性是公开测试版。这个特性是在 v1.12 中以内部测试版引入的，第二个有重大变化的内部测试版是 v1.13 。</p><h2 id=容器存储接口迁移公开测试版>容器存储接口迁移公开测试版</h2><p>在 v1.17 中，Kubernetes树内存储插件到容器存储接口(CSI)的迁移基础架构是公开测试版。容器存储接口迁移最初是在Kubernetes v1.14 中以内部测试版引入的。</p><h2 id=云服务提供商标签基本可用-1>云服务提供商标签基本可用</h2><p>当节点和卷被创建，会基于基础云提供商的Kubernetes集群打上一系列标准标签。节点会获得一个实例类型标签。节点和卷都会得到两个描述资源在云提供商拓扑的位置标签,通常是以区域和地区的方式组织。</p><p>Kubernetes组件使用标准标签来支持一些特性。例如，调度者会保证pods和它们所声明的卷放置在相同的区域；当调度部署的pods时，调度器会优先将它们分布在不同的区域。你还可以在自己的pods标准中利用标签来配置，如节点亲和性，之类的事。标准标签使得你写的pod规范在不同的云提供商之间是可移植的。</p><p>在这个版本中，标签已经达到基本可用。Kubernetes组件都已经更新，可以填充基本可用和公开测试版标签，并对两者做出反应。然而，如果你的pod规范或自定义的控制器正在使用公开测试版标签，如节点亲和性，我们建议你可以将它们迁移到新的基本可用标签中。你可以从如下地方找到新标签的文档：</p><ul><li><a href=/zh-cn/docs/reference/labels-annotations-taints/#nodekubernetesioinstance-type>实例类型</a></li><li><a href=/zh-cn/docs/reference/labels-annotations-taints/#topologykubernetesioregion>地区</a></li><li><a href=/zh-cn/docs/reference/labels-annotations-taints/#topologykubernetesiozone>区域</a></li></ul><h2 id=卷快照进入公开测试版-1>卷快照进入公开测试版</h2><p>在 v1.17 中，Kubernetes卷快照是是公开测试版。最初是在 v1.12 中以内部测试版引入的，第二个有重大变化的内部测试版是 v1.13 。这篇文章总结它在公开版本中的变化。</p><h3 id=卷快照是什么>卷快照是什么？</h3><p>许多的存储系统(如谷歌云持久化磁盘，亚马逊弹性块存储和许多的内部存储系统)支持为持久卷创建快照。快照代表卷在一个时间点的复制。它可用于配置新卷(使用快照数据提前填充)或恢复卷到一个之前的状态(用快照表示)。</p><h3 id=为什么给kubernetes加入卷快照>为什么给Kubernetes加入卷快照？</h3><p>Kubernetes卷插件系统已经提供了功能强大的抽象用于自动配置、附加和挂载块文件系统。</p><p>支持所有这些特性是Kubernetes负载可移植的目标：Kubernetes旨在分布式系统应用和底层集群之间创建一个抽象层,使得应用可以不感知其运行集群的具体信息并且部署也不需特定集群的知识。</p><p>Kubernetes存储特别兴趣组(SIG)将快照操作确定为对很多有状态负载的关键功能。如数据库管理员希望在操作数据库前保存数据库卷快照。</p><p>在Kubernetes接口中提供一种标准的方式触发快照操作，Kubernetes用户可以处理这种用户场景，而不必使用Kubernetes API(并手动执行存储系统的具体操作)。</p><p>取而代之的是，Kubernetes用户现在被授权以与集群无关的方式将快照操作放进他们的工具和策略中，并且确信它将对任意的Kubernetes集群有效，而与底层存储无关。</p><p>此外，Kubernetes 快照原语作为基础构建能力解锁了为Kubernetes开发高级、企业级、存储管理特性的能力:包括应用或集群级别的备份方案。</p><p>你可以阅读更多关于<a href=https://kubernetes.io/blog/2019/12/09/kubernetes-1-17-feature-cis-volume-snapshot-beta/>发布容器存储接口卷快照公开测试版</a></p><h2 id=容器存储接口迁移公测版>容器存储接口迁移公测版</h2><h3 id=为什么我们迁移内建树插件到容器存储接口>为什么我们迁移内建树插件到容器存储接口？</h3><p>在容器存储接口之前，Kubernetes提供功能强大的卷插件系统。这些卷插件是树内的意味着它们的代码是核心Kubernetes代码的一部分并附带在核心Kubernetes二进制中。然而，为Kubernetes添加插件支持新卷是非常有挑战的。希望在Kubernetes上为自己存储系统添加支持(或修复现有卷插件的bug)的供应商被迫与Kubernetes发行进程对齐。此外，第三方存储代码在核心Kubernetes二进制中会造成可靠性和安全问题，并且这些代码对于Kubernetes的维护者来说是难以(一些场景是不可能)测试和维护的。在Kubernetes上采用容器存储接口可以解决大部分问题。</p><p>随着更多容器存储接口驱动变成生产环境可用，我们希望所有的Kubernetes用户从容器存储接口模型中获益。然而，我们不希望强制用户以破坏现有基本可用的存储接口的方式去改变负载和配置。道路很明确，我们将不得不用CSI替换树内插件接口。什么是容器存储接口迁移？</p><p>在容器存储接口迁移上所做的努力使得替换现有的树内存储插件，如<code>kubernetes.io/gce-pd</code>或<code>kubernetes.io/aws-ebs</code>，为相应的容器存储接口驱动成为可能。如果容器存储接口迁移正常工作，Kubernetes终端用户不会注意到任何差别。迁移过后，Kubernetes用户可以继续使用现有接口来依赖树内存储插件的功能。</p><p>当Kubernetes集群管理者更新集群使得CSI迁移可用，现有的有状态部署和工作负载照常工作；然而，在幕后Kubernetes将存储管理操作交给了(以前是交给树内驱动)CSI驱动。</p><p>Kubernetes组非常努力地保证存储接口的稳定性和平滑升级体验的承诺。这需要细致的考虑现有特性和行为来确保后向兼容和接口稳定性。你可以想像成在加速行驶的直线上给赛车换轮胎。</p><p>你可以在这篇博客中阅读更多关于<a href=https://kubernetes.io/blog/2019/12/09/kubernetes-1-17-feature-csi-migration-beta/>容器存储接口迁移成为公开测试版</a>.</p><h2 id=其它更新>其它更新</h2><h3 id=稳定>稳定💯</h3><ul><li><a href=https://github.com/kubernetes/enhancements/issues/382>按条件污染节点</a></li><li><a href=https://github.com/kubernetes/enhancements/issues/495>可配置的Pod进程共享命名空间</a></li><li><a href=https://github.com/kubernetes/enhancements/issues/548>采用kube-scheduler调度DaemonSet Pods</a></li><li><a href=https://github.com/kubernetes/enhancements/issues/554>动态卷最大值</a></li><li><a href=https://github.com/kubernetes/enhancements/issues/557>Kubernetes容器存储接口支持拓扑</a></li><li><a href=https://github.com/kubernetes/enhancements/issues/559>在SubPath挂载提供环境变量扩展</a></li><li><a href=https://github.com/kubernetes/enhancements/issues/575>为Custom Resources提供默认值</a></li><li><a href=https://github.com/kubernetes/enhancements/issues/589>从频繁的Kublet心跳到租约接口</a></li><li><a href=https://github.com/kubernetes/enhancements/issues/714>拆分Kubernetes测试Tarball</a></li><li><a href=https://github.com/kubernetes/enhancements/issues/956>添加Watch书签支持</a></li><li><a href=https://github.com/kubernetes/enhancements/issues/960>行为驱动一致性测试</a></li><li><a href=https://github.com/kubernetes/enhancements/issues/980>服务负载均衡终结保护</a></li><li><a href=https://github.com/kubernetes/enhancements/issues/1152>避免每一个Watcher独立序列化相同的对象</a></li></ul><h3 id=主要变化>主要变化</h3><ul><li><a href=https://github.com/kubernetes/enhancements/issues/563>添加IPv4/IPv6双栈支持</a></li></ul><h3 id=其它显著特性>其它显著特性</h3><ul><li><a href=https://github.com/kubernetes/enhancements/issues/536>拓扑感知路由服务(内部测试版)</a></li><li><a href=https://github.com/kubernetes/enhancements/issues/1043>为Windows添加RunAsUserName</a></li></ul><h3 id=可用性>可用性</h3><p>Kubernetes 1.17 可以<a href=https://github.com/kubernetes/kubernetes/releases/tag/v1.17.0>在GitHub下载</a>。开始使用Kubernetes，看看这些<a href=https://kubernetes.io/docs/tutorials/>交互教学</a>。你可以非常容易使用<a href=https://kubernetes.io/docs/setup/independent/create-cluster-kubeadm/>kubeadm</a>安装1.17。</p><h3 id=发布团队>发布团队</h3><p>正是因为有上千人参与技术或非技术内容的贡献才使这个版本成为可能。特别感谢由Guinevere Saenger领导的<a href=https://github.com/kubernetes/sig-release/blob/master/releases/release-1.17/release_team.md>发布团队</a>。发布团队的35名成员在发布版本的多方面进行了协调，从文档到测试，校验和特性的完善。</p><p>随着Kubernetes社区的成长，我们的发布流程是在开源软件协作方面惊人的示例。Kubernetes快速并持续获得新用户。这一成长产生了良性的反馈循环，更多的贡献者贡献代码创造了更加活跃的生态。Kubernetes已经有超过<a href="https://k8s.devstats.cncf.io/d/24/overall-project-statistics?orgId=1">39000位贡献者</a>和一个超过66000人的活跃社区。</p><h3 id=网络研讨会>网络研讨会</h3><p>2020年1月7号，加入Kubernetes 1.17发布团队，学习关于这次发布的主要特性。<a href=https://zoom.us/webinar/register/9315759188139/WN_kPOZA_6RTjeGdXTG7YFO3A>这里</a>注册。</p><h3 id=参与其中>参与其中</h3><p>最简单的参与Kubernetes的方式是加入其中一个与你兴趣相同的<a href=https://github.com/kubernetes/community/blob/master/sig-list.md>特别兴趣组</a>（SIGs)。有什么想要广播到Kubernetes社区吗？通过如下的频道，在每周的<a href=https://github.com/kubernetes/community/tree/master/communication>社区会议</a>分享你的声音。感谢你的贡献和支持。</p><ul><li>在Twitter上关注我们<a href=https://twitter.com/kubernetesio>@Kubernetesio</a>获取最新的更新</li><li>在<a href=https://discuss.kubernetes.io/>Discuss</a>参与社区的讨论</li><li>在<a href=http://slack.k8s.io/>Slack</a>加入社区</li><li>在<a href=http://stackoverflow.com/questions/tagged/kubernetes>Stack Overflow</a>发布问题(或回答问题)</li><li>分享你的Kubernetes<a href=https://docs.google.com/a/linuxfoundation.org/forms/d/e/1FAIpQLScuI7Ye3VQHQTwBASrgkjQDSS5TP0g3AXfFhwSM9YpHgxRKFA/viewform>故事</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-601488fd56d4096c09b2a9959d0e7a43>使用 Java 开发一个 Kubernetes controller</h1><div class="td-byline mb-4"><time datetime=2019-11-26 class=text-muted>2019.11.26</time></div><p><strong>作者:</strong> Min Kim (蚂蚁金服), Tony Ado (蚂蚁金服)</p><p><a href=https://github.com/kubernetes-client/java>Kubernetes Java SDK</a> 官方项目最近发布了他们的最新工作，为 Java Kubernetes 开发人员提供一个便捷的 Kubernetes 控制器-构建器 SDK，它有助于轻松开发高级工作负载或系统。</p><h2 id=综述>综述</h2><p>Java 无疑是世界上最流行的编程语言之一，但由于社区中缺少库资源，一段时间以来，那些非 Golang 开发人员很难构建他们定制的 controller/operator。在 Golang 的世界里，已经有一些很好的 controller 框架了，例如，<a href=https://github.com/kubernetes-sigs/controller-runtime>controller runtime</a>，<a href=https://github.com/operator-framework/operator-sdk>operator SDK</a>。这些现有的 Golang 框架依赖于 <a href=https://github.com/kubernetes/client-go>Kubernetes Golang SDK</a> 提供的各种实用工具，这些工具经过多年证明是稳定的。受进一步集成到 Kubernetes 平台的需求驱动，我们不仅将 Golang SDK 中的许多基本工具移植到 kubernetes Java SDK 中，包括 informers、work-queues、leader-elections 等，也开发了一个控制器构建 SDK，它可以将所有东西连接到一个可运行的控制器中，而不会产生任何问题。</p><h2 id=背景>背景</h2><p>为什么要使用 Java 实现 kubernetes 工具？选择 Java 的原因可能是：</p><ul><li><p><strong>集成遗留的企业级 Java 系统</strong>：许多公司的遗留系统或框架都是用 Java 编写的，用以支持稳定性。我们不能轻易把所有东西搬到 Golang。</p></li><li><p><strong>更多开源社区的资源</strong>：Java 是成熟的，并且在过去几十年中累计了丰富的开源库，尽管 Golang 对于开发人员来说越来越具有吸引力，越来越流行。此外，现在开发人员能够在 SQL 存储上开发他们的聚合-apiserver，而 Java 在 SQL 上有更好的支持。</p></li></ul><h2 id=如何去使用>如何去使用</h2><p>以 maven 项目为例，将以下依赖项添加到您的依赖中：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:green;font-weight:700>&lt;dependency&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&lt;groupId&gt;</span>io.kubernetes<span style=color:green;font-weight:700>&lt;/groupId&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&lt;artifactId&gt;</span>client-java-extended<span style=color:green;font-weight:700>&lt;/artifactId&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&lt;version&gt;</span>6.0.1<span style=color:green;font-weight:700>&lt;/version&gt;</span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>&lt;/dependency&gt;</span>
</span></span></code></pre></div><p>然后我们可以使用提供的生成器库来编写自己的控制器。例如，下面是一个简单的控制，它打印出关于监视通知的节点信息，
在<a href=https://github.com/kubernetes-client/java/blob/master/examples/examples-release-13/src/main/java/io/kubernetes/client/examples/ControllerExample.java>此处</a>
查看完整的例子：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#666>...</span>
</span></span><span style=display:flex><span>    Reconciler reconciler <span style=color:#666>=</span> <span style=color:#a2f;font-weight:700>new</span> Reconciler<span style=color:#666>()</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>      <span style=color:#a2f>@Override</span>
</span></span><span style=display:flex><span>      <span style=color:#a2f;font-weight:700>public</span> Result <span style=color:#00a000>reconcile</span><span style=color:#666>(</span>Request request<span style=color:#666>)</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>        V1Node node <span style=color:#666>=</span> nodeLister<span style=color:#666>.</span><span style=color:#b44>get</span><span style=color:#666>(</span>request<span style=color:#666>.</span><span style=color:#b44>getName</span><span style=color:#666>());</span>
</span></span><span style=display:flex><span>        System<span style=color:#666>.</span><span style=color:#b44>out</span><span style=color:#666>.</span><span style=color:#b44>println</span><span style=color:#666>(</span><span style=color:#b44>&#34;triggered reconciling &#34;</span> <span style=color:#666>+</span> node<span style=color:#666>.</span><span style=color:#b44>getMetadata</span><span style=color:#666>().</span><span style=color:#b44>getName</span><span style=color:#666>());</span>
</span></span><span style=display:flex><span>        <span style=color:#a2f;font-weight:700>return</span> <span style=color:#a2f;font-weight:700>new</span> Result<span style=color:#666>(</span><span style=color:#a2f;font-weight:700>false</span><span style=color:#666>);</span>
</span></span><span style=display:flex><span>      <span style=color:#666>}</span>
</span></span><span style=display:flex><span>    <span style=color:#666>};</span>
</span></span><span style=display:flex><span>    Controller controller <span style=color:#666>=</span>
</span></span><span style=display:flex><span>        ControllerBuilder<span style=color:#666>.</span><span style=color:#b44>defaultBuilder</span><span style=color:#666>(</span>informerFactory<span style=color:#666>)</span>
</span></span><span style=display:flex><span>            <span style=color:#666>.</span><span style=color:#b44>watch</span><span style=color:#666>(</span>
</span></span><span style=display:flex><span>                <span style=color:#666>(</span>workQueue<span style=color:#666>)</span> <span style=color:#666>-&gt;</span> ControllerBuilder<span style=color:#666>.</span><span style=color:#b44>controllerWatchBuilder</span><span style=color:#666>(</span>V1Node<span style=color:#666>.</span><span style=color:#b44>class</span><span style=color:#666>,</span> workQueue<span style=color:#666>).</span><span style=color:#b44>build</span><span style=color:#666>())</span>
</span></span><span style=display:flex><span>            <span style=color:#666>.</span><span style=color:#b44>withReconciler</span><span style=color:#666>(</span>nodeReconciler<span style=color:#666>)</span> <span style=color:#080;font-style:italic>// required, set the actual reconciler
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>            <span style=color:#666>.</span><span style=color:#b44>withName</span><span style=color:#666>(</span><span style=color:#b44>&#34;node-printing-controller&#34;</span><span style=color:#666>)</span> <span style=color:#080;font-style:italic>// optional, set name for controller for logging, thread-tracing
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>            <span style=color:#666>.</span><span style=color:#b44>withWorkerCount</span><span style=color:#666>(</span><span style=color:#666>4</span><span style=color:#666>)</span> <span style=color:#080;font-style:italic>// optional, set worker thread count
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>            <span style=color:#666>.</span><span style=color:#b44>withReadyFunc</span><span style=color:#666>(</span> nodeInformer<span style=color:#666>::</span>hasSynced<span style=color:#666>)</span> <span style=color:#080;font-style:italic>// optional, only starts controller when the cache has synced up
</span></span></span><span style=display:flex><span><span style=color:#080;font-style:italic></span>            <span style=color:#666>.</span><span style=color:#b44>build</span><span style=color:#666>();</span>
</span></span></code></pre></div><p>如果您留意，新的 Java 控制器框架很多地方借鉴于 <a href=https://github.com/kubernetes-sigs/controller-runtime>controller-runtime</a> 的设计，它成功地将控制器内部的复杂组件封装到几个干净的接口中。在 Java 泛型的帮助下，我们甚至更进一步，以更好的方式简化了封装。</p><p>我们可以将多个控制器封装到一个 controller-manager 或 leader-electing controller 中，这有助于在 HA 设置中进行部署。</p><h2 id=未来计划>未来计划</h2><p>Kubernetes Java SDK 项目背后的社区将专注于为希望编写云原生 Java 应用程序来扩展 Kubernetes 的开发人员提供更有用的实用程序。如果您对更详细的信息感兴趣，请查看我们的仓库 <a href=https://github.com/kubernetes-client/java>kubernetes-client/java</a>。请通过问题或 <a href=http://kubernetes.slack.com/messages/kubernetes-client/>Slack</a> 与我们分享您的反馈。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-b16b2be554bf6272235c07443e287255>使用 Microk8s 在 Linux 上本地运行 Kubernetes</h1><div class="td-byline mb-4"><time datetime=2019-11-26 class=text-muted>2019.11.26</time></div><p><strong>作者</strong>: <a href=https://twitter.com/idvoretskyi>Ihor Dvoretskyi</a>，开发支持者，云原生计算基金会；<a href=https://twitter.com/carminerimi>Carmine Rimi</a></p><p>本文是关于 Linux 上的本地部署选项<a href=https://twitter.com/idvoretskyi>系列</a>的第二篇，涵盖了 <a href=https://microk8s.io/>MicroK8s</a>。Microk8s 是本地部署 Kubernetes 集群的 'click-and-run' 方案，最初由 Ubuntu 的发布者 Canonical 开发。</p><p>虽然 Minikube 通常为 Kubernetes 集群创建一个本地虚拟机（VM），但是 MicroK8s 不需要 VM。它使用<a href=https://snapcraft.io/>snap</a> 包，这是一种应用程序打包和隔离技术。</p><p>这种差异有其优点和缺点。在这里，我们将讨论一些有趣的区别，并且基于 VM 的方法和非 VM 方法的好处。第一个因素是跨平台的移植性。虽然 Minikube VM 可以跨操作系统移植——它不仅支持 Linux，还支持 Windows、macOS、甚至 FreeBSD，但 Microk8s 需要 Linux，而且只在<a href=https://snapcraft.io/docs/installing-snapd>那些支持 snaps</a> 的发行版上。支持大多数流行的 Linux 发行版。</p><p>另一个考虑到的因素是资源消耗。虽然 VM 设备为您提供了更好的可移植性，但它确实意味着您将消耗更多资源来运行 VM，这主要是因为 VM 提供了一个完整的操作系统，并且运行在管理程序之上。当 VM 处于休眠时你将消耗更多的磁盘空间。当它运行时，你将会消耗更多的 RAM 和 CPU。因为 Microk8s 不需要创建虚拟机，你将会有更多的资源去运行你的工作负载和其他设备。考虑到所占用的空间更小，MicroK8s 是物联网设备的理想选择-你甚至可以在 Paspberry Pi 和设备上使用它！</p><p>最后，项目似乎遵循了不同的发布节奏和策略。Microk8s 和 snaps 通常提供<a href=https://snapcraft.io/docs/channels>渠道</a>允许你使用测试版和发布 KUbernetes 新版本的候选版本，同样也提供先前稳定版本。Microk8s 通常几乎立刻发布 Kubernetes 上游的稳定版本。</p><p>但是等等，还有更多！Minikube 和 Microk8s 都是作为单节点集群启动的。本质上来说，它们允许你用单个工作节点创建 Kubernetes 集群。这种情况即将改变 - MicroK8s 早期的 alpha 版本包括集群。有了这个能力，你可以创建正如你希望多的工作节点的 KUbernetes 集群。对于创建集群来说，这是一个没有主见的选项 - 开发者在节点之间创建网络连接和集成了其他所需要的基础设施，比如一个外部的负载均衡。总的来说，MicroK8s 提供了一种快速简易的方法，使得少量的计算机和虚拟机变成一个多节点的 Kubernetes 集群。以后我们将撰写更多这种体系结构的文章。</p><h2 id=免责声明>免责声明</h2><p>这不是 MicroK8s 官方介绍文档。你可以在它的官方<a href=https://microk8s.io/docs/>网页</a>查询运行和使用 MicroK8s 的详情信息，其中覆盖了不同的用例，操作系统，环境等。相反，这篇文章的意图是提供在 Linux 上运行 MicroK8s 清晰易懂的指南。</p><h2 id=前提条件>前提条件</h2><p>一个<a href=https://snapcraft.io/docs/installing-snapd>支持 snaps</a> 的 Linux 发行版是被需要的。这篇指南，我们将会用支持 snaps 且即开即用的 Ubuntu 18.04 LTS。如果你对运行在 Windows 或者 Mac 上的 MicroK8s 感兴趣，你应该检查<a href=https://multipass.run>多通道</a>，安装一个快速的 Ubuntu VM，作为在你的系统上运行虚拟机 Ubuntu 的官方方式。</p><h2 id=microk8s-安装>MicroK8s 安装</h2><p>简洁的 MicroK8s 安装：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sudo snap install microk8s --classic
</span></span></code></pre></div><center><figure><img src=/images/blog/2019-11-05-kubernetes-with-microk8s/001-install.png width=600></figure></center><h2 id=使用-microk8s>使用 microk8s</h2><p>使用 MicrosK8s 就像和安装它一样便捷。MicroK8s 本身包括一个 <code>kubectl</code> 库，该库可以通过执行 <code>microk8s.kubectl</code> 命令去访问。例如：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>microk8s.kubectl get nodes
</span></span></code></pre></div><center><figure><img src=/images/blog/2019-11-05-kubernetes-with-microk8s/003-nodes.png width=600></figure></center><p>当使用前缀 <code>microk8s.kubectl</code> 时，允许在没有影响的情况下并行地安装另一个系统级的 kubectl，你可以便捷地使用 <code>snap alias</code> 命令摆脱它：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sudo snap <span style=color:#a2f>alias</span> microk8s.kubectl kubectl
</span></span></code></pre></div><center><figure><img src=/images/blog/2019-11-05-kubernetes-with-microk8s/004-alias.png width=600></figure></center><p>这将允许你以后便捷地使用 <code>kubectl</code>，你可以用 <code>snap unalias</code>命令恢复这个改变。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get nodes
</span></span></code></pre></div><center><figure><img src=/images/blog/2019-11-05-kubernetes-with-microk8s/005-nodes.png width=600></figure></center><h2 id=microk8s-插件>MicroK8s 插件</h2><p>使用 MicroK8s 其中最大的好处之一事实上是也支持各种各样的插件和扩展。更重要的是它们是开箱即用的，用户仅仅需要启动它们。通过运行 <code>microk8s.status</code> 命令检查出扩展的完整列表。</p><pre tabindex=0><code>sudo microk8s.status
</code></pre><p>截至到写这篇文章为止，MicroK8s 已支持以下插件：</p><center><figure><img src=/images/blog/2019-11-05-kubernetes-with-microk8s/006-status.png width=600></figure></center><p>社区创建和贡献了越来越多的插件，经常检查他们是十分有帮助的。</p><h2 id=发布渠道>发布渠道</h2><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sudo snap info microk8s
</span></span></code></pre></div><center><figure><img src=/images/blog/2019-11-05-kubernetes-with-microk8s/010-releases.png width=600></figure></center><h2 id=安装简单的应用>安装简单的应用</h2><p>在这篇指南中我将会用 NGINX 作为一个示例应用程序（<a href=https://hub.docker.com/_/nginx>官方 Docker Hub 镜像</a>）。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create deployment nginx --image<span style=color:#666>=</span>nginx
</span></span></code></pre></div><p>为了检查安装，让我们运行以下命令：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get deployments
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods
</span></span></code></pre></div><center><figure><img src=/images/blog/2019-11-05-kubernetes-with-microk8s/007-deployments.png width=600></figure></center><p>我们也可以检索出 Kubernetes 集群中所有可用对象的完整输出。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get all --all-namespaces
</span></span></code></pre></div><center><figure><img src=/images/blog/2019-11-05-kubernetes-with-microk8s/008-all.png width=600></figure></center><h2 id=卸载-mircrok8s>卸载 MircroK8s</h2><p>卸载您的 microk8s 集群与卸载 Snap 同样便捷。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sudo snap remove microk8s
</span></span></code></pre></div><center><figure><img src=/images/blog/2019-11-05-kubernetes-with-microk8s/009-remove.png width=600></figure></center><h2 id=截屏视频>截屏视频</h2><p><a href=https://asciinema.org/a/263394><img src=https://asciinema.org/a/263394.svg alt=asciicast></a></p></div><div class=td-content style=page-break-before:always><h1 id=pg-464e22d2595c073a96a61069f2fd202f>Kubernetes 文档最终用户调研</h1><div class="td-byline mb-4"><time datetime=2019-10-29 class=text-muted>2019.10.29</time></div><p><strong>Author:</strong> <a href=https://www.linkedin.com/in/aimee-ukasick/>Aimee Ukasick</a> and SIG Docs</p><p>9月，SIG Docs 进行了第一次关于 <a href=https://kubernetes.io/docs/>Kubernetes 文档</a>的用户调研。我们要感谢 CNCF
的 Kim McMahon 帮助我们创建调查并获取结果。</p><h1 id=主要收获>主要收获</h1><p>受访者希望能在概念、任务和参考部分得到更多示例代码、更详细的内容和更多图表。</p><p>74% 的受访者希望教程部分包含高级内容。</p><p>69.70% 的受访者认为 Kubernetes 文档是他们首要寻找关于 Kubernetes 资料的地方。</p><h1 id=调查方法和受访者>调查方法和受访者</h1><p>我们用英语进行了调查。由于时间限制，调查的有效期只有 4 天。
我们在 Kubernetes 邮件列表、Kubernetes Slack 频道、Twitter、Kube Weekly 上发布了我们的调查问卷。
这份调查有 23 个问题， 受访者平均用 4 分钟完成这个调查。</p><h2 id=关于受访者的简要情况>关于受访者的简要情况</h2><ul><li>48.48% 是经验丰富的 Kubernetes 用户，26.26% 是专家，25.25% 是初学者</li><li>57.58% 的人同时使用 Kubernetes 作为管理员和开发人员</li><li>64.65% 的人使用 Kubernetes 文档超过 12 个月</li><li>95.96% 的人阅读英文文档</li></ul><h1 id=问题和回答要点>问题和回答要点</h1><h2 id=人们为什么访问-kubernetes-文档>人们为什么访问 Kubernetes 文档</h2><p>大多数受访者表示，他们访问文档是为了了解概念。</p><figure><img src=/images/blog/2019-sig-docs-survey/Q9-k8s-docs-use.png alt="受访者为什么访问 Kubernetes 文档"></figure><p>这与我们在 Google Analytics 上看到的略有不同：在今年浏览量最多的10个页面中，第一是在参考部分的 kubectl
的备忘单，其次是概念部分的页面。</p><h2 id=对文档的满意程度>对文档的满意程度</h2><p>我们要求受访者从概念、任务、参考和教程部分记录他们对细节的满意度：</p><ul><li>概念：47.96% 中等满意</li><li>任务：50.54% 中等满意</li><li>参考：40.86% 非常满意</li><li>教程：47.25% 中等满意</li></ul><h2 id=sig-docs-如何改进文档的各个部分>SIG Docs 如何改进文档的各个部分</h2><p>我们询问如何改进每个部分，为受访者提供可选答案以及文本输入框。绝大多数人想要更多
示例代码、更详细的内容、更多图表和更高级的教程：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>- 就个人而言，希望看到更多的类比，以帮助进一步理解。
</span></span><span style=display:flex><span>- 如果代码的相应部分也能解释一下就好了
</span></span><span style=display:flex><span>- 通过扩展概念把它们融合在一起 - 它们现在宛如在一桶水内朝各个方向游动的一条条鳗鱼。
</span></span><span style=display:flex><span>- 更多的图表，更多的示例代码
</span></span></code></pre></div><p>受访者使用“其他”文本框记录引发阻碍的区域：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>- 使概念保持最新和准确
</span></span><span style=display:flex><span>- 保持任务主题的最新性和准确性。亲身试验。
</span></span><span style=display:flex><span>- 彻底检查示例。很多时候显示的命令输出不是实际情况。
</span></span><span style=display:flex><span>- 我从来都不知道如何导航或解释参考部分
</span></span><span style=display:flex><span>- 使教程保持最新，或将其删除
</span></span></code></pre></div><h2 id=sig-docs-如何全面改进文档>SIG Docs 如何全面改进文档</h2><p>我们询问受访者如何从整体上改进 Kubernetes 文档。一些人抓住这次机会告诉我们我们正在做一个很棒的
工作：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>- 对我而言，这是我见过的文档最好的开源项目。
</span></span><span style=display:flex><span>- 继续努力！
</span></span><span style=display:flex><span>- 我觉得文档很好。
</span></span><span style=display:flex><span>- 你们做得真好。真的。
</span></span></code></pre></div><p>其它受访者提供关于内容的反馈：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>-  ...但既然我们谈论的是文档，多多益善。更多的高级配置示例对我来说将是最好的选择。比如每个配置主题的用例页面，
</span></span><span style=display:flex><span>从初学者到高级示例场景。像这样的东西真的是令人惊叹......
</span></span><span style=display:flex><span>- 更深入的例子和用例将是很好的。我经常感觉 Kubernetes 文档只是触及了一个主题的表面，这可能对新用户很好，
</span></span><span style=display:flex><span>但是它没有让更有经验的用户获取多少关于如何实现某些东西的“官方”指导。
</span></span><span style=display:flex><span>- 资源节（特别是 secrets）希望有更多类似于产品的示例或指向类似产品的示例的链接
</span></span><span style=display:flex><span>- 如果能像很多其它技术项目那样有非常清晰的“快速启动” 逐步教学完成搭建就更好了。现有的快速入门内容屈指可数，
</span></span><span style=display:flex><span>也没有统一的指南。结果是信息泛滥。
</span></span></code></pre></div><p>少数受访者提供的技术建议：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>- 使用 ReactJS 或者 Angular component 使表的列可排序和可筛选。
</span></span><span style=display:flex><span>- 对于大多数人来说，我认为用 Hugo - 一个静态站点生成系统 - 创建文档是不合适的。有更好的系统来记录大型软件项目。
</span></span><span style=display:flex><span>具体来说，我希望看到 k8s 切换到 Sphinx 来获取文档。Sphinx 有一个很好的内置搜索。如果你了解 markdown，学习起来也很容易。
</span></span><span style=display:flex><span>Sphinx 被其他项目广泛采用（例如，在 readthedocs.io、linux kernel、docs.python.org 等等）。
</span></span></code></pre></div><p>总体而言，受访者提供了建设性的批评，其关注点是高级用例以及更深入的示例、指南和演练。</p><h1 id=哪里可以看到更多>哪里可以看到更多</h1><p>调查结果摘要、图表和原始数据可在 <code>kubernetes/community</code> sig-docs
<a href=https://github.com/kubernetes/community/tree/master/sig-docs/survey>survey</a>
目录下。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-fb4706cbf52d410fa926ccb78d30b84f>圣迭戈贡献者峰会日程公布！</h1><div class="td-byline mb-4"><time datetime=2019-10-10 class=text-muted>2019.10.10</time></div><p><strong>作者：</strong> Josh Berkus (Red Hat), Paris Pittman (Google), Jonas Rosland (VMware)</p><p>除了新贡献者研讨会之外，贡献者峰会还安排了许多精彩的会议，这些会议分布在当前五个贡献者内容的会议室中。由于这是一个上游贡献者峰会，并且我们不经常见面，所以作为一个全球分布的团队，这些会议大多是讨论或动手实践，而不仅仅是演示。我们希望大家互相学习，并于他们的开源代码队友玩的开心。</p><p>像去年一样，非组织会议将重新开始，会议将在周一上午进行选择。对于最新的热门话题和贡献者想要进行的特定讨论，这是理想的选择。在过去的几年中，我们涵盖了不稳定的测试，集群生命周期，KEP（Kubernetes增强建议），指导，安全性等等。</p><p><img src=/images/blog/2019-10-10-contributor-summit-san-diego-schedule/DSCF0806.jpg alt=非组织会议></p><p>尽管在每个时间间隙日程安排都包含困难的决定，但我们选择了以下几点，让您体验一下您将在峰会上听到、看到和参与的内容：</p><ul><li><strong><a href=https://sched.co/VvMc>预见</a></strong>: SIG组织将分享他们对于明年和以后Kubernetes开发发展方向的认识。</li><li><strong><a href=https://sched.co/VvMj>安全</a></strong>: Tim Allclair和CJ Cullen将介绍Kubernetes安全的当前情况。在另一个安全性演讲中，Vallery Lancey将主持有关使我们的平台默认情况下安全的讨论。</li><li><strong><a href=https://sched.co/Vv6Z>Prow</a></strong>: 有兴趣与Prow合作并为Test-Infra做贡献，但不确定从哪里开始？ Rob Keilty将帮助您在笔记本电脑上运行Prow测试环境</li><li><strong><a href=https://sched.co/VvNa>Git</a></strong>: GitHub的员工将与Christoph Blecker合作，为Kubernetes贡献者分享实用的Git技巧。</li><li><strong><a href=https://sched.co/VutA>审阅</a></strong>: 蒂姆·霍金（Tim Hockin）将分享成为一名出色的代码审阅者的秘密，而乔丹·利吉特（Jordan Liggitt）将进行实时API审阅，以便您可以进行一次或至少了解一次审阅。</li><li><strong><a href=https://sched.co/VvNJ>终端用户</a></strong>: 应Cheryl Hung邀请，来自CNCF合作伙伴生态的数个终端用户，将回答贡献者的问题，以加强我们的反馈循环。</li><li><strong><a href=https://sched.co/Vux2>文档</a></strong>: 与往常一样，SIG Docs将举办一个为时三个小时的文档撰写研讨会。</li></ul><p>我们还将向在2019年杰出的贡献者颁发奖项，周一星期一结束时将有一个巨大的见面会，供新的贡献者找到他们的SIG（以及现有的贡献者询问他们的PR）。</p><p>希望能够在峰会上见到您，并且确保您已经提前<a href=https://events19.linuxfoundation.org/events/kubernetes-contributor-summit-north-america-2019/register/>注册</a>！</p><p><a href=http://git.k8s.io/community/events/events-team>圣迭戈团队</a></p></div><div class=td-content style=page-break-before:always><h1 id=pg-fc6fc922d4286e1fe8e3289d1094bdf8>2019 指导委员会选举结果</h1><div class="td-byline mb-4"><time datetime=2019-10-03 class=text-muted>2019.10.03</time></div><p><strong>作者</strong>：Bob Killen (University of Michigan), Jorge Castro (VMware),
Brian Grant (Google), and Ihor Dvoretskyi (CNCF)</p><p><a href=https://git.k8s.io/community/events/elections/2021>2019 指导委员会选举</a> 是 Kubernetes 项目的重要里程碑。最初的自助委员会正逐步退休，现在该委员会已缩减到最后分配的 7 个席位。指导委员会的所有成员现在都由 Kubernetes 社区选举产生。</p><p>接下来的选举将选出 3 到 4 名委员，任期两年。</p><h2 id=选举结果>选举结果</h2><p>Kubernetes 指导委员会选举现已完成，以下候选人提前获得立即开始的两年任期 (按 GitHub handle 的字母顺序排列) ：</p><ul><li><strong>Christoph Blecker (<a href=https://github.com/cblecker>@cblecker</a>), Red Hat</strong></li><li><strong>Derek Carr (<a href=https://github.com/derekwaynecarr>@derekwaynecarr</a>), Red Hat</strong></li><li><strong>Nikhita Raghunath (<a href=https://github.com/nikhita>@nikhita</a>), Loodse</strong></li><li><strong>Paris Pittman (<a href=https://github.com/parispittman>@parispittman</a>)</strong>, <strong>Google</strong></li></ul><p>他们加入了 Aaron Crickenberger (<a href=https://github.com/spiffxp>@spiffxp</a>)， Google；Davanum Srinivas (<a href=https://github.com/dims>@dims</a>)，VMware; and Timothy St. Clair (<a href=https://github.com/timothysc>@timothysc</a>), VMware，使得委员会更圆满。Aaron、Davanum 和 Timothy 占据的这些席位将会在明年的这个时候进行选举。</p><h2 id=诚挚的感谢>诚挚的感谢！</h2><ul><li>感谢最初的引导委员会创立了最初项目的管理并监督了多年的过渡期：<ul><li>Joe Beda (<a href=https://github.com/jbeda>@jbeda</a>), VMware</li><li>Brendan Burns (<a href=https://github.com/brendandburns>@brendandburns</a>), Microsoft</li><li>Clayton Coleman (<a href=https://github.com/smarterclayton>@smarterclayton</a>), Red Hat</li><li>Brian Grant (<a href=https://github.com/bgrant0607>@bgrant0607</a>), Google</li><li>Tim Hockin (<a href=https://github.com/thockin>@thockin</a>), Google</li><li>Sarah Novotny (<a href=https://github.com/sarahnovotny>@sarahnovotny</a>), Microsoft</li><li>Brandon Philips (<a href=https://github.com/philips>@philips</a>), Red Hat</li></ul></li></ul><ul><li>同样感谢其他的已退休指导委员会成员。社区对你们先前的服务表示赞赏：<ul><li>Quinton Hoole (<a href=https://github.com/quinton-hoole>@quinton-hoole</a>), Huawei</li><li>Michelle Noorali (<a href=https://github.com/michelleN>@michelleN</a>), Microsoft</li><li>Phillip Wittrock (<a href=https://github.com/pwittrock>@pwittrock</a>), Google</li></ul></li></ul><ul><li>感谢参选的候选人。 愿在每次选举中，我们都能拥有一群像您一样推动社区向前发展的人。</li><li>感谢所有投票的377位选民。</li><li>最后，感谢康奈尔大学举办的 <a href=https://civs.cs.cornell.edu/>CIVS</a>!</li></ul><h2 id=参与指导委员会>参与指导委员会</h2><p>你可以跟进指导委员会的 <a href=https://github.com/kubernetes/steering/projects/1>代办事项</a>，通过提出问题或者向 <a href=https://github.com/kubernetes/steering>仓库</a> 提交一个 pr 。他们每两周一次，在 <a href=https://github.com/kubernetes/steering>UTC 时间周三晚上 8 点</a> 会面，并定期与我们的贡献者见面。也可以通过他们的公共邮件列表 <a href=mailto:steering@kubernetes.io>steering@kubernetes.io</a> 联系他们。</p><p>指导委员会会议：</p><ul><li><a href="https://www.youtube.com/playlist?list=PL69nYSiGNLP1yP1B_nd9-drjoxp0Q14qM">YouTube 播放列表</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-aed805df2d0756cee0216566e206c2e0>San Diego 贡献者峰会开放注册！</h1><div class="td-byline mb-4"><time datetime=2019-09-24 class=text-muted>2019.09.24</time></div><p><strong>作者：</strong> Paris Pittman (Google), Jeffrey Sica (Red Hat), Jonas Rosland (VMware)</p><p><a href=https://events.linuxfoundation.org/events/kubernetes-contributor-summit-north-america-2019/>2019 San Diego 贡献者峰会活动页面</a>
在创纪录的时间内，<em>新贡献者研讨会</em> 活动已满员！</p><p><strong>11月17日，星期日</strong><br>晚间贡献者庆典：<br><a href=https://quartyardsd.com/>QuartYard</a>†<br>地址: 1301 Market Street, San Diego, CA 92101<br>时间: 下午6:00 - 下午9:00</p><p><strong>11月18日，星期一</strong><br>全天贡献者峰会：<br><a href="https://www.marriott.com/hotels/travel/sandt-marriott-marquis-san-diego-marina/?scid=bb1a189a-fec3-4d19-a255-54ba596febe2">Marriott Marquis San Diego Marina</a><br>地址: 333 W Harbor Dr, San Diego, CA 92101<br>时间: 上午9:00 - 下午5:00</p><p>虽然 Kubernetes 项目只有五年的历史，但是在 KubeCon + CloudNativeCon 之前，今年11月在圣迭戈时我们举办的第九届贡献者峰会了。快速增长的原因是在我们之前所做的北美活动中增加了欧洲和亚洲贡献者峰会。我们将继续在全球举办贡献者峰会，因为重要的是，我们的贡献者要以各种形式的多样性地成长。</p><p>Kubernetes 拥有一个庞大的分布式远程贡献团队，由来自世界各地的 <a href="https://k8s.devstats.cncf.io/d/8/company-statistics-by-repository-group?orgId=1&var-period=y&var-metric=contributions&var-repogroup_name=All&var-companies=All">个人和组织</a> 组成。贡献者峰会每年为社区提供三次聚会的机会，围绕社区主题开展工作，并有互相了解的时间。即将举行的 San Diego 峰会预计将吸引 450 多名与会者，并将包含多个方向，适合所有人。重点将围绕贡献者的增长和可持续性。我们将在这里停留，为举行未来峰会做准备；我们希望这次活动为个人和项目提供价值。我们已经从峰会与会者的反馈中得知，完成工作、学习和与人们面对面交流是当务之急。通过限制参加人数并在更多地方提供贡献者聚会，将有助于我们实现这些目标。</p><p>这次峰会是独一无二的，因为我们在贡献者体验活动团队的坚持自我方面已采取了重大举措。从发行团队的手册中摘录，我们添加了其他核心团队和跟随学习角色，使其成为天然的辅导关系（包括监督和实施）。预计跟随学习者将在 2020 年的三项活动中扮演另一个角色，核心团队成员将带头完成。为这个团队做准备，我们开源了 <a href=https://github.com/kubernetes/community/tree/master/events/events-team>技术手册，指南，最佳做法</a>，并开放了 <a href="https://docs.google.com/document/d/1oLXv5_rM4f645jlXym_Vd7AUq7x6DV-O87E6tcW1sjU/edit?usp=sharing">会议</a> 和 <a href=https://github.com/orgs/kubernetes/projects/21>项目委员会</a>。我们的团队组成了 Kubernetes 项目的许多部分，并确保所有声音都得到体现。</p><p>您是否已经在 KubeCon + CloudNativeCon 上，但无法参与会议？ 在 KubeCon + CloudNativeCon 期间查看 <a href="https://kccncna19.sched.com/overview/type/Maintainer+Track+Sessions?iframe=yes">SIG入门和深潜课程</a> 参与问答，并听取每个特殊兴趣小组（SIG）的最新消息。活动结束后，我们还将记录所有贡献者峰会的课题，在讨论中做笔记，并与您分享。</p><p>我们希望能在 San Diego 的 Kubernetes 贡献者峰会上与大家见面，确保您直接进入并点击 <a href=https://events.linuxfoundation.org/events/kubernetes-contributor-summit-north-america-2019/>立即注册</a>！ 此活动将关闭 - 特此提醒。 ：笑脸：</p><p>查看往期博客有关 <a href=https://kubernetes.io/blog/2019/03/20/a-look-back-and-whats-in-store-for-kubernetes-contributor-summits/>围绕我们的活动构建角色</a> 和 <a href=https://kubernetes.io/blog/2019/06/25/recap-of-kubernetes-contributor-summit-barcelona-2019/>巴塞罗那峰会故事</a>。</p><p>！<a href=/images/blog/2019-09-24-san-diego-contributor-summit/IMG_2588.JPG>2018年集体照</a></p><p>†=QuartYard 有一个巨大的舞台！想要在您的贡献者同行面前做点什么？加入我们吧！ <a href=mailto:community@kubernetes.io>community@kubernetes.io</a></p></div><div class=td-content style=page-break-before:always><h1 id=pg-976a1c2afde41e47eb984e28c88c7085>机器可以完成这项工作，一个关于 kubernetes 测试、CI 和自动化贡献者体验的故事</h1><div class="td-byline mb-4"><time datetime=2019-08-29 class=text-muted>2019.08.29</time></div><p><strong>作者</strong>：Aaron Crickenberger（谷歌）和 Benjamin Elder（谷歌）</p><p><em>”大型项目有很多不那么令人兴奋，但却很辛苦的工作。比起辛苦工作，我们更重视把时间花在自动化重复性工作上，如果这项工作无法实现自动化，我们的文化就是承认并奖励所有类型的贡献。然而，英雄主义是不可持续的。“</em> - <a href=https://git.k8s.io/community/values.md#automation-over-process>Kubernetes Community Values</a></p><p>像许多开源项目一样，Kubernetes 托管在 GitHub 上。 如果项目位于在开发人员已经工作的地方，使用的开发人员已经知道的工具和流程，那么参与的障碍将是最低的。 因此，该项目完全接受了这项服务：它是我们工作流程，问题跟踪，文档，博客平台，团队结构等的基础。</p><p>这个策略奏效了。 它运作良好，以至于该项目迅速超越了其贡献者的人类能力。 接下来是一次令人难以置信的自动化和创新之旅。 我们不仅需要在飞行途中重建我们的飞机而不会崩溃，我们需要将其转换为火箭飞船并发射到轨道。 我们需要机器来完成这项工作。</p><h2 id=工作>工作</h2><p>最初，我们关注的事实是，我们需要支持复杂的分布式系统（如 Kubernetes）所要求的大量测试。 真实世界中的故障场景必须通过端到端（e2e）测试来执行，确保正确的功能。 不幸的是，e2e 测试容易受到薄片（随机故障）的影响，并且需要花费一个小时到一天才能完成。</p><p>进一步的经验揭示了机器可以为我们工作的其他领域：</p><ul><li>Pull Request 工作流程<ul><li>贡献者是否签署了我们的 CLA？</li><li>Pull Request 通过测试吗？</li><li>Pull Request 可以合并吗？</li><li>合并提交是否通过了测试？</li></ul></li><li>鉴别分类<ul><li>谁应该审查 Pull Request？</li><li>是否有足够的信息将问题发送给合适的人？</li><li>问题是否依旧存在？</li></ul></li><li>项目健康<ul><li>项目中发生了什么？</li><li>我们应该注意什么？</li></ul></li></ul><p>当我们开发自动化来改善我们的情况时，我们遵循了以下几个指导原则：</p><ul><li>遵循适用于 Kubernetes 的推送/拉取控制循环模式</li><li>首选无状态松散耦合服务</li><li>更倾向于授权整个社区权利，而不是赋予少数核心贡献者权力</li><li>做好自己的事，而不要重新造轮子</li></ul><h2 id=了解-prow>了解 Prow</h2><p>这促使我们创建 <a href=https://git.k8s.io/test-infra/prow>Prow</a> 作为我们自动化的核心组件。 Prow有点像 <a href=https://ifttt.com/>If This, Then That</a> 用于 GitHub 事件， 内置 <a href=https://prow.k8s.io/command-help>commands</a>， <a href=https://prow.k8s.io/plugins>plugins</a>， 和实用程序。 我们在 Kubernetes 之上建立了 Prow，让我们不必担心资源管理和日程安排，并确保更愉快的运营体验。</p><p>Prow 让我们做以下事情：</p><ul><li>允许我们的社区通过评论诸如“/priority critical-urgent”，“/assign mary”或“/close”之类的命令对 issues/Pull Requests 进行分类</li><li>根据用户更改的代码数量或创建的文件自动标记 Pull Requests</li><li>标出长时间保持不活动状态 issues/Pull Requests</li><li>自动合并符合我们PR工作流程要求的 Pull Requests</li><li>运行定义为<a href=https://github.com/knative/build>Knative Builds</a>的 Kubernetes Pods或 Jenkins jobs的 CI 作业</li><li>实施组织范围和重构 GitHub 仓库策略，如<a href=https://github.com/kubernetes/test-infra/tree/master/prow/cmd/branchprotector>Knative Builds</a>和<a href=https://github.com/kubernetes/test-infra/tree/master/label_sync>GitHub labels</a></li></ul><p>Prow最初由构建 Google Kubernetes Engine 的工程效率团队开发，并由 Kubernetes SIG Testing 的多个成员积极贡献。 Prow 已被其他几个开源项目采用，包括 Istio，JetStack，Knative 和 OpenShift。 <a href=https://github.com/kubernetes/test-infra/tree/master/prow#getting-started>Getting started with Prow</a>需要一个 Kubernetes 集群和 <code>kubectl apply starter.yaml</code>（在 Kubernetes 集群上运行 pod）。</p><p>一旦我们安装了 Prow，我们就开始遇到其他的问题，因此需要额外的工具以支持 Kubernetes 所需的规模测试，包括：</p><ul><li><a href=https://github.com/kubernetes/test-infra/tree/master/boskos>Boskos</a>: 管理池中的作业资源（例如 GCP 项目），检查它们是否有工作并自动清理它们 (<a href="http://velodrome.k8s.io/dashboard/db/boskos-dashboard?orgId=1">with monitoring</a>)</li><li><a href=https://github.com/kubernetes/test-infra/tree/master/ghproxy>ghProxy</a>: 优化用于 GitHub API 的反向代理 HTTP 缓存，以确保我们的令牌使用不会达到 API 限制 (<a href="http://velodrome.k8s.io/dashboard/db/github-cache?refresh=1m&orgId=1">with monitoring</a>)</li><li><a href=https://github.com/kubernetes/test-infra/tree/master/greenhouse>Greenhouse</a>: 允许我们使用远程 bazel 缓存为 Pull requests 提供更快的构建和测试结果 (<a href="http://velodrome.k8s.io/dashboard/db/bazel-cache?orgId=1">with monitoring</a>)</li><li><a href=https://github.com/kubernetes/test-infra/tree/master/prow/cmd/splice>Splice</a>: 允许我们批量测试和合并 Pull requests，确保我们的合并速度不仅限于我们的测试速度</li><li><a href=https://github.com/kubernetes/test-infra/tree/master/prow/cmd/tide>Tide</a>: 允许我们合并通过 GitHub 查询选择的 Pull requests，而不是在队列中排序，允许显着更高合并速度与拼接一起</li></ul><p>##　关注项目健康状况</p><p>随着工作流自动化的实施，我们将注意力转向了项目健康。我们选择使用 Google Cloud Storage (GCS)作为所有测试数据的真实来源，允许我们依赖已建立的基础设施，并允许社区贡献结果。然后，我们构建了各种工具来帮助个人和整个项目理解这些数据，包括：</p><ul><li><a href=https://github.com/kubernetes/test-infra/tree/master/gubernator>Gubernator</a>: 显示给定 Pull Request 的结果和测试历史</li><li><a href=https://github.com/kubernetes/test-infra/tree/master/kettle>Kettle</a>: 将数据从 GCS 传输到可公开访问的 bigquery 数据集</li><li><a href=https://k8s-gubernator.appspot.com/pr>PR dashboard</a>: 一个工作流程识别仪表板，允许参与者了解哪些 Pull Request 需要注意以及为什么</li><li><a href=https://storage.googleapis.com/k8s-gubernator/triage/index.html>Triage</a>: 识别所有作业和测试中发生的常见故障</li><li><a href=https://k8s-testgrid.appspot.com/>Testgrid</a>: 显示所有运行中给定作业的测试结果，汇总各组作业的测试结果</li></ul><p>我们与云计算本地计算基金会（CNCF）联系，开发 DevStats，以便从我们的 GitHub 活动中收集见解，例如：</p><ul><li><a href="https://k8s.devstats.cncf.io/d/5/bot-commands-repository-groups?orgId=1">Which prow commands are people most actively using</a></li><li><a href="https://k8s.devstats.cncf.io/d/46/pr-reviews-by-contributor?orgId=1&var-period=d7&var-repo_name=All&var-reviewers=All">PR reviews by contributor over time</a></li><li><a href="https://k8s.devstats.cncf.io/d/44/pr-time-to-approve-and-merge?orgId=1">Time spent in each phase of our PR workflow</a></li></ul><h2 id=into-the-beyond>Into the Beyond</h2><p>今天，Kubernetes 项目跨越了5个组织125个仓库。有31个特殊利益集团和10个工作组在项目内协调发展。在过去的一年里，该项目有 <a href="https://k8s.devstats.cncf.io/d/13/developer-activity-counts-by-repository-group?orgId=1&var-period_name=Last%20year&var-metric=contributions&var-repogroup_name=All">来自13800多名独立开发人员的参与</a>。</p><p>在任何给定的工作日，我们的 Prow 实例<a href="http://velodrome.k8s.io/dashboard/db/bigquery-metrics?panelId=10&fullscreen&orgId=1&from=now-6M&to=now">运行超过10,000个 CI 工作</a>; 从2017年3月到2018年3月，它有430万个工作岗位。 这些工作中的大多数涉及建立整个 Kubernetes 集群，并使用真实场景来实施它。 它们使我们能够确保所有受支持的 Kubernetes 版本跨云提供商，容器引擎和网络插件工作。 他们确保最新版本的 Kubernetes 能够启用各种可选功能，安全升级，满足性能要求，并跨架构工作。</p><p>今天<a href=https://www.cncf.io/announcement/2018/08/29/cncf-receives-9-million-cloud-credit-grant-from-google>来自CNCF的公告</a> - 注意到 Google Cloud 有开始将 Kubernetes 项目的云资源的所有权和管理权转让给 CNCF 社区贡献者，我们很高兴能够开始另一个旅程。 允许项目基础设施由贡献者社区拥有和运营，遵循对项目其余部分有效的相同开放治理模型。 听起来令人兴奋。 请来 kubernetes.slack.com 上的 #sig-testing on kubernetes.slack.com 与我们联系。</p><p>想了解更多？ 快来看看这些资源：</p><ul><li><a href=https://elder.dev/posts/prow>Prow: Testing the way to Kubernetes Next</a></li><li><a href="https://www.youtube.com/watch?v=BsIC7gPkH5M">Automation and the Kubernetes Contributor Experience</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-87d6b9119a0096eaf905a06844242333>OPA Gatekeeper：Kubernetes 的策略和管理</h1><div class="td-byline mb-4"><time datetime=2019-08-06 class=text-muted>2019.08.06</time></div><p><strong>作者：</strong> Rita Zhang (Microsoft), Max Smythe (Google), Craig Hooper (Commonwealth Bank AU), Tim Hinrichs (Styra), Lachie Evenson (Microsoft), Torin Sandall (Styra)</p><p>可以从项目 <a href=https://github.com/open-policy-agent/gatekeeper>Open Policy Agent Gatekeeper</a> 中获得帮助，在 Kubernetes 环境下实施策略并加强治理。在本文中，我们将逐步介绍该项目的目标，历史和当前状态。</p><p>以下是 Kubecon EU 2019 会议的录音，帮助我们更好地开展与 Gatekeeper 合作：</p><ul><li><a href=https://youtu.be/Yup1FUc2Qn0>简介：开放策略代理 Gatekeeper</a></li><li><a href=https://youtu.be/n94_FNhuzy4>深入研究：开放策略代理</a></li></ul><h2 id=出发点>出发点</h2><p>如果您所在的组织一直在使用 Kubernetes，您可能一直在寻找如何控制终端用户在集群上的行为，以及如何确保集群符合公司政策。这些策略可能需要满足管理和法律要求，或者符合最佳执行方法和组织惯例。使用 Kubernetes，如何在不牺牲开发敏捷性和运营独立性的前提下确保合规性？</p><p>例如，您可以执行以下策略：</p><ul><li>所有镜像必须来自获得批准的存储库</li><li>所有入口主机名必须是全局唯一的</li><li>所有 Pod 必须有资源限制</li><li>所有命名空间都必须具有列出联系的标签</li></ul><p>在接收请求被持久化为 Kubernetes 中的对象之前，Kubernetes 允许通过 <a href=https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/>admission controller webhooks</a> 将策略决策与 API 服务器分离，从而拦截这些请求。<a href=https://github.com/open-policy-agent/gatekeeper>Gatekeeper</a> 创建的目的是使用户能够通过配置（而不是代码）自定义控制许可，并使用户了解集群的状态，而不仅仅是针对评估状态的单个对象，在这些对象准许加入的时候。Gatekeeper 是 Kubernetes 的一个可定制的许可 webhook ，它由 <a href=https://www.openpolicyagent.org>Open Policy Agent (OPA)</a> 强制执行， OPA 是 Cloud Native 环境下的策略引擎，由 CNCF 主办。</p><h2 id=发展>发展</h2><p>在深入了解 Gatekeeper 的当前情况之前，让我们看一下 Gatekeeper 项目是如何发展的。</p><ul><li>Gatekeeper v1.0 - 使用 OPA 作为带有 kube-mgmt sidecar 的许可控制器，用来强制执行基于 configmap 的策略。这种方法实现了验证和转换许可控制。贡献方：Styra</li><li>Gatekeeper v2.0 - 使用 Kubernetes 策略控制器作为许可控制器，OPA 和 kube-mgmt sidecar 实施基于 configmap 的策略。这种方法实现了验证和转换准入控制和审核功能。贡献方：Microsoft</li><li>Gatekeeper v3.0 - 准入控制器与 <a href=https://github.com/open-policy-agent/frameworks/tree/master/constraint>OPA Constraint Framework</a> 集成在一起，用来实施基于 CRD 的策略，并可以可靠地共享已完成声明配置的策略。使用 kubebuilder 进行构建，实现了验证以及最终转换（待完成）为许可控制和审核功能。这样就可以为 <a href=https://www.openpolicyagent.org/docs/latest/how-do-i-write-policies/>Rego</a> 策略创建策略模板，将策略创建为 CRD 并存储审核结果到策略 CRD 上。该项目是 Google，Microsoft，Red Hat 和 Styra 合作完成的。</li></ul><p><img src=/images/blog/2019-08-06-opa-gatekeeper/v3.png alt></p><h2 id=gatekeeper-v3-0-的功能>Gatekeeper v3.0 的功能</h2><p>现在我们详细看一下 Gatekeeper 当前的状态，以及如何利用所有最新的功能。假设一个组织希望确保集群中的所有对象都有 department 信息，这些信息是对象标签的一部分。如何利用 Gatekeeper 完成这项需求？</p><h3 id=验证许可控制>验证许可控制</h3><p>在集群中所有 Gatekeeper 组件都 <a href=https://github.com/open-policy-agent/gatekeeper>安装</a> 完成之后，只要集群中的资源进行创建、更新或删除，API 服务器将触发 Gatekeeper 准入 webhook 来处理准入请求。</p><p>在验证过程中，Gatekeeper 充当 API 服务器和 OPA 之间的桥梁。API 服务器将强制实施 OPA 执行的所有策略。</p><h3 id=策略与-constraint>策略与 Constraint</h3><p>结合 OPA Constraint Framework，Constraint 是一个声明，表示作者希望系统满足给定的一系列要求。Constraint 都使用 Rego 编写，Rego 是声明性查询语言，OPA 用 Rego 来枚举违背系统预期状态的数据实例。所有 Constraint 都遵循逻辑 AND。假使有一个 Constraint 不满足，那么整个请求都将被拒绝。</p><p>在定义 Constraint 之前，您需要创建一个 Constraint Template，允许大家声明新的 Constraint。每个模板都描述了强制执行 Constraint 的 Rego 逻辑和 Constraint 的模式，其中包括 CRD 的模式和传递到 enforces 中的参数，就像函数的参数一样。</p><p>例如，以下是一个 Constraint 模板 CRD，它的请求是在任意对象上显示某些标签。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>templates.gatekeeper.sh/v1beta1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConstraintTemplate<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>k8srequiredlabels<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>crd</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>names</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>K8sRequiredLabels<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>listKind</span>:<span style=color:#bbb> </span>K8sRequiredLabelsList<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>plural</span>:<span style=color:#bbb> </span>k8srequiredlabels<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>singular</span>:<span style=color:#bbb> </span>k8srequiredlabels<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>validation</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># Schema for the `parameters` field</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>openAPIV3Schema</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>properties</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>array<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb> </span>string<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>targets</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>target</span>:<span style=color:#bbb> </span>admission.k8s.gatekeeper.sh<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>rego</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        package k8srequiredlabels
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        deny[{&#34;msg&#34;: msg, &#34;details&#34;: {&#34;missing_labels&#34;: missing}}] {
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>          provided := {label | input.review.object.metadata.labels[label]}
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>          required := {label | label := input.parameters.labels[_]}
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>          missing := required - provided
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>          count(missing) &gt; 0
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>          msg := sprintf(&#34;you must provide labels: %v&#34;, [missing])
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        }</span><span style=color:#bbb>        
</span></span></span></code></pre></div><p>在集群中部署了 Constraint 模板后，管理员现在可以创建由 Constraint 模板定义的单个 Constraint CRD。例如，这里以下是一个 Constraint CRD，要求标签 <code>hr</code> 出现在所有命名空间上。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>constraints.gatekeeper.sh/v1beta1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>K8sRequiredLabels<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>ns-must-have-hr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>match</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kinds</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>kinds</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;Namespace&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;hr&#34;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div><p>类似地，可以从同一个 Constraint 模板轻松地创建另一个 Constraint CRD，该 Constraint CRD 要求所有命名空间上都有 <code>finance</code> 标签。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>constraints.gatekeeper.sh/v1beta1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>K8sRequiredLabels<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>ns-must-have-finance<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>match</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kinds</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>kinds</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;Namespace&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;finance&#34;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div><p>如您所见，使用 Constraint framework，我们可以通过 Constraint 模板可靠地共享 rego，使用匹配字段定义执行范围，并为 Constraint 提供用户定义的参数，从而为每个 Constraint 创建自定义行为。</p><h3 id=审核>审核</h3><p>根据集群中强制执行的 Constraint，审核功能可定期评估复制的资源，并检测先前存在的错误配置。Gatekeeper 将审核结果存储为 <code>violations</code>，在相关 Constraint 的 <code>status</code> 字段中列出。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>constraints.gatekeeper.sh/v1beta1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>K8sRequiredLabels<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>ns-must-have-hr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>match</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kinds</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>kinds</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;Namespace&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;hr&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>auditTimestamp</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2019-08-06T01:46:13Z&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>byPod</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>enforced</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>id</span>:<span style=color:#bbb> </span>gatekeeper-controller-manager-0<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>violations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>enforcementAction</span>:<span style=color:#bbb> </span>deny<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Namespace<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>message: &#39;you must provide labels</span>:<span style=color:#bbb> </span>{<span style=color:#b44>&#34;hr&#34;</span>}<span style=color:#b44>&#39;
</span></span></span><span style=display:flex><span><span style=color:#b44>    name: default
</span></span></span><span style=display:flex><span><span style=color:#b44>  - enforcementAction: deny
</span></span></span><span style=display:flex><span><span style=color:#b44>    kind: Namespace
</span></span></span><span style=display:flex><span><span style=color:#b44>    message: &#39;</span><span style=color:green;font-weight:700>you must provide labels</span>:<span style=color:#bbb> </span>{<span style=color:#b44>&#34;hr&#34;</span>}<span style=color:#b44>&#39;
</span></span></span><span style=display:flex><span><span style=color:#b44>    name: gatekeeper-system
</span></span></span><span style=display:flex><span><span style=color:#b44>  - enforcementAction: deny
</span></span></span><span style=display:flex><span><span style=color:#b44>    kind: Namespace
</span></span></span><span style=display:flex><span><span style=color:#b44>    message: &#39;</span><span style=color:green;font-weight:700>you must provide labels</span>:<span style=color:#bbb> </span>{<span style=color:#b44>&#34;hr&#34;</span>}<span style=color:#b44>&#39;
</span></span></span><span style=display:flex><span><span style=color:#b44>    name: kube-public
</span></span></span><span style=display:flex><span><span style=color:#b44>  - enforcementAction: deny
</span></span></span><span style=display:flex><span><span style=color:#b44>    kind: Namespace
</span></span></span><span style=display:flex><span><span style=color:#b44>    message: &#39;</span><span style=color:green;font-weight:700>you must provide labels</span>:<span style=color:#bbb> </span>{<span style=color:#b44>&#34;hr&#34;</span>}&#39;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=数据复制>数据复制</h3><p>审核要求将 Kubernetes 复制到 OPA 中，然后才能根据强制的 Constraint 对其进行评估。数据复制同样也需要 Constraint，这些 Constraint 需要访问集群中除评估对象之外的对象。例如，一个 Constraint 要强制确定入口主机名的唯一性，就必须有权访问集群中的所有其他入口。</p><p>对 Kubernetes 数据进行复制，请使用复制到 OPA 中的资源创建 sync config 资源。例如，下面的配置将所有命名空间和 Pod 资源复制到 OPA。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>config.gatekeeper.sh/v1alpha1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;gatekeeper-system&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>sync</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>syncOnly</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>group</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;v1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Namespace&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>group</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;v1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Pod&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=未来计划>未来计划</h2><p>Gatekeeper 项目背后的社区将专注于提供转换许可控制，可以用来支持转换方案（例如：在创建新资源时使用 department 信息自动注释对象），支持外部数据以将集群外部环境加入到许可决策中，支持试运行以便在执行策略之前了解策略对集群中现有资源的影响，还有更多的审核功能。</p><p>如果您有兴趣了解更多有关该项目的信息，请查看 <a href=https://github.com/open-policy-agent/gatekeeper>Gatekeeper</a> 存储库。如果您有兴趣帮助确定 Gatekeeper 的方向，请加入 <a href=https://openpolicyagent.slack.com/messages/CDTN970AX>#kubernetes-policy</a> OPA Slack 频道，并加入我们的 <a href=https://docs.google.com/document/d/1A1-Q-1OMw3QODs1wT6eqfLTagcGmgzAJAjJihiO3T48/edit>周会</a> 一同讨论开发、任务、用例等。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-037f0eed4d73549cc2f339290039e718>欢迎参加在上海举行的贡献者峰会</h1><div class="td-byline mb-4"><time datetime=2019-06-11 class=text-muted>2019.06.11</time></div><p><strong>Author</strong>: Josh Berkus (Red Hat)</p><p>![贡献者小组讨论掠影，摄于 2018 年上海贡献者峰会，作者 Josh Berkus, 许可证 CC-BY 4.0](/images/blog/2019-
06-11-contributor-summit-shanghai/panel.png)</p><p>连续第二年，我们将在 <a href=https://events.linuxfoundation.cn/events/kubecon-cloudnativecon-china-2019/>KubeCon China</a> 之前举行一天的 <a href=https://www.lfasiallc.com/events/contributors-summit-china-2019/>贡献者峰会</a>。
不管您是否已经是一名 Kubernetes 贡献者，还是想要加入社区队伍，贡献一份力量，都请考虑<a href=https://www.lfasiallc.com/events/contributors-summit-china-2019/register/>注册</a>参加这次活动。
这次峰会将于六月 24 号，在上海世博中心（和 KubeCon 的举办地点相同）举行，
一天的活动将包含“现有贡献者活动”，以及“新贡献者工作坊”和“文档小组活动”。</p><h3 id=现有贡献者活动>现有贡献者活动</h3><p>去年的贡献者节之后，我们的团队收到了很多反馈意见，很多亚洲和大洋洲的贡献者也想要针对当前贡献者的峰会内容。
有鉴于此，我们在今年的安排中加入了当前贡献者的主题。</p><p>尽管我们还没有一个完整的时间安排，下面是当前贡献者主题所会包含的话题：</p><ul><li>如何撰写 Kubernetes 改进议案 (KEP)</li><li>代码库研习</li><li>本地构建以及测试调试</li><li>不写代码的贡献机会</li><li>SIG-Azure 面对面交流</li><li>SIG-Scheduling 面对面交流</li><li>其他兴趣小组的面对面机会</li></ul><p>整个计划安排将会在完全确定之后，整理放在<a href=https://github.com/kubernetes/community/tree/master/events/2019/06-contributor-summit>社区页面</a>上。</p><p>如果您的 SIG 想要在 Kubecon Shanghai 上进行面对面的交流，请联系 <a href=mailto:jberkus@redhat.com>Josh Berkus</a>。</p><h3 id=新贡献者工作坊>新贡献者工作坊</h3><p>参与过<a href=/blog/2018/12/05/new-contributor-workshop-shanghai/>去年新贡献者工作坊（NCW）</a>的学生觉得这项活动非常的有价值，
这项活动也帮助、引导了很多亚洲和大洋洲的开发者更多地参与到 Kubernetes 社区之中。</p><blockquote><p>“这次活动可以让人一次快速熟悉社区。”其中的一位参与者提到。</p></blockquote><p>如果您之前从没有参与过 Kubernetes 的贡献，或者只是做过一次或两次贡献，都请考虑<a href=https://www.lfasiallc.com/events/contributors-summit-china-2019/register/>注册参加</a>新贡献者工作坊。</p><blockquote><p>“熟悉了从 CLA 到 PR 的整个流程，也认识结交了很多贡献者。”另一位开发者提到。</p></blockquote><h3 id=文档小组活动>文档小组活动</h3><p>文档小组的新老贡献者都会聚首一天，讨论如何提升文档质量，以及将文档翻译成更多的语言。
如果您对翻译文档，将这些知识和信息翻译成中文和其他语言感兴趣的话，请在这里<a href=https://www.lfasiallc.com/events/contributors-summit-china-2019/register/>注册</a>，报名参加文档小组活动。</p><h3 id=参与之前>参与之前</h3><p>不论您参与的是哪一项活动，所有人都需要在到达贡献者峰会前签署 <a href=https://git.k8s.io/community/CLA.md#the-contributor-license-agreement>Kubernetes CLA</a>。
您也同时需要考虑带一个合适的笔记本电脑，帮助文档写作或是编程开发。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-61a7d410a8742331c4512c365210431d>壮大我们的贡献者研讨会</h1><div class="td-byline mb-4"><time datetime=2019-05-14 class=text-muted>2019.05.14</time></div><p><strong>作者:</strong> Guinevere Saenger (GitHub) 和 Paris Pittman (Google)（谷歌）</p><p><strong>tl;dr</strong> - 与我们一起了解贡献者社区，并获得你的第一份 PR ! 我们在[巴塞罗那][欧洲]有空位（登记 在5月15号周三<strong>结束</strong>，所以抓住这次机会！）并且在[上海][中国]有即将到来的峰会。</p><p>巴塞罗那的活动将是我们迄今为止最大的一次，登记的参与者比以往任何时候都多！</p><p>你是否曾经想为 Kubernetes 做贡献，但不知道从哪里开始？你有没有曾经看过我们社区的许多代码库并认为需要改进的地方？我们为你准备了一个工作室！</p><p>KubeCon + CloudNativeCon 巴塞罗那的研讨会<a href=https://events.linuxfoundation.org/events/contributor-summit-europe-2019/>新贡献者研讨会</a>将是第四个这样的研讨会，我们真的很期待！</p><p>这个研讨会去年在哥本哈根的 KubeConEU 启动，到目前为止，我们已经把它带到了上海和西雅图，现在是巴塞罗那，以及一些非 KubeConEU 的地方。</p><p>我们根据以往课程的反馈，不断更新和改进研讨会的内容。</p><p>这一次，我们将根据参与者对开源和 Kubernetes 的经验和适应程度来进行划分。</p><p>作为101课程的一部分，我们将为完全不熟悉开源和 Kubernetes 的人提供开发人员设置和项目工作流支持，并希望为每个参与者开展他们自己的第一期工作。</p><p>在201课程中，我们将为那些在开源方面有更多经验但可能不熟悉我们社区开发工具的人进行代码库演练和本地开发和测试演示。</p><p>对于这两门课程，你将有机会亲自动手并体会到其中的乐趣。因为不是每个贡献者都使用代码，也不是每项贡献都是技术性的，所以我们将在研讨会开始时学习如何构建和组织项目，以及如何进行找到合适的人，以及遇到困难时在哪里寻求帮助。</p><h2 id=辅导机会>辅导机会</h2><p>我们还将回归 SIG Meet-and-Greet，在这里新入门的菜鸟贡献者将有机会与当值的贡献者交流，这也许会让他们找到他们梦想的 SIG，了解他们可以帮助哪些激动人心的领域，获得导师，结交朋友。</p><p>PS - 5月23日星期四，在 KubeCon+CloudNativeCon 会议期间会有两次导师会议。[在这里注册][导师]。在西雅图活动期间，60% 的与会者会向贡献者提问。</p><h2 id=曾经与会者的故事-vallery-lancy-lyft-的工程师>曾经与会者的故事 - Vallery Lancy，Lyft 的工程师</h2><p>在一系列采访中，我们与一些过去的参与者进行了交谈，这些采访将在今年全年公布。</p><p>在我们的前两个片段中，我们会提到 Vallery Lancy，Lyft 公司的工程师，也是我们最近西雅图版研讨会的75名与会者之一。她在社区里闲逛了一段时间，想看看能不能投身到某个领域当中。</p><p>在这里观看 Vallery 讲述她的经历：<center><iframe width=560 height=315 src=https://www.youtube.com/embed/uKg5WUcl6WU frameborder=0 allow="autoplay; encrypted-media" allowfullscreen></iframe></center></p><p>Vallery 和那些对研讨会感兴趣的人或者参加巴塞罗那会议的人说了些什么？</p><center><iframe width=560 height=315 src=https://www.youtube.com/embed/niHiem7JmPA frameborder=0 allow="autoplay; encrypted-media" allowfullscreen></iframe></center><p>想变得和 Vallery 还有数百名参与之前的新贡献者研讨会的与会者一样的话：在巴塞罗那（或者上海-或者圣地亚哥！）加入我们！你会有一个与众不同的体验，而不再是死读我们的文档！</p><p>Have the opportunity to meet with the experts and go step by step into your journey with your peers around you. We’re looking forward to seeing you there! <a href=https://events.linuxfoundation.org/events/contributor-summit-europe-2019/>Register here</a>
-->
你将有机会与专家见面，并与周围的同龄人一步步走上属于你的道路。我们期待着在那里与你见面！<a href=https://events.linuxfoundation.org/events/contributor-summit-europe-2019/> 在这里注册</a></p></div><div class=td-content style=page-break-before:always><h1 id=pg-d21acaf645c18e3c642d1cbc4482e575>如何参与 Kubernetes 文档的本地化工作</h1><div class="td-byline mb-4"><time datetime=2019-04-26 class=text-muted>2019.04.26</time></div><p><strong>作者: Zach Corleissen（Linux 基金会）</strong></p><p>去年我们对 Kubernetes 网站进行了优化，加入了<a href=https://kubernetes.io/blog/2018/11/08/kubernetes-docs-updates-international-edition/>多语言内容的支持</a>。贡献者们踊跃响应，加入了多种新的本地化内容：截至 2019 年 4 月，Kubernetes 文档有了 9 个不同语言的未完成版本，其中有 6 个是 2019 年加入的。在每个 Kubernetes 文档页面的上方，读者都可以看到一个语言选择器，其中列出了所有可用语言。</p><p>不论是完成度最高的<a href=https://v1-12.docs.kubernetes.io/zh-cn/>中文版 v1.12</a>，还是最新加入的<a href=https://kubernetes.io/pt/>葡萄牙文版 v1.14</a>，各语言的本地化内容还未完成，这是一个进行中的项目。如果读者有兴趣对现有本地化工作提供支持，请继续阅读。</p><h2 id=什么是本地化>什么是本地化</h2><p>翻译是以词表意的问题。而本地化在此基础之上，还包含了过程和设计方面的工作。</p><p>本地化和翻译很像，但是包含更多内容。除了进行翻译之外，本地化还要为编写和发布过程的框架进行优化。例如，Kubernetes.io 多数的站点浏览功能（按钮文字）都保存在<a href=https://github.com/kubernetes/website/tree/master/i18n>单独的文件</a>之中。所以启动新本地化的过程中，需要包含加入对特定文件中字符串进行翻译的工作。</p><p>本地化很重要，能够有效的降低 Kubernetes 的采纳和支持门槛。如果能用母语阅读 Kubernetes 文档，就能更轻松的开始使用 Kubernetes，并对其发展作出贡献。</p><h2 id=如何启动本地化工作>如何启动本地化工作</h2><p>不同语言的本地化工作都是单独的功能——和其它 Kubernetes 功能一致，贡献者们在一个 SIG 中进行本地化工作，分享出来进行评审，并加入项目。</p><p>贡献者们在团队中进行内容的本地化工作。因为自己不能批准自己的 PR，所以一个本地化团队至少应该有两个人——例如意大利文的本地化团队有两个人。这个团队规模可能很大：中文团队有几十个成员。</p><p>每个团队都有自己的工作流。有些团队手工完成所有的内容翻译；有些会使用带有翻译插件的编译器，并使用评审机来提供正确性的保障。SIG Docs 专注于输出的标准；这就给了本地化团队采用适合自己工作情况的工作流。这样一来，团队可以根据最佳实践进行协作，并以 Kubernetes 的社区精神进行分享。</p><h2 id=为本地化工作添砖加瓦>为本地化工作添砖加瓦</h2><p>如果你有兴趣为 Kubernetes 文档加入新语种的本地化内容，<a href=https://kubernetes.io/docs/contribute/localization/>Kubernetes contribution guide</a> 中包含了这方面的相关内容。</p><p>已经启动的的本地化工作同样需要支持。如果有兴趣为现存项目做出贡献，可以加入本地化团队的 Slack 频道，去做个自我介绍。各团队的成员会帮助你开始工作。</p><table><thead><tr><th>语种</th><th>Slack 频道</th></tr></thead><tbody><tr><td>中文</td><td><a href=https://kubernetes.slack.com/messages/CE3LNFYJ1/>#kubernetes-docs-zh</a></td></tr><tr><td>英文</td><td><a href=https://kubernetes.slack.com/messages/C1J0BPD2M/>#sig-docs</a></td></tr><tr><td>法文</td><td><a href=https://kubernetes.slack.com/messages/CG838BFT9/>#kubernetes-docs-fr</a></td></tr><tr><td>德文</td><td><a href=https://kubernetes.slack.com/messages/CH4UJ2BAL/>#kubernetes-docs-de</a></td></tr><tr><td>印地</td><td><a href=https://kubernetes.slack.com/messages/CJ14B9BDJ/>#kubernetes-docs-hi</a></td></tr><tr><td>印度尼西亚文</td><td><a href=https://kubernetes.slack.com/messages/CJ1LUCUHM/>#kubernetes-docs-id</a></td></tr><tr><td>意大利文</td><td><a href=https://kubernetes.slack.com/messages/CGB1MCK7X/>#kubernetes-docs-it</a></td></tr><tr><td>日文</td><td><a href=https://kubernetes.slack.com/messages/CAG2M83S8/>#kubernetes-docs-ja</a></td></tr><tr><td>韩文</td><td><a href=https://kubernetes.slack.com/messages/CA1MMR86S/>#kubernetes-docs-ko</a></td></tr><tr><td>葡萄牙文</td><td><a href=https://kubernetes.slack.com/messages/CJ21AS0NA/>#kubernetes-docs-pt</a></td></tr><tr><td>西班牙文</td><td><a href=https://kubernetes.slack.com/messages/CH7GB2E3B/>#kubernetes-docs-es</a></td></tr></tbody></table><h2 id=下一步>下一步？</h2><p>最新的<a href=https://kubernetes.slack.com/messages/CJ14B9BDJ/>印地文本地化</a>工作正在启动。为什么不加入你的语言？</p><p>身为 SIG Docs 的主席，我甚至希望本地化工作跳出文档范畴，直接为 Kubernetes 组件提供本地化支持。有什么组件是你希望支持不同语言的么？可以提交一个 <a href=https://github.com/kubernetes/enhancements/tree/master/keps>Kubernetes Enhancement Proposal</a> 来促成这一进步。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-d59cccde9a0772812b0e105b30f5b7c7>Kubernetes 1.14 稳定性改进中的进程ID限制</h1><div class="td-byline mb-4"><time datetime=2019-04-15 class=text-muted>2019.04.15</time></div><p><strong>作者: Derek Carr</strong></p><p>你是否见过有人拿走了比属于他们那一份更多的饼干？ 一个人走过来，抓起半打新鲜烤制的大块巧克力饼干然后匆匆离去，就像饼干怪兽大喊 “Om nom nom nom”。</p><p>在一些罕见的工作负载中，Kubernetes 集群内部也发生了类似的情况。每个 Pod 和 Node 都有有限数量的可能的进程 ID（PID），供所有应用程序共享。尽管很少有进程或 Pod 能够进入并获取所有 PID，但由于这种行为，一些用户会遇到资源匮乏的情况。 因此，在 Kubernetes 1.14 中，我们引入了一项增强功能，以降低单个 Pod 垄断所有可用 PID 的风险。</p><h2 id=你能预留一些-pids-吗>你能预留一些 PIDs 吗？</h2><p>在这里，我们谈论的是某些容器的贪婪性。 在理想情况之外，失控进程有时会发生，特别是在测试集群中。 因此，在这些集群中会发生一些混乱的非生产环境准备就绪的事情。</p><p>在这种情况下，可能会在节点内部发生类似于 fork 炸弹耗尽 PID 的攻击。随着资源的缓慢腐蚀，被一些不断产生子进程的僵尸般的进程所接管，其他正常的工作负载会因为这些像气球般不断膨胀的浪费的处理能力而开始受到冲击。这可能导致同一 Pod 上的其他进程缺少所需的 PID。这也可能导致有趣的副作用，因为节点可能会发生故障，并且该Pod的副本将安排到新的机器上，至此，该过程将在整个集群中重复进行。</p><h2 id=解决问题>解决问题</h2><p>因此，在 Kubernetes 1.14 中，我们添加了一个特性，允许通过配置 kubelet，限制给定 Pod 可以消耗的 PID 数量。如果该机器支持 32768 个 PIDs 和 100 个 Pod，则可以为每个 Pod 提供 300 个 PIDs 的预算，以防止 PIDs 完全耗尽。如果管理员想要像 CPU 或内存那样过度使用 PIDs，那么他们也可以配置超额使用，但是这样会有一些额外风险。不管怎样，没有一个Pod能搞坏整个机器。这通常会防止简单的分叉函数炸弹接管你的集群。</p><p>此更改允许管理员保护一个 Pod 不受另一个 Pod 的影响，但不能确保计算机上的所有 Pod 都能保护节点和节点代理本身不受影响。因此，我们在这个版本中以 Alpha 的形式引入了这个一个特性，它提供了 PIDs 在节点代理（ kubelet、runtime 等）与 Pod 上的最终用户工作负载的分离。管理员可以预定特定数量的 pid（类似于今天如何预定 CPU 或内存），并确保它们不会被该计算机上的 pod 消耗。一旦从 Alpha 进入到 Beta，然后在将来的 Kubernetes 版本中稳定下来，我们就可以使用这个特性防止 Linux 资源耗尽。</p><p>开始使用 <a href=https://github.com/Kubernetes/Kubernetes/releases/tag/v1.14.0>Kubernetes 1.14</a>。</p><p>##参与其中</p><p>如果您对此特性有反馈或有兴趣参与其设计与开发，请加入[节点特别兴趣小组](<a href=https://github.com/kubernetes/community/tree/master/sig>https://github.com/kubernetes/community/tree/master/sig</a> Node)。</p><p>###关于作者：
Derek Carr 是 Red Hat 高级首席软件工程师。他也是 Kubernetes 的贡献者和 Kubernetes 社区指导委员会的成员。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-19cd0c4556be5dfd65e562e60778ef83>Raw Block Volume 支持进入 Beta</h1><div class="td-byline mb-4"><time datetime=2019-03-07 class=text-muted>2019.03.07</time></div><p><strong>作者：</strong>
Ben Swartzlander (NetApp), Saad Ali (Google)</p><p>Kubernetes v1.13 中对原生数据块卷（Raw Block Volume）的支持进入 Beta 阶段。此功能允许将持久卷作为块设备而不是作为已挂载的文件系统暴露在容器内部。</p><h2 id=什么是块设备>什么是块设备？</h2><p>块设备允许对固定大小的块中的数据进行随机访问。硬盘驱动器、SSD 和 CD-ROM 驱动器都是块设备的例子。</p><p>通常，持久性性存储是在通过在块设备（例如磁盘或 SSD）之上构造文件系统（例如 ext4）的分层方式实现的。这样应用程序就可以读写文件而不是操作数据块进。操作系统负责使用指定的文件系统将文件读写转换为对底层设备的数据块读写。</p><p>值得注意的是，整个磁盘都是块设备，磁盘分区也是如此，存储区域网络（SAN）设备中的 LUN 也是一样的。</p><h2 id=为什么要将-raw-block-volume-添加到-kubernetes>为什么要将 raw block volume 添加到 kubernetes？</h2><p>有些特殊的应用程序需要直接访问块设备，原因例如，文件系统层会引入不必要的开销。最常见的情况是数据库，通常会直接在底层存储上组织数据。原生的块设备（Raw Block Devices）还通常由能自己实现某种存储服务的软件（软件定义的存储系统）使用。</p><p>从程序员的角度来看，块设备是一个非常大的字节数组，具有某种最小读写粒度，通常为 512 个字节，大部分情况为 4K 或更大。</p><p>随着在 Kubernetes 中运行数据库软件和存储基础架构软件变得越来越普遍，在 Kubernetes 中支持原生块设备的需求变得越来越重要。</p><h2 id=哪些卷插件支持-raw-block>哪些卷插件支持 raw block？</h2><p>在发布此博客时，以下 in-tree 卷类型支持原生块设备：</p><ul><li>AWS EBS</li><li>Azure Disk</li><li>Cinder</li><li>Fibre Channel</li><li>GCE PD</li><li>iSCSI</li><li>Local volumes</li><li>RBD (Ceph)</li><li>Vsphere</li></ul><p>Out-of-tree <a href=https://kubernetes.io/blog/2019/01/15/container-storage-interface-ga/>CSI 卷驱动程序</a> 可能也支持原生数据块卷。Kubernetes CSI 对原生数据块卷的支持目前为 alpha 阶段。参考 <a href=https://kubernetes-csi.github.io/docs/raw-block.html>这篇</a> 文档。</p><h2 id=kubernetes-raw-block-volume-的-api>Kubernetes raw block volume 的 API</h2><p>原生数据块卷与普通存储卷有很多共同点。两者都通过创建与 <code>PersistentVolume</code> 对象绑定的 <code>PersistentVolumeClaim</code> 对象发起请求，并通过将它们加入到 <code>PodSpec</code> 的 volumes 数组中来连接到 Kubernetes 中的 Pod。</p><p>但是有两个重要的区别。首先，要请求原生数据块设备的 <code>PersistentVolumeClaim</code> 必须在 <code>PersistentVolumeClaimSpec</code> 中设置 <code>volumeMode = "Block"</code>。<code>volumeMode</code> 为空时与传统设置方式中的指定 <code>volumeMode = "Filesystem"</code> 是一样的。<code>PersistentVolumes</code> 在其 <code>PersistentVolumeSpec</code> 中也有一个 <code>volumeMode</code> 字段，<code>"Block"</code> 类型的 PVC 只能绑定到 <code>"Block"</code> 类型的 PV 上，而<code>"Filesystem"</code> 类型的 PVC 只能绑定到 <code>"Filesystem"</code> PV 上。</p><p>其次，在 Pod 中使用原生数据块卷时，必须在 <code>PodSpec</code> 的 Container 部分指定一个 <code>VolumeDevice</code>，而不是 <code>VolumeMount</code>。<code>VolumeDevices</code> 具备 <code>devicePaths</code> 而不是 <code>mountPaths</code>，在容器中，应用程序将看到位于该路径的设备，而不是挂载了的文件系统。</p><p>应用程序打开、读取和写入容器内的设备节点，就像它们在非容器化或虚拟环境中与系统上的任何块设备交互一样。</p><h2 id=创建一个新的原生块设备-pvc>创建一个新的原生块设备 PVC</h2><p>首先，请确保与您选择的存储类关联的驱动支持原生块设备。然后创建 PVC。</p><pre tabindex=0><code>apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: my-pvc
spec:
  accessModes:
    - ReadWriteMany
  volumeMode: Block
  storageClassName: my-sc
  resources:
    requests:
    storage: 1Gi
</code></pre><h2 id=使用原生块-pvc>使用原生块 PVC</h2><p>在 Pod 定义中使用 PVC 时，需要选择块设备的设备路径，而不是文件系统的安装路径。</p><pre tabindex=0><code>apiVersion: v1
kind: Pod
metadata:
  name: my-pod
spec:
  containers:
    - name: my-container
      image: busybox
      command:
        - sleep
        - “3600”
      volumeDevices:
        - devicePath: /dev/block
          name: my-volume
      imagePullPolicy: IfNotPresent
  volumes:
    - name: my-volume
      persistentVolumeClaim:
        claimName: my-pvc
</code></pre><h2 id=作为存储供应商-我如何在-csi-插件中添加对原生块设备的支持>作为存储供应商，我如何在 CSI 插件中添加对原生块设备的支持？</h2><p>CSI 插件的原生块支持仍然是 alpha 版本，但是现在可以改进了。<a href=https://github.com/container-storage-interface/spec/blob/master/spec.md>CSI 规范</a> 详细说明了如何处理具有 <code>BlockVolume</code> 能力而不是 <code>MountVolume</code> 能力的卷的请求。CSI 插件可以支持两种类型的卷，也可以支持其中一种或另一种。更多详细信息，请查看 <a href=https://kubernetes-csi.github.io/docs/raw-block.html>这个文档</a>。</p><h2 id=问题-陷阱>问题/陷阱</h2><p>由于块设备实质上还是设备，因此可以从容器内部对其进行底层操作，而文件系统的卷则无法执行这些操作。例如，实际上是块设备的 SCSI 磁盘支持使用 Linux ioctl 向设备发送 SCSI 命令。</p><p>默认情况下，Linux 不允许容器将 SCSI 命令从容器内部发送到磁盘。为此，必须向容器安全层级认证 <code>SYS_RAWIO</code> 功能实现这种行为。请参阅 <a href=/docs/tasks/configure-pod-container/security-context/#set-capabilities-for-a-container>这篇</a> 文档。</p><p>另外，尽管 Kubernetes 保证可以将块设备交付到容器中，但不能保证它实际上是 SCSI 磁盘或任何其他类型的磁盘。用户必须确保所需的磁盘类型与 Pod 一起使用，或只部署可以处理各种块设备类型的应用程序。</p><h2 id=如何学习更多>如何学习更多？</h2><p>在此处查看有关 snapshot 功能的其他文档：<a href=/docs/concepts/storage/persistent-volumes/#raw-block-volume-support>Raw Block Volume 支持</a></p><p>如何参与进来？</p><p>加入 Kubernetes 存储 SIG 和 CSI 社区，帮助我们添加更多出色的功能并改进现有功能，就像 raw block 存储一样！</p><p><a href=https://github.com/kubernetes/community/tree/master/sig-storage>https://github.com/kubernetes/community/tree/master/sig-storage</a>
<a href=https://github.com/container-storage-interface/community/blob/master/README.md>https://github.com/container-storage-interface/community/blob/master/README.md</a></p><p>特别感谢所有为 Kubernetes 增加 block volume 支持的贡献者，包括：</p><ul><li>Ben Swartzlander (<a href=https://github.com/bswartz>https://github.com/bswartz</a>)</li><li>Brad Childs (<a href=https://github.com/childsb>https://github.com/childsb</a>)</li><li>Erin Boyd (<a href=https://github.com/erinboyd>https://github.com/erinboyd</a>)</li><li>Masaki Kimura (<a href=https://github.com/mkimuram>https://github.com/mkimuram</a>)</li><li>Matthew Wong (<a href=https://github.com/wongma7>https://github.com/wongma7</a>)</li><li>Michelle Au (<a href=https://github.com/msau42>https://github.com/msau42</a>)</li><li>Mitsuhiro Tanino (<a href=https://github.com/mtanino>https://github.com/mtanino</a>)</li><li>Saad Ali (<a href=https://github.com/saad-ali>https://github.com/saad-ali</a>)</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-015d4916d80a01d1f89156ab0583fd6c>新贡献者工作坊上海站</h1><div class="td-byline mb-4"><time datetime=2018-12-05 class=text-muted>2018.12.05</time></div><p><strong>作者</strong>: Josh Berkus (红帽), Yang Li (The Plant), Puja Abbassi (Giant Swarm), XiangPeng Zhao (中兴通讯)</p><figure><img src=/images/blog/2018-12-05-new-contributor-shanghai/attendees.png alt="KubeCon 上海站新贡献者峰会与会者，摄影：Jerry Zhang"><figcaption><p>KubeCon 上海站新贡献者峰会与会者，摄影：Jerry Zhang</p></figcaption></figure><p>最近，在中国的首次 KubeCon 上，我们完成了在中国的首次新贡献者峰会。看到所有中国和亚洲的开发者（以及来自世界各地的一些人）有兴趣成为贡献者，这令人非常兴奋。在长达一天的课程中，他们了解了如何、为什么以及在何处为 Kubernetes 作出贡献，创建了 PR，参加了贡献者圆桌讨论，并签署了他们的 CLA。</p><p>这是我们的第二届新贡献者工作坊（NCW），它由前一次贡献者体验 SIG 成员创建和领导的哥本哈根研讨会延伸而来。根据受众情况，本次活动采用了中英文两种语言，充分利用了 CNCF 赞助的一流的同声传译服务。同样，NCW 团队由社区成员组成，既有说英语的，也有说汉语的：Yang Li、XiangPeng Zhao、Puja Abbassi、Noah Abrahams、Tim Pepper、Zach Corleissen、Sen Lu 和 Josh Berkus。除了演讲和帮助学员外，团队的双语成员还将所有幻灯片翻译成了中文。共有五十一名学员参加。</p><figure><img src=/images/blog/2018-12-05-new-contributor-shanghai/noahabrahams.png alt="Noah Abrahams 讲解 Kubernetes 沟通渠道。摄影：Jerry Zhang"><figcaption><p>Noah Abrahams 讲解 Kubernetes 沟通渠道。摄影：Jerry Zhang</p></figcaption></figure><p>NCW 让参与者完成了为 Kubernetes 作出贡献的各个阶段，从决定在哪里作出贡献开始，接着介绍了 SIG 系统和我们的代码仓库结构。我们还有来自文档和测试基础设施领域的「客座讲者」，他们负责讲解有关的贡献。最后，我们在创建 issue、提交并批准 PR 的实践练习后，结束了工作坊。</p><p>这些实践练习使用一个名为<a href=https://github.com/kubernetes-sigs/contributor-playground>贡献者游乐场</a>的代码仓库，由贡献者体验 SIG 创建，让新贡献者尝试在一个 Kubernetes 仓库中执行各种操作。它修改了 Prow 和 Tide 自动化，使用与真实代码仓库类似的 Owners 文件。这可以让学员了解为我们的仓库做出贡献的有关机制，同时又不妨碍正常的开发流程。</p><figure><img src=/images/blog/2018-12-05-new-contributor-shanghai/yangli.png alt="Yang Li 讲到如何让你的 PR 通过评审。摄影：Josh Berkus"><figcaption><p>Yang Li 讲到如何让你的 PR 通过评审。摄影：Josh Berkus</p></figcaption></figure><p>「防火长城」和语言障碍都使得在中国为 Kubernetes 作出贡献变得困难。而且，中国的开源商业模式并不成熟，员工在开源项目上工作的时间有限。</p><p>中国工程师渴望参与 Kubernetes 的研发，但他们中的许多人不知道从何处开始，因为 Kubernetes 是一个如此庞大的项目。通过本次工作坊，我们希望帮助那些想要参与贡献的人，不论他们希望修复他们遇到的一些错误、改进或本地化文档，或者他们需要在工作中用到 Kubernetes。我们很高兴看到越来越多的中国贡献者在过去几年里加入社区，我们也希望将来可以看到更多。</p><p>「我已经参与了 Kubernetes 社区大约三年」，XiangPeng Zhao 说，「在社区，我注意到越来越多的中国开发者表现出对 Kubernetes 贡献的兴趣。但是，开始为这样一个项目做贡献并不容易。我尽力帮助那些我在社区遇到的人，但是，我认为可能仍有一些新的贡献者离开社区，因为他们在遇到麻烦时不知道从哪里获得帮助。幸运的是，社区在 KubeCon 哥本哈根站发起了 NCW，并在 KubeCon 上海站举办了第二届。我很高兴受到 Josh Berkus 的邀请，帮助组织这个工作坊。在工作坊期间，我当面见到了社区里的朋友，在练习中指导了与会者，等等。所有这些对我来说都是难忘的经历。作为有着多年贡献者经验的我，也学习到了很多。我希望几年前我开始为 Kubernetes 做贡献时参加过这样的工作坊」。</p><figure><img src=/images/blog/2018-12-05-new-contributor-shanghai/panel.png alt="贡献者圆桌讨论。摄影：Jerry Zhang"><figcaption><p>贡献者圆桌讨论。摄影：Jerry Zhang</p></figcaption></figure><p>工作坊以现有贡献者圆桌讨论结束，嘉宾包括 Lucas Käldström、Janet Kuo、Da Ma、Pengfei Ni、Zefeng Wang 和 Chao Xu。这场圆桌讨论旨在让新的和现有的贡献者了解一些最活跃的贡献者和维护者的幕后日常工作，不论他们来自中国还是世界各地。嘉宾们讨论了从哪里开始贡献者的旅程，以及如何与评审者和维护者进行互动。他们进一步探讨了在中国参与贡献的主要问题，并向与会者预告了在 Kubernetes 的未来版本中可以期待的令人兴奋的功能。</p><p>工作坊结束后，XiangPeng Zhao 和一些与会者就他们的经历在微信和 Twitter 上进行了交谈。他们很高兴参加了 NCW，并就改进工作坊提出了一些建议。一位名叫 Mohammad 的与会者说：「我在工作坊上玩得很开心，学习了参与 k8s 贡献的整个过程。」另一位与会者 Jie Jia 说：「工作坊非常精彩。它系统地解释了如何为 Kubernetes 做出贡献。即使参与者之前对此一无所知，他（她）也可以理解这个过程。对于那些已经是贡献者的人，他们也可以学习到新东西。此外，我还可以在工作坊上结识来自国内外的新朋友。真是棒极了！」</p><p>贡献者体验 SIG 将继续在未来的 KubeCon 上举办新贡献者工作坊，包括西雅图站、巴塞罗那站，然后在 2019 年六月回到上海。如果你今年未能参加，请在未来的 KubeCon 上注册。并且，如果你遇到工作坊的与会者，请务必欢迎他们加入社区。</p><p>链接：</p><ul><li>中文版幻灯片：<a href=https://gist.github.com/jberkus/889be25c234b01761ce44eccff816380#file-kubernetes-shanghai-cihinese-pdf>PDF</a></li><li>英文版幻灯片：<a href=https://gist.github.com/jberkus/889be25c234b01761ce44eccff816380#file-kubernetes-shanghai-english-pdf>PDF</a> 或 <a href="https://docs.google.com/presentation/d/1l5f_iAFsKg50LFq3N80KbZKUIEL_tyCaUoWPzSxColo/edit?usp=sharing">带有演讲者笔记的 Google Docs</a></li><li><a href=https://github.com/kubernetes-sigs/contributor-playground>贡献者游乐场</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-5193292ae0d55535d8029ff9a7566fca>Kubernetes 文档更新，国际版</h1><div class="td-byline mb-4"><time datetime=2018-11-08 class=text-muted>2018.11.08</time></div><p><strong>作者</strong>：Zach Corleissen （Linux 基金会）</p><p>作为文档特别兴趣小组（SIG Docs）的联合主席，我很高兴能与大家分享 Kubernetes 文档在本地化（l10n）方面所拥有的一个完全成熟的工作流。</p><h2 id=丰富的缩写>丰富的缩写</h2><p>L10n 是 <em>localization</em> 的缩写。</p><p>I18n 是 <em>internationalization</em> 的缩写。</p><p>I18n 定义了<a href=https://www.w3.org/International/questions/qa-i18n>做什么</a> 能让 l10n 更容易。而 L10n 更全面，相比翻译（ <em>t9n</em> ）具备更完善的流程。</p><h2 id=为什么本地化很重要>为什么本地化很重要</h2><p>SIG Docs 的目标是让 Kubernetes 更容易为尽可能多的人使用。</p><p>一年前，我们研究了是否有可能由一个独立翻译 Kubernetes 文档的中国团队来主持文档输出。经过多次交谈（包括 OpenStack l10n 的专家），<a href=https://kubernetes.io/blog/2018/05/05/hugo-migration/>多次转变</a>，以及<a href=https://github.com/kubernetes/website/pull/10485>重新致力于更轻松的本地化</a>，我们意识到，开源文档就像开源软件一样，是在可能的边缘不断进行实践。</p><p>整合工作流程、语言标签和团队级所有权可能看起来像是十分简单的改进，但是这些功能使 l10n 可以扩展到规模越来越大的 l10n 团队。随着 SIG Docs 不断改进，我们已经在单一工作流程中偿还了大量技术债务并简化了 l10n。这对未来和现在都很有益。</p><h2 id=整合的工作流程>整合的工作流程</h2><p>现在，本地化已整合到 <a href=https://github.com/kubernetes/website>kubernetes/website</a> 存储库。我们已经配置了 Kubernetes CI/CD 系统，<a href=https://github.com/kubernetes/test-infra/tree/master/prow>Prow</a> 来处理自动语言标签分配以及团队级 PR 审查和批准。</p><h3 id=语言标签>语言标签</h3><p>Prow 根据文件路径自动添加语言标签。感谢 SIG Docs 贡献者 <a href=https://github.com/kubernetes/test-infra/pull/9835>June Yi</a>，他让人们还可以在 pull request（PR）注释中手动分配语言标签。例如，当为 issue 或 PR 留下下述注释时，将为之分配标签 <code>language/ko</code>（Korean）。</p><pre tabindex=0><code>/language ko
</code></pre><p>这些存储库标签允许审阅者按语言过滤 PR 和 issue。例如，您现在可以过滤 kubernetes/website 面板中<a href="https://github.com/kubernetes/website/pulls?utf8=%E2%9C%93&q=is%3Aopen+is%3Apr+label%3Alanguage%2Fzh">具有中文内容的 PR</a>。</p><h3 id=团队审核>团队审核</h3><p>L10n 团队现在可以审查和批准他们自己的 PR。例如，英语的审核和批准权限在位于用于显示英语内容的顶级子文件夹中的 <a href=https://github.com/kubernetes/website/blob/main/content/en/OWNERS>OWNERS 文件中指定</a>。</p><p>将 <code>OWNERS</code> 文件添加到子目录可以让本地化团队审查和批准更改，而无需由可能并不擅长该门语言的审阅者进行批准。</p><h2 id=下一步是什么>下一步是什么</h2><p>我们期待着<a href=https://kccncchina2018english.sched.com/event/HVb2/contributor-summit-doc-sprint-additional-registration-required>上海的 doc sprint</a> 能作为中国 l10n 团队的资源。</p><p>我们很高兴继续支持正在取得良好进展的日本和韩国 l10n 队伍。</p><p>如果您有兴趣将 Kubernetes 本地化为您自己的语言或地区，请查看我们的<a href=https://kubernetes.io/docs/contribute/localization/>本地化 Kubernetes 文档指南</a>，并联系 <a href=https://github.com/kubernetes/community/tree/master/sig-docs#leadership>SIG Docs 主席团</a>获取支持。</p><h3 id=加入sig-docs>加入SIG Docs</h3><p>如果您对 Kubernetes 文档感兴趣，请参加 SIG Docs <a href=https://github.com/kubernetes/community/tree/master/sig-docs#meetings>每周会议</a>，或在 <a href=https://kubernetes.slack.com/messages/C1J0BPD2M/details/>Kubernetes Slack 加入 #sig-docs</a>。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-5acf5044e610fc3bc7a65c6616cdf99d>Kubernetes 2018 年北美贡献者峰会</h1><div class="td-byline mb-4"><time datetime=2018-10-16 class=text-muted>2018.10.16</time></div><p><strong>作者：</strong></p><p><a href=https://twitter.com/mrbobbytables>Bob Killen</a>（密歇根大学）
<a href=https://twitter.com/sp_zala>Sahdev Zala</a>（IBM），
<a href=https://twitter.com/idvoretskyi>Ihor Dvoretskyi</a>（CNCF）</p><p>2018 年北美 Kubernetes 贡献者峰会将在西雅图 <a href=https://events.linuxfoundation.org/events/kubecon-cloudnativecon-north-america-2018/>KubeCon + CloudNativeCon</a> 会议之前举办，这将是迄今为止规模最大的一次盛会。</p><p>这是一个将新老贡献者聚集在一起，面对面交流和分享的活动；并为现有的贡献者提供一个机会，帮助塑造社区发展的未来。它为新的社区成员提供了一个学习、探索和实践贡献工作流程的良好空间。</p><p>与之前的贡献者峰会不同，本次活动为期两天，有一个更为轻松的行程安排，一般贡献者将于 12 月 9 日（周日）下午 5 点至 8 点在距离会议中心仅几步远的 <a href=https://www.garagebilliards.com/>Garage Lounge and Gaming Hall</a> 举办峰会。在那里，贡献者也可以进行台球、保龄球等娱乐活动，而且还有各种食品和饮料。</p><p>接下来的一天，也就是 10 号星期一，有三个独立的会议你可以选择参与：</p><h3 id=新贡献者研讨会>新贡献者研讨会：</h3><p>为期半天的研讨会旨在让新贡献者加入社区，并营造一个良好的 Kubernetes 社区工作环境。
请在开会期间保持在场，该讨论会不允许随意进出。</p><h3 id=当前贡献者追踪>当前贡献者追踪：</h3><p>保留给那些积极参与项目开发的贡献者；目前的贡献者追踪包括讲座、研讨会、聚会、Unconferences 会议、指导委员会会议等等!
请留意 <a href=https://git.k8s.io/community/events/2018/12-contributor-summit#agenda>GitHub 中的时间表</a>，因为内容经常更新。</p><h3 id=docs-冲刺>Docs 冲刺：</h3><p>SIG-Docs 将在活动日期临近的时候列出一个需要处理的问题和挑战列表。</p><h2 id=注册>注册：</h2><p>要注册贡献者峰会，请参阅 Git Hub 上的<a href=https://git.k8s.io/community/events/2018/12-contributor-summit#registration>活动详情注册部分</a>。请注意报名正在审核中。
如果您选择了 “当前贡献者追踪”，而您却不是一个活跃的贡献者，您将被要求参加新贡献者研讨会，或者被要求进入候补名单。
成千上万的贡献者只有 300 个位置，我们需要确保正确的人被安排席位。</p><p>如果您有任何问题或疑虑，请随时通过 <a href=mailto:community@kubernetes.io>community@kubernetes.io</a> 联系贡献者峰会组织团队。</p><p>期待在那里看到每个人！</p></div><div class=td-content style=page-break-before:always><h1 id=pg-241e2cb43c3584096fd288edfdbbdebb>2018 年督导委员会选举结果</h1><div class="td-byline mb-4"><time datetime=2018-10-15 class=text-muted>2018.10.15</time></div><p><strong>作者</strong>: Jorge Castro (Heptio), Ihor Dvoretskyi (CNCF), Paris Pittman (Google)</p><h2 id=结果>结果</h2><p><a href=https://kubernetes.io/blog/2018/09/06/2018-steering-committee-election-cycle-kicks-off/>Kubernetes 督导委员会选举</a>现已完成，以下候选人获得了立即开始的两年任期：</p><ul><li>Aaron Crickenberger, Google, <a href=https://github.com/spiffxp>@spiffxp</a></li><li>Davanum Srinivas, Huawei, <a href=https://github.com/dims>@dims</a></li><li>Tim St. Clair, Heptio, <a href=https://github.com/timothysc>@timothysc</a></li></ul><h2 id=十分感谢>十分感谢！</h2><ul><li>督导委员会荣誉退休成员 <a href=https://github.com/quinton-hoole>Quinton Hoole</a>，表扬他在过去一年为社区所作的贡献。我们期待着</li><li>参加竞选的候选人。愿我们永远拥有一群强大的人，他们希望在每一次选举中都能像你们一样推动社区向前发展。</li><li>共计 307 名选民参与投票。</li><li>本次选举由康奈尔大学主办 <a href=https://civs.cs.cornell.edu/>CIVS</a>！</li></ul><h2 id=加入督导委员会>加入督导委员会</h2><p>你可以关注督导委员会的<a href=https://git.k8s.io/steering/backlog.md>任务清单</a>，并通过向他们的<a href=https://github.com/kubernetes/steering>代码仓库</a>提交 issue 或 PR 的方式来参与。他们也会在<a href=https://github.com/kubernetes/steering>UTC 时间每周三晚 8 点</a>举行会议，并定期与我们的贡献者见面。</p><p>督导委员会会议：</p><ul><li><a href="https://www.youtube.com/playlist?list=PL69nYSiGNLP1yP1B_nd9-drjoxp0Q14qM">YouTube 播放列表</a></li></ul><p>与我们的贡献者会面：</p><ul><li><a href=https://youtu.be/x6Jm8p0K-IQ>2018 年 10 月 3 日</a></li><li><a href=https://youtu.be/UbxWV12Or58>2018 年 7 月 5 日</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-f460d202f8a5ec9dfaefd832c33cfa7a>Kubernetes 中的拓扑感知数据卷供应</h1><div class="td-byline mb-4"><time datetime=2018-10-11 class=text-muted>2018.10.11</time></div><p><strong>作者</strong>: Michelle Au（谷歌）</p><p>通过提供拓扑感知动态卷供应功能，具有持久卷的多区域集群体验在 Kubernetes 1.12
中得到了改进。此功能使得 Kubernetes 在动态供应卷时能做出明智的决策，方法是从调度器获得为
Pod 提供数据卷的最佳位置。在多区域集群环境，这意味着数据卷能够在满足你的 Pod
运行需要的合适的区域被供应，从而允许你跨故障域轻松部署和扩展有状态工作负载，从而提供高可用性和容错能力。</p><h2 id=以前的挑战>以前的挑战</h2><p>在此功能被提供之前，在多区域集群中使用区域化的持久磁盘（例如 AWS ElasticBlockStore、
Azure Disk、GCE PersistentDisk）运行有状态工作负载存在许多挑战。动态供应独立于 Pod
调度处理，这意味着只要你创建了一个 PersistentVolumeClaim（PVC），一个卷就会被供应。
这也意味着供应者不知道哪些 Pod 正在使用该卷，也不清楚任何可能影响调度的 Pod 约束。</p><p>这导致了不可调度的 Pod，因为在以下区域中配置了卷：</p><ul><li>没有足够的 CPU 或内存资源来运行 Pod</li><li>与节点选择器、Pod 亲和或反亲和策略冲突</li><li>由于污点（taint）不能运行 Pod</li></ul><p>另一个常见问题是，使用多个持久卷的非有状态 Pod 可能会在不同的区域中配置每个卷，从而导致一个不可调度的 Pod。</p><p>次优的解决方法包括节点超配，或在正确的区域中手动创建卷，但这会造成难以动态部署和扩展有状态工作负载的问题。</p><p>拓扑感知动态供应功能解决了上述所有问题。</p><h2 id=支持的卷类型>支持的卷类型</h2><p>在 1.12 中，以下驱动程序支持拓扑感知动态供应：</p><ul><li>AWS EBS</li><li>Azure Disk</li><li>GCE PD（包括 Regional PD）</li><li>CSI（alpha） - 目前只有 GCE PD CSI 驱动实现了拓扑支持</li></ul><h2 id=设计原则>设计原则</h2><p>虽然最初支持的插件集都是基于区域的，但我们设计此功能时遵循 Kubernetes 跨环境可移植性的原则。
拓扑规范是通用的，并使用类似于基于标签的规范，如 Pod nodeSelectors 和 nodeAffinity。
该机制允许你定义自己的拓扑边界，例如内部部署集群中的机架，而无需修改调度程序以了解这些自定义拓扑。</p><p>此外，拓扑信息是从 Pod 规范中抽象出来的，因此 Pod 不需要了解底层存储系统的拓扑特征。
这意味着你可以在多个集群、环境和存储系统中使用相同的 Pod 规范。</p><h2 id=入门>入门</h2><p>要启用此功能，你需要做的就是创建一个将 <code>volumeBindingMode</code> 设置为 <code>WaitForFirstConsumer</code> 的 StorageClass：</p><pre tabindex=0><code>kind: StorageClass
apiVersion: storage.k8s.io/v1
metadata:
  name: topology-aware-standard
provisioner: kubernetes.io/gce-pd
volumeBindingMode: WaitForFirstConsumer
parameters:
  type: pd-standard
</code></pre><p>这个新设置表明卷配置器不立即创建卷，而是等待使用关联的 PVC 的 Pod 通过调度运行。
请注意，不再需要指定以前的 StorageClass <code>zone</code> 和 <code>zones</code> 参数，因为现在在哪个区域中配置卷由 Pod 策略决定。</p><p>接下来，使用此 StorageClass 创建一个 Pod 和 PVC。
此过程与之前相同，但在 PVC 中指定了不同的 StorageClass。
以下是一个假设示例，通过指定许多 Pod 约束和调度策略来演示新功能特性：</p><ul><li>一个 Pod 多个 PVC</li><li>跨子区域的节点亲和</li><li>同一区域 Pod 反亲和</li></ul><pre tabindex=0><code>apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: web
spec:   
  serviceName: &#34;nginx&#34;
  replicas: 2
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      affinity:
        nodeAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
            nodeSelectorTerms:
            - matchExpressions:
              - key: failure-domain.beta.kubernetes.io/zone
                operator: In
                values:
                - us-central1-a
                - us-central1-f
        podAntiAffinity:
          requiredDuringSchedulingIgnoredDuringExecution:
          - labelSelector:
              matchExpressions:
              - key: app
                operator: In
                values:
                - nginx
            topologyKey: failure-domain.beta.kubernetes.io/zone
      containers:
      - name: nginx
        image: gcr.io/google_containers/nginx-slim:0.8
        ports:
        - containerPort: 80
          name: web
        volumeMounts:
        - name: www
          mountPath: /usr/share/nginx/html
        - name: logs
          mountPath: /logs
 volumeClaimTemplates:
  - metadata:
      name: www
    spec:
      accessModes: [ &#34;ReadWriteOnce&#34; ]
      storageClassName: topology-aware-standard
      resources:
        requests:
          storage: 10Gi
  - metadata:
      name: logs
    spec:
      accessModes: [ &#34;ReadWriteOnce&#34; ]
      storageClassName: topology-aware-standard
      resources:
        requests:
          storage: 1Gi
</code></pre><p>之后，你可以看到根据 Pod 设置的策略在区域中配置卷：</p><pre tabindex=0><code>$ kubectl get pv -o=jsonpath=&#39;{range .items[*]}{.spec.claimRef.name}{&#34;\t&#34;}{.metadata.labels.failure\-domain\.beta\.kubernetes\.io/zone}{&#34;\n&#34;}{end}&#39;
www-web-0       us-central1-f
logs-web-0      us-central1-f
www-web-1       us-central1-a
logs-web-1      us-central1-a
</code></pre><h2 id=我怎样才能了解更多>我怎样才能了解更多？</h2><p>有关拓扑感知动态供应功能的官方文档可在此处获取：
<a href=https://kubernetes.io/docs/concepts/storage/storage-classes/#volume-binding-mode>https://kubernetes.io/docs/concepts/storage/storage-classes/#volume-binding-mode</a></p><p>有关 CSI 驱动程序的文档，请访问： <a href=https://kubernetes-csi.github.io/docs/>https://kubernetes-csi.github.io/docs/</a></p><h2 id=下一步是什么>下一步是什么？</h2><p>我们正积极致力于改进此功能以支持：</p><ul><li>更多卷类型，包括本地卷的动态供应</li><li>动态容量可附加计数和每个节点的容量限制</li></ul><h2 id=我如何参与>我如何参与？</h2><p>如果你对此功能有反馈意见或有兴趣参与设计和开发，请加入
<a href=https://github.com/kubernetes/community/tree/master/sig-storage>Kubernetes 存储特别兴趣小组</a>（SIG）。
我们正在快速成长，并始终欢迎新的贡献者。</p><p>特别感谢帮助推出此功能的所有贡献者，包括 Cheng Xing (<a href=https://github.com/verult>verult</a>)、
Chuqiang Li (<a href=https://github.com/lichuqiang>lichuqiang</a>)、David Zhu (<a href=https://github.com/davidz627>davidz627</a>)、
Deep Debroy (<a href=https://github.com/ddebroy>ddebroy</a>)、Jan Šafránek (<a href=https://github.com/jsafrane>jsafrane</a>)、
Jordan Liggitt (<a href=https://github.com/liggitt>liggitt</a>)、Michelle Au (<a href=https://github.com/msau42>msau42</a>)、
Pengfei Ni (<a href=https://github.com/feiskyer>feiskyer</a>)、Saad Ali (<a href=https://github.com/saad-ali>saad-ali</a>)、
Tim Hockin (<a href=https://github.com/thockin>thockin</a>)，以及 Yecheng Fu (<a href=https://github.com/cofyc>cofyc</a>)。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-744fea7e150e5cd9616530e5a9339c47>Kubernetes v1.12: RuntimeClass 简介</h1><div class="td-byline mb-4"><time datetime=2018-10-10 class=text-muted>2018.10.10</time></div><p><strong>作者</strong>: Tim Allclair (Google)</p><p>Kubernetes 最初是为了支持在 Linux 主机上运行本机应用程序的 Docker 容器而创建的。
从 Kubernetes 1.3 中的 <a href=https://kubernetes.io/blog/2016/07/rktnetes-brings-rkt-container-engine-to-kubernetes/>rkt</a> 开始，更多的运行时间开始涌现，
这导致了<a href=https://kubernetes.io/blog/2016/12/container-runtime-interface-cri-in-kubernetes/>容器运行时接口（Container Runtime Interface）</a>（CRI）的开发。
从那时起，备用运行时集合越来越大：
为了加强工作负载隔离，<a href=https://katacontainers.io/>Kata Containers</a> 和 <a href=https://github.com/google/gvisor>gVisor</a> 等项目被发起，
并且 Kubernetes 对 Windows 的支持正在<a href=https://kubernetes.io/blog/2018/01/kubernetes-v19-beta-windows-support/>稳步发展</a>。</p><p>由于存在诸多针对不同用例的运行时，集群对混合运行时的需求变得明晰起来。
但是，所有这些不同的容器运行方式都带来了一系列新问题要处理：</p><ul><li>用户如何知道哪些运行时可用，并为其工作负荷选择运行时？</li><li>我们如何确保将 Pod 被调度到支持所需运行时的节点上？</li><li>哪些运行时支持哪些功能，以及我们如何向用户显示不兼容性？</li><li>我们如何考虑运行时的各种资源开销？</li></ul><p><strong>RuntimeClass</strong> 旨在解决这些问题。</p><h2 id=kubernetes-1-12-中的-runtimeclass>Kubernetes 1.12 中的 RuntimeClass</h2><p>最近，RuntimeClass 在 Kubernetes 1.12 中作为 alpha 功能引入。
最初的实现侧重于提供运行时选择 API，并为解决其他未解决的问题铺平道路。</p><p>RuntimeClass 资源代表 Kubernetes 集群中支持的容器运行时。
集群制备组件安装、配置和定义支持 RuntimeClass 的具体运行时。
在 RuntimeClassSpec 的当前形式中，只有一个字段，即 <strong>RuntimeHandler</strong>。
RuntimeHandler 由在节点上运行的 CRI 实现解释，并映射到实际的运行时配置。
同时，PodSpec 被扩展添加了一个新字段 <strong>RuntimeClassName</strong>，命名应该用于运行 Pod 的 RuntimeClass。</p><p>为什么 RuntimeClass 是 Pod 级别的概念？
Kubernetes 资源模型期望 Pod 中的容器之间可以共享某些资源。
如果 Pod 由具有不同资源模型的不同容器组成，支持必要水平的资源共享变得非常具有挑战性。
例如，要跨 VM 边界支持本地回路（localhost）接口非常困难，但这是 Pod 中两个容器之间通信的通用模型。</p><h2 id=下一步是什么>下一步是什么？</h2><p>RuntimeClass 资源是将运行时属性显示到控制平面的重要基础。
例如，要对具有支持不同运行时间的异构节点的集群实施调度程序支持，我们可以在 RuntimeClass 定义中添加
<a href=/zh-cn/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity>NodeAffinity</a> 条件。
另一个需要解决的领域是管理可变资源需求以运行不同运行时的 Pod。
<a href=https://docs.google.com/document/d/1EJKT4gyl58-kzt2bnwkv08MIUZ6lkDpXcxkHqCvvAp4/preview>Pod Overhead 提案</a>是一项较早的尝试，与
RuntimeClass 设计非常吻合，并且可能会进一步推广。</p><p>人们还提出了许多其他 RuntimeClass 扩展，随着功能的不断发展和成熟，我们会重新讨论这些提议。
正在考虑的其他扩展包括：</p><ul><li>提供运行时支持的可选功能，并更好地查看由不兼容功能导致的错误。</li><li>自动运行时或功能发现，支持无需手动配置的调度决策。</li><li>标准化或一致的 RuntimeClass 名称，用于定义一组具有相同名称的 RuntimeClass 的集群应支持的属性。</li><li>动态注册附加的运行时，因此用户可以在不停机的情况下在现有集群上安装新的运行时。</li><li>根据 Pod 的要求“匹配” RuntimeClass。
例如，指定运行时属性并使系统与适当的 RuntimeClass 匹配，而不是通过名称显式分配 RuntimeClass。</li></ul><p>至少要到 2019 年，RuntimeClass 才会得到积极的开发，我们很高兴看到从 Kubernetes 1.12 中的 RuntimeClass alpha 开始，此功能得以形成。</p><h2 id=学到更多>学到更多</h2><ul><li>试试吧！作为 Alpha 功能，还有一些其他设置步骤可以使用 RuntimeClass。
有关如何使其运行，请参考 <a href=/zh-cn/docs/concepts/containers/runtime-class/#runtime-class>RuntimeClass 文档</a>。</li><li>查看 <a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-node/runtime-class.md>RuntimeClass Kubernetes 增强建议</a>以获取更多细节设计细节。</li><li><a href=https://docs.google.com/document/d/1fe7lQUjYKR0cijRmSbH_y0_l3CYPkwtQa5ViywuNo8Q/preview>沙盒隔离级别决策</a>记录了最初使
RuntimeClass 成为 Pod 级别选项的思考过程。</li><li>加入讨论，并通过 <a href=https://github.com/kubernetes/community/tree/master/sig-node>SIG-Node 社区</a>帮助塑造 RuntimeClass 的未来。</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-cfe43151cb19b506570e75c8f0a61259>KubeDirector：在 Kubernetes 上运行复杂状态应用程序的简单方法</h1><div class="td-byline mb-4"><time datetime=2018-10-03 class=text-muted>2018.10.03</time></div><p><strong>作者</strong>：Thomas Phelan（BlueData）</p><p>KubeDirector 是一个开源项目，旨在简化在 Kubernetes 上运行复杂的有状态扩展应用程序集群。KubeDirector 使用自定义资源定义（CRD）
框架构建，并利用了本地 Kubernetes API 扩展和设计哲学。这支持与 Kubernetes 用户/资源 管理以及现有客户端和工具的透明集成。</p><p>我们最近<a href=https://medium.com/@thomas_phelan/operation-stateful-introducing-bluek8s-and-kubernetes-director-aa204952f619/>介绍了 KubeDirector 项目</a>，作为我们称为 BlueK8s 的更广泛的 Kubernetes 开源项目的一部分。我很高兴地宣布 <a href=https://github.com/bluek8s/kubedirector/>KubeDirector</a> 的
pre-alpha 代码现在已经可用。在这篇博客文章中，我将展示它是如何工作的。</p><p>KubeDirector 提供以下功能：</p><ul><li>无需修改代码即可在 Kubernetes 上运行非云原生有状态应用程序。换句话说，不需要分解这些现有的应用程序来适应微服务设计模式。</li><li>本机支持保存特定于应用程序的配置和状态。</li><li>与应用程序无关的部署模式，最大限度地减少将新的有状态应用程序装载到 Kubernetes 的时间。</li></ul><p>KubeDirector 使熟悉数据密集型分布式应用程序（如 Hadoop、Spark、Cassandra、TensorFlow、Caffe2 等）的数据科学家能够在 Kubernetes 上运行这些应用程序 -- 只需极少的学习曲线，无需编写 GO 代码。由 KubeDirector 控制的应用程序由一些基本元数据和相关的配置工件包定义。应用程序元数据称为 KubeDirectorApp 资源。</p><p>要了解 KubeDirector 的组件，请使用类似于以下的命令在 <a href=https://github.com/bluek8s/kubedirector/>GitHub</a> 上克隆存储库：</p><pre tabindex=0><code>git clone http://&lt;userid&gt;@github.com/bluek8s/kubedirector.
</code></pre><p>Spark 2.2.1 应用程序的 KubeDirectorApp 定义位于文件 <code>kubedirector/deploy/example_catalog/cr-app-spark221e2.json</code> 中。</p><pre tabindex=0><code>~&gt; cat kubedirector/deploy/example_catalog/cr-app-spark221e2.json
{
   &#34;apiVersion&#34;: &#34;kubedirector.bluedata.io/v1alpha1&#34;,
   &#34;kind&#34;: &#34;KubeDirectorApp&#34;,
   &#34;metadata&#34;: {
       &#34;name&#34; : &#34;spark221e2&#34;
   },
   &#34;spec&#34; : {
       &#34;systemctlMounts&#34;: true,
       &#34;config&#34;: {
           &#34;node_services&#34;: [
               {
                   &#34;service_ids&#34;: [
                       &#34;ssh&#34;,
                       &#34;spark&#34;,
                       &#34;spark_master&#34;,
                       &#34;spark_worker&#34;
                   ],
…
</code></pre><p>应用程序集群的配置称为 KubeDirectorCluster 资源。示例 Spark 2.2.1 集群的 KubeDirectorCluster 定义位于文件
<code>kubedirector/deploy/example_clusters/cr-cluster-spark221.e1.yaml</code> 中。</p><pre tabindex=0><code>~&gt; cat kubedirector/deploy/example_clusters/cr-cluster-spark221.e1.yaml
apiVersion: &#34;kubedirector.bluedata.io/v1alpha1&#34;
kind: &#34;KubeDirectorCluster&#34;
metadata:
  name: &#34;spark221e2&#34;
spec:
  app: spark221e2
  roles:
  - name: controller
    replicas: 1
    resources:
      requests:
        memory: &#34;4Gi&#34;
        cpu: &#34;2&#34;
      limits:
        memory: &#34;4Gi&#34;
        cpu: &#34;2&#34;
  - name: worker
    replicas: 2
    resources:
      requests:
        memory: &#34;4Gi&#34;
        cpu: &#34;2&#34;
      limits:
        memory: &#34;4Gi&#34;
        cpu: &#34;2&#34;
  - name: jupyter
…
</code></pre><h2 id=使用-kubedirector-在-kubernetes-上运行-spark>使用 KubeDirector 在 Kubernetes 上运行 Spark</h2><p>使用 KubeDirector，可以轻松在 Kubernetes 上运行 Spark 集群。</p><p>首先，使用命令 <code>kubectl version</code> 验证 Kubernetes（版本 1.9 或更高）是否正在运行</p><pre tabindex=0><code>~&gt; kubectl version
Client Version: version.Info{Major:&#34;1&#34;, Minor:&#34;11&#34;, GitVersion:&#34;v1.11.3&#34;, GitCommit:&#34;a4529464e4629c21224b3d52edfe0ea91b072862&#34;, GitTreeState:&#34;clean&#34;, BuildDate:&#34;2018-09-09T18:02:47Z&#34;, GoVersion:&#34;go1.10.3&#34;, Compiler:&#34;gc&#34;, Platform:&#34;linux/amd64&#34;}
Server Version: version.Info{Major:&#34;1&#34;, Minor:&#34;11&#34;, GitVersion:&#34;v1.11.3&#34;, GitCommit:&#34;a4529464e4629c21224b3d52edfe0ea91b072862&#34;, GitTreeState:&#34;clean&#34;, BuildDate:&#34;2018-09-09T17:53:03Z&#34;, GoVersion:&#34;go1.10.3&#34;, Compiler:&#34;gc&#34;, Platform:&#34;linux/amd64&#34;}                                    
</code></pre><p>使用以下命令部署 KubeDirector 服务和示例 KubeDirectorApp 资源定义：</p><pre tabindex=0><code>cd kubedirector
make deploy
</code></pre><p>这些将启动 KubeDirector pod：</p><pre tabindex=0><code>~&gt; kubectl get pods
NAME                           READY     STATUS     RESTARTS     AGE
kubedirector-58cf59869-qd9hb   1/1       Running    0            1m     
</code></pre><p><code>kubectl get KubeDirectorApp</code> 列出中已安装的 KubeDirector 应用程序</p><pre tabindex=0><code>~&gt; kubectl get KubeDirectorApp
NAME           AGE
cassandra311   30m
spark211up     30m
spark221e2     30m
</code></pre><p>现在，您可以使用示例 KubeDirectorCluster 文件和 <code>kubectl create -f deploy/example_clusters/cr-cluster-spark211up.yaml</code> 命令
启动 Spark 2.2.1 集群。验证 Spark 集群已经启动:</p><pre tabindex=0><code>~&gt; kubectl get pods
NAME                             READY     STATUS    RESTARTS   AGE
kubedirector-58cf59869-djdwl     1/1       Running   0          19m
spark221e2-controller-zbg4d-0    1/1       Running   0          23m
spark221e2-jupyter-2km7q-0       1/1       Running   0          23m
spark221e2-worker-4gzbz-0        1/1       Running   0          23m
spark221e2-worker-4gzbz-1        1/1       Running   0          23m
</code></pre><p>现在运行的服务包括 Spark 服务：</p><pre tabindex=0><code>~&gt; kubectl get service
NAME                                TYPE         CLUSTER-IP        EXTERNAL-IP    PORT(S)                                                    AGE
kubedirector                        ClusterIP    10.98.234.194     &lt;none&gt;         60000/TCP                                                  1d
kubernetes                          ClusterIP    10.96.0.1         &lt;none&gt;         443/TCP                                                    1d
svc-spark221e2-5tg48                ClusterIP    None              &lt;none&gt;         8888/TCP                                                   21s
svc-spark221e2-controller-tq8d6-0   NodePort     10.104.181.123    &lt;none&gt;         22:30534/TCP,8080:31533/TCP,7077:32506/TCP,8081:32099/TCP  20s
svc-spark221e2-jupyter-6989v-0      NodePort     10.105.227.249    &lt;none&gt;         22:30632/TCP,8888:30355/TCP                                20s
svc-spark221e2-worker-d9892-0       NodePort     10.107.131.165    &lt;none&gt;         22:30358/TCP,8081:32144/TCP                                20s
svc-spark221e2-worker-d9892-1       NodePort     10.110.88.221     &lt;none&gt;         22:30294/TCP,8081:31436/TCP                                20s
</code></pre><p>将浏览器指向端口 31533 连接到 Spark 主节点 UI：</p><p><img src=/images/blog/2018-10-03-kubedirector/kubedirector.png alt=kubedirector></p><p>就是这样!
事实上，在上面的例子中，我们还部署了一个 Jupyter notebook 和 Spark 集群。</p><p>要启动另一个应用程序（例如 Cassandra），只需指定另一个 KubeDirectorApp 文件：</p><pre tabindex=0><code>kubectl create -f deploy/example_clusters/cr-cluster-cassandra311.yaml
</code></pre><p>查看正在运行的 Cassandra 集群：</p><pre tabindex=0><code>~&gt; kubectl get pods
NAME                              READY     STATUS    RESTARTS   AGE
cassandra311-seed-v24r6-0         1/1       Running   0          1m
cassandra311-seed-v24r6-1         1/1       Running   0          1m
cassandra311-worker-rqrhl-0       1/1       Running   0          1m
cassandra311-worker-rqrhl-1       1/1       Running   0          1m
kubedirector-58cf59869-djdwl      1/1       Running   0          1d
spark221e2-controller-tq8d6-0     1/1       Running   0          22m
spark221e2-jupyter-6989v-0        1/1       Running   0          22m
spark221e2-worker-d9892-0         1/1       Running   0          22m
spark221e2-worker-d9892-1         1/1       Running   0          22m
</code></pre><p>现在，您有一个 Spark 集群（带有 Jupyter notebook ）和一个运行在 Kubernetes 上的 Cassandra 集群。
使用 <code>kubectl get service</code> 查看服务集。</p><pre tabindex=0><code>~&gt; kubectl get service
NAME                                TYPE         CLUSTER-IP       EXTERNAL-IP   PORT(S)                                                   AGE
kubedirector                        ClusterIP    10.98.234.194    &lt;none&gt;        60000/TCP                                                 1d
kubernetes                          ClusterIP    10.96.0.1        &lt;none&gt;        443/TCP                                                   1d
svc-cassandra311-seed-v24r6-0       NodePort     10.96.94.204     &lt;none&gt;        22:31131/TCP,9042:30739/TCP                               3m
svc-cassandra311-seed-v24r6-1       NodePort     10.106.144.52    &lt;none&gt;        22:30373/TCP,9042:32662/TCP                               3m
svc-cassandra311-vhh29              ClusterIP    None             &lt;none&gt;        8888/TCP                                                  3m
svc-cassandra311-worker-rqrhl-0     NodePort     10.109.61.194    &lt;none&gt;        22:31832/TCP,9042:31962/TCP                               3m
svc-cassandra311-worker-rqrhl-1     NodePort     10.97.147.131    &lt;none&gt;        22:31454/TCP,9042:31170/TCP                               3m
svc-spark221e2-5tg48                ClusterIP    None             &lt;none&gt;        8888/TCP                                                  24m
svc-spark221e2-controller-tq8d6-0   NodePort     10.104.181.123   &lt;none&gt;        22:30534/TCP,8080:31533/TCP,7077:32506/TCP,8081:32099/TCP 24m
svc-spark221e2-jupyter-6989v-0      NodePort     10.105.227.249   &lt;none&gt;        22:30632/TCP,8888:30355/TCP                               24m
svc-spark221e2-worker-d9892-0       NodePort     10.107.131.165   &lt;none&gt;        22:30358/TCP,8081:32144/TCP                               24m
svc-spark221e2-worker-d9892-1       NodePort     10.110.88.221    &lt;none&gt;        22:30294/TCP,8081:31436/TCP                               24m
</code></pre><h2 id=参与其中>参与其中</h2><p>KubeDirector 是一个完全开放源码的 Apache v2 授权项目 – 在我们称为 BlueK8s 的更广泛的计划中，它是多个开放源码项目中的第一个。
KubeDirector 的 pre-alpha 代码刚刚发布，我们希望您加入到不断增长的开发人员、贡献者和使用者社区。
在 Twitter 上关注 <a href=https://twitter.com/BlueK8s/>@BlueK8s</a>，并通过以下渠道参与:</p><ul><li>KubeDirector <a href=https://join.slack.com/t/bluek8s/shared_invite/enQtNDUwMzkwODY5OTM4LTRhYmRmZmE4YzY3OGUzMjA1NDg0MDVhNDQ2MGNkYjRhM2RlMDNjMTI1NDQyMjAzZGVlMDFkNThkNGFjZGZjMGY/>Slack 聊天室</a></li><li>KubeDirector <a href=https://github.com/bluek8s/kubedirector/>GitHub 仓库</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-e38db7f640df9065a21c341cfbe4705c>在 Kubernetes 上对 gRPC 服务器进行健康检查</h1><div class="td-byline mb-4"><time datetime=2018-10-01 class=text-muted>2018.10.01</time></div><p><strong>作者</strong>： <a href=https://twitter.com/ahmetb>Ahmet Alp Balkan</a> (Google)</p><p><strong>更新（2021 年 12 月）：</strong> “Kubernetes 从 v1.23 开始具有内置 gRPC 健康探测。
了解更多信息，请参阅<a href=/zh-cn/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#define-a-grpc-liveness-probe>配置存活探针、就绪探针和启动探针</a>。
本文最初是为有关实现相同任务的外部工具所写。”</p><p><a href=https://grpc.io>gRPC</a> 将成为本地云微服务间进行通信的通用语言。如果您现在将 gRPC 应用程序部署到 Kubernetes，您可能会想要了解配置健康检查的最佳方法。在本文中，我们将介绍 <a href=https://github.com/grpc-ecosystem/grpc-health-probe/>grpc-health-probe</a>，这是 Kubernetes 原生的健康检查 gRPC 应用程序的方法。</p><p>如果您不熟悉，Kubernetes的 <a href=/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/>健康检查</a>（存活探针和就绪探针）可以使您的应用程序在睡眠时保持可用状态。当检测到没有回应的 Pod 时，会将其标记为不健康，并使这些 Pod 重新启动或重新安排。</p><p>Kubernetes 原本 <a href=https://github.com/kubernetes/kubernetes/issues/21493>不支持</a> gRPC 健康检查。gRPC 的开发人员在 Kubernetes 中部署时可以采用以下三种方法：</p><p><a href=/images/blog/2019-09-30-health-checking-grpc/options.png><img src=/images/blog/2019-09-30-health-checking-grpc/options.png alt="当前在 kubernetes 上进行 gRPC 健康检查的选项"></a></p><ol><li><strong>httpGet prob：</strong> 不能与 gRPC 一起使用。您需要重构您的应用程序，必须同时支持 gRPC 和 HTTP/1.1 协议（在不同的端口号上）。</li><li><strong>tcpSocket probe：</strong> 打开 gRPC 服务器的 Socket 是没有意义的，因为它无法读取响应主体。</li><li><strong>exec probe：</strong> 将定期调用容器生态系统中的程序。对于 gRPC，这意味着您要自己实现健康 RPC，然后使用容器编写并交付客户端工具。</li></ol><p>我们可以做得更好吗？这是肯定的。</p><h2 id=介绍-grpc-health-probe>介绍 “grpc-health-probe”</h2><p>为了使上述 "exec probe" 方法标准化，我们需要：</p><ul><li>可以在任何 gRPC 服务器中轻松实现的 <strong>标准</strong> 健康检查 "协议" 。</li><li>一种 <strong>标准</strong> 健康检查 "工具" ，可以轻松查询健康协议。</li></ul><p>幸运的是，gRPC 具有 <a href=https://github.com/grpc/grpc/blob/v1.15.0/doc/health-checking.md>标准的健康检查协议</a>。可以用任何语言轻松调用它。几乎所有实现 gRPC 的语言都附带了生成的代码和用于设置健康状态的实用程序。</p><p>如果您在 gRPC 应用程序中 <a href=https://github.com/grpc/grpc/blob/v1.15.0/src/proto/grpc/health/v1/health.proto>实现</a> 此健康检查协议，那么可以使用标准或通用工具调用 <code>Check()</code> 方法来确定服务器状态。</p><p>接下来您需要的是 "标准工具" <a href=https://github.com/grpc-ecosystem/grpc-health-probe/><strong>grpc-health-probe</strong></a>。</p><a href=/images/blog/2019-09-30-health-checking-grpc/grpc_health_probe.png><img width=768 title='grpc-health-probe on kubernetes' src=/images/blog/2019-09-30-health-checking-grpc/grpc_health_probe.png></a><p>使用此工具，您可以在所有 gRPC 应用程序中使用相同的健康检查配置。这种方法有以下要求：</p><ol><li>用您喜欢的语言找到 gRPC 的 "健康" 模块并开始使用它（例如 <a href=https://godoc.org/github.com/grpc/grpc-go/health>Go 库</a>）。</li><li>将二进制文件 <a href=https://github.com/grpc-ecosystem/grpc-health-probe/>grpc_health_probe</a> 送到容器中。</li><li><a href=https://github.com/grpc-ecosystem/grpc-health-probe/tree/1329d682b4232c102600b5e7886df8ffdcaf9e26#example-grpc-health-checking-on-kubernetes>配置</a> Kubernetes 的 "exec" 检查模块来调用容器中的 "grpc_health_probe" 工具。</li></ol><p>在这种情况下，执行 "grpc_health_probe" 将通过 <code>localhost</code> 调用您的 gRPC 服务器，因为它们位于同一个容器中。</p><h2 id=下一步工作>下一步工作</h2><p><strong>grpc-health-probe</strong> 项目仍处于初期阶段，需要您的反馈。它支持多种功能，例如与 TLS 服务器通信和配置延时连接/RPC。</p><p>如果您最近要在 Kubernetes 上运行 gRPC 服务器，请尝试使用 gRPC Health Protocol，并在您的 Deployment 中尝试 grpc-health-probe，然后 <a href=https://github.com/grpc-ecosystem/grpc-health-probe/>进行反馈</a>。</p><h2 id=更多内容>更多内容</h2><ul><li>协议： <a href=https://github.com/grpc/grpc/blob/v1.15.0/doc/health-checking.md>GRPC Health Checking Protocol</a> (<a href=https://github.com/grpc/grpc/blob/v1.15.0/src/proto/grpc/health/v1/health.proto>health.proto</a>)</li><li>文档： <a href=/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/>Kubernetes 存活和就绪探针</a></li><li>文章： <a href=https://ahmet.im/blog/advanced-kubernetes-health-checks/>升级版 Kubernetes 健康检查模式</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-5cd188187bd5cac97e56eebd5891dd04>使用 CSI 和 Kubernetes 实现卷的动态扩容</h1><div class="td-byline mb-4"><time datetime=2018-08-02 class=text-muted>2018.08.02</time></div><p><strong>作者</strong>：Orain Xiong（联合创始人, WoquTech）</p><p><em>Kubernetes 本身有一个非常强大的存储子系统，涵盖了相当广泛的用例。而当我们计划使用 Kubernetes 构建产品级关系型数据库平台时，我们面临一个巨大的挑战：提供存储。本文介绍了如何扩展最新的 Container Storage Interface 0.2.0 和与 Kubernetes 集成，并演示了卷动态扩容的基本方面。</em></p><h2 id=介绍>介绍</h2><p>当我们专注于客户时，尤其是在金融领域，采用容器编排技术的情况大大增加。</p><p>他们期待着能用开源解决方案重新设计已经存在的整体应用程序，这些应用程序已经在虚拟化基础架构或裸机上运行了几年。</p><p>考虑到可扩展性和技术成熟程度，Kubernetes 和 Docker 排在我们选择列表的首位。但是将整体应用程序迁移到类似于 Kubernetes 之类的分布式容器编排平台上很具有挑战性，其中关系数据库对于迁移来说至关重要。</p><p>关于关系数据库，我们应该注意存储。Kubernetes 本身内部有一个非常强大的存储子系统。它非常有用，涵盖了相当广泛的用例。当我们计划在生产环境中使用 Kubernetes 运行关系型数据库时，我们面临一个巨大挑战：提供存储。目前，仍有一些基本功能尚未实现。特别是，卷的动态扩容。这听起来很无聊，但在除创建，删除，安装和卸载之类的操作外，它是非常必要的。</p><p>目前，扩展卷仅适用于这些存储供应商：</p><ul><li>gcePersistentDisk</li><li>awsElasticBlockStore</li><li>OpenStack Cinder</li><li>glusterfs</li><li>rbd</li></ul><p>为了启用此功能，我们应该将特性开关 <code>ExpandPersistentVolumes</code> 设置为 true 并打开 <code>PersistentVolumeClaimResize</code> 准入插件。 一旦启用了 <code>PersistentVolumeClaimResize</code>，则其对应的 <code>allowVolumeExpansion</code> 字段设置为 true 的存储类将允许调整大小。</p><p>不幸的是，即使基础存储提供者具有此功能，也无法通过容器存储接口（CSI）和 Kubernetes 动态扩展卷。</p><p>本文将给出 CSI 的简化视图，然后逐步介绍如何在现有 CSI 和 Kubernetes 上引入新的扩展卷功能。最后，本文将演示如何动态扩展卷容量。</p><h2 id=容器存储接口-csi>容器存储接口（CSI）</h2><p>为了更好地了解我们将要做什么，我们首先需要知道什么是容器存储接口。当前，Kubernetes 中已经存在的存储子系统仍然存在一些问题。 存储驱动程序代码在 Kubernetes 核心存储库中维护，这很难测试。 但是除此之外，Kubernetes 还需要授予存储供应商许可，以将代码签入 Kubernetes 核心存储库。 理想情况下，这些应在外部实施。</p><p>CSI 旨在定义行业标准，该标准将使支持 CSI 的存储提供商能够在支持 CSI 的容器编排系统中使用。</p><p>该图描述了一种与 CSI 集成的高级 Kubernetes 原型：</p><p><img src=/images/blog/2018-08-02-dynamically-expand-volume-csi/csi-diagram.png alt="csi diagram"></p><ul><li>引入了三个新的外部组件以解耦 Kubernetes 和存储提供程序逻辑</li><li>蓝色箭头表示针对 API 服务器进行调用的常规方法</li><li>红色箭头显示 gRPC 以针对 Volume Driver 进行调用</li></ul><p>更多详细信息，请访问： <a href=https://github.com/container-storage-interface/spec/blob/master/spec.md>https://github.com/container-storage-interface/spec/blob/master/spec.md</a></p><h2 id=扩展-csi-和-kubernetes>扩展 CSI 和 Kubernetes</h2><p>为了实现在 Kubernetes 上扩展卷的功能，我们应该扩展几个组件，包括 CSI 规范，“in-tree” 卷插件，external-provisioner 和 external-attacher。</p><h2 id=扩展csi规范>扩展CSI规范</h2><p>最新的 CSI 0.2.0 仍未定义扩展卷的功能。应该引入新的3个 RPC，包括 <code>RequiresFSResize</code>， <code>ControllerResizeVolume</code> 和 <code>NodeResizeVolume</code>。</p><pre tabindex=0><code>service Controller {
 rpc CreateVolume (CreateVolumeRequest)
   returns (CreateVolumeResponse) {}
……
 rpc RequiresFSResize (RequiresFSResizeRequest)
   returns (RequiresFSResizeResponse) {}
 rpc ControllerResizeVolume (ControllerResizeVolumeRequest)
   returns (ControllerResizeVolumeResponse) {}
}

service Node {
 rpc NodeStageVolume (NodeStageVolumeRequest)
   returns (NodeStageVolumeResponse) {}
……
 rpc NodeResizeVolume (NodeResizeVolumeRequest)
   returns (NodeResizeVolumeResponse) {}
}
</code></pre><h2 id=扩展-in-tree-卷插件>扩展 “In-Tree” 卷插件</h2><p>除了扩展的 CSI 规范之外，Kubernetes 中的 <code>csiPlugin</code> 接口还应该实现 <code>expandablePlugin</code>。<code>csiPlugin</code> 接口将扩展代表 <code>ExpanderController</code> 的 <code>PersistentVolumeClaim</code>。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a2f;font-weight:700>type</span> ExpandableVolumePlugin <span style=color:#a2f;font-weight:700>interface</span> {
</span></span><span style=display:flex><span>VolumePlugin
</span></span><span style=display:flex><span><span style=color:#00a000>ExpandVolumeDevice</span>(spec Spec, newSize resource.Quantity, oldSize resource.Quantity) (resource.Quantity, <span style=color:#0b0;font-weight:700>error</span>)
</span></span><span style=display:flex><span><span style=color:#00a000>RequiresFSResize</span>() <span style=color:#0b0;font-weight:700>bool</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=实现卷驱动程序>实现卷驱动程序</h3><p>最后，为了抽象化实现的复杂性，我们应该将单独的存储提供程序管理逻辑硬编码为以下功能，这些功能在 CSI 规范中已明确定义：</p><ul><li>CreateVolume</li><li>DeleteVolume</li><li>ControllerPublishVolume</li><li>ControllerUnpublishVolume</li><li>ValidateVolumeCapabilities</li><li>ListVolumes</li><li>GetCapacity</li><li>ControllerGetCapabilities</li><li>RequiresFSResize</li><li>ControllerResizeVolume</li></ul><h2 id=展示>展示</h2><p>让我们以具体的用户案例来演示此功能。</p><ul><li>为 CSI 存储供应商创建存储类</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>allowVolumeExpansion</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>csi-qcfs<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>csiProvisionerSecretName</span>:<span style=color:#bbb> </span>orain-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>csiProvisionerSecretNamespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>csi-qcfsplugin<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>reclaimPolicy</span>:<span style=color:#bbb> </span>Delete<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>volumeBindingMode</span>:<span style=color:#bbb> </span>Immediate<span style=color:#bbb>
</span></span></span></code></pre></div><ul><li><p>在 Kubernetes 集群上部署包括存储供应商 <code>csi-qcfsplugin</code> 在内的 CSI 卷驱动</p></li><li><p>创建 PVC <code>qcfs-pvc</code>，它将由存储类 <code>csi-qcfs</code> 动态配置</p></li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qcfs-pvc<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span>.<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- ReadWriteOnce<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>300Gi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>csi-qcfs<span style=color:#bbb>
</span></span></span></code></pre></div><ul><li>创建 MySQL 5.7 实例以使用 PVC <code>qcfs-pvc</code></li><li>为了反映完全相同的生产级别方案，实际上有两种不同类型的工作负载，包括：
     * 批量插入使 MySQL 消耗更多的文件系统容量
     * 浪涌查询请求</li><li>通过编辑 pvc <code>qcfs-pvc</code> 配置动态扩展卷容量</li></ul><p>Prometheus 和 Grafana 的集成使我们可以可视化相应的关键指标。</p><p><img src=/images/blog/2018-08-02-dynamically-expand-volume-csi/prometheus-grafana.png alt="prometheus grafana"></p><p>我们注意到中间的读数显示在批量插入期间 MySQL 数据文件的大小缓慢增加。 同时，底部读数显示文件系统在大约20分钟内扩展了两次，从 300 GiB 扩展到 400 GiB，然后扩展到 500 GiB。 同时，上半部分显示，扩展卷的整个过程立即完成，几乎不会影响 MySQL QPS。</p><h2 id=结论>结论</h2><p>不管运行什么基础结构应用程序，数据库始终是关键资源。拥有更高级的存储子系统以完全支持数据库需求至关重要。这将有助于推动云原生技术的更广泛采用。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-4ce1d602e0512565b4d1b6e9a57367e1>使用 Kubernetes 调整 PersistentVolume 的大小</h1><div class="td-byline mb-4"><time datetime=2018-07-12 class=text-muted>2018.07.12</time></div><p><strong>作者</strong>: Hemant Kumar (Red Hat)</p><p><strong>编者注：这篇博客是<a href=https://kubernetes.io/blog/2018/06/27/kubernetes-1.11-release-announcement/>深度文章系列</a>的一部分，这个系列介绍了 Kubernetes 1.11 中的新增特性</strong></p><p>在 Kubernetes v1.11 中，持久化卷扩展功能升级为 Beta。
该功能允许用户通过编辑 <code>PersistentVolumeClaim</code>（PVC）对象，轻松调整已存在数据卷的大小。
用户不再需要手动与存储后端交互，或者删除再重建 PV 和 PVC 对象来增加卷的大小。缩减持久化卷暂不支持。</p><p>卷扩展是在 v1.8 版本中作为 Alpha 功能引入的，
在 v1.11 之前的版本都需要开启特性门控 <code>ExpandPersistentVolumes</code> 以及准入控制器 <code>PersistentVolumeClaimResize</code>（防止扩展底层存储供应商不支持调整大小的 PVC）。
在 Kubernetes v1.11+ 中，特性门控和准入控制器都是默认启用的。</p><p>虽然该功能默认是启用的，但集群管理员必须选择允许用户调整数据卷的大小。
Kubernetes v1.11 为以下树内卷插件提供了卷扩展支持：
AWS-EBS、GCE-PD、Azure Disk、Azure File、Glusterfs、Cinder、Portworx 和 Ceph RBD。
一旦管理员确定底层供应商支持卷扩展，
就可以通过在 <code>StorageClass</code> 对象中设置 <code>allowVolumeExpansion</code> 字段为 <code>true</code>，让用户可以使用该功能。
只有由这个 <code>StorageClass</code> 创建的 PVC 才能触发卷扩展。</p><pre tabindex=0><code>~&gt; cat standard.yaml
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: standard
parameters:
  type: pd-standard
provisioner: kubernetes.io/gce-pd
allowVolumeExpansion: true
reclaimPolicy: Delete
</code></pre><p>从这个 <code>StorageClass</code> 创建的任何 PVC 都可以被编辑（如下图所示）以请求更多的空间。
Kubernetes 会将存储字段的变化解释为对更多空间的请求，并触发卷大小的自动调整。</p><p><img src=/images/blog/2018-07-12-resizing-persistent-volumes-using-kubernetes/pvc-storageclass.png alt="PVC StorageClass"></p><h2 id=file-system-expansion>文件系统扩展</h2><p>如 GCE-PD、AWS-EBS、Azure Disk、Cinder 和 Ceph RBD 这类的块存储卷类型，
通常需要在扩展卷的额外空间被 Pod 使用之前进行文件系统扩展。
Kubernetes 会在引用数据卷的 Pod 重新启动时自动处理这个问题。</p><p>网络附加文件系统（如 Glusterfs 和 Azure File）可以被扩展，而不需要重新启动引用的 Pod，
因为这些系统不需要特殊的文件系统扩展。</p><p>文件系统扩展必须通过终止使用该卷的 Pod 来触发。更具体地说：</p><ul><li>编辑 PVC 以请求更多的空间。</li><li>一旦底层卷被存储提供商扩展后， PersistentVolume 对象将反映更新的大小，PVC 会有 <code>FileSystemResizePending</code> 状态。</li></ul><p>你可以通过运行 <code>kubectl get pvc &lt;pvc_name> -o yaml</code> 来验证这一点。</p><pre tabindex=0><code>~&gt; kubectl get pvc myclaim -o yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: myclaim
  namespace: default
  uid: 02d4aa83-83cd-11e8-909d-42010af00004
spec:
  accessModes:
  - ReadWriteOnce
  resources:
    requests:
      storage: 14Gi
  storageClassName: standard
  volumeName: pvc-xxx
status:
  capacity:
    storage: 9G
  conditions:
  - lastProbeTime: null
    lastTransitionTime: 2018-07-11T14:51:10Z
    message: Waiting for user to (re-)start a pod to finish file system resize of
      volume on node.
    status: &#34;True&#34;
    type: FileSystemResizePending
  phase: Bound
</code></pre><ul><li>一旦 PVC 具有 <code>FileSystemResizePending</code> 状态 ，就可以重启使用该 PVC 的 Pod 以完成节点上的文件系统大小调整。
重新启动可以通过删除并重新创建 Pod，或者通过 Deployment 缩容后再扩容来实现。</li><li>一旦文件系统的大小调整完成，PVC 将自动更新以展现新的大小。</li></ul><p>在扩展文件系统时遇到的任何错误都应作为 Pod 的事件而存在。</p><h2 id=online-file-system-expansion>在线文件系统扩展</h2><p>Kubernetes v1.11 里还引入了一个名为在线文件系统扩展的 Alpha 功能。
该功能可以让一个正在被 Pod 使用的卷进行文件系统扩展。
因为这个功能是 Alpha 阶段，所以它需要启用特性门控 <code>ExpandInUsePersistentVolumes</code>。
树内卷插件 GCE-PD、AWS-EBS、Cinder 和 Ceph RBD 都支持该功能。
当这个功能被启用时，引用调整后的卷的 Pod 不需要被重新启动。
相反，在使用中文件系统将作为卷扩展的一部分自动调整大小。
文件系统的扩展是在一个 Pod 引用调整后的卷时才发生的，所以如果没有引用卷的 Pod 在运行，文件系统的扩展就不会发生。</p><h2 id=how-can-i-learn-more>更多信息</h2><p>在这里查看有关这一特性的其他文档：
<a href=https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/>https://kubernetes.io/zh-cn/docs/concepts/storage/persistent-volumes/</a></p></div><div class=td-content style=page-break-before:always><h1 id=pg-37f9b93223232a11f579d220e199b9d1>动态 Kubelet 配置</h1><div class="td-byline mb-4"><time datetime=2018-07-11 class=text-muted>2018.07.11</time></div><p><strong>作者</strong>: Michael Taufen (Google)</p><p><strong>编者注：在 1.22 版本弃用后，该功能已在 1.24 版本中删除。</strong></p><p><strong>编者注：这篇文章是<a href=https://kubernetes.io/blog/2018/06/27/kubernetes-1.11-release-announcement/>一系列深度文章</a> 的一部分，这个系列介绍了 Kubernetes 1.11 中的新增功能</strong></p><h2 id=为什么要进行动态-kubelet-配置>为什么要进行动态 Kubelet 配置？</h2><p>Kubernetes 提供了以 API 为中心的工具，可显着改善用于管理应用程序和基础架构的工作流程。
但是，在大多数的 Kubernetes 安装中，kubelet 在每个主机上作为本机进程运行，因此
未被标准 Kubernetes API 覆盖。</p><p>过去，这意味着集群管理员和服务提供商无法依靠 Kubernetes API 在活动集群中重新配置 Kubelets。
实际上，这要求操作员要 SSH 登录到计算机以执行手动重新配置，要么使用第三方配置管理自动化工具，
或创建已经安装了所需配置的新 VM，然后将工作迁移到新计算机上。
这些方法是特定于环境的，并且可能很耗时费力。</p><p>动态 Kubelet 配置使集群管理员和服务提供商能够通过 Kubernetes API 在活动集群中重新配置 Kubelet。</p><h2 id=什么是动态-kubelet-配置>什么是动态 Kubelet 配置？</h2><p>Kubernetes v1.10 使得可以通过 Beta 版本的<a href=/zh-cn/docs/tasks/administer-cluster/kubelet-config-file/>配置文件</a>
API 配置 kubelet。
Kubernetes 已经提供了用于在 API 服务器中存储任意文件数据的 ConfigMap 抽象。</p><p>动态 Kubelet 配置扩展了 Node 对象，以便 Node 可以引用包含相同类型配置文件的 ConfigMap。
当节点更新为引用新的 ConfigMap 时，关联的 Kubelet 将尝试使用新的配置。</p><h2 id=它是如何工作的>它是如何工作的？</h2><p>动态 Kubelet 配置提供以下核心功能：</p><ul><li>Kubelet 尝试使用动态分配的配置。</li><li>Kubelet 将其配置已检查点的形式保存到本地磁盘，无需 API 服务器访问即可重新启动。</li><li>Kubelet 在 Node 状态中报告已指定的、活跃的和最近已知良好的配置源。</li><li>当动态分配了无效的配置时，Kubelet 会自动退回到最后一次正确的配置，并在 Node 状态中报告错误。</li></ul><p>要使用动态 Kubelet 配置功能，集群管理员或服务提供商将首先发布包含所需配置的 ConfigMap，
然后设置每个 Node.Spec.ConfigSource.ConfigMap 引用以指向新的 ConfigMap。
运营商可以以他们喜欢的速率更新这些参考，从而使他们能够执行新配置的受控部署。</p><p>每个 Kubelet 都会监视其关联的 Node 对象的更改。
更新 Node.Spec.ConfigSource.ConfigMap 引用后，
Kubelet 将通过将其包含的文件通过检查点机制写入本地磁盘保存新的 ConfigMap。
然后，Kubelet 将退出，而操作系统级进程管理器将重新启动它。
请注意，如果未设置 Node.Spec.ConfigSource.ConfigMap 引用，
则 Kubelet 将使用其正在运行的计算机本地的一组标志和配置文件。</p><p>重新启动后，Kubelet 将尝试使用来自新检查点的配置。
如果新配置通过了 Kubelet 的内部验证，则 Kubelet 将更新
Node.Status.Config 用以反映它正在使用新配置。
如果新配置无效，则 Kubelet 将退回到其最后一个正确的配置，并在 Node.Status.Config 中报告错误。</p><p>请注意，默认的最后一次正确配置是 Kubelet 命令行标志与 Kubelet 的本地配置文件的组合。
与配置文件重叠的命令行标志始终优先于本地配置文件和动态配置，以实现向后兼容。</p><p>有关单个节点的配置更新的高级概述，请参见下图：</p><p><img src=/images/blog/2018-07-11-dynamic-kubelet-configuration/kubelet-diagram.png alt=kubelet-diagram></p><h2 id=我如何了解更多>我如何了解更多？</h2><p>请参阅/docs/tasks/administer-cluster/reconfigure-kubelet/上的官方教程，
其中包含有关用户工作流，某配置如何成为“最新的正确的”配置，Kubelet 如何对配置执行“检查点”操作等，
更多详细信息，以及可能的故障模式。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-4d1b8243b08fd75f7c6f7a1ee1b31e1c>用于 Kubernetes 集群 DNS 的 CoreDNS GA 正式发布</h1><div class="td-byline mb-4"><time datetime=2018-07-10 class=text-muted>2018.07.10</time></div><p><strong>作者</strong>：John Belamaric (Infoblox)</p><p>**编者注：这篇文章是 <a href=https://kubernetes.io/blog/2018/06/27/kubernetes-1.11-release-announcement/>系列深度文章</a> 中的一篇，介绍了 Kubernetes 1.11 新增的功能</p><h2 id=介绍>介绍</h2><p>在 Kubernetes 1.11 中，<a href=https://coredns.io>CoreDNS</a> 已经达到基于 DNS 服务发现的 General Availability (GA)，可以替代 kube-dns 插件。这意味着 CoreDNS 会作为即将发布的安装工具的选项之一上线。实际上，从 Kubernetes 1.11 开始，kubeadm 团队选择将它设为默认选项。</p><p>很久以来， kube-dns 集群插件一直是 Kubernetes 的一部分，用来实现基于 DNS 的服务发现。
通常，此插件运行平稳，但对于实现的可靠性、灵活性和安全性仍存在一些疑虑。</p><p>CoreDNS 是通用的、权威的 DNS 服务器，提供与 Kubernetes 向后兼容但可扩展的集成。它解决了 kube-dns 遇到的问题，并提供了许多独特的功能，可以解决各种用例。</p><p>在本文中，您将了解 kube-dns 和 CoreDNS 的实现有何差异，以及 CoreDNS 提供的一些非常有用的扩展。</p><h2 id=实现差异>实现差异</h2><p>在 kube-dns 中，一个 Pod 中使用多个 容器：<code>kubedns</code>、<code>dnsmasq</code>、和 <code>sidecar</code>。<code>kubedns</code> 容器监视 Kubernetes API 并根据 <a href=https://github.com/kubernetes/dns/blob/master/docs/specification.md>Kubernetes DNS 规范</a> 提供 DNS 记录，<code>dnsmasq</code> 提供缓存和存根域支持，<code>sidecar</code> 提供指标和健康检查。</p><p>随着时间的推移，此设置会导致一些问题。一方面，以往 <code>dnsmasq</code> 中的安全漏洞需要通过发布 Kubernetes 的安全补丁来解决。但是，由于 <code>dnsmasq</code> 处理存根域，而 <code>kubedns</code> 处理外部服务，因此您不能在外部服务中使用存根域，导致这个功能具有局限性（请参阅 <a href=https://github.com/kubernetes/dns/issues/131>dns#131</a>）。</p><p>在 CoreDNS 中，所有这些功能都是在一个容器中完成的，该容器运行用 Go 编写的进程。所启用的不同插件可复制（并增强）在 kube-dns 中存在的功能。</p><h2 id=配置-coredns>配置 CoreDNS</h2><p>在 kube-dns 中，您可以 <a href=https://kubernetes.io/blog/2017/04/configuring-private-dns-zones-upstream-nameservers-kubernetes/>修改 ConfigMap</a> 来更改服务发现的行为。用户可以添加诸如为存根域提供服务、修改上游名称服务器以及启用联盟之类的功能。</p><p>在 CoreDNS 中，您可以类似地修改 CoreDNS <a href=https://coredns.io/2017/07/23/corefile-explained/>Corefile</a> 的 ConfigMap，以更改服务发现的工作方式。这种 Corefile 配置提供了比 kube-dns 中更多的选项，因为它是 CoreDNS 用于配置所有功能的主要配置文件，即使与 Kubernetes 不相关的功能也可以操作。</p><p>使用 <code>kubeadm</code> 将 kube-dns 升级到 CoreDNS 时，现有的 ConfigMap 将被用来为您生成自定义的 Corefile，包括存根域、联盟和上游名称服务器的所有配置。更多详细信息，请参见
<a href=/zh-cn/docs/tasks/administer-cluster/coredns/>使用 CoreDNS 进行服务发现</a>。</p><h2 id=错误修复和增强>错误修复和增强</h2><p>在 CoreDNS 中解决了 kube-dn 的多个未解决问题，无论是默认配置还是某些自定义配置。</p><ul><li><p><a href=https://github.com/kubernetes/dns/issues/55>dns#55 - kube-dns 的自定义 DNS 条目</a> 可以使用 <a href=https://coredns.io/plugins/kubernetes>kubernetes 插件</a> 中的 "fallthrough" 机制，使用 <a href=https://coredns.io/plugins/rewrite>rewrite 插件</a>，或者分区使用不同的插件，例如 <a href=https://coredns.io/plugins/file>file 插件</a>。</p></li><li><p><a href=https://github.com/kubernetes/dns/issues/116>dns#116 - 对具有相同主机名的、提供无头服务服务的 Pod 仅设置了一个 A 记录</a>。无需任何其他配置即可解决此问题。</p></li><li><p><a href=https://github.com/kubernetes/dns/issues/131>dns#131 - externalName 未使用 stubDomains 设置</a>。无需任何其他配置即可解决此问题。</p></li><li><p><a href=https://github.com/kubernetes/dns/issues/167>dns#167 - 允许 skyDNS 为 A/AAAA 记录提供轮换</a>。可以使用 <a href=https://coredns.io/plugins/loadbalance>负载均衡插件</a> 配置等效功能。</p></li><li><p><a href=https://github.com/kubernetes/dns/issues/190>dns#190 - kube-dns 无法以非 root 用户身份运行</a>。今天，通过使用 non-default 镜像解决了此问题，但是在将来的版本中，它将成为默认的 CoreDNS 行为。</p></li><li><p><a href=https://github.com/kubernetes/dns/issues/232>dns#232 - 在 dns srv 记录中修复 pod hostname 为 podname</a> 是通过下面提到的 "endpoint_pod_names" 功能进行支持的增强功能。</p></li></ul><h2 id=指标>指标</h2><p>CoreDNS 默认配置的功能性行为与 kube-dns 相同。但是，你需要了解的差别之一是二者发布的指标是不同的。在 kube-dns 中，您将分别获得 <code>dnsmasq</code> 和 <code>kubedns</code>（skydns）的度量值。在 CoreDNS 中，存在一组完全不同的指标，因为它们在同一个进程中。您可以在 CoreDNS <a href=https://coredns.io/plugins/metrics/>Prometheus 插件</a> 页面上找到有关这些指标的更多详细信息。</p><h2 id=一些特殊功能>一些特殊功能</h2><p>标准的 CoreDNS Kubernetes 配置旨在与以前的 kube-dns 在行为上向后兼容。但是，通过进行一些配置更改，CoreDNS 允许您修改 DNS 服务发现在集群中的工作方式。这些功能中的许多功能仍要符合 <a href=https://github.com/kubernetes/dns/blob/master/docs/specification.md>Kubernetes DNS规范</a>；它们在增强了功能的同时保持向后兼容。由于 CoreDNS 并非 <em>仅</em> 用于 Kubernetes，而是通用的 DNS 服务器，因此您可以做很多超出该规范的事情。</p><h3 id=pod-验证模式>Pod 验证模式</h3><p>在 kube-dns 中，Pod 名称记录是 "伪造的"。也就是说，任何 "a-b-c-d.namespace.pod.cluster.local" 查询都将返回 IP 地址 "a.b.c.d"。在某些情况下，这可能会削弱 TLS 提供的身份确认。因此，CoreDNS 提供了一种 "Pod 验证" 的模式，该模式仅在指定名称空间中存在具有该 IP 地址的 Pod 时才返回 IP 地址。</p><h3 id=基于-pod-名称的端点名称>基于 Pod 名称的端点名称</h3><p>在 kube-dns 中，使用无头服务时，可以使用 SRV 请求获取该服务的所有端点的列表：</p><pre tabindex=0><code>dnstools# host -t srv headless
headless.default.svc.cluster.local has SRV record 10 33 0 6234396237313665.headless.default.svc.cluster.local.
headless.default.svc.cluster.local has SRV record 10 33 0 6662363165353239.headless.default.svc.cluster.local.
headless.default.svc.cluster.local has SRV record 10 33 0 6338633437303230.headless.default.svc.cluster.local.
dnstools#
</code></pre><p>但是，端点 DNS 名称（出于实际目的）是随机的。在 CoreDNS 中，默认情况下，您所获得的端点 DNS 名称是基于端点 IP 地址生成的：</p><pre tabindex=0><code>dnstools# host -t srv headless
headless.default.svc.cluster.local has SRV record 0 25 443 172-17-0-14.headless.default.svc.cluster.local.
headless.default.svc.cluster.local has SRV record 0 25 443 172-17-0-18.headless.default.svc.cluster.local.
headless.default.svc.cluster.local has SRV record 0 25 443 172-17-0-4.headless.default.svc.cluster.local.
headless.default.svc.cluster.local has SRV record 0 25 443 172-17-0-9.headless.default.svc.cluster.local.
</code></pre><p>对于某些应用程序，你会希望在这里使用 Pod 名称，而不是 Pod IP 地址（例如，参见 <a href=https://github.com/kubernetes/kubernetes/issues/47992>kubernetes#47992</a> 和 <a href=https://github.com/coredns/coredns/pull/1190>coredns#1190</a>）。要在 CoreDNS 中启用此功能，请在 Corefile 中指定 "endpoint_pod_names" 选项，结果如下：</p><pre tabindex=0><code>dnstools# host -t srv headless
headless.default.svc.cluster.local has SRV record 0 25 443 headless-65bb4c479f-qv84p.headless.default.svc.cluster.local.
headless.default.svc.cluster.local has SRV record 0 25 443 headless-65bb4c479f-zc8lx.headless.default.svc.cluster.local.
headless.default.svc.cluster.local has SRV record 0 25 443 headless-65bb4c479f-q7lf2.headless.default.svc.cluster.local.
headless.default.svc.cluster.local has SRV record 0 25 443 headless-65bb4c479f-566rt.headless.default.svc.cluster.local.
</code></pre><h3 id=自动路径>自动路径</h3><p>CoreDNS 还具有一项特殊功能，可以改善 DNS 中外部名称请求的延迟。在 Kubernetes 中，Pod 的 DNS 搜索路径指定了一长串后缀。这一特点使得你可以针对集群中服务使用短名称 - 例如，上面的 "headless"，而不是 "headless.default.svc.cluster.local"。但是，当请求一个外部名称（例如 "infoblox.com"）时，客户端会进行几个无效的 DNS 查询，每次都需要从客户端到 kube-dns 往返（实际上是到 <code>dnsmasq</code>，然后到 <code>kubedns</code>），因为 <a href=https://github.com/kubernetes/dns/issues/121>禁用了负缓存</a>）</p><ul><li>infoblox.com.default.svc.cluster.local -> NXDOMAIN</li><li>infoblox.com.svc.cluster.local -> NXDOMAIN</li><li>infoblox.com.cluster.local -> NXDOMAIN</li><li>infoblox.com.your-internal-domain.com -> NXDOMAIN</li></ul><ul><li>infoblox.com -> 返回有效记录</li></ul><p>在 CoreDNS 中，可以启用 <a href=https://coredns.io/plugins/autopath>autopath</a> 的可选功能，该功能使搜索路径在 <em>服务器端</em> 遍历。也就是说，CoreDNS 将基于源 IP 地址判断客户端 Pod 所在的命名空间，并且遍历此搜索列表，直到获得有效答案为止。由于其中的前三个是在 CoreDNS 本身内部解决的，因此它消除了客户端和服务器之间所有的来回通信，从而减少了延迟。</p><h3 id=其他一些特定于-kubernetes-的功能>其他一些特定于 Kubernetes 的功能</h3><p>在 CoreDNS 中，您可以使用标准 DNS 区域传输来导出整个 DNS 记录集。这对于调试服务以及将集群区导入其他 DNS 服务器很有用。</p><p>您还可以按名称空间或标签选择器进行过滤。这样，您可以运行特定的 CoreDNS 实例，该实例仅服务与过滤器匹配的记录，从而通过 DNS 公开受限的服务集。</p><h2 id=可扩展性>可扩展性</h2><p>除了上述功能之外，CoreDNS 还可轻松扩展，构建包含您独有的功能的自定义版本的 CoreDNS。例如，这一能力已被用于扩展 CoreDNS 来使用 <a href=https://coredns.io/explugins/unbound>unbound 插件</a> 进行递归解析、使用 <a href=https://coredns.io/explugins/pdsql>pdsql 插件</a> 直接从数据库提供记录，以及使用 <a href=https://coredns.io/explugins/redisc>redisc 插件</a> 与多个 CoreDNS 实例共享一个公共的 2 级缓存。</p><p>已添加的还有许多其他有趣的扩展，您可以在 CoreDNS 站点的 <a href=https://coredns.io/explugins/>外部插件</a> 页面上找到这些扩展。Kubernetes 和 Istio 用户真正感兴趣的是 <a href=https://coredns.io/explugins/kubernetai>kubernetai 插件</a>，它允许单个 CoreDNS 实例连接到多个 Kubernetes 集群并在所有集群中提供服务发现 。</p><h2 id=下一步工作>下一步工作</h2><p>CoreDNS 是一个独立的项目，许多与 Kubernetes 不直接相关的功能正在开发中。但是，其中许多功能将在 Kubernetes 中具有对应的应用。例如，与策略引擎完成集成后，当请求无头服务时，CoreDNS 能够智能地选择返回哪个端点。这可用于将流量分流到本地 Pod 或响应更快的 Pod。更多的其他功能正在开发中，当然作为一个开源项目，我们欢迎您提出建议并贡献自己的功能特性！</p><p>上述特征和差异是几个示例。CoreDNS 还可以做更多的事情。您可以在 <a href=https://coredns.io/blog>CoreDNS 博客</a> 上找到更多信息。</p><h3 id=参与-coredns>参与 CoreDNS</h3><p>CoreDNS 是一个 <a href=https:://cncf.io>CNCF</a> 孵化项目。</p><p>我们在 Slack（和 GitHub）上最活跃：</p><ul><li>Slack: #coredns on <a href=https://slack.cncf.io>https://slack.cncf.io</a></li><li>GitHub: <a href=https://github.com/coredns/coredns>https://github.com/coredns/coredns</a></li></ul><p>更多资源请浏览：</p><ul><li>Website: <a href=https://coredns.io>https://coredns.io</a></li><li>Blog: <a href=https://blog.coredns.io>https://blog.coredns.io</a></li><li>Twitter: <a href=https://twitter.com/corednsio>@corednsio</a></li><li>Mailing list/group: <a href=mailto:coredns-discuss@googlegroups.com>coredns-discuss@googlegroups.com</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-ff1a9a29a39941763cf19d669d7fbbcc>基于 IPVS 的集群内部负载均衡</h1><div class="td-byline mb-4"><time datetime=2018-07-09 class=text-muted>2018.07.09</time></div><p>作者: Jun Du(华为), Haibin Xie(华为), Wei Liang(华为)</p><p>注意: 这篇文章出自 系列深度文章 介绍 Kubernetes 1.11 的新特性</p><p>介绍</p><p>根据 Kubernetes 1.11 发布的博客文章, 我们宣布基于 IPVS 的集群内部服务负载均衡已达到一般可用性。 在这篇博客中，我们将带您深入了解该功能。</p><p>什么是 IPVS ?</p><p>IPVS (IP Virtual Server)是在 Netfilter 上层构建的，并作为 Linux 内核的一部分，实现传输层负载均衡。</p><p>IPVS 集成在 LVS（Linux Virtual Server，Linux 虚拟服务器）中，它在主机上运行，并在物理服务器集群前作为负载均衡器。IPVS 可以将基于 TCP 和 UDP 服务的请求定向到真实服务器，并使真实服务器的服务在单个IP地址上显示为虚拟服务。 因此，IPVS 自然支持 Kubernetes 服务。</p><p>为什么为 Kubernetes 选择 IPVS ?</p><p>随着 Kubernetes 的使用增长，其资源的可扩展性变得越来越重要。特别是，服务的可扩展性对于运行大型工作负载的开发人员/公司采用 Kubernetes 至关重要。</p><p>Kube-proxy 是服务路由的构建块，它依赖于经过强化攻击的 iptables 来实现支持核心的服务类型，如 ClusterIP 和 NodePort。 但是，iptables 难以扩展到成千上万的服务，因为它纯粹是为防火墙而设计的，并且基于内核规则列表。</p><p>尽管 Kubernetes 在版本v1.6中已经支持5000个节点，但使用 iptables 的 kube-proxy 实际上是将集群扩展到5000个节点的瓶颈。 一个例子是，在5000节点集群中使用 NodePort 服务，如果我们有2000个服务并且每个服务有10个 pod，这将在每个工作节点上至少产生20000个 iptable 记录，这可能使内核非常繁忙。</p><p>另一方面，使用基于 IPVS 的集群内服务负载均衡可以为这种情况提供很多帮助。 IPVS 专门用于负载均衡，并使用更高效的数据结构（哈希表），允许几乎无限的规模扩张。</p><p>基于 IPVS 的 Kube-proxy</p><p>参数更改</p><p>参数: --proxy-mode 除了现有的用户空间和 iptables 模式，IPVS 模式通过--proxy-mode = ipvs 进行配置。 它隐式使用 IPVS NAT 模式进行服务端口映射。</p><p>参数: --ipvs-scheduler</p><p>添加了一个新的 kube-proxy 参数来指定 IPVS 负载均衡算法，参数为 --ipvs-scheduler。 如果未配置，则默认为 round-robin 算法（rr）。</p><ul><li>rr: round-robin</li><li>lc: least connection</li><li>dh: destination hashing</li><li>sh: source hashing</li><li>sed: shortest expected delay</li><li>nq: never queue</li></ul><p>将来，我们可以实现特定于服务的调度程序（可能通过注释），该调度程序具有更高的优先级并覆盖该值。</p><p>参数: --cleanup-ipvs 类似于 --cleanup-iptables 参数，如果为 true，则清除在 IPVS 模式下创建的 IPVS 配置和 IPTables 规则。</p><p>参数: --ipvs-sync-period 刷新 IPVS 规则的最大间隔时间（例如'5s'，'1m'）。 必须大于0。</p><p>参数: --ipvs-min-sync-period 刷新 IPVS 规则的最小间隔时间间隔（例如'5s'，'1m'）。 必须大于0。</p><p>参数: --ipvs-exclude-cidrs 清除 IPVS 规则时 IPVS 代理不应触及的 CIDR 的逗号分隔列表，因为 IPVS 代理无法区分 kube-proxy 创建的 IPVS 规则和用户原始规则 IPVS 规则。 如果您在环境中使用 IPVS proxier 和您自己的 IPVS 规则，则应指定此参数，否则将清除原始规则。</p><p>设计注意事项</p><p>IPVS 服务网络拓扑</p><p>创建 ClusterIP 类型服务时，IPVS proxier 将执行以下三项操作：</p><ul><li>确保节点中存在虚拟接口，默认为 kube-ipvs0</li><li>将服务 IP 地址绑定到虚拟接口</li><li>分别为每个服务 IP 地址创建 IPVS 虚拟服务器</li></ul><p>这是一个例子:</p><pre><code># kubectl describe svc nginx-service
Name:			nginx-service
...
Type:			ClusterIP
IP:			    10.102.128.4
Port:			http	3080/TCP
Endpoints:		10.244.0.235:8080,10.244.1.237:8080
Session Affinity:	None

# ip addr
...
73: kube-ipvs0: &lt;BROADCAST,NOARP&gt; mtu 1500 qdisc noop state DOWN qlen 1000
    link/ether 1a:ce:f5:5f:c1:4d brd ff:ff:ff:ff:ff:ff
    inet 10.102.128.4/32 scope global kube-ipvs0
       valid_lft forever preferred_lft forever

# ipvsadm -ln
IP Virtual Server version 1.2.1 (size=4096)
Prot LocalAddress:Port Scheduler Flags
  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn
TCP  10.102.128.4:3080 rr
  -&gt; 10.244.0.235:8080            Masq    1      0          0
  -&gt; 10.244.1.237:8080            Masq    1      0          0
</code></pre><p>请注意，Kubernetes 服务和 IPVS 虚拟服务器之间的关系是“1：N”。 例如，考虑具有多个 IP 地址的 Kubernetes 服务。 外部 IP 类型服务有两个 IP 地址 - 集群IP和外部 IP。 然后，IPVS 代理将创建2个 IPVS 虚拟服务器 - 一个用于集群 IP，另一个用于外部 IP。 Kubernetes 的 endpoint（每个IP +端口对）与 IPVS 虚拟服务器之间的关系是“1：1”。</p><p>删除 Kubernetes 服务将触发删除相应的 IPVS 虚拟服务器，IPVS 物理服务器及其绑定到虚拟接口的 IP 地址。</p><p>端口映射</p><p>IPVS 中有三种代理模式：NAT（masq），IPIP 和 DR。 只有 NAT 模式支持端口映射。 Kube-proxy 利用 NAT 模式进行端口映射。 以下示例显示 IPVS 服务端口3080到Pod端口8080的映射。</p><pre><code>TCP  10.102.128.4:3080 rr
  -&gt; 10.244.0.235:8080            Masq    1      0          0
  -&gt; 10.244.1.237:8080            Masq    1      0
</code></pre><p>会话关系</p><p>IPVS 支持客户端 IP 会话关联（持久连接）。 当服务指定会话关系时，IPVS 代理将在 IPVS 虚拟服务器中设置超时值（默认为180分钟= 10800秒）。 例如：</p><pre><code># kubectl describe svc nginx-service
Name:			nginx-service
...
IP:			    10.102.128.4
Port:			http	3080/TCP
Session Affinity:	ClientIP

# ipvsadm -ln
IP Virtual Server version 1.2.1 (size=4096)
Prot LocalAddress:Port Scheduler Flags
  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn
TCP  10.102.128.4:3080 rr persistent 10800
</code></pre><p>IPVS 代理中的 Iptables 和 Ipset</p><p>IPVS 用于负载均衡，它无法处理 kube-proxy 中的其他问题，例如 包过滤，数据包欺骗，SNAT 等</p><p>IPVS proxier 在上述场景中利用 iptables。 具体来说，ipvs proxier 将在以下4种情况下依赖于 iptables：</p><ul><li>kube-proxy 以 --masquerade-all = true 开头</li><li>在 kube-proxy 启动中指定集群 CIDR</li><li>支持 Loadbalancer 类型服务</li><li>支持 NodePort 类型的服务</li></ul><p>但是，我们不想创建太多的 iptables 规则。 所以我们采用 ipset 来减少 iptables 规则。 以下是 IPVS proxier 维护的 ipset 集表：</p><p>设置名称 成员 用法
KUBE-CLUSTER-IP 所有服务 IP + 端口 masquerade-all=true 或 clusterCIDR 指定的情况下进行伪装
KUBE-LOOP-BACK 所有服务 IP +端口+ IP 解决数据包欺骗问题
KUBE-EXTERNAL-IP 服务外部 IP +端口 将数据包伪装成外部 IP
KUBE-LOAD-BALANCER 负载均衡器入口 IP +端口 将数据包伪装成 Load Balancer 类型的服务
KUBE-LOAD-BALANCER-LOCAL 负载均衡器入口 IP +端口 以及 externalTrafficPolicy=local 接受数据包到 Load Balancer externalTrafficPolicy=local
KUBE-LOAD-BALANCER-FW 负载均衡器入口 IP +端口 以及 loadBalancerSourceRanges 使用指定的 loadBalancerSourceRanges 丢弃 Load Balancer类型Service的数据包
KUBE-LOAD-BALANCER-SOURCE-CIDR 负载均衡器入口 IP +端口 + 源 CIDR 接受 Load Balancer 类型 Service 的数据包，并指定loadBalancerSourceRanges
KUBE-NODE-PORT-TCP NodePort 类型服务 TCP 将数据包伪装成 NodePort（TCP）
KUBE-NODE-PORT-LOCAL-TCP NodePort 类型服务 TCP 端口，带有 externalTrafficPolicy=local 接受数据包到 NodePort 服务 使用 externalTrafficPolicy=local
KUBE-NODE-PORT-UDP NodePort 类型服务 UDP 端口 将数据包伪装成 NodePort(UDP)
KUBE-NODE-PORT-LOCAL-UDP NodePort 类型服务 UDP 端口 使用 externalTrafficPolicy=local 接受数据包到NodePort服务 使用 externalTrafficPolicy=local</p><p>通常，对于 IPVS proxier，无论我们有多少 Service/ Pod，iptables 规则的数量都是静态的。</p><p>在 IPVS 模式下运行 kube-proxy</p><p>目前，本地脚本，GCE 脚本和 kubeadm 支持通过导出环境变量（KUBE_PROXY_MODE=ipvs）或指定标志（--proxy-mode=ipvs）来切换 IPVS 代理模式。 在运行IPVS 代理之前，请确保已安装 IPVS 所需的内核模块。</p><pre><code>ip_vs
ip_vs_rr
ip_vs_wrr
ip_vs_sh
nf_conntrack_ipv4
</code></pre><p>最后，对于 Kubernetes v1.10，“SupportIPVSProxyMode” 默认设置为 “true”。 对于 Kubernetes v1.11 ，该选项已完全删除。 但是，您需要在v1.10之前为Kubernetes 明确启用 --feature-gates = SupportIPVSProxyMode = true。</p><p>参与其中</p><p>参与 Kubernetes 的最简单方法是加入众多<a href=https://github.com/kubernetes/community/blob/master/sig-list.md>特别兴趣小组</a> (SIG）中与您的兴趣一致的小组。 你有什么想要向 Kubernetes 社区广播的吗？ 在我们的每周<a href=https://github.com/kubernetes/community/blob/master/communication.md#weekly-meeting>社区会议</a>或通过以下渠道分享您的声音。</p><p>感谢您的持续反馈和支持。
在<a href=http://stackoverflow.com/questions/tagged/kubernetes>Stack Overflow</a>上发布问题（或回答问题）</p><p>加入<a href=http://k8sport.org/>K8sPort</a>的倡导者社区门户网站</p><p>在 Twitter 上关注我们 <a href=https://twitter.com/kubernetesio>@Kubernetesio</a>获取最新更新</p><p>在<a href=http://slack.k8s.io/>Slack</a>上与社区聊天</p><p>分享您的 Kubernetes <a href=https://docs.google.com/a/linuxfoundation.org/forms/d/e/1FAIpQLScuI7Ye3VQHQTwBASrgkjQDSS5TP0g3AXfFhwSM9YpHgxRKFA/viewform>故事</a></p></div><div class=td-content style=page-break-before:always><h1 id=pg-56b1754609f34aa3b199a3e9af607d92>Airflow 在 Kubernetes 中的使用（第一部分）：一种不同的操作器</h1><div class="td-byline mb-4"><time datetime=2018-06-28 class=text-muted>2018.06.28</time></div><p>作者: Daniel Imberman (Bloomberg LP)</p><h2 id=介绍>介绍</h2><p>作为 Bloomberg <a href=https://www.techatbloomberg.com/blog/bloomberg-awarded-first-cncf-end-user-award-contributions-kubernetes/>持续致力于开发 Kubernetes 生态系统</a>的一部分，
我们很高兴能够宣布 Kubernetes Airflow Operator 的发布;
<a href=https://airflow.apache.org/>Apache Airflow</a>的一种机制，一种流行的工作流程编排框架，
使用 Kubernetes API 可以在本机启动任意的 Kubernetes Pod。</p><h2 id=什么是-airflow>什么是 Airflow?</h2><p>Apache Airflow 是“配置即代码”的 DevOps 理念的一种实现。
Airflow 允许用户使用简单的 Python 对象 DAG（有向无环图）启动多步骤流水线。
你可以在易于阅读的 UI 中定义依赖关系，以编程方式构建复杂的工作流，并监视调度的作业。</p><img src=/images/blog/2018-05-25-Airflow-Kubernetes-Operator/2018-05-25-airflow_dags.png width=85% alt="Airflow DAGs">
<img src=/images/blog/2018-05-25-Airflow-Kubernetes-Operator/2018-05-25-airflow.png width=85% alt="Airflow UI"><h2 id=为什么在-kubernetes-上使用-airflow>为什么在 Kubernetes 上使用 Airflow？</h2><p>自成立以来，Airflow 的最大优势在于其灵活性。
Airflow 提供广泛的服务集成，包括Spark和HBase，以及各种云提供商的服务。
Airflow 还通过其插件框架提供轻松的可扩展性。
但是，该项目的一个限制是 Airflow 用户仅限于执行时 Airflow 站点上存在的框架和客户端。
单个组织可以拥有各种 Airflow 工作流程，范围从数据科学流到应用程序部署。
用例中的这种差异会在依赖关系管理中产生问题，因为两个团队可能会在其工作流程使用截然不同的库。</p><p>为了解决这个问题，我们使 Kubernetes 允许用户启动任意 Kubernetes Pod 和配置。
Airflow 用户现在可以在其运行时环境，资源和机密上拥有全部权限，基本上将 Airflow 转变为“你想要的任何工作”工作流程协调器。</p><h2 id=kubernetes-operator>Kubernetes Operator</h2><p>在进一步讨论之前，我们应该澄清 Airflow 中的 <a href=https://airflow.apache.org/concepts.html#operators>Operator</a> 是一个任务定义。
当用户创建 DAG 时，他们将使用像 “SparkSubmitOperator” 或 “PythonOperator” 这样的 Operator 分别提交/监视 Spark 作业或 Python 函数。
Airflow 附带了 Apache Spark，BigQuery，Hive 和 EMR 等框架的内置运算符。
它还提供了一个插件入口点，允许DevOps工程师开发自己的连接器。</p><p>Airflow 用户一直在寻找更易于管理部署和 ETL 流的方法。
在增加监控的同时，任何解耦流程的机会都可以减少未来的停机等问题。
以下是 Airflow Kubernetes Operator 提供的好处：</p><ul><li><strong>提高部署灵活性：</strong>
Airflow 的插件 API一直为希望在其 DAG 中测试新功能的工程师提供了重要的福利。
不利的一面是，每当开发人员想要创建一个新的 Operator 时，他们就必须开发一个全新的插件。
现在，任何可以在 Docker 容器中运行的任务都可以通过完全相同的运算符访问，而无需维护额外的 Airflow 代码。</li></ul><ul><li><strong>配置和依赖的灵活性：</strong></li></ul><p>对于在静态 Airflow 工作程序中运行的 Operator，依赖关系管理可能变得非常困难。
如果开发人员想要运行一个需要 <a href=https://www.scipy.org>SciPy</a> 的任务和另一个需要 <a href=http://www.numpy.org>NumPy</a> 的任务，
开发人员必须维护所有 Airflow 节点中的依赖关系或将任务卸载到其他计算机（如果外部计算机以未跟踪的方式更改，则可能导致错误）。
自定义 Docker 镜像允许用户确保任务环境，配置和依赖关系完全是幂等的。</p><ul><li><strong>使用kubernetes Secret以增加安全性：</strong>
处理敏感数据是任何开发工程师的核心职责。Airflow 用户总有机会在严格条款的基础上隔离任何API密钥，数据库密码和登录凭据。
使用 Kubernetes 运算符，用户可以利用 Kubernetes Vault 技术存储所有敏感数据。
这意味着 Airflow 工作人员将永远无法访问此信息，并且可以容易地请求仅使用他们需要的密码信息构建 Pod。</li></ul><h1 id=架构>架构</h1><img src=/images/blog/2018-05-25-Airflow-Kubernetes-Operator/2018-05-25-airflow-architecture.png width=85% alt="Airflow Architecture"><p>Kubernetes Operator 使用 <a href=https://github.com/kubernetes-client/Python>Kubernetes Python客户端</a>生成由 APIServer 处理的请求（1）。
然后，Kubernetes将使用你定义的需求启动你的 Pod（2）。
镜像文件中将加载环境变量，Secret 和依赖项，执行单个命令。
一旦启动作业，Operator 只需要监视跟踪日志的状况（3）。
用户可以选择将日志本地收集到调度程序或当前位于其 Kubernetes 集群中的任何分布式日志记录服务。</p><h1 id=使用-kubernetes-operator>使用 Kubernetes Operator</h1><h2 id=一个基本的例子>一个基本的例子</h2><p>以下 DAG 可能是我们可以编写的最简单的示例，以显示 Kubernetes Operator 的工作原理。
这个 DAG 在 Kubernetes 上创建了两个 Pod：一个带有 Python 的 Linux 发行版和一个没有它的基本 Ubuntu 发行版。
Python Pod 将正确运行 Python 请求，而没有 Python 的那个将向用户报告失败。
如果 Operator 正常工作，则应该完成 “passing-task” Pod，而“ falling-task” Pod 则向 Airflow 网络服务器返回失败。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Python data-lang=Python><span style=display:flex><span><span style=color:#a2f;font-weight:700>from</span> <span style=color:#00f;font-weight:700>airflow</span> <span style=color:#a2f;font-weight:700>import</span> DAG
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>from</span> <span style=color:#00f;font-weight:700>datetime</span> <span style=color:#a2f;font-weight:700>import</span> datetime, timedelta
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>from</span> <span style=color:#00f;font-weight:700>airflow.contrib.operators.kubernetes_pod_operator</span> <span style=color:#a2f;font-weight:700>import</span> KubernetesPodOperator
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>from</span> <span style=color:#00f;font-weight:700>airflow.operators.dummy_operator</span> <span style=color:#a2f;font-weight:700>import</span> DummyOperator
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>default_args <span style=color:#666>=</span> {
</span></span><span style=display:flex><span>    <span style=color:#b44>&#39;owner&#39;</span>: <span style=color:#b44>&#39;airflow&#39;</span>,
</span></span><span style=display:flex><span>    <span style=color:#b44>&#39;depends_on_past&#39;</span>: <span style=color:#a2f;font-weight:700>False</span>,
</span></span><span style=display:flex><span>    <span style=color:#b44>&#39;start_date&#39;</span>: datetime<span style=color:#666>.</span>utcnow(),
</span></span><span style=display:flex><span>    <span style=color:#b44>&#39;email&#39;</span>: [<span style=color:#b44>&#39;airflow@example.com&#39;</span>],
</span></span><span style=display:flex><span>    <span style=color:#b44>&#39;email_on_failure&#39;</span>: <span style=color:#a2f;font-weight:700>False</span>,
</span></span><span style=display:flex><span>    <span style=color:#b44>&#39;email_on_retry&#39;</span>: <span style=color:#a2f;font-weight:700>False</span>,
</span></span><span style=display:flex><span>    <span style=color:#b44>&#39;retries&#39;</span>: <span style=color:#666>1</span>,
</span></span><span style=display:flex><span>    <span style=color:#b44>&#39;retry_delay&#39;</span>: timedelta(minutes<span style=color:#666>=</span><span style=color:#666>5</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>dag <span style=color:#666>=</span> DAG(
</span></span><span style=display:flex><span>    <span style=color:#b44>&#39;kubernetes_sample&#39;</span>, default_args<span style=color:#666>=</span>default_args, schedule_interval<span style=color:#666>=</span>timedelta(minutes<span style=color:#666>=</span><span style=color:#666>10</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>start <span style=color:#666>=</span> DummyOperator(task_id<span style=color:#666>=</span><span style=color:#b44>&#39;run_this_first&#39;</span>, dag<span style=color:#666>=</span>dag)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>passing <span style=color:#666>=</span> KubernetesPodOperator(namespace<span style=color:#666>=</span><span style=color:#b44>&#39;default&#39;</span>,
</span></span><span style=display:flex><span>                          image<span style=color:#666>=</span><span style=color:#b44>&#34;Python:3.6&#34;</span>,
</span></span><span style=display:flex><span>                          cmds<span style=color:#666>=</span>[<span style=color:#b44>&#34;Python&#34;</span>,<span style=color:#b44>&#34;-c&#34;</span>],
</span></span><span style=display:flex><span>                          arguments<span style=color:#666>=</span>[<span style=color:#b44>&#34;print(&#39;hello world&#39;)&#34;</span>],
</span></span><span style=display:flex><span>                          labels<span style=color:#666>=</span>{<span style=color:#b44>&#34;foo&#34;</span>: <span style=color:#b44>&#34;bar&#34;</span>},
</span></span><span style=display:flex><span>                          name<span style=color:#666>=</span><span style=color:#b44>&#34;passing-test&#34;</span>,
</span></span><span style=display:flex><span>                          task_id<span style=color:#666>=</span><span style=color:#b44>&#34;passing-task&#34;</span>,
</span></span><span style=display:flex><span>                          get_logs<span style=color:#666>=</span><span style=color:#a2f;font-weight:700>True</span>,
</span></span><span style=display:flex><span>                          dag<span style=color:#666>=</span>dag
</span></span><span style=display:flex><span>                          )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>failing <span style=color:#666>=</span> KubernetesPodOperator(namespace<span style=color:#666>=</span><span style=color:#b44>&#39;default&#39;</span>,
</span></span><span style=display:flex><span>                          image<span style=color:#666>=</span><span style=color:#b44>&#34;ubuntu:1604&#34;</span>,
</span></span><span style=display:flex><span>                          cmds<span style=color:#666>=</span>[<span style=color:#b44>&#34;Python&#34;</span>,<span style=color:#b44>&#34;-c&#34;</span>],
</span></span><span style=display:flex><span>                          arguments<span style=color:#666>=</span>[<span style=color:#b44>&#34;print(&#39;hello world&#39;)&#34;</span>],
</span></span><span style=display:flex><span>                          labels<span style=color:#666>=</span>{<span style=color:#b44>&#34;foo&#34;</span>: <span style=color:#b44>&#34;bar&#34;</span>},
</span></span><span style=display:flex><span>                          name<span style=color:#666>=</span><span style=color:#b44>&#34;fail&#34;</span>,
</span></span><span style=display:flex><span>                          task_id<span style=color:#666>=</span><span style=color:#b44>&#34;failing-task&#34;</span>,
</span></span><span style=display:flex><span>                          get_logs<span style=color:#666>=</span><span style=color:#a2f;font-weight:700>True</span>,
</span></span><span style=display:flex><span>                          dag<span style=color:#666>=</span>dag
</span></span><span style=display:flex><span>                          )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>passing<span style=color:#666>.</span>set_upstream(start)
</span></span><span style=display:flex><span>failing<span style=color:#666>.</span>set_upstream(start)
</span></span></code></pre></div><img src=/images/blog/2018-05-25-Airflow-Kubernetes-Operator/2018-05-25-basic-dag-run.png width=85% alt="Basic DAG Run"><h2 id=但这与我的工作流程有什么关系>但这与我的工作流程有什么关系？</h2><p>虽然这个例子只使用基本映像，但 Docker 的神奇之处在于，这个相同的 DAG 可以用于你想要的任何图像/命令配对。
以下是推荐的 CI/CD 管道，用于在 Airflow DAG 上运行生产就绪代码。</p><h3 id=1-github-中的-pr>1：github 中的 PR</h3><p>使用Travis或Jenkins运行单元和集成测试，请你的朋友PR你的代码，并合并到主分支以触发自动CI构建。</p><h3 id=2-ci-cd-构建-jenkins-docker-镜像>2：CI/CD 构建 Jenkins - > Docker 镜像</h3><p><a href=https://getintodevops.com/blog/building-your-first-Docker-image-with-jenkins-2-guide-for-developers>在 Jenkins 构建中生成 Docker 镜像和更新版本</a>。</p><h3 id=3-airflow-启动任务>3：Airflow 启动任务</h3><p>最后，更新你的 DAG 以反映新版本，你应该准备好了！</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Python data-lang=Python><span style=display:flex><span>production_task <span style=color:#666>=</span> KubernetesPodOperator(namespace<span style=color:#666>=</span><span style=color:#b44>&#39;default&#39;</span>,
</span></span><span style=display:flex><span>                          <span style=color:#080;font-style:italic># image=&#34;my-production-job:release-1.0.1&#34;, &lt;-- old release</span>
</span></span><span style=display:flex><span>                          image<span style=color:#666>=</span><span style=color:#b44>&#34;my-production-job:release-1.0.2&#34;</span>,
</span></span><span style=display:flex><span>                          cmds<span style=color:#666>=</span>[<span style=color:#b44>&#34;Python&#34;</span>,<span style=color:#b44>&#34;-c&#34;</span>],
</span></span><span style=display:flex><span>                          arguments<span style=color:#666>=</span>[<span style=color:#b44>&#34;print(&#39;hello world&#39;)&#34;</span>],
</span></span><span style=display:flex><span>                          name<span style=color:#666>=</span><span style=color:#b44>&#34;fail&#34;</span>,
</span></span><span style=display:flex><span>                          task_id<span style=color:#666>=</span><span style=color:#b44>&#34;failing-task&#34;</span>,
</span></span><span style=display:flex><span>                          get_logs<span style=color:#666>=</span><span style=color:#a2f;font-weight:700>True</span>,
</span></span><span style=display:flex><span>                          dag<span style=color:#666>=</span>dag
</span></span><span style=display:flex><span>                          )
</span></span></code></pre></div><h1 id=启动测试部署>启动测试部署</h1><p>由于 Kubernetes Operator 尚未发布，我们尚未发布官方
<a href=https://helm.sh/>helm</a> 图表或 Operator（但两者目前都在进行中）。
但是，我们在下面列出了基本部署的说明，并且正在积极寻找测试人员来尝试这一新功能。
要试用此系统，请按以下步骤操作：</p><h2 id=步骤1-将-kubeconfig-设置为指向-kubernetes-集群>步骤1：将 kubeconfig 设置为指向 kubernetes 集群</h2><h2 id=步骤2-克隆-airflow-仓库>步骤2：克隆 Airflow 仓库：</h2><p>运行 <code>git clone https://github.com/apache/incubator-airflow.git</code> 来克隆官方 Airflow 仓库。</p><h2 id=步骤3-运行>步骤3：运行</h2><p>为了运行这个基本 Deployment，我们正在选择我们目前用于 Kubernetes Executor 的集成测试脚本（将在本系列的下一篇文章中对此进行解释）。
要启动此部署，请运行以下三个命令：</p><pre tabindex=0><code>sed -ie &#34;s/KubernetesExecutor/LocalExecutor/g&#34; scripts/ci/kubernetes/kube/configmaps.yaml
./scripts/ci/kubernetes/Docker/build.sh
./scripts/ci/kubernetes/kube/deploy.sh
</code></pre><p>在我们继续之前，让我们讨论这些命令正在做什么：</p><h3 id=sed-ie-s-kubernetesexecutor-localexecutor-g-scripts-ci-kubernetes-kube-configmaps-yaml>sed -ie "s/KubernetesExecutor/LocalExecutor/g" scripts/ci/kubernetes/kube/configmaps.yaml</h3><p>Kubernetes Executor 是另一种 Airflow 功能，允许动态分配任务已解决幂等 Pod 的问题。
我们将其切换到 LocalExecutor 的原因只是一次引入一个功能。
如果你想尝试 Kubernetes Executor，欢迎你跳过此步骤，但我们将在以后的文章中详细介绍。</p><h3 id=scripts-ci-kubernetes-docker-build-sh>./scripts/ci/kubernetes/Docker/build.sh</h3><p>此脚本将对Airflow主分支代码进行打包，以根据Airflow的发行文件构建Docker容器</p><h3 id=scripts-ci-kubernetes-kube-deploy-sh>./scripts/ci/kubernetes/kube/deploy.sh</h3><p>最后，我们在你的集群上创建完整的Airflow部署。这包括 Airflow 配置，postgres 后端，web 服务器和调度程序以及之间的所有必要服务。
需要注意的一点是，提供的角色绑定是集群管理员，因此如果你没有该集群的权限级别，可以在 scripts/ci/kubernetes/kube/airflow.yaml 中进行修改。</p><h2 id=步骤4-登录你的网络服务器>步骤4：登录你的网络服务器</h2><p>现在你的 Airflow 实例正在运行，让我们来看看 UI！
用户界面位于 Airflow Pod的 8080 端口，因此只需运行即可：</p><pre tabindex=0><code>WEB=$(kubectl get pods -o go-template --template &#39;{{range .items}}{{.metadata.name}}{{&#34;\n&#34;}}{{end}}&#39; | grep &#34;airflow&#34; | head -1)
kubectl port-forward $WEB 8080:8080
</code></pre><p>现在，Airflow UI 将存在于 http://localhost:8080上。
要登录，只需输入<code>airflow</code>/<code>airflow</code>，你就可以完全访问 Airflow Web UI。</p><h2 id=步骤5-上传测试文档>步骤5：上传测试文档</h2><p>要修改/添加自己的 DAG，可以使用 <code>kubectl cp</code> 将本地文件上传到 Airflow 调度程序的 DAG 文件夹中。
然后，Airflow 将读取新的 DAG 并自动将其上传到其系统。以下命令将任何本地文件上载到正确的目录中：</p><p><code>kubectl cp &lt;local file> &lt;namespace>/&lt;pod>:/root/airflow/dags -c scheduler</code></p><h2 id=步骤6-使用它>步骤6：使用它！</h2><h1 id=那么我什么时候可以使用它>那么我什么时候可以使用它？</h1><p>虽然此功能仍处于早期阶段，但我们希望在未来几个月内发布该功能以进行广泛发布。</p><h1 id=参与其中>参与其中</h1><p>此功能只是将 Apache Airflow 集成到 Kubernetes 中的多项主要工作的开始。
Kubernetes Operator 已合并到 <a href=https://github.com/apache/incubator-airflow/tree/v1-10-test>Airflow 的 1.10 发布分支</a>（实验模式中的执行模块），
以及完整的 k8s 本地调度程序称为 Kubernetes Executor（即将发布文章）。
这些功能仍处于早期采用者/贡献者可能对这些功能的未来产生巨大影响的阶段。</p><p>对于有兴趣加入这些工作的人，我建议按照以下步骤：</p><ul><li>加入 airflow-dev 邮件列表 <a href=mailto:dev@airflow.apache.org>dev@airflow.apache.org</a>。</li><li>在 <a href=https://issues.apache.org/jira/projects/AIRFLOW/issues/>Apache Airflow JIRA</a>中提出问题</li><li>周三上午 10点 太平洋标准时间加入我们的 SIG-BigData 会议。</li><li>在 kubernetes.slack.com 上的 #sig-big-data 找到我们。</li></ul><p>特别感谢 Apache Airflow 和 Kubernetes 社区，特别是 Grant Nicholas，Ben Goldberg，Anirudh Ramanathan，Fokko Dreisprong 和 Bolke de Bruin，
感谢你对这些功能的巨大帮助以及我们未来的努力。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-416d1fed0ff270b6e7f8838c494f3117>Kubernetes 的动态 Ingress</h1><div class="td-byline mb-4">By <b>Richard Li (Datawire)</b> |
<time datetime=2018-06-07 class=text-muted>2018.06.07</time></div><p>Kubernetes 可以轻松部署由许多微服务组成的应用程序，但这种架构的关键挑战之一是动态地将流量路由到这些服务中的每一个。
一种方法是使用 <a href=https://www.getambassador.io>Ambassador</a>，
一个基于 <a href=https://www.envoyproxy.io>Envoy Proxy</a> 构建的 Kubernetes 原生开源 API 网关。
Ambassador 专为动态环境而设计，这类环境中的服务可能被频繁添加或删除。</p><p>Ambassador 使用 Kubernetes 注解进行配置。
注解用于配置从给定 Kubernetes 服务到特定 URL 的具体映射关系。
每个映射中可以包括多个注解，用于配置路由。
注解的例子有速率限制、协议、跨源请求共享（CORS）、流量影射和路由规则等。</p><h2 id=一个简单的-ambassador-示例>一个简单的 Ambassador 示例</h2><p>Ambassador 通常作为 Kubernetes Deployment 来安装，也可以作为 Helm Chart 使用。
配置 Ambassador 时，请使用 Ambassador 注解创建 Kubernetes 服务。
下面是一个例子，用来配置 Ambassador，将针对 /httpbin/ 的请求路由到公共的 httpbin.org 服务：</p><pre tabindex=0><code>apiVersion: v1
kind: Service
metadata:
  name: httpbin
  annotations:
    getambassador.io/config: |
      ---
      apiVersion: ambassador/v0
      kind:  Mapping
      name:  httpbin_mapping
      prefix: /httpbin/
      service: httpbin.org:80
      host_rewrite: httpbin.org
spec:
  type: ClusterIP
  ports:
    - port: 80
</code></pre><p>例子中创建了一个 Mapping 对象，其 prefix 设置为 /httpbin/，service 名称为 httpbin.org。
其中的 host_rewrite 注解指定 HTTP 的 host 头部字段应设置为 httpbin.org。</p><h2 id=kubeflow>Kubeflow</h2><p><a href=https://github.com/kubeflow/kubeflow>Kubeflow</a> 提供了一种简单的方法，用于在 Kubernetes 上轻松部署机器学习基础设施。
Kubeflow 团队需要一个代理，为 Kubeflow 中所使用的各种服务提供集中化的认证和路由能力；Kubeflow 中许多服务本质上都是生命期很短的。</p><center><i>Kubeflow architecture, pre-Ambassador</center></i><h2 id=服务配置>服务配置</h2><p>有了 Ambassador，Kubeflow 可以使用分布式模型进行配置。
Ambassador 不使用集中的配置文件，而是允许每个服务通过 Kubernetes 注解在 Ambassador 中配置其路由。
下面是一个简化的配置示例：</p><pre tabindex=0><code>---
apiVersion: ambassador/v0
kind:  Mapping
name: tfserving-mapping-test-post
prefix: /models/test/
rewrite: /model/test/:predict
method: POST
service: test.kubeflow:8000
</code></pre><p>示例中，“test” 服务使用 Ambassador 注解来为服务动态配置路由。
所配置的路由仅在 HTTP 方法是 POST 时触发；注解中同时还给出了一条重写规则。</p><h2 id=kubeflow-和-ambassador>Kubeflow 和 Ambassador</h2><p>通过 Ambassador，Kubeflow 可以使用 Kubernetes 注解轻松管理路由。
Kubeflow 配置同一个 Ingress 对象，将流量定向到 Ambassador，然后根据需要创建具有 Ambassador 注解的服务，以将流量定向到特定后端。
例如，在部署 TensorFlow 服务时，Kubeflow 会创建 Kubernetes 服务并为其添加注解，
以便用户能够在 <code>https://&lt;ingress主机>/models/&lt;模型名称>/</code> 处访问到模型本身。
Kubeflow 还可以使用 Envoy Proxy 来进行实际的 L7 路由。
通过 Ambassador，Kubeflow 能够更充分地利用 URL 重写和基于方法的路由等额外的路由配置能力。</p><p>如果您对在 Kubeflow 中使用 Ambassador 感兴趣，标准的 Kubeflow 安装会自动安装和配置 Ambassador。</p><p>如果您有兴趣将 Ambassador 用作 API 网关或 Kubernetes 的 Ingress 解决方案，
请参阅 <a href=https://www.getambassador.io/user-guide/getting-started>Ambassador 入门指南</a>。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-bfad75a93816a9020a268af7543370fe>Kubernetes 这四年</h1><div class="td-byline mb-4"><time datetime=2018-06-06 class=text-muted>2018.06.06</time></div><p><strong>作者</strong>：Joe Beda（Heptio 首席技术官兼创始人）</p><p>2014 年 6 月 6 日，我检查了 Kubernetes 公共代码库的<a href=https://github.com/kubernetes/kubernetes/commit/2c4b3a562ce34cddc3f8218a2c4d11c7310e6d56>第一次 commit</a> 。许多人会认为这是故事开始的地方。这难道不是一切开始的地方吗？但这的确不能把整个过程说清楚。</p><p><img src=/images/blog/2018-06-06-4-years-of-k8s/k8s-first-commit.png alt=k8s_first_commit></p><p>第一次 commit 涉及的人员众多，自那以后 Kubernetes 的成功归功于更大的开发者阵容。</p><p>Kubernetes 建立在过去十年曾经在 Google 的 Borg 集群管理系统中验证过的思路之上。而 Borg 本身也是 Google 和其他公司早期努力的结果。</p><p>具体而言，Kubernetes 最初是从 Brendan Burns 的一些原型开始，结合我和 Craig McLuckie 正在进行的工作，以更好地将 Google 内部实践与 Google Cloud 的经验相结合。 Brendan，Craig 和我真的希望人们使用它，所以我们建议将这个原型构建为一个开源项目，将 Borg 的最佳创意带给大家。</p><p>在我们所有人同意后，就开始着手构建这个系统了。我们采用了 Brendan 的原型（Java 语言），用 Go 语言重写了它，并且以上述核心思想去构建该系统。到这个时候，团队已经成长为包括 Ville Aikas，Tim Hockin，Brian Grant，Dawn Chen 和 Daniel Smith。一旦我们有了一些工作需求，有人必须承担一些脱敏的工作，以便为公开发布做好准备。这个角色最终由我承担。当时，我不知道这件事情的重要性，我创建了一个新的仓库，把代码搬过来，然后进行了检查。所以在我第一次提交 public commit 之前，就有工作已经启动了。</p><p>那时 Kubernetes 的版本只是现在版本的简单雏形。核心概念已经有了，但非常原始。例如，Pods 被称为 Tasks，这在我们推广前一天就被替换。2014年6月10日 Eric Brewe 在第一届 DockerCon 上的演讲中正式发布了 Kubernetes。你可以在此处观看该视频：</p><center><iframe width=560 height=315 src=https://www.youtube.com/embed/YrxnVKZeqK8 frameborder=0 allow="autoplay; encrypted-media" allowfullscreen></iframe></center><p>但是，无论多么原始，这小小的一步足以激起一个开始强大而且变得更强大的社区的兴趣。在过去的四年里，Kubernetes 已经超出了我们所有人的期望。我们对 Kubernetes 社区的所有人员表示感谢。该项目所取得的成功不仅基于代码和技术，还基于一群出色的人聚集在一起所做的有意义的事情。Sarah Novotny 策划的一套 <a href=https://github.com/kubernetes/steering/blob/master/values.md>Kubernetes 价值观</a>是以上最好的表现形式。</p><p>让我们一起期待下一个 4 年！🎉🎉🎉</p></div><div class=td-content style=page-break-before:always><h1 id=pg-819e0ad707ce8b6e6e6d031bb89f354d>向 Discuss Kubernetes 问好</h1><div class="td-byline mb-4"><time datetime=2018-05-30 class=text-muted>2018.05.30</time></div><p>作者: Jorge Castro (Heptio)</p><p>就一个超过 35,000 人的全球性社区而言，参与其中时沟通是非常关键的。 跟踪 Kubernetes 社区中的所有内容可能是一项艰巨的任务。 一方面，我们有官方资源，如 Stack Overflow，GitHub 和邮件列表，另一方面，我们有更多瞬时性的资源，如 Slack，你可以加入进去、与某人聊天然后各走各路。</p><p>Slack 非常适合随意和及时的对话，并与其他社区成员保持联系，但未来很难轻易引用通信。此外，在35,000名参与者中提问并得到回答很难。邮件列表在有问题尝试联系特定人群并且想要跟踪大家的回应时非常有用，但是对于大量人员来说可能是麻烦的。 Stack Overflow 和 GitHub 非常适合在涉及代码的项目或问题上进行协作，并且如果在将来要进行搜索也很有用，但某些主题如“你最喜欢的 CI/CD 工具是什么”或“<a href=http://discuss.kubernetes.io/t/kubectl-tips-and-tricks/192>Kubectl提示和技巧</a>“在那里是没有意义的。</p><p>虽然我们目前的各种沟通渠道对他们自己来说都很有价值，但我们发现电子邮件和实时聊天之间仍然存在差距。在网络的其他部分，许多其他开源项目，如 Docker、Mozilla、Swift、Ghost 和 Chef，已经成功地在<a href=http://www.discourse.org/features>Discourse</a>之上构建社区，一个开放的讨论平台。那么，如果我们可以使用这个工具将我们的讨论结合在一个平台下，使用开放的API，或许也不会让我们的大部分信息消失在网络中呢？只有一种方法可以找到：欢迎来到<a href=http://discuss.kubernetes.io>discuss.kubernetes.io</a></p><p>马上，我们有用户可以浏览的类别。检查和发布这些类别允许用户参与他们可能感兴趣的事情，而无需订阅列表。精细的通知控件允许用户只订阅他们想要的类别或标签，并允许通过电子邮件回复主题。</p><p>生态系统合作伙伴和开发人员现在有一个地方可以<a href=http://discuss.kubernetes.io/c/announcements>宣布项目</a>，他们正在为用户工作，而不会想知道它是否会在官方列表中脱离主题。我们可以让这个地方不仅仅是关于核心 Kubernetes，而是关于我们社区正在建设的数百个精彩工具。</p><p>这个新的社区论坛为人们提供了一个可以讨论 Kubernetes 的地方，也是开发人员在 Kubernetes 周围发布事件的声音板，同时可以搜索并且更容易被更广泛的用户访问。</p><p>进来看看。我们刚刚开始，所以，您可能希望从<a href=http://discuss.kubernetes.io/t/introduce-yourself-here/56>自我介绍</a>开始，到处浏览。也有 <a href="http://play.google.com/store/apps/details?id=com.discourse&hl=en_US&rdid=com.discourse&pli=1">Android</a> 和 <a href="http://itunes.apple.com/us/app/discourse-app/id1173672076?mt=8">iOS</a> 应用下载。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-b1db29e1fa629592ea431f588f2145fc>在 Kubernetes 上开发</h1><div class="td-byline mb-4"><time datetime=2018-05-01 class=text-muted>2018.05.01</time></div><p><strong>作者</strong>： <a href=https://twitter.com/mhausenblas>Michael Hausenblas</a> (Red Hat), <a href=https://twitter.com/errordeveloper>Ilya Dmitrichenko</a> (Weaveworks)</p><p>您将如何开发一个 Kubernetes 应用？也就是说，您如何编写并测试一个要在 Kubernetes 上运行的应用程序？本文将重点介绍在独自开发或者团队协作中，您可能希望了解到的为了成功编写 Kubernetes 应用程序而需面临的挑战，工具和方法。</p><p>我们假定您是一位开发人员，有您钟爱的编程语言，编辑器/IDE（集成开发环境），以及可用的测试框架。在针对 Kubernetes 开发应用时，最重要的目标是减少对当前工作流程的影响，改变越少越好，尽量做到最小。举个例子，如果您是 Node.js 开发人员，习惯于那种热重载的环境 - 也就是说您在编辑器里一做保存，正在运行的程序就会自动更新 - 那么跟容器、容器镜像或者镜像仓库打交道，又或是跟 Kubernetes 部署、triggers 以及更多头疼东西打交道，不仅会让人难以招架也真的会让开发过程完全失去乐趣。</p><p>在下文中，我们将首先讨论 Kubernetes 总体开发环境，然后回顾常用工具，最后进行三个示例性工具的实践演练。这些工具允许针对 Kubernetes 进行本地应用程序的开发和迭代。</p><h2 id=您的集群运行在哪里>您的集群运行在哪里？</h2><p>作为开发人员，您既需要考虑所针对开发的 Kubernetes 集群运行在哪里，也需要思考开发环境如何配置。概念上，有四种开发模式：</p><p><img src=/images/blog/2018-05-01-developing-on-kubernetes/dok-devmodes_preview.png alt="Dev Modes"></p><p>许多工具支持纯 offline 开发，包括 Minikube、Docker（Mac 版/Windows 版）、Minishift 以及下文中我们将详细讨论的几种。有时，比如说在一个微服务系统中，已经有若干微服务在运行，proxied 模式（通过转发把数据流传进传出集群）就非常合适，Telepresence 就是此类工具的一个实例。live 模式，本质上是您基于一个远程集群进行构建和部署。最后，纯 online 模式意味着您的开发环境和运行集群都是远程的，典型的例子是 <a href=https://www.eclipse.org/che/docs/che-7/introduction-to-eclipse-che/>Eclipse Che</a> 或者 <a href=https://github.com/errordeveloper/k9c>Cloud 9</a>。现在让我们仔细看看离线开发的基础：在本地运行 Kubernetes。</p><p><a href=/docs/getting-started-guides/minikube/>Minikube</a> 在更加喜欢于本地 VM 上运行 Kubernetes 的开发人员中，非常受欢迎。不久前，Docker 的 <a href=https://docs.docker.com/docker-for-mac/kubernetes/>Mac</a> 版和 <a href=https://docs.docker.com/docker-for-windows/kubernetes/>Windows</a> 版，都试验性地开始自带 Kubernetes（需要下载 “edge” 安装包）。在两者之间，以下原因也许会促使您选择 Minikube 而不是 Docker 桌面版：</p><ul><li>您已经安装了 Minikube 并且它运行良好</li><li>您想等到 Docker 出稳定版本</li><li>您是 Linux 桌面用户</li><li>您是 Windows 用户，但是没有配有 Hyper-V 的 Windows 10 Pro</li></ul><p>运行一个本地集群，开发人员可以离线工作，不用支付云服务。云服务收费一般不会太高，并且免费的等级也有，但是一些开发人员不喜欢为了使用云服务而必须得到经理的批准，也不愿意支付意想不到的费用，比如说忘了下线而集群在周末也在运转。</p><p>有些开发人员却更喜欢远程的 Kubernetes 集群，这样他们通常可以获得更大的计算能力和存储容量，也简化了协同工作流程。您可以更容易的拉上一个同事来帮您调试，或者在团队内共享一个应用的使用。再者，对某些开发人员来说，尽可能的让开发环境类似生产环境至关重要，尤其是您依赖外部厂商的云服务时，如：专有数据库、云对象存储、消息队列、外商的负载均衡器或者邮件投递系统。</p><p>总之，无论您选择本地或者远程集群，理由都足够多。这很大程度上取决于您所处的阶段：从早期的原型设计/单人开发到后期面对一批稳定微服务的集成。</p><p>既然您已经了解到运行环境的基本选项，那么我们就接着讨论如何迭代式的开发并部署您的应用。</p><h2 id=常用工具>常用工具</h2><p>我们现在回顾既可以允许您可以在 Kubernetes 上开发应用程序又尽可能最小地改变您现有的工作流程的一些工具。我们致力于提供一份不偏不倚的描述，也会提及使用某个工具将会意味着什么。</p><p>请注意这很棘手，因为即使在成熟定型的技术中做选择，比如说在 JSON、YAML、XML、REST、gRPC 或者 SOAP 之间做选择，很大程度也取决于您的背景、喜好以及公司环境。在 Kubernetes 生态系统内比较各种工具就更加困难，因为技术发展太快，几乎每周都有新工具面市；举个例子，仅在准备这篇博客的期间，<a href=https://gitkube.sh/>Gitkube</a> 和 <a href=https://github.com/MinikubeAddon/watchpod>Watchpod</a> 相继出品。为了进一步覆盖到这些新的，以及一些相关的已推出的工具，例如 <a href=https://github.com/weaveworks/flux>Weave Flux</a> 和 OpenShift 的 <a href=https://docs.openshift.com/container-platform/3.9/creating_images/s2i.html>S2I</a>，我们计划再写一篇跟进的博客。</p><h3 id=draft>Draft</h3><p><a href=https://github.com/Azure/draft>Draft</a> 旨在帮助您将任何应用程序部署到 Kubernetes。它能够检测到您的应用所使用的编程语言，并且生成一份 Dockerfile 和 Helm 图表。然后它替您启动构建并且依照 Helm 图表把所生产的镜像部署到目标集群。它也可以让您很容易地设置到 localhost 的端口映射。</p><p>这意味着：</p><ul><li>用户可以任意地自定义 Helm 图表和 Dockerfile 模版，或者甚至创建一个 <a href=https://github.com/Azure/draft/blob/master/docs/reference/dep-003.md>custom pack</a>（使用 Dockerfile、Helm 图表以及其他）以备后用</li></ul><ul><li>要想理解一个应用应该怎么构建并不容易，在某些情况下，用户也许需要修改 Draft 生成的 Dockerfile 和 Heml 图表</li></ul><ul><li>如果使用 <a href=https://github.com/Azure/draft/releases/tag/v0.12.0>Draft version 0.12.0</a><sup>1</sup> 或者更老版本，每一次用户想要测试一个改动，他们需要等 Draft 把代码拷贝到集群，运行构建，推送镜像并且发布更新后的图表；这些步骤可能进行得很快，但是每一次用户的改动都会产生一个镜像（无论是否提交到 git ）</li></ul><ul><li>在 Draft 0.12.0版本，构建是本地进行的</li><li>用户不能选择 Helm 以外的工具进行部署</li><li>它可以监控本地的改动并且触发部署，但是这个功能默认是关闭的</li></ul><ul><li>它允许开发人员使用本地或者远程的 Kubernetes 集群</li><li>如何部署到生产环境取决于用户， Draft 的作者推荐了他们的另一个项目 - Brigade</li><li>可以代替 Skaffold， 并且可以和 Squash 一起使用</li></ul><p>更多信息：</p><ul><li><a href=https://kubernetes.io/blog/2017/05/draft-kubernetes-container-development>Draft: Kubernetes container development made easy</a></li><li><a href=https://github.com/Azure/draft/blob/master/docs/getting-started.md>Getting Started Guide</a></li></ul><p>【1】：此处疑为 0.11.0，因为 0.12.0 已经支持本地构建，见下一条</p><h3 id=skaffold>Skaffold</h3><p><a href=https://github.com/GoogleCloudPlatform/skaffold>Skaffold</a> 让 CI 集成具有可移植性的，它允许用户采用不同的构建系统，镜像仓库和部署工具。它不同于 Draft，同时也具有一定的可比性。它具有生成系统清单的基本能力，但那不是一个重要功能。Skaffold 易于扩展，允许用户在构建和部署应用的每一步选取相应的工具。</p><p>这意味着：</p><ul><li>模块化设计</li><li>不依赖于 CI，用户不需要 Docker 或者 Kubernetes 插件</li><li>没有 CI 也可以工作，也就是说，可以在开发人员的电脑上工作</li><li>它可以监控本地的改动并且触发部署</li></ul><ul><li>它允许开发人员使用本地或者远程的 Kubernetes 集群</li><li>它可以用于部署生产环境，用户可以精确配置，也可以为每一套目标环境提供不同的生产线</li><li>可以代替 Draft，并且和其他工具一起使用</li></ul><p>更多信息：</p><ul><li><a href=https://cloudplatform.googleblog.com/2018/03/introducing-Skaffold-Easy-and-repeatable-Kubernetes-development.html>Introducing Skaffold: Easy and repeatable Kubernetes development</a></li><li><a href=https://github.com/GoogleCloudPlatform/skaffold#getting-started-with-local-tooling>Getting Started Guide</a></li></ul><h3 id=squash>Squash</h3><p><a href=https://github.com/solo-io/squash>Squash</a> 包含一个与 Kubernetes 全面集成的调试服务器，以及一个 IDE 插件。它允许您插入断点和所有的调试操作，就像您所习惯的使用 IDE 调试一个程序一般。它允许您将调试器应用到 Kubernetes 集群中运行的 pod 上，从而让您可以使用 IDE 调试 Kubernetes 集群。</p><p>这意味着：</p><ul><li>不依赖您选择的其它工具</li><li>需要一组特权 DaemonSet</li><li>可以和流行 IDE 集成</li><li>支持 Go、Python、Node.js、Java 和 gdb</li></ul><ul><li>用户必须确保容器中的应用程序使编译时使用了调试符号</li><li>可与此处描述的任何其他工具结合使用</li><li>它可以与本地或远程 Kubernetes 集群一起使用</li></ul><p>更多信息：</p><ul><li><a href="https://www.youtube.com/watch?v=5TrV3qzXlgI">Squash: A Debugger for Kubernetes Apps</a></li><li><a href=https://squash.solo.io/overview/>Getting Started Guide</a></li></ul><h3 id=telepresence>Telepresence</h3><p><a href=https://www.telepresence.io/>Telepresence</a> 使用双向代理将开发人员工作站上运行的容器与远程 Kubernetes 集群连接起来，并模拟集群内环境以及提供对配置映射和机密的访问。它消除了将应用部署到集群的需要，并利用本地容器抽象出网络和文件系统接口，以使其看起来应用好像就在集群中运行，从而改进容器应用程序开发的迭代时间。</p><p>这意味着：</p><ul><li>它不依赖于其它您选取的工具</li><li>可以同 Squash 一起使用，但是 Squash 必须用于调试集群中的 pods，而传统/本地调试器需要用于调试通过 Telepresence 连接到集群的本地容器</li><li>Telepresence 会产生一些网络延迟</li></ul><ul><li>它通过辅助进程提供连接 - sshuttle，基于SSH的一个工具</li><li>还提供了使用 LD_PRELOAD/DYLD_INSERT_LIBRARIES 的更具侵入性的依赖注入模式</li><li>它最常用于远程 Kubernetes 集群，但也可以与本地集群一起使用</li></ul><p>更多信息：</p><ul><li><a href=https://www.telepresence.io/>Telepresence: fast, realistic local development for Kubernetes microservices</a></li><li><a href=https://www.telepresence.io/tutorials/docker>Getting Started Guide</a></li><li><a href=https://www.telepresence.io/discussion/how-it-works>How It Works</a></li></ul><h3 id=ksync>Ksync</h3><p><a href=https://github.com/vapor-ware/ksync>Ksync</a> 在本地计算机和运行在 Kubernetes 中的容器之间同步应用程序代码（和配置），类似于 <a href=https://docs.openshift.com/container-platform/3.9/dev_guide/copy_files_to_container.html>oc rsync</a> 在 OpenShift 中的角色。它旨在通过消除构建和部署步骤来缩短应用程序开发的迭代时间。</p><p>这意味着：</p><ul><li>它绕过容器图像构建和修订控制</li><li>使用编译语言的用户必须在 pod（TBC）内运行构建</li><li>双向同步 - 远程文件会复制到本地目录</li><li>每次更新远程文件系统时都会重启容器</li><li>无安全功能 - 仅限开发</li></ul><ul><li>使用 <a href=https://github.com/syncthing/syncthing>Syncthing</a>，一个用于点对点同步的 Go 语言库</li><li>需要一个在集群中运行的特权 DaemonSet</li><li>Node 必须使用带有 overlayfs2 的 Docker - 在写作本文时，尚不支持其他 CRI 实现</li></ul><p>更多信息：</p><ul><li><a href=https://github.com/vapor-ware/ksync#getting-started>Getting Started Guide</a></li><li><a href=https://github.com/vapor-ware/ksync/blob/master/docs/architecture.md>How It Works</a></li><li><a href=https://www.katacoda.com/vaporio/scenarios/ksync>Katacoda scenario to try out ksync in your browser</a></li><li><a href=https://docs.syncthing.net/specs/>Syncthing Specification</a></li></ul><h2 id=实践演练>实践演练</h2><p>我们接下来用于练习使用工具的应用是一个简单的<a href=https://github.com/kubernauts/dok-example-us>股市模拟器</a>，包含两个微服务：</p><ul><li><code>stock-gen</code>（股市数据生成器）微服务是用 Go 编写的，随机生成股票数据并通过 HTTP 端点 <code>/ stockdata</code> 公开</li><li>第二个微服务，<code>stock-con</code>（股市数据消费者）是一个 Node.js 应用程序，它使用来自 <code>stock-gen</code> 的股票数据流，并通过 HTTP 端点 <code>/average/$SYMBOL</code> 提供股价移动平均线，也提供一个健康检查端点 <code>/healthz</code>。</li></ul><p>总体上，此应用的默认配置如下图所示：</p><p><img src=/images/blog/2018-05-01-developing-on-kubernetes/dok-architecture_preview.png alt="Default Setup"></p><p>在下文中，我们将选取以上讨论的代表性工具进行实践演练：ksync，具有本地构建的 Minikube 以及 Skaffold。对于每个工具，我们执行以下操作：</p><ul><li>设置相应的工具，包括部署准备和 <code>stock-con</code> 微服务数据的本地读取</li><li>执行代码更新，即更改 <code>stock-con</code> 微服务的 <code>/healthz</code> 端点的源代码并观察网页刷新</li></ul><p>请注意，我们一直使用 Minikube 的本地 Kubernetes 集群，但是您也可以使用 ksync 和 Skaffold 的远程集群跟随练习。</p><h2 id=实践演练-ksync>实践演练：ksync</h2><p>作为准备，安装 <a href=https://vapor-ware.github.io/ksync/#installation>ksync</a>，然后执行以下步骤配置开发环境：</p><pre tabindex=0><code>$ mkdir -p $(pwd)/ksync
$ kubectl create namespace dok
$ ksync init -n dok
</code></pre><p>完成基本设置后，我们可以告诉 ksync 的本地客户端监控 Kubernetes 的某个命名空间，然后我们创建一个规范来定义我们想要同步的文件夹（本地的 <code>$(pwd)/ksync</code> 和容器中的 <code>/ app</code> ）。请注意，目标 pod 是用 selector 参数指定：</p><pre tabindex=0><code>$ ksync watch -n dok
$ ksync create -n dok --selector=app=stock-con $(pwd)/ksync /app
$ ksync get -n dok
</code></pre><p>现在我们部署股价数据生成器和股价数据消费者微服务：</p><pre tabindex=0><code>$ kubectl -n=dok apply \
      -f https://raw.githubusercontent.com/kubernauts/dok-example-us/master/stock-gen/app.yaml
$ kubectl -n=dok apply \
      -f https://raw.githubusercontent.com/kubernauts/dok-example-us/master/stock-con/app.yaml
</code></pre><p>一旦两个部署建好并且 pod 开始运行，我们转发 <code>stock-con</code> 服务以供本地读取（另开一个终端窗口）：</p><pre tabindex=0><code>$ kubectl get -n dok po --selector=app=stock-con  \
                     -o=custom-columns=:metadata.name --no-headers |  \
                     xargs -IPOD kubectl -n dok port-forward POD 9898:9898
</code></pre><p>这样，通过定期查询 <code>healthz</code> 端点，我们就应该能够从本地机器上读取 <code>stock-con</code> 服务，查询命令如下（在一个单独的终端窗口）：</p><pre tabindex=0><code>$ watch curl localhost:9898/healthz
</code></pre><p>现在，改动 <code>ksync/stock-con</code> 目录中的代码，例如改动 <a href=https://github.com/kubernauts/dok-example-us/blob/2334ee8fb11f8813370122bd46285cf45bdd4c48/stock-con/service.js#L52><code>service.js</code> 中定义的 <code>/healthz</code> 端点代码</a>，在其 JSON 形式的响应中新添一个字段并观察 pod 如何更新以及 <code>curl localhost：9898/healthz</code> 命令的输出发生何种变化。总的来说，您最后应该看到类似的内容：</p><p><img src=/images/blog/2018-05-01-developing-on-kubernetes/dok-ksync_preview.png alt=Preview></p><h3 id=实践演练-带本地构建的-minikube>实践演练：带本地构建的 Minikube</h3><p>对于以下内容，您需要启动并运行 Minikube，我们将利用 Minikube 自带的 Docker daemon 在本地构建镜像。作为准备，请执行以下操作</p><pre tabindex=0><code>$ git clone https://github.com/kubernauts/dok-example-us.git &amp;&amp; cd dok-example-us
$ eval $(minikube docker-env)
$ kubectl create namespace dok
</code></pre><p>现在我们部署股价数据生成器和股价数据消费者微服务：</p><pre tabindex=0><code>$ kubectl -n=dok apply -f stock-gen/app.yaml
$ kubectl -n=dok apply -f stock-con/app.yaml
</code></pre><p>一旦两个部署建好并且 pod 开始运行，我们转发 <code>stock-con</code> 服务以供本地读取（另开一个终端窗口）并检查 <code>healthz</code> 端点的响应：</p><pre tabindex=0><code>$ kubectl get -n dok po --selector=app=stock-con  \
                     -o=custom-columns=:metadata.name --no-headers |  \
                     xargs -IPOD kubectl -n dok port-forward POD 9898:9898 &amp;
$ watch curl localhost:9898/healthz
</code></pre><p>现在，改一下 <code>ksync/stock-con</code> 目录中的代码，例如修改 <a href=https://github.com/kubernauts/dok-example-us/blob/2334ee8fb11f8813370122bd46285cf45bdd4c48/stock-con/service.js#L52><code>service.js</code> 中定义的 <code>/healthz</code> 端点代码</a>，在其 JSON 形式的响应中添加一个字段。在您更新完代码后，最后一步是构建新的容器镜像并启动新部署，如下所示：</p><pre tabindex=0><code>$ docker build -t stock-con:dev -f Dockerfile .
$ kubectl -n dok set image deployment/stock-con *=stock-con:dev
</code></pre><p>总的来说，您最后应该看到类似的内容：</p><p><img src=/images/blog/2018-05-01-developing-on-kubernetes/dok-minikube-localdev_preview.png alt="Local Preview"></p><h3 id=实践演练-skaffold>实践演练：Skaffold</h3><p>要进行此演练，首先需要安装 <a href=https://github.com/GoogleContainerTools/skaffold#installation>Skaffold</a>。完成后，您可以执行以下步骤来配置开发环境：</p><pre tabindex=0><code>$ git clone https://github.com/kubernauts/dok-example-us.git &amp;&amp; cd dok-example-us
$ kubectl create namespace dok
</code></pre><p>现在我们部署股价数据生成器（但是暂不部署股价数据消费者，此服务将使用 Skaffold 完成）：</p><pre tabindex=0><code>$ kubectl -n=dok apply -f stock-gen/app.yaml
</code></pre><p>请注意，最初我们在执行 <code>skaffold dev</code> 时发生身份验证错误，为避免此错误需要安装<a href=https://github.com/GoogleContainerTools/skaffold/issues/322>问题322</a> 中所述的修复。本质上，需要将 <code>〜/.docker/config.json</code> 的内容改为：</p><pre tabindex=0><code>{
   &#34;auths&#34;: {}
}
</code></pre><p>接下来，我们需要略微改动 <code>stock-con/app.yaml</code>，这样 Skaffold 才能正常使用此文件：</p><p>在 <code>stock-con</code> 部署和服务中添加一个 <code>namespace</code> 字段，其值为 <code>dok</code></p><p>将容器规范的 <code>image</code> 字段更改为 <code>quay.io/mhausenblas/stock-con</code>，因为 Skaffold 可以即时管理容器镜像标签。</p><p>最终的 stock-con 的 <code>app.yaml</code> 文件看起来如下：</p><pre tabindex=0><code>apiVersion: apps/v1beta1
kind: Deployment
metadata:
  labels:
    app: stock-con
  name: stock-con
  namespace: dok
spec:
  replicas: 1
  template:
    metadata:
      labels:
        app: stock-con
    spec:
      containers:
      - name: stock-con
        image: quay.io/mhausenblas/stock-con
        env:
        - name: DOK_STOCKGEN_HOSTNAME
          value: stock-gen
        - name: DOK_STOCKGEN_PORT
          value: &#34;9999&#34;
        ports:
        - containerPort: 9898
          protocol: TCP
        livenessProbe:
          initialDelaySeconds: 2
          periodSeconds: 5
          httpGet:
            path: /healthz
            port: 9898
        readinessProbe:
          initialDelaySeconds: 2
          periodSeconds: 5
          httpGet:
            path: /healthz
            port: 9898
---
apiVersion: v1
kind: Service
metadata:
  labels:
    app: stock-con
  name: stock-con
  namespace: dok
spec:
  type: ClusterIP
  ports:
  - name: http
    port: 80
    protocol: TCP
    targetPort: 9898
  selector:
    app: stock-con
</code></pre><p>我们能够开始开发之前的最后一步是配置 Skaffold。因此，在 <code>stock-con/</code> 目录中创建文件 <code>skaffold.yaml</code>，其中包含以下内容：</p><pre tabindex=0><code>apiVersion: skaffold/v1alpha2
kind: Config
build:
  artifacts:
  - imageName: quay.io/mhausenblas/stock-con
    workspace: .
    docker: {}
  local: {}
deploy:
  kubectl:
    manifests:
      - app.yaml
</code></pre><p>现在我们准备好开始开发了。为此，在 <code>stock-con/</code> 目录中执行以下命令：</p><pre tabindex=0><code>$ skaffold dev
</code></pre><p>上面的命令将触发 <code>stock-con</code> 图像的构建和部署。一旦 <code>stock-con</code> 部署的 pod 开始运行，我们再次转发 <code>stock-con</code> 服务以供本地读取（在单独的终端窗口中）并检查 <code>healthz</code> 端点的响应：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ kubectl get -n dok po --selector<span style=color:#666>=</span><span style=color:#b8860b>app</span><span style=color:#666>=</span>stock-con  <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>                     -o<span style=color:#666>=</span>custom-columns<span style=color:#666>=</span>:metadata.name --no-headers |  <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>                     xargs -IPOD kubectl -n dok port-forward POD 9898:9898 &amp;
</span></span><span style=display:flex><span>$ watch curl localhost:9898/healthz
</span></span></code></pre></div><p>现在，如果您修改一下 <code>stock-con</code> 目录中的代码，例如 <a href=https://github.com/kubernauts/dok-example-us/blob/2334ee8fb11f8813370122bd46285cf45bdd4c48/stock-con/service.js#L52><code>service.js</code> 中定义的 <code>/healthz</code> 端点代码</a>，在其 JSON 形式的响应中添加一个字段，您应该看到 Skaffold 可以检测到代码改动并创建新图像以及部署它。您的屏幕看起来应该类似这样：</p><p><img src=/images/blog/2018-05-01-developing-on-kubernetes/dok-skaffold_preview.png alt="Skaffold Preview"></p><p>至此，您应该对不同的工具如何帮您在 Kubernetes 上开发应用程序有了一定的概念，如果您有兴趣了解有关工具和/或方法的更多信息，请查看以下资源：</p><ul><li>Blog post by Shahidh K Muhammed on <a href=https://blog.hasura.io/draft-vs-gitkube-vs-helm-vs-ksonnet-vs-metaparticle-vs-skaffold-f5aa9561f948>Draft vs Gitkube vs Helm vs Ksonnet vs Metaparticle vs Skaffold</a> (03/2018)</li><li>Blog post by Gergely Nemeth on <a href=https://nemethgergely.com/using-kubernetes-for-local-development/index.html>Using Kubernetes for Local Development</a>, with a focus on Skaffold (03/2018)</li><li>Blog post by Richard Li on <a href=https://hackernoon.com/locally-developing-kubernetes-services-without-waiting-for-a-deploy-f63995de7b99>Locally developing Kubernetes services (without waiting for a deploy)</a>, with a focus on Telepresence</li><li>Blog post by Abhishek Tiwari on <a href=https://abhishek-tiwari.com/local-development-environment-for-kubernetes-using-minikube/>Local Development Environment for Kubernetes using Minikube</a> (09/2017)</li><li>Blog post by Aymen El Amri on <a href=https://medium.com/devopslinks/using-kubernetes-minikube-for-local-development-c37c6e56e3db>Using Kubernetes for Local Development — Minikube</a> (08/2017)</li><li>Blog post by Alexis Richardson on <a href=https://www.weave.works/blog/gitops-operations-by-pull-request>​GitOps - Operations by Pull Request</a> (08/2017)</li><li>Slide deck <a href=https://docs.google.com/presentation/d/1d3PigRVt_m5rO89Ob2XZ16bW8lRSkHHH5k816-oMzZo/>GitOps: Drive operations through git</a>, with a focus on Gitkube by Tirumarai Selvan (03/2018)</li><li>Slide deck <a href=https://speakerdeck.com/mhausenblas/developing-apps-on-kubernetes>Developing apps on Kubernetes</a>, a talk Michael Hausenblas gave at a CNCF Paris meetup (04/2018)</li><li>YouTube videos:<ul><li><a href="https://www.youtube.com/watch?v=QW85Y0Ug3KY">TGI Kubernetes 029: Developing Apps with Ksync</a></li><li><a href="https://www.youtube.com/watch?v=McwwWhCXMxc">TGI Kubernetes 030: Exploring Skaffold</a></li><li><a href="https://www.youtube.com/watch?v=zezeBAJ_3w8">TGI Kubernetes 031: Connecting with Telepresence</a></li><li><a href="https://www.youtube.com/watch?v=8B1D7cTMPgA">TGI Kubernetes 033: Developing with Draft</a></li></ul></li><li>Raw responses to the <a href=https://docs.google.com/spreadsheets/d/12ilRCly2eHKPuicv1P_BD6z__PXAqpiaR-tDYe2eudE/edit>Kubernetes Application Survey</a> 2018 by SIG Apps</li></ul><p>有了这些，我们这篇关于如何在 Kubernetes 上开发应用程序的博客就可以收尾了，希望您有所收获，如果您有反馈和/或想要指出您认为有用的工具，请通过 Twitter 告诉我们：<a href=https://twitter.com/errordeveloper>Ilya</a> 和 <a href=https://twitter.com/mhausenblas>Michael</a></p></div><div class=td-content style=page-break-before:always><h1 id=pg-0b6913088687941c6716b37e47562f16>Kubernetes 社区 - 2017 年开源排行榜榜首</h1><div class="td-byline mb-4"><time datetime=2018-04-25 class=text-muted>2018.04.25</time></div><p>对于 Kubernetes 来说，2017 年是丰收的一年，GitHub的最新 <a href=https://octoverse.github.com>Octoverse 报告</a> 说明了该项目获得了多少关注。</p><p>Kubernetes 是 <a href=/docs/concepts/overview/what-is-kubernetes/>用于运行应用程序容器的开源平台</a>，它提供了一个统一的界面，使开发人员和操作团队能够自动执行部署、管理和扩展几乎任何基础架构上的各种应用程序。</p><p>Kubernetes 所做的，是通过利用广泛的专业知识和行业经验来解决这些共同的挑战，可以帮助工程师专注于在堆栈的顶部构建自己的产品，而不是不必要地进行重复工作，比如现在已经存在的 “云原生” 工具包的标准部分。</p><p>但是，通过临时的集体组织来实现这些收益是它独有的挑战，这使得支持开源，社区驱动的工作变得越来越困难。</p><p>继续阅读以了解 Kubernetes 社区如何解决这些挑战，从而在 GitHub 的 2017 Octoverse 报告中位居榜首。</p><h2 id=github-上讨论最多的>GitHub 上讨论最多的</h2><p>2017 年讨论最多的两个仓库都是基于 Kubernetes 的：</p><p>！<a href=/images/blog-logging/2018-04-24-open-source-charts-2017/most-discussed.png>讨论最多</a></p><p>在 GitHub 的所有开源存储库中，没有比 <a href=https://github.com/kubernetes/kubernetes/>kubernetes/kubernetes</a> 收到更多的评论。 <a href=http://openshift.com/>OpenShift</a>， <a href=https://www.cncf.io/announcement/2017/11/13/cloud-native-computing-foundation-launches-certified-kubernetes-program-32-conformant-distributions-platforms/>CNCF 认证的 Kubernetes 发行版</a> 排名第二。</p><p>利用充足时间进行公开讨论来获取社区反馈和审查，有助于建立共享的基础架构并为云原生计算建立新标准。</p><h2 id=github-上审阅最多的>GitHub 上审阅最多的</h2><p>成功扩展开放源代码工作的通信通常会带来更好的协调和更高质量的功能交付。Kubernetes 项目的 <a href=https://github.com/kubernetes/community/blob/master/sig-list.md>Special Interest Group（SIG）</a> 结构已使其成为 GitHub 审阅第二多的项目：</p><p>！<a href=/images/blog-logging/2018-04-24-open-source-charts-2017/most-reviews.png>审阅最多</a></p><p>使用 SIG 对社区参与机制进行细分和标准化有助于从资格更高的社区成员中获得更频繁的审阅。</p><p>如果得到有效管理，活跃的社区讨论不仅表明代码库存在很大的争议，也可能表明项目包含大量未满足的需求。</p><p>扩展项目处理问题和社区互动的能力有助于扩大交流。同时，大型社区具有更多不同的用例和更多的支持问题需要管理。Kubernetes <a href=https://github.com/kubernetes/community#sigs>SIG 组织结构</a> 帮助应对大规模复杂通信的挑战。</p><p>SIG 会议为不同学科的用户、维护者和专家提供了重点合作的机会，以共同协作来支持社区的工作。这些在组织上的投资有助于创建一个环境，在这样的环境中，可以更轻松地将架构讨论和规划的优先级排到提交速度前面，并使项目能够维持这种规模。</p><h2 id=加入我们>加入我们！</h2><p>您可能已经在 Kubernetes 上成功使用管理和扩展的解决方案。例如，托管 Kubernetes 上游源代码的 GitHub.com <a href=https://githubengineering.com/kubernetes-at-github/>现在也可以在 Kubernetes 上运行</a> ！</p><p>请查看 <a href=https://github.com/kubernetes/community/blob/master/contributors/guide/README.md>Kubernetes 贡献者指南</a> ，以获取有关如何开始作为贡献者的更多信息。</p><p>您也可以参加 <a href=https://github.com/kubernetes/community/tree/master/communication#weekly-meeting>每周 Kubernetes 的社区会议</a> 并考虑 <a href=https://github.com/kubernetes/community/blob/master/sig-list.md#master-sig-list>加入一个或两个 SIG</a>。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-58315accba126f61921f8cdcf34ab405>“基于容器的应用程序设计原理”</h1><div class="td-byline mb-4"><time datetime=2018-03-15 class=text-muted>2018.03.15</time></div><p>如今，可以将几乎所有应用程序放入容器中并运行它。
但是，创建云原生应用程序（由 Kubernetes 等云原生平台自动有效地编排的容器化应用程序）需要付出额外的努力。
云原生应用程序会预期失败；
它们可以可靠的运行和扩展，即使基础架构出现故障。
为了提供这样的功能，像 Kubernetes 这样的云原生平台对应用程序施加了一系列约定和约束。
这些合同确保运行的应用程序符合某些约束条件，并允许平台自动执行应用程序管理。</p><p>我总结了容器化应用要成为彻底的云原生应用所要遵从的<a href=https://www.redhat.com/en/resources/cloud-native-container-design-whitepaper>七个原则</a>。</p><p>| ----- |
| <img src=https://lh5.googleusercontent.com/1XqojkVC0CET1yKCJqZ3-0VWxJ3W8Q74zPLlqnn6eHSJsjHOiBTB7EGUX5o_BOKumgfkxVdgBeLyoyMfMIXwVm9p2QXkq_RRy2mDJG1qEExJDculYL5PciYcWfPAKxF2-DGIdiLw alt> |</p><p>| 容器设计原则 |</p><p>这七个原则涵盖了构建时间和运行时问题。</p><h4 id=建立时间>建立时间</h4><ul><li><strong>单独关注点：</strong> 每个容器都解决了一个单独的关注点，并做到了。</li></ul><ul><li><strong>自包含：</strong> 容器仅依赖于Linux内核的存在。 构建容器时会添加其他库。</li></ul><ul><li><strong>镜像不可变性：</strong> 容器化应用程序是不可变的，并且一旦构建，就不会在不同环境之间发生变化。</li></ul><h4 id=运行时>运行时</h4><ul><li><strong>高度可观察性：</strong> 每个容器都必须实现所有必要的API，以帮助平台以最佳方式观察和管理应用程序。</li></ul><ul><li><strong>生命周期一致性：</strong> 容器必须具有读取来自平台的事件并通过对这些事件做出反应来进行一致性的方式。</li></ul><ul><li><strong>进程可丢弃：</strong> 容器化的应用程序必须尽可能短暂，并随时可以被另一个容器实例替换。</li></ul><ul><li><strong>运行时可约束</strong> 每个容器必须声明其资源需求，并根据所标明的需求限制其资源使用。
构建时间原则可确保容器具有正确的颗粒度，一致性和适当的结构。
运行时原则规定了必须执行哪些功能才能使容器化的应用程序具有云原生功能。
遵循这些原则有助于确保您的应用程序适合Kubernetes中的自动化。</li></ul><p>白皮书可以免费下载：</p><p>要了解有关为Kubernetes设计云原生应用程序的更多信息，请翻阅我的<a href=http://leanpub.com/k8spatterns/>Kubernetes 模式</a>这本书。</p><p>— <a href=http://twitter.com/bibryam>Bilgin Ibryam</a>，首席架构师，Red Hat</p><p>推特：<br>博客： <a href=http://www.ofbizian.com/>http://www.ofbizian.com</a><br>领英：</p><p>Bilgin Ibryam（@bibryam）是 Red Hat 的首席架构师，ASF 的开源提交者，博客，作者和发言人。
他是骆驼设计模式和 Kubernetes 模式书籍的作者。
在日常工作中，Bilgin 乐于指导，培训和领导团队，以使他们在分布式系统，微服务，容器和云原生应用程序方面取得成功。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-f018685bed3dd1eaad90e61436e60e10>Kubernetes 1.9 对 Windows Server 容器提供 Beta 版本支持</h1><div class="td-byline mb-4"><time datetime=2018-01-09 class=text-muted>2018.01.09</time></div><p>随着 Kubernetes v1.9 的发布，我们确保所有人在任何地方都能正常运行 Kubernetes 的使命前进了一大步。我们的 Beta 版本对 Windows Server 的支持进行了升级，并且在 Kubernetes 和 Windows 平台上都提供了持续的功能改进。为了在 Kubernetes 上运行许多特定于 Windows 的应用程序和工作负载，SIG-Windows 自2016年3月以来一直在努力，大大扩展了 Kubernetes 的实现场景和企业适用范围。</p><p>各种规模的企业都在 .NET 和基于 Windows 的应用程序上进行了大量投资。如今许多企业产品组合都包含 .NET 和 Windows，Gartner 声称 <a href=http://www.gartner.com/document/3446217>80%</a> 的企业应用都在 Windows 上运行。根据 StackOverflow Insights，40% 的专业开发人员使用 .NET 编程语言（包括 .NET Core）。</p><p>但为什么这些信息都很重要？这意味着企业既有传统的，也有新生的云（microservice）应用程序，利用了大量的编程框架。业界正在大力推动将现有/遗留应用程序现代化到容器中，使用类似于“提升和转移”的方法。同时，也能灵活地向其他 Windows 或 Linux 容器引入新功能。容器正在成为打包、部署和管理现有程序和微服务应用程序的业界标准。IT 组织正在寻找一种更简单且一致的方法来跨 Linux 和 Windows 环境进行协调和管理容器。Kubernetes v1.9 现在对 Windows Server 容器提供了 Beta 版本支持，使之成为策划任何类型容器的明确选择。</p><h3 id=特点>特点</h3><p>Kubernetes 中对 Windows Server 容器的 Alpha 支持是非常有用的，尤其是对于概念项目和可视化 Kubernetes 中 Windows 支持的路线图。然而，Alpha 版本有明显的缺点，并且缺少许多特性，特别是在网络方面。SIG Windows、Microsoft、Cloudbase Solutions、Apprenda 和其他社区成员联合创建了一个全面的 Beta 版本，使 Kubernetes 用户能够开始评估和使用 Windows。</p><p>Kubernetes 对 Windows 服务器容器的一些关键功能改进包括：</p><ul><li>改进了对 Pod 的支持！Pod 中多个 Windows Server 容器现在可以使用 Windows Server 中的网络隔离专区共享网络命名空间。此功能中 Pod 的概念相当于基于 Linux 的容器</li><li>可通过每个 Pod 使用单个网络端点来降低网络复杂性</li><li>可以使用 Virtual Filtering Platform（VFP）的 Hyper-v Switch Extension（类似于 Linux iptables）达到基于内核的负载平衡</li><li>具备 Container Runtime Interface（CRI）的 Pod 和 Node 级别的统计信息。可以使用从 Pod 和节点收集的性能指标配置 Windows Server 容器的 Horizontal Pod Autoscaling</li></ul><ul><li>支持 kubeadm 命令将 Windows Server 的 Node 添加到 Kubernetes 环境。Kubeadm 简化了 Kubernetes 集群的配置，通过对 Windows Server 的支持，您可以在您的基础配置中使用单一的工具部署 Kubernetes</li><li>支持 ConfigMaps, Secrets, 和 Volumes。这些是非常关键的特性，您可以将容器的配置从实施体系中分离出来，并且在大部分情况下是安全的<br>然而，kubernetes 1.9 windows 支持的最大亮点是网络增强。随着 Windows 服务器 1709 的发布，微软在操作系统和 Windows Host Networking Service（HNS）中启用了关键的网络功能，这为创造大量与 Kubernetes 中的 Windows 服务器容器一起工作的 CNI 插件铺平了道路。Kubernetes 1.9 支持的第三层路由和网络覆盖插件如下所示：</li></ul><ol><li>上游 L3 路由 - 上游 ToR 中配置的 IP 路由</li><li>Host-Gateway - 在每个主机上配置的 IP 路由</li><li>具有 Overlay 的 Open vSwitch（OVS）和 Open Virtual Network（OVN） - 支持 STT 和 Geneve 的 tunneling 类型
您可以阅读更多有关 <a href=/docs/getting-started-guides/windows/>配置、设置和运行时功能</a> 的信息，以便在 Kubernetes 中为您的网络堆栈做出明智的选择。</li></ol><p>如果您需要继续在 Linux 中运行 Kubernetes Control Plane 和 Master Components，现在也可以将 Windows Server 作为 Kubernetes 中的一个节点引入。对一个社区来说，这是一个巨大的里程碑和成就。现在，我们将会在 Kubernetes 中看到 .NET，.NET Core，ASP.NET，IIS，Windows 服务，Windows 可执行文件以及更多基于 Windows 的应用程序。</p><h3 id=接下来还会有什么>接下来还会有什么</h3><p>这个 Beta 版本进行了大量工作，但是社区意识到在将 Windows 支持作为生产工作负载发布为 GA（General Availability）之前，我们需要更多领域的投资。2018年前两个季度的重点关注领域包括：</p><ol><li>继续在网络领域取得更多进展。其他 CNI 插件正在开发中，并且即将完成</li></ol><ul><li>Overlay - win-Overlay（vxlan 或 IP-in-IP 使用 Flannel 封装）</li><li>Win-l2bridge（host-gateway）</li><li>使用云网络的 OVN - 不再依赖 Overlay</li><li>在 ovn-Kubernetes 中支持 Kubernetes 网络策略</li><li>支持 Hyper-V Isolation</li><li>支持有状态应用程序的 StatefulSet 功能</li><li>生成适用于任何基础架构以及跨多公共云提供商（例如 Microsoft Azure，Google Cloud 和 Amazon AWS）的安装工具和文档</li><li>SIG-Windows 的 Continuous Integration/Continuous Delivery（CI/CD）基础结构</li><li>可伸缩性和性能测试
尽管我们尚未承诺正式版的具体时间线，但估计 SIG-Windows 将于2018年上半年正式发布。</li></ul><h3 id=加入我们>加入我们</h3><p>随着我们在 Kubernetes 的普遍可用性方向不断取得进展，我们欢迎您参与进来，贡献代码、提供反馈，将 Windows 服务器容器部署到 Kubernetes 集群，或者干脆加入我们的社区。</p><ul><li>如果你想要开始在 Kubernetes 中部署 Windows Server 容器，请阅读我们的开始导览 <a href=/docs/getting-started-guides/windows/>/docs/getting-started-guides/windows/</a></li><li>我们每隔一个星期二在美国东部标准时间（EST）的12:30在 <a href=https://zoom.us/my/sigwindows>https://zoom.us/my/sigwindows</a> 开会。所有会议内容都记录在 Youtube 并附上了参考材料 <a href="https://www.youtube.com/playlist?list=PL69nYSiGNLP2OH9InCcNkWNu2bl-gmIU4">https://www.youtube.com/playlist?list=PL69nYSiGNLP2OH9InCcNkWNu2bl-gmIU4</a></li><li>通过 Slack 联系我们 <a href=https://kubernetes.slack.com/messages/sig-windows>https://kubernetes.slack.com/messages/sig-windows</a></li><li>在 Github 上找到我们 <a href=https://github.com/kubernetes/community/tree/master/sig-windows>https://github.com/kubernetes/community/tree/master/sig-windows</a></li></ul><p>谢谢大家，</p><p>Michael Michael (@michmike77)<br>SIG-Windows 领导人<br>Apprenda 产品管理高级总监</p></div><div class=td-content style=page-break-before:always><h1 id=pg-bb3ab16fad15d53ca096effeae4cc253>Kubernetes 中自动缩放</h1><div class="td-byline mb-4"><time datetime=2017-11-17 class=text-muted>2017.11.17</time></div><p>Kubernetes 允许开发人员根据当前的流量和负载自动调整集群大小和 pod 副本的数量。这些调整减少了未使用节点的数量，节省了资金和资源。
在这次演讲中，谷歌的 Marcin Wielgus 将带领您了解 Kubernetes 中 pod 和 node 自动调焦的当前状态：它是如何工作的，以及如何使用它，包括在生产应用程序中部署的最佳实践。</p><p>喜欢这个演讲吗？ 12 月 6 日至 8 日，在 Austin 参加 KubeCon 关于扩展和自动化您的 Kubernetes 集群的更令人兴奋的会议。<a href="https://www.eventbrite.com/e/kubecon-cloudnativecon-north-america-registration-37824050754?_ga=2.9666039.317115486.1510003873-1623727562.1496428006">现在注册</a>。</p><p>一定要查看由 Ron Lipke， Gannet/USA Today Network, 平台即服务高级开发人员，在<a href=http://sched.co/CU64>公共云中自动化和测试产品就绪的 Kubernetes 集群</a>。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-bccec10413bd4f89b97d497368323e1b>Kubernetes 1.8 的五天</h1><div class="td-byline mb-4"><time datetime=2017-10-24 class=text-muted>2017.10.24</time></div><p>Kubernetes 1.8 已经推出，数百名贡献者在这个最新版本中推出了成千上万的提交。</p><p>社区已经有超过 66,000 个提交在主仓库，并在主仓库之外继续快速增长，这标志着该项目日益成熟和稳定。仅 v1.7.0 到 v1.8.0，社区就记录了所有仓库的超过 120,000 次提交和 17839 次提交。</p><p>在拥有 1400 多名贡献者，并且不断发展壮大的社区的帮助下，我们合并了 3000 多个 PR，并发布了 5000 多个提交，最后的 Kubernetes 1.8 在安全和工作负载方面添加了很多的更新。
这一切都表明稳定性的提高，这是我们整个项目关注成熟<a href=https://github.com/kubernetes/sig-release>流程</a>、形式化<a href=https://github.com/kubernetes/community/tree/master/sig-architecture>架构</a>和加强 Kubernetes 的<a href=https://github.com/kubernetes/community/tree/master/community/elections/2017>治理模型</a>的结果。</p><p>虽然有很多改进，但我们在下面列出的这一系列深度文章中突出了一些关键特性。<a href=https://twitter.com/kubernetesio>跟随</a>并了解存储，安全等方面的新功能和改进功能。</p><p><strong>第一天：</strong> <a href=https://kubernetes.io/blog/2017/10/five-days-of-kubernetes-18>Kubernetes 1.8 的五天</a>
<strong>第二天：</strong> <a href=https://kubernetes.io/blog/2017/10/kubeadm-v18-released>kubeadm v1.8 为 Kubernetes 集群引入了简单的升级</a>
<strong>第三天：</strong> <a href=https://kubernetes.io/blog/2017/10/it-takes-village-to-raise-kubernetes>Kubernetes v1.8 回顾：提升一个 Kubernetes 需要一个 Village</a>
<strong>第四天：</strong> <a href=https://kubernetes.io/blog/2017/10/using-rbac-generally-available-18>使用 RBAC，一般在 Kubernetes v1.8 中提供</a>
<strong>第五天：</strong> <a href=https://kubernetes.io/blog/2017/10/enforcing-network-policies-in-kubernetes>在 Kubernetes 执行网络策略</a></p><p><strong>链接</strong></p><ul><li>在 <a href=http://stackoverflow.com/questions/tagged/kubernetes>Stack Overflow</a> 上发布问题（或回答问题）</li><li>加入 <a href=http://k8sport.org/>K8sPort</a> 布道师的社区门户网站</li><li>在 Twitter <a href=https://twitter.com/kubernetesio>@Kubernetesio</a> 关注我们以获取最新更新</li><li>与 <a href=http://slack.k8s.io/>Slack</a> 上的社区联系</li><li>参与 <a href=https://github.com/kubernetes/kubernetes>GitHub</a> 上的 Kubernetes 项目</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-b7983d3e161ebbda5791cc9abf7d749d>Kubernetes 社区指导委员会选举结果</h1><div class="td-byline mb-4"><time datetime=2017-10-05 class=text-muted>2017.10.05</time></div><p>自 2015 年 OSCON 发布 Kubernetes 1.0 以来，大家一直在共同努力，在 Kubernetes 社区中共同分享领导力和责任。</p><p>在 Brandon Philips、Brendan Burns、Brian Grant、Clayton Coleman、Joe Beda、Sarah Novotny 和 Tim Hockin 组成的自举治理委员会的工作下 - 代表 5 家不同公司的长期领导者，他们对 Kubernetes 生态系统进行了大量的人才投资和努力 - 编写了初始的<a href=https://github.com/kubernetes/steering/blob/master/charter.md>指导委员会章程</a>，并发起了一次社区选举，以选举 Kubernetes 指导委员会成员。</p><p>引用章程 -</p><p>_指导委员会的最初职责是<strong>实例化 Kubernetes 治理的正式过程</strong>。除定义初始治理过程外，指导委员会还坚信<strong>提供一种方法来迭代指导委员会定义的方法很重要</strong>。我们不相信我们会在第一次或以后把这些做好，也不会一口气完成治理开发工作。指导委员会的作用是成为一个积极响应的机构，可以根据需要进行重构和改造，以适应不断变化的项目和社区。</p><p>这是将我们隐式治理结构明确化的最大一步。Kubernetes 的愿景一直是成为一个包容而广泛的社区，用我们的软件带给用户容器的便利性。指导委员会将是一个强有力的引领声音，指导该项目取得成功。</p><p>Kubernetes 社区很高兴地宣布 2017 年指导委员会选举的结果。 <strong>请祝贺 Aaron Crickenberger、Derek Carr、Michelle Noorali、Phillip Wittrock、Quinton Hoole 和 Timothy St. Clair</strong>，他们将成为新成立的 Kubernetes 指导委员会的自举治理委员会成员。Derek、Michelle 和 Phillip 将任职 2 年。Aaron、Quinton、和 Timothy 将任职 1 年。</p><p>该小组将定期开会，以阐明和简化项目的结构和运行。早期的工作将包括选举 CNCF 理事会的代表，发展项目流程，完善和记录项目的愿景和范围，以及授权和委派更多主题社区团体。</p><p>请参阅<a href=https://github.com/kubernetes/steering/blob/master/backlog.md>完整的指导委员会待办事项列表</a>以获取更多详细信息。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-0bdd9be1eea1fe9ccb870ef33266eb15>使用 Kubernetes Pet Sets 和 Datera Elastic Data Fabric 的 FlexVolume 扩展有状态的应用程序</h1><div class="td-byline mb-4"><time datetime=2016-08-29 class=text-muted>2016.08.29</time></div><p><em>编者注：今天的邀请帖子来自 Datera 公司的软件架构师 Shailesh Mittal 和高级产品总监 Ashok Rajagopalan，介绍在 Datera Elastic Data Fabric 上用 Kubernetes 配置状态应用程序。</em></p><p><strong>简介</strong></p><p>用户从无状态工作负载转移到运行有状态应用程序，Kubernetes 中的持久卷是基础。虽然 Kubernetes 早已支持有状态的应用程序，比如 MySQL、Kafka、Cassandra 和 Couchbase，但是 Pet Sets 的引入明显改善了情况。特别是，<a href=/docs/user-guide/petset/>Pet Sets</a> 具有持续扩展和关联的能力，在配置和启动的顺序过程中，可以自动缩放“Pets”（需要连续处理和持久放置的应用程序）。</p><p>Datera 是用于云部署的弹性块存储，可以通过 <a href=/docs/user-guide/volumes/#flexvolume>FlexVolume</a> 框架与 <a href=http://datera.io/blog-library/8/19/datera-simplifies-stateful-containers-on-kubernetes-13>Kubernetes 无缝集成</a>。基于容器的基本原则，Datera 允许应用程序的资源配置与底层物理基础架构分离，为有状态的应用程序提供简洁的协议（也就是说，不依赖底层物理基础结构及其相关内容）、声明式格式和最后移植的能力。</p><p>Kubernetes 可以通过 yaml 配置来灵活定义底层应用程序基础架构，而 Datera 可以将该配置传递给存储基础结构以提供持久性。通过 Datera AppTemplates 声明，在 Kubernetes 环境中，有状态的应用程序可以自动扩展。</p><p><strong>部署永久性存储</strong></p><p>永久性存储是通过 Kubernetes 的子系统 <a href=/docs/user-guide/persistent-volumes/#persistent-volumes>PersistentVolume</a> 定义的。PersistentVolumes 是卷插件，它定义的卷的生命周期和使用它的 Pod 相互独立。PersistentVolumes 由 NFS、iSCSI 或云提供商的特定存储系统实现。Datera 开发了用于 PersistentVolumes 的卷插件，可以在 Datera Data Fabric 上为 Kubernetes 的 Pod 配置 iSCSI 块存储。</p><p>Datera 卷插件从 minion nodes 上的 kubelet 调用，并通过 REST API 回传到 Datera Data Fabric。以下是带有 Datera 插件的 PersistentVolume 的部署示例：</p><pre tabindex=0><code> apiVersion: v1

 kind: PersistentVolume

 metadata:

   name: pv-datera-0

 spec:

   capacity:

     storage: 100Gi

   accessModes:

     - ReadWriteOnce

   persistentVolumeReclaimPolicy: Retain

   flexVolume:

     driver: &#34;datera/iscsi&#34;

     fsType: &#34;xfs&#34;

     options:

       volumeID: &#34;kube-pv-datera-0&#34;

       size: “100&#34;

       replica: &#34;3&#34;

       backstoreServer: &#34;[tlx170.tlx.daterainc.com](http://tlx170.tlx.daterainc.com/):7717”
</code></pre><p>为 Pod 申请 PersistentVolume，要按照以下清单在 Datera Data Fabric 中配置 100 GB 的 PersistentVolume。</p><pre tabindex=0><code>[root@tlx241 /]# kubectl get pv

NAME          CAPACITY   ACCESSMODES   STATUS      CLAIM     REASON    AGE

pv-datera-0   100Gi        RWO         Available                       8s

pv-datera-1   100Gi        RWO         Available                       2s

pv-datera-2   100Gi        RWO         Available                       7s

pv-datera-3   100Gi        RWO         Available                       4s
</code></pre><p><strong>配置</strong></p><p>Datera PersistenceVolume 插件安装在所有 minion node 上。minion node 的声明是绑定到之前设置的永久性存储上的，当 Pod 进入具备有效声明的 minion node 上时，Datera 插件会转发请求，从而在 Datera Data Fabric 上创建卷。根据配置请求，PersistentVolume 清单中所有指定的选项都将发送到插件。</p><p>在 Datera Data Fabric 中配置的卷会作为 iSCSI 块设备呈现给 minion node，并且 kubelet 将该设备安装到容器（在 Pod 中）进行访问。</p><p><img src=https://lh4.googleusercontent.com/ILlUm1HrWhGa8uTt97dQ786Gn20FHFZkavfucz05NHv6moZWiGDG7GlELM6o4CSzANWvZckoAVug5o4jMg17a-PbrfD1FRbDPeUCIc8fKVmVBNUsUPshWanXYkBa3gIJy5BnhLmZ alt></p><p><strong>使用永久性存储</strong></p><p>Kubernetes PersistentVolumes 与具备 PersistentVolume Claims 的 Pod 一起使用。定义声明后，会被绑定到与声明规范匹配的 PersistentVolume 上。上面提到的定义 PersistentVolume 的典型声明如下所示：</p><pre tabindex=0><code>kind: PersistentVolumeClaim

apiVersion: v1

metadata:

 name: pv-claim-test-petset-0

spec:

 accessModes:

   - ReadWriteOnce

 resources:

   requests:

     storage: 100Gi
</code></pre><p>定义这个声明并将其绑定到 PersistentVolume 时，资源与 Pod 规范可以一起使用：</p><pre tabindex=0><code>[root@tlx241 /]# kubectl get pv

NAME          CAPACITY   ACCESSMODES   STATUS      CLAIM                            REASON    AGE

pv-datera-0   100Gi      RWO           Bound       default/pv-claim-test-petset-0             6m

pv-datera-1   100Gi      RWO           Bound       default/pv-claim-test-petset-1             6m

pv-datera-2   100Gi      RWO           Available                                              7s

pv-datera-3   100Gi      RWO           Available                                              4s


[root@tlx241 /]# kubectl get pvc

NAME                     STATUS    VOLUME        CAPACITY   ACCESSMODES   AGE

pv-claim-test-petset-0   Bound     pv-datera-0   0                        3m

pv-claim-test-petset-1   Bound     pv-datera-1   0                        3m
</code></pre><p>Pod 可以使用 PersistentVolume 声明，如下所示：</p><pre tabindex=0><code>apiVersion: v1

kind: Pod

metadata:

 name: kube-pv-demo

spec:

 containers:

 - name: data-pv-demo

   image: nginx

   volumeMounts:

   - name: test-kube-pv1

     mountPath: /data

   ports:

   - containerPort: 80

 volumes:

 - name: test-kube-pv1

   persistentVolumeClaim:

     claimName: pv-claim-test-petset-0
</code></pre><p>程序的结果是 Pod 将 PersistentVolume Claim 作为卷。依次将请求发送到 Datera 卷插件，然后在 Datera Data Fabric 中配置存储。</p><pre tabindex=0><code>[root@tlx241 /]# kubectl describe pods kube-pv-demo

Name:       kube-pv-demo

Namespace:  default

Node:       tlx243/172.19.1.243

Start Time: Sun, 14 Aug 2016 19:17:31 -0700

Labels:     \&lt;none\&gt;

Status:     Running

IP:         10.40.0.3

Controllers: \&lt;none\&gt;

Containers:

 data-pv-demo:

   Container ID: [docker://ae2a50c25e03143d0dd721cafdcc6543fac85a301531110e938a8e0433f74447](about:blank)

   Image:   nginx

   Image ID: [docker://sha256:0d409d33b27e47423b049f7f863faa08655a8c901749c2b25b93ca67d01a470d](about:blank)

   Port:    80/TCP

   State:   Running

     Started:  Sun, 14 Aug 2016 19:17:34 -0700

   Ready:   True

   Restart Count:  0

   Environment Variables:  \&lt;none\&gt;

Conditions:

 Type           Status

 Initialized    True

 Ready          True

 PodScheduled   True

Volumes:

 test-kube-pv1:

   Type:  PersistentVolumeClaim (a reference to a PersistentVolumeClaim in the same namespace)

   ClaimName:   pv-claim-test-petset-0

   ReadOnly:    false

 default-token-q3eva:

   Type:        Secret (a volume populated by a Secret)

   SecretName:  default-token-q3eva

   QoS Tier:  BestEffort

Events:

 FirstSeen LastSeen Count From SubobjectPath Type Reason Message

 --------- -------- ----- ---- ------------- -------- ------ -------

 43s 43s 1 {default-scheduler } Normal Scheduled Successfully assigned kube-pv-demo to tlx243

 42s 42s 1 {kubelet tlx243} spec.containers{data-pv-demo} Normal Pulling pulling image &#34;nginx&#34;

 40s 40s 1 {kubelet tlx243} spec.containers{data-pv-demo} Normal Pulled Successfully pulled image &#34;nginx&#34;

 40s 40s 1 {kubelet tlx243} spec.containers{data-pv-demo} Normal Created Created container with docker id ae2a50c25e03

 40s 40s 1 {kubelet tlx243} spec.containers{data-pv-demo} Normal Started Started container with docker id ae2a50c25e03
</code></pre><p>永久卷在 minion node（在本例中为 tlx243）中显示为 iSCSI 设备：</p><pre tabindex=0><code>[root@tlx243 ~]# lsscsi

[0:2:0:0]    disk    SMC      SMC2208          3.24  /dev/sda

[11:0:0:0]   disk    DATERA   IBLOCK           4.0   /dev/sdb


[root@tlx243 datera~iscsi]# mount  ``` grep sdb

/dev/sdb on /var/lib/kubelet/pods/6b99bd2a-628e-11e6-8463-0cc47ab41442/volumes/datera~iscsi/pv-datera-0 type xfs (rw,relatime,attr2,inode64,noquota)
</code></pre><p>在 Pod 中运行的容器按照清单中将设备安装在 /data 上：</p><pre tabindex=0><code>[root@tlx241 /]# kubectl exec kube-pv-demo -c data-pv-demo -it bash

root@kube-pv-demo:/# mount  ``` grep data

/dev/sdb on /data type xfs (rw,relatime,attr2,inode64,noquota)
</code></pre><p><strong>使用 Pet Sets</strong></p><p>通常，Pod 被视为无状态单元，因此，如果其中之一状态异常或被取代，Kubernetes 会将其丢弃。相反，PetSet 是一组有状态的 Pod，具有更强的身份概念。PetSet 可以将标识分配给应用程序的各个实例，这些应用程序没有与底层物理结构连接，PetSet 可以消除这种依赖性。</p><p>每个 PetSet 需要{0..n-1}个 Pet。每个 Pet 都有一个确定的名字、PetSetName-Ordinal 和唯一的身份。每个 Pet 最多有一个 Pod，每个 PetSet 最多包含一个给定身份的 Pet。要确保每个 PetSet 在任何特定时间运行时，具有唯一标识的“pet”的数量都是确定的。Pet 的身份标识包括以下几点：</p><ul><li>一个稳定的主机名，可以在 DNS 中使用</li><li>一个序号索引</li><li>稳定的存储：链接到序号和主机名</li></ul><p>使用 PersistentVolume Claim 定义 PetSet 的典型例子如下所示：</p><pre tabindex=0><code># A headless service to create DNS records

apiVersion: v1

kind: Service

metadata:

 name: test-service

 labels:

   app: nginx

spec:

 ports:

 - port: 80

   name: web

 clusterIP: None

 selector:

   app: nginx

---

apiVersion: apps/v1alpha1

kind: PetSet

metadata:

 name: test-petset

spec:

 serviceName: &#34;test-service&#34;

 replicas: 2

 template:

   metadata:

     labels:

       app: nginx

     annotations:

       [pod.alpha.kubernetes.io/initialized:](http://pod.alpha.kubernetes.io/initialized:) &#34;true&#34;

   spec:

     terminationGracePeriodSeconds: 0

     containers:

     - name: nginx

       image: [gcr.io/google\_containers/nginx-slim:0.8](http://gcr.io/google_containers/nginx-slim:0.8)

       ports:

       - containerPort: 80

         name: web

       volumeMounts:

       - name: pv-claim

         mountPath: /data

 volumeClaimTemplates:

 - metadata:

     name: pv-claim

     annotations:

       [volume.alpha.kubernetes.io/storage-class:](http://volume.alpha.kubernetes.io/storage-class:) anything

   spec:

     accessModes: [&#34;ReadWriteOnce&#34;]

     resources:

       requests:

         storage: 100Gi
</code></pre><p>我们提供以下 PersistentVolume Claim：</p><pre tabindex=0><code>[root@tlx241 /]# kubectl get pvc

NAME                     STATUS    VOLUME        CAPACITY   ACCESSMODES   AGE

pv-claim-test-petset-0   Bound     pv-datera-0   0                        41m

pv-claim-test-petset-1   Bound     pv-datera-1   0                        41m

pv-claim-test-petset-2   Bound     pv-datera-2   0                        5s

pv-claim-test-petset-3   Bound     pv-datera-3   0                        2s
</code></pre><p>配置 PetSet 时，将实例化两个 Pod：</p><pre tabindex=0><code>[root@tlx241 /]# kubectl get pods

NAMESPACE     NAME                        READY     STATUS    RESTARTS   AGE

default       test-petset-0               1/1       Running   0          7s

default       test-petset-1               1/1       Running   0          3s
</code></pre><p>以下是一个 PetSet：test-petset 实例化之前的样子：</p><pre tabindex=0><code>[root@tlx241 /]# kubectl describe petset test-petset

Name: test-petset

Namespace: default

Image(s): [gcr.io/google\_containers/nginx-slim:0.8](http://gcr.io/google_containers/nginx-slim:0.8)

Selector: app=nginx

Labels: app=nginx

Replicas: 2 current / 2 desired

Annotations: \&lt;none\&gt;

CreationTimestamp: Sun, 14 Aug 2016 19:46:30 -0700

Pods Status: 2 Running / 0 Waiting / 0 Succeeded / 0 Failed

No volumes.

No events.
</code></pre><p>一旦实例化 PetSet（例如下面的 test-petset），随着副本数（从 PetSet 的初始 Pod 数量算起）的增加，实例化的 Pod 将变得更多，并且更多的 PersistentVolume Claim 会绑定到新的 Pod 上：</p><pre tabindex=0><code>[root@tlx241 /]# kubectl patch petset test-petset -p&#39;{&#34;spec&#34;:{&#34;replicas&#34;:&#34;3&#34;}}&#39;

&#34;test-petset” patched


[root@tlx241 /]# kubectl describe petset test-petset

Name: test-petset

Namespace: default

Image(s): [gcr.io/google\_containers/nginx-slim:0.8](http://gcr.io/google_containers/nginx-slim:0.8)

Selector: app=nginx

Labels: app=nginx

Replicas: 3 current / 3 desired

Annotations: \&lt;none\&gt;

CreationTimestamp: Sun, 14 Aug 2016 19:46:30 -0700

Pods Status: 3 Running / 0 Waiting / 0 Succeeded / 0 Failed

No volumes.

No events.


[root@tlx241 /]# kubectl get pods

NAME                        READY     STATUS    RESTARTS   AGE

test-petset-0               1/1       Running   0          29m

test-petset-1               1/1       Running   0          28m

test-petset-2               1/1       Running   0          9s
</code></pre><p>现在，应用修补程序后，PetSet 正在运行3个 Pod。</p><p>当上述 PetSet 定义修补完成，会产生另一个副本，PetSet 将在系统中引入另一个 pod。反之，这会导致在 Datera Data Fabric 上配置更多的卷。因此，在 PetSet 进行扩展时，要配置动态卷并将其附加到 Pod 上。</p><p>为了平衡持久性和一致性的概念，如果 Pod 从一个 Minion 转移到另一个，卷确实会附加（安装）到新的 minion node 上，并与旧的 Minion 分离（卸载），从而实现对数据的持久访问。</p><p><strong>结论</strong></p><p>本文展示了具备 Pet Sets 的 Kubernetes 协调有状态和无状态工作负载。当 Kubernetes 社区致力于扩展 FlexVolume 框架的功能时，我们很高兴这个解决方案使 Kubernetes 能够在数据中心广泛运行。</p><p>加入我们并作出贡献：Kubernetes <a href=https://groups.google.com/forum/#!forum/kubernetes-sig-storage>Storage SIG</a>.</p><ul><li><a href=http://get.k8s.io/>下载 Kubernetes</a></li><li>参与 Kubernetes 项目 <a href=https://github.com/kubernetes/kubernetes>GitHub</a></li><li>发布问题（或者回答问题） <a href=http://stackoverflow.com/questions/tagged/kubernetes>Stack Overflow</a></li><li>联系社区 <a href=http://slack.k8s.io/>k8s Slack</a></li><li>在 Twitter 上关注我们 <a href=https://twitter.com/kubernetesio>@Kubernetesio</a> for latest updates</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-28828ac2d323ef978d2063693d4b7de1>SIG Apps: 为 Kubernetes 构建应用并在 Kubernetes 中进行运维</h1><div class="td-byline mb-4"><time datetime=2016-08-16 class=text-muted>2016.08.16</time></div><p><strong>编者注</strong>：这篇文章由 Kubernetes SIG-Apps 团队撰写，分享他们如何关注在 Kubernetes
中运行应用的开发者和 devops 经验。</p><p>Kubernetes 是容器化应用程序的出色管理者。因此，<a href=https://kubernetes.io/blog/2016/02/sharethis-kubernetes-in-production>众多</a>
<a href=https://blog.box.com/blog/kubernetes-box-microservices-maximum-velocity/>公司</a>
<a href=http://techblog.yahoo.co.jp/infrastructure/os_n_k8s/>已经</a>
<a href=http://www.nextplatform.com/2015/11/12/inside-ebays-shift-to-kubernetes-and-containers-atop-openstack/>开始</a> 在 Kubernetes 中运行应用程序。</p><p>Kubernetes 特殊兴趣小组 (<a href=https://github.com/kubernetes/community/blob/master/README.md#special-interest-groups-sig>SIGs</a>)
自 1.0 版本开始就一直致力于支持开发者和运营商社区。围绕网络、存储、扩展和其他运营领域组织的人员。</p><p>随着 Kubernetes 的兴起，对工具、最佳实践以及围绕构建和运营云原生应用程序的讨论的需求也随之增加。为了满足这一需求，
Kubernetes <a href=https://github.com/kubernetes/community/tree/master/sig-apps>SIG Apps</a> 应运而生。</p><p>SIG Apps 为公司和个人提供以下支持：</p><ul><li>查看和分享正在构建的、为应用操作人员赋能的工具的演示</li><li>了解和讨论应用运营人员的需求</li><li>组织各方努力改善体验</li></ul><p>自从 SIG Apps 成立以来，我们已经进行了项目演示，例如 <a href=https://github.com/opencredo/kubefuse>KubeFuse</a>、
<a href=https://github.com/kubespray/kpm>KPM</a>，和 <a href=https://stacksmith.bitnami.com/>StackSmith</a>。
我们还对那些负责 Kubernetes 中应用运维的人进行了调查。</p><p>从调查结果中，我们学到了很多东西，包括：</p><ul><li>81% 的受访者希望采用某种形式的自动扩缩</li><li>为了存储秘密信息，47% 的受访者使用内置 Secret。目前这些资料并未实现静态加密。
（如果你需要关于加密的帮助，请参见<a href=https://github.com/kubernetes/kubernetes/issues/10439>问题</a>。)</li><li>响应最多的问题与第三方工具和调试有关</li><li>对于管理应用程序的第三方工具，没有明确的赢家。有各种各样的做法</li><li>总体上对缺乏有用文件有较多抱怨。（请在<a href=https://github.com/kubernetes/kubernetes.github.io>此处</a>帮助提交文档。）</li><li>数据量很大。很多回答是可选的，所以我们很惊讶所有候选人的所有问题中有 935 个都被填写了。
如果你想亲自查看数据，可以<a href="https://docs.google.com/spreadsheets/d/15SUL7QTpR4Flrp5eJ5TR8A5ZAFwbchfX2QL4MEoJFQ8/edit?usp=sharing">在线</a>查看。</li></ul><p>就应用运维而言，仍然有很多东西需要解决和共享。如果你对运行应用程序有看法或者有改善体验的工具，
或者只是想潜伏并了解状况，请加入我们。</p><ul><li>在 SIG-Apps <a href=https://kubernetes.slack.com/messages/sig-apps>Slack 频道</a>与我们聊天</li><li>发送邮件到 SIG-Apps <a href=https://groups.google.com/forum/#!forum/kubernetes-sig-apps>邮件列表</a></li><li>参加我们的公开会议：太平洋时间每周三上午 9 点，<a href=https://github.com/kubernetes/community/blob/master/sig-apps/README.md#meeting>详情点击此处</a></li></ul><p><em>--Matt Farina ，Hewlett Packard Enterprise 首席工程师</em></p></div><div class=td-content style=page-break-before:always><h1 id=pg-e74a934a1afe2c3d5f1bb068f967c67f>Kubernetes 生日快乐。哦，这是你要去的地方！</h1><div class="td-byline mb-4"><time datetime=2016-07-21 class=text-muted>2016.07.21</time></div><p><em>编者按，今天的嘉宾帖子来自一位独立的 kubernetes 撰稿人 Justin Santa Barbara，分享了他对项目从一开始到未来发展的思考。</em></p><p><strong>亲爱的 K8s,</strong></p><p><em>很难相信你是唯一的一个 - 成长这么快的。在你一岁生日的时候，我想我可以写一个小纸条，告诉你为什么我在你出生的时候那么兴奋，为什么我觉得很幸运能成为抚养你长大的一员，为什么我渴望看到你继续成长！</em></p><p><em>--Justin</em></p><p>你从一个优秀的基础 - 良好的声明性功能开始，它是围绕一个具有良好定义的模式和机制的坚实的 API 构建的，这样我们就可以向前发展了。果然，在你的第一年里，你增长得如此之快：autoscaling、HTTP load-balancing support (Ingress)、support for persistent workloads including clustered databases (PetSets)。你已经和更多的云交了朋友(欢迎 azure 和 openstack 加入家庭)，甚至开始跨越区域和集群(Federation)。这些只是一些最明显的变化 - 在你的大脑里发生了太多的变化！</p><p>我觉得你一直保持开放的态度真是太好了 - 你好像把所有的东西都写在 github 上 - 不管是好是坏。我想我们在这方面都学到了很多，比如让工程师做缩放声明的风险，然后在没有完全相同的精确性和严谨性框架的情况下，将这些声明与索赔进行权衡。但我很自豪你选择了不降低你的标准，而是上升到挑战，只是跑得更快 - 这可能不是最现实的办法，但这是唯一的方式能移动山！</p><p>然而，不知何故，你已经设法避免了许多其他开源软件陷入的共同死胡同，特别是当那些项目越来越大，开发人员最终要做的比直接使用它更多的时候。你是怎么做到的？有一个很可能是虚构的故事，讲的是 IBM 的一名员工犯了一个巨大的错误，被传唤去见大老板，希望被解雇，却被告知“我们刚刚花了几百万美元培训你。我们为什么要解雇你？“。尽管谷歌对你进行了大量的投资(包括 redhat 和其他公司)，但我有时想知道，我们正在避免的错误是否更有价值。有一个非常开放的开发过程，但也有一个“oracle”，它有时会通过告诉我们两年后如果我们做一个特定的设计决策会发生什么来纠正错误。这是你应该听的父母！</p><p>所以，尽管你只有一岁，你真的有一个<a href="http://queue.acm.org/detail.cfm?ID=2898444">旧灵魂</a>。我只是<a href=https://kubernetes.io/blog/2016/07/happy-k8sbday-1>很多人抚养你</a>中的一员，但对我来说，能够与那些建立了这些令人难以置信的系统并拥有所有这些领域知识的人一起工作是一次极好的学习经历。然而，因为我们是白手起家(而不是采用现有的 Borg 代码)，我们处于同一水平，仍然可以就如何培养你进行真正的讨论。好吧，至少和我们的水平一样接近，但值得称赞的是，他们都太好了，从来没提过！</p><p>如果我选择两个聪明人做出的明智决定：</p><ul><li>标签和选择器给我们声明性的“pointers”，所以我们可以说“为什么”我们想要东西，而不是直接列出东西。这是如何扩展到[伟大高度]的秘密(<a href=https://kubernetes.io/blog/2016/07/thousand-instances-of-cassandra-using-kubernetes-pet-set>https://kubernetes.io/blog/2016/07/thousand-instances-of-cassandra-using-kubernetes-pet-set</a>)；不是命名每一步，而是说“像第一步一样多走一千步”。</li><li>控制器是状态同步器：我们指定目标，您的控制器将不遗余力地工作，使系统达到该状态。它们工作在强类型 API 基础上，并且贯穿整个代码，因此 Kubernetes 比一个大的程序多一百个小程序。仅仅从技术上扩展到数千个节点是不够的；这个项目还必须扩展到数千个开发人员和特性；控制器帮助我们达到目的。</li></ul><p>等等我们就走！我们将取代那些控制器，建立更多，API 基金会让我们构建任何我们可以用这种方式表达的东西 - 大多数东西只是标签或注释远离！但你的思想不会由语言来定义：有了第三方资源，你可以表达任何你选择的东西。现在我们可以不用在 Kubernetes 建造Kubernetes 了，创造出与其他任何东西一样感觉是 Kubernetes 的一部分的东西。最近添加的许多功能，如ingress、DNS integration、autoscaling and network policies ，都已经完成或可以通过这种方式完成。最终，在这些事情发生之前很难想象你会是怎样的一个人，但是明天的标准功能可以从今天开始，没有任何障碍或看门人，甚至对一个听众来说也是这样。</p><p>所以我期待着看到越来越多的增长发生在离 Kubernetes 核心越来越远的地方。我们必须通过这些阶段来工作；从需要在 kubernetes 内核中发生的事情开始——比如用部署替换复制控制器。现在我们开始构建不需要核心更改的东西。但我们仍然在讨论基础设施和应用程序。接下来真正有趣的是：当我们开始构建依赖于 kubernetes api 的应用程序时。我们一直有使用 kubernetes api 进行自组装的 cassandra 示例，但我们还没有真正开始更广泛地探讨这个问题。正如 S3 APIs 改变了我们构建记忆事物的方式一样，我认为 k8s APIs 也将改变我们构建思考事物的方式。</p><p>所以我很期待你的二岁生日：我可以试着预测你那时的样子，但我知道你会超越我所能想象的最大胆的东西。哦，这是你要去的地方！</p><p><em>-- Justin Santa Barbara, 独立的 Kubernetes 贡献者</em></p></div><div class=td-content style=page-break-before:always><h1 id=pg-d0c04eabe8ccc353a49856a0440f8725>将端到端的 Kubernetes 测试引入 Azure （第二部分）</h1><div class="td-byline mb-4"><time datetime=2016-07-18 class=text-muted>2016.07.18</time></div><p><em>作者标注：今天的邀请帖子是 Travis Newhouse 的 <a href=https://kubernetes.io/blog/2016/06/bringing-end-to-end-testing-to-azure>系列</a> 中的第二部分，他是 AppFormix 的首席架构师，这篇文章介绍了他们对 Kubernetes 的贡献。</em></p><p>历史上，Kubernetes 测试一直由谷歌托管，在 <a href=https://cloud.google.com/compute/>谷歌计算引擎</a> (GCE) 和 <a href=https://cloud.google.com/container-engine/>谷歌容器引擎</a> (GKE) 上运行端到端测试。实际上，提交队列的选通检查是在这些测试平台上执行测试的子集。联合测试旨在通过使组织托管各种平台的测试作业并贡献测试结果，从而让 Kubernetes 项目受益来扩大测试范围。谷歌和 SIG-Testing 的 Kubernetes 测试小组成员已经创建了一个 <a href=http://storage.googleapis.com/kubernetes-test-history/static/index.html>Kubernetes 测试历史记录仪表板</a>，可以发布所有联合测试作业（包括谷歌托管的作业）的全部结果。</p><p>在此博客文章中，我们介绍了扩展 Azure 的端到端测试工作，并展示了如何为 Kubernetes 项目贡献联合测试。</p><p><strong>Azure 的端到端集成测试</strong></p><p>成功实现 <a href=https://kubernetes.io/blog/2016/06/bringing-end-to-end-testing-to-azure>在 Azure 上自动部署 Kubernetes 的 “development distro” 脚本</a> 之后，我们的下一个目标是运行端到端集成测试，并与 Kubernetes 社区共享结果。</p><p>通过在私有 Jenkins 服务器中定义夜间工作，我们自动化了在 Azure 上执行 Kubernetes 端到端测试的工作流程。图2显示了使用 kube-up.sh 在运行于 Azure 的 Ubuntu 虚拟机上部署 Kubernetes，然后执行端到端测试的工作流程。测试完成后，该作业将测试结果和日志上传到 Google Cloud Storage 目录中，其格式可以由 <a href=https://github.com/kubernetes/test-infra/tree/master/jenkins/test-history>生成测试历史记录仪表板的脚本</a> 进行处理。我们的 Jenkins 作业使用 hack/jenkins/e2e-runner.sh 和 hack/jenkins/upload-to-gcs.sh 脚本生成正确格式的结果。</p><p>| <img src=https://lh6.googleusercontent.com/TZiUu4sQ7G0XDvJgv9a1a4UEdxntOZDT9I3S42c8BOAyigxaysKmhJMen8vLaJ3UYaYKPIG9h-cyBOvTSI6kBgqnUQabe4xxZXhrUyVxinKGEaCDUnmNlBo__HNjzoYc_U7zM77_Dxe alt="Kubernetes on Azure - Flow Chart - New Page.png"> |
| 图 2 - 夜间测试工作流程 |</p><p><strong>如何进行端到端测试</strong></p><p>在创建 Azure 端到端测试工作的整个过程中，我们与 <a href=https://github.com/kubernetes/community/tree/master/sig-testing>SIG-Testing</a> 的成员进行了合作，找到了一种将结果发布到 Kubernetes 社区的方法。合作的结果是以文档和简化的流程从联合测试工作中贡献结果。贡献端到端测试结果的过程可以归纳为4个步骤。</p><ol><li>创建一个 <a href=https://cloud.google.com/storage/>Google Cloud Storage</a> 空间用来发布结果。</li><li>定义一个自动化作业来运行端到端测试，通过设置一些环境变量，使用 hack/jenkins/e2e-runner.sh 部署 Kubernetes 二进制文件并执行测试。</li><li>使用 hack/jenkins/upload-to-gcs.sh 上传结果。</li><li>通过提交对 <a href=https://github.com/kubernetes/test-infra>kubernetes/test-infra</a> 中的几个文件进行修改的请求，将结果合并到测试历史记录仪表板中。</li></ol><p>联合测试文档更详细地描述了这些步骤。运行端到端测试并上传结果的脚本简化了贡献新联合测试作业的工作量。设置自动化测试作业的具体步骤以及在其中部署 Kubernetes 的合适环境将留给读者进行选择。对于使用 Jenkins 的组织，用于 GCE 和 GKE 测试的 jenkins-job-builder 配置可能会提供有用的示例。</p><p><strong>回顾</strong></p><p>Azure 上的端到端测试已经运行了几周。在此期间，我们在 Kubernetes 中发现了两个问题。Weixu Zhuang 立即发布了修补程序并已合并到 Kubernetes master 分支中。</p><p>当我们想用 Ubuntu VM 在 Azure 上用 SaltStack 打开 Kubernetes 集群时，发生了第一个问题。一个提交 (07d7cfd3) 修改了 OpenVPN 证书生成脚本，使用了一个仅由集群或者ubuntu中的脚本初始化的变量。证书生成脚本对参数是否存在进行严格检查会导致其他使用该脚本的平台失败（例如，为支持 Azure 而进行的更改）。我们提交了一个<a href=https://github.com/kubernetes/kubernetes/pull/21357>解决问题的请求</a> ，通过使用默认值初始化变量让证书生成脚本在所有平台类型上都更加健壮，。</p><p>第二个 <a href=https://github.com/kubernetes/kubernetes/pull/22321>清理未使用导入的请求</a> 在 Daemonset 单元测试文件中。import 语句打破了 golang 1.4 的单元测试。我们的夜间 Jenkins 工作帮助我们找到错误并且迅速完成修复。</p><p><strong>结论与未来工作</strong></p><p>在 Azure 上为 Kubernetes 添加了夜间端到端测试工作，这有助于定义为 Kubernetes 项目贡献联合测试的过程。在工作过程中，当 Azure 测试工作发现兼容性问题时，我们还发现了将测试覆盖范围扩展到更多平台的直接好处。</p><p>我们要感谢 Aaron Crickenberger, Erick Fejta, Joe Finney 和 Ryan Hutchinson 的帮助，将我们的 Azure 端到端测试结果纳入了 Kubernetes 测试历史。如果您想参与测试来创建稳定的、高质量的 Kubernetes 版本，请加入我们的 <a href=https://github.com/kubernetes/community/tree/master/sig-testing>Kubernetes Testing SIG (sig-testing)</a>。</p><p><em>--Travis Newhouse, AppFormix 首席架构师</em></p></div><div class=td-content style=page-break-before:always><h1 id=pg-1496574418064c58fdb070c88d97a679>Dashboard - Kubernetes 的全功能 Web 界面</h1><div class="td-byline mb-4"><time datetime=2016-07-15 class=text-muted>2016.07.15</time></div><p><em>编者按：这篇文章是<a href=https://kubernetes.io/blog/2016/07/five-days-of-kubernetes-1-3>一系列深入的文章</a> 中关于Kubernetes 1.3的新内容的一部分</em>
<a href=http://github.com/kubernetes/dashboard>Kubernetes Dashboard</a>是一个旨在为 Kubernetes 世界带来通用监控和操作 Web 界面的项目。三个月前，我们<a href=https://kubernetes.io/blog/2016/04/building-awesome-user-interfaces-for-kubernetes>发布</a>第一个面向生产的版本，从那时起 dashboard 已经做了大量的改进。在一个 UI 中，您可以在不离开浏览器的情况下，与 Kubernetes 集群执行大多数可能的交互。这篇博客文章分解了最新版本中引入的新功能，并概述了未来的路线图。</p><p><strong>全功能的 Dashboard</strong></p><p>由于社区和项目成员的大量贡献，我们能够为<a href=https://kubernetes.io/blog/2016/07/kubernetes-1-3-bridging-cloud-native-and-enterprise-workloads/>Kubernetes 1.3发行版</a>提供许多新功能。我们一直在认真听取用户的反馈(参见<a href=http://static.lwy.io/img/kubernetes_dashboard_infographic.png>摘要信息图表</a>)，并解决了最高优先级的请求和难点。
--></p><p>Dashboard UI 现在处理所有工作负载资源。这意味着无论您运行什么工作负载类型，它都在 web 界面中可见，并且您可以对其进行操作更改。例如，可以使用<a href=/docs/user-guide/petset/>Pet Sets</a>修改有状态的 mysql 安装，使用部署对 web 服务器进行滚动更新，或使用守护程序安装集群监视。</p><p><a href=https://lh3.googleusercontent.com/p9bMGxPx4jE6_Z2KB-MktmyuAxyFst-bEk29M_Bn0Bj5ul7uzinH6u5WjHsMmqhGvBwlABZt06dwQ5qkBZiLq_EM1oddCmpwChvXDNXZypaS5l8uzkKuZj3PBUmzTQT4dgDxSXgz><img src=https://lh3.googleusercontent.com/p9bMGxPx4jE6_Z2KB-MktmyuAxyFst-bEk29M_Bn0Bj5ul7uzinH6u5WjHsMmqhGvBwlABZt06dwQ5qkBZiLq_EM1oddCmpwChvXDNXZypaS5l8uzkKuZj3PBUmzTQT4dgDxSXgz alt></a></p><p>除了查看资源外，还可以创建、编辑、更新和删除资源。这个特性支持许多用例。例如，您可以杀死一个失败的 pod，对部署进行滚动更新，或者只组织资源。您还可以导出和导入云应用程序的 yaml 配置文件，并将它们存储在版本控制系统中。</p><p><img src=https://lh6.googleusercontent.com/zz-qjNcGgvWXrK1LIipUdIdPyeWJ1EyPVJxRnSvI6pMcLBkxDxpQt-ObsIiZsS_X0RjVBWtXYO5TCvhsymb__CGXFzKuPUnUrB4HKnAMsxtYdWLwMmHEb8c9P9Chzlo5ePHRKf5O alt></p><p>这个版本包括一个用于管理和操作用例的集群节点的 beta 视图。UI 列出集群中的所有节点，以便进行总体分析和快速筛选有问题的节点。details 视图显示有关该节点的所有信息以及指向在其上运行的 pod 的链接。</p><p><img src=https://lh6.googleusercontent.com/3CSTUy-8Tz-yAL9tCqxNUqMcWJYKK0dwk7kidE9zy-L-sXFiD4A4Y2LKEqbJKgI6Fl6xbzYxsziI8dULVXPJbu6eU0ci7hNtqi3tTuhdbVD6CG3EXw151fvt2MQuqumHRbab6g-_ alt></p><p>我们随发行版提供的还有许多小范围的新功能，即：支持命名空间资源、国际化、性能改进和许多错误修复(请参阅<a href=https://github.com/kubernetes/dashboard/releases/tag/v1.1.0>发行说明</a>中的更多内容)。所有这些改进都会带来更好、更简单的产品用户体验。</p><p><strong>Future Work</strong></p><p>该团队对跨越多个用例的未来有着雄心勃勃的计划。我们还对所有功能请求开放，您可以在我们的<a href=https://github.com/kubernetes/dashboard/issues>问题跟踪程序</a>上发布这些请求。</p><p>以下是我们接下来几个月的重点领域：</p><ul><li><a href=https://github.com/kubernetes/dashboard/issues/961>Handle more Kubernetes resources</a> - 显示集群用户可能与之交互的所有资源。一旦完成，dashboard 就可以完全替代cli。</li><li><a href=https://github.com/kubernetes/dashboard/issues/962>Monitoring and troubleshooting</a> - 将资源使用统计信息/图表添加到 Dashboard 中显示的对象。这个重点领域将允许对云应用程序进行可操作的调试和故障排除。</li><li><a href=https://github.com/kubernetes/dashboard/issues/964>Security, auth and logging in</a> - 使仪表板可从集群外部的网络访问，并使用自定义身份验证系统。</li></ul><p><strong>联系我们</strong></p><p>我们很乐意与您交谈并听取您的反馈！</p><ul><li>请在[SIG-UI邮件列表](<a href=https://groups.google.com/forum/>https://groups.google.com/forum/</a>向我们发送电子邮件！论坛/kubernetes sig ui)</li><li>在 kubernetes slack 上与我们聊天。<a href=https://kubernetes.slack.com/messages/sig-ui/>#SIG-UI channel</a></li><li>参加我们的会议：东部时间下午4点。请参阅<a href="https://calendar.google.com/calendar/embed?src=google.com_52lm43hc2kur57dgkibltqc6kc%40group.calendar.google.com&ctz=Europe/Warsaw">SIG-UI日历</a>了解详细信息。</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-7bef62438e14fb0960709d89c1672c30>Citrix + Kubernetes = 全垒打</h1><div class="td-byline mb-4"><time datetime=2016-07-14 class=text-muted>2016.07.14</time></div><p>编者按：今天的客座文章来自 Citrix Systems 的产品管理总监 Mikko Disini，他分享了他们在 Kubernetes 集成上的合作经验。 _</p><p>技术合作就像体育运动。如果你能像一个团队一样合作，你就能在最后关头取得胜利。这就是我们对谷歌云平台团队的经验。</p><p>最近，我们与 Google 云平台（GCP）联系，代表 Citrix 客户以及更广泛的企业市场，希望就工作负载的迁移进行协作。此迁移需要将 [NetScaler Docker 负载均衡器]https://www.citrix.com/blogs/2016/06/20/the-best-docker-load-balancer-at-dockercon-in-seattle-this-week/) CPX 包含到 Kubernetes 节点中，并解决将流量引入 CPX 代理的任何问题。</p><p><strong>为什么是 NetScaler 和 Kubernetes</strong></p><ol><li>Citrix 的客户希望他们开始使用 Kubernetes 部署他们的容器和微服务体系结构时，能够像当初迁移到云计算时一样，享有 NetScaler 所提供的第 4 层到第 7 层能力 </li><li>Kubernetes 提供了一套经过验证的基础设施，可用来运行容器和虚拟机，并自动交付工作负载；</li><li>NetScaler CPX 提供第 4 层到第 7 层的服务，并为日志和分析平台 <a href=https://www.citrix.com/blogs/2016/05/24/introducing-the-next-generation-netscaler-management-and-analytics-system/>NetScaler 管理和分析系统</a> 提供高效的度量数据。</li></ol><p>我希望我们所有与技术合作伙伴一起工作的经验都能像与 GCP 一起工作一样好。我们有一个列表，包含支持我们的用例所需要解决的问题。我们能够快速协作形成解决方案。为了解决这些问题，GCP 团队提供了深入的技术支持，与 Citrix 合作，从而使得 NetScaler CPX 能够在每台主机上作为客户端代理启动运行。</p><p>接下来，需要在 GCP 入口负载均衡器的数据路径中插入 NetScaler CPX，使 NetScaler CPX 能够将流量分散到前端 web 服务器。NetScaler 团队进行了修改，以便 NetScaler CPX 监听 API 服务器事件，并配置自己来创建 VIP、IP 表规则和服务器规则，以便跨前端应用程序接收流量和负载均衡。谷歌云平台团队提供反馈和帮助，验证为克服技术障碍所做的修改。完成了!</p><p>NetScaler CPX 用例在 <a href=https://kubernetes.io/blog/2016/07/kubernetes-1-3-bridging-cloud-native-and-enterprise-workloads/>Kubernetes 1.3</a> 中提供支持。Citrix 的客户和更广泛的企业市场将有机会基于 Kubernetes 享用 NetScaler 服务，从而降低将工作负载转移到云平台的阻力。 </p><p>您可以在<a href=https://www.citrix.com/networking/microservices.html>此处</a>了解有关 NetScaler CPX 的更多信息。</p><p>_ -- Mikko Disini，Citrix Systems NetScaler 产品管理总监</p></div><div class=td-content style=page-break-before:always><h1 id=pg-9e91022359423a7a5fdefbcd200af963>容器中运行有状态的应用！？ Kubernetes 1.3 说 “是！”</h1><div class="td-byline mb-4"><time datetime=2016-07-13 class=text-muted>2016.07.13</time></div><p><em>编者注： 今天的来宾帖子来自 Diamanti 产品副总裁 Mark Balch，他将分享有关他们对 Kubernetes 所做的贡献的更多信息。</em></p><p>祝贺 Kubernetes 社区发布了另一个<a href=https://kubernetes.io/blog/2016/07/kubernetes-1-3-bridging-cloud-native-and-enterprise-workloads/>有价值的版本</a>。
专注于有状态应用程序和联邦集群是我对 1.3 如此兴奋的两个原因。
Kubernetes 对有状态应用程序（例如 Cassandra、Kafka 和 MongoDB）的支持至关重要。
重要服务依赖于数据库、键值存储、消息队列等。
此外，随着应用程序的发展为全球数百万用户提供服务，仅依靠一个数据中心或容器集群将无法正常工作。
联邦集群允许用户跨多个集群和数据中心部署应用程序，以实现规模和弹性。</p><p>您可能<a href=https://www.diamanti.com/blog/the-next-great-application-platform/>之前听过我说过</a>，容器是下一个出色的应用程序平台。
Diamanti 正在加速在生产中使用有状态应用程序的容器-在这方面，性能和易于部署非常重要。</p><p><strong>应用程序不仅仅需要牛</strong></p><p>除了诸如Web服务器之类的无状态容器（因为它们是可互换的，因此被称为“牛”）之外，用户越来越多地使用容器来部署有状态工作负载，以从“一次构建，随处运行”中受益并提高裸机效率/利用率。
这些“宠物”（之所以称为“宠物”，是因为每个宠物都需要特殊的处理）带来了新的要求，包括更长的生命周期，配置依赖项，有状态故障转移以及性能敏感性。
容器编排必须满足这些需求，才能成功部署和扩展应用程序。</p><p>输入 <a href=/docs/user-guide/petset/>Pet Set</a>，这是 Kubernetes 1.3 中的新对象，用于改进对状态应用程序的支持。
Pet Set 在每个数据库副本的启动阶段进行排序（例如），以确保有序的主/从配置。
Pet Set 还利用普遍存在的 DNS SRV 记录简化了服务发现，DNS SRV 记录是一种广为人知且长期了解的机制。</p><p>Diamanti 对 Kubernetes 的 <a href=https://github.com/kubernetes/kubernetes/pull/13840>FlexVolume 贡献</a> 通过为持久卷提供低延迟存储并保证性能来实现有状态工作负载，包括从容器到媒体的强制服务质量。</p><p><strong>联邦主义者</strong></p><p>为应用可用性作规划的用户必须应对故障迁移问题并在整个地理区域内扩展。
跨集群联邦服务允许容器化的应用程序轻松跨多个集群进行部署。
联邦服务解决了诸如管理多个容器集群以及协调跨联邦集群的服务部署和发现之类的挑战。</p><p>像严格的集中式模型一样，联邦身份验证提供了通用的应用程序部署界面。
但是，由于每个集群都具有自治权，因此联邦会增加了在网络中断和其他事件期间在本地管理集群的灵活性。
跨集群联邦服务还可以提供跨容器集群应用一致的服务命名和采用，简化 DNS 解析。</p><p>很容易想象在将来的版本中具有跨集群联邦服务的强大多集群用例。
一个示例是根据治理，安全性和性能要求调度容器。
Diamanti 的调度程序扩展是在考虑了这一概念的基础上开发的。
我们的<a href=https://github.com/kubernetes/kubernetes/pull/13580>第一个实现</a>使 Kubernetes 调度程序意识到每个集群节点本地的网络和存储资源。
将来，类似的概念可以应用于跨集群联邦服务的更广泛的放置控件。</p><p><strong>参与其中</strong></p><p>随着对有状态应用的兴趣日益浓厚，人们已经开始进一步增强 Kubernetes 存储的工作。
存储特别兴趣小组正在讨论支持本地存储资源的提案。
Diamanti 期待将 FlexVolume 扩展到包括更丰富的 API，这些 API 可以启用本地存储和存储服务，包括数据保护，复制和缩减。
我们还正在研究有关通过 Kubernetes 跨集群联邦服务改善应用程序放置，迁移和跨容器集群故障转移的建议。</p><p>加入对话并做出贡献！
这里是一些入门的地方：</p><ul><li>产品管理 <a href=https://groups.google.com/forum/#!forum/kubernetes-sig-pm>组</a></li><li>Kubernetes <a href=https://groups.google.com/forum/#!forum/kubernetes-sig-storage>存储 SIG</a> </li><li>Kubernetes <a href=https://groups.google.com/forum/#!forum/kubernetes-sig-federation>集群联邦 SIG</a></li></ul><p><em>-- <a href=https://diamanti.com/>Diamanti</a> 产品副总裁 Mark Balch。 Twitter <a href=https://twitter.com/markbalch>@markbalch</a></em></p></div><div class=td-content style=page-break-before:always><h1 id=pg-dfd7c2731ea9e6f52443db7ecb32aa82>CoreOS Fest 2016: CoreOS 和 Kubernetes 在柏林（和旧金山）社区见面会</h1><div class="td-byline mb-4"><time datetime=2016-05-03 class=text-muted>2016.05.03</time></div><p><a href=https://coreos.com/fest/>CoreOS Fest 2016</a> 将汇集容器和开源分布式系统社区，其中包括 Kubernetes 领域的许多思想领袖。
这是第二次年度 CoreOS 社区会议，于5月9日至10日在柏林首次举行。
CoreOS 相信 Kubernetes 是提供 GIFEE（适用于所有人的 Google 的基础架构）服务的合适的容器编排组件。</p><p>在今年的 CoreOS Fest 上，有专门针对 Kubernetes 的报道，您将听到有关 Kubernetes 性能和可伸缩性，持续交付以及 Kubernetes，rktnetes，stackanetes 等各种主题的信息。
此外，这里将有各种各样的讲座，涵盖从入门讲习班到深入探讨容器和相关软件的方方面面。</p><p>不要错过<strong>柏林</strong>会议上的精彩演讲：</p><ul><li><a href="https://coreosfest2016.sched.org/event/6ckp/kubernetes-performance-scalability-deep-dive?iframe=no&w=i:100;&sidebar=yes&bg=no">深入了解 Kubernetes 的性能和可扩展性</a> 由 Google 的高级软件工程师 Filip Grzadkowski 演讲</li><li><a href=http://coreosfest2016.sched.org/event/6T0b/launching-a-complex-application-in-a-kubernetes-cloud>在 Kubernetes 云中启动一个复杂的应用程序</a> 由 immmr Gmbh（德国电信研发部门开发的服务）的运营和基础架构负责人Thomas Fricke 和 Jannis Rake-Revelant 演讲</li><li><a href="https://coreosfest2016.sched.org/event/6db3/i-have-kubernetes-now-what?iframe=no&w=i:100;&sidebar=yes&bg=no">我有 Kubernetes，现在呢？</a> 由 Engine Yard 的 CTO 和 Deis 的创建者 Gabriel Monroy 演讲</li><li><a href="https://coreosfest2016.sched.org/event/6YGg/when-rkt-meets-kubernetes-a-troubleshooting-tale?iframe=no&w=i:100;&sidebar=yes&bg=no">当 rkt 与 Kubernetes 碰面时 ：一个故障排除的故事</a> 由 Sysdig 的软件工程师 Luca Marturana 演讲</li><li><a href="https://coreosfest2016.sched.org/event/6eSE/use-kubernetes-to-deploy-telecom-applications?iframe=no&w=i:100;&sidebar=yes&bg=no">使用 Kubernetes 部署电信应用程序</a> 由华为技术有限公司高级工程师 Victor Hu 演讲</li><li><a href="https://coreosfest2016.sched.org/event/6qCs/continuous-delivery-kubernetes-and-you?iframe=no&w=i:100;&sidebar=yes&bg=no">连续交付，Kubernetes 和您</a> 由 Wercker首席执行官兼创始人 Micha Hernandez van Leuffen 演讲</li><li><a href="https://coreosfest2016.sched.org/event/6YJl/gifee-more-containers-more-problems?iframe=no&w=i:100;&sidebar=yes&bg=no">#GIFEE，更多容器，更多问题</a> 由 CoreOS 构造负责人 Ed Rooth 演讲</li><li><a href="https://coreosfest2016.sched.org/event/6YH4/kubernetes-access-control-with-dex?iframe=no&w=i:100;&sidebar=yes&bg=no">带有 dex 的 Kubernetes 访问控制</a> 由 CoreOS 的软件工程师 Eric Chiang 演讲</li></ul><p>如果您无法到达柏林，Kubernetes 还是** CoreOS Fest <a href=https://www.eventbrite.com/e/coreos-fest-san-francisco-satellite-event-tickets-22705108591>旧金山</a> ** <a href=https://www.eventbrite.com/e/coreos-fest-san-francisco-satellite-event-tickets-22705108591><strong>卫星事件</strong></a> 的焦点，这是一个专门针对 CoreOS 和 Kubernetes 的一日活动。
实际上， Google 的高级工程师， Kubernetes 的创建者之一 Tim Hockin 将以专门介绍 Kubernetes 更新的主题演讲拉开序幕。</p><p>专门针对 Kubernetes 的<strong>旧金山</strong>会议包括：</p><ul><li>Tim Hockin的主题演讲，Google 高级工程师</li><li>当 rkt 与 Kubernetes 相遇时：Sysdig 首席执行官 Loris Degioanni 的故障排除故事</li><li>rktnetes: CoreOS的软件工程师Derek Gonyeo提供了容器运行时和 Kubernetes 的新功能</li><li>神奇的安全性蔓延：CoreOS 和 Kubernetes 上的安全，弹性微服务，浮力技术总监 Oliver Gould</li></ul><p>** SF 的 Kubernetes 研讨会**：<a href=https://www.eventbrite.com/e/getting-started-with-kubernetes-tickets-25180552711>Kubernetes 入门</a>，
Google 开发人员计划工程师 Carter Morgan 和 Bill Prin 于5月10日（星期二）上午9:00至1:00 pm在 Google 旧金山办公室（Spear 街345号第7层）举办会议，之后将提供午餐。
席位有限，请 <a href=https://www.eventbrite.com/e/getting-started-with-kubernetes-tickets-25180552711>此处免费提供 RSVP</a> 。</p><p><strong>获取门票</strong> :</p><ul><li><a href=https://ti.to/coreos/coreos-fest-2016/en>CoreOS Fest - 柏林</a>, 位于 <a href="https://www.google.com/maps/place/bcc+Berlin+Congress+Center+GmbH/@52.5206732,13.4165195,15z/data=!4m2!3m1!1s0x0:0xd2a15220241f2080">柏林会议中心</a> (<a href=http://www.parkinn-berlin.de/>酒店选项</a>)</li><li>卫星事件在 <a href=https://www.eventbrite.com/e/coreos-fest-san-francisco-satellite-event-tickets-22705108591>旧金山</a>, 在 <a href="https://www.google.com/maps/place/111+Minna+Gallery/@37.7873222,-122.3994124,15z/data=!4m2!3m1!1s0x0:0xb55875af8c0ca88b?sa=X&ved=0ahUKEwjZ8cPLtL7MAhVQ5GMKHa8bCM4Q_BIIdjAN">111 米娜美术馆</a></li></ul><p>要了解更多信息，请访问： <a href=https://coreos.com/fest/>coreos.com/fest/</a>  和 Twitter <a href=https://twitter.com/coreosfest>@CoreOSFest</a> #CoreOSFest</p><p><em>-- Sarah Novotny, Kubernetes 社区管理者</em></p></div><div class=td-content style=page-break-before:always><h1 id=pg-f5bc74c369fabdc9aabeb7ba9c4f3d42>SIG-ClusterOps: 提升 Kubernetes 集群的可操作性和互操作性</h1><div class="td-byline mb-4"><time datetime=2016-04-19 class=text-muted>2016.04.19</time></div><p><em>编者注： 本周我们将推出 <a href=https://github.com/kubernetes/kubernetes/wiki/Special-Interest-Groups-(SIGs)>Kubernetes 特殊兴趣小组</a>；今天的帖子由 SIG-ClusterOps 团队负责，其任务是促进 Kubernetes 集群的可操作性和互操作性 -- 倾听，帮助和升级。</em></p><p>我们认为 Kubernetes 是大规模运行应用程序的绝佳方法！
不幸的是，存在一个引导问题：我们需要良好的方法来围绕 Kubernetes 构建安全可靠的扩展环境。
虽然平台管理的某些部分利用了平台（很酷！），这有一些基本的操作主题需要解决，还有一些问题（例如升级和一致性）需要回答。</p><p><strong>输入 Cluster Ops SIG – 在平台下工作以保持其运行的社区成员。</strong></p><p>我们对 Cluster Ops 的目标是首先成为一个人对人的社区，其次才是意见、文档、测试和脚本的来源。
这意味着我们将花费大量时间和精力来简单地比较有关工作内容的注释并讨论实际操作。
这些互动为我们提供了形成意见的数据。
这也意味着我们可以利用实际经验来为项目提供信息。</p><p>我们旨在成为对该项目进行运营审查和反馈的论坛。
为了使 Kubernetes 取得成功，运营商需要通过每周参与并收集调查数据在项目中拥有重要的声音。
我们并不是想对操作发表意见，但我们确实想创建一个协调的资源来收集项目的运营反馈。
作为一个公认的团体，操作员更容易获得影响力。</p><p><strong>现实世界中的可交付成果如何？</strong></p><p>我们也有切实成果的计划。
我们已经在努力实现具体的交付成果，例如参考架构，工具目录，社区部署说明和一致性测试。
Cluster Ops 希望成为运营资源的交换所。
我们将根据实际经验和经过战斗测试的部署来进行此操作。</p><p><strong>联系我们。</strong></p><p>集群运营可能会很辛苦–别一个人做。
我们在这里倾听，在我们可以帮助的时候提供帮助，而在我们不能帮助的时候向上一级反映。
在以下位置加入对话：</p><ul><li>在 <a href=https://kubernetes.slack.com/messages/sig-cluster-ops/>Cluster Ops Slack 频道</a> 与我们聊天</li><li>通过 <a href=https://groups.google.com/forum/#!forum/kubernetes-sig-cluster-ops>Cluster Ops SIG 电子邮件列表</a> 给我们发送电子邮件</li></ul><p>SIG Cluster Ops 每周四在太平洋标准时间下午 13:00 开会，您可以通过
<a href=https://plus.google.com/hangouts/_/google.com/sig-cluster-ops>视频环聊</a> 加入我们并查看最新的
<a href=https://docs.google.com/document/d/1IhN5v6MjcAUrvLd9dAWtKcGWBWSaRU8DNyPiof3gYMY/edit>会议记录</a>
了解所涉及的议程和主题。</p><p><em>-- RackN 首席执行官 Rob Hirschfeld</em></p></div><div class=td-content style=page-break-before:always><h1 id=pg-d3f23f912c594dbbccd2c55d5b380e84>“SIG-Networking：1.3 版本引入 Kubernetes 网络策略 API”</h1><div class="td-byline mb-4"><time datetime=2016-04-18 class=text-muted>2016.04.18</time></div><p><em>编者注：本周我们将推出 <a href=https://github.com/kubernetes/kubernetes/wiki/Special-Interest-Groups-(SIGs)>Kubernetes 特殊兴趣小组</a>、
Network-SIG 小组今天的帖子描述了 1.3 版中的网络策略 API-安全，隔离和多租户策略。</em></p><p>自去年下半年以来，<a href=https://kubernetes.slack.com/messages/sig-network/>Kubernetes SIG-Networking</a> 一直在定期开会，致力于将网络策略引入 Kubernetes，我们开始看到这个努力的结果。</p><p>许多用户面临的一个问题是，Kubernetes 的开放访问网络策略不适用于需要对访问容器或服务的流量进行更精确控制的应用程序。
如今，这种应用可能是多层应用，其中仅允许来自某个相邻层的流量。
但是，随着新的云原生应用不断通过组合微服务构建出来，对服务间流动的数据进行控制的能力变得更加重要。</p><p>在大多数 IaaS 环境（公共和私有）中，通过允许 VM 加入“安全组（Security Group）”来提供这种控制，
其中“安全组”成员的流量由网络策略或访问控制列表（ ACL ）定义，并由网络数据包过滤器实施。</p><p>SIG-Networking 开始这项工作时的第一步是辩识需要特定网络隔离以增强安全性的
<a href="https://docs.google.com/document/d/1blfqiH4L_fpn33ZrnQ11v7LcYP0lmpiJ_RaapAPBbNU/edit?pref=2&pli=1#">特定用例场景</a>。
确保所定义的 API 适用于这些简单和常见的用例非常重要，因为它们为在 Kubernetes 内
实现更复杂的网络策略以支持多租户奠定了基础。</p><p>基于这些场景，团队考虑了几种可能的方法，并定义了一个最小的
<a href=https://docs.google.com/document/d/1qAm-_oSap-f1d6a-xRTj6xaH1sYQBfK36VyjB5XOZug/edit>策略规范</a> 。
基本思想是，如果按命名空间启用了隔离，则特定流量类型被允许时会选择特定的 Pod。</p><p>快速支持此实验性 API 的最简单方法是对 API 服务器的 ThirdPartyResource 扩展，今天在 Kubernetes 1.2 中就可以实现。</p><p>如果您不熟悉它的工作方式，则可以通过定义 ThirdPartyResources 来扩展 Kubernetes API ，ThirdPartyResources 在指定的 URL 上创建一个新的 API 端点。</p><h4 id=third-party-res-def-yaml>third-party-res-def.yaml</h4><pre tabindex=0><code>kind: ThirdPartyResource
apiVersion: extensions/v1beta1
metadata:
name: network-policy.net.alpha.kubernetes.io
description: &#34;Network policy specification&#34;
versions:
- name: v1alpha1
</code></pre><pre tabindex=0><code>$kubectl create -f third-party-res-def.yaml
</code></pre><p>这将创建一个 API 端点（每个名称空间一个）：</p><pre tabindex=0><code>/net.alpha.kubernetes.io/v1alpha1/namespace/default/networkpolicys/
</code></pre><p>第三方网络控制器现在可以在这些端点上进行侦听，并在创建，修改或删除资源时根据需要做出反应。
<em>注意：在即将发布的 Kubernetes 1.3 版本中-当网络政策 API 以 beta 形式发布时-无需创建如上所示的 ThirdPartyResource API 端点。</em></p><p>默认情况下，网络隔离处于关闭状态，以便所有Pod都能正常通信。
但是，重要的是要知道，启用网络隔离后，所有命名空间中所有容器的所有流量都会被阻止，这意味着启用隔离将改变容器的行为</p><p>通过在名称空间上定义 <em>network-isolation</em> 注解来启用网络隔离，如下所示：</p><pre tabindex=0><code>net.alpha.kubernetes.io/network-isolation: [on | off]
</code></pre><p>启用网络隔离后，<strong>必须应用</strong>显式网络策略才能启用 Pod 通信。</p><p>可以将策略规范应用于命名空间，以定义策略的详细信息，如下所示：</p><pre tabindex=0><code>POST /apis/net.alpha.kubernetes.io/v1alpha1/namespaces/tenant-a/networkpolicys/

{
&#34;kind&#34;: &#34;NetworkPolicy&#34;,
&#34;metadata&#34;: {
&#34;name&#34;: &#34;pol1&#34;
},
&#34;spec&#34;: {
&#34;allowIncoming&#34;: {
&#34;from&#34;: [
{ &#34;pods&#34;: { &#34;segment&#34;: &#34;frontend&#34; } }
],
&#34;toPorts&#34;: [
{ &#34;port&#34;: 80, &#34;protocol&#34;: &#34;TCP&#34; }
]
},
&#34;podSelector&#34;: { &#34;segment&#34;: &#34;backend&#34; }
}
}
</code></pre><p>在此示例中，‘ <strong>tenant-a</strong> ’名称空间将按照指示应用策略‘ <strong>pol1</strong> ’。
具体而言，带有<strong>segment</strong>标签 ‘ <strong>后端</strong> ’ 的容器将允许接收来自带有“segment**标签‘ <strong>frontend</strong> ’的容器的端口80上的TCP流量。</p><p>现今，<a href=http://romana.io/>Romana</a>, <a href=https://www.openshift.com/>OpenShift</a>, <a href=http://www.opencontrail.org/>OpenContrail</a> 和 <a href=http://projectcalico.org/>Calico</a> 支持应用于名称空间和容器的网络策略。
思科和 VMware 也在努力实施。
Romana 和 Calico 最近都在 KubeCon 上使用 Kubernetes 1.2 演示了这些功能。
你可以在此处观看他们的演讲：<a href="https://www.youtube.com/watch?v=f-dLKtK6qCs">Romana</a> (<a href=http://www.slideshare.net/RomanaProject/kubecon-london-2016-ronana-cloud-native-sdn>slides</a>)， <a href="https://www.youtube.com/watch?v=p1zfh4N4SX0">Calico</a> (<a href=http://www.slideshare.net/kubecon/kubecon-eu-2016-secure-cloudnative-networking-with-project-calico>slides</a>)。 </p><p><strong>它是如何工作的？</strong></p><p>每个解决方案都有其自己的特定实现细节。
今天，他们依靠某种形式的主机执行机制，但是将来的实现也可以构建为在虚拟机管理程序上，甚至直接由网络本身应用策略构建。 </p><p>外部策略控制软件（具体情况因实现而异）将监视新 API 终结点是否正在创建容器和/或正在应用新策略。
当发生需要配置策略的事件时，侦听器将识别出更改，并且控制器将通过配置接口并应用策略来做出响应。 
下图显示了 API 侦听器和策略控制器，它通过主机代理在本地应用网络策略来响应更新。
主机上的网络接口由主机上的 CNI 插件配置（未显示）。</p><p><img src=https://lh5.googleusercontent.com/zMEpLMYmask-B-rYWnbMyGb0M7YusPQFPS6EfpNOSLbkf-cM49V7rTDBpA6k9-Zdh2soMul39rz9rHFJfL-jnEn_mHbpg0E1WlM-wjU-qvQu9KDTQqQ9uBmdaeWynDDNhcT3UjX5 alt=controller.jpg></p><p>如果您由于网络隔离和/或安全性问题而一直拒绝使用 Kubernetes 开发应用程序，那么这些新的网络策略将为您提供所需的控制功能大有帮助。
无需等到 Kubernetes 1.3，因为网络策略现在作为实验性 API 可用，已启用 ThirdPartyResource。</p><p>如果您对 Kubernetes 和网络感兴趣，有几种参与方式-请通过以下方式加入我们：</p><ul><li>我们的 <a href=https://kubernetes.slack.com/messages/sig-network/>Networking Slack 频道</a> </li></ul><ul><li>我们的 <a href=https://groups.google.com/forum/#!forum/kubernetes-sig-network>Kubernetes Networking Special Interest Group</a> 电子邮件列表 </li></ul><p>网络“特殊兴趣小组”，每两周一次，在太平洋时间下午 3 点（15：00）在<a href=https://zoom.us/j/5806599998>SIG-Networking 环聊</a>开会。 </p><p><em>--Pani Networks 联合创始人 Chris Marino</em></p></div><div class=td-content style=page-break-before:always><h1 id=pg-584fa2494155bf80b285f6d9e0dd5284>在 Rancher 中添加对 Kuernetes 的支持</h1><div class="td-byline mb-4"><time datetime=2016-04-08 class=text-muted>2016.04.08</time></div><p><em>今天的来宾帖子由 Rancher Labs（用于管理容器的开源软件平台）的首席架构师 Darren Shepherd 撰写。</em></p><p>在过去的一年中，我们看到希望在其软件开发和IT组织中利用容器的公司数量激增。
为了实现这一目标，组织一直在研究如何构建集中式的容器管理功能，该功能将使用户可以轻松访问容器，同时集中管理IT组织的可见性和控制力。
2014年，我们启动了开源 Rancher 项目，通过构建容器管理平台来解决此问题。</p><p>最近，我们发布了 Rancher v1.0。
在此最新版本中，用于管理容器的开源软件平台 <a href=http://www.rancher.com/>Rancher</a> 现在在创建环境时支持 Kubernetes 作为容器编排框架。
现在，使用 Rancher 启动 Kubernetes 环境是完全自动化的，只需 5 至 10 分钟即可交付运行正常的集群。</p><p>我们创建 Rancher 的目的是为组织提供完整的容器管理平台。
作为其中的一部分，我们始终支持使用 Docker API 和 Docker Compose 在本地部署 Docker 环境。
自成立以来， Kubernetes 的运营成熟度给我们留下了深刻的印象，而在此版本中，我们使得其可以在同一管理平台上部署各种容器编排和调度框架。</p><p>添加 Kubernetes 使用户可以访问增长最快的平台之一，用于在生产中部署和管理容器。
我们将在 Rancher 中提供一流的 Kubernetes 支持，并将继续支持本机 Docker 部署。</p><p><strong>将 Kubernetes 带到 Rancher</strong></p><p><img src=https://lh6.googleusercontent.com/bhmC1-XO5T-itFN3ZsCQmrxUSSEcnezaL-qch6ILWvJRnbhEBZZlAMEj-RcNgkM9XVEUzsRMsvDGc7u8f-M19Jdk_J0GCoO-gZTCZDtgkokgqNkCgP98o8W29xD0kmKiMPeLN-Tt alt="Kubernetes deployment-3.PNG"></p><p>我们的平台已经可以扩展为各种不同的包装格式，因此我们对拥抱 Kubernetes 感到乐观。
没错，作为开发人员，与 Kubernetes 项目一起工作是一次很棒的经历。
该项目的设计使这一操作变得异常简单，并且我们能够利用插件和扩展来构建 Kubernetes 发行版，从而利用我们的基础架构和应用程序服务。
例如，我们能够将 Rancher 的软件定义的网络，存储管理，负载平衡，DNS 和基础结构管理功能直接插入 Kubernetes，而无需更改代码库。</p><p>更好的是，我们已经能够围绕 Kubernetes 核心功能添加许多服务。
例如，我们在 Kubernetes 上实现了常用的 <a href=https://github.com/rancher/community-catalog/tree/master/kubernetes-templates>应用程序目录</a> 。
过去，我们曾使用 Docker Compose 定义应用程序模板，但是在此版本中，我们现在支持 Kubernetes 服务、副本控制器和和 Pod 来部署应用程序。
使用目录，用户可以连接到 git 仓库并自动部署和升级作为 Kubernetes 服务部署的应用。
然后，用户只需单击一下按钮，即可配置和部署复杂的多节点企业应用程序。
升级也是完全自动化的，并集中向用户推出。</p><p><strong>回馈</strong></p><p>与 Kubernetes 一样，Rancher 是一个开源软件项目，任何人均可免费使用，并且不受任何限制地分发给社区。
您可以在 <a href=http://www.github.com/rancher/rancher>GitHub</a> 上找到 Rancher 的所有源代码，即将发布的版本和问题。
我们很高兴加入 Kubernetes 社区，并期待与所有其他贡献者合作。
在Rancher <a href=http://rancher.com/kubernetes/>here</a> 中查看有关 Kubernetes 新支持的演示。 </p><p><em>-- Rancher Labs 首席架构师 Darren Shepherd</em></p></div><div class=td-content style=page-break-before:always><h1 id=pg-a59c3151a2598aa5539dd1e5f8b30666>KubeCon EU 2016：伦敦 Kubernetes 社区</h1><div class="td-byline mb-4"><time datetime=2016-02-24 class=text-muted>2016.02.24</time></div><p>KubeCon EU 2016 是首届<a href=http://kubernetes.io/>欧洲 Kubernetes</a> 社区会议，紧随 2015 年 11 月召开的北美会议。KubeCon 致力于为 <a href=http://kubernetes.io/>Kubernetes</a> 爱好者、产品用户和周围的生态系统提供教育和社区参与。</p><p>快来加入我们在伦敦，与 Kubernetes 社区的数百人一起出去，体验各种深入的技术专家讲座和用例。</p><p>不要错过这些优质的演讲：</p><ul><li><p>“Kubernetes 硬件黑客：通过旋钮、推杆和滑块探索 Kubernetes API” 演讲者 Ian Lewis 和 Brian Dorsey，谷歌开发布道师* <a href=http://sched.co/6Bl3>http://sched.co/6Bl3</a></p></li><li><p>“rktnetes: 容器运行时和 Kubernetes 的新功能” 演讲者 Jonathan Boulle, CoreOS 的主程 -* <a href=http://sched.co/6BY7>http://sched.co/6BY7</a></p></li><li><p>“Kubernetes 文档：贡献、修复问题、收集奖金” 作者：John Mulhausen，首席技术作家，谷歌 -* <a href=http://sched.co/6BUP>http://sched.co/6BUP</a> </p></li><li><p>“<a href="https://kubeconeurope2016.sched.org/event/6BYC/what-is-openstacks-role-in-a-kubernetes-world?iframe=yes&w=i:0;&sidebar=yes&bg=no#?iframe=yes&w=i:100;&sidebar=yes&bg=no">OpenStack 在 Kubernetes 的世界中扮演什么角色？</a>” 作者：Thierry carez, OpenStack 基金会工程总监 -* <a href=http://sched.co/6BYC>http://sched.co/6BYC</a></p></li><li><p>“容器调度的实用指南” 作者：Mandy Waite，开发者倡导者，谷歌 -* <a href=http://sched.co/6BZa>http://sched.co/6BZa</a></p></li><li><p>“<a href="https://kubeconeurope2016.sched.org/event/67f2/kubernetes-in-production-in-the-new-york-times-newsroom?iframe=yes&w=i:0;&sidebar=yes&bg=no#?iframe=yes&w=i:100;&sidebar=yes&bg=no">《纽约时报》编辑部正在制作 Kubernetes</a>” Eric Lewis，《纽约时报》网站开发人员 -* <a href=http://sched.co/67f2>http://sched.co/67f2</a></p></li><li><p>“<a href="https://kubeconeurope2016.sched.org/event/6Bc9/creating-an-advanced-load-balancing-solution-for-kubernetes-with-nginx?iframe=yes&w=i:0;&sidebar=yes&bg=no#?iframe=yes&w=i:100;&sidebar=yes&bg=no">使用 NGINX 为 Kubernetes 创建一个高级负载均衡解决方案</a>” 作者：Andrew Hutchings, NGINX 技术产品经理 -* <a href=http://sched.co/6Bc9>http://sched.co/6Bc9</a></p></li><li><p>还有更多 <a href=http://kubeconeurope2016.sched.org/>http://kubeconeurope2016.sched.org/</a></p></li></ul><p><a href=https://ti.to/kubecon/kubecon-eu-2016>在这里</a>获取您的 KubeCon EU 门票。</p><p>会场地址：CodeNode * 英国伦敦南广场 10 号<br>酒店住宿：<a href=https://skillsmatter.com/contact-us>酒店</a><br>网站：[kubecon.io] (<a href=https://www.kubecon.io/>https://www.kubecon.io/</a>)<br>推特：[@KubeConio] (<a href=https://twitter.com/kubeconio>https://twitter.com/kubeconio</a>)
谷歌是 KubeCon EU 2016 的钻石赞助商。下个月 3 月 10 - 11 号来伦敦，参观 13 号展位，了解 Kubernetes，Google Container Engine（GKE），Google Cloud Platform 的所有信息!</p><p>_KubeCon 是由 KubeAcademy、LLC 组织的，这是一个由社区驱动的开发者团体，专注于开发人员的教育和 kubernetes 的推广
-* Sarah Novotny, 谷歌的 Kubernetes 社区经理</p></div><div class=td-content style=page-break-before:always><h1 id=pg-5c389f15f0500871a7419690797bb894>Kubernetes 社区会议记录 - 20160218</h1><div class="td-byline mb-4"><time datetime=2016-02-23 class=text-muted>2016.02.23</time></div><h5 id=2月18号-kmachine-演示-sig-clusterops-成立-新的-k8s-io-网站预览-1-2-版本更新和-1-3-版本计划>2月18号 - kmachine 演示、SIG clusterops 成立、新的 k8s.io 网站预览、1.2 版本更新和 1.3 版本计划</h5><p>Kubernetes 贡献社区会议大多在星期四的 10:00 召开，通过视频会议讨论项目现有情况。这里是最近一次会议的笔记。</p><ul><li>记录员: Rob Hirschfeld</li><li>示例 (10 min): <a href=https://github.com/skippbox/kmachine>kmachine</a> [Sebastien Goasguen]<ul><li>开始 :01 视频介绍</li><li>为 Kubernetes 创建 Docker tools 的镜像 （例如 machine,compose 等等）</li><li>kmachine （ 它是 Docker Machine的一个分叉, 因此两者有相同的 endpoints）</li></ul></li></ul><ul><li>演示案例 (10 min): 开始时间 :15</li></ul><ul><li>SIG 汇报启动会<ul><li>周五进行 Cluster Ops 启动会 (<a href=https://docs.google.com/document/d/1IhN5v6MjcAUrvLd9dAWtKcGWBWSaRU8DNyPiof3gYMY/edit#>doc</a>). [Rob Hirschfeld]</li></ul></li></ul><ul><li>时区讨论 [:22]<ul><li>当前时区不适合亚洲。</li><li>考虑轮转时间 - 每一个月一次</li><li>大约 5 或者 6 PT</li><li>Rob 建议把例会时间上调一些</li></ul></li></ul><ul><li>k8s.io 网站 概述 [John Mulhausen] [:27]<ul><li>使用 github 进行文档操作。你可以通过网站进行 fork 操作并且做一个 pull request 请求</li><li>Google 将会提供一个 "doc bounty"，"doc bounty" 是一个让你得到 GCP 积分来为你的文档使用的地方</li><li>使用 Jekyll 创建网站 (例如 the ToC)</li><li>100% 使用 GitHub 页面原则; 没有脚本或者插件外挂, 仅仅只有 fork/clone，edit，和 push 操作</li><li>希望能在 Kubecon EU 启动</li><li>主页唯一概述地址: <a href=http://kub.unitedcreations.xyz>http://kub.unitedcreations.xyz</a></li></ul></li></ul><ul><li>1.2 版本观看 [T.J. Goltermann] [:38]</li><li>1.3 版本更新计划 [T.J. Goltermann]</li><li>GSoC 分享会 -- 截止日期 2月19号 [Sarah Novotny]</li><li>3月10号 会议? [Sarah Novotny]</li></ul><p>想要加入 Kubernetes 社区的人，考虑加入 [Slack channel] <a href=http://slack.k8s.io/>3</a>频道，
在 GitHub 上看看<a href=https://github.com/kubernetes/>Kubernetes project</a>，
或者加入<a href=https://groups.google.com/forum/#!forum/kubernetes-dev>Kubernetes-dev Google group</a>。</p><p>如果你对此真的充满激情，你可以做完上述所有事情并加入我们的下一次社区对话 - 在2016年2月25日。</p><p>请将您自己或您想了解的主题添加到<a href=https://docs.google.com/document/d/1VQDIAB0OqiSjIHI8AWMvSdceWhnz56jNpZrLs6o7NJY/edit#>agenda</a>，加入<a href=https://groups.google.com/forum/#!forum/kubernetes-community-video-chat>this group</a>组即可获得日历邀请。</p><p>"https://youtu.be/L5BgX2VJhlY?list=PL69nYSiGNLP1pkHsbPjzAewvMgGUpkCnJ"</p><p>_-- Kubernetes 社区 _</p></div><div class=td-content style=page-break-before:always><h1 id=pg-ca2bb4aa037f8b34a465c33394c21026>Kubernetes 社区会议记录 - 20160204</h1><div class="td-byline mb-4"><time datetime=2016-02-09 class=text-muted>2016.02.09</time></div><h4 id=2-月-4-日-rkt-演示-祝贺-1-0-版本-coreos-ebay-将-k8s-放在-openstack-上并认为-openstack-在-k8s-sig-和片状测试激增方面取得了进展>2 月 4 日 - rkt 演示（祝贺 1.0 版本，CoreOS！），eBay 将 k8s 放在 Openstack 上并认为 Openstack 在 k8s，SIG 和片状测试激增方面取得了进展。</h4><p>Kubernetes 贡献社区在每周四 10:00 PT 开会,通过视频会议讨论项目状态。以下是最近一次会议的笔记。</p><ul><li>书记员：Rob Hirschfeld</li><li>演示视频（20 分钟）：CoreOS rkt + Kubernetes [Shaya Potter]<ul><li>期待在未来几个月内看到与rkt和k8s的整合（“rkt-netes”）。 还没有集成到 v1.2 版本中。</li><li>Shaya 做了一个演示（8分钟的会议视频参考）<ul><li>rkt 的 CLI 显示了旋转容器</li><li>[注意：音频在点数上是乱码]</li><li>关于 k8s&rkt 整合的讨论</li><li>下周 rkt 社区同步： <a href=https://groups.google.com/forum/#!topic/rkt-dev/FlwZVIEJGbY>https://groups.google.com/forum/#!topic/rkt-dev/FlwZVIEJGbY</a></li><li>Dawn Chen:<ul><li>将 rkt 与 kubernetes 集成的其余问题：1）cadivsor 2） DNS 3）与日志记录相关的错误</li><li>但是需要在 e2e 测试套件上做更多的工作</li></ul></li></ul></li></ul></li></ul><ul><li>用例（10分钟）：在 OpenStack 上的 eBay k8s 和 k8s 上的 OpenStack [Ashwin Raveendran]<ul><li>eBay 目前正在 OpenStack 上运行 Kubernetes</li><li>eBay 的目标是管理带有 k8s 的 OpenStack 控制平面。目标是实现升级。</li><li>OpenStack Kolla 为控制平面创建容器。使用 Ansible+Docker 来管理容器。</li><li>致力于 k8s 控制计划管理 - Saltstack 被证明是他们想运营的规模的管理挑战。寻找 k8s 控制平面的自动化管理。</li></ul></li></ul><ul><li>SIG 报告</li><li>测试更新 [Jeff, Joe, 和 Erick]<ul><li>努力使有助于 K8s 的工作流程更容易理解<ul><li><a href=https://github.com/kubernetes/kubernetes/pull/19714>pull/19714</a>有 bot 流程图来帮助用户理解</li></ul></li><li>需要一种一致的方法来运行测试 w/hacking 配置脚本（你现在必须伪造一个 Jenkins 进程）</li><li>想要创建必要的基础设施，使测试设置不那么薄弱</li><li>想要将测试开始（单次或完整）与 Jenkins分离</li><li>目标是指出你有一个可以指向任何集群的脚本</li><li>演示包括 Google 内部视图 - 努力尝试获取外部视图。</li><li>希望能够收集测试运行结果</li><li>Bob Wise 不赞同在 v1.3 版本进行测试方面的基础设施建设。</li><li>关于测试实践的长期讨论…<ul><li>我们希望在多个平台上进行测试的共识。</li><li>为测试报告提供一个全面转储会很有帮助</li><li>可以使用"phone-home"收集异常</li></ul></li></ul></li></ul><ul><li>1.2发布观察</li><li>CoC [Sarah]</li><li>GSoC [Sarah]</li></ul><p>要参与 Kubernetes 社区，请考虑加入我们的 <a href=https://slack.k8s.io/>Slack 频道</a>，查看 GitHub 上的
<a href=https://github.com/kubernetes/>Kubernetes 项目</a>，或加入 <a href=https://groups.google.com/forum/#!forum/kubernetes-dev>Kubernetes-dev Google 小组</a>。
如果你真的很兴奋，你可以完成上述所有工作并加入我们的下一次社区对话 - 2016 年 2 月 11 日。
请将你自己或你想要了解的主题添加到<a href=https://docs.google.com/document/d/1VQDIAB0OqiSjIHI8AWMvSdceWhnz56jNpZrLs6o7NJY/edit#>议程</a>并通过加入<a href=https://groups.google.com/forum/#!forum/kubernetes-community-video-chat>此组</a>来获取日历邀请。</p><p>"https://youtu.be/IScpP8Cj0hw?list=PL69nYSiGNLP1pkHsbPjzAewvMgGUpkCnJ"</p></div><div class=td-content style=page-break-before:always><h1 id=pg-7b6c140fad77ba1f495571539d32b7aa>容器世界现状，2016 年 1 月</h1><div class="td-byline mb-4"><time datetime=2016-02-01 class=text-muted>2016.02.01</time></div><p>新年伊始，我们进行了一项调查，以评估容器世界的现状。
我们已经准备好发送<a href=https://docs.google.com/forms/d/13yxxBqb5igUhwrrnDExLzZPjREiCnSs-AH-y4SSZ-5c/viewform> 2 月版</a>但在此之前，让我们从 119 条回复中看一下 1 月的数据（感谢您的参与！）。</p><p>关于这些数字的注释：
首先，您可能会注意到，这些数字加起来并不是 100％，在大多数情况下，选择不是唯一的，因此给出的百分比是选择特定选择的所有受访者的百分比。
其次，虽然我们尝试覆盖广泛的云社区，但调查最初是通过 Twitter 发送给<a href=https://twitter.com/brendandburns>@brendandburns</a>，<a href=https://twitter.com/kelseyhightower>@kelseyhightower</a>，<a href=https://twitter.com/sarahnovotny>@sarahnovotny</a>，<a href=https://twitter.com/juliaferraioli>@juliaferraioli</a>，<a href=https://twitter.com/thagomizer_rb>@thagomizer_rb</a>，因此受众覆盖可能并不完美。
我们正在努力扩大样本数量（我是否提到过2月份的调查？<a href=https://docs.google.com/forms/d/13yxxBqb5igUhwrrnDExLzZPjREiCnSs-AH-y4SSZ-5c/viewform>点击立即参加</a>)。</p><h4 id=言归正传-来谈谈数据>言归正传，来谈谈数据：</h4><p>首先，很多人正在使用容器！目前有 71％ 的人正在使用容器，而其中有 24％ 的人正在考虑尽快使用它们。
显然，这表明样本集有些偏颇。
在更广泛的社区中，容器使用的数量有所不同，但绝对低于 71％。
因此，对这些数字的其余部分要持怀疑态度。</p><p>那么人们在使用容器做什么呢？
超过 80％ 的受访者使用容器进行开发，但只有 50％ 的人在生产环境下使用容器。
但是他们有计划很快投入到生产环境之中，78% 的容器用户表示了意愿。</p><p>你们在哪里部署容器？
你的笔记本电脑显然是赢家，53% 的人使用笔记本电脑。
接下来是 44％ 的人在自己的 VM 上运行（Vagrant？OpenStack？我们将在2月的调查中尝试深入研究），然后是 33％ 的人在物理基础架构上运行，而 31％ 的人在公共云 VM 上运行。</p><p>如何部署容器？
你们当中有 54% 的人使用 Kubernetes，虽然看起来有点受样本集的偏见（请参阅上面的注释），但真是令人惊讶，但有 45％ 的人在使用 shell 脚本。
是因为 Kubernetes 存储库中正在运行大量（且很好）的 Bash 脚本吗？
继续下去，我们可以看到真相……
数据显示，25% 使用 CAPS (Chef/Ansible/Puppet/Salt)系统，约 13% 使用 Docker Swarm、Mesos 或其他系统。</p><p>最后，我们让人们自由回答使用容器的挑战。
这儿有一些进行了分组和复制的最有趣的答案：</p><h6 id=开发复杂性>开发复杂性</h6><ul><li>“孤立的开发环境/工作流程可能是零散的，调试容器时可以轻松访问日志等工具，但有时却不太直观，需要大量知识来掌握整个基础架构堆栈和部署/ 更新 kubernetes，到底层网络等。”</li><li>“迁移开发者的工作流程。 那些不熟悉容器、卷等的人只是想工作。”</li></ul><h6 id=安全>安全</h6><ul><li>“网络安全”</li><li>“Secrets”</li></ul><h6 id=不成熟>不成熟</h6><ul><li>“缺乏全面的非专有标准（例如，非 Docker），例如 runC / OCI”</li><li>“仍处于早期阶段，只有很少的工具和许多缺少的功能。”</li><li>“糟糕的 CI 支持，很多工具仍然处于非常早期的阶段。”</li><li>"我们以前从未那样做过。"</li></ul><h6 id=复杂性>复杂性</h6><ul><li>“网络支持， 为 kubernetes 在裸机上为每个 Pod 提供 IP”</li><li>“集群化还是太难了”</li><li>“设置 Mesos 和 Kubernetes 太复杂了！！”</li></ul><h6 id=数据>数据</h6><ul><li>“卷缺乏灵活性（与 VM，物理硬件等相同的问题）”</li><li>“坚持不懈”</li><li>“存储”</li><li>“永久数据”</li></ul><p><em>下载完整的调查结果 <a href="https://docs.google.com/spreadsheets/d/18wZe7wEDvRuT78CEifs13maXoSGem_hJvbOSmsuJtkA/pub?gid=530616014&single=true&output=csv">链接</a> (CSV 文件）。</em></p><p>_Up-- Brendan Burns，Google 软件工程师</p></div><div class=td-content style=page-break-before:always><h1 id=pg-eace1ed65ee850592eaf33f599130b33>Kubernetes 社区会议记录 - 20160114</h1><div class="td-byline mb-4"><time datetime=2016-01-28 class=text-muted>2016.01.28</time></div><h5 id=1-月-14-日-rackn-演示-测试问题和-kubecon-eu-cfp>1 月 14 日 - RackN 演示、测试问题和 KubeCon EU CFP。</h5><hr><h2 id=记录者-joe-beda>记录者：Joe Beda</h2><ul><li><p>演示：在 Metal，AWS 和其他平台上使用 Digital Rebar 自动化部署，来自 RackN 的 Rob Hirschfeld 和 Greg Althaus。</p><ul><li><p>Greg Althaus。首席技术官。Digital Rebar 是产品。裸机置备工具。</p></li><li><p>检测硬件，启动硬件，配置 RAID、操作系统并部署工作负载。</p></li><li><p>处理 Kubernetes 的工作负载。</p></li><li><p>看到始于云，然后又回到裸机的趋势。</p></li><li><p>新的提供商模型可以在云和裸机上使用预配置系统。</p></li><li><p>UI, REST API, CLI</p></li><li><p>演示：数据包--裸机即服务</p><ul><li><p>4个正在运行的节点归为一个“部署”</p></li><li><p>每个节点选择的功能性角色/操作。</p></li><li><p>分解的 kubernetes 带入可以订购和同步的单元。依赖关系树--诸如在启动 k8s master 之前等待 etcd 启动的事情。</p></li><li><p>在封面下使用 Ansible。</p></li><li><p>演示带来了另外5个节点--数据包将构建这些节点</p></li><li><p>从 ansible 中提取基本参数。诸如网络配置，DNS 设置等内容。</p></li><li><p>角色层次结构引入了其他组件--使节点成为主节点会带来一系列其他必要的角色。</p></li><li><p>通过简单的配置文件将所有这些组合到命令行工具中。</p></li></ul></li><li><p>转发：扩展到多个云以进行测试部署。还希望在裸机和云之间创建拆分/复制。</p></li><li><p>问：秘密？<br>答：使用 Ansible。构建自己的证书，然后分发它们。想要将它们抽象出来并将其推入上游。</p></li><li><p>问：您是否支持使用 PXE 引导从真正的裸机启动？<br>答：是的--将发现裸机系统并安装操作系统，安装 ssh 密钥，建立网络等。</p></li></ul></li></ul><ul><li><p>[来自 SIG-scalability]问：转到 golang 1.5 的状态如何？<br>答：在 HEAD，我们是1.5，但也会支持1.4。有一些跟稳定性相关的问题，但看起来现在情况稳定了。</p><ul><li><p>还希望使用1.5供应商实验。不再使用 godep。但只有在基线为1.5之前，才能这样做。</p></li><li><p>Sarah：现在我们正在工作的事情之一就是提供做这些事的小奖品。云积分，T恤，扑克筹码，小马。</p></li></ul></li><li><p>[来自可伸缩性兴趣小组]问：清理基于 jenkins 的提交队列的状态如何？社区可以做些什么来帮助您？<br>答：最近几天一直很艰难。每个方面都应该有相关的问题。在这些问题上有一个<a href=https://github.com/kubernetes/kubernetes/labels/kind%2Fflake>片状标签</a>。</p><ul><li><p>仍在进行联盟测试。现在有更多测试资源。随着新人们的进步，事情有希望进展的更快。这对让很多人在他们的环境中进行端到端测试非常有用。</p></li><li><p>Erick Fjeta 是新的测试负责人</p></li><li><p>Brendan很乐意帮助分享有关 Jenkins 设置的详细信息，但这不是必须的。</p></li><li><p>联盟可以使用 Jenkins API，但不需要 Jenkins 本身。</p></li><li><p>Joe 嘲笑以 Jenkins 的方式运行 e2e 测试是一件棘手的事实。布伦丹说，它应该易于运行。乔再看一眼。</p></li><li><p>符合性测试？ etune 做到了，但他不在。 -重新访问20150121</p></li></ul></li></ul><ul><li><pre><code>* 3月10日至11日在伦敦举行。地点将于本周宣布。
</code></pre><ul><li><p>请发送讲话！CFP 截止日期为2月5日。</p></li><li><p>令人兴奋。看起来是700-800人。比SF版本大（560 人）。</p></li><li><p>提前购买门票--早起的鸟儿价格将很快结束，价格将上涨到100英镑。</p></li><li><p>为演讲者提供住宿吗？</p></li><li><p>三星 Bob 的提问：我们可以针对以下问题获得更多警告/计划吗：</p><ul><li><p>答：Sarah -- 我不太早就听说过这些东西，但会尝试整理一下清单。努力使 kubernetes.io 上的事件页面更易于使用。</p></li><li><p>答：JJ -- 我们将确保我们早日为下届美国会议提供更多信息。</p></li></ul></li></ul></li></ul><ul><li><p>规模测试[RackN 的 Rob Hirschfeld] -- 如果您想帮助进行规模测试，我们将非常乐意为您提供帮助。</p><ul><li><p>Bob 邀请 Rob 加入规模特别兴趣小组。</p></li><li><p>还有一个大型的裸机集群，通过 CNCF（来自 Intel）也很有用。尚无确切日期。</p></li></ul></li><li><p>笔记/视频将发布在 k8s 博客上。（未录制20150114的视频。失败。）</p></li></ul><p>要加入 Kubernetes 社区，请考虑加入我们的<a href=http://slack.k8s.io/>Slack 频道</a>，看看GitHub上的<a href=https://github.com/kubernetes/>Kubernetes 项目</a>，或加入<a href=https://groups.google.com/forum/#!forum/kubernetes-dev>Kubernetes-dev Google 论坛</a>。如果您真的对此感到兴奋，则可以完成上述所有操作，并加入我们的下一次社区对话-2016年1月27日。请将您自己或您想了解的话题添加到<a href=https://docs.google.com/document/d/1VQDIAB0OqiSjIHI8AWMvSdceWhnz56jNpZrLs6o7NJY/edit#>议程</a>中，并获得一个加入<a href=https://groups.google.com/forum/#!forum/kubernetes-community-video-chat>此群组</a>进行日历邀请。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-bf667c51e2011c6904d9968c4e0e4850>为什么 Kubernetes 不用 libnetwork</h1><div class="td-byline mb-4"><time datetime=2016-01-14 class=text-muted>2016.01.14</time></div><p>在 1.0 版本发布之前，Kubernetes 已经有了一个非常基础的网络插件形式-大约在引入 Docker’s <a href=https://github.com/docker/libnetwork>libnetwork</a> 和 Container Network Model (<a href=https://github.com/docker/libnetwork/blob/master/docs/design.md>CNM</a>) 的时候。与 libnetwork 不同，Kubernetes 插件系统仍然保留它的 'alpha' 名称。现在 Docker 的网络插件支持已经发布并得到支持，我们发现一个明显的问题是 Kubernetes 尚未采用它。毕竟，供应商几乎肯定会为 Docker 编写插件-我们最好还是用相同的驱动程序，对吧？</p><p>在进一步说明之前，重要的是记住 Kubernetes 是一个支持多种容器运行时的系统， Docker 只是其中之一。配置网络只是每一个运行时的一个方面，所以当人们问起“ Kubernetes 会支持CNM吗？”，他们真正的意思是“ Kubernetes 会支持 Docker 运行时的 CNM 驱动吗？”如果我们能够跨运行时实现通用的网络支持会很棒，但这不是一个明确的目标。</p><p>实际上， Kubernetes 还没有为 Docker 运行时采用 CNM/libnetwork 。事实上，我们一直在研究 CoreOS 提出的替代 Container Network Interface (<a href=https://github.com/appc/cni/blob/master/SPEC.md>CNI</a>) 模型以及 App Container (<a href=https://github.com/appc>appc</a>) 规范的一部分。为什么我们要这么做？有很多技术和非技术的原因。</p><p>首先，Docker 的网络驱动程序设计中存在一些基本假设，这些假设会给我们带来问题。</p><p>Docker 有一个“本地”和“全局”驱动程序的概念。本地驱动程序（例如 "bridge" ）以机器为中心，不进行任何跨节点协调。全局驱动程序（例如 "overlay" ）依赖于 <a href=https://github.com/docker/libkv>libkv</a> （一个键值存储抽象库）来协调跨机器。这个键值存储是另一个插件接口，并且是非常低级的（键和值，没有其他含义）。 要在 Kubernetes 集群中运行类似 Docker's overlay 驱动程序，我们要么需要集群管理员来运行 <a href=https://github.com/hashicorp/consul>consul</a>, <a href=https://github.com/coreos/etcd>etcd</a> 或 <a href=https://zookeeper.apache.org/>zookeeper</a> 的整个不同实例 (see <a href=https://docs.docker.com/engine/userguide/networking/get-started-overlay/>multi-host networking</a>) 否则我们必须提供我们自己的 libkv 实现，那被 Kubernetes 支持。</p><p>后者听起来很有吸引力，并且我们尝试实现它，但 libkv 接口是非常低级的，并且架构在内部定义为 Docker 。我们必须直接暴露我们的底层键值存储，或者提供键值语义（在我们的结构化API之上，它本身是在键值系统上实现的）。对于性能，可伸缩性和安全性原因，这些都不是很有吸引力。最终结果是，当使用 Docker 网络的目标是简化事情时，整个系统将显得更加复杂。</p><p>对于愿意并且能够运行必需的基础架构以满足 Docker 全局驱动程序并自己配置 Docker 的用户， Docker 网络应该“正常工作。” Kubernetes 不会妨碍这样的设置，无论项目的方向如何，该选项都应该可用。但是对于默认安装，实际的结论是这对用户来说是一个不应有的负担，因此我们不能使用 Docker 的全局驱动程序（包括 "overlay" ），这消除了使用 Docker 插件的很多价值。</p><p>Docker 的网络模型做出了许多对 Kubernetes 无效的假设。在 docker 1.8 和 1.9 版本中，它包含一个从根本上有缺陷的“发现”实现，导致容器中的 <code>/etc/hosts</code> 文件损坏 (<a href=https://github.com/docker/docker/issues/17190>docker #17190</a>) - 并且这不容易被关闭。在 1.10 版本中，Docker 计划 <a href=https://github.com/docker/docker/issues/17195>捆绑一个新的DNS服务器</a>，目前还不清楚是否可以关闭它。容器级命名不是 Kubernetes 的正确抽象 - 我们已经有了自己的服务命名，发现和绑定概念，并且我们已经有了自己的 DNS 模式和服务器（基于完善的 <a href=https://github.com/skynetservices/skydns>SkyDNS</a> ）。捆绑的解决方案不足以满足我们的需求，但不能禁用。</p><p>与本地/全局拆分正交， Docker 具有进程内和进程外（ "remote" ）插件。我们调查了是否可以绕过 libnetwork （从而跳过上面的问题）并直接驱动 Docker remote 插件。不幸的是，这意味着我们无法使用任何 Docker 进程中的插件，特别是 "bridge" 和 "overlay"，这再次消除了 libnetwork 的大部分功能。</p><p>另一方面， CNI 在哲学上与 Kubernetes 更加一致。它比 CNM 简单得多，不需要守护进程，并且至少有合理的跨平台（ CoreOS 的 <a href=https://coreos.com/rkt/docs/>rkt</a> 容器运行时支持它）。跨平台意味着有机会启用跨运行时（例如 Docker ， Rocket ， Hyper ）运行相同的网络配置。 它遵循 UNIX 的理念，即做好一件事。</p><p>此外，包装 CNI 插件并生成更加个性化的 CNI 插件是微不足道的 - 它可以通过简单的 shell 脚本完成。 CNM 在这方面要复杂得多。这使得 CNI 对于快速开发和迭代是有吸引力的选择。早期的原型已经证明，可以将 kubelet 中几乎 100％ 的当前硬编码网络逻辑弹出到插件中。</p><p>我们调查了为 Docker <a href=https://groups.google.com/g/kubernetes-sig-network/c/5MWRPxsURUw>编写 "bridge" CNM驱动程序</a> 并运行 CNI 驱动程序。事实证明这非常复杂。首先， CNM 和 CNI 模型非常不同，因此没有一种“方法”协调一致。 我们仍然有上面讨论的全球与本地和键值问题。假设这个驱动程序会声明自己是本地的，我们必须从 Kubernetes 获取有关逻辑网络的信息。</p><p>不幸的是， Docker 驱动程序很难映射到像 Kubernetes 这样的其他控制平面。具体来说，驱动程序不会被告知连接容器的网络名称 - 只是 Docker 内部分配的 ID 。这使得驱动程序很难映射回另一个系统中存在的任何网络概念。</p><p>这个问题和其他问题已由网络供应商提出给 Docker 开发人员，并且通常关闭为“按预期工作”，(<a href=https://github.com/docker/libnetwork/issues/139>libnetwork #139</a>, <a href=https://github.com/docker/libnetwork/issues/486>libnetwork #486</a>, <a href=https://github.com/docker/libnetwork/pull/514>libnetwork #514</a>, <a href=https://github.com/docker/libnetwork/issues/865>libnetwork #865</a>, <a href=https://github.com/docker/docker/issues/18864>docker #18864</a>)，即使它们使非 Docker 第三方系统更难以与之集成。在整个调查过程中， Docker 明确表示他们对偏离当前路线或委托控制的想法不太欢迎。这对我们来说非常令人担忧，因为 Kubernetes 补充了 Docker 并增加了很多功能，但它存在于 Docker 之外。</p><p>出于所有这些原因，我们选择投资 CNI 作为 Kubernetes 插件模型。这会有一些不幸的副作用。它们中的大多数都相对较小（例如， <code>docker inspect</code> 不会显示 IP 地址），特别是由 <code>docker run</code> 启动的容器可能无法与 Kubernetes 启动的容器通信，如果网络集成商想要与 Kubernetes 完全集成，则必须提供 CNI 驱动程序。但另一方面， Kubernetes 将变得更简单，更灵活，早期引入的许多丑陋的（例如配置 Docker 使用我们的网桥）将会消失。</p><p>当我们沿着这条道路前进时，我们会保持开放，以便更好地整合和简化。如果您对我们如何做到这一点有所想法，我们真的希望听到它们 - 在 <a href=http://slack.k8s.io/>slack</a> 或者 <a href=https://groups.google.com/g/kubernetes-sig-network>network SIG mailing-list</a> 找到我们。</p><p>Tim Hockin, Software Engineer, Google</p></div><div class=td-content style=page-break-before:always><h1 id=pg-f2fbd7b648c34ea2b5bc519080891738>Kubernetes 和 Docker 简单的 leader election</h1><div class="td-byline mb-4"><time datetime=2016-01-11 class=text-muted>2016.01.11</time></div><h4 id=概述>概述</h4><p>Kubernetes 简化了集群上运行的服务的部署和操作管理。但是，它也简化了这些服务的发展。在本文中，我们将看到如何使用 Kubernetes 在分布式应用程序中轻松地执行 leader election。分布式应用程序通常为了可靠性和可伸缩性而复制服务的任务，但通常需要指定其中一个副本作为负责所有副本之间协调的负责人。</p><p>通常在 leader election 中，会确定一组成为领导者的候选人。这些候选人都竞相宣布自己为领袖。其中一位候选人获胜并成为领袖。一旦选举获胜，领导者就会不断地“信号”以表示他们作为领导者的地位，其他候选人也会定期地做出新的尝试来成为领导者。这样可以确保在当前领导因某种原因失败时，快速确定新领导。</p><p>实现 leader election 通常需要部署 ZooKeeper、etcd 或 Consul 等软件并将其用于协商一致，或者也可以自己实现协商一致算法。我们将在下面看到，Kubernetes 使在应用程序中使用 leader election 的过程大大简化。</p><p>####在 Kubernetes 实施领导人选举</p><p>Leader election 的首要条件是确定候选人的人选。Kubernetes 已经使用 <em>Endpoints</em> 来表示组成服务的一组复制 pod，因此我们将重用这个相同的对象。（旁白：您可能认为我们会使用 <em>ReplicationControllers</em>，但它们是绑定到特定的二进制文件，而且通常您希望只有一个领导者，即使您正在执行滚动更新）</p><p>要执行 leader election，我们使用所有 Kubernetes api 对象的两个属性：</p><ul><li>ResourceVersions - 每个 API 对象都有一个惟一的 ResourceVersion，您可以使用这些版本对 Kubernetes 对象执行比较和交换</li><li>Annotations - 每个 API 对象都可以用客户端使用的任意键/值对进行注释。</li></ul><p>给定这些原语，使用 master election 的代码相对简单，您可以在这里找到<a href=https://github.com/kubernetes/contrib/pull/353>here</a>。我们自己来做吧。</p><pre tabindex=0><code>$ kubectl run leader-elector --image=gcr.io/google_containers/leader-elector:0.4 --replicas=3 -- --election=example
</code></pre><p>这将创建一个包含3个副本的 leader election 集合：</p><pre tabindex=0><code>$ kubectl get pods
NAME                   READY     STATUS    RESTARTS   AGE
leader-elector-inmr1   1/1       Running   0          13s
leader-elector-qkq00   1/1       Running   0          13s
leader-elector-sgwcq   1/1       Running   0          13s
</code></pre><p>要查看哪个pod被选为领导，您可以访问其中一个 pod 的日志，用您自己的一个 pod 的名称替换</p><pre tabindex=0><code>${pod_name}, (e.g. leader-elector-inmr1 from the above)

$ kubectl logs -f ${name}
leader is (leader-pod-name)
</code></pre><p>…或者，可以直接检查 endpoints 对象：</p><p>_'example' 是上面 kubectl run … 命令_中候选集的名称</p><pre tabindex=0><code>$ kubectl get endpoints example -o yaml
</code></pre><p>现在，要验证 leader election 是否实际有效，请在另一个终端运行：</p><pre tabindex=0><code>$ kubectl delete pods (leader-pod-name)
</code></pre><p>这将删除现有领导。由于 pod 集由 replication controller 管理，因此新的 pod 将替换已删除的pod，确保复制集的大小仍为3。通过 leader election，这三个pod中的一个被选为新的领导者，您应该会看到领导者故障转移到另一个pod。因为 Kubernetes 的吊舱在终止前有一个 <em>grace period</em>，这可能需要30-40秒。</p><p>Leader-election container 提供了一个简单的 web 服务器，可以服务于任何地址(e.g. http://localhost:4040)。您可以通过删除现有的 leader election 组并创建一个新的 leader elector 组来测试这一点，在该组中，您还可以向 leader elector 映像传递--http=(host):(port) 规范。这将导致集合中的每个成员通过 webhook 提供有关领导者的信息。</p><pre tabindex=0><code># delete the old leader elector group
$ kubectl delete rc leader-elector

# create the new group, note the --http=localhost:4040 flag
$ kubectl run leader-elector --image=gcr.io/google_containers/leader-elector:0.4 --replicas=3 -- --election=example --http=0.0.0.0:4040

# create a proxy to your Kubernetes api server
$ kubectl proxy
</code></pre><p>然后您可以访问：</p><p>http://localhost:8001/api/v1/proxy/namespaces/default/pods/(leader-pod-name):4040/</p><p>你会看到：</p><pre tabindex=0><code>{&#34;name&#34;:&#34;(name-of-leader-here)&#34;}
</code></pre><h4 id=有副手的-leader-election>有副手的 leader election</h4><p>好吧，那太好了，你可以通过 HTTP 进行leader election 并找到 leader，但是你如何从自己的应用程序中使用它呢？这就是 sidecar 的由来。Kubernetes 中，Pods 由一个或多个容器组成。通常情况下，这意味着您将 sidecar containers 添加到主应用程序中以组成 pod。（关于这个主题的更详细的处理，请参阅我之前的博客文章）。
Leader-election container 可以作为一个 sidecar，您可以从自己的应用程序中使用。Pod 中任何对当前 master 感兴趣的容器都可以简单地访问http://localhost:4040，它们将返回一个包含当前 master 名称的简单 json 对象。由于 pod中 的所有容器共享相同的网络命名空间，因此不需要服务发现！</p><p>例如，这里有一个简单的 Node.js 应用程序，它连接到 leader election sidecar 并打印出它当前是否是 master。默认情况下，leader election sidecar 将其标识符设置为 <code>hostname</code>。</p><pre tabindex=0><code>var http = require(&#39;http&#39;);
// This will hold info about the current master
var master = {};

  // The web handler for our nodejs application
  var handleRequest = function(request, response) {
    response.writeHead(200);
    response.end(&#34;Master is &#34; + master.name);
  };

  // A callback that is used for our outgoing client requests to the sidecar
  var cb = function(response) {
    var data = &#39;&#39;;
    response.on(&#39;data&#39;, function(piece) { data = data + piece; });
    response.on(&#39;end&#39;, function() { master = JSON.parse(data); });
  };

  // Make an async request to the sidecar at http://localhost:4040
  var updateMaster = function() {
    var req = http.get({host: &#39;localhost&#39;, path: &#39;/&#39;, port: 4040}, cb);
    req.on(&#39;error&#39;, function(e) { console.log(&#39;problem with request: &#39; + e.message); });
    req.end();
  };

  / / Set up regular updates
  updateMaster();
  setInterval(updateMaster, 5000);

  // set up the web server
  var www = http.createServer(handleRequest);
  www.listen(8080);
</code></pre><p>当然，您可以从任何支持 HTTP 和 JSON 的语言中使用这个 sidecar。</p><h4 id=结论>结论</h4><p>希望我已经向您展示了使用 Kubernetes 为您的分布式应用程序构建 leader election 是多么容易。在以后的部分中，我们将向您展示 Kubernetes 如何使构建分布式系统变得更加容易。同时，转到<a href=https://cloud.google.com/container-engine/>Google Container Engine</a>或<a href=http://kubernetes.io/>kubernetes.io</a>开始使用Kubernetes。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-9ead5345aff00f9fdaf83a1f428f0559>使用 Puppet 管理 Kubernetes Pod、Service 和 Replication Controller</h1><div class="td-byline mb-4"><time datetime=2015-12-17 class=text-muted>2015.12.17</time></div><p><em>今天的嘉宾帖子是由 IT 自动化领域的领导者 Puppet Labs 的高级软件工程师 Gareth Rushgrove 撰写的。Gareth告诉我们一个新的 Puppet 模块，它帮助管理 Kubernetes 中的资源。</em></p><p>熟悉[Puppet]的人(<a href=https://github.com/puppetlabs/puppet>https://github.com/puppetlabs/puppet</a>)可能使用它来管理主机上的文件、包和用户。但是Puppet首先是一个配置管理工具，配置管理是一个比管理主机级资源更广泛的规程。配置管理的一个很好的定义是它旨在解决四个相关的问题：标识、控制、状态核算和验证审计。这些问题存在于任何复杂系统的操作中，并且有了新的<a href=https://forge.puppetlabs.com/garethr/kubernetes>Puppet Kubernetes module</a>，我们开始研究如何为 Kubernetes 解决这些问题。</p><h3 id=puppet-kubernetes-模块>Puppet Kubernetes 模块</h3><p>Puppet kubernetes 模块目前假设您已经有一个 kubernetes 集群 [启动并运行]](<a href=http://kubernetes.io/gettingstarted/>http://kubernetes.io/gettingstarted/</a>)。它的重点是管理 Kubernetes中的资源，如 Pods、Replication Controllers 和 Services，而不是（现在）管理底层的 kubelet 或 etcd services。下面是描述 Puppet’s DSL 中一个 Pod 的简短代码片段。</p><pre tabindex=0><code>kubernetes_pod { &#39;sample-pod&#39;:
  ensure =&gt; present,
  metadata =&gt; {
    namespace =&gt; &#39;default&#39;,
  },
  spec =&gt; {
    containers =&gt; [{
      name =&gt; &#39;container-name&#39;,
      image =&gt; &#39;nginx&#39;,
    }]
  },
}
</code></pre><p>如果您熟悉 YAML 文件格式，您可能会立即识别该结构。 该接口故意采取相同的格式以帮助在不同格式之间进行转换 — 事实上，为此提供支持的代码是从Kubernetes API Swagger自动生成的。 运行上面的代码，假设我们将其保存为 pod.pp，就像下面这样简单：</p><pre tabindex=0><code>puppet apply pod.pp
</code></pre><p>身份验证使用标准的 kubectl 配置文件。您可以在模块的自述文件中找到完整的<a href=https://github.com/garethr/garethr-kubernetes/blob/master/README.md>README</a>。</p><p>Kubernetes 有很多资源，来自 Pods、 Services、 Replication Controllers 和 Service Accounts。您可以在<a href=https://puppetlabs.com/blog/kubernetes-guestbook-example-puppet>Puppet 中的 kubernetes 留言簿示例</a>文章中看到管理这些资源的模块示例。这演示了如何将规范的 hello-world 示例转换为使用 Puppet代码。</p><p>然而，使用 Puppet 的一个主要优点是，您可以创建自己的更高级别和更特定于业务的接口，以连接 kubernetes 管理的应用程序。例如，对于留言簿，可以创建如下内容：</p><pre tabindex=0><code>guestbook { &#39;myguestbook&#39;:
  redis_slave_replicas =&gt; 2,
  frontend_replicas =&gt; 3,
  redis_master_image =&gt; &#39;redis&#39;,
  redis_slave_image =&gt; &#39;gcr.io/google_samples/gb-redisslave:v1&#39;,
  frontend_image =&gt; &#39;gcr.io/google_samples/gb-frontend:v3&#39;,
}
</code></pre><p>您可以在Puppet博客文章<a href=https://puppetlabs.com/blog/building-your-own-abstractions-kubernetes-puppet>在 Puppet 中为 Kubernetes 构建自己的抽象</a>中阅读更多关于使用 Puppet 定义的类型的信息，并看到更多的代码示例。</p><h3 id=结论>结论</h3><p>使用 Puppet 而不仅仅是使用标准的 YAML 文件和 kubectl 的优点是：</p><ul><li>能够创建自己的抽象，以减少重复和设计更高级别的用户界面，如上面的留言簿示例。</li><li>使用 Puppet 的开发工具验证代码和编写单元测试。</li><li>与 Puppet Server 等其他工具配合，以确保代码中的模型与集群的状态匹配，并与 PuppetDB 配合工作，以存储报告和跟踪更改。</li><li>能够针对 Kubernetes API 重复运行相同的代码，以检测任何更改或修正配置。</li></ul><p>值得注意的是，大多数大型组织都将拥有非常异构的环境，运行各种各样的软件和操作系统。拥有统一这些离散系统的单一工具链可以使采用 Kubernetes 等新技术变得更加容易。</p><p>可以肯定地说，Kubernetes提供了一组优秀的组件来构建云原生系统。使用 Puppet，您可以解决在生产中运行任何复杂系统所带来的一些操作和配置管理问题。<a href=mailto:gareth@puppetlabs.com>告诉我们</a>如果您试用了该模块，您会有什么想法，以及您希望在将来看到哪些支持。</p><p>Gareth Rushgrove，Puppet Labs 高级软件工程师</p></div><div class=td-content style=page-break-before:always><h1 id=pg-992cbdcc8b44baeab01f6bc0ef8b4eae>Kubernetes 1.1 性能升级，工具改进和社区不断壮大</h1><div class="td-byline mb-4"><time datetime=2015-11-09 class=text-muted>2015.11.09</time></div><p>自从 Kubernetes 1.0 在七月发布以来，我们已经看到大量公司采用建立分布式系统来管理其容器集群。
我们也对帮助 Kubernetes 社区变得更好，迅速发展的人感到钦佩。
我们已经看到诸如 CoreOS 的 Tectonic 和 RedHat Atomic Host 之类的商业产品应运而生，用以提供 Kubernetes 的部署和支持。
一个不断发展的生态系统增加了 Kubernetes 的支持，包括 Sysdig 和 Project Calico 等工具供应商。</p><p>在数百名贡献者的帮助下，我们自豪地宣布 Kubernetes 1.1 的可用性，它提供了主要的性能升级、改进的工具和新特性，使应用程序更容易构建和部署。</p><p>我们想强调的一些工作包括:</p><ul><li><strong>实质性的性能提升</strong> ：从第一天开始，我们就设计了 Kubernetes 来处理 Google 规模的工作负载，而我们的客户已经按照自己的进度进行了调整。
在 Kubernetes 1.1 中，我们进行了进一步的投资，以确保您可以在超大规模环境中运行；
本周晚些时候，我们将分享运行数千个节点集群，并针对单个集群运行超过一百万个 QPS 的示例。</li></ul><ul><li><strong>网络吞吐量显着提高</strong> : 运行 Google 规模的工作负载也需要 Google 规模的网络。
在 Kubernetes 1.1 中，我们提供了使用本机IP表的选项，可将尾部延迟减少80％，几乎完全消除了CPU开销，并提高了可靠性和系统架构，从而确保Kubernetes可以很好地处理未来的大规模吞吐量。</li></ul><ul><li><strong>水平 Pod 自动缩放 (测试版)</strong>：许多工作负载可能会经历尖峰的使用期，从而给用户带来不均匀的体验。
Kubernetes 现在支持水平 Pod 自动缩放，这意味着您的 Pod 可以根据 CPU 使用率进行缩放。
阅读有关<a href=http://kubernetes.io/v1.1/docs/user-guide/horizontal-pod-autoscaler.html>水平 Pod 自动缩放</a>的更多信息。</li></ul><ul><li><strong>HTTP 负载均衡器 (测试版)</strong>：Kubernetes 现在具有基于数据包自省功能来路由 HTTP 流量的内置功能。
这意味着您可以让 ‘http://foo.com/bar’ 使用一项服务，而 ‘http://foo.com/meep’ 使用一项完全独立的服务。
阅读有关<a href=http://kubernetes.io/v1.1/docs/user-guide/ingress.html>Ingress对象</a>的更多信息。</li></ul><ul><li><strong>Job 对象 (测试版)</strong>：我们也经常需要集成的批处理 Job ，例如处理一批图像以创建缩略图，或者将特别大的数据文件分解成很多块。
<a href=https://github.com/kubernetes/kubernetes/blob/master/docs/user-guide/jobs.md#writing-a-job-spec>Job 对象</a>引入了一个新的 API 对象，该对象运行工作负载，
如果失败，则重新启动它，并继续尝试直到成功完成。
阅读有关<a href=http://kubernetes.io/v1.1/docs/user-guide/jobs.html>Job 对象</a>的更多信息。</li></ul><ul><li><strong>新功能可缩短开发人员的测试周期</strong> :我们将继续致力于快速便捷地为 Kubernetes 开发应用程序。
加快开发人员工作流程的两项新功能包括以交互方式运行容器的功能，以及改进的架构验证功能，可在部署配置文件之前让您知道配置文件是否存在任何问题。</li></ul><ul><li><strong>滚动更新改进</strong> : DevOps 运动的核心是能够发布新更新，而不会影响正在运行的服务。
滚动更新现在可确保在继续更新之前，已更新的 Pod 状况良好。</li></ul><ul><li>还有很多。有关更新的完整列表，请参见<a href=https://github.com/kubernetes/kubernetes/releases>1.1. 发布</a>在GitHub上的笔记</li></ul><p>今天，我们也很荣幸地庆祝首届Kubernetes会议<a href=https://kubecon.io/>KubeCon</a>，约有400个社区成员以及数十个供应商参加支持 Kubernetes 项目的会议。</p><p>我们想强调几个使 Kubernetes 变得更好的众多合作伙伴中的几位：</p><blockquote><p>“我们押注我们的主要产品 Tectonic-它能使任何公司都能在任何地方部署、管理和保护其容器-在 Kubernetes 上使用，因为我们认为这是数据中心的未来。
Kubernetes 1.1 的发布是另一个重要的里程碑，它将使分布式系统和容器得到更广泛的采用，并使我们走上一条必将导致新一代产品和服务的道路。” – CoreOS 首席执行官Alex Polvi</p></blockquote><blockquote><p>“Univa 的客户正在寻找可扩展的企业级解决方案，以简化企业中容器和非容器工作负载的管理。
我们选择Kubernetes作为我们新的 Navops 套件的基础，它将帮助 IT 和 DevOps 将容器化工作负载快速集成到他们的生产系统中，并将这些工作负载扩展到云服务中。” – Univa 首席执行官 Gary Tyreman</p></blockquote><blockquote><p>“我们看到通过 Kubernetes 大规模运行容器的巨大客户需求是推动 Redapt 专业服务业务增长的关键因素。
作为值得信赖的顾问，在我们的工具带中有像 Kubernetes 这样的工具能够帮助我们的客户实现他们的目标，这是非常棒的。“ – Redapt SR 云解决方案副总裁 Paul Welch</p></blockquote><p>如上所述，我们希望得到您的帮助:</p><ul><li>在 <a href=https://github.com/kubernetes/kubernetes>GitHub</a>上参与 Kubernetes 项目；</li><li>通过 <a href=http://slack.kubernetes.io/>Slack</a> 与社区联系；</li><li>关注我们的 Twitter <a href=https://twitter.com/kubernetesio>@Kubernetesio</a> 获取最新信息；</li><li>在 Stackoverflow 上发布问题（或回答问题）</li><li>开始运行，部署和使用 Kubernetes <a href=/docs/tutorials/kubernetes-basics/>指南</a>；</li></ul><p>但是，最重要的是，请让我们知道您是如何使用 Kubernetes 改变您的业务的，以及我们如何可以帮助您更快地做到这一点。谢谢您的支持!</p><p> - David Aronchick, Kubernetes 和谷歌容器引擎的高级产品经理</p></div><div class=td-content style=page-break-before:always><h1 id=pg-a5d839dbca2e85bc033ad97da511f701>Kubernetes 社区每周环聊笔记——2015 年 7 月 31 日</h1><div class="td-byline mb-4"><time datetime=2015-08-04 class=text-muted>2015.08.04</time></div><p>每周，Kubernetes 贡献社区都会通过Google 环聊虚拟开会。我们希望任何有兴趣的人都知道本论坛讨论的内容。</p><p>这是今天会议的笔记：</p><ul><li><p>私有镜像仓库演示 - Muhammed</p><ul><li><p>将 docker-registry 作为 RC/Pod/Service 运行</p></li><li><p>在每个节点上运行代理</p></li><li><p>以 localhost:5000 访问</p></li><li><p>讨论：</p><ul><li><p>我们应该在可能的情况下通过 GCS 或 S3 支持它吗？</p></li><li><p>在每个节点上运行由 $object_store 支持的真实镜像仓库</p></li><li><p>DNS 代替 localhost？</p><ul><li><p>分解 docker 镜像字符串？</p></li><li><p>更像 DNS 策略吗？</p></li></ul></li></ul></li></ul></li></ul><ul><li><p>运行大型集群 - Joe</p><ul><li><p>三星渴望看到大规模 O(1000)</p><ul><li>从 AWS 开始</li></ul></li><li><p>RH 也有兴趣 - 需要测试计划</p></li><li><p>计划下周：讨论工作组</p></li><li><p>如果您有兴趣加入有关集群可扩展性的对话，请发送邮件至[joe@0xBEDA.com][4]</p></li></ul></li></ul><ul><li><p>资源 API 提案 - Clayton</p><ul><li><p>新东西需要更多资源信息</p></li><li><p>关于资源 API 的提案 - 向 apiserver 询问有关pod的信息</p></li><li><p>发送反馈至：#11951</p></li><li><p>关于快照，时间序列和聚合的讨论</p></li></ul></li></ul><ul><li><p>容器化 kubelet - Clayton</p><ul><li><p>打开 pull</p></li><li><p>Docker挂载传播 - RH 带有补丁</p></li><li><p>有关整个系统引导程序的大问题</p><ul><li>双：引导docker /系统docker</li></ul></li><li><p>Kube-in-docker非常好，但可能并不关键</p><ul><li><p>做些小事以取得进步</p></li><li><p>对 docker 施加压力</p></li></ul></li></ul></li></ul><ul><li><p>Web UI（preilly）</p><ul><li><p>Web UI 放在哪里？</p><ul><li><p>确定将其拆分出去</p></li><li><p>将其用作容器镜像</p></li><li><p>作为 kube 发布过程的一部分构建映像</p></li><li><p>vendor回来了吗？也许吧，也许不是。</p></li></ul></li><li><p>DNS将被拆分吗？</p><ul><li>可能更紧密地集成在一起，而不是</li></ul></li><li><p>其他潜在的衍生产品：</p><ul><li><p>apiserver</p></li><li><p>clients</p></li></ul></li></ul></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-c8d31fe28a6a2f2c0b717dd1b1f21835>宣布首个Kubernetes企业培训课程</h1><div class="td-byline mb-4"><time datetime=2015-07-08 class=text-muted>2015.07.08</time></div><p>在谷歌，我们依赖 Linux 容器应用程序去运行我们的核心基础架构。所有服务，从搜索引擎到Gmail服务，都运行在容器中。事实上，我们非常喜欢容器，甚至我们的谷歌云计算引擎虚拟机也运行在容器上！由于容器对于我们的业务至关重要，我们已经与社区合作开发许多基本的容器技术（从 cgroups 到 Docker 的 LibContainer）,甚至决定去构建谷歌的下一代开源容器调度技术，Kubernetes。</p><p>在 Kubernetes 项目进行一年后，在 OSCON 上发布 V1 版本的前夕，我们很高兴的宣布Kubernetes 的主要贡献者 Mesosphere 组织了有史以来第一次正规的以企业为中心的 Kubernetes 培训会议。首届会议将于 6 月 20 日在波特兰的 OSCON 举办，由来自 Mesosphere 的 Zed Shaw 和 Michael Hausenblas 演讲。<a href=https://mesosphere.com/training/kubernetes/>Pre-registration</a> 对于优先注册者是免费的，但名额有限，立刻行动吧！</p><p>这个为期一天的课程将包涵使用 Kubernetes 构建和部署容器化应用程序的基础知识。它将通过完整的流程引导与参会者创建一个 Kubernetes 的应用程序体系结构，创建和配置 Docker 镜像，并把它们部署到 Kubernetes 集群上。用户还将了解在我们的谷歌容器引擎和 Mesosphere 的数据中心操作系统上部署 Kubernetes 应用程序和服务的基础知识。</p><p>即将推出的 Kubernetes bootcamp 将是学习如何应用 Kubernetes 解决长期部署和应用程序管理问题的一个好途径。相对于我们所预期的，来自于广泛社区的众多培训项目而言，这只是其中一个。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-d3c0039c2d00bc08b5dbc16a4f7f29e2>幻灯片：Kubernetes 集群管理，爱丁堡大学演讲</h1><div class="td-byline mb-4"><time datetime=2015-06-26 class=text-muted>2015.06.26</time></div><p>2015年6月5日星期五，我在爱丁堡大学给普通听众做了一个演讲，题目是<a href="https://docs.google.com/presentation/d/1H4ywDb4vAJeg8KEjpYfhNqFSig0Q8e_X5I36kM9S6q0/pub?start=false&loop=false&delayms=3000">使用 Kubernetes 进行集群管理</a>。这次演讲包括一个带有 Kibana 前端 UI 的音乐存储系统的例子，以及一个基于 Elasticsearch 的后端，该后端有助于生成具体的概念，如 pods、复制控制器和服务。</p><p><a href="https://docs.google.com/presentation/d/1H4ywDb4vAJeg8KEjpYfhNqFSig0Q8e_X5I36kM9S6q0/pub?start=false&loop=false&delayms=3000">Kubernetes 集群管理</a>。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-3b8bd1fa11dba03c4234640bf5bebd0d>OpenStack 上的 Kubernetes</h1><div class="td-byline mb-4"><time datetime=2015-05-19 class=text-muted>2015.05.19</time></div><p><a href=https://3.bp.blogspot.com/-EOrCHChZJZE/VVZzq43g6CI/AAAAAAAAF-E/JUilRHk369E/s1600/Untitled%2Bdrawing.jpg><img src=https://3.bp.blogspot.com/-EOrCHChZJZE/VVZzq43g6CI/AAAAAAAAF-E/JUilRHk369E/s400/Untitled%2Bdrawing.jpg alt></a></p><p>今天，<a href=https://www.openstack.org/foundation/>OpenStack 基金会</a>通过在其<a href=http://apps.openstack.org/>社区应用程序目录</a>中包含 Kubernetes，使您更容易在 OpenStack 云上部署和管理 Docker 容器集群。
今天在温哥华 OpenStack 峰会上的主题演讲中，OpenStack 基金会的首席运营官：Mark Collier 和 <a href=https://www.mirantis.com/>Mirantis</a> 产品线经理 Craig Peters 通过利用 OpenStack 云中已经存在的计算、存储、网络和标识系统，在几秒钟内启动了 Kubernetes 集群，展示了社区应用程序目录的工作流。</p><p>目录中的条目不仅包括<a href="http://apps.openstack.org/#tab=murano-apps&asset=Kubernetes%20Cluster">启动 Kubernetes 集群</a>的功能，还包括部署在 Kubernetes 管理的 Docker 容器中的一系列应用程序。这些应用包括：</p><ul><li></li></ul><h2 id=apache-web-服务器>Apache web 服务器</h2><h2 id=nginx-web-服务器>Nginx web 服务器</h2><h2 id=crate-docker的分布式数据库>Crate - Docker的分布式数据库</h2><h2 id=glassfish-java-ee-7-应用服务器>GlassFish - Java EE 7 应用服务器</h2><h2 id=tomcat-一个开源的-web-服务器和-servlet-容器>Tomcat - 一个开源的 web 服务器和 servlet 容器</h2><h2 id=influxdb-一个开源的-分布式的-时间序列数据库>InfluxDB - 一个开源的、分布式的、时间序列数据库</h2><h2 id=grafana-influxdb-的度量仪表板>Grafana - InfluxDB 的度量仪表板</h2><h2 id=jenkins-一个可扩展的开放源码持续集成服务器>Jenkins - 一个可扩展的开放源码持续集成服务器</h2><h2 id=mariadb-数据库>MariaDB 数据库</h2><h2 id=mysql-数据库>MySql 数据库</h2><h2 id=redis-键-值缓存和存储>Redis - 键-值缓存和存储</h2><h2 id=postgresql-数据库>PostgreSQL 数据库</h2><h2 id=mongodb-nosql-数据库>MongoDB NoSQL 数据库</h2><p>Zend 服务器 - 完整的 PHP 应用程序平台</p><p>此列表将会增长，并在<a href=https://opendev.org/x/k8s-docker-suite-app-murano/src/branch/master/Kubernetes>此处</a>进行策划。您可以检查（并参与）YAML 文件，该文件告诉 Murano 如何根据<a href=https://opendev.org/x/k8s-docker-suite-app-murano/src/branch/master/Kubernetes/KubernetesCluster/package/Classes/KubernetesCluster.yaml>此处</a>定义来安装和启动 ...apps/blob/master/Docker/Kubernetes/KubernetesCluster/package/Classes/KubernetesCluster.yaml)安装和启动 Kubernetes 集群。</p><p><a href=https://github.com/GoogleCloudPlatform/kubernetes>Kubernetes 开源项目</a>继续受到社区的欢迎，并且势头越来越好，GitHub 上有超过 11000 个提交和 7648 颗星。从 Red Hat 和 Intel 到 CoreOS 和 Box.net，它已经代表了从企业 IT 到前沿创业企业的一系列客户。我们鼓励您尝试一下，给我们您的反馈，并参与到我们不断增长的社区中来。</p><ul><li>Martin Buhr, Kubernetes 开源项目产品经理</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-801e598fff1bb0a31a4322ac49bf5bf1>Kubernetes 社区每周聚会笔记- 2015年5月1日</h1><div class="td-byline mb-4"><time datetime=2015-05-11 class=text-muted>2015.05.11</time></div><p>每个星期，Kubernetes 贡献者社区几乎都会在谷歌 Hangouts 上聚会。我们希望任何对此感兴趣的人都能了解这个论坛的讨论内容。</p><ul><li><p>简单的滚动更新 - Brendan</p><ul><li><p>滚动更新 = RCs和Pods很好的例子。</p></li><li><p>...pause… (Brendan 需要 Kelsey 的演示恢复技巧)</p></li><li><p>滚动更新具有恢复功能:取消更新并重新启动，更新从停止的地方继续。</p></li><li><p>新控制器获取旧控制器的名称，因此外观是纯粹的更新。</p></li><li><p>还可以在 update 中命名版本(最后不会重命名)。</p></li></ul></li></ul><ul><li><p>Rocket 演示 - CoreOS 的伙计们</p><ul><li><p>Rocket 和 docker 之间的主要区别: Rocket 是无守护进程和以 pod 为中心。。</p></li><li><p>Rocket 具有原生的 AppContainer 格式，但也支持 docker 镜像格式。</p></li><li><p>可以在同一个 pod 中运行 AppContainer 和 docker 容器。</p></li><li><p>变更接近于合并。</p></li></ul></li></ul><ul><li><p>演示 service accounts 和 secrets 被添加到 pod - Jordan</p><ul><li><p>问题：很难获得与API通信的令牌。</p></li><li><p>新的API对象："ServiceAccount"</p></li><li><p>ServiceAccount 是命名空间，控制器确保命名空间中至少存在一个个默认 service account。</p></li><li><p>键入 "ServiceAccountToken"，控制器确保至少有一个默认令牌。</p></li><li><p>演示</p></li><li><pre><code>* 可以使用 ServiceAccountToken 创建新的 service account。控制器将为它创建令牌。
</code></pre></li><li><p>可以创建一个带有 service account 的 pod, pod 将在 /var/run/secrets/kubernetes.io/…</p></li></ul></li></ul><ul><li><p>Kubelet 在容器中运行 - Paul</p><ul><li>Kubelet 成功地运行了带有 secret 的 pod。</li></ul></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-05680064b0bb19d48e280af9d6152529>通过 RKT 对 Kubernetes 的 AppC 支持</h1><div class="td-byline mb-4"><time datetime=2015-05-04 class=text-muted>2015.05.04</time></div><p>我们最近接受了对 Kubernetes 项目的拉取请求，以增加对 Kubernetes 社区的应用程序支持。  AppC 是由 CoreOS 发起的新的开放容器规范，并通过 CoreOS rkt 容器运行时受到支持。</p><p>对于Kubernetes项目和更广泛的容器社区而言，这是重要的一步。  它为容器语言增加了灵活性和选择余地，并为Kubernetes开发人员带来了令人信服的新安全性和性能功能。</p><p>与智能编排技术（例如 Kubernetes 和/或 Apache Mesos）配合使用时，基于容器的运行时（例如 Docker 或 rkt）对开发人员构建和运行其应用程序的方式是一种合法干扰。  尽管支持技术还处于新生阶段，但它们确实为组装，部署，更新，调试和扩展解决方案提供了一些非常强大的新方法。  我相信，世界还没有意识到容器的全部潜力，未来几年将特别令人兴奋！  考虑到这一点，有几个具有不同属性和不同目的的项目才有意义。能够根据给定应用程序的特定需求将不同的部分（无论是容器运行时还是编排工具）插入在一起也是有意义的。</p><p>Docker 在使容器技术民主化并使外界可以访问它们方面做得非常出色，我们希望 Kubernetes 能够无限期地支持 Docker。CoreOS 还开始与 rkt 进行有趣的工作，以创建一个优雅，干净，简单和开放的平台，该平台提供了一些非常有趣的属性。  这看起来蓄势待发，可以为容器提供安全，高性能的操作环境。  Kubernetes 团队已经与 CoreOS 的 appc 团队合作了一段时间，在许多方面，他们都将 Kubernetes 作为简单的可插入运行时组件来构建 rkt。  </p><p>真正的好处是，借助 Kubernetes，您现在可以根据工作负载的需求选择最适合您的容器运行时，无需替换集群环境即可更改运行时，甚至可以将在同一集群中在不同容器中运行的应用程序的不同部分混合在一起。  其他选择无济于事，但最终使最终开发人员受益。</p><p>-- Craig McLuckie
Google 产品经理和 Kubernetes 联合创始人</p></div><div class=td-content style=page-break-before:always><h1 id=pg-c21afabad8ee96c94af485cfbcc582a5>Kubernetes 社区每周聚会笔记- 2015年4月24日</h1><div class="td-byline mb-4"><time datetime=2015-04-30 class=text-muted>2015.04.30</time></div><p>每个星期，Kubernetes 贡献者社区几乎都会在谷歌 Hangouts 上聚会。我们希望任何对此感兴趣的人都能了解这个论坛的讨论内容。</p><p>日程安排：</p><ul><li>Flocker 和 Kubernetes 集成演示</li></ul><p>笔记：</p><ul><li>flocker 和 kubernetes 集成演示</li><li><ul><li><p>Flocker Q/A</p><ul><li><p>迁移后文件是否仍存在于node1上？</p></li><li><p>Brendan: 有没有计划把它做成一本书？我们不需要 powerstrip？</p><ul><li><p>Luke: 需要找出感兴趣的来决定我们是否想让它成为 kube 中的一个一流的持久性磁盘提供商。</p></li><li><p>Brendan: 删除对 powerstrip 的需求会使其易于使用。完全去做。</p></li><li><p>Tim: 将它添加到 kubernetes 应该不超过45分钟:)</p></li></ul></li></ul></li></ul></li></ul><pre><code>* Derek: 持久卷和请求相比呢?

    * Luke: 除了基于 ZFS 的新后端之外，差别不大。使工作负载真正可移植。

    * Tim: 与基于网络的卷非常不同。有趣的是，它是唯一允许升级媒体的产品。

    * Brendan: 请求，它如何查找重复请求？Cassandra 希望在底层复制数据。向上和向下扩缩是有效的。根据负载动态地创建存储。它的步骤不仅仅是快照——通过编程使用预分配创建副本。

    * Tim: 帮助自动配置。
</code></pre><pre><code>* Brian: flocker 是否需要其他组件？

    * Kai: Flocker 控制服务与主服务器位于同一位置。(dia 在博客上)。Powerstrip + Powerstrip Flocker。对在 etcd 中持久化状态非常有趣。它保存关于每个卷的元数据。

    * Brendan: 在未来，flocker 可以是一个插件，我们将负责持久性。发布 v1.0。

    * Brian: 有兴趣为 flocker 等服务添加通用插件。

    * Luke: 当扩展到单个节点上的许多容器时，Zfs 会变得非常有价值。
</code></pre><pre><code>* Alex: flocker 服务可以作为 pod 运行吗？

    * Kai: 是的，唯一的要求是 flocker 控制服务应该能够与 zfs 代理对话。需要在主机上安装 zfs 代理，并且需要访问 zfs 二进制文件。

    * Brendan: 从理论上讲，所有 zfs 位都可以与设备一起放入容器中。

    * Luke: 是的，仍然在处理跨容器安装问题。

    * Tim: pmorie 正在通过它使 kubelet 在容器中工作。可能重复使用。

* Kai: Cinder 支持即将到来。几天之后。
</code></pre><ul><li>Bob: 向 GKE 推送 kube 的过程是怎样的？需要更多的可见度。</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-cb033081886f937e8367cbdc7c9aa2f6>Borg: Kubernetes 的前身</h1><div class="td-byline mb-4"><time datetime=2015-04-23 class=text-muted>2015.04.23</time></div><p>十多年来，谷歌一直在生产中运行容器化工作负载。
无论是像网络前端和有状态服务器之类的工作，像 <a href=http://research.google.com/archive/bigtable.html>Bigtable</a> 和
<a href=http://research.google.com/archive/spanner.html>Spanner</a>一样的基础架构系统，或是像
<a href=http://research.google.com/archive/mapreduce.html>MapReduce</a> 和 <a href=http://research.google.com/pubs/pub41378.html>Millwheel</a>一样的批处理框架，
Google 的几乎一切都是以容器的方式运行的。今天，我们揭开了 Borg 的面纱，Google 传闻已久的面向容器的内部集群管理系统，并在学术计算机系统会议 <a href=http://eurosys2015.labri.fr/>Eurosys</a> 上发布了详细信息。你可以在 <a href=https://research.google.com/pubs/pub43438.html>此处</a> 找到论文。</p><p>Kubernetes 直接继承自 Borg。
在 Google 的很多从事 Kubernetes 的开发人员以前都是 Borg 项目的开发人员。
我们在 Kubernetes 中结合了 Borg 的最佳创意，并试图解决用户多年来在 Borg 中发现的一些痛点。</p><p>Kubernetes 中的以下四个功能特性源于我们从 Borg 获得的经验：</p><ol><li><a href=https://github.com/GoogleCloudPlatform/kubernetes/blob/master/docs/pods.md>Pods</a>.
Pod 是 Kubernetes 中调度的单位。
它是一个或多个容器在其中运行的资源封装。
保证属于同一 Pod 的容器可以一起调度到同一台计算机上，并且可以通过本地卷共享状态。</li></ol><p>Borg 有一个类似的抽象，称为 alloc（“资源分配”的缩写）。
Borg 中 alloc 的常见用法包括运行 Web 服务器，该服务器生成日志，一起部署一个轻量级日志收集进程，
该进程将日志发送到集群文件系统（和 fluentd 或 logstash 没什么不同 ）；
运行 Web 服务器，该 Web 服务器从磁盘目录提供数据，
该磁盘目录由从集群文件系统读取数据并为 Web 服务器准备/暂存的进程填充（与内容管理系统没什么不同）；
并与存储分片一起运行用户定义的处理功能。</p><p>Pod 不仅支持这些用例，而且还提供类似于在单个 VM 中运行多个进程的环境 -- Kubernetes 用户可以在 Pod 中部署多个位于同一地点的协作过程，而不必放弃一个应用程序一个容器的部署模型。</p><ol start=2><li><a href=https://github.com/GoogleCloudPlatform/kubernetes/blob/master/docs/services.md>服务</a>。
尽管 Borg 的主要角色是管理任务和计算机的生命周期，但是在 Borg 上运行的应用程序还可以从许多其它集群服务中受益，包括命名和负载均衡。
Kubernetes 使用服务抽象支持命名和负载均衡：带名字的服务，会映射到由标签选择器定义的一组动态 Pod 集（请参阅下一节）。
集群中的任何容器都可以使用服务名称链接到服务。</li></ol><p>在幕后，Kubernetes 会自动在与标签选择器匹配到 Pod 之间对与服务的连接进行负载均衡，并跟踪 Pod 在哪里运行，由于故障，它们会随着时间的推移而重新安排。</p><ol start=3><li><a href=https://github.com/GoogleCloudPlatform/kubernetes/blob/master/docs/labels.md>标签</a>。
Borg 中的容器通常是一组相同或几乎相同的容器中的一个副本，该容器对应于 Internet 服务的一层（例如 Google Maps 的前端）或批处理作业的工人（例如 MapReduce）。
该集合称为 Job ，每个副本称为任务。
尽管 Job 是一个非常有用的抽象，但它可能是有限的。
例如，用户经常希望将其整个服务（由许多 Job 组成）作为一个实体进行管理，或者统一管理其服务的几个相关实例，例如单独的 Canary 和稳定的发行版。
另一方面，用户经常希望推理和控制 Job 中的任务子集 --最常见的示例是在滚动更新期间，此时作业的不同子集需要具有不同的配置。</li></ol><p>通过使用标签组织 Pod ，Kubernetes 比 Borg 支持更灵活的集合，标签是用户附加到 Pod（实际上是系统中的任何对象）的任意键/值对。
用户可以通过在其 Pod 上使用 “job:&lt;jobname>” 标签来创建与 Borg Jobs 等效的分组，但是他们还可以使用其他标签来标记服务名称，服务实例（生产，登台，测试）以及一般而言，其 pod 的任何子集。
标签查询（称为“标签选择器”）用于选择操作应用于哪一组 Pod 。
结合起来，标签和<a href=https://github.com/GoogleCloudPlatform/kubernetes/blob/master/docs/replication-controller.md>复制控制器</a> 允许非常灵活的更新语义，以及跨等效项的操作 Borg Jobs。</p><ol start=4><li>每个 Pod 一个 IP。在 Borg 中，计算机上的所有任务都使用该主机的 IP 地址，从而共享主机的端口空间。
虽然这意味着 Borg 可以使用普通网络，但是它给基础结构和应用程序开发人员带来了许多负担：Borg 必须将端口作为资源进行调度；任务必须预先声明它们需要多少个端口，并将要使用的端口作为启动参数；Borglet（节点代理）必须强制端口隔离；命名和 RPC 系统必须处理端口以及 IP 地址。</li></ol><p>多亏了软件定义的覆盖网络，例如 <a href=https://coreos.com/blog/introducing-rudder/>flannel</a> 或内置于<a href=https://cloud.google.com/compute/docs/networking>公有云</a>网络的出现，Kubernetes 能够为每个 Pod 提供服务并为其提供自己的 IP 地址。
这消除了管理端口的基础架构的复杂性，并允许开发人员选择他们想要的任何端口，而不需要其软件适应基础架构选择的端口。
后一点对于使现成的易于运行 Kubernetes 上的开源应用程序至关重要 -- 可以将 Pod 视为 VMs 或物理主机，可以访问整个端口空间，他们可能与其他 Pod 共享同一台物理计算机，这一事实已被忽略。</p><p>随着基于容器的微服务架构的日益普及，Google 从内部运行此类系统所汲取的经验教训已引起外部 DevOps 社区越来越多的兴趣。
通过揭示集群管理器 Borg 的一些内部工作原理，并将下一代集群管理器构建为一个开源项目（Kubernetes）和一个公开可用的托管服务（<a href=http://cloud.google.com/container-engine>Google Container Engine</a>），我们希望这些课程可以使 Google 之外的广大社区受益，并推动容器调度和集群管理方面的最新技术发展。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-5a383598a2a3cf35ecf5f846ce0d2772>Kubernetes 社区每周聚会笔记- 2015年4月17日</h1><div class="td-byline mb-4"><time datetime=2015-04-17 class=text-muted>2015.04.17</time></div><p>每个星期，Kubernetes 贡献者社区几乎都会在谷歌 Hangouts 上聚会。我们希望任何对此感兴趣的人都能了解这个论坛的讨论内容。</p><p>议程</p><ul><li>Mesos 集成</li><li>高可用性（HA）</li><li>向 e2e 添加性能和分析详细信息以跟踪回归</li><li>客户端版本化</li></ul><p>笔记</p><ul><li><p>Mesos 集成</p><ul><li><p>Mesos 集成提案：</p></li><li><p>没有阻塞集成的因素。</p></li><li><p>文档需要更新。</p></li></ul></li></ul><ul><li><p>HA</p><ul><li><p>提案今天应该会提交。</p></li><li><p>Etcd 集群。</p></li><li><p>apiserver 负载均衡。</p></li><li><p>控制器管理器和其他主组件的冷备用。</p></li></ul></li></ul><ul><li><p>向 e2e 添加性能和分析详细信息以跟踪回归</p><ul><li><p>希望红色为性能回归</p></li><li><p>需要公共数据库才能发布数据</p><ul><li>查看</li></ul></li><li><p>Justin 致力于多平台 e2e 仪表盘</p></li></ul></li></ul><ul><li><p>客户端版本化</p><ul><li></li></ul></li></ul><pre><code>*

* 客户端库当前使用内部 API 对象。

* 尽管没有人反映频繁修改 `types.go` 有多痛苦，但我们很为此担心。

* 结构化类型在客户端中很有用。版本化的结构就可以了。

* 如果从 json/yaml (kubectl) 开始，则不应转换为结构化类型。使用 swagger。
</code></pre><ul><li><p>Security context</p><ul><li></li></ul></li></ul><pre><code>* 管理员可以限制谁可以运行特权容器或需要特定的 unix uid

* kubelet 将能够从 apiserver 获取证书

* 政策提案将于下周左右出台
</code></pre><ul><li><p>讨论用户的上游，等等进入Kubernetes，至少是可选的</p></li><li><p>1.0 路线图</p><ul><li><p>重点是性能，稳定性，集群升级</p></li><li><p>TJ 一直在对<a href=https://github.com/GoogleCloudPlatform/kubernetes/blob/master/docs/roadmap.md>roadmap.md</a>进行一些编辑，但尚未发布PR</p></li></ul></li><li><p>Kubernetes UI</p><ul><li><p>依赖关系分解为第三方</p></li><li><p>@lavalamp 是评论家</p></li></ul></li></ul><p>[*[3:27 PM]: 2015-04-17T15:27:00-07:00</p></div><div class=td-content style=page-break-before:always><h1 id=pg-79141a7a1c693c72f0adcbe84b41d683>Kubernetes Release: 0.15.0</h1><div class="td-byline mb-4"><time datetime=2015-04-16 class=text-muted>2015.04.16</time></div><p>Release 说明：</p><ul><li>启用 1beta3 API 并将其设置为默认 API 版本 (<a href=https://github.com/GoogleCloudPlatform/kubernetes/pull/6098 title="在 master 中默认启用 v1beta3 api 版本">#6098</a>)</li><li>增加了多端口服务(<a href=https://github.com/GoogleCloudPlatform/kubernetes/pull/6182 title=实现多端口服务>#6182</a>)<ul><li>新入门指南</li><li>多节点本地启动指南 (<a href=https://github.com/GoogleCloudPlatform/kubernetes/pull/6505 title="Docker 多节点">#6505</a>)</li><li>Google 云平台上的 Mesos (<a href=https://github.com/GoogleCloudPlatform/kubernetes/pull/5442 title="谷歌云平台上 Mesos 入门指南">#5442</a>)</li><li>Ansible 安装说明 (<a href=https://github.com/GoogleCloudPlatform/kubernetes/pull/6237 title="示例 ansible 设置仓库">#6237</a>)</li></ul></li><li>添加了一个控制器框架 (<a href=https://github.com/GoogleCloudPlatform/kubernetes/pull/5270 title=控制器框架>#5270</a>, <a href=https://github.com/GoogleCloudPlatform/kubernetes/pull/5473 title="添加 DeltaFIFO（控制器框架块）">#5473</a>)</li><li>Kubelet 现在监听一个安全的 HTTPS 端口 (<a href=https://github.com/GoogleCloudPlatform/kubernetes/pull/6380 title="将 kubelet 配置为使用 HTTPS (获得 2)">#6380</a>)</li><li>使 kubectl 错误更加友好 (<a href=https://github.com/GoogleCloudPlatform/kubernetes/pull/6338 title=返回用于配置验证的类型化错误，并简化错误>#6338</a>)</li><li>apiserver 现在支持客户端 cert 身份验证 (<a href=https://github.com/GoogleCloudPlatform/kubernetes/pull/6190 title=添加客户端证书认证>#6190</a>)</li><li>apiserver 现在限制了它处理的并发请求的数量 (<a href=https://github.com/GoogleCloudPlatform/kubernetes/pull/6207 title=为服务器处理的正在运行的请求数量添加一个限制。>#6207</a>)</li><li>添加速度限制删除 pod (<a href=https://github.com/GoogleCloudPlatform/kubernetes/pull/6355 title="添加速度限制删除 pod">#6355</a>)</li><li>将平衡资源分配算法作为优先级函数实现在调度程序包中 (<a href=https://github.com/GoogleCloudPlatform/kubernetes/pull/6150 title=将均衡资源分配算法作为优先级函数实现在调度程序包中。>#6150</a>)</li><li>从主服务器启用日志收集功能 (<a href=https://github.com/GoogleCloudPlatform/kubernetes/pull/6396 title=启用主服务器收集日志。>#6396</a>)</li><li>添加了一个 api 端口来从 Pod 中提取日志 (<a href=https://github.com/GoogleCloudPlatform/kubernetes/pull/6497 title="pod 子日志资源">#6497</a>)</li><li>为调度程序添加了延迟指标 (<a href=https://github.com/GoogleCloudPlatform/kubernetes/pull/6368 title=将基本延迟指标添加到调度程序。>#6368</a>)</li><li>为 REST 客户端添加了延迟指标 (<a href=https://github.com/GoogleCloudPlatform/kubernetes/pull/6409 title="向 REST 客户端添加延迟指标">#6409</a>)</li></ul><ul><li>etcd 现在在 master 上的一个 pod 中运行 (<a href=https://github.com/GoogleCloudPlatform/kubernetes/pull/6221 title="在 pod 中运行 etcd 2.0.5">#6221</a>)</li><li>nginx 现在在 master上的容器中运行 (<a href=https://github.com/GoogleCloudPlatform/kubernetes/pull/6334 title="添加一个 nginx docker 镜像用于主程序。">#6334</a>)</li><li>开始为主组件构建 Docker 镜像 (<a href=https://github.com/GoogleCloudPlatform/kubernetes/pull/6326 title="为主组件创建 Docker 镜像">#6326</a>)</li><li>更新了 GCE 程序以使用 gcloud 0.9.54 (<a href=https://github.com/GoogleCloudPlatform/kubernetes/pull/6270 title="gcloud 0.9.54 的更新">#6270</a>)</li><li>更新了 AWS 程序来修复区域与区域语义 (<a href=https://github.com/GoogleCloudPlatform/kubernetes/pull/6011 title="修复 AWS 区域 与 zone">#6011</a>)</li><li>记录镜像 GC 失败时的事件 (<a href=https://github.com/GoogleCloudPlatform/kubernetes/pull/6091 title="记录镜像 GC 失败时的事件。">#6091</a>)</li><li>为 kubernetes 客户端添加 QPS 限制器 (<a href=https://github.com/GoogleCloudPlatform/kubernetes/pull/6203 title="向 kubernetes 客户端添加 QPS 限制器。">#6203</a>)</li><li>减少运行 make release 所需的时间 (<a href=https://github.com/GoogleCloudPlatform/kubernetes/pull/6196 title="在 `make release` 的构建和打包阶段并行化架构">#6196</a>)</li><li>新卷的支持<ul><li>添加 iscsi 卷插件 (<a href=https://github.com/GoogleCloudPlatform/kubernetes/pull/5506 title="添加 iscsi 卷插件">#5506</a>)</li><li>添加 glusterfs 卷插件 (<a href=https://github.com/GoogleCloudPlatform/kubernetes/pull/6174 title="实现 glusterfs 卷插件">#6174</a>)</li><li>AWS EBS 卷支持 (<a href=https://github.com/GoogleCloudPlatform/kubernetes/pull/5138 title="AWS EBS 卷支持">#5138</a>)</li></ul></li><li>更新到 heapster 版本到 v0.10.0 (<a href=https://github.com/GoogleCloudPlatform/kubernetes/pull/6331 title="将 heapster 版本更新到 v0.10.0">#6331</a>)</li><li>更新到 etcd 2.0.9 (<a href=https://github.com/GoogleCloudPlatform/kubernetes/pull/6544 title="构建 etcd 镜像(版本 2.0.9)，并将 kubernetes 集群升级到新版本">#6544</a>)</li><li>更新到 Kibana 到 v1.2 (<a href=https://github.com/GoogleCloudPlatform/kubernetes/pull/6426 title="更新 Kibana 到 v1.2，它对 Elasticsearch 的位置进行了参数化">#6426</a>)</li><li>漏洞修复<ul><li>如果服务的公共 IP 发生变化，Kube-proxy现在会更新iptables规则 (<a href=https://github.com/GoogleCloudPlatform/kubernetes/pull/6123 title="修复了 kube-proxy 中的一个错误，如果一个服务的公共 ip 发生变化，它不会更新 iptables 规则">#6123</a>)</li><li>如果初始创建失败，则重试 kube-addons 创建 (<a href=https://github.com/GoogleCloudPlatform/kubernetes/pull/6200 title="如果 kube-addons 创建失败，请重试 kube-addons 创建。">#6200</a>)</li><li>使 kube-proxy 对耗尽文件描述符更具弹性 (<a href=https://github.com/GoogleCloudPlatform/kubernetes/pull/6727 title="pkg/proxy: fd 用完后引起恐慌">#6727</a>)</li></ul></li></ul><p>要下载，请访问 <a href=https://github.com/GoogleCloudPlatform/kubernetes/releases/tag/v0.15.0>https://github.com/GoogleCloudPlatform/kubernetes/releases/tag/v0.15.0</a></p></div><div class=td-content style=page-break-before:always><h1 id=pg-1f81358fabb3f1915bb19a2c37312d39>每周 Kubernetes 社区例会笔记 - 2015 年 4 月 3 日</h1><div class="td-byline mb-4"><time datetime=2015-04-04 class=text-muted>2015.04.04</time></div><h1 id=kubernetes-每周-kubernetes-社区聚会笔记>Kubernetes: 每周 Kubernetes 社区聚会笔记</h1><p>每周，Kubernetes 贡献社区几乎都会通过 Google Hangouts 开会。
我们希望任何有兴趣的人都知道本论坛讨论的内容。</p><p>议程：</p><ul><li>Quinton - 集群联邦</li><li>Satnam - 性能基准测试更新</li></ul><p><em>会议记录：</em></p><ol><li>Quinton - 集群联邦</li></ol><ul><li>在旧金山见面会后，想法浮出水面</li><li><ul><li>请阅读、评论</li></ul></li><li>不是 1.0，而是将文档放在一起以显示路线图</li><li>可以在 Kubernetes 之外构建</li><li>用于控制多个集群中事物的 API ，包括一些逻辑</li></ul><ol><li><p>Auth(n)(z)</p></li><li><p>调度策略</p></li><li><p>……</p></li></ol><ul><li>集群联邦的不同原因</li></ul><ol><li><p>区域(非)可用性:对区域故障的弹性</p></li><li><p>混合云：有些在云中，有些在本地。 由于各种原因</p></li><li><p>避免锁定云提供商。 由于各种原因</p></li><li><p>"Cloudbursting" - 自动溢出到云中</p></li></ol><ul><li>困难的问题</li></ul><ol><li><p>位置亲和性。Pod 需要多近？</p><ol><li><p>工作负载的耦合</p></li><li><p>绝对位置(例如，欧盟数据需要在欧盟内)</p></li></ol></li><li><p>跨集群服务发现</p><ol><li>服务/DNS 如何跨集群工作</li></ol></li><li><p>跨集群工作负载迁移</p><ol><li>如何在跨集群中逐块移动应用程序?</li></ol></li><li><p>跨集群调度</p><ol><li><p>如何充分了解集群以知道在哪里进行调度</p></li><li><p>可能使用成本函数以最小的复杂性得出亲和性</p></li><li><p>还可以使用成本来确定调度位置（使用不足的集群比过度使用的集群便宜）</p></li></ol></li></ol><ul><li>隐含要求</li></ul><ol><li><p>跨集群集成不应创建跨集群故障模式</p><ol><li>在 Ubernetes 死亡的灾难情况下可以独立使用。</li></ol></li><li><p>统一可见性</p><ol><li>希望有统一的监控，报警，日志，内省，用户体验等。</li></ol></li><li><p>统一的配额和身份管理</p><ol><li>希望将用户数据库和 auth(n)/(z) 放在一个位置</li></ol></li></ol><ul><li>需要注意的是，导致软件故障的大多数原因不是基础架构</li></ul><ol><li><p>拙劣的软件升级</p></li><li><p>拙劣的配置升级</p></li><li><p>拙劣的密钥分发</p></li><li><p>过载</p></li><li><p>失败的外部依赖</p></li></ol><ul><li>讨论：</li></ul><ol><li><p>”ubernetes“ 的边界确定</p><ol><li>可能在可用区，但也可能在机架，或地区</li></ol></li><li><p>重要的是不要鸽子洞并防止其他用户</p></li></ol><ol start=2><li>Satnam - 浸泡测试</li></ol><ul><li>想要测量长时间运行的事务，以确保集群在一段时间内是稳定的。性能不会降低，不会发生内存泄漏等。</li><li>github.com/GoogleCloudPlatform/kubernetes/test/soak/…</li><li>单个二进制文件，在每个节点上放置许多 Pod，并查询每个 Pod 以确保其正在运行。</li><li>Pod 的创建速度越来越快（即使在过去一周内），也可以使事情进展得更快。</li><li>Pod 运行起来后，我们通过代理点击 Pod。决定使用代理是有意的，因此我们测试了 kubernetes apiserver。</li><li>代码已经签入。</li><li>将 Pod 固定在每个节点上，练习每个 Pod，确保你得到每个节点的响应。</li><li>单个二进制文件，永远运行。</li><li>Brian - v1beta3 默认启用， v1beta1 和 v1beta2 不支持，在6月关闭。仍应与升级现有集群等一起使用。</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-6fac4a6542db8c1435843173a812efe8>Kubernetes 社区每周聚会笔记 - 2015 年 3 月 27 日</h1><div class="td-byline mb-4"><time datetime=2015-03-28 class=text-muted>2015.03.28</time></div><p>每个星期，Kubernetes 贡献者社区几乎都会在谷歌 Hangouts 上聚会。我们希望任何对此感兴趣的人都能了解这个论坛的讨论内容。</p><p>日程安排：</p><p>- Andy - 演示远程执行和端口转发</p><p>- Quinton - 联邦集群 - 延迟</p><p>- Clayton - 围绕 Kubernetes 的 UI 代码共享和协作</p><p>从会议指出：</p><p>1. Andy 从 RedHat：</p><ul><li>演示远程执行</li></ul><pre><code>* kubectl exec -p $POD -- $CMD

* 作为代理与主机建立连接，找出 pod 所在的节点，代理与 kubelet 的连接，这一点很有趣。通过 nsenter。

* 使用 SPDY 通过 HTTP 进行多路复用流式传输

* 还有互动模式：

* 假设第一个容器，可以使用 -c $CONTAINER 一个特定的。

* 如果在容器中预先安装了 gdb，则可以交互地将其附加到正在运行的进程中

    * backtrace、symbol tbles、print 等。  使用gdb可以做的大多数事情。

* 也可以用精心制作的参数在上面运行 rsync 或者在容器内设置 sshd。

* 一些聊天反馈：
</code></pre><ul><li>Andy 还演示了端口转发</li><li>nnsenter 与 docker exec</li></ul><pre><code>* 想要在主机的控制下注入二进制文件，类似于预启动钩子

* socat、nsenter，任何预启动钩子需要的
</code></pre><ul><li>如果能在博客上发表这方面的文章就太好了</li><li>wheezy 中的 nginx 版本太旧，无法支持所需的主代理功能</li></ul><p>2. Clayton: 我们的社区组织在哪里，例如 kubernetes UI 组件？</p><ul><li>google-containers-ui IRC 频道，邮件列表。</li><li>Tim: google-containers 前缀是历史的，应该只做 "kubernetes-ui"</li><li>也希望将设计资源投入使用，并且 bower 期望自己的仓库。</li><li>通用协议</li></ul><p>3. Brian Grant:</p><ul><li>测试 v1beta3，准备进入。</li><li>Paul 致力于改变命令行的内容。</li><li>下周初至中旬，尝试默认启用v1beta3 ?</li><li>对于任何其他更改，请发出文件并抄送 thockin。</li></ul><p>4. 一般认为30分钟比60分钟好</p><ul><li>不应该为了填满时间而人为地延长。</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-64e10f0095f0c1f67ad7b47541c7860c>Kubernetes 采集视频</h1><div class="td-byline mb-4"><time datetime=2015-03-23 class=text-muted>2015.03.23</time></div><p>如果你错过了上个月在旧金山举行的 Kubernetes 大会，不要害怕!以下是在 YouTube 上组织成播放列表的晚间演示文稿中的视频。</p><p><a href="https://www.youtube.com/playlist?list=PL69nYSiGNLP2FBVvSLHpJE8_6hRHW8Kxe"><img src=https://img.youtube.com/vi/q8lGZCKktYo/0.jpg alt="Kubernetes Gathering"></a></p></div><div class=td-content style=page-break-before:always><h1 id=pg-38fe5117270c19dea659675ee7fa1a8a>欢迎来到 Kubernetes 博客!</h1><div class="td-byline mb-4"><time datetime=2015-03-20 class=text-muted>2015.03.20</time></div><p>欢迎来到新的 Kubernetes 博客。关注此博客，了解 Kubernetes 开源项目。我们计划时不时的发布发布说明，操作方法文章，活动，甚至一些非常有趣的话题。</p><p>如果您正在使用 Kubernetes 或为该项目做出贡献并想要发帖子，<a href=mailto:kitm@google.com>请告诉我</a>。</p><p>首先，以下是 Kubernetes 最近在其他网站上发布的文章摘要：</p><ul><li><a href=http://googlecloudplatform.blogspot.com/2015/03/scaling-MySQL-in-the-cloud-with-Vitess-and-Kubernetes.html>使用 Vitess 和 Kubernetes 在云中扩展 MySQL</a></li><li><a href=http://googlecloudplatform.blogspot.com/2015/02/container-clusters-on-vms.html>虚拟机上的容器集群</a></li><li><a href=http://googlecloudplatform.blogspot.com/2015/01/everything-you-wanted-to-know-about-Kubernetes-but-were-afraid-to-ask.html>想知道的关于 kubernetes 的一切，却又不敢问</a></li><li><a href=http://googlecloudplatform.blogspot.com/2015/01/what-makes-a-container-cluster.html>什么构成容器集群？</a></li><li><a href=https://www.mirantis.com/blog/integrating-openstack-and-kubernetes-with-murano/>将 OpenStack 和 Kubernetes 与 Murano 集成</a></li><li><a href=http://googlecloudplatform.blogspot.com/2015/01/in-coming-weeks-we-will-be-publishing.html>容器介绍，Kubernetes 以及现代云计算的发展轨迹</a></li><li><a href=http://www.centurylinklabs.com/what-is-kubernetes-and-how-to-use-it/>什么是 Kubernetes 以及如何使用它？</a></li><li><a href=https://blog.openshift.com/v3-docker-kubernetes-interview/>OpenShift V3，Docker 和 Kubernetes 策略</a></li><li><a href=https://www.digitalocean.com/community/tutorials/an-introduction-to-kubernetes>Kubernetes 简介</a></li></ul><p>快乐的云计算！</p><ul><li>Kit Merker - Google 云平台产品经理</li></ul></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/zh-cn/docs/home/>主页</a>
<a class=text-white href=/zh-cn/blog/>博客</a>
<a class=text-white href=/zh-cn/training/>培训</a>
<a class=text-white href=/zh-cn/partners/>合作伙伴</a>
<a class=text-white href=/zh-cn/community/>社区</a>
<a class=text-white href=/zh-cn/case-studies/>案例分析</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 The Kubernetes 作者 | 文档发布基于 <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a> 授权许可</small><br><small class=text-white>Copyright &copy; 2023 Linux 基金会&reg;。保留所有权利。Linux 基金会已注册并使用商标。如需了解 Linux 基金会的商标列表，请访问<a href=https://www.linuxfoundation.org/trademark-usage class=light-text>商标使用页面</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>