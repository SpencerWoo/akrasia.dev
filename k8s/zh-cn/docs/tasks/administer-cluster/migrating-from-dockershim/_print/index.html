<!doctype html><html lang=zh-cn class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=en href=https://kubernetes.io/docs/tasks/administer-cluster/migrating-from-dockershim/><link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/tasks/administer-cluster/migrating-from-dockershim/><link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/tasks/administer-cluster/migrating-from-dockershim/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/migrating-from-dockershim/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>从 dockershim 迁移 | Kubernetes</title><meta property="og:title" content="从 dockershim 迁移"><meta property="og:description" content="生产级别的容器编排系统"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/migrating-from-dockershim/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="从 dockershim 迁移"><meta itemprop=description content="生产级别的容器编排系统"><meta name=twitter:card content="summary"><meta name=twitter:title content="从 dockershim 迁移"><meta name=twitter:description content="生产级别的容器编排系统"><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content=" 本节提供从 dockershim 迁移到其他容器运行时的必备知识。
自从 Kubernetes 1.20 宣布 弃用 dockershim， 各类疑问随之而来：这对各类工作负载和 Kubernetes 部署会产生什么影响。 我们的弃用 Dockershim 常见问题可以帮助你更好地理解这个问题。
Dockershim 在 Kubernetes v1.24 版本已经被移除。 如果你集群内是通过 dockershim 使用 Docker Engine 作为容器运行时，并希望 Kubernetes 升级到 v1.24， 建议你迁移到其他容器运行时或使用其他方法以获得 Docker 引擎支持。
建议从 dockershim 迁移到其他替代的容器运行时。 请参阅容器运行时 一节以了解可用的备选项。 当在迁移过程中遇到麻烦，请上报问题。 那么问题就可以及时修复，你的集群也可以进入移除 dockershim 前的就绪状态。
你的集群中可以有不止一种类型的节点，尽管这不是常见的情况。
下面这些任务可以帮助你完成迁移：
检查弃用 Dockershim 是否影响到你 将 Docker Engine 节点从 dockershim 迁移到 cri-dockerd 从 dockershim 迁移遥测和安全代理 接下来 查看容器运行时了解可选的容器运行时。 GitHub 问题跟踪有关 dockershim 的弃用和删除的讨论。 如果你发现与 dockershim 迁移相关的缺陷或其他技术问题， 可以在 Kubernetes 项目报告问题。 "><meta property="og:description" content=" 本节提供从 dockershim 迁移到其他容器运行时的必备知识。
自从 Kubernetes 1.20 宣布 弃用 dockershim， 各类疑问随之而来：这对各类工作负载和 Kubernetes 部署会产生什么影响。 我们的弃用 Dockershim 常见问题可以帮助你更好地理解这个问题。
Dockershim 在 Kubernetes v1.24 版本已经被移除。 如果你集群内是通过 dockershim 使用 Docker Engine 作为容器运行时，并希望 Kubernetes 升级到 v1.24， 建议你迁移到其他容器运行时或使用其他方法以获得 Docker 引擎支持。
建议从 dockershim 迁移到其他替代的容器运行时。 请参阅容器运行时 一节以了解可用的备选项。 当在迁移过程中遇到麻烦，请上报问题。 那么问题就可以及时修复，你的集群也可以进入移除 dockershim 前的就绪状态。
你的集群中可以有不止一种类型的节点，尽管这不是常见的情况。
下面这些任务可以帮助你完成迁移：
检查弃用 Dockershim 是否影响到你 将 Docker Engine 节点从 dockershim 迁移到 cri-dockerd 从 dockershim 迁移遥测和安全代理 接下来 查看容器运行时了解可选的容器运行时。 GitHub 问题跟踪有关 dockershim 的弃用和删除的讨论。 如果你发现与 dockershim 迁移相关的缺陷或其他技术问题， 可以在 Kubernetes 项目报告问题。 "><meta name=twitter:description content=" 本节提供从 dockershim 迁移到其他容器运行时的必备知识。
自从 Kubernetes 1.20 宣布 弃用 dockershim， 各类疑问随之而来：这对各类工作负载和 Kubernetes 部署会产生什么影响。 我们的弃用 Dockershim 常见问题可以帮助你更好地理解这个问题。
Dockershim 在 Kubernetes v1.24 版本已经被移除。 如果你集群内是通过 dockershim 使用 Docker Engine 作为容器运行时，并希望 Kubernetes 升级到 v1.24， 建议你迁移到其他容器运行时或使用其他方法以获得 Docker 引擎支持。
建议从 dockershim 迁移到其他替代的容器运行时。 请参阅容器运行时 一节以了解可用的备选项。 当在迁移过程中遇到麻烦，请上报问题。 那么问题就可以及时修复，你的集群也可以进入移除 dockershim 前的就绪状态。
你的集群中可以有不止一种类型的节点，尽管这不是常见的情况。
下面这些任务可以帮助你完成迁移：
检查弃用 Dockershim 是否影响到你 将 Docker Engine 节点从 dockershim 迁移到 cri-dockerd 从 dockershim 迁移遥测和安全代理 接下来 查看容器运行时了解可选的容器运行时。 GitHub 问题跟踪有关 dockershim 的弃用和删除的讨论。 如果你发现与 dockershim 迁移相关的缺陷或其他技术问题， 可以在 Kubernetes 项目报告问题。 "><meta property="og:url" content="https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/migrating-from-dockershim/"><meta property="og:title" content="从 dockershim 迁移"><meta name=twitter:title content="从 dockershim 迁移"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/zh-cn/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/zh-cn/docs/>文档</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/zh-cn/blog/>Kubernetes 博客</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/zh-cn/training/>培训</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/zh-cn/partners/>合作伙伴</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/zh-cn/community/>社区</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/zh-cn/case-studies/>案例分析</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>版本列表</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/zh-cn/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/zh-cn/docs/tasks/administer-cluster/migrating-from-dockershim/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/zh-cn/docs/tasks/administer-cluster/migrating-from-dockershim/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/zh-cn/docs/tasks/administer-cluster/migrating-from-dockershim/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/zh-cn/docs/tasks/administer-cluster/migrating-from-dockershim/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/zh-cn/docs/tasks/administer-cluster/migrating-from-dockershim/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>中文 (Chinese)</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/docs/tasks/administer-cluster/migrating-from-dockershim/>English</a>
<a class=dropdown-item href=/ko/docs/tasks/administer-cluster/migrating-from-dockershim/>한국어 (Korean)</a>
<a class=dropdown-item href=/ja/docs/tasks/administer-cluster/migrating-from-dockershim/>日本語 (Japanese)</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>这是本节的多页打印视图。
<a href=# onclick="return print(),!1">点击此处打印</a>.</p><p><a href=/zh-cn/docs/tasks/administer-cluster/migrating-from-dockershim/>返回本页常规视图</a>.</p></div><h1 class=title>从 dockershim 迁移</h1><ul><li>1: <a href=#pg-b8acce0768c2f92cdb8eaa31e8072353>将节点上的容器运行时从 Docker Engine 改为 containerd</a></li><li>2: <a href=#pg-d81ef0973a7bb4813e1797a452864742>将 Docker Engine 节点从 dockershim 迁移到 cri-dockerd</a></li><li>3: <a href=#pg-d79db9ed1698f75ec5f2228987290e49>查明节点上所使用的容器运行时</a></li><li>4: <a href=#pg-c4b5bb78bc6c59690d21c44e41f12270>排查 CNI 插件相关的错误</a></li><li>5: <a href=#pg-cbd252cc297e67c1b73a84d5882474fb>检查移除 Dockershim 是否对你有影响</a></li><li>6: <a href=#pg-eb3e279a6c5e1224e744080a52ee3f28>从 dockershim 迁移遥测和安全代理</a></li></ul><div class=content><p>本节提供从 dockershim 迁移到其他容器运行时的必备知识。</p><p>自从 Kubernetes 1.20 宣布
<a href=/zh-cn/blog/2020/12/08/kubernetes-1-20-release-announcement/#dockershim-deprecation>弃用 dockershim</a>，
各类疑问随之而来：这对各类工作负载和 Kubernetes 部署会产生什么影响。
我们的<a href=/blog/2022/02/17/dockershim-faq/>弃用 Dockershim 常见问题</a>可以帮助你更好地理解这个问题。</p><p>Dockershim 在 Kubernetes v1.24 版本已经被移除。
如果你集群内是通过 dockershim 使用 Docker Engine 作为容器运行时，并希望 Kubernetes 升级到 v1.24，
建议你迁移到其他容器运行时或使用其他方法以获得 Docker 引擎支持。</p><p>建议从 dockershim 迁移到其他替代的容器运行时。
请参阅<a href=/zh-cn/docs/setup/production-environment/container-runtimes/>容器运行时</a>
一节以了解可用的备选项。
当在迁移过程中遇到麻烦，请<a href=https://github.com/kubernetes/kubernetes/issues>上报问题</a>。
那么问题就可以及时修复，你的集群也可以进入移除 dockershim 前的就绪状态。</p><p>你的集群中可以有不止一种类型的节点，尽管这不是常见的情况。</p><p>下面这些任务可以帮助你完成迁移：</p><ul><li><a href=/zh-cn/docs/tasks/administer-cluster/migrating-from-dockershim/check-if-dockershim-removal-affects-you/>检查弃用 Dockershim 是否影响到你</a></li><li><a href=/zh-cn/docs/tasks/administer-cluster/migrating-from-dockershim/migrate-dockershim-dockerd/>将 Docker Engine 节点从 dockershim 迁移到 cri-dockerd</a></li><li><a href=/zh-cn/docs/tasks/administer-cluster/migrating-from-dockershim/migrating-telemetry-and-security-agents/>从 dockershim 迁移遥测和安全代理</a></li></ul><h2 id=接下来>接下来</h2><ul><li>查看<a href=/zh-cn/docs/setup/production-environment/container-runtimes/>容器运行时</a>了解可选的容器运行时。</li><li><a href=https://github.com/kubernetes/kubernetes/issues/106917>GitHub 问题</a>跟踪有关
dockershim 的弃用和删除的讨论。</li><li>如果你发现与 dockershim 迁移相关的缺陷或其他技术问题，
可以在 Kubernetes 项目<a href=https://github.com/kubernetes/kubernetes/issues/new/choose>报告问题</a>。</li></ul></div></div><div class=td-content style=page-break-before:always><h1 id=pg-b8acce0768c2f92cdb8eaa31e8072353>1 - 将节点上的容器运行时从 Docker Engine 改为 containerd</h1><p>本任务给出将容器运行时从 Docker 改为 containerd 所需的步骤。
此任务适用于运行 1.23 或更早版本 Kubernetes 的集群操作人员。
同时，此任务也涉及从 dockershim 迁移到 containerd 的示例场景。
有关其他备选的容器运行时，可查阅
<a href=/zh-cn/docs/setup/production-environment/container-runtimes/>此页面</a>进行拣选。</p><h2 id=准备开始>准备开始</h2><div class="alert alert-secondary callout third-party-content" role=alert><strong>说明：</strong>
本部分链接到提供 Kubernetes 所需功能的第三方项目。Kubernetes 项目作者不负责这些项目。此页面遵循<a href=https://github.com/cncf/foundation/blob/master/website-guidelines.md target=_blank>CNCF 网站指南</a>，按字母顺序列出项目。要将项目添加到此列表中，请在提交更改之前阅读<a href=/docs/contribute/style/content-guide/#third-party-content>内容指南</a>。</div><p>安装 containerd。进一步的信息可参见
<a href=https://containerd.io/docs/getting-started/>containerd 的安装文档</a>。
关于一些特定的环境准备工作，请遵循 <a href=/zh-cn/docs/setup/production-environment/container-runtimes/#containerd>containerd 指南</a>。</p><h2 id=drain-the-node>腾空节点</h2><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl drain &lt;node-to-drain&gt; --ignore-daemonsets
</span></span></code></pre></div><p>将 <code>&lt;node-to-drain></code> 替换为你所要腾空的节点的名称。</p><h2 id=stop-the-docker-daemon>停止 Docker 守护进程</h2><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>systemctl stop kubelet
</span></span><span style=display:flex><span>systemctl disable docker.service --now
</span></span></code></pre></div><h2 id=install-containerd>安装 Containerd</h2><p>遵循此<a href=/zh-cn/docs/setup/production-environment/container-runtimes/#containerd>指南</a>
了解安装 containerd 的详细步骤。</p><ul class="nav nav-tabs" id=tab-cri-containerd-installation role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-cri-containerd-installation-0 role=tab aria-controls=tab-cri-containerd-installation-0 aria-selected=true>Linux</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-cri-containerd-installation-1 role=tab aria-controls=tab-cri-containerd-installation-1>Windows (PowerShell)</a></li></ul><div class=tab-content id=tab-cri-containerd-installation><div id=tab-cri-containerd-installation-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-cri-containerd-installation-0><p><ol><li>从官方的 Docker 仓库安装 <code>containerd.io</code> 包。关于为你所使用的 Linux 发行版来设置
Docker 仓库，以及安装 <code>containerd.io</code> 包的详细说明，
可参见<a href=https://github.com/containerd/containerd/blob/main/docs/getting-started.md>开始使用 containerd</a>。</li></ol><ol start=2><li><p>配置 containerd：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sudo mkdir -p /etc/containerd
</span></span><span style=display:flex><span>containerd config default | sudo tee /etc/containerd/config.toml
</span></span></code></pre></div></li></ol><ol start=3><li><p>重启 containerd：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sudo systemctl restart containerd
</span></span></code></pre></div></li></ol></div><div id=tab-cri-containerd-installation-1 class=tab-pane role=tabpanel aria-labelledby=tab-cri-containerd-installation-1><p><p>启动一个 Powershell 会话，将 <code>$Version</code> 设置为期望的版本（例如：<code>$Version="1.4.3"</code>），
之后运行下面的命令：</p><ol><li><p>下载 containerd：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>curl.exe -L https<span>:</span>//github.com/containerd/containerd/releases/download/v<span style=color:#b8860b>$Version</span>/containerd-<span style=color:#b8860b>$Version</span>-windows-amd64.tar.gz -o <span style=color:#a2f>containerd-windows</span>-amd64.tar.gz
</span></span><span style=display:flex><span>tar.exe xvf .\<span style=color:#a2f>containerd-windows</span>-amd64.tar.gz
</span></span></code></pre></div></li></ol><ol start=2><li><p>解压缩并执行配置：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#a2f>Copy-Item</span> -Path <span style=color:#b44>&#34;.\bin\&#34;</span> -Destination <span style=color:#b44>&#34;</span><span style=color:#b8860b>$Env:ProgramFiles</span><span style=color:#b44>\containerd&#34;</span> -Recurse -Force
</span></span><span style=display:flex><span><span style=color:#a2f>cd </span><span style=color:#b8860b>$Env:ProgramFiles</span>\containerd\
</span></span><span style=display:flex><span>.\containerd.exe config <span style=color:#a2f;font-weight:700>default</span> | <span style=color:#a2f>Out-File</span> config.toml -Encoding ascii
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 请审查配置信息。取决于你的安装环境，你可能需要调整：</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># - sandbox_image （Kubernetes pause 镜像）</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># - CNI 的 bin_dir 和 conf_dir 的位置</span>
</span></span><span style=display:flex><span><span style=color:#a2f>Get-Content</span> config.toml
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># （可选步骤，但强烈建议执行）将 containerd 排除在 Windows Defender 扫描之外</span>
</span></span><span style=display:flex><span><span style=color:#a2f>Add-MpPreference</span> -ExclusionProcess <span style=color:#b44>&#34;</span><span style=color:#b8860b>$Env:ProgramFiles</span><span style=color:#b44>\containerd\containerd.exe&#34;</span>
</span></span></code></pre></div></li></ol><ol start=3><li><p>启动 containerd：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>.\containerd.exe --register-service
</span></span><span style=display:flex><span><span style=color:#a2f>Start-Service</span> containerd
</span></span></code></pre></div></li></ol></div></div><h2 id=配置-kubelet-使用-containerd-作为其容器运行时>配置 kubelet 使用 containerd 作为其容器运行时</h2><p>编辑文件 <code>/var/lib/kubelet/kubeadm-flags.env</code>，将 containerd 运行时添加到标志中：
<code>--container-runtime=remote</code> 和
<code>--container-runtime-endpoint=unix:///run/containerd/containerd.sock</code>。</p><p><code>kubeadm</code> 工具将每个主机的 CRI 套接字保存在该主机对应的 Node 对象的注解中。
使用 <code>kubeadm</code> 的用户应该知道，<code>kubeadm</code> 工具将每个主机的 CRI 套接字保存在该主机对应的
Node 对象的注解中。
要更改这一注解信息，你可以在一台包含 kubeadm <code>/etc/kubernetes/admin.conf</code> 文件的机器上执行以下命令：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl edit no &lt;node-name&gt;
</span></span></code></pre></div><p>这一命令会打开一个文本编辑器，供你在其中编辑 Node 对象。
要选择不同的文本编辑器，你可以设置 <code>KUBE_EDITOR</code> 环境变量。</p><ul><li><p>更改 <code>kubeadm.alpha.kubernetes.io/cri-socket</code> 值，将其从
<code>/var/run/dockershim.sock</code> 改为你所选择的 CRI 套接字路径
（例如：<code>unix:///run/containerd/containerd.sock</code>）。</p><p>注意新的 CRI 套接字路径必须带有 <code>unix://</code> 前缀。</p></li><li><p>保存文本编辑器中所作的修改，这会更新 Node 对象。</p></li></ul><h2 id=restart-the-kubelet>重启 kubelet</h2><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>systemctl start kubelet
</span></span></code></pre></div><h2 id=verify-that-the-node-is-healthy>验证节点处于健康状态</h2><p>运行 <code>kubectl get nodes -o wide</code>，containerd 会显示为我们所更改的节点上的运行时。</p><h2 id=remove-docker-engine>移除 Docker Engine</h2><div class="alert alert-secondary callout third-party-content" role=alert><strong>说明：</strong>
本部分链接到提供 Kubernetes 所需功能的第三方项目。Kubernetes 项目作者不负责这些项目。此页面遵循<a href=https://github.com/cncf/foundation/blob/master/website-guidelines.md target=_blank>CNCF 网站指南</a>，按字母顺序列出项目。要将项目添加到此列表中，请在提交更改之前阅读<a href=/docs/contribute/style/content-guide/#third-party-content>内容指南</a>。</div><p>最后，在一切顺利时删除 Docker。</p><ul class="nav nav-tabs" id=tab-remove-docker-engine role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tab-remove-docker-engine-0 role=tab aria-controls=tab-remove-docker-engine-0 aria-selected=true>CentOS</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-remove-docker-engine-1 role=tab aria-controls=tab-remove-docker-engine-1>Debian</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-remove-docker-engine-2 role=tab aria-controls=tab-remove-docker-engine-2>Fedora</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tab-remove-docker-engine-3 role=tab aria-controls=tab-remove-docker-engine-3>Ubuntu</a></li></ul><div class=tab-content id=tab-remove-docker-engine><div id=tab-remove-docker-engine-0 class="tab-pane show active" role=tabpanel aria-labelledby=tab-remove-docker-engine-0><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sudo yum remove docker-ce docker-ce-cli
</span></span></code></pre></div></div><div id=tab-remove-docker-engine-1 class=tab-pane role=tabpanel aria-labelledby=tab-remove-docker-engine-1><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sudo apt-get purge docker-ce docker-ce-cli
</span></span></code></pre></div></div><div id=tab-remove-docker-engine-2 class=tab-pane role=tabpanel aria-labelledby=tab-remove-docker-engine-2><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sudo dnf remove docker-ce docker-ce-cli
</span></span></code></pre></div></div><div id=tab-remove-docker-engine-3 class=tab-pane role=tabpanel aria-labelledby=tab-remove-docker-engine-3><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sudo apt-get purge docker-ce docker-ce-cli
</span></span></code></pre></div></div></div><p>上面的命令不会移除你的主机上的镜像、容器、卷或者定制的配置文件。
要删除这些内容，参阅 Docker 的指令来<a href=https://docs.docker.com/engine/install/ubuntu/#uninstall-docker-engine>卸载 Docker Engine</a>。</p><div class="alert alert-warning caution callout" role=alert><strong>注意：</strong><p>Docker 所提供的卸载 Docker Engine 命令指导中，存在删除 containerd 的风险。
在执行命令时要谨慎。</div></div><div class=td-content style=page-break-before:always><h1 id=pg-d81ef0973a7bb4813e1797a452864742>2 - 将 Docker Engine 节点从 dockershim 迁移到 cri-dockerd</h1><div class="alert alert-secondary callout third-party-content" role=alert><strong>说明：</strong>
本部分链接到提供 Kubernetes 所需功能的第三方项目。Kubernetes 项目作者不负责这些项目。此页面遵循<a href=https://github.com/cncf/foundation/blob/master/website-guidelines.md target=_blank>CNCF 网站指南</a>，按字母顺序列出项目。要将项目添加到此列表中，请在提交更改之前阅读<a href=/docs/contribute/style/content-guide/#third-party-content>内容指南</a>。</div><p>本页面为你展示如何迁移你的 Docker Engine 节点，使之使用 <code>cri-dockerd</code> 而不是 dockershim。
在以下场景中，你可以遵从这里的步骤执行操作：</p><ul><li>你期望不再使用 dockershim，但仍然使用 Docker Engine 来在 Kubernetes 中运行容器。</li><li>你希望升级到 Kubernetes v1.25 且你的现有集群依赖于 dockershim，
因此你必须放弃 dockershim，而 <code>cri-dockerd</code> 是你的一种选项。</li></ul><p>要进一步了解 dockershim 的移除，请阅读 <a href=/zh-cn/dockershim>FAQ 页面</a>。</p><h2 id=what-is-cri-dockerd>cri-dockerd 是什么？</h2><p>在 Kubernetes v1.24 及更早版本中，你可以在 Kubernetes 中使用 Docker Engine，
依赖于一个称作 <em>dockershim</em> 的内置 Kubernetes 组件。
dockershim 组件在 Kubernetes v1.24 发行版本中已被移除；不过，一种来自第三方的替代品，
<code>cri-dockerd</code> 是可供使用的。<code>cri-dockerd</code> 适配器允许你通过
<a class=glossary-tooltip title='一组与 kubelet 集成的容器运行时 API' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/overview/components/#container-runtime target=_blank aria-label='容器运行时接口（Container Runtime Interface，CRI）'>容器运行时接口（Container Runtime Interface，CRI）</a>
来使用 Docker Engine。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>如果你已经在使用 <code>cri-dockerd</code>，那么你不会被 dockershim 的移除影响到。
在开始之前，<a href=/zh-cn/docs/tasks/administer-cluster/migrating-from-dockershim/find-out-runtime-you-use/>检查你的节点是否在使用 dockershim</a>。</div><p>如果你想要迁移到 <code>cri-dockerd</code> 以便继续使用 Docker Engine 作为你的容器运行时，
你需要在所有被影响的节点上执行以下操作：</p><ol><li>安装 <code>cri-dockerd</code>；</li><li>隔离（Cordon）并腾空（Drain）该节点；</li><li>配置 kubelet 使用 <code>cri-dockerd</code>；</li><li>重新启动 kubelet；</li><li>验证节点处于健康状态。</li></ol><p>首先在非关键节点上测试这一迁移过程。</p><p>你应该针对所有希望迁移到 <code>cri-dockerd</code> 的节点执行以下步骤。</p><h2 id=准备开始>准备开始</h2><ul><li>安装了 <a href=https://github.com/mirantis/cri-dockerd#build-and-install><code>cri-dockerd</code></a>
并且该服务已经在各节点上启动；</li><li>一个<a href=/zh-cn/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/>网络插件</a>。</li></ul><h2 id=cordon-and-drain-the-node>隔离并腾空节点</h2><ol><li><p>隔离节点，阻止新的 Pod 被调度到节点上：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl cordon &lt;NODE_NAME&gt;
</span></span></code></pre></div><p>将 <code>&lt;NODE_NAME></code> 替换为节点名称。</p></li></ol><ol start=2><li><p>腾空节点以安全地逐出所有运行中的 Pod：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl drain &lt;NODE_NAME&gt; --ignore-daemonsets
</span></span></code></pre></div></li></ol><h2 id=configure-the-kubelet-to-use-cri-dockerd>配置 kubelet 使用 cri-dockerd</h2><p>下面的步骤适用于用 kubeadm 工具安装的集群。如果你使用不同的工具，
你需要使用针对该工具的配置指令来修改 kubelet。</p><ol><li>在每个被影响的节点上，打开 <code>/var/lib/kubelet/kubeadm-flags.env</code> 文件；</li><li>将 <code>--container-runtime-endpoint</code> 标志，将其设置为 <code>unix:///var/run/cri-dockerd.sock</code>。</li></ol><p>kubeadm 工具将节点上的套接字存储为控制面上 <code>Node</code> 对象的注解。
要为每个被影响的节点更改此套接字：</p><ol><li><p>编辑 <code>Node</code> 对象的 YAML 表示：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#b8860b>KUBECONFIG</span><span style=color:#666>=</span>/path/to/admin.conf kubectl edit no &lt;NODE_NAME&gt;
</span></span></code></pre></div><p>根据下面的说明执行替换：</p><ul><li><code>/path/to/admin.conf</code>：指向 kubectl 配置文件 <code>admin.conf</code> 的路径；</li><li><code>&lt;NODE_NAME></code>：你要修改的节点的名称。</li></ul></li><li><p>将 <code>kubeadm.alpha.kubernetes.io/cri-socket</code> 标志从
<code>/var/run/dockershim.sock</code> 更改为 <code>unix:///var/run/cri-dockerd.sock</code>；</p></li><li><p>保存所作更改。保存时，<code>Node</code> 对象被更新。</p></li></ol><h2 id=restart-the-kubelet>重启 kubelet</h2><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>systemctl restart kubelet
</span></span></code></pre></div><h2 id=verify-that-the-node-is-healthy>验证节点处于健康状态</h2><p>要检查节点是否在使用 <code>cri-dockerd</code> 端点，
按照<a href=/zh-cn/docs/tasks/administer-cluster/migrating-from-dockershim/find-out-runtime-you-use/>找出你所使用的运行时</a>页面所给的指令操作。
kubelet 的 <code>--container-runtime-endpoint</code> 标志取值应该是 <code>unix:///var/run/cri-dockerd.sock</code>。</p><h2 id=uncordon-the-node>解除节点隔离</h2><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl uncordon &lt;NODE_NAME&gt;
</span></span></code></pre></div><h2 id=接下来>接下来</h2><ul><li>阅读 <a href=/zh-cn/dockershim>移除 Dockershim 的常见问题</a>。</li><li><a href=/zh-cn/docs/tasks/administer-cluster/migrating-from-dockershim/change-runtime-containerd/>了解如何从基于 dockershim 的 Docker Engine 迁移到 containerd</a>。</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-d79db9ed1698f75ec5f2228987290e49>3 - 查明节点上所使用的容器运行时</h1><p>本页面描述查明集群中节点所使用的<a href=/zh-cn/docs/setup/production-environment/container-runtimes/>容器运行时</a>
的步骤。</p><p>取决于你运行集群的方式，节点所使用的容器运行时可能是事先配置好的，
也可能需要你来配置。如果你在使用托管的 Kubernetes 服务，
可能存在特定于厂商的方法来检查节点上配置的容器运行时。
本页描述的方法应该在能够执行 <code>kubectl</code> 的场合下都可以工作。</p><h2 id=准备开始>准备开始</h2><p>安装并配置 <code>kubectl</code>。参见<a href=/zh-cn/docs/tasks/tools/#kubectl>安装工具</a> 节了解详情。</p><h2 id=find-out-the-container-runtime-used-on-a-node>查明节点所使用的容器运行时</h2><p>使用 <code>kubectl</code> 来读取并显示节点信息：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get nodes -o wide
</span></span></code></pre></div><p>输出如下面所示。<code>CONTAINER-RUNTIME</code> 列给出容器运行时及其版本。</p><p>对于 Docker Engine，输出类似于：</p><pre tabindex=0><code class=language-none data-lang=none>NAME         STATUS   VERSION    CONTAINER-RUNTIME
node-1       Ready    v1.16.15   docker://19.3.1
node-2       Ready    v1.16.15   docker://19.3.1
node-3       Ready    v1.16.15   docker://19.3.1
</code></pre><p>如果你的容器运行时显示为 Docker Engine，你仍然可能不会被 v1.24 中 dockershim 的移除所影响。
通过<a href=#which-endpoint>检查运行时端点</a>，可以查看你是否在使用 dockershim。
如果你没有使用 dockershim，你就不会被影响。</p><p>对于 containerd，输出类似于这样：</p><pre tabindex=0><code class=language-none data-lang=none># For containerd
NAME         STATUS   VERSION   CONTAINER-RUNTIME
node-1       Ready    v1.19.6   containerd://1.4.1
node-2       Ready    v1.19.6   containerd://1.4.1
node-3       Ready    v1.19.6   containerd://1.4.1
</code></pre><p>你可以在<a href=/zh-cn/docs/setup/production-environment/container-runtimes/>容器运行时</a>
页面找到与容器运行时相关的更多信息。</p><h2 id=which-endpoint>检查当前使用的运行时端点</h2><p>容器运行时使用 Unix Socket 与 kubelet 通信，这一通信使用基于 gRPC 框架的
<a href=/zh-cn/docs/concepts/architecture/cri/>CRI 协议</a>。kubelet 扮演客户端，运行时扮演服务器端。
在某些情况下，你可能想知道你的节点使用的是哪个 socket。
如若集群是 Kubernetes v1.24 及以后的版本，
或许你想知道当前运行时是否是使用 dockershim 的 Docker Engine。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>如果你的节点在通过 <code>cri-dockerd</code> 使用 Docker Engine，
那么集群不会受到 Kubernetes 移除 dockershim 的影响。</div><p>可以通过检查 kubelet 的参数得知当前使用的是哪个 socket。</p><ol><li><p>查看 kubelet 进程的启动命令</p><pre tabindex=0><code> tr \\0 &#39; &#39; &lt; /proc/&#34;$(pgrep kubelet)&#34;/cmdline
</code></pre><p>如有节点上没有 <code>tr</code> 或者 <code>pgrep</code>，就需要手动检查 kubelet 的启动命令</p></li></ol><ol start=2><li><p>在命令的输出中，查找 <code>--container-runtime</code> 和 <code>--container-runtime-endpoint</code> 标志。</p><ul><li>如果 Kubernetes 集群版本是 v1.23 或者更早的版本，并且这两个参数不存在，
或者 <code>container-runtime</code> 标志值不是 <code>remote</code>，则你在通过 dockershim 套接字使用
Docker Engine。
或者如果集群使用的 Docker engine 和 dockershim socket，则输出结果中 <code>--container-runtime</code> 不是 <code>remote</code>,</li><li>如果设置了 <code>--container-runtime-endpoint</code> 参数，查看套接字名称即可得知当前使用的运行时。
如若套接字 <code>unix:///run/containerd/containerd.sock</code> 是 containerd 的端点。</li></ul></li></ol><p>如果你将节点上的容器运行时从 Docker Engine 改变为 containerd，可在
<a href=/zh-cn/docs/tasks/administer-cluster/migrating-from-dockershim/change-runtime-containerd/>迁移到不同的运行时</a>
找到更多信息。或者，如果你想在 Kubernetes v1.24 及以后的版本仍使用 Docker Engine，
可以安装 CRI 兼容的适配器实现，如 <a href=https://github.com/Mirantis/cri-dockerd><code>cri-dockerd</code></a>。
<a href=https://github.com/Mirantis/cri-dockerd><code>cri-dockerd</code></a>。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-c4b5bb78bc6c59690d21c44e41f12270>4 - 排查 CNI 插件相关的错误</h1><p>为了避免 CNI 插件相关的错误，需要验证你正在使用或升级到一个经过测试的容器运行时，
该容器运行时能够在你的 Kubernetes 版本上正常工作。</p><h2 id=about-the-incompatible-cni-versions-and-failed-to-destroy-network-for-sandbox-errors>关于 "Incompatible CNI versions" 和 "Failed to destroy network for sandbox" 错误</h2><p>在 containerd v1.6.0-v1.6.3 中，当配置或清除 Pod CNI 网络时，如果 CNI 插件没有升级和/或
CNI 配置文件中没有声明 CNI 配置版本时，会出现服务问题。containerd 团队报告说：
“这些问题在 containerd v1.6.4 中得到了解决。”</p><p>在使用 containerd v1.6.0-v1.6.3 时，如果你不升级 CNI 插件和/或声明 CNI 配置版本，
你可能会遇到以下 "Incompatible CNI versions" 或 "Failed to destroy network for sandbox"
错误状况。</p><h3 id=incompatible-cni-versions-error>Incompatible CNI versions 错误</h3><p>如果因为配置版本比插件版本新，导致你的 CNI 插件版本与配置中的插件版本无法正确匹配时，
在启动 Pod 时，containerd 日志可能会显示类似的错误信息：</p><pre tabindex=0><code>incompatible CNI versions; config is \&#34;1.0.0\&#34;, plugin supports [\&#34;0.1.0\&#34; \&#34;0.2.0\&#34; \&#34;0.3.0\&#34; \&#34;0.3.1\&#34; \&#34;0.4.0\&#34;]&#34;
</code></pre><p>为了解决这个问题，需要<a href=#updating-your-cni-plugins-and-cni-config-files>更新你的 CNI 插件和 CNI 配置文件</a>。</p><h3 id=failed-to-destroy-network-for-sandbox-error>Failed to destroy network for sandbox 错误</h3><p>如果 CNI 插件配置中未给出插件的版本，
Pod 可能可以运行。但是，停止 Pod 时会产生类似于以下错误：</p><pre tabindex=0><code>ERRO[2022-04-26T00:43:24.518165483Z] StopPodSandbox for &#34;b&#34; failed
error=&#34;failed to destroy network for sandbox \&#34;bbc85f891eaf060c5a879e27bba9b6b06450210161dfdecfbb2732959fb6500a\&#34;: invalid version \&#34;\&#34;: the version is empty&#34;
</code></pre><p>此错误使 Pod 处于未就绪状态，且仍然挂接到某网络名字空间上。
为修复这一问题，<a href=#updating-your-cni-plugins-and-cni-config-files>编辑 CNI 配置文件</a>以添加缺失的版本信息。
下一次尝试停止 Pod 应该会成功。</p><h3 id=updating-your-cni-plugins-and-cni-config-files>更新你的 CNI 插件和 CNI 配置文件</h3><p>如果你使用 containerd v1.6.0-v1.6.3 并遇到 "Incompatible CNI versions" 或者
"Failed to destroy network for sandbox" 错误，考虑更新你的 CNI 插件并编辑 CNI 配置文件。</p><p>以下是针对各节点要执行的典型步骤的概述：</p><ol><li><a href=/zh-cn/docs/tasks/administer-cluster/safely-drain-node/>安全地腾空并隔离节点</a>。</li></ol><ol start=2><li>停止容器运行时和 kubelet 服务后，执行以下升级操作：</li></ol><ul><li>如果你正在运行 CNI 插件，请将它们升级到最新版本。</li><li>如果你使用的是非 CNI 插件，请将它们替换为 CNI 插件，并使用最新版本的插件。</li><li>更新插件配置文件以指定或匹配 CNI 规范支持的插件版本，
如后文<a href=#an-example-containerd-configuration-file>"containerd 配置文件示例"</a>章节所示。</li><li>对于 <code>containerd</code>，请确保你已安装 CNI loopback 插件的最新版本（v1.0.0 或更高版本）。</li><li>将节点组件（例如 kubelet）升级到 Kubernetes v1.24</li><li>升级到或安装最新版本的容器运行时。</li></ul><ol start=3><li>通过重新启动容器运行时和 kubelet 将节点重新加入到集群。取消节点隔离（<code>kubectl uncordon &lt;nodename></code>）。</li></ol><h2 id=an-example-containerd-configuration-file>containerd 配置文件示例</h2><p>以下示例显示了 <code>containerd</code> 运行时 v1.6.x 的配置，
它支持最新版本的 CNI 规范（v1.0.0）。
请参阅你的插件和网络提供商的文档，以获取有关你系统配置的进一步说明。</p><p>在 Kubernetes 中，作为其默认行为，containerd 运行时为 Pod 添加一个本地回路接口，<code>lo</code>。
containerd 运行时通过 CNI 插件 <code>loopback</code> 配置本地回路接口。<br><code>loopback</code> 插件作为 <code>containerd</code> 发布包的一部分，扮演 <code>cni</code> 角色。
<code>containerd</code> v1.6.0 及更高版本包括与 CNI v1.0.0 兼容的 loopback 插件以及其他默认 CNI 插件。
loopback 插件的配置由 containerd 内部完成， 并被设置为使用 CNI v1.0.0。
这也意味着当这个更新版本的 <code>containerd</code> 启动时，<code>loopback</code> 插件的版本必然是 v1.0.0 或更高版本。</p><p>以下 Bash 命令生成一个 CNI 配置示例。这里，<code>cniVersion</code> 字段被设置为配置版本值 1.0.0，
以供 <code>containerd</code> 调用 CNI 桥接插件时使用。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt; EOF | tee /etc/cni/net.d/10-containerd-net.conflist
</span></span></span><span style=display:flex><span><span style=color:#b44>{
</span></span></span><span style=display:flex><span><span style=color:#b44> &#34;cniVersion&#34;: &#34;1.0.0&#34;,
</span></span></span><span style=display:flex><span><span style=color:#b44> &#34;name&#34;: &#34;containerd-net&#34;,
</span></span></span><span style=display:flex><span><span style=color:#b44> &#34;plugins&#34;: [
</span></span></span><span style=display:flex><span><span style=color:#b44>   {
</span></span></span><span style=display:flex><span><span style=color:#b44>     &#34;type&#34;: &#34;bridge&#34;,
</span></span></span><span style=display:flex><span><span style=color:#b44>     &#34;bridge&#34;: &#34;cni0&#34;,
</span></span></span><span style=display:flex><span><span style=color:#b44>     &#34;isGateway&#34;: true,
</span></span></span><span style=display:flex><span><span style=color:#b44>     &#34;ipMasq&#34;: true,
</span></span></span><span style=display:flex><span><span style=color:#b44>     &#34;promiscMode&#34;: true,
</span></span></span><span style=display:flex><span><span style=color:#b44>     &#34;ipam&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#b44>       &#34;type&#34;: &#34;host-local&#34;,
</span></span></span><span style=display:flex><span><span style=color:#b44>       &#34;ranges&#34;: [
</span></span></span><span style=display:flex><span><span style=color:#b44>         [{
</span></span></span><span style=display:flex><span><span style=color:#b44>           &#34;subnet&#34;: &#34;10.88.0.0/16&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44>         }],
</span></span></span><span style=display:flex><span><span style=color:#b44>         [{
</span></span></span><span style=display:flex><span><span style=color:#b44>           &#34;subnet&#34;: &#34;2001:db8:4860::/64&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44>         }]
</span></span></span><span style=display:flex><span><span style=color:#b44>       ],
</span></span></span><span style=display:flex><span><span style=color:#b44>       &#34;routes&#34;: [
</span></span></span><span style=display:flex><span><span style=color:#b44>         { &#34;dst&#34;: &#34;0.0.0.0/0&#34; },
</span></span></span><span style=display:flex><span><span style=color:#b44>         { &#34;dst&#34;: &#34;::/0&#34; }
</span></span></span><span style=display:flex><span><span style=color:#b44>       ]
</span></span></span><span style=display:flex><span><span style=color:#b44>     }
</span></span></span><span style=display:flex><span><span style=color:#b44>   },
</span></span></span><span style=display:flex><span><span style=color:#b44>   {
</span></span></span><span style=display:flex><span><span style=color:#b44>     &#34;type&#34;: &#34;portmap&#34;,
</span></span></span><span style=display:flex><span><span style=color:#b44>     &#34;capabilities&#34;: {&#34;portMappings&#34;: true}
</span></span></span><span style=display:flex><span><span style=color:#b44>   }
</span></span></span><span style=display:flex><span><span style=color:#b44> ]
</span></span></span><span style=display:flex><span><span style=color:#b44>}
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>基于你的用例和网络地址规划，将前面示例中的 IP 地址范围更新为合适的值。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-cbd252cc297e67c1b73a84d5882474fb>5 - 检查移除 Dockershim 是否对你有影响</h1><p>Kubernetes 的 <code>dockershim</code> 组件使得你可以把 Docker 用作 Kubernetes 的
<a class=glossary-tooltip title=容器运行时是负责运行容器的软件。 data-toggle=tooltip data-placement=top href=/zh-cn/docs/setup/production-environment/container-runtimes target=_blank aria-label=容器运行时>容器运行时</a>。
在 Kubernetes v1.24 版本中，内建组件 <code>dockershim</code> 被移除。</p><p>本页讲解你的集群把 Docker 用作容器运行时的运作机制，
并提供使用 <code>dockershim</code> 时，它所扮演角色的详细信息，
继而展示了一组操作，可用来检查移除 <code>dockershim</code> 对你的工作负载是否有影响。</p><h2 id=find-docker-dependencies>检查你的应用是否依赖于 Docker</h2><p>即使你是通过 Docker 创建的应用容器，也不妨碍你在其他任何容器运行时上运行这些容器。
这种使用 Docker 的方式并不构成对 Docker 作为一个容器运行时的依赖。</p><p>当用了别的容器运行时之后，Docker 命令可能不工作，或者产生意外的输出。
下面是判定你是否依赖于 Docker 的方法。</p><ol><li>确认没有特权 Pod 执行 Docker 命令（如 <code>docker ps</code>）、重新启动 Docker
服务（如 <code>systemctl restart docker.service</code>）或修改 Docker 配置文件
<code>/etc/docker/daemon.json</code>。</li><li>检查 Docker 配置文件（如 <code>/etc/docker/daemon.json</code>）中容器镜像仓库的镜像（mirror）站点设置。
这些配置通常需要针对不同容器运行时来重新设置。</li><li>检查确保在 Kubernetes 基础设施之外的节点上运行的脚本和应用程序没有执行 Docker 命令。
可能的情况有：<ul><li>SSH 到节点排查故障；</li><li>节点启动脚本；</li><li>直接安装在节点上的监控和安全代理。</li></ul></li></ol><ol start=4><li>检查执行上述特权操作的第三方工具。
详细操作请参考<a href=/zh-cn/docs/tasks/administer-cluster/migrating-from-dockershim/migrating-telemetry-and-security-agents>从 dockershim 迁移遥测和安全代理</a>。</li><li>确认没有对 dockershim 行为的间接依赖。这是一种极端情况，不太可能影响你的应用。
一些工具很可能被配置为使用了 Docker 特性，比如，基于特定指标发警报，
或者在故障排查指令的一个环节中搜索特定的日志信息。
如果你有此类配置的工具，需要在迁移之前，在测试集群上测试这类行为。</li></ol><h2 id=role-of-dockershim>Docker 依赖详解</h2><p><a href=/zh-cn/docs/concepts/containers/#container-runtimes>容器运行时</a>是一个软件，
用来运行组成 Kubernetes Pod 的容器。
Kubernetes 负责编排和调度 Pod；在每一个节点上，<a class=glossary-tooltip title='一个在集群中每个节点上运行的代理。它保证容器都运行在 Pod 中。' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a>
使用抽象的容器运行时接口，所以你可以任意选用兼容的容器运行时。</p><p>在早期版本中，Kubernetes 提供的兼容性支持一个容器运行时：Docker。
在 Kubernetes 后来的发展历史中，集群运营人员希望采用别的容器运行时。
于是 CRI 被设计出来满足这类灵活性需求 - 而 kubelet 亦开始支持 CRI。
然而，因为 Docker 在 CRI 规范创建之前就已经存在，Kubernetes 就创建了一个适配器组件 <code>dockershim</code>。
dockershim 适配器允许 kubelet 与 Docker 交互，就好像 Docker 是一个 CRI 兼容的运行时一样。</p><p>你可以阅读博文
<a href=/blog/2018/05/24/kubernetes-containerd-integration-goes-ga/>Kubernetes 正式支持集成 Containerd</a>。</p><p><img src=/images/blog/2018-05-24-kubernetes-containerd-integration-goes-ga/cri-containerd.png alt="Dockershim 和 Containerd CRI 的实现对比图"></p><p>切换到 Containerd 容器运行时可以消除掉中间环节。
所有相同的容器都可由 Containerd 这类容器运行时来运行。
但是现在，由于直接用容器运行时调度容器，它们对 Docker 是不可见的。
因此，你以前用来检查这些容器的 Docker 工具或漂亮的 UI 都不再可用。</p><p>你不能再使用 <code>docker ps</code> 或 <code>docker inspect</code> 命令来获取容器信息。
由于你不能列出容器，因此你不能获取日志、停止容器，甚至不能通过 <code>docker exec</code> 在容器中执行命令。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>如果你在用 Kubernetes 运行工作负载，最好通过 Kubernetes API 停止容器，
而不是通过容器运行时来停止它们（此建议适用于所有容器运行时，不仅仅是针对 Docker）。</div><p>你仍然可以下载镜像，或者用 <code>docker build</code> 命令创建它们。
但用 Docker 创建、下载的镜像，对于容器运行时和 Kubernetes，均不可见。
为了在 Kubernetes 中使用，需要把镜像推送（push）到某镜像仓库。</p><h2 id=接下来>接下来</h2><ul><li>阅读<a href=/zh-cn/docs/tasks/administer-cluster/migrating-from-dockershim/>从 dockershim 迁移</a>，
以了解你的下一步工作。</li><li>阅读<a href=/zh-cn/blog/2020/12/02/dockershim-faq/>弃用 Dockershim 的常见问题</a>，了解更多信息。</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-eb3e279a6c5e1224e744080a52ee3f28>6 - 从 dockershim 迁移遥测和安全代理</h1><div class="alert alert-secondary callout third-party-content" role=alert><strong>说明：</strong>
本部分链接到提供 Kubernetes 所需功能的第三方项目。Kubernetes 项目作者不负责这些项目。此页面遵循<a href=https://github.com/cncf/foundation/blob/master/website-guidelines.md target=_blank>CNCF 网站指南</a>，按字母顺序列出项目。要将项目添加到此列表中，请在提交更改之前阅读<a href=/docs/contribute/style/content-guide/#third-party-content>内容指南</a>。</div><p>Kubernetes 对与 Docker Engine 直接集成的支持已被弃用且已经被删除。
大多数应用程序不直接依赖于托管容器的运行时。但是，仍然有大量的遥测和监控代理依赖
docker 来收集容器元数据、日志和指标。
本文汇总了一些信息和链接：信息用于阐述如何探查这些依赖，链接用于解释如何迁移这些代理去使用通用的工具或其他容器运行。</p><h2 id=telemetry-and-security-agents>遥测和安全代理</h2><p>在 Kubernetes 集群中，有几种不同的方式来运行遥测或安全代理。
一些代理在以 DaemonSet 的形式运行或直接在节点上运行时，直接依赖于 Docker Engine。</p><h3 id=为什么有些遥测代理会与-docker-engine-通信>为什么有些遥测代理会与 Docker Engine 通信？</h3><p>从历史上看，Kubernetes 是专门为与 Docker Engine 一起工作而编写的。
Kubernetes 负责网络和调度，依靠 Docker Engine
在节点上启动并运行容器（在 Pod 内）。一些与遥测相关的信息，例如 pod 名称，
只能从 Kubernetes 组件中获得。其他数据，例如容器指标，不是容器运行时的责任。
早期遥测代理需要查询容器运行时<strong>和</strong> Kubernetes 以报告准确的信息。
随着时间的推移，Kubernetes 获得了支持多种运行时的能力，
现在支持任何兼容<a href=/zh-cn/docs/concepts/architecture/cri/>容器运行时接口</a>的运行时。</p><p>一些代理和 Docker 工具紧密绑定。比如代理会用到
<a href=https://docs.docker.com/engine/reference/commandline/ps/><code>docker ps</code></a>
或 <a href=https://docs.docker.com/engine/reference/commandline/top/><code>docker top</code></a>
这类命令来列出容器和进程，用
<a href=https://docs.docker.com/engine/reference/commandline/logs/><code>docker logs</code></a>
订阅 Docker 的日志。
如果现有集群中的节点使用 Docker Engine，在你切换到其它容器运行时的时候，
这些命令将不再起作用。</p><h3 id=identify-docker-dependency>识别依赖于 Docker Engine 的 DaemonSet</h3><p>如果某 Pod 想调用运行在节点上的 <code>dockerd</code>，该 Pod 必须满足以下两个条件之一：</p><ul><li>将包含 Docker 守护进程特权套接字的文件系统挂载为一个<a class=glossary-tooltip title='包含可被 Pod 中容器访问的数据的目录。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/storage/volumes/ target=_blank aria-label=卷>卷</a>；或</li><li>直接以卷的形式挂载 Docker 守护进程特权套接字的特定路径。</li></ul><p>举例来说：在 COS 镜像中，Docker 通过 <code>/var/run/docker.sock</code> 开放其 Unix 域套接字。
这意味着 Pod 的规约中需要包含 <code>hostPath</code> 卷以挂载 <code>/var/run/docker.sock</code>。</p><p>下面是一个 shell 示例脚本，用于查找包含直接映射 Docker 套接字的挂载点的 Pod。
你也可以删掉 <code>grep '/var/run/docker.sock'</code> 这一代码片段以查看其它挂载信息。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl get pods --all-namespaces <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>-o<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{range .items[*]}{&#34;\n&#34;}{.metadata.namespace}{&#34;:\t&#34;}{.metadata.name}{&#34;:\t&#34;}{range .spec.volumes[*]}{.hostPath.path}{&#34;, &#34;}{end}{end}&#39;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>| sort <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>| grep <span style=color:#b44>&#39;/var/run/docker.sock&#39;</span>
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>说明：</strong> 对于 Pod 来说，访问宿主机上的 Docker 还有其他方式。
例如，可以挂载 <code>/var/run</code> 的父目录而非其完整路径
（就像<a href=https://gist.github.com/itaysk/7bc3e56d69c4d72a549286d98fd557dd>这个例子</a>）。
上述脚本只检测最常见的使用方式。</div><h3 id=detecting-docker-dependency-from-node-agents>检测节点代理对 Docker 的依赖性</h3><p>在你的集群节点被定制、且在各个节点上均安装了额外的安全和遥测代理的场景下，
一定要和代理的供应商确认：该代理是否依赖于 Docker。</p><h3 id=telemetry-and-security-agent-vendors>遥测和安全代理的供应商</h3><p>本节旨在汇总有关可能依赖于容器运行时的各种遥测和安全代理的信息。</p><p>我们通过
<a href=https://docs.google.com/document/d/1ZFi4uKit63ga5sxEiZblfb-c23lFhvy6RXVPikS8wf0/edit#>谷歌文档</a>
提供了为各类遥测和安全代理供应商准备的持续更新的迁移指导。
请与供应商联系，获取从 dockershim 迁移的最新说明。</p><h2 id=migration-from-dockershim>从 dockershim 迁移</h2><h3 id=aqua-https-www-aquasec-com><a href=https://www.aquasec.com>Aqua</a></h3><p>无需更改：在运行时变更时可以无缝切换运行。</p><h3 id=datadog-https-www-datadoghq-com-product><a href=https://www.datadoghq.com/product/>Datadog</a></h3><p>如何迁移：
<a href=https://docs.datadoghq.com/agent/guide/docker-deprecation/>Kubernetes 中对于 Docker 的弃用</a>
名字中包含以下字符串的 Pod 可能访问 Docker Engine：</p><ul><li><code>datadog-agent</code></li><li><code>datadog</code></li><li><code>dd-agent</code></li></ul><h3 id=dynatrace-https-www-dynatrace-com><a href=https://www.dynatrace.com/>Dynatrace</a></h3><p>如何迁移：
<a href=https://community.dynatrace.com/t5/Best-practices/Migrating-from-Docker-only-to-generic-container-metrics-in/m-p/167030#M49>在 Dynatrace 上从 Docker-only 迁移到通用容器指标</a></p><p>Containerd 支持公告：<a href=https://www.dynatrace.com/news/blog/get-automated-full-stack-visibility-into-containerd-based-kubernetes-environments/>在基于 containerd 的 Kubernetes 环境的获取容器的自动化全栈可见性</a>
CRI-O 支持公告：<a href=https://www.dynatrace.com/news/blog/get-automated-full-stack-visibility-into-your-cri-o-kubernetes-containers-beta/>在基于 CRI-O 的 Kubernetes 环境获取容器的自动化全栈可见性（测试版）</a></p><p>名字中包含以下字符串的 Pod 可能访问 Docker：</p><ul><li><code>dynatrace-oneagent</code></li></ul><h3 id=falco-https-falco-org><a href=https://falco.org>Falco</a></h3><p>如何迁移：
<a href=https://falco.org/docs/getting-started/deployment/#docker-deprecation-in-kubernetes>迁移 Falco 从 dockershim</a>
Falco 支持任何与 CRI 兼容的运行时（默认配置中使用 containerd）；该文档解释了所有细节。</p><p>名字中包含以下字符串的 Pod 可能访问 Docker：</p><ul><li><code>falco</code></li></ul><h3 id=prisma-cloud-compute-https-docs-paloaltonetworks-com-prisma-prisma-cloud-html><a href=https://docs.paloaltonetworks.com/prisma/prisma-cloud.html>Prisma Cloud Compute</a></h3><p>在依赖于 CRI（非 Docker）的集群上安装 Prisma Cloud 时，查看
<a href=https://docs.paloaltonetworks.com/prisma/prisma-cloud/prisma-cloud-admin-compute/install/install_kubernetes.html>Prisma Cloud 提供的文档</a>。</p><p>名字中包含以下字符串的 Pod 可能访问 Docker：</p><ul><li><code>twistlock-defender-ds</code></li></ul><h3 id=signalfx-splunk-https-www-splunk-com-en-us-investor-relations-acquisitions-signalfx-html><a href=https://www.splunk.com/en_us/investor-relations/acquisitions/signalfx.html>SignalFx (Splunk)</a></h3><p>SignalFx Smart Agent（已弃用）在 Kubernetes 集群上使用了多种不同的监视器，
包括 <code>kubernetes-cluster</code>，<code>kubelet-stats/kubelet-metrics</code>，<code>docker-container-stats</code>。
<code>kubelet-stats</code> 监视器此前已被供应商所弃用，现支持 <code>kubelet-metrics</code>。
<code>docker-container-stats</code> 监视器受 dockershim 移除的影响。
不要为 <code>docker-container-stats</code> 监视器使用 Docker Engine 之外的运行时。</p><p>如何从依赖 dockershim 的代理迁移：</p><ol><li>从<a href=https://github.com/signalfx/signalfx-agent/blob/main/docs/monitor-config.md>所配置的监视器</a>中移除 <code>docker-container-stats</code>。
注意，若节点上已经安装了 Docker，在非 dockershim 环境中启用此监视器后会导致报告错误的指标；
如果节点未安装 Docker，则无法获得指标。</li><li><a href=https://github.com/signalfx/signalfx-agent/blob/main/docs/monitors/kubelet-metrics.md>启用和配置 <code>kubelet-metrics</code></a> 监视器。</li></ol><div class="alert alert-info note callout" role=alert><strong>说明：</strong> 收集的指标会发生变化。具体请查看你的告警规则和仪表盘。</div><p>名字中包含以下字符串的 Pod 可能访问 Docker：</p><ul><li><code>signalfx-agent</code></li></ul><h3 id=yahoo-kubectl-flame>Yahoo Kubectl Flame</h3><p>Flame 不支持 Docker 以外的容器运行时，具体可见 <a href=https://github.com/yahoo/kubectl-flame/issues/51>https://github.com/yahoo/kubectl-flame/issues/51</a></p></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/zh-cn/docs/home/>主页</a>
<a class=text-white href=/zh-cn/blog/>博客</a>
<a class=text-white href=/zh-cn/training/>培训</a>
<a class=text-white href=/zh-cn/partners/>合作伙伴</a>
<a class=text-white href=/zh-cn/community/>社区</a>
<a class=text-white href=/zh-cn/case-studies/>案例分析</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 The Kubernetes 作者 | 文档发布基于 <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a> 授权许可</small><br><small class=text-white>Copyright &copy; 2023 Linux 基金会&reg;。保留所有权利。Linux 基金会已注册并使用商标。如需了解 Linux 基金会的商标列表，请访问<a href=https://www.linuxfoundation.org/trademark-usage class=light-text>商标使用页面</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>