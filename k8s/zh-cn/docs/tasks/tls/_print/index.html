<!doctype html><html lang=zh-cn class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=en href=https://kubernetes.io/docs/tasks/tls/><link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/tasks/tls/><link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/tasks/tls/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/tasks/tls/><link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/tasks/tls/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/tasks/tls/><link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/tasks/tls/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/zh-cn/docs/tasks/tls/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>TLS | Kubernetes</title><meta property="og:title" content="TLS"><meta property="og:description" content="了解如何使用传输层安全性（ TLS ）保护集群中的流量。"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/zh-cn/docs/tasks/tls/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="TLS"><meta itemprop=description content="了解如何使用传输层安全性（ TLS ）保护集群中的流量。"><meta name=twitter:card content="summary"><meta name=twitter:title content="TLS"><meta name=twitter:description content="了解如何使用传输层安全性（ TLS ）保护集群中的流量。"><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content="了解如何使用传输层安全性（ TLS ）保护集群中的流量。"><meta property="og:description" content="了解如何使用传输层安全性（ TLS ）保护集群中的流量。"><meta name=twitter:description content="了解如何使用传输层安全性（ TLS ）保护集群中的流量。"><meta property="og:url" content="https://kubernetes.io/zh-cn/docs/tasks/tls/"><meta property="og:title" content="TLS"><meta name=twitter:title content="TLS"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/zh-cn/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/zh-cn/docs/>文档</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/zh-cn/blog/>Kubernetes 博客</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/zh-cn/training/>培训</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/zh-cn/partners/>合作伙伴</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/zh-cn/community/>社区</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/zh-cn/case-studies/>案例分析</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>版本列表</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/zh-cn/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/zh-cn/docs/tasks/tls/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/zh-cn/docs/tasks/tls/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/zh-cn/docs/tasks/tls/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/zh-cn/docs/tasks/tls/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/zh-cn/docs/tasks/tls/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>中文 (Chinese)</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/docs/tasks/tls/>English</a>
<a class=dropdown-item href=/ko/docs/tasks/tls/>한국어 (Korean)</a>
<a class=dropdown-item href=/ja/docs/tasks/tls/>日本語 (Japanese)</a>
<a class=dropdown-item href=/fr/docs/tasks/tls/>Français (French)</a>
<a class=dropdown-item href=/de/docs/tasks/tls/>Deutsch (German)</a>
<a class=dropdown-item href=/es/docs/tasks/tls/>Español (Spanish)</a>
<a class=dropdown-item href=/id/docs/tasks/tls/>Bahasa Indonesia</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>这是本节的多页打印视图。
<a href=# onclick="return print(),!1">点击此处打印</a>.</p><p><a href=/zh-cn/docs/tasks/tls/>返回本页常规视图</a>.</p></div><h1 class=title>TLS</h1><div class=lead>了解如何使用传输层安全性（ TLS ）保护集群中的流量。</div><ul><li>1: <a href=#pg-9a87de8ee8332cb487f34a05debb1125>管理集群中的 TLS 认证</a></li><li>2: <a href=#pg-43d5e2b1fc2a7e104e66d481d08578dc>手动轮换 CA 证书</a></li><li>3: <a href=#pg-1272b18ac0c008f6ffc2c62a29fa929f>为 kubelet 配置证书轮换</a></li></ul><div class=content></div></div><div class=td-content><h1 id=pg-9a87de8ee8332cb487f34a05debb1125>1 - 管理集群中的 TLS 认证</h1><p>Kubernetes 提供 <code>certificates.k8s.io</code> API，可让你配置由你控制的证书颁发机构（CA）
签名的 TLS 证书。 你的工作负载可以使用这些 CA 和证书来建立信任。</p><p><code>certificates.k8s.io</code> API使用的协议类似于
<a href=https://github.com/ietf-wg-acme/acme/>ACME 草案</a>。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>使用 <code>certificates.k8s.io</code> API 创建的证书由指定 <a href=#configuring-your-cluster-to-provide-signing>CA</a> 颁发。
将集群配置为使用集群根目录 CA 可以达到这个目的，但是你永远不要依赖这一假定。
不要以为这些证书将针对群根目录 CA 进行验证。</div><h2 id=准备开始>准备开始</h2><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li></ul><p>你需要 <code>cfssl</code> 工具。
你可以从 <a href=https://github.com/cloudflare/cfssl/releases>https://github.com/cloudflare/cfssl/releases</a>
下载 <code>cfssl</code>。</p><p>本文中某些步骤使用 <code>jq</code> 工具。如果你没有 <code>jq</code>，你可以通过操作系统的软件源安装，
或者从 <a href=https://stedolan.github.io/jq/>https://stedolan.github.io/jq/</a> 获取。</p><h2 id=集群中的-tls-信任>集群中的 TLS 信任</h2><p>信任 Pod 中运行的应用程序所提供的<a href=#configuring-your-cluster-to-provide-signing>自定义 CA</a> 通常需要一些额外的应用程序配置。
你需要将 CA 证书包添加到 TLS 客户端或服务器信任的 CA 证书列表中。
例如，你可以使用 Golang TLS 配置通过解析证书链并将解析的证书添加到
<a href=https://pkg.go.dev/crypto/tls#Config><code>tls.Config</code></a> 结构中的 <code>RootCAs</code>
字段中。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>即使自定义 CA 证书可能包含在文件系统中（在 ConfigMap <code>kube-root-ca.crt</code> 中），
除了验证内部 Kubernetes 端点之外，你不应将该证书颁发机构用于任何目的。
内部 Kubernetes 端点的一个示例是默认命名空间中名为 <code>kubernetes</code> 的服务。</p><p>如果你想为你的工作负载使用自定义证书颁发机构，你应该单独生成该 CA，
并使用你的 Pod 有读权限的 <a href=/zh-cn/docs/tasks/configure-pod-container/configure-pod-configmap>ConfigMap</a>
分发该 CA 证书。</p></div><h2 id=请求证书>请求证书</h2><p>以下部分演示如何为通过 DNS 访问的 Kubernetes 服务创建 TLS 证书。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong> 本教程使用 CFSSL：Cloudflare's PKI 和 TLS 工具包
<a href=https://blog.cloudflare.com/introducing-cfssl/>点击此处</a>了解更多信息。</div><h2 id=创建证书签名请求>创建证书签名请求</h2><p>通过运行以下命令生成私钥和证书签名请求（或 CSR）:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF | cfssl genkey - | cfssljson -bare server
</span></span></span><span style=display:flex><span><span style=color:#b44>{
</span></span></span><span style=display:flex><span><span style=color:#b44>  &#34;hosts&#34;: [
</span></span></span><span style=display:flex><span><span style=color:#b44>    &#34;my-svc.my-namespace.svc.cluster.local&#34;,
</span></span></span><span style=display:flex><span><span style=color:#b44>    &#34;my-pod.my-namespace.pod.cluster.local&#34;,
</span></span></span><span style=display:flex><span><span style=color:#b44>    &#34;192.0.2.24&#34;,
</span></span></span><span style=display:flex><span><span style=color:#b44>    &#34;10.0.34.2&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44>  ],
</span></span></span><span style=display:flex><span><span style=color:#b44>  &#34;CN&#34;: &#34;my-pod.my-namespace.pod.cluster.local&#34;,
</span></span></span><span style=display:flex><span><span style=color:#b44>  &#34;key&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#b44>    &#34;algo&#34;: &#34;ecdsa&#34;,
</span></span></span><span style=display:flex><span><span style=color:#b44>    &#34;size&#34;: 256
</span></span></span><span style=display:flex><span><span style=color:#b44>  }
</span></span></span><span style=display:flex><span><span style=color:#b44>}
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>其中 <code>192.0.2.24</code> 是服务的集群 IP，<code>my-svc.my-namespace.svc.cluster.local</code>
是服务的 DNS 名称，<code>10.0.34.2</code> 是 Pod 的 IP，而
<code>my-pod.my-namespace.pod.cluster.local</code> 是 Pod 的 DNS 名称。
你能看到的输出类似于：</p><pre tabindex=0><code>2022/02/01 11:45:32 [INFO] generate received request
2022/02/01 11:45:32 [INFO] received CSR
2022/02/01 11:45:32 [INFO] generating key: ecdsa-256
2022/02/01 11:45:32 [INFO] encoded CSR
</code></pre><p>此命令生成两个文件；它生成包含 PEM 编码
<a href=https://tools.ietf.org/html/rfc2986>PKCS#10</a> 证书请求的 <code>server.csr</code>，
以及 PEM 编码密钥的 <code>server-key.pem</code>，用于待生成的证书。</p><h2 id=创建证书签名请求-csr-对象发送到-kubernetes-api>创建证书签名请求（CSR）对象发送到 Kubernetes API</h2><p>使用以下命令创建 CSR YAML 文件，并发送到 API 服务器：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF | kubectl apply -f -
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: certificates.k8s.io/v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: CertificateSigningRequest
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: my-svc.my-namespace
</span></span></span><span style=display:flex><span><span style=color:#b44>spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>  request: $(cat server.csr | base64 | tr -d &#39;\n&#39;)
</span></span></span><span style=display:flex><span><span style=color:#b44>  signerName: example.com/serving
</span></span></span><span style=display:flex><span><span style=color:#b44>  usages:
</span></span></span><span style=display:flex><span><span style=color:#b44>  - digital signature
</span></span></span><span style=display:flex><span><span style=color:#b44>  - key encipherment
</span></span></span><span style=display:flex><span><span style=color:#b44>  - server auth
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>请注意，在步骤 1 中创建的 <code>server.csr</code> 文件是 base64 编码并存储在
<code>.spec.request</code> 字段中的。你还要求提供 “digital signature（数字签名）”，
“密钥加密（key encipherment）” 和 “服务器身份验证（server auth）” 密钥用途，
由 <code>example.com/serving</code> 示例签名程序签名的证书。
你也可以要求使用特定的 <code>signerName</code>。更多信息可参阅
<a href=/zh-cn/docs/reference/access-authn-authz/certificate-signing-requests/#signers>支持的签署者名称</a>。</p><p>在 API server 中可以看到这些 CSR 处于 Pending 状态。执行下面的命令你将可以看到：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe csr my-svc.my-namespace
</span></span></code></pre></div><pre tabindex=0><code class=language-none data-lang=none>Name:                   my-svc.my-namespace
Labels:                 &lt;none&gt;
Annotations:            &lt;none&gt;
CreationTimestamp:      Tue, 01 Feb 2022 11:49:15 -0500
Requesting User:        yourname@example.com
Signer:                 example.com/serving
Status:                 Pending
Subject:
        Common Name:    my-pod.my-namespace.pod.cluster.local
        Serial Number:
Subject Alternative Names:
        DNS Names:      my-pod.my-namespace.pod.cluster.local
                        my-svc.my-namespace.svc.cluster.local
        IP Addresses:   192.0.2.24
                        10.0.34.2
Events: &lt;none&gt;
</code></pre><h2 id=get-the-certificate-signing-request-approved>批准证书签名请求（CSR）</h2><p><a href=/zh-cn/docs/reference/access-authn-authz/certificate-signing-requests/>证书签名请求</a>
的批准或者是通过自动批准过程完成的，或由集群管理员一次性完成。
如果你被授权批准证书请求，你可以使用 <code>kubectl</code> 来手动完成此操作；例如：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl certificate approve my-svc.my-namespace
</span></span></code></pre></div><pre tabindex=0><code class=language-none data-lang=none>certificatesigningrequest.certificates.k8s.io/my-svc.my-namespace approved
</code></pre><p>你现在应该能看到如下输出：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get csr
</span></span></code></pre></div><pre tabindex=0><code class=language-none data-lang=none>NAME                  AGE   SIGNERNAME            REQUESTOR              REQUESTEDDURATION   CONDITION
my-svc.my-namespace   10m   example.com/serving   yourname@example.com   &lt;none&gt;              Approved
</code></pre><p>这意味着证书请求已被批准，并正在等待请求的签名者对其签名。</p><h2 id=sign-the-certificate-signing-request>签名证书签名请求（CSR）</h2><p>接下来，你将扮演证书签署者的角色，颁发证书并将其上传到 API 服务器。</p><p>签名者通常会使用其 <code>signerName</code> 查看对象的 CertificateSigningRequest API，
检查它们是否已被批准，为这些请求签署证书，并使用已颁发的证书更新 API 对象状态。</p><h3 id=创建证书颁发机构>创建证书颁发机构</h3><p>你需要授权在新证书上提供数字签名。</p><p>首先，通过运行以下命令创建签名证书：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF | cfssl gencert -initca - | cfssljson -bare ca
</span></span></span><span style=display:flex><span><span style=color:#b44>{
</span></span></span><span style=display:flex><span><span style=color:#b44>  &#34;CN&#34;: &#34;My Example Signer&#34;,
</span></span></span><span style=display:flex><span><span style=color:#b44>  &#34;key&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#b44>    &#34;algo&#34;: &#34;rsa&#34;,
</span></span></span><span style=display:flex><span><span style=color:#b44>    &#34;size&#34;: 2048
</span></span></span><span style=display:flex><span><span style=color:#b44>  }
</span></span></span><span style=display:flex><span><span style=color:#b44>}
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>你应该看到类似于以下的输出：</p><pre tabindex=0><code class=language-none data-lang=none>2022/02/01 11:50:39 [INFO] generating a new CA key and certificate from CSR
2022/02/01 11:50:39 [INFO] generate received request
2022/02/01 11:50:39 [INFO] received CSR
2022/02/01 11:50:39 [INFO] generating key: rsa-2048
2022/02/01 11:50:39 [INFO] encoded CSR
2022/02/01 11:50:39 [INFO] signed certificate with serial number 263983151013686720899716354349605500797834580472
</code></pre><p>这会产生一个证书颁发机构密钥文件（<code>ca-key.pem</code>）和证书（<code>ca.pem</code>）。</p><h3 id=颁发证书>颁发证书</h3><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/tls/server-signing-config.json download=tls/server-signing-config.json><code>tls/server-signing-config.json</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("tls-server-signing-config-json")' title="Copy tls/server-signing-config.json to clipboard"></img></div><div class=includecode id=tls-server-signing-config-json><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;signing&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;default&#34;</span>: {
</span></span><span style=display:flex><span>            <span style=color:green;font-weight:700>&#34;usages&#34;</span>: [
</span></span><span style=display:flex><span>                <span style=color:#b44>&#34;digital signature&#34;</span>,
</span></span><span style=display:flex><span>                <span style=color:#b44>&#34;key encipherment&#34;</span>,
</span></span><span style=display:flex><span>                <span style=color:#b44>&#34;server auth&#34;</span>
</span></span><span style=display:flex><span>            ],
</span></span><span style=display:flex><span>            <span style=color:green;font-weight:700>&#34;expiry&#34;</span>: <span style=color:#b44>&#34;876000h&#34;</span>,
</span></span><span style=display:flex><span>            <span style=color:green;font-weight:700>&#34;ca_constraint&#34;</span>: {
</span></span><span style=display:flex><span>                <span style=color:green;font-weight:700>&#34;is_ca&#34;</span>: <span style=color:#a2f;font-weight:700>false</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div></div><p>使用 <code>server-signing-config.json</code> 签名配置、证书颁发机构密钥文件和证书来签署证书请求：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get csr my-svc.my-namespace -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.spec.request}&#39;</span> | <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  base64 --decode | <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  cfssl sign -ca ca.pem -ca-key ca-key.pem -config server-signing-config.json - | <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  cfssljson -bare ca-signed-server
</span></span></code></pre></div><p>你应该看到类似于以下的输出：</p><pre tabindex=0><code>2022/02/01 11:52:26 [INFO] signed certificate with serial number 576048928624926584381415936700914530534472870337
</code></pre><p>这会生成一个签名的服务证书文件，<code>ca-signed-server.pem</code>。</p><h3 id=上传签名证书>上传签名证书</h3><p>最后，在 API 对象的状态中填充签名证书：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get csr my-svc.my-namespace -o json | <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  jq <span style=color:#b44>&#39;.status.certificate = &#34;&#39;</span><span style=color:#a2f;font-weight:700>$(</span>base64 ca-signed-server.pem | tr -d <span style=color:#b44>&#39;\n&#39;</span><span style=color:#a2f;font-weight:700>)</span><span style=color:#b44>&#39;&#34;&#39;</span> | <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  kubectl replace --raw /apis/certificates.k8s.io/v1/certificatesigningrequests/my-svc.my-namespace/status -f -
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>这使用命令行工具 <a href=https://stedolan.github.io/jq/><code>jq</code></a>
在 <code>.status.certificate</code> 字段中填充 base64 编码的内容。
如果你没有 <code>jq</code> 工具，你还可以将 JSON 输出保存到文件中，手动填充此字段，然后上传结果文件。</div><p>批准 CSR 并上传签名证书后，运行：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get csr
</span></span></code></pre></div><p>输入类似于：</p><pre tabindex=0><code class=language-none data-lang=none>NAME                  AGE   SIGNERNAME            REQUESTOR              REQUESTEDDURATION   CONDITION
my-svc.my-namespace   20m   example.com/serving   yourname@example.com   &lt;none&gt;              Approved,Issued
</code></pre><h2 id=下载证书并使用它>下载证书并使用它</h2><p>现在，作为请求用户，你可以通过运行以下命令下载颁发的证书并将其保存到 <code>server.crt</code> 文件中：</p><p>CSR 被签署并获得批准后，你应该看到以下内容：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get csr my-svc.my-namespace -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.status.certificate}&#39;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    | base64 --decode &gt; server.crt
</span></span></code></pre></div><p>现在你可以将 <code>server.crt</code> 和 <code>server-key.pem</code> 填充到
<a class=glossary-tooltip title='Secret 用于存储敏感信息，如密码、 OAuth 令牌和 SSH 密钥。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/configuration/secret/ target=_blank aria-label=Secret>Secret</a> 中，
稍后你可以将其挂载到 Pod 中（例如，用于提供 HTTPS 的网络服务器）。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret tls server --cert server.crt --key server-key.pem
</span></span></code></pre></div><pre tabindex=0><code class=language-none data-lang=none>secret/server created
</code></pre><p>最后，你可以将 <code>ca.pem</code> 填充到
<a class=glossary-tooltip title='ConfigMap 是一种 API 对象，用来将非机密性的数据保存到键值对中。使用时可以用作环境变量、命令行参数或者存储卷中的配置文件。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/tasks/configure-pod-container/configure-pod-configmap/ target=_blank aria-label=ConfigMap>ConfigMap</a>
并将其用作信任根来验证服务证书：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create configmap example-serving-ca --from-file ca.crt<span style=color:#666>=</span>ca.pem
</span></span></code></pre></div><pre tabindex=0><code class=language-none data-lang=none>configmap/example-serving-ca created
</code></pre><h2 id=approving-certificate-signing-requests>批准证书签名请求（CSR）</h2><p>Kubernetes 管理员（具有适当权限）可以使用 <code>kubectl certificate approve</code> 和
<code>kubectl certificate deny</code> 命令手动批准（或拒绝）证书签名请求（CSR）。
但是，如果你打算大量使用此 API，则可以考虑编写自动化的证书控制器。</p><div class="alert alert-warning caution callout" role=alert><strong>注意：</strong><p>批准证书 CSR 的能力决定了在你的环境中谁信任谁。
不应广泛或轻率地授予批准 CSR 的能力。</p><p>在授予 <code>approve</code> 权限之前，你应该确保自己充分了解批准人的验证要求<strong>和</strong>颁发特定证书的后果。</p></div><p>无论上述机器或人使用 kubectl，“批准者”的作用是验证 CSR 满足如下两个要求：</p><ol><li>CSR 的 subject 控制用于签署 CSR 的私钥。这解决了伪装成授权主体的第三方的威胁。
在上述示例中，此步骤将验证该 Pod 控制了用于生成 CSR 的私钥。</li><li>CSR 的 subject 被授权在请求的上下文中执行。
这点用于处理不期望的主体被加入集群的威胁。
在上述示例中，此步骤将是验证该 Pod 是否被允许加入到所请求的服务中。</li></ol><p>当且仅当满足这两个要求时，审批者应该批准 CSR，否则拒绝 CSR。</p><p>有关证书批准和访问控制的更多信息，
请阅读<a href=/zh-cn/docs/reference/access-authn-authz/certificate-signing-requests/>证书签名请求</a>参考页。</p><h2 id=给集群管理员的一个建议>给集群管理员的一个建议</h2><p>本页面假设已经为 certificates API 配置了签名者。
Kubernetes 控制器管理器提供了一个签名者的默认实现。要启用它，请为控制器管理器设置
<code>--cluster-signing-cert-file</code> 和 <code>--cluster-signing-key-file</code> 参数，
使之取值为你的证书机构的密钥对的路径。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-43d5e2b1fc2a7e104e66d481d08578dc>2 - 手动轮换 CA 证书</h1><p>本页展示如何手动轮换证书机构（CA）证书。</p><h2 id=准备开始>准备开始</h2><p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li></ul>要获知版本信息，请输入 <code>kubectl version</code>.</p><ul><li>要了解 Kubernetes 中用户认证的更多信息，参阅
<a href=/zh-cn/docs/reference/access-authn-authz/authentication>认证</a>；</li><li>要了解与 CA 证书最佳实践有关的更多信息，
参阅<a href=/zh-cn/docs/setup/best-practices/certificates/#single-root-ca>单根 CA</a>。</li></ul><h2 id=rotate-the-ca-certificates-manually>手动轮换 CA 证书</h2><div class="alert alert-warning caution callout" role=alert><strong>注意：</strong><p>确保备份你的证书目录、配置文件以及其他必要文件。</p><p>这里的方法假定 Kubernetes 的控制面通过运行多个 API 服务器以高可用配置模式运行。
另一假定是 API 服务器可体面地终止，因而客户端可以彻底地与一个 API 服务器断开
连接并连接到另一个 API 服务器。</p><p>如果集群中只有一个 API 服务器，则在 API 服务器重启期间会经历服务中断期。</p></div><ol><li>将新的 CA 证书和私钥（例如：<code>ca.crt</code>、<code>ca.key</code>、<code>front-proxy-ca.crt</code> 和
<code>front-proxy-client.key</code>）分发到所有控制面节点，放在其 Kubernetes 证书目录下。</li></ol><ol start=2><li><p>更新 <a class=glossary-tooltip title=主节点上运行控制器的组件。 data-toggle=tooltip data-placement=top href=/zh-cn/docs/reference/command-line-tools-reference/kube-controller-manager/ target=_blank aria-label=kube-controller-manager>kube-controller-manager</a>
的 <code>--root-ca-file</code> 标志，使之同时包含老的和新的 CA，之后重启组件。</p><p>自此刻起，所创建的所有<a class=glossary-tooltip title='为在 Pod 中运行的进程提供标识。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/tasks/configure-pod-container/configure-service-account/ target=_blank aria-label=ServiceAccount>ServiceAccount</a>
都会获得同时包含老的 CA 和新的 CA 的 Secret。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>kube-controller-manager 标志 <code>--client-ca-file</code> 和 <code>--cluster-signing-cert-file</code>
所引用的文件不能是 CA 证书包。如果这些标志和 <code>--root-ca-file</code> 指向同一个 <code>ca.crt</code> 包文件
（包含老的和新的 CA 证书），你将会收到出错信息。
要解决这个问题，可以将新的 CA 证书复制到单独的文件中，并将 <code>--client-ca-file</code> 和
<code>--cluster-signing-cert-file</code> 标志指向该副本。一旦 <code>ca.crt</code> 不再是证书包文件，
就可以恢复有问题的标志指向 <code>ca.crt</code> 并删除该副本。</p><p>kubeadm 的 <a href=https://github.com/kubernetes/kubeadm/issues/1350>Issue 1350</a>
在跟踪一个导致 kube-controller-manager 无法接收 CA 证书包的问题。</p></div></li></ol><ol start=3><li><p>等待该控制器管理器更新服务账号 Secret 中的 <code>ca.crt</code>，使之同时包含老的和新的 CA 证书。</p><p>如果在 API 服务器使用新的 CA 之前启动了新的 Pod，这些新的 Pod
也会获得此更新并且同时信任老的和新的 CA 证书。</p></li></ol><ol start=4><li><p>重启所有使用集群内配置的 Pod（例如：kube-proxy、CoreDNS 等），以便这些 Pod
能够使用与 ServiceAccount 相关联的 Secret 中的、已更新的证书机构数据。</p><ul><li>确保 CoreDNS、kube-proxy 和其他使用集群内配置的 Pod 都正按预期方式工作。</li></ul></li><li><p>将老的和新的 CA 都追加到 <code>kube-apiserver</code> 配置的 <code>--client-ca-file</code> 和
<code>--kubelet-certificate-authority</code> 标志所指的文件。</p></li><li><p>将老的和新的 CA 都追加到 <code>kube-scheduler</code> 配置的 <code>--client-ca-file</code> 标志所指的文件。</p></li></ol><ol start=7><li><p>通过替换 <code>client-certificate-data</code> 和 <code>client-key-data</code> 中的内容，更新用户账号的证书。</p><p>有关为独立用户账号创建证书的更多信息，可参阅
<a href=/zh-cn/docs/setup/best-practices/certificates/#configure-certificates-for-user-accounts>为用户帐号配置证书</a>。</p><p>另外，还要更新 kubeconfig 文件中的 <code>certificate-authority-data</code> 节，
使之包含 Base64 编码的老的和新的证书机构数据。</p></li></ol><ol start=8><li><p>更新 <a class=glossary-tooltip title='将 Kubernetes 与第三方云提供商进行集成的控制平面组件。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/architecture/cloud-controller/ target=_blank aria-label='云控制器管理器（Cloud Controller Manager）'>云控制器管理器（Cloud Controller Manager）</a> 的 <code>--root-ca-file</code>
标志值，使之同时包含老的和新的 CA，之后重新启动 cloud-controller-manager。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>如果你的集群中不包含 cloud-controller-manager，你可以略过这一步。</div></li></ol><ol start=9><li><p>遵循下列步骤执行滚动更新</p><ol><li><p>重新启动所有其他<a href=/zh-cn/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>被聚合的 API 服务器</a>
或者 Webhook 处理程序，使之信任新的 CA 证书。</p></li><li><p>在所有节点上更新 kubelet 配置中的 <code>clientCAFile</code> 所指文件以及 kubelet.conf 中的
<code>certificate-authority-data</code> 并重启 kubelet 以同时使用老的和新的 CA 证书。</p><p>如果你的 kubelet 并未使用客户端证书轮换，则在所有节点上更新 kubelet.conf 中
<code>client-certificate-data</code> 和 <code>client-key-data</code> 以及 kubelet
客户端证书文件（通常位于 <code>/var/lib/kubelet/pki</code> 目录下）</p></li></ol><ol start=3><li>使用用新的 CA 签名的证书
（<code>apiserver.crt</code>、<code>apiserver-kubelet-client.crt</code> 和 <code>front-proxy-client.crt</code>）
来重启 API 服务器。
你可以使用现有的私钥，也可以使用新的私钥。
如果你改变了私钥，则要将更新的私钥也放到 Kubernetes 证书目录下。</li></ol><pre><code>  由于集群中的 Pod 既信任老的 CA 也信任新的 CA，Pod 中的客户端会经历短暂的连接断开状态，
</code></pre><p>之后再使用新的 CA 所签名的证书连接到新的 API 服务器。</p><pre><code>  * 重启 <a class=glossary-tooltip title='控制平面组件，负责监视新创建的、未指定运行节点的 Pod，选择节点让 Pod 在上面运行。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/reference/command-line-tools-reference/kube-scheduler/ target=_blank aria-label=kube-scheduler>kube-scheduler</a> 以使用并信任新的
 CA 证书。
</code></pre><ul><li>确保控制面组件的日志中没有 TLS 相关的错误信息。</li></ul><div class="alert alert-info note callout" role=alert><strong>说明：</strong><pre><code>  要使用 `openssl` 命令行为集群生成新的证书和私钥，可参阅
  [证书（`openssl`）](/zh-cn/docs/tasks/administer-cluster/certificates/#openssl)。
  你也可以使用[`cfssl`](/zh-cn/docs/tasks/administer-cluster/certificates/#cfssl).</code></pre></div><ol start=4><li>为 Daemonset 和 Deployment 添加注解，从而触发较安全的滚动更新，替换 Pod。</li></ol><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f;font-weight:700>for</span> namespace in <span style=color:#a2f;font-weight:700>$(</span>kubectl get namespace -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.items[*].metadata.name}&#39;</span><span style=color:#a2f;font-weight:700>)</span>; <span style=color:#a2f;font-weight:700>do</span>
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>for</span> name in <span style=color:#a2f;font-weight:700>$(</span>kubectl get deployments -n <span style=color:#b8860b>$namespace</span> -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.items[*].metadata.name}&#39;</span><span style=color:#a2f;font-weight:700>)</span>; <span style=color:#a2f;font-weight:700>do</span>
</span></span><span style=display:flex><span>        kubectl patch deployment -n <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>namespace</span><span style=color:#b68;font-weight:700>}</span> <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>name</span><span style=color:#b68;font-weight:700>}</span> -p <span style=color:#b44>&#39;{&#34;spec&#34;:{&#34;template&#34;:{&#34;metadata&#34;:{&#34;annotations&#34;:{&#34;ca-rotation&#34;: &#34;1&#34;}}}}}&#39;</span>;
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>done</span>
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>for</span> name in <span style=color:#a2f;font-weight:700>$(</span>kubectl get daemonset -n <span style=color:#b8860b>$namespace</span> -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.items[*].metadata.name}&#39;</span><span style=color:#a2f;font-weight:700>)</span>; <span style=color:#a2f;font-weight:700>do</span>
</span></span><span style=display:flex><span>        kubectl patch daemonset -n <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>namespace</span><span style=color:#b68;font-weight:700>}</span> <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>name</span><span style=color:#b68;font-weight:700>}</span> -p <span style=color:#b44>&#39;{&#34;spec&#34;:{&#34;template&#34;:{&#34;metadata&#34;:{&#34;annotations&#34;:{&#34;ca-rotation&#34;: &#34;1&#34;}}}}}&#39;</span>;
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>done</span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>done</span>
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>说明：</strong><pre><code>  要限制应用可能受到的并发干扰数量，
  可以参阅[配置 Pod 干扰预算](/zh-cn/docs/tasks/run-application/configure-pdb/)。</code></pre></div><pre><code>  取决于你在如何使用 StatefulSet，你可能需要对其执行类似的滚动替换操作。
</code></pre></li></ol><ol start=10><li><p>如果你的集群使用启动引导令牌来添加节点，则需要更新 <code>kube-public</code> 名字空间下的
ConfigMap <code>cluster-info</code>，使之包含新的 CA 证书。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#b8860b>base64_encoded_ca</span><span style=color:#666>=</span><span style=color:#b44>&#34;</span><span style=color:#a2f;font-weight:700>$(</span>base64 -w0 /etc/kubernetes/pki/ca.crt<span style=color:#a2f;font-weight:700>)</span><span style=color:#b44>&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl get cm/cluster-info --namespace kube-public -o yaml | <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>   /bin/sed <span style=color:#b44>&#34;s/\(certificate-authority-data:\).*/\1 </span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>base64_encoded_ca</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>/&#34;</span> | <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>   kubectl apply -f -
</span></span></code></pre></div></li></ol><ol start=11><li><p>验证集群的功能正常。</p><ol><li><p>检查控制面组件以及 <code>kubelet</code> 和 <code>kube-proxy</code> 的日志，确保其中没有抛出 TLS 错误，
参阅<a href=/zh-cn/docs/tasks/debug/debug-cluster/#looking-at-logs>查看日志</a>。</p></li><li><p>验证被聚合的 API 服务器的日志，以及所有使用集群内配置的 Pod 的日志。</p></li></ol></li></ol><ol start=12><li><p>完成集群功能的检查之后：</p><ol><li><p>更新所有的服务账号令牌，使之仅包含新的 CA 证书。</p><ul><li>使用集群内 kubeconfig 的 Pod 最终也需要被重启，以获得新的服务账号 Secret
数据，这样就不会有 Pod 再依赖老的集群 CA。</li></ul></li><li><p>从 kubeconfig 文件和 <code>--client-ca-file</code> 以及 <code>--root-ca-file</code> 标志所指向的文件
中去除老的 CA 数据，之后重启控制面组件。</p></li><li><p>在每个节点上，移除 <code>clientCAFile</code> 标志所指向的文件，以删除老的 CA 数据，并从
kubelet kubeconfig 文件中去掉老的 CA，重启 kubelet。
你应该用滚动更新的方式来执行这一步骤的操作。</p><p>如果你的集群允许你执行这一变更，你也可以通过替换节点而不是重新配置节点的方式来将其上线。</p></li></ol></li></ol></div><div class=td-content style=page-break-before:always><h1 id=pg-1272b18ac0c008f6ffc2c62a29fa929f>3 - 为 kubelet 配置证书轮换</h1><p>本文展示如何在 kubelet 中启用并配置证书轮换。</p><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.19 [stable]</code></div><h2 id=准备开始>准备开始</h2><ul><li>要求 Kubernetes 1.8.0 或更高的版本</li></ul><h2 id=概述>概述</h2><p>Kubelet 使用证书进行 Kubernetes API 的认证。
默认情况下，这些证书的签发期限为一年，所以不需要太频繁地进行更新。</p><p>Kubernetes 包含特性
<a href=/zh-cn/docs/reference/access-authn-authz/kubelet-tls-bootstrapping/>kubelet 证书轮换</a>，
在当前证书即将过期时，
将自动生成新的秘钥，并从 Kubernetes API 申请新的证书。 一旦新的证书可用，它将被用于与
Kubernetes API 间的连接认证。</p><h2 id=启用客户端证书轮换>启用客户端证书轮换</h2><p><code>kubelet</code> 进程接收 <code>--rotate-certificates</code> 参数，该参数决定 kubelet 在当前使用的
证书即将到期时，是否会自动申请新的证书。</p><p><code>kube-controller-manager</code> 进程接收 <code>--cluster-signing-duration</code> 参数
（在 1.19 版本之前为 <code>--experimental-cluster-signing-duration</code>），用来
控制签发证书的有效期限。</p><h2 id=理解证书轮换配置>理解证书轮换配置</h2><p>当 kubelet 启动时，如被配置为自举（使用<code>--bootstrap-kubeconfig</code> 参数），kubelet
会使用其初始证书连接到 Kubernetes API ，并发送证书签名的请求。
可以通过以下方式查看证书签名请求的状态：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get csr
</span></span></code></pre></div><p>最初，来自节点上 kubelet 的证书签名请求处于 <code>Pending</code> 状态。 如果证书签名请求满足特定条件，
控制器管理器会自动批准，此时请求会处于 <code>Approved</code> 状态。 接下来，控制器管理器会签署证书，
证书的有效期限由 <code>--cluster-signing-duration</code> 参数指定，签署的证书会被附加到证书签名请求中。</p><p>Kubelet 会从 Kubernetes API 取回签署的证书，并将其写入磁盘，存储位置通过 <code>--cert-dir</code>
参数指定。
然后 kubelet 会使用新的证书连接到 Kubernetes API。</p><p>当签署的证书即将到期时，kubelet 会使用 Kubernetes API，自动发起新的证书签名请求。
该请求会发生在证书的有效时间剩下 30% 到 10% 之间的任意时间点。
同样地，控制器管理器会自动批准证书请求，并将签署的证书附加到证书签名请求中。 Kubelet
会从 Kubernetes API 取回签署的证书，并将其写入磁盘。 然后它会更新与 Kubernetes API
的连接，使用新的证书重新连接到 Kubernetes API。</p></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/zh-cn/docs/home/>主页</a>
<a class=text-white href=/zh-cn/blog/>博客</a>
<a class=text-white href=/zh-cn/training/>培训</a>
<a class=text-white href=/zh-cn/partners/>合作伙伴</a>
<a class=text-white href=/zh-cn/community/>社区</a>
<a class=text-white href=/zh-cn/case-studies/>案例分析</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 The Kubernetes 作者 | 文档发布基于 <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a> 授权许可</small><br><small class=text-white>Copyright &copy; 2023 Linux 基金会&reg;。保留所有权利。Linux 基金会已注册并使用商标。如需了解 Linux 基金会的商标列表，请访问<a href=https://www.linuxfoundation.org/trademark-usage class=light-text>商标使用页面</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>