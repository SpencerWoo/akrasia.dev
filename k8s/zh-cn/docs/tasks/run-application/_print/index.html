<!doctype html><html lang=zh-cn class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=en href=https://kubernetes.io/docs/tasks/run-application/><link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/tasks/run-application/><link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/tasks/run-application/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/tasks/run-application/><link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/tasks/run-application/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/tasks/run-application/><link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/tasks/run-application/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/zh-cn/docs/tasks/run-application/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>运行应用 | Kubernetes</title><meta property="og:title" content="运行应用"><meta property="og:description" content="运行和管理无状态和有状态的应用程序。"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/zh-cn/docs/tasks/run-application/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="运行应用"><meta itemprop=description content="运行和管理无状态和有状态的应用程序。"><meta name=twitter:card content="summary"><meta name=twitter:title content="运行应用"><meta name=twitter:description content="运行和管理无状态和有状态的应用程序。"><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content="运行和管理无状态和有状态的应用程序。"><meta property="og:description" content="运行和管理无状态和有状态的应用程序。"><meta name=twitter:description content="运行和管理无状态和有状态的应用程序。"><meta property="og:url" content="https://kubernetes.io/zh-cn/docs/tasks/run-application/"><meta property="og:title" content="运行应用"><meta name=twitter:title content="运行应用"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/zh-cn/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/zh-cn/docs/>文档</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/zh-cn/blog/>Kubernetes 博客</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/zh-cn/training/>培训</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/zh-cn/partners/>合作伙伴</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/zh-cn/community/>社区</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/zh-cn/case-studies/>案例分析</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>版本列表</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/zh-cn/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/zh-cn/docs/tasks/run-application/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/zh-cn/docs/tasks/run-application/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/zh-cn/docs/tasks/run-application/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/zh-cn/docs/tasks/run-application/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/zh-cn/docs/tasks/run-application/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>中文 (Chinese)</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/docs/tasks/run-application/>English</a>
<a class=dropdown-item href=/ko/docs/tasks/run-application/>한국어 (Korean)</a>
<a class=dropdown-item href=/ja/docs/tasks/run-application/>日本語 (Japanese)</a>
<a class=dropdown-item href=/fr/docs/tasks/run-application/>Français (French)</a>
<a class=dropdown-item href=/de/docs/tasks/run-application/>Deutsch (German)</a>
<a class=dropdown-item href=/es/docs/tasks/run-application/>Español (Spanish)</a>
<a class=dropdown-item href=/id/docs/tasks/run-application/>Bahasa Indonesia</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>这是本节的多页打印视图。
<a href=# onclick="return print(),!1">点击此处打印</a>.</p><p><a href=/zh-cn/docs/tasks/run-application/>返回本页常规视图</a>.</p></div><h1 class=title>运行应用</h1><div class=lead>运行和管理无状态和有状态的应用程序。</div><ul><li>1: <a href=#pg-790ea02857492b3a822e981e93e3a98b>使用 Deployment 运行一个无状态应用</a></li><li>2: <a href=#pg-43398a6f5dc7ce19df59f5f4c2e7922d>运行一个单实例有状态应用</a></li><li>3: <a href=#pg-95b3d561509c573e53bec2368264cf6a>运行一个有状态的应用程序</a></li><li>4: <a href=#pg-c43537b0ee1da992ecb7488f87e6c934>删除 StatefulSet</a></li><li>5: <a href=#pg-f5f2f7a74377a9d45325c5253353fa8f>强制删除 StatefulSet 中的 Pod</a></li><li>6: <a href=#pg-0c0bb1bd76d2a9069e50e2cec6d20c2a>Pod 水平自动扩缩</a></li><li>7: <a href=#pg-8138226ce9660ac8e3e82ff86fff8ad2>HorizontalPodAutoscaler 演练</a></li><li>8: <a href=#pg-fbe2744f00d1aa4df4cdf4eea6a082d4>为应用程序设置干扰预算（Disruption Budget）</a></li><li>9: <a href=#pg-52cd10ee3fc7c74a6c31043a2d489878>从 Pod 中访问 Kubernetes API</a></li><li>10: <a href=#pg-7a9b5779e228083ba3fdeaf414fe704e>扩缩 StatefulSet</a></li></ul><div class=content></div></div><div class=td-content><h1 id=pg-790ea02857492b3a822e981e93e3a98b>1 - 使用 Deployment 运行一个无状态应用</h1><p>本文介绍如何通过 Kubernetes Deployment 对象去运行一个应用。</p><h2 id=教程目标>教程目标</h2><ul><li>创建一个 nginx Deployment。</li><li>使用 kubectl 列举该 Deployment 的相关信息。</li><li>更新该 Deployment。</li></ul><h2 id=准备开始>准备开始</h2><p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li></ul>你的 Kubernetes 服务器版本必须不低于版本 v1.9.
要获知版本信息，请输入 <code>kubectl version</code>.</p><h2 id=创建并了解一个-nginx-deployment>创建并了解一个 nginx Deployment</h2><p>你可以通过创建一个 Kubernetes Deployment 对象来运行一个应用, 且你可以在一个
YAML 文件中描述 Deployment。例如, 下面这个 YAML 文件描述了一个运行 nginx:1.14.2
Docker 镜像的 Deployment：</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/application/deployment.yaml download=application/deployment.yaml><code>application/deployment.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("application-deployment-yaml")' title="Copy application/deployment.yaml to clipboard"></img></div><div class=includecode id=application-deployment-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># 告知 Deployment 运行 2 个与该模板匹配的 Pod</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><ol><li><p>通过 YAML 文件创建一个 Deployment：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/application/deployment.yaml
</span></span></code></pre></div></li></ol><ol start=2><li><p>显示该 Deployment 的相关信息：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe deployment nginx-deployment
</span></span></code></pre></div><p>输出类似于这样：</p><pre tabindex=0><code>Name:     nginx-deployment
Namespace:    default
CreationTimestamp:  Tue, 30 Aug 2016 18:11:37 -0700
Labels:     app=nginx
Annotations:    deployment.kubernetes.io/revision=1
Selector:   app=nginx
Replicas:   2 desired | 2 updated | 2 total | 2 available | 0 unavailable
StrategyType:   RollingUpdate
MinReadySeconds:  0
RollingUpdateStrategy:  1 max unavailable, 1 max surge
Pod Template:
  Labels:       app=nginx
  Containers:
   nginx:
    Image:              nginx:1.7.9
    Port:               80/TCP
    Environment:        &lt;none&gt;
    Mounts:             &lt;none&gt;
  Volumes:              &lt;none&gt;
Conditions:
  Type          Status  Reason
  ----          ------  ------
  Available     True    MinimumReplicasAvailable
  Progressing   True    NewReplicaSetAvailable
OldReplicaSets:   &lt;none&gt;
NewReplicaSet:    nginx-deployment-1771418926 (2/2 replicas created)
No events.
</code></pre></li></ol><ol start=3><li><p>列出该 Deployment 创建的 Pod：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx
</span></span></code></pre></div><p>输出类似于这样：</p><pre tabindex=0><code>NAME                                READY     STATUS    RESTARTS   AGE
nginx-deployment-1771418926-7o5ns   1/1       Running   0          16h
nginx-deployment-1771418926-r18az   1/1       Running   0          16h
</code></pre></li></ol><ol start=4><li><p>展示某一个 Pod 信息：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe pod &lt;pod-name&gt;
</span></span></code></pre></div><p>这里的 <code>&lt;pod-name></code> 是某一 Pod 的名称。</p></li></ol><h2 id=更新-deployment>更新 Deployment</h2><p>你可以通过应用一个新的 YAML 文件来更新 Deployment。下面的 YAML 文件指定该
Deployment 镜像更新为 nginx 1.16.1。</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/application/deployment-update.yaml download=application/deployment-update.yaml><code>application/deployment-update.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("application-deployment-update-yaml")' title="Copy application/deployment-update.yaml to clipboard"></img></div><div class=includecode id=application-deployment-update-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.16.1<span style=color:#bbb> </span><span style=color:#080;font-style:italic># 将 nginx 版本从 1.14.2 更新为 1.16.1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><ol><li><p>应用新的 YAML：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/application/deployment-update.yaml
</span></span></code></pre></div></li></ol><ol start=2><li><p>查看该 Deployment 以新的名称创建 Pod 同时删除旧的 Pod：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx
</span></span></code></pre></div></li></ol><h2 id=通过增加副本数来扩缩应用>通过增加副本数来扩缩应用</h2><p>你可以通过应用新的 YAML 文件来增加 Deployment 中 Pod 的数量。
下面的 YAML 文件将 <code>replicas</code> 设置为 4，指定该 Deployment 应有 4 个 Pod：</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/application/deployment-scale.yaml download=application/deployment-scale.yaml><code>application/deployment-scale.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("application-deployment-scale-yaml")' title="Copy application/deployment-scale.yaml to clipboard"></img></div><div class=includecode id=application-deployment-scale-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>4</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># 将副本数从 2 更新为 4</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><ol><li><p>应用新的 YAML 文件：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/application/deployment-scale.yaml
</span></span></code></pre></div></li></ol><ol start=2><li><p>验证该 Deployment 有 4 个 Pod：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx
</span></span></code></pre></div><p>输出的结果类似于:</p><pre tabindex=0><code>NAME                               READY     STATUS    RESTARTS   AGE
nginx-deployment-148880595-4zdqq   1/1       Running   0          25s
nginx-deployment-148880595-6zgi1   1/1       Running   0          25s
nginx-deployment-148880595-fxcez   1/1       Running   0          2m
nginx-deployment-148880595-rwovn   1/1       Running   0          2m
</code></pre></li></ol><h2 id=删除-deployment>删除 Deployment</h2><p>基于名称删除 Deployment：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete deployment nginx-deployment
</span></span></code></pre></div><h2 id=replicationcontroller-旧的方式>ReplicationController —— 旧的方式</h2><p>创建一个多副本应用首选方法是使用 Deployment，该 Deployment 内部将轮流使用 ReplicaSet。
在 Deployment 和 ReplicaSet 被引入到 Kubernetes 之前，多副本应用通过
<a href=/zh-cn/docs/concepts/workloads/controllers/replicationcontroller/>ReplicationController</a>
来配置。</p><h2 id=接下来>接下来</h2><ul><li>进一步了解 <a href=/zh-cn/docs/concepts/workloads/controllers/deployment/>Deployment 对象</a>。</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-43398a6f5dc7ce19df59f5f4c2e7922d>2 - 运行一个单实例有状态应用</h1><p>本文介绍在 Kubernetes 中如何使用 PersistentVolume 和 Deployment 运行一个单实例有状态应用。该应用是 MySQL.</p><h2 id=教程目标>教程目标</h2><ul><li>在你的环境中创建一个引用磁盘的 PersistentVolume</li><li>创建一个 MySQL Deployment.</li><li>在集群内以一个已知的 DNS 名称将 MySQL 暴露给其他 Pod</li></ul><h2 id=准备开始>准备开始</h2><ul><li><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li></ul>要获知版本信息，请输入 <code>kubectl version</code>.</li><li><p>你需要有一个带有默认 <a href=/zh-cn/docs/concepts/storage/storage-classes/>StorageClass</a>的
<a href=/zh-cn/docs/concepts/storage/dynamic-provisioning/>动态 PersistentVolume 供应程序</a>，
或者自己<a href=/zh-cn/docs/concepts/storage/persistent-volumes/#provisioning>静态的提供 PersistentVolume</a>
来满足这里使用的 <a href=/zh-cn/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims>PersistentVolumeClaim</a>。</p></li></ul><h2 id=deploy-mysql>部署 MySQL</h2><p>你可以通过创建一个 Kubernetes Deployment 并使用 PersistentVolumeClaim 将其连接到
某已有的 PV 卷来运行一个有状态的应用。
例如，这里的 YAML 描述的是一个运行 MySQL 的 Deployment，其中引用了 PVC 申领。
文件为 /var/lib/mysql 定义了加载卷，并创建了一个 PVC 申领，寻找一个 20G 大小的卷。
该申领可以通过现有的满足需求的卷来满足，也可以通过动态供应卷的机制来满足。</p><p>注意：在配置的 YAML 文件中定义密码的做法是不安全的。具体安全解决方案请参考
<a href=/zh-cn/docs/concepts/configuration/secret/>Kubernetes Secrets</a>.</p><p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/application/mysql/mysql-deployment.yaml download=application/mysql/mysql-deployment.yaml><code>application/mysql/mysql-deployment.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("application-mysql-mysql-deployment-yaml")' title="Copy application/mysql/mysql-deployment.yaml to clipboard"></img></div><div class=includecode id=application-mysql-mysql-deployment-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>3306</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clusterIP</span>:<span style=color:#bbb> </span>None<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>strategy</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Recreate<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>mysql:5.6<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:#080;font-style:italic># 在实际中使用 secret</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MYSQL_ROOT_PASSWORD<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span>password<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>3306</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql-persistent-storage<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/lib/mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql-persistent-storage<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>persistentVolumeClaim</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>claimName</span>:<span style=color:#bbb> </span>mysql-pv-claim<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/application/mysql/mysql-pv.yaml download=application/mysql/mysql-pv.yaml><code>application/mysql/mysql-pv.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("application-mysql-mysql-pv-yaml")' title="Copy application/mysql/mysql-pv.yaml to clipboard"></img></div><div class=includecode id=application-mysql-mysql-pv-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql-pv-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>local<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>manual<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>capacity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>20Gi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/mnt/data&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql-pv-claim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>manual<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>20Gi<span style=color:#bbb>
</span></span></span></code></pre></div></div></div></p><ol><li><p>部署 YAML 文件中定义的 PV 和 PVC：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/application/mysql/mysql-pv.yaml
</span></span></code></pre></div></li><li><p>部署 YAML 文件中定义的 Deployment：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/application/mysql/mysql-deployment.yaml
</span></span></code></pre></div></li><li><p>展示 Deployment 相关信息:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe deployment mysql
</span></span></code></pre></div><p>输出类似于：</p><pre tabindex=0><code>Name:                 mysql
Namespace:            default
CreationTimestamp:    Tue, 01 Nov 2016 11:18:45 -0700
Labels:               app=mysql
Annotations:          deployment.kubernetes.io/revision=1
Selector:             app=mysql
Replicas:             1 desired | 1 updated | 1 total | 0 available | 1 unavailable
StrategyType:         Recreate
MinReadySeconds:      0
Pod Template:
  Labels:       app=mysql
  Containers:
   mysql:
    Image:      mysql:5.6
    Port:       3306/TCP
    Environment:
      MYSQL_ROOT_PASSWORD:      password
    Mounts:
      /var/lib/mysql from mysql-persistent-storage (rw)
  Volumes:
   mysql-persistent-storage:
    Type:       PersistentVolumeClaim (a reference to a PersistentVolumeClaim in the same namespace)
    ClaimName:  mysql-pv-claim
    ReadOnly:   false
    Conditions:
      Type          Status  Reason
      ----          ------  ------
      Available     False   MinimumReplicasUnavailable
      Progressing   True    ReplicaSetUpdated
      OldReplicaSets:       &lt;none&gt;
      NewReplicaSet:        mysql-63082529 (1/1 replicas created)
      Events:
        FirstSeen    LastSeen    Count    From                SubobjectPath    Type        Reason            Message
        ---------    --------    -----    ----                -------------    --------    ------            -------
        33s          33s         1        {deployment-controller }             Normal      ScalingReplicaSet Scaled up replica set mysql-63082529 to 1
</code></pre></li><li><p>列举出 Deployment 创建的 pods:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>mysql
</span></span></code></pre></div><p>输出类似于：</p><pre tabindex=0><code>NAME                   READY     STATUS    RESTARTS   AGE
mysql-63082529-2z3ki   1/1       Running   0          3m
</code></pre></li><li><p>查看 PersistentVolumeClaim：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe pvc mysql-pv-claim
</span></span></code></pre></div><p>输出类似于：</p><pre tabindex=0><code>Name:         mysql-pv-claim
Namespace:    default
StorageClass:
Status:       Bound
Volume:       mysql-pv-volume
Labels:       &lt;none&gt;
Annotations:    pv.kubernetes.io/bind-completed=yes
                pv.kubernetes.io/bound-by-controller=yes
Capacity:     20Gi
Access Modes: RWO
Events:       &lt;none&gt;
</code></pre></li></ol><h2 id=accessing-the-mysql-instance>访问 MySQL 实例</h2><p>前面 YAML 文件中创建了一个允许集群内其他 Pod 访问的数据库服务。该服务中选项
<code>clusterIP: None</code> 让服务 DNS 名称直接解析为 Pod 的 IP 地址。
当在一个服务下只有一个 Pod 并且不打算增加 Pod 的数量这是最好的.</p><p>运行 MySQL 客户端以连接到服务器:</p><pre tabindex=0><code>kubectl run -it --rm --image=mysql:5.6 --restart=Never mysql-client -- mysql -h mysql -ppassword
</code></pre><p>此命令在集群内创建一个新的 Pod 并运行 MySQL 客户端，并通过 Service 连接到服务器。
如果连接成功，你就知道有状态的 MySQL 数据库正处于运行状态。</p><pre tabindex=0><code>Waiting for pod default/mysql-client-274442439-zyp6i to be running, status is Pending, pod ready: false
If you don&#39;t see a command prompt, try pressing enter.

mysql&gt;
</code></pre><h2 id=updating>更新</h2><p>Deployment 中镜像或其他部分同往常一样可以通过 <code>kubectl apply</code> 命令更新。
以下是特定于有状态应用的一些注意事项:</p><ul><li>不要对应用进行规模扩缩。这里的设置仅适用于单实例应用。下层的 PersistentVolume
仅只能挂载到一个 Pod 上。对于集群级有状态应用，请参考
<a href=/zh-cn/docs/concepts/workloads/controllers/statefulset/>StatefulSet 文档</a>.</li><li>在 Deployment 的 YAML 文件中使用 <code>strategy:</code> <code>type: Recreate</code>。
该选项指示 Kubernetes <em>不</em> 使用滚动升级。滚动升级无法工作，因为这里一次不能
运行多个 Pod。在使用更新的配置文件创建新的 Pod 前，<code>Recreate</code> 策略将
保证先停止第一个 Pod。</li></ul><h2 id=deleting-a-deployment>删除 Deployment</h2><p>通过名称删除部署的对象:</p><pre tabindex=0><code>kubectl delete deployment,svc mysql
kubectl delete pvc mysql-pv-claim
kubectl delete pv mysql-pv-volume
</code></pre><p>如果通过手动的方式供应 PersistentVolume, 那么也需要手动删除它以释放下层资源。
如果是用动态供应方式创建的 PersistentVolume，在删除 PersistentVolumeClaim 后
PersistentVolume 将被自动删除。
一些存储服务（比如 EBS 和 PD）也会在 PersistentVolume 被删除时自动回收下层资源。</p><h2 id=接下来>接下来</h2><ul><li><p>欲进一步了解 Deployment 对象，请参考 <a href=/zh-cn/docs/concepts/workloads/controllers/deployment/>Deployment 对象</a></p></li><li><p>进一步了解<a href=/zh-cn/docs/tasks/run-application/run-stateless-application-deployment/>部署应用</a></p></li><li><p>参阅 <a href=/docs/reference/generated/kubectl/kubectl-commands/#run>kubectl run 文档</a></p></li><li><p>参阅<a href=/zh-cn/docs/concepts/storage/volumes/>卷</a>和<a href=/zh-cn/docs/concepts/storage/persistent-volumes/>持久卷</a></p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-95b3d561509c573e53bec2368264cf6a>3 - 运行一个有状态的应用程序</h1><p>本页展示如何使用 <a class=glossary-tooltip title='StatefulSet 用来管理某 Pod 集合的部署和扩缩，并为这些 Pod 提供持久存储和持久标识符。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/workloads/controllers/statefulset/ target=_blank aria-label=StatefulSet>StatefulSet</a>
控制器运行一个有状态的应用程序。此例是多副本的 MySQL 数据库。
示例应用的拓扑结构有一个主服务器和多个副本，使用异步的基于行（Row-Based）
的数据复制。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong> <strong>这不是生产环境下配置</strong>。
尤其注意，MySQL 设置都使用的是不安全的默认值，这是因为我们想把重点放在 Kubernetes
中运行有状态应用程序的一般模式上。</div><h2 id=准备开始>准备开始</h2><ul><li><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li></ul></li><li><p>你需要有一个带有默认 <a href=/zh-cn/docs/concepts/storage/storage-classes/>StorageClass</a>的
<a href=/zh-cn/docs/concepts/storage/dynamic-provisioning/>动态 PersistentVolume 供应程序</a>，
或者自己<a href=/zh-cn/docs/concepts/storage/persistent-volumes/#provisioning>静态的提供 PersistentVolume</a>
来满足这里使用的 <a href=/zh-cn/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims>PersistentVolumeClaim</a>。</p></li></ul><ul><li>本教程假定你熟悉
<a href=/zh-cn/docs/concepts/storage/persistent-volumes/>PersistentVolumes</a>
与 <a href=/zh-cn/docs/concepts/workloads/controllers/statefulset/>StatefulSet</a>,
以及其他核心概念，例如 <a href=/zh-cn/docs/concepts/workloads/pods/>Pod</a>、
<a href=/zh-cn/docs/concepts/services-networking/service/>服务</a> 与
<a href=/zh-cn/docs/tasks/configure-pod-container/configure-pod-configmap/>ConfigMap</a>.</li><li>熟悉 MySQL 会有所帮助，但是本教程旨在介绍对其他系统应该有用的常规模式。</li><li>你正在使用默认命名空间或不包含任何冲突对象的另一个命名空间。</li></ul><h2 id=教程目标>教程目标</h2><ul><li>使用 StatefulSet 部署多副本 MySQL 拓扑架构。</li><li>发送 MySQL 客户端请求</li><li>观察对宕机的抵抗力</li><li>扩缩 StatefulSet 的规模</li></ul><h2 id=deploy-mysql>部署 MySQL</h2><p>MySQL 示例部署包含一个 ConfigMap、两个 Service 与一个 StatefulSet。</p><h3 id=configmap>创建一个 ConfigMap</h3><p>使用以下的 YAML 配置文件创建 ConfigMap ：</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/application/mysql/mysql-configmap.yaml download=application/mysql/mysql-configmap.yaml><code>application/mysql/mysql-configmap.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("application-mysql-mysql-configmap-yaml")' title="Copy application/mysql/mysql-configmap.yaml to clipboard"></img></div><div class=includecode id=application-mysql-mysql-configmap-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>primary.cnf</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    # 仅在主服务器上应用此配置
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    [mysqld]
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    log-bin</span><span style=color:#bbb>    
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replica.cnf</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    # 仅在副本服务器上应用此配置
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    [mysqld]
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    super-read-only</span><span style=color:#bbb>    
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/application/mysql/mysql-configmap.yaml
</span></span></code></pre></div><p>这个 ConfigMap 提供 <code>my.cnf</code> 覆盖设置，使你可以独立控制 MySQL 主服务器和副本服务器的配置。
在这里，你希望主服务器能够将复制日志提供给副本服务器，
并且希望副本服务器拒绝任何不是通过复制进行的写操作。</p><p>ConfigMap 本身没有什么特别之处，因而也不会出现不同部分应用于不同的 Pod 的情况。
每个 Pod 都会在初始化时基于 StatefulSet 控制器提供的信息决定要查看的部分。</p><h3 id=services>创建 Service</h3><p>使用以下 YAML 配置文件创建服务：</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/application/mysql/mysql-services.yaml download=application/mysql/mysql-services.yaml><code>application/mysql/mysql-services.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("application-mysql-mysql-services-yaml")' title="Copy application/mysql/mysql-services.yaml to clipboard"></img></div><div class=includecode id=application-mysql-mysql-services-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#080;font-style:italic># 为 StatefulSet 成员提供稳定的 DNS 表项的无头服务（Headless Service）</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>3306</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clusterIP</span>:<span style=color:#bbb> </span>None<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 用于连接到任一 MySQL 实例执行读操作的客户端服务</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 对于写操作，你必须连接到主服务器：mysql-0.mysql</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql-read<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>readonly</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>3306</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/application/mysql/mysql-services.yaml
</span></span></code></pre></div><p>这个无头 Service 给 StatefulSet <a class=glossary-tooltip title='控制器通过 API 服务器监控集群的公共状态，并致力于将当前状态转变为期望的状态。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/architecture/controller/ target=_blank aria-label=控制器>控制器</a>
为集合中每个 Pod 创建的 DNS 条目提供了一个宿主。
因为无头服务名为 <code>mysql</code>，所以可以通过在同一 Kubernetes 集群和命名空间中的任何其他 Pod
内解析 <code>&lt;Pod 名称>.mysql</code> 来访问 Pod。</p><p>客户端 Service 称为 <code>mysql-read</code>，是一种常规 Service，具有其自己的集群 IP。
该集群 IP 在报告就绪的所有 MySQL Pod 之间分配连接。
可能的端点集合包括 MySQL 主节点和所有副本节点。</p><p>请注意，只有读查询才能使用负载平衡的客户端 Service。
因为只有一个 MySQL 主服务器，所以客户端应直接连接到 MySQL 主服务器 Pod
（通过其在无头 Service 中的 DNS 条目）以执行写入操作。</p><h3 id=statefulset>创建 StatefulSet</h3><p>最后，使用以下 YAML 配置文件创建 StatefulSet：</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/application/mysql/mysql-statefulset.yaml download=application/mysql/mysql-statefulset.yaml><code>application/mysql/mysql-statefulset.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("application-mysql-mysql-statefulset-yaml")' title="Copy application/mysql/mysql-statefulset.yaml to clipboard"></img></div><div class=includecode id=application-mysql-mysql-statefulset-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StatefulSet<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>serviceName</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>initContainers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>init-mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>mysql:5.7<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- bash<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:#b44>&#34;-c&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- |<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>          set -ex
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>          # 基于 Pod 序号生成 MySQL 服务器的 ID。
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>          [[ $HOSTNAME =~ -([0-9]+)$ ]] || exit 1
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>          ordinal=${BASH_REMATCH[1]}
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>          echo [mysqld] &gt; /mnt/conf.d/server-id.cnf
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>          # 添加偏移量以避免使用 server-id=0 这一保留值。
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>          echo server-id=$((100 + $ordinal)) &gt;&gt; /mnt/conf.d/server-id.cnf
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>          # 将合适的 conf.d 文件从 config-map 复制到 emptyDir。
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>          if [[ $ordinal -eq 0 ]]; then
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>            cp /mnt/config-map/primary.cnf /mnt/conf.d/
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>          else
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>            cp /mnt/config-map/replica.cnf /mnt/conf.d/
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>          fi</span><span style=color:#bbb>          
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>conf<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/mnt/conf.d<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config-map<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/mnt/config-map<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>clone-mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/google-samples/xtrabackup:1.0<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- bash<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:#b44>&#34;-c&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- |<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>          set -ex
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>          # 如果已有数据，则跳过克隆。
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>          [[ -d /var/lib/mysql/mysql ]] &amp;&amp; exit 0
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>          # 跳过主实例（序号索引 0）的克隆。
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>          [[ `hostname` =~ -([0-9]+)$ ]] || exit 1
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>          ordinal=${BASH_REMATCH[1]}
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>          [[ $ordinal -eq 0 ]] &amp;&amp; exit 0
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>          # 从原来的对等节点克隆数据。
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>          ncat --recv-only mysql-$(($ordinal-1)).mysql 3307 | xbstream -x -C /var/lib/mysql
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>          # 准备备份。
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>          xtrabackup --prepare --target-dir=/var/lib/mysql</span><span style=color:#bbb>          
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>data<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/lib/mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>subPath</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>conf<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/mysql/conf.d<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>mysql:5.7<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MYSQL_ALLOW_EMPTY_PASSWORD<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>3306</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>data<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/lib/mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>subPath</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>conf<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/mysql/conf.d<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>500m<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>1Gi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>livenessProbe</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>exec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;mysqladmin&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;ping&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>initialDelaySeconds</span>:<span style=color:#bbb> </span><span style=color:#666>30</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>timeoutSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>readinessProbe</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>exec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:#080;font-style:italic># 检查我们是否可以通过 TCP 执行查询（skip-networking 是关闭的）。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;mysql&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-h&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;127.0.0.1&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-e&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;SELECT 1&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>initialDelaySeconds</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>timeoutSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>xtrabackup<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/google-samples/xtrabackup:1.0<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>xtrabackup<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>3307</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- bash<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:#b44>&#34;-c&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- |<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>          set -ex
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>          cd /var/lib/mysql
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>          # 确定克隆数据的 binlog 位置（如果有的话）。
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>          if [[ -f xtrabackup_slave_info &amp;&amp; &#34;x$(&lt;xtrabackup_slave_info)&#34; != &#34;x&#34; ]]; then
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>            # XtraBackup 已经生成了部分的 “CHANGE MASTER TO” 查询
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>            # 因为我们从一个现有副本进行克隆。(需要删除末尾的分号!)
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>            cat xtrabackup_slave_info | sed -E &#39;s/;$//g&#39; &gt; change_master_to.sql.in
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>            # 在这里要忽略 xtrabackup_binlog_info （它是没用的）。
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>            rm -f xtrabackup_slave_info xtrabackup_binlog_info
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>          elif [[ -f xtrabackup_binlog_info ]]; then
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>            # 我们直接从主实例进行克隆。解析 binlog 位置。
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>            [[ `cat xtrabackup_binlog_info` =~ ^(.*?)[[:space:]]+(.*?)$ ]] || exit 1
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>            rm -f xtrabackup_binlog_info xtrabackup_slave_info
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>            echo &#34;CHANGE MASTER TO MASTER_LOG_FILE=&#39;${BASH_REMATCH[1]}&#39;,\
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>                  MASTER_LOG_POS=${BASH_REMATCH[2]}&#34; &gt; change_master_to.sql.in
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>          fi
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>          # 检查我们是否需要通过启动复制来完成克隆。
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>          if [[ -f change_master_to.sql.in ]]; then
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>            echo &#34;Waiting for mysqld to be ready (accepting connections)&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>            until mysql -h 127.0.0.1 -e &#34;SELECT 1&#34;; do sleep 1; done
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>            echo &#34;Initializing replication from clone position&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>            mysql -h 127.0.0.1 \
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>                  -e &#34;$(&lt;change_master_to.sql.in), \
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>                          MASTER_HOST=&#39;mysql-0.mysql&#39;, \
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>                          MASTER_USER=&#39;root&#39;, \
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>                          MASTER_PASSWORD=&#39;&#39;, \
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>                          MASTER_CONNECT_RETRY=10; \
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>                        START SLAVE;&#34; || exit 1
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>            # 如果容器重新启动，最多尝试一次。
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>            mv change_master_to.sql.in change_master_to.sql.orig
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>          fi
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>          # 当对等点请求时，启动服务器发送备份。
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>          exec ncat --listen --keep-open --send-only --max-conns=1 3307 -c \
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>            &#34;xtrabackup --backup --slave-info --stream=xbstream --host=127.0.0.1 --user=root&#34;</span><span style=color:#bbb>          
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>data<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/lib/mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>subPath</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>conf<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/mysql/conf.d<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>100m<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>100Mi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>conf<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config-map<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>configMap</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeClaimTemplates</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>data<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;ReadWriteOnce&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>10Gi<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/application/mysql/mysql-statefulset.yaml
</span></span></code></pre></div><p>你可以通过运行以下命令查看启动进度：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>mysql --watch
</span></span></code></pre></div><p>一段时间后，你应该看到所有 3 个 Pod 进入 <code>Running</code> 状态：</p><pre tabindex=0><code>NAME      READY     STATUS    RESTARTS   AGE
mysql-0   2/2       Running   0          2m
mysql-1   2/2       Running   0          1m
mysql-2   2/2       Running   0          1m
</code></pre><p>输入 <strong>Ctrl+C</strong> 结束监视操作。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>如果你看不到任何进度，确保已启用<a href=#%E5%87%86%E5%A4%87%E5%BC%80%E5%A7%8B>前提条件</a>
中提到的动态 PersistentVolume 制备程序。</div><p>此清单使用多种技术来管理作为 StatefulSet 的一部分的有状态 Pod。
下一节重点介绍其中的一些技巧，以解释 StatefulSet 创建 Pod 时发生的状况。</p><h2 id=了解有状态的-pod-初始化>了解有状态的 Pod 初始化</h2><p>StatefulSet 控制器按序数索引顺序地每次启动一个 Pod。
它一直等到每个 Pod 报告就绪才再启动下一个 Pod。</p><p>此外，控制器为每个 Pod 分配一个唯一、稳定的名称，形如 <code>&lt;statefulset 名称>-&lt;序数索引></code>，
其结果是 Pods 名为 <code>mysql-0</code>、<code>mysql-1</code> 和 <code>mysql-2</code>。</p><p>上述 StatefulSet 清单中的 Pod 模板利用这些属性来执行 MySQL 副本的有序启动。</p><h3 id=生成配置>生成配置</h3><p>在启动 Pod 规约中的任何容器之前，Pod 首先按顺序运行所有的
<a href=/zh-cn/docs/concepts/workloads/pods/init-containers/>初始化容器</a>。</p><p>第一个名为 <code>init-mysql</code> 的初始化容器根据序号索引生成特殊的 MySQL 配置文件。</p><p>该脚本通过从 Pod 名称的末尾提取索引来确定自己的序号索引，而 Pod 名称由 <code>hostname</code> 命令返回。
然后将序数（带有数字偏移量以避免保留值）保存到 MySQL <code>conf.d</code> 目录中的文件 <code>server-id.cnf</code>。
这一操作将 StatefulSet 所提供的唯一、稳定的标识转换为 MySQL 服务器 ID，
而这些 ID 也是需要唯一性、稳定性保证的。</p><p>通过将内容复制到 <code>conf.d</code> 中，<code>init-mysql</code> 容器中的脚本也可以应用 ConfigMap 中的
<code>primary.cnf</code> 或 <code>replica.cnf</code>。
由于示例部署结构由单个 MySQL 主节点和任意数量的副本节点组成，
因此脚本仅将序数 <code>0</code> 指定为主节点，而将其他所有节点指定为副本节点。</p><p>与 StatefulSet 控制器的
<a href=/zh-cn/docs/concepts/workloads/controllers/statefulset/#deployment-and-scaling-guarantees>部署顺序保证</a>
相结合，
可以确保 MySQL 主服务器在创建副本服务器之前已准备就绪，以便它们可以开始复制。</p><h3 id=克隆现有数据>克隆现有数据</h3><p>通常，当新 Pod 作为副本节点加入集合时，必须假定 MySQL 主节点可能已经有数据。
还必须假设复制日志可能不会一直追溯到时间的开始。</p><p>这些保守的假设是允许正在运行的 StatefulSet 随时间扩大和缩小而不是固定在其初始大小的关键。</p><p>第二个名为 <code>clone-mysql</code> 的初始化容器，第一次在带有空 PersistentVolume 的副本 Pod
上启动时，会在从属 Pod 上执行克隆操作。
这意味着它将从另一个运行中的 Pod 复制所有现有数据，使此其本地状态足够一致，
从而可以开始从主服务器复制。</p><p>MySQL 本身不提供执行此操作的机制，因此本示例使用了一种流行的开源工具 Percona XtraBackup。
在克隆期间，源 MySQL 服务器性能可能会受到影响。
为了最大程度地减少对 MySQL 主服务器的影响，该脚本指示每个 Pod 从序号较低的 Pod 中克隆。
可以这样做的原因是 StatefulSet 控制器始终确保在启动 Pod <code>N + 1</code> 之前 Pod <code>N</code> 已准备就绪。</p><h3 id=开始复制>开始复制</h3><p>初始化容器成功完成后，应用容器将运行。MySQL Pod 由运行实际 <code>mysqld</code> 服务的 <code>mysql</code>
容器和充当<a href=/blog/2015/06/the-distributed-system-toolkit-patterns>辅助工具</a>的
xtrabackup 容器组成。</p><p><code>xtrabackup</code> sidecar 容器查看克隆的数据文件，并确定是否有必要在副本服务器上初始化 MySQL 复制。
如果是这样，它将等待 <code>mysqld</code> 准备就绪，然后使用从 XtraBackup 克隆文件中提取的复制参数执行
<code>CHANGE MASTER TO</code> 和 <code>START SLAVE</code> 命令。</p><p>一旦副本服务器开始复制后，它会记住其 MySQL 主服务器，并且如果服务器重新启动或连接中断也会自动重新连接。
另外，因为副本服务器会以其稳定的 DNS 名称查找主服务器（<code>mysql-0.mysql</code>），
即使由于重新调度而获得新的 Pod IP，它们也会自动找到主服务器。</p><p>最后，开始复制后，<code>xtrabackup</code> 容器监听来自其他 Pod 的连接，处理其数据克隆请求。
如果 StatefulSet 扩大规模，或者下一个 Pod 失去其 PersistentVolumeClaim 并需要重新克隆，
则此服务器将无限期保持运行。</p><h2 id=发送客户端请求>发送客户端请求</h2><p>你可以通过运行带有 <code>mysql:5.7</code> 镜像的临时容器并运行 <code>mysql</code> 客户端二进制文件，
将测试查询发送到 MySQL 主服务器（主机名 <code>mysql-0.mysql</code>）。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl run mysql-client --image<span style=color:#666>=</span>mysql:5.7 -i --rm --restart<span style=color:#666>=</span>Never --<span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  mysql -h mysql-0.mysql <span style=color:#b44>&lt;&lt;EOF
</span></span></span><span style=display:flex><span><span style=color:#b44>CREATE DATABASE test;
</span></span></span><span style=display:flex><span><span style=color:#b44>CREATE TABLE test.messages (message VARCHAR(250));
</span></span></span><span style=display:flex><span><span style=color:#b44>INSERT INTO test.messages VALUES (&#39;hello&#39;);
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>使用主机名 <code>mysql-read</code> 将测试查询发送到任何报告为就绪的服务器：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl run mysql-client --image<span style=color:#666>=</span>mysql:5.7 -i -t --rm --restart<span style=color:#666>=</span>Never --<span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  mysql -h mysql-read -e <span style=color:#b44>&#34;SELECT * FROM test.messages&#34;</span>
</span></span></code></pre></div><p>你应该获得如下输出：</p><pre tabindex=0><code>Waiting for pod default/mysql-client to be running, status is Pending, pod ready: false
+---------+
| message |
+---------+
| hello   |
+---------+
pod &#34;mysql-client&#34; deleted
</code></pre><p>为了演示 <code>mysql-read</code> 服务在服务器之间分配连接，你可以在循环中运行 <code>SELECT @@server_id</code>：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl run mysql-client-loop --image<span style=color:#666>=</span>mysql:5.7 -i -t --rm --restart<span style=color:#666>=</span>Never --<span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  bash -ic <span style=color:#b44>&#34;while sleep 1; do mysql -h mysql-read -e &#39;SELECT @@server_id,NOW()&#39;; done&#34;</span>
</span></span></code></pre></div><p>你应该看到报告的 <code>@@server_id</code> 发生随机变化，因为每次尝试连接时都可能选择了不同的端点：</p><pre tabindex=0><code>+-------------+---------------------+
| @@server_id | NOW()               |
+-------------+---------------------+
|         100 | 2006-01-02 15:04:05 |
+-------------+---------------------+
+-------------+---------------------+
| @@server_id | NOW()               |
+-------------+---------------------+
|         102 | 2006-01-02 15:04:06 |
+-------------+---------------------+
+-------------+---------------------+
| @@server_id | NOW()               |
+-------------+---------------------+
|         101 | 2006-01-02 15:04:07 |
+-------------+---------------------+
</code></pre><p>要停止循环时可以按 <strong>Ctrl+C</strong> ，但是让它在另一个窗口中运行非常有用，
这样你就可以看到以下步骤的效果。</p><h2 id=simulate-pod-and-node-downtime>模拟 Pod 和 Node 失效</h2><p>为了证明从副本节点缓存而不是单个服务器读取数据的可用性提高，请在使 Pod 退出 Ready
状态时，保持上述 <code>SELECT @@server_id</code> 循环一直运行。</p><h3 id=破坏就绪态探测>破坏就绪态探测</h3><p><code>mysql</code> 容器的<a href=/zh-cn/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#define-readiness-probes>就绪态探测</a>
运行命令 <code>mysql -h 127.0.0.1 -e 'SELECT 1'</code>，以确保服务器已启动并能够执行查询。</p><p>迫使就绪态探测失败的一种方法就是中止该命令：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> mysql-2 -c mysql -- mv /usr/bin/mysql /usr/bin/mysql.off
</span></span></code></pre></div><p>此命令会进入 Pod <code>mysql-2</code> 的实际容器文件系统，重命名 <code>mysql</code> 命令，导致就绪态探测无法找到它。
几秒钟后， Pod 会报告其中一个容器未就绪。你可以通过运行以下命令进行检查：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod mysql-2
</span></span></code></pre></div><p>在 <code>READY</code> 列中查找 <code>1/2</code>：</p><pre tabindex=0><code>NAME      READY     STATUS    RESTARTS   AGE
mysql-2   1/2       Running   0          3m
</code></pre><p>此时，你应该会看到 <code>SELECT @@server_id</code> 循环继续运行，尽管它不再报告 <code>102</code>。
回想一下，<code>init-mysql</code> 脚本将 <code>server-id</code> 定义为 <code>100 + $ordinal</code>，
因此服务器 ID <code>102</code> 对应于 Pod <code>mysql-2</code>。</p><p>现在修复 Pod，几秒钟后它应该重新出现在循环输出中：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> mysql-2 -c mysql -- mv /usr/bin/mysql.off /usr/bin/mysql
</span></span></code></pre></div><h3 id=删除-pods>删除 Pods</h3><p>如果删除了 Pod，则 StatefulSet 还会重新创建 Pod，类似于 ReplicaSet 对无状态 Pod 所做的操作。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pod mysql-2
</span></span></code></pre></div><p>StatefulSet 控制器注意到不再存在 <code>mysql-2</code> Pod，于是创建一个具有相同名称并链接到相同
PersistentVolumeClaim 的新 Pod。
你应该看到服务器 ID <code>102</code> 从循环输出中消失了一段时间，然后又自行出现。</p><h3 id=drain-a-node>腾空节点</h3><p>如果你的 Kubernetes 集群具有多个节点，则可以通过发出以下
<a href=/docs/reference/generated/kubectl/kubectl-commands/#drain>drain</a>
命令来模拟节点停机（就好像节点在被升级）。</p><p>首先确定 MySQL Pod 之一在哪个节点上：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod mysql-2 -o wide
</span></span></code></pre></div><p>节点名称应显示在最后一列中：</p><pre tabindex=0><code>NAME      READY     STATUS    RESTARTS   AGE       IP            NODE
mysql-2   2/2       Running   0          15m       10.244.5.27   kubernetes-node-9l2t
</code></pre><p>接下来，通过运行以下命令腾空节点，该命令将其保护起来，以使新的 Pod 不能调度到该节点，
然后逐出所有现有的 Pod。将 <code>&lt;节点名称></code> 替换为在上一步中找到的节点名称。</p><div class="alert alert-warning caution callout" role=alert><strong>注意：</strong><p>腾空一个 Node 可能影响到在该节点上运行的其他负载和应用。
只应在测试集群上执行下列步骤</div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 关于对其他负载的影响，参见前文建议</span>
</span></span><span style=display:flex><span>kubectl drain &lt;节点名称&gt; --force --delete-local-data --ignore-daemonsets
</span></span></code></pre></div><p>现在，你可以监视 Pod 被重新调度到其他节点上：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod mysql-2 -o wide --watch
</span></span></code></pre></div><p>它看起来应该像这样：</p><pre tabindex=0><code>NAME      READY   STATUS          RESTARTS   AGE       IP            NODE
mysql-2   2/2     Terminating     0          15m       10.244.1.56   kubernetes-node-9l2t
[...]
mysql-2   0/2     Pending         0          0s        &lt;none&gt;        kubernetes-node-fjlm
mysql-2   0/2     Init:0/2        0          0s        &lt;none&gt;        kubernetes-node-fjlm
mysql-2   0/2     Init:1/2        0          20s       10.244.5.32   kubernetes-node-fjlm
mysql-2   0/2     PodInitializing 0          21s       10.244.5.32   kubernetes-node-fjlm
mysql-2   1/2     Running         0          22s       10.244.5.32   kubernetes-node-fjlm
mysql-2   2/2     Running         0          30s       10.244.5.32   kubernetes-node-fjlm
</code></pre><p>再次，你应该看到服务器 ID <code>102</code> 从 <code>SELECT @@server_id</code>
循环输出中消失一段时间，然后再次出现。</p><p>现在去掉节点保护（Uncordon），使其恢复为正常模式:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl uncordon &lt;节点名称&gt;
</span></span></code></pre></div><h2 id=扩展副本节点数量>扩展副本节点数量</h2><p>使用 MySQL 复制时，你可以通过添加副本节点来扩展读取查询的能力。
使用 StatefulSet，你可以使用单个命令执行此操作：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl scale statefulset mysql --replicas<span style=color:#666>=</span><span style=color:#666>5</span>
</span></span></code></pre></div><p>运行下面的命令，监视新的 Pod 启动：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>mysql --watch
</span></span></code></pre></div><p>一旦 Pod 启动，你应该看到服务器 IDs <code>103</code> 和 <code>104</code> 开始出现在 <code>SELECT @@server_id</code>
循环输出中。</p><p>你还可以验证这些新服务器在存在之前已添加了数据：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl run mysql-client --image<span style=color:#666>=</span>mysql:5.7 -i -t --rm --restart<span style=color:#666>=</span>Never --<span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  mysql -h mysql-3.mysql -e <span style=color:#b44>&#34;SELECT * FROM test.messages&#34;</span>
</span></span></code></pre></div><pre tabindex=0><code>Waiting for pod default/mysql-client to be running, status is Pending, pod ready: false
+---------+
| message |
+---------+
| hello   |
+---------+
pod &#34;mysql-client&#34; deleted
</code></pre><p>向下缩容操作也是很平滑的：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl scale statefulset mysql --replicas<span style=color:#666>=</span><span style=color:#666>3</span>
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>扩容操作会自动创建新的 PersistentVolumeClaim，但是缩容时不会自动删除这些 PVC。
这使你可以选择保留那些已被初始化的 PVC，以加速再次扩容，或者在删除它们之前提取数据。</div><p>你可以通过运行以下命令查看此效果：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pvc -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>mysql
</span></span></code></pre></div><p>这表明，尽管将 StatefulSet 缩小为3，所有5个 PVC 仍然存在：</p><pre tabindex=0><code>NAME           STATUS    VOLUME                                     CAPACITY   ACCESSMODES   AGE
data-mysql-0   Bound     pvc-8acbf5dc-b103-11e6-93fa-42010a800002   10Gi       RWO           20m
data-mysql-1   Bound     pvc-8ad39820-b103-11e6-93fa-42010a800002   10Gi       RWO           20m
data-mysql-2   Bound     pvc-8ad69a6d-b103-11e6-93fa-42010a800002   10Gi       RWO           20m
data-mysql-3   Bound     pvc-50043c45-b1c5-11e6-93fa-42010a800002   10Gi       RWO           2m
data-mysql-4   Bound     pvc-500a9957-b1c5-11e6-93fa-42010a800002   10Gi       RWO           2m
</code></pre><p>如果你不打算重复使用多余的 PVC，则可以删除它们：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pvc data-mysql-3
</span></span><span style=display:flex><span>kubectl delete pvc data-mysql-4
</span></span></code></pre></div><h2 id=清理现场>清理现场</h2><ol><li><p>通过在终端上按 <strong>Ctrl+C</strong> 取消 <code>SELECT @@server_id</code> 循环，或从另一个终端运行以下命令：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pod mysql-client-loop --now
</span></span></code></pre></div></li></ol><ol start=2><li><p>删除 StatefulSet。这也会开始终止 Pod。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete statefulset mysql
</span></span></code></pre></div></li></ol><ol start=3><li><p>验证 Pod 消失。他们可能需要一些时间才能完成终止。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>mysql
</span></span></code></pre></div><p>当上述命令返回如下内容时，你就知道 Pod 已终止：</p><pre tabindex=0><code>No resources found.
</code></pre></li></ol><ol start=4><li><p>删除 ConfigMap、Service 和 PersistentVolumeClaim。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete configmap,service,pvc -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>mysql
</span></span></code></pre></div></li></ol><ol start=5><li>如果你手动供应 PersistentVolume，则还需要手动删除它们，并释放下层资源。
如果你使用了动态预配器，当得知你删除 PersistentVolumeClaim 时，它将自动删除 PersistentVolume。
一些动态预配器（例如用于 EBS 和 PD 的预配器）也会在删除 PersistentVolume 时释放下层资源。</li></ol><h2 id=接下来>接下来</h2><ul><li>进一步了解<a href=/zh-cn/docs/tasks/run-application/scale-stateful-set/>为 StatefulSet 扩缩容</a>；</li><li>进一步了解<a href=/zh-cn/docs/tasks/debug/debug-application/debug-statefulset/>调试 StatefulSet</a>；</li><li>进一步了解<a href=/zh-cn/docs/tasks/run-application/delete-stateful-set/>删除 StatefulSet</a>；</li><li>进一步了解<a href=/zh-cn/docs/tasks/run-application/force-delete-stateful-set-pod/>强制删除 StatefulSet Pod</a>；</li><li>在 <a href=https://artifacthub.io/>Helm Charts 仓库</a>中查找其他有状态的应用程序示例。</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-c43537b0ee1da992ecb7488f87e6c934>4 - 删除 StatefulSet</h1><p>本任务展示如何删除 StatefulSet。</p><h2 id=准备开始>准备开始</h2><ul><li>本任务假设在你的集群上已经运行了由 StatefulSet 创建的应用。</li></ul><h2 id=deleting-a-statefulset>删除 StatefulSet</h2><p>你可以像删除 Kubernetes 中的其他资源一样删除 StatefulSet：使用 <code>kubectl delete</code> 命令，并按文件或者名字指定 StatefulSet。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete -f &lt;file.yaml&gt;
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete statefulsets &lt;statefulset 名称&gt;
</span></span></code></pre></div><p>删除 StatefulSet 之后，你可能需要单独删除关联的无头服务。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete service &lt;服务名称&gt;
</span></span></code></pre></div><p>当通过 <code>kubectl</code> 删除 StatefulSet 时，StatefulSet 会被缩容为 0。
属于该 StatefulSet 的所有 Pod 也被删除。
如果你只想删除 StatefulSet 而不删除 Pod，使用 <code>--cascade=orphan</code>。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete -f &lt;file.yaml&gt; --cascade<span style=color:#666>=</span>orphan
</span></span></code></pre></div><p>通过将 <code>--cascade=orphan</code> 传递给 <code>kubectl delete</code>，在删除 StatefulSet 对象之后，
StatefulSet 管理的 Pod 会被保留下来。如果 Pod 具有标签 <code>app.kubernetes.io/name=MyApp</code>，则可以按照
如下方式删除它们：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pods -l app.kubernetes.io/name<span style=color:#666>=</span>MyApp
</span></span></code></pre></div><h3 id=persistent-volumes>持久卷</h3><p>删除 StatefulSet 管理的 Pod 并不会删除关联的卷。这是为了确保你有机会在删除卷之前从卷中复制数据。
在 Pod 离开<a href=/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination>终止状态</a>
后删除 PVC 可能会触发删除背后的 PV 持久卷，具体取决于存储类和回收策略。
永远不要假定在 PVC 删除后仍然能够访问卷。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong> 删除 PVC 时要谨慎，因为这可能会导致数据丢失。</div><h3 id=complete-deletion-of-a-statefulset>完全删除 StatefulSet</h3><p>要删除 StatefulSet 中的所有内容，包括关联的 pods，你可以运行
一系列如下所示的命令：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#b8860b>grace</span><span style=color:#666>=</span><span style=color:#a2f;font-weight:700>$(</span>kubectl get pods &lt;stateful-set-pod&gt; --template <span style=color:#b44>&#39;{{.spec.terminationGracePeriodSeconds}}&#39;</span><span style=color:#a2f;font-weight:700>)</span>
</span></span><span style=display:flex><span>kubectl delete statefulset -l app.kubernetes.io/name<span style=color:#666>=</span>MyApp
</span></span><span style=display:flex><span>sleep <span style=color:#b8860b>$grace</span>
</span></span><span style=display:flex><span>kubectl delete pvc -l app.kubernetes.io/name<span style=color:#666>=</span>MyApp
</span></span></code></pre></div><p>在上面的例子中，Pod 的标签为 <code>app.kubernetes.io/name=MyApp</code>；适当地替换你自己的标签。</p><h3 id=强制删除-statefulset-的-pod>强制删除 StatefulSet 的 Pod</h3><p>如果你发现 StatefulSet 的某些 Pod 长时间处于 'Terminating' 或者 'Unknown' 状态，
则可能需要手动干预以强制从 API 服务器中删除这些 Pod。
这是一项有点危险的任务。详细信息请阅读
<a href=/zh-cn/docs/tasks/run-application/force-delete-stateful-set-pod/>删除 StatefulSet 类型的 Pods</a>。</p><h2 id=接下来>接下来</h2><p>进一步了解<a href=/zh-cn/docs/tasks/run-application/force-delete-stateful-set-pod/>强制删除 StatefulSet 的 Pods</a>。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-f5f2f7a74377a9d45325c5253353fa8f>5 - 强制删除 StatefulSet 中的 Pod</h1><p>本文介绍如何删除 <a class=glossary-tooltip title='StatefulSet 用来管理某 Pod 集合的部署和扩缩，并为这些 Pod 提供持久存储和持久标识符。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/workloads/controllers/statefulset/ target=_blank aria-label=StatefulSet>StatefulSet</a>
管理的 Pod，并解释这样操作时需要记住的注意事项。</p><h2 id=准备开始>准备开始</h2><ul><li>这是一项相当高级的任务，并且可能会违反 StatefulSet 固有的某些属性。</li><li>继续任务之前，请熟悉下面列举的注意事项。</li></ul><h2 id=statefulset-注意事项>StatefulSet 注意事项</h2><p>在 StatefulSet 的正常操作中，<strong>永远不</strong>需要强制删除 StatefulSet 管理的 Pod。
<a href=/zh-cn/docs/concepts/workloads/controllers/statefulset/>StatefulSet 控制器</a>负责创建、
扩缩和删除 StatefulSet 管理的 Pod。它尝试确保指定数量的从序数 0 到 N-1 的 Pod
处于活跃状态并准备就绪。StatefulSet 确保在任何时候，集群中最多只有一个具有给定标识的 Pod。
这就是所谓的由 StatefulSet 提供的<strong>最多一个（At Most One）</strong> Pod 的语义。</p><p>应谨慎进行手动强制删除操作，因为它可能会违反 StatefulSet 固有的至多一个的语义。
StatefulSets 可用于运行分布式和集群级的应用，这些应用需要稳定的网络标识和可靠的存储。
这些应用通常配置为具有固定标识固定数量的成员集合。
具有相同身份的多个成员可能是灾难性的，并且可能导致数据丢失 (例如：票选系统中的脑裂场景)。</p><h2 id=delete-pods>删除 Pod</h2><p>你可以使用下面的命令执行体面地删除 Pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pods &lt;pod&gt;
</span></span></code></pre></div><p>为了让上面操作能够体面地终止 Pod，Pod <strong>一定不能</strong>设置 <code>pod.Spec.TerminationGracePeriodSeconds</code> 为 0。
将 <code>pod.Spec.TerminationGracePeriodSeconds</code> 设置为 0 秒的做法是不安全的，强烈建议 StatefulSet 类型的
Pod 不要使用。体面删除是安全的，并且会在 kubelet 从 API 服务器中删除资源名称之前确保
<a href=/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination>体面地结束 Pod</a>。</p><p>当某个节点不可达时，不会引发自动删除 Pod。
在无法访问的节点上运行的 Pod 在
<a href=/zh-cn/docs/concepts/architecture/nodes/#condition>超时</a>
后会进入 “Terminating” 或者 “Unknown” 状态。
当用户尝试体面地删除无法访问的节点上的 Pod 时 Pod 也可能会进入这些状态。
从 API 服务器上删除处于这些状态 Pod 的仅有可行方法如下：</p><ul><li>删除 Node 对象（要么你来删除, 要么<a href=/zh-cn/docs/concepts/architecture/nodes/#node-controller>节点控制器</a>
来删除）</li><li>无响应节点上的 kubelet 开始响应，杀死 Pod 并从 API 服务器上移除 Pod 对象</li><li>用户强制删除 pod</li></ul><p>推荐使用第一种或者第二种方法。
如果确认节点已经不可用了（比如，永久断开网络、断电等），
则应删除 Node 对象。
如果节点遇到网裂问题，请尝试解决该问题或者等待其解决。
当网裂愈合时，kubelet 将完成 Pod 的删除并从 API 服务器上释放其名字。</p><p>通常，Pod 一旦不在节点上运行，或者管理员删除了节点，系统就会完成其删除动作。
你也可以通过强制删除 Pod 来绕过这一机制。</p><h3 id=force-deletion>强制删除</h3><p>强制删除<strong>不会</strong>等待来自 kubelet 对 Pod 已终止的确认消息。
无论强制删除是否成功杀死了 Pod，它都会立即从 API 服务器中释放该名字。
这将让 StatefulSet 控制器创建一个具有相同标识的替身 Pod；因而可能导致正在运行 Pod 的重复，
并且如果所述 Pod 仍然可以与 StatefulSet 的成员通信，则将违反 StatefulSet 所要保证的
最多一个的语义。</p><p>当你强制删除 StatefulSet 类型的 Pod 时，你要确保有问题的 Pod 不会再和 StatefulSet 管理的其他
Pod 通信并且可以安全地释放其名字以便创建替代 Pod。</p><p>如果要使用 kubectl 1.5 以上版本强制删除 Pod，请执行下面命令：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pods &lt;pod&gt; --grace-period<span style=color:#666>=</span><span style=color:#666>0</span> --force
</span></span></code></pre></div><p>如果你使用 kubectl 的 1.4 以下版本，则应省略 <code>--force</code> 选项：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pods &lt;pod&gt; --grace-period<span style=color:#666>=</span><span style=color:#666>0</span>
</span></span></code></pre></div><p>如果在这些命令后 Pod 仍处于 <code>Unknown</code> 状态，请使用以下命令从集群中删除 Pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl patch pod &lt;pod&gt; -p <span style=color:#b44>&#39;{&#34;metadata&#34;:{&#34;finalizers&#34;:null}}&#39;</span>
</span></span></code></pre></div><p>请始终谨慎地执行强制删除 StatefulSet 类型的 Pod，并充分了解强制删除操作所涉及的风险。</p><h2 id=接下来>接下来</h2><p>进一步了解<a href=/zh-cn/docs/tasks/debug/debug-application/debug-statefulset/>调试 StatefulSet</a>。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-0c0bb1bd76d2a9069e50e2cec6d20c2a>6 - Pod 水平自动扩缩</h1><p>在 Kubernetes 中，<strong>HorizontalPodAutoscaler</strong> 自动更新工作负载资源
（例如 <a class=glossary-tooltip title=管理集群上的多副本应用。 data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Deployment>Deployment</a> 或者
<a class=glossary-tooltip title='StatefulSet 用来管理某 Pod 集合的部署和扩缩，并为这些 Pod 提供持久存储和持久标识符。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/workloads/controllers/statefulset/ target=_blank aria-label=StatefulSet>StatefulSet</a>），
目的是自动扩缩工作负载以满足需求。</p><p>水平扩缩意味着对增加的负载的响应是部署更多的 <a class=glossary-tooltip title='Pod 表示你的集群上一组正在运行的容器。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/workloads/pods/ target=_blank aria-label=Pod>Pod</a>。
这与 “垂直（Vertical）” 扩缩不同，对于 Kubernetes，
垂直扩缩意味着将更多资源（例如：内存或 CPU）分配给已经为工作负载运行的 Pod。</p><p>如果负载减少，并且 Pod 的数量高于配置的最小值，
HorizontalPodAutoscaler 会指示工作负载资源（Deployment、StatefulSet 或其他类似资源）缩减。</p><p>水平 Pod 自动扩缩不适用于无法扩缩的对象（例如：<a class=glossary-tooltip title='确保 Pod 的副本在集群中的一组节点上运行。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/workloads/controllers/daemonset/ target=_blank aria-label=DaemonSet>DaemonSet</a>。）</p><p>HorizontalPodAutoscaler 被实现为 Kubernetes API
资源和<a class=glossary-tooltip title='控制器通过 API 服务器监控集群的公共状态，并致力于将当前状态转变为期望的状态。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/architecture/controller/ target=_blank aria-label=控制器>控制器</a>。</p><p>资源决定了控制器的行为。
在 Kubernetes <a class=glossary-tooltip title='控制平面是指容器编排层，它暴露 API 和接口来定义、部署容器和管理容器的生命周期。' data-toggle=tooltip data-placement=top href='/zh-cn/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label=控制平面>控制平面</a>内运行的水平
Pod 自动扩缩控制器会定期调整其目标（例如：Deployment）的所需规模，以匹配观察到的指标，
例如，平均 CPU 利用率、平均内存利用率或你指定的任何其他自定义指标。</p><p>使用水平 Pod 自动扩缩<a href=/zh-cn/docs/tasks/run-application/horizontal-pod-autoscale-walkthrough/>演练示例</a>。</p><h2 id=how-does-a-horizontalpodautoscaler-work>HorizontalPodAutoscaler 是如何工作的？</h2><figure class=diagram-medium><img src=/images/docs/horizontal-pod-autoscaler.svg alt="HorizontalPodAutoscaler 控制 Deployment 及其 ReplicaSet 的规模"><figcaption><p>HorizontalPodAutoscaler 控制 Deployment 及其 ReplicaSet 的规模</p></figcaption></figure><p>Kubernetes 将水平 Pod 自动扩缩实现为一个间歇运行的控制回路（它不是一个连续的过程）。间隔由
<a href=/zh-cn/docs/reference/command-line-tools-reference/kube-controller-manager/><code>kube-controller-manager</code></a>
的 <code>--horizontal-pod-autoscaler-sync-period</code> 参数设置（默认间隔为 15 秒）。</p><p>在每个时间段内，控制器管理器都会根据每个 HorizontalPodAutoscaler 定义中指定的指标查询资源利用率。
控制器管理器找到由 <code>scaleTargetRef</code> 定义的目标资源，然后根据目标资源的 <code>.spec.selector</code> 标签选择 Pod，
并从资源指标 API（针对每个 Pod 的资源指标）或自定义指标获取指标 API（适用于所有其他指标）。</p><ul><li><p>对于按 Pod 统计的资源指标（如 CPU），控制器从资源指标 API 中获取每一个
HorizontalPodAutoscaler 指定的 Pod 的度量值，如果设置了目标使用率，
控制器获取每个 Pod 中的容器<a href=/zh-cn/docs/concepts/configuration/manage-resources-containers/#requests-and-limits>资源使用</a> 情况，
并计算资源使用率。如果设置了 target 值，将直接使用原始数据（不再计算百分比）。
接下来，控制器根据平均的资源使用率或原始值计算出扩缩的比例，进而计算出目标副本数。</p><p>需要注意的是，如果 Pod 某些容器不支持资源采集，那么控制器将不会使用该 Pod 的 CPU 使用率。
下面的<a href=#algorithm-details>算法细节</a>章节将会介绍详细的算法。</p></li></ul><ul><li>如果 Pod 使用自定义指示，控制器机制与资源指标类似，区别在于自定义指标只使用原始值，而不是使用率。</li></ul><ul><li>如果 Pod 使用对象指标和外部指标（每个指标描述一个对象信息）。
这个指标将直接根据目标设定值相比较，并生成一个上面提到的扩缩比例。
在 <code>autoscaling/v2beta2</code> 版本 API 中，这个指标也可以根据 Pod 数量平分后再计算。</li></ul><p>HorizontalPodAutoscaler 的常见用途是将其配置为从<a class=glossary-tooltip title='聚合层允许你在自己的集群上安装额外的 Kubernetes 风格的 API。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/ target=_blank aria-label='聚合 API'>聚合 API</a>
（<code>metrics.k8s.io</code>、<code>custom.metrics.k8s.io</code> 或 <code>external.metrics.k8s.io</code>）获取指标。
<code>metrics.k8s.io</code> API 通常由名为 Metrics Server 的插件提供，需要单独启动。有关资源指标的更多信息，
请参阅 <a href=/zh-cn/docs/tasks/debug/debug-cluster/resource-metrics-pipeline/#metrics-server>Metrics Server</a>。</p><p>对 <a href=#support-for-metrics-apis>Metrics API 的支持</a>解释了这些不同 API 的稳定性保证和支持状态</p><p>HorizontalPodAutoscaler 控制器访问支持扩缩的相应工作负载资源（例如：Deployment 和 StatefulSet）。
这些资源每个都有一个名为 <code>scale</code> 的子资源，该接口允许你动态设置副本的数量并检查它们的每个当前状态。
有关 Kubernetes API 子资源的一般信息，
请参阅 <a href=/zh-cn/docs/reference/using-api/api-concepts/>Kubernetes API 概念</a>。</p><h3 id=algorithm-details>算法细节</h3><p>从最基本的角度来看，Pod 水平自动扩缩控制器根据当前指标和期望指标来计算扩缩比例。</p><pre tabindex=0><code>期望副本数 = ceil[当前副本数 * (当前指标 / 期望指标)]
</code></pre><p>例如，如果当前指标值为 <code>200m</code>，而期望值为 <code>100m</code>，则副本数将加倍，
因为 <code>200.0 / 100.0 == 2.0</code> 如果当前值为 <code>50m</code>，则副本数将减半，
因为 <code>50.0 / 100.0 == 0.5</code>。如果比率足够接近 1.0（在全局可配置的容差范围内，默认为 0.1），
则控制平面会跳过扩缩操作。</p><p>如果 HorizontalPodAutoscaler 指定的是 <code>targetAverageValue</code> 或 <code>targetAverageUtilization</code>，
那么将会把指定 Pod 度量值的平均值做为 <code>currentMetricValue</code>。</p><p>在检查容差并决定最终值之前，控制平面还会考虑是否缺少任何指标，
以及有多少 Pod <a href=/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#pod-conditions><code>已就绪</code></a>。</p><p>所有设置了删除时间戳的 Pod（带有删除时间戳的对象正在关闭/移除的过程中）都会被忽略，
所有失败的 Pod 都会被丢弃。</p><p>如果某个 Pod 缺失度量值，它将会被搁置，只在最终确定扩缩数量时再考虑。</p><p>当使用 CPU 指标来扩缩时，任何还未就绪（还在初始化，或者可能是不健康的）状态的 Pod <strong>或</strong>
最近的指标度量值采集于就绪状态前的 Pod，该 Pod 也会被搁置。</p><p>由于技术限制，HorizontalPodAutoscaler 控制器在确定是否保留某些 CPU 指标时无法准确确定 Pod 首次就绪的时间。
相反，如果 Pod 未准备好并在其启动后的一个可配置的短时间窗口内转换为准备好，它会认为 Pod “尚未准备好”。
该值使用 <code>--horizontal-pod-autoscaler-initial-readiness-delay</code> 标志配置，默认值为 30 秒。
一旦 Pod 准备就绪，如果它发生在自启动后较长的、可配置的时间内，它就会认为任何向准备就绪的转换都是第一个。
该值由 <code>-horizontal-pod-autoscaler-cpu-initialization-period</code> 标志配置，默认为 5 分钟。</p><p>在排除掉被搁置的 Pod 后，扩缩比例就会根据 <code>currentMetricValue/desiredMetricValue</code>
计算出来。</p><p>如果缺失某些度量值，控制平面会更保守地重新计算平均值，在需要缩小时假设这些 Pod 消耗了目标值的 100%，
在需要放大时假设这些 Pod 消耗了 0% 目标值。这可以在一定程度上抑制扩缩的幅度。</p><p>此外，如果存在任何尚未就绪的 Pod，工作负载会在不考虑遗漏指标或尚未就绪的 Pod 的情况下进行扩缩，
控制器保守地假设尚未就绪的 Pod 消耗了期望指标的 0%，从而进一步降低了扩缩的幅度。</p><p>考虑到尚未准备好的 Pod 和缺失的指标后，控制器会重新计算使用率。
如果新的比率与扩缩方向相反，或者在容差范围内，则控制器不会执行任何扩缩操作。
在其他情况下，新比率用于决定对 Pod 数量的任何更改。</p><p>注意，平均利用率的 <strong>原始</strong> 值是通过 HorizontalPodAutoscaler 状态体现的，
而不考虑尚未准备好的 Pod 或缺少的指标，即使使用新的使用率也是如此。</p><p>如果创建 HorizontalPodAutoscaler 时指定了多个指标，
那么会按照每个指标分别计算扩缩副本数，取最大值进行扩缩。
如果任何一个指标无法顺利地计算出扩缩副本数（比如，通过 API 获取指标时出错），
并且可获取的指标建议缩容，那么本次扩缩会被跳过。
这表示，如果一个或多个指标给出的 <code>desiredReplicas</code> 值大于当前值，HPA 仍然能实现扩容。</p><p>最后，在 HPA 控制器执行扩缩操作之前，会记录扩缩建议信息。
控制器会在操作时间窗口中考虑所有的建议信息，并从中选择得分最高的建议。
这个值可通过 <code>kube-controller-manager</code> 服务的启动参数
<code>--horizontal-pod-autoscaler-downscale-stabilization</code> 进行配置，
默认值为 5 分钟。
这个配置可以让系统更为平滑地进行缩容操作，从而消除短时间内指标值快速波动产生的影响。</p><h2 id=api-object>API 对象</h2><p>HorizontalPodAutoscaler 是 Kubernetes <code>autoscaling</code> API 组中的 API 资源。
当前的稳定版本可以在 <code>autoscaling/v2</code> API 版本中找到，其中包括对基于内存和自定义指标执行扩缩的支持。
在使用 <code>autoscaling/v1</code> 时，<code>autoscaling/v2</code> 中引入的新字段作为注释保留。</p><p>创建 HorizontalPodAutoscaler 对象时，需要确保所给的名称是一个合法的
<a href=/zh-cn/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNS 子域名</a>。
有关 API 对象的更多信息，请查阅
<a href=/docs/reference/generated/kubernetes-api/v1.25/#horizontalpodautoscaler-v2-autoscaling>HorizontalPodAutoscaler 对象文档</a>。</p><h2 id=flapping>工作量规模的稳定性</h2><p>在使用 HorizontalPodAutoscaler 管理一组副本的规模时，由于评估的指标的动态特性，
副本的数量可能会经常波动。这有时被称为 <strong>抖动（thrashing）</strong> 或 <strong>波动（flapping）</strong>。
它类似于控制论中的 <strong>滞后（hysteresis）</strong> 概念。</p><h2 id=autoscaling-during-rolling-update>滚动升级时扩缩</h2><p>Kubernetes 允许你在 Deployment 上执行滚动更新。在这种情况下，Deployment 为你管理下层的 ReplicaSet。
当你为一个 Deployment 配置自动扩缩时，你要为每个 Deployment 绑定一个 HorizontalPodAutoscaler。
HorizontalPodAutoscaler 管理 Deployment 的 <code>replicas</code> 字段。
Deployment Controller 负责设置下层 ReplicaSet 的 <code>replicas</code> 字段，
以便确保在上线及后续过程副本个数合适。</p><p>如果你对一个副本个数被自动扩缩的 StatefulSet 执行滚动更新，该 StatefulSet
会直接管理它的 Pod 集合 （不存在类似 ReplicaSet 这样的中间资源）。</p><h2 id=support-for-resource-metrics>对资源指标的支持</h2><p>HPA 的任何目标资源都可以基于其中的 Pods 的资源用量来实现扩缩。
在定义 Pod 规约时，类似 <code>cpu</code> 和 <code>memory</code> 这类资源请求必须被设定。
这些设定值被用来确定资源利用量并被 HPA 控制器用来对目标资源完成扩缩操作。
要使用基于资源利用率的扩缩，可以像下面这样指定一个指标源：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Resource<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>resource</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cpu<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>target</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Utilization<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>averageUtilization</span>:<span style=color:#bbb> </span><span style=color:#666>60</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>基于这一指标设定，HPA 控制器会维持扩缩目标中的 Pods 的平均资源利用率在 60%。
利用率是 Pod 的当前资源用量与其请求值之间的比值。
关于如何计算利用率以及如何计算平均值的细节可参考<a href=#algorithm-details>算法</a>小节。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>由于所有的容器的资源用量都会被累加起来，Pod 的总体资源用量值可能不会精确体现各个容器的资源用量。
这一现象也会导致一些问题，例如某个容器运行时的资源用量非常高，但因为 Pod
层面的资源用量总值让人在可接受的约束范围内，HPA 不会执行扩大目标对象规模的操作。</div><h3 id=container-resource-metrics>容器资源指标</h3><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.20 [alpha]</code></div><p>HorizontalPodAutoscaler API 也支持容器指标源，这时 HPA 可以跟踪记录一组 Pod
中各个容器的资源用量，进而触发扩缩目标对象的操作。
容器资源指标的支持使得你可以为特定 Pod 中最重要的容器配置规模扩缩阈值。
例如，如果你有一个 Web 应用和一个执行日志操作的边车容器，你可以基于 Web
应用的资源用量来执行扩缩，忽略边车容器的存在及其资源用量。</p><p>如果你更改扩缩目标对象，令其使用新的、包含一组不同的容器的 Pod 规约，你就需要修改
HPA 的规约才能基于新添加的容器来执行规模扩缩操作。
如果指标源中指定的容器不存在或者仅存在于部分 Pod 中，那么这些 Pod 会被忽略，
HPA 会重新计算资源用量值。参阅<a href=#algorithm-details>算法</a>小节进一步了解计算细节。
要使用容器资源用量来完成自动扩缩，可以像下面这样定义指标源：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>ContainerResource<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>containerResource</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cpu<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>container</span>:<span style=color:#bbb> </span>application<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>target</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Utilization<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>averageUtilization</span>:<span style=color:#bbb> </span><span style=color:#666>60</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>在上面的例子中，HPA 控制器会对目标对象执行扩缩操作以确保所有 Pod 中
<code>application</code> 容器的平均 CPU 用量为 60%。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>如果你要更改 HorizontalPodAutoscaler 所跟踪记录的容器的名称，你可以按一定顺序来执行这一更改，
确保在应用更改的过程中用来判定扩缩行为的容器可用。
在更新定义容器的资源（如 Deployment）之前，你需要更新相关的 HPA，
使之能够同时跟踪记录新的和老的容器名称。这样，HPA 就能够在整个更新过程中继续计算并提供扩缩操作建议。</p><p>一旦你已经将容器名称变更这一操作应用到整个负载对象至上，就可以从 HPA
的规约中去掉老的容器名称，完成清理操作。</p></div><h2 id=scaling-on-custom-metrics>扩展自定义指标</h2><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.23 [stable]</code></div><p>（之前的 <code>autoscaling/v2beta2</code> API 版本将此功能作为 beta 功能提供）</p><p>如果你使用 <code>autoscaling/v2</code> API 版本，则可以将 HorizontalPodAutoscaler
配置为基于自定义指标（未内置于 Kubernetes 或任何 Kubernetes 组件）进行扩缩。
HorizontalPodAutoscaler 控制器能够从 Kubernetes API 查询这些自定义指标。</p><p>有关要求，请参阅对 <a href=#support-for-metrics-apis>Metrics APIs 的支持</a>。</p><h2 id=scaling-on-multiple-metrics>基于多个指标来执行扩缩</h2><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.23 [stable]</code></div><p>（之前的 <code>autoscaling/v2beta2</code> API 版本将此功能作为 beta 功能提供）</p><p>如果你使用 <code>autoscaling/v2</code> API 版本，你可以为 HorizontalPodAutoscaler 指定多个指标以进行扩缩。
HorizontalPodAutoscaler 控制器评估每个指标，并根据该指标提出一个新的比例。
HorizontalPodAutoscaler 采用为每个指标推荐的最大比例，
并将工作负载设置为该大小（前提是这不大于你配置的总体最大值）。</p><h2 id=support-for-metrics-apis>对 Metrics API 的支持</h2><p>默认情况下，HorizontalPodAutoscaler 控制器会从一系列的 API 中检索度量值。
集群管理员需要确保下述条件，以保证 HPA 控制器能够访问这些 API：</p><ul><li><p>启用了 <a href=/zh-cn/docs/tasks/extend-kubernetes/configure-aggregation-layer/>API 聚合层</a></p></li><li><p>相应的 API 已注册：</p><ul><li><p>对于资源指标，将使用 <code>metrics.k8s.io</code> API，一般由 <a href=https://github.com/kubernetes-incubator/metrics-server>metrics-server</a> 提供。
它可以作为集群插件启动。</p></li><li><p>对于自定义指标，将使用 <code>custom.metrics.k8s.io</code> API。
它由其他度量指标方案厂商的“适配器（Adapter）” API 服务器提供。
检查你的指标管道以查看是否有可用的 Kubernetes 指标适配器。</p></li><li><p>对于外部指标，将使用 <code>external.metrics.k8s.io</code> API。可能由上面的自定义指标适配器提供。</p></li></ul></li></ul><p>关于指标来源以及其区别的更多信息，请参阅相关的设计文档，
<a href=https://github.com/kubernetes/design-proposals-archive/blob/main/autoscaling/hpa-v2.md>HPA V2</a>，
<a href=https://github.com/kubernetes/design-proposals-archive/blob/main/instrumentation/custom-metrics-api.md>custom.metrics.k8s.io</a> 和
<a href=https://github.com/kubernetes/design-proposals-archive/blob/main/instrumentation/external-metrics-api.md>external.metrics.k8s.io</a>。</p><p>关于如何使用它们的示例，
请参考<a href=/zh-cn/docs/tasks/run-application/horizontal-pod-autoscale-walkthrough/#autoscaling-on-multiple-metrics-and-custom-metrics>使用自定义指标的教程</a>
和<a href=/zh-cn/docs/tasks/run-application/horizontal-pod-autoscale-walkthrough/#autoscaling-on-metrics-not-related-to-kubernetes-objects>使用外部指标的教程</a>。</p><h2 id=configurable-scaling-behavior>可配置的扩缩行为</h2><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.23 [stable]</code></div><p>（之前的 <code>autoscaling/v2beta2</code> API 版本将此功能作为 beta 功能提供）</p><p>如果你使用 <code>v2</code> HorizontalPodAutoscaler API，你可以使用 <code>behavior</code> 字段
（请参阅 <a href=/zh-cn/docs/reference/kubernetes-api/workload-resources/horizontal-pod-autoscaler-v2/#HorizontalPodAutoscalerSpec>API 参考</a>）
来配置单独的放大和缩小行为。你可以通过在行为字段下设置 <code>scaleUp</code> 和/或 <code>scaleDown</code> 来指定这些行为。</p><p>你可以指定一个 “稳定窗口”，以防止扩缩目标的副本计数发生<a href=#flapping>波动</a>。
扩缩策略还允许你在扩缩时控制副本的变化率。</p><h3 id=scaling-policies>扩缩策略</h3><p>可以在规约的 <code>behavior</code> 部分中指定一个或多个扩缩策略。当指定多个策略时，
允许最大更改量的策略是默认选择的策略。以下示例显示了缩小时的这种行为：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>behavior</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scaleDown</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>policies</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Pods<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#666>4</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>60</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Percent<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>60</span><span style=color:#bbb>
</span></span></span></code></pre></div><p><code>periodSeconds</code> 表示在过去的多长时间内要求策略值为真。
第一个策略（Pods）允许在一分钟内最多缩容 4 个副本。第二个策略（Percent）
允许在一分钟内最多缩容当前副本个数的百分之十。</p><p>由于默认情况下会选择容许更大程度作出变更的策略，只有 Pod 副本数大于 40 时，
第二个策略才会被采用。如果副本数为 40 或者更少，则应用第一个策略。
例如，如果有 80 个副本，并且目标必须缩小到 10 个副本，那么在第一步中将减少 8 个副本。
在下一轮迭代中，当副本的数量为 72 时，10% 的 Pod 数为 7.2，但是这个数字向上取整为 8。
在 autoscaler 控制器的每个循环中，将根据当前副本的数量重新计算要更改的 Pod 数量。
当副本数量低于 40 时，应用第一个策略（Pods），一次减少 4 个副本。</p><p>可以指定扩缩方向的 <code>selectPolicy</code> 字段来更改策略选择。
通过设置 <code>Min</code> 的值，它将选择副本数变化最小的策略。
将该值设置为 <code>Disabled</code> 将完全禁用该方向的扩缩。</p><h3 id=stabilization-window>稳定窗口</h3><p>当用于扩缩的指标不断波动时，稳定窗口用于限制副本计数的<a href=#flapping>波动</a>。
自动扩缩算法使用此窗口来推断先前的期望状态并避免对工作负载规模进行不必要的更改。</p><p>例如，在以下示例代码段中，为 <code>scaleDown</code> 指定了稳定窗口。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>behavior</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scaleDown</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>stabilizationWindowSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>300</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>当指标显示目标应该缩容时，自动扩缩算法查看之前计算的期望状态，并使用指定时间间隔内的最大值。
在上面的例子中，过去 5 分钟的所有期望状态都会被考虑。</p><p>这近似于滚动最大值，并避免了扩缩算法频繁删除 Pod 而又触发重新创建等效 Pod。</p><h3 id=default-behavior>默认行为</h3><p>要使用自定义扩缩，不必指定所有字段。
只有需要自定义的字段才需要指定。
这些自定义值与默认值合并。
默认值与 HPA 算法中的现有行为匹配。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>behavior</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scaleDown</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>stabilizationWindowSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>300</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>policies</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Percent<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#666>100</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>15</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scaleUp</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>stabilizationWindowSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>0</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>policies</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Percent<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#666>100</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>15</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Pods<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#666>4</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>15</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>selectPolicy</span>:<span style=color:#bbb> </span>Max<span style=color:#bbb>
</span></span></span></code></pre></div><p>用于缩小稳定窗口的时间为 <strong>300</strong> 秒（或是 <code>--horizontal-pod-autoscaler-downscale-stabilization</code>
参数设定值）。
只有一种缩容的策略，允许 100% 删除当前运行的副本，这意味着扩缩目标可以缩小到允许的最小副本数。
对于扩容，没有稳定窗口。当指标显示目标应该扩容时，目标会立即扩容。
这里有两种策略，每 15 秒添加 4 个 Pod 或 100% 当前运行的副本数，直到 HPA 达到稳定状态。</p><h3 id=example-change-downscale-stabilization-window>示例：更改缩容稳定窗口</h3><p>将下面的 behavior 配置添加到 HPA 中，可提供一个 1 分钟的自定义缩容稳定窗口：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>behavior</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scaleDown</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>stabilizationWindowSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>60</span><span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=example-limit-scale-down-rate>示例：限制缩容速率</h3><p>将下面的 behavior 配置添加到 HPA 中，可限制 Pod 被 HPA 删除速率为每分钟 10%：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>behavior</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scaleDown</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>policies</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Percent<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>60</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>为了确保每分钟删除的 Pod 数不超过 5 个，可以添加第二个缩容策略，大小固定为 5，并将 <code>selectPolicy</code> 设置为最小值。
将 <code>selectPolicy</code> 设置为 <code>Min</code> 意味着 autoscaler 会选择影响 Pod 数量最小的策略:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>behavior</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scaleDown</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>policies</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Percent<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>60</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Pods<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>60</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>selectPolicy</span>:<span style=color:#bbb> </span>Min<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=example-disable-scale-down>示例：禁用缩容</h3><p><code>selectPolicy</code> 的值 <code>Disabled</code> 会关闭对给定方向的缩容。
因此使用以下策略，将会阻止缩容：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>behavior</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scaleDown</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>selectPolicy</span>:<span style=color:#bbb> </span>Disabled<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=support-for-horizontalpodautoscaler-in-kubectl>kubectl 对 HorizontalPodAutoscaler 的支持</h2><p>与每个 API 资源一样，HorizontalPodAutoscaler 都被 <code>kubectl</code> 以标准方式支持。
你可以使用 <code>kubectl create</code> 命令创建一个新的自动扩缩器。
你可以通过 <code>kubectl get hpa</code> 列出自动扩缩器或通过 <code>kubectl describe hpa</code> 获取详细描述。
最后，你可以使用 <code>kubectl delete hpa</code> 删除自动扩缩器。</p><p>此外，还有一个特殊的 <code>kubectl autoscale</code> 命令用于创建 HorizontalPodAutoscaler 对象。
例如，执行 <code>kubectl autoscale rs foo --min=2 --max=5 --cpu-percent=80</code>
将为 ReplicaSet <strong>foo</strong> 创建一个自动扩缩器，目标 CPU 利用率设置为 <code>80%</code>，副本数在 2 到 5 之间。</p><h2 id=implicit-maintenance-mode-deactivation>隐式维护状态禁用</h2><p>你可以在不必更改 HPA 配置的情况下隐式地为某个目标禁用 HPA。
如果此目标的期望副本个数被设置为 0，而 HPA 的最小副本个数大于 0，
则 HPA 会停止调整目标（并将其自身的 <code>ScalingActive</code> 状况设置为 <code>false</code>），
直到你通过手动调整目标的期望副本个数或 HPA 的最小副本个数来重新激活。</p><h3 id=migrating-deployments-and-statefulsets-to-horizontal-autoscaling>将 Deployment 和 StatefulSet 迁移到水平自动扩缩</h3><p>当启用 HPA 时，建议从它们的<a class=glossary-tooltip title='一个或多个 Kubernetes API 对象的序列化规范。' data-toggle=tooltip data-placement=top href='/zh-cn/docs/reference/glossary/?all=true#term-manifest' target=_blank aria-label=清单>清单</a>中删除
Deployment 和/或 StatefulSet 的 <code>spec.replicas</code> 的值。
如果不这样做，则只要应用对该对象的更改，例如通过 <code>kubectl apply -f deployment.yaml</code>，
这将指示 Kubernetes 将当前 Pod 数量扩缩到 <code>spec.replicas</code> 键的值。这可能不是所希望的，
并且当 HPA 处于活动状态时可能会很麻烦。</p><p>请记住，删除 <code>spec.replicas</code> 可能会导致 Pod 计数一次性降级，因为此键的默认值为 1
（参考 <a href=/zh-cn/docs/concepts/workloads/controllers/deployment#replicas>Deployment Replicas</a>）。
更新后，除 1 之外的所有 Pod 都将开始其终止程序。之后的任何部署应用程序都将正常运行，
并根据需要遵守滚动更新配置。你可以根据修改部署的方式选择以下两种方法之一来避免这种降级：</p><ul class="nav nav-tabs" id=fix-replicas-instructions role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#fix-replicas-instructions-0 role=tab aria-controls=fix-replicas-instructions-0 aria-selected=true>客户端 apply 操作（默认行为）</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#fix-replicas-instructions-1 role=tab aria-controls=fix-replicas-instructions-1>服务器端 apply 操作</a></li></ul><div class=tab-content id=fix-replicas-instructions><div id=fix-replicas-instructions-0 class="tab-pane show active" role=tabpanel aria-labelledby=fix-replicas-instructions-0><p><ol><li><code>kubectl apply edit-last-applied deployment/&lt;Deployment 名称></code></li><li>在编辑器中，删除 <code>spec.replicas</code>。当你保存并退出编辑器时，<code>kubectl</code> 会应用更新。
在此步骤中不会更改 Pod 计数。</li><li>你现在可以从清单中删除 <code>spec.replicas</code>。如果你使用源代码管理，
还应提交你的更改或采取任何其他步骤来修改源代码，以适应你如何跟踪更新。</li><li>从这里开始，你可以运行 <code>kubectl apply -f deployment.yaml</code></li></ol></div><div id=fix-replicas-instructions-1 class=tab-pane role=tabpanel aria-labelledby=fix-replicas-instructions-1><p><p>使用<a href=/zh-cn/docs/reference/using-api/server-side-apply/>服务器端 Apply</a> 机制，
你可以遵循<a href=/zh-cn/docs/reference/using-api/server-side-apply/#transferring-ownership>交出所有权</a>说明，
该指南涵盖了这个确切的用例。</p></div></div><h2 id=接下来>接下来</h2><p>如果你在集群中配置自动扩缩，你可能还需要考虑运行集群级别的自动扩缩器，
例如 <a href=https://github.com/kubernetes/autoscaler/tree/master/cluster-autoscaler>Cluster Autoscaler</a>。</p><p>有关 HorizontalPodAutoscaler 的更多信息：</p><ul><li>阅读水平 Pod 自动扩缩的<a href=/zh-cn/docs/tasks/run-application/horizontal-pod-autoscale-walkthrough/>演练示例</a>。</li><li>阅读 <a href=/docs/reference/generated/kubectl/kubectl-commands/#autoscale><code>kubectl autoscale</code></a> 的文档。</li><li>如果你想编写自己的自定义指标适配器，
请查看 <a href=https://github.com/kubernetes-sigs/custom-metrics-apiserver>boilerplate</a> 以开始使用。</li><li>阅读 <a href=/zh-cn/docs/reference/kubernetes-api/workload-resources/horizontal-pod-autoscaler-v2/>API 参考</a>。</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-8138226ce9660ac8e3e82ff86fff8ad2>7 - HorizontalPodAutoscaler 演练</h1><p><a href=/zh-cn/docs/tasks/run-application/horizontal-pod-autoscale/>HorizontalPodAutoscaler</a>（简称 HPA ）
自动更新工作负载资源（例如 <a class=glossary-tooltip title=管理集群上的多副本应用。 data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Deployment>Deployment</a> 或者
<a class=glossary-tooltip title='StatefulSet 用来管理某 Pod 集合的部署和扩缩，并为这些 Pod 提供持久存储和持久标识符。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/workloads/controllers/statefulset/ target=_blank aria-label=StatefulSet>StatefulSet</a>），
目的是自动扩缩工作负载以满足需求。</p><p>水平扩缩意味着对增加的负载的响应是部署更多的 <a class=glossary-tooltip title='Pod 表示你的集群上一组正在运行的容器。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/workloads/pods/ target=_blank aria-label=Pod>Pod</a>。
这与 “垂直（Vertical）” 扩缩不同，对于 Kubernetes，
垂直扩缩意味着将更多资源（例如：内存或 CPU）分配给已经为工作负载运行的 Pod。</p><p>如果负载减少，并且 Pod 的数量高于配置的最小值，
HorizontalPodAutoscaler 会指示工作负载资源（Deployment、StatefulSet 或其他类似资源）缩减。</p><p>本文档将引导你完成启用 HorizontalPodAutoscaler 以自动管理示例 Web 应用程序的扩缩的示例。
此示例工作负载是运行一些 PHP 代码的 Apache httpd。</p><h2 id=准备开始>准备开始</h2><p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li></ul>你的 Kubernetes 服务器版本必须不低于版本 1.23.
要获知版本信息，请输入 <code>kubectl version</code>.</p><p>如果你运行的是旧版本的 Kubernetes，请参阅该版本的文档版本
（<a href=/zh-cn/docs/home/supported-doc-versions/>可用的文档版本</a>）。</p><p>按照本演练进行操作，你需要一个部署并配置了
<a href=https://github.com/kubernetes-sigs/metrics-server#readme>Metrics Server</a> 的集群。
Kubernetes Metrics Server 从集群中的 <a class=glossary-tooltip title='一个在集群中每个节点上运行的代理。它保证容器都运行在 Pod 中。' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelets>kubelets</a> 收集资源指标，
并通过 <a href=/zh-cn/docs/concepts/overview/kubernetes-api/>Kubernetes API</a> 公开这些指标，
使用 <a href=/zh-cn/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>APIService</a> 添加代表指标读数的新资源。</p><p>要了解如何部署 Metrics Server，请参阅
<a href=https://github.com/kubernetes-sigs/metrics-server#deployment>metrics-server 文档</a>。</p><h2 id=run-and-expose-php-apache-server>运行 php-apache 服务器并暴露服务</h2><p>为了演示 HorizontalPodAutoscaler，你将首先启动一个 Deployment 用 <code>hpa-example</code> 镜像运行一个容器，
然后使用以下清单文件将其暴露为一个 <a class=glossary-tooltip title='将运行在一组 Pods 上的应用程序公开为网络服务的抽象方法。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/services-networking/service/ target=_blank aria-label=服务（Service）>服务（Service）</a>：</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/application/php-apache.yaml download=application/php-apache.yaml><code>application/php-apache.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("application-php-apache-yaml")' title="Copy application/php-apache.yaml to clipboard"></img></div><div class=includecode id=application-php-apache-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>php-apache<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>php-apache<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>php-apache<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>php-apache<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>registry.k8s.io/hpa-example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>500m<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>200m<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>php-apache<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>php-apache<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>php-apache<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>为此，运行下面的命令：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/application/php-apache.yaml
</span></span></code></pre></div><pre tabindex=0><code>deployment.apps/php-apache created
service/php-apache created
</code></pre><h2 id=create-horizontal-pod-autoscaler>创建 HorizontalPodAutoscaler</h2><p>现在服务器正在运行，使用 <code>kubectl</code> 创建自动扩缩器。
<a href=/docs/reference/generated/kubectl/kubectl-commands#autoscale><code>kubectl autoscale</code></a> 子命令是 <code>kubectl</code> 的一部分，
可以帮助你执行此操作。</p><p>你将很快运行一个创建 HorizontalPodAutoscaler 的命令，
该 HorizontalPodAutoscaler 维护由你在这些说明的第一步中创建的 php-apache Deployment 控制的 Pod 存在 1 到 10 个副本。</p><p>粗略地说，HPA <a class=glossary-tooltip title='控制器通过 API 服务器监控集群的公共状态，并致力于将当前状态转变为期望的状态。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/architecture/controller/ target=_blank aria-label=控制器>控制器</a>将增加和减少副本的数量
（通过更新 Deployment）以保持所有 Pod 的平均 CPU 利用率为 50%。
Deployment 然后更新 ReplicaSet —— 这是所有 Deployment 在 Kubernetes 中工作方式的一部分 ——
然后 ReplicaSet 根据其 <code>.spec</code> 的更改添加或删除 Pod。</p><p>由于每个 Pod 通过 <code>kubectl run</code> 请求 200 milli-cores，这意味着平均 CPU 使用率为 100 milli-cores。
有关算法的更多详细信息，
请参阅<a href=/zh-cn/docs/tasks/run-application/horizontal-pod-autoscale/#algorithm-details>算法详细信息</a>。</p><p>创建 HorizontalPodAutoscaler：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl autoscale deployment php-apache --cpu-percent<span style=color:#666>=</span><span style=color:#666>50</span> --min<span style=color:#666>=</span><span style=color:#666>1</span> --max<span style=color:#666>=</span><span style=color:#666>10</span>
</span></span></code></pre></div><pre tabindex=0><code>horizontalpodautoscaler.autoscaling/php-apache autoscaled
</code></pre><p>你可以通过运行以下命令检查新制作的 HorizontalPodAutoscaler 的当前状态：</p><!--# You can use "hpa" or "horizontalpodautoscaler"; either name works OK. --><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 你可以使用 “hpa” 或 “horizontalpodautoscaler”；任何一个名字都可以。</span>
</span></span><span style=display:flex><span>kubectl get hpa
</span></span></code></pre></div><p>输出类似于：</p><pre tabindex=0><code>NAME         REFERENCE                     TARGET    MINPODS   MAXPODS   REPLICAS   AGE
php-apache   Deployment/php-apache/scale   0% / 50%  1         10        1          18s
</code></pre><p>（如果你看到其他具有不同名称的 HorizontalPodAutoscalers，这意味着它们已经存在，这通常不是问题）。</p><p>请注意当前的 CPU 利用率是 0%，这是由于我们尚未发送任何请求到服务器
（<code>TARGET</code> 列显示了相应 Deployment 所控制的所有 Pod 的平均 CPU 利用率）。</p><h2 id=increase-load>增加负载</h2><p>接下来，看看自动扩缩器如何对增加的负载做出反应。
为此，你将启动一个不同的 Pod 作为客户端。
客户端 Pod 中的容器在无限循环中运行，向 php-apache 服务发送查询。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 在单独的终端中运行它</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 以便负载生成继续，你可以继续执行其余步骤</span>
</span></span><span style=display:flex><span>kubectl run -i --tty load-generator --rm --image<span style=color:#666>=</span>busybox:1.28 --restart<span style=color:#666>=</span>Never -- /bin/sh -c <span style=color:#b44>&#34;while sleep 0.01; do wget -q -O- http://php-apache; done&#34;</span>
</span></span></code></pre></div><p>现在执行：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 准备好后按 Ctrl+C 结束观察</span>
</span></span><span style=display:flex><span>kubectl get hpa php-apache --watch
</span></span></code></pre></div><p>一分钟时间左右之后，通过以下命令，我们可以看到 CPU 负载升高了；例如：</p><pre tabindex=0><code>NAME         REFERENCE                     TARGET      MINPODS   MAXPODS   REPLICAS   AGE
php-apache   Deployment/php-apache/scale   305% / 50%  1         10        1          3m
</code></pre><p>然后，更多的副本被创建。例如：</p><pre tabindex=0><code>NAME         REFERENCE                     TARGET      MINPODS   MAXPODS   REPLICAS   AGE
php-apache   Deployment/php-apache/scale   305% / 50%  1         10        7          3m
</code></pre><p>这时，由于请求增多，CPU 利用率已经升至请求值的 305%。
可以看到，Deployment 的副本数量已经增长到了 7：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get deployment php-apache
</span></span></code></pre></div><p>你应该会看到与 HorizontalPodAutoscaler 中的数字与副本数匹配</p><pre tabindex=0><code>NAME         READY   UP-TO-DATE   AVAILABLE   AGE
php-apache   7/7      7           7           19m
</code></pre><div class="alert alert-info note callout" role=alert><strong>说明：</strong> 有时最终副本的数量可能需要几分钟才能稳定下来。由于环境的差异，
不同环境中最终的副本数量可能与本示例中的数量不同。</div><h2 id=stop-load>停止产生负载</h2><p>要完成该示例，请停止发送负载。</p><p>在我们创建 <code>busybox</code> 容器的终端中，输入 <code>&lt;Ctrl> + C</code> 来终止负载的产生。</p><p>然后验证结果状态（大约一分钟后）：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 准备好后按 Ctrl+C 结束观察</span>
</span></span><span style=display:flex><span>kubectl get hpa php-apache --watch
</span></span></code></pre></div><p>输出类似于：</p><pre tabindex=0><code>NAME         REFERENCE                     TARGET       MINPODS   MAXPODS   REPLICAS   AGE
php-apache   Deployment/php-apache/scale   0% / 50%     1         10        1          11m
</code></pre><p>Deployment 也显示它已经缩小了：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get deployment php-apache
</span></span></code></pre></div><pre tabindex=0><code>NAME         READY   UP-TO-DATE   AVAILABLE   AGE
php-apache   1/1     1            1           27m
</code></pre><p>一旦 CPU 利用率降至 0，HPA 会自动将副本数缩减为 1。</p><p>自动扩缩完成副本数量的改变可能需要几分钟的时间。</p><h2 id=autoscaling-on-multiple-metrics-and-custom-metrics>基于多项度量指标和自定义度量指标自动扩缩</h2><p>利用 <code>autoscaling/v2</code> API 版本，你可以在自动扩缩 php-apache 这个
Deployment 时使用其他度量指标。</p><p>首先，将 HorizontalPodAutoscaler 的 YAML 文件改为 <code>autoscaling/v2</code> 格式：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get hpa php-apache -o yaml &gt; /tmp/hpa-v2.yaml
</span></span></code></pre></div><p>在编辑器中打开 <code>/tmp/hpa-v2.yaml</code>，你应看到如下所示的 YAML 文件：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>autoscaling/v2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>HorizontalPodAutoscaler<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>php-apache<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scaleTargetRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>php-apache<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>minReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>maxReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>metrics</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Resource<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resource</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cpu<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>target</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Utilization<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>averageUtilization</span>:<span style=color:#bbb> </span><span style=color:#666>50</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>observedGeneration</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>lastScaleTime</span>:<span style=color:#bbb> </span>&lt;some-time&gt;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>currentReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>desiredReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>currentMetrics</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Resource<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resource</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cpu<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>current</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>averageUtilization</span>:<span style=color:#bbb> </span><span style=color:#666>0</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>averageValue</span>:<span style=color:#bbb> </span><span style=color:#666>0</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>需要注意的是，<code>targetCPUUtilizationPercentage</code> 字段已经被名为 <code>metrics</code> 的数组所取代。
CPU 利用率这个度量指标是一个 <em>resource metric</em>（资源度量指标），因为它表示容器上指定资源的百分比。
除 CPU 外，你还可以指定其他资源度量指标。默认情况下，目前唯一支持的其他资源度量指标为内存。
只要 <code>metrics.k8s.io</code> API 存在，这些资源度量指标就是可用的，并且他们不会在不同的 Kubernetes 集群中改变名称。</p><p>你还可以指定资源度量指标使用绝对数值，而不是百分比，你需要将 <code>target.type</code> 从
<code>Utilization</code> 替换成 <code>AverageValue</code>，同时设置 <code>target.averageValue</code>
而非 <code>target.averageUtilization</code> 的值。</p><p>还有两种其他类型的度量指标，他们被认为是 <em>custom metrics</em>（自定义度量指标）：
即 Pod 度量指标和 Object 度量指标。
这些度量指标可能具有特定于集群的名称，并且需要更高级的集群监控设置。</p><p>第一种可选的度量指标类型是 <strong>Pod 度量指标</strong>。这些指标从某一方面描述了 Pod，
在不同 Pod 之间进行平均，并通过与一个目标值比对来确定副本的数量。
它们的工作方式与资源度量指标非常相像，只是它们 <strong>仅</strong> 支持 <code>target</code> 类型为 <code>AverageValue</code>。</p><p>Pod 度量指标通过如下代码块定义：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Pods<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>pods</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>metric</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>packets-per-second<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>target</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>AverageValue<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>averageValue</span>:<span style=color:#bbb> </span>1k<span style=color:#bbb>
</span></span></span></code></pre></div><p>第二种可选的度量指标类型是对象 <strong>（Object）度量指标</strong>。
这些度量指标用于描述在相同名字空间中的别的对象，而非 Pod。
请注意这些度量指标不一定来自某对象，它们仅用于描述这些对象。
对象度量指标支持的 <code>target</code> 类型包括 <code>Value</code> 和 <code>AverageValue</code>。
如果是 <code>Value</code> 类型，<code>target</code> 值将直接与 API 返回的度量指标比较，
而对于 <code>AverageValue</code> 类型，API 返回的度量值将按照 Pod 数量拆分，
然后再与 <code>target</code> 值比较。
下面的 YAML 文件展示了一个表示 <code>requests-per-second</code> 的度量指标。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Object<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>object</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>metric</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>requests-per-second<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>describedObject</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Ingress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>main-route<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>target</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Value<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span>2k<span style=color:#bbb>
</span></span></span></code></pre></div><p>如果你指定了多个上述类型的度量指标，HorizontalPodAutoscaler 将会依次考量各个指标。
HorizontalPodAutoscaler 将会计算每一个指标所提议的副本数量，然后最终选择一个最高值。</p><p>比如，如果你的监控系统能够提供网络流量数据，你可以通过 <code>kubectl edit</code>
命令将上述 Horizontal Pod Autoscaler 的定义更改为：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>autoscaling/v2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>HorizontalPodAutoscaler<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>php-apache<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scaleTargetRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>php-apache<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>minReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>maxReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>metrics</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Resource<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resource</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cpu<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>target</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Utilization<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>averageUtilization</span>:<span style=color:#bbb> </span><span style=color:#666>50</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Pods<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>pods</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>metric</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>packets-per-second<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>target</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>AverageValue<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>averageValue</span>:<span style=color:#bbb> </span>1k<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Object<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>object</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>metric</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>requests-per-second<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>describedObject</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Ingress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>main-route<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>target</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Value<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span>10k<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>observedGeneration</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>lastScaleTime</span>:<span style=color:#bbb> </span>&lt;some-time&gt;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>currentReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>desiredReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>currentMetrics</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Resource<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resource</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cpu<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>current</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>averageUtilization</span>:<span style=color:#bbb> </span><span style=color:#666>0</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>averageValue</span>:<span style=color:#bbb> </span><span style=color:#666>0</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Object<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>object</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>metric</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>requests-per-second<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>describedObject</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>networking.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Ingress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>main-route<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>current</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span>10k<span style=color:#bbb>
</span></span></span></code></pre></div><p>这样，你的 HorizontalPodAutoscaler 将会尝试确保每个 Pod 的 CPU 利用率在 50% 以内，
每秒能够服务 1000 个数据包请求，
并确保所有在 Ingress 后的 Pod 每秒能够服务的请求总数达到 10000 个。</p><h3 id=autoscaing-on-more-specific-metrics>基于更特别的度量值来扩缩</h3><p>许多度量流水线允许你通过名称或附加的 <strong>标签</strong> 来描述度量指标。
对于所有非资源类型度量指标（Pod、Object 和后面将介绍的 External），
可以额外指定一个标签选择算符。例如，如果你希望收集包含 <code>verb</code> 标签的
<code>http_requests</code> 度量指标，可以按如下所示设置度量指标块，使得扩缩操作仅针对
GET 请求执行：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Object<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>object</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>metric</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>http_requests<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb> </span>{<span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb> </span>{<span style=color:green;font-weight:700>verb</span>:<span style=color:#bbb> </span>GET}}<span style=color:#bbb>
</span></span></span></code></pre></div><p>这个选择算符使用与 Kubernetes 标签选择算符相同的语法。
如果名称和标签选择算符匹配到多个系列，监测管道会决定如何将多个系列合并成单个值。
选择算符是可以累加的，它不会选择目标以外的对象（类型为 <code>Pods</code> 的目标 Pod 或者类型为 <code>Object</code> 的目标对象）。</p><h3 id=autoscaling-on-metrics-not-related-to-kubernetes-objects>基于与 Kubernetes 对象无关的度量指标执行扩缩</h3><p>运行在 Kubernetes 上的应用程序可能需要基于与 Kubernetes
集群中的任何对象没有明显关系的度量指标进行自动扩缩，
例如那些描述与任何 Kubernetes 名字空间中的服务都无直接关联的度量指标。
在 Kubernetes 1.10 及之后版本中，你可以使用外部度量指标（external metrics）。</p><p>使用外部度量指标时，需要了解你所使用的监控系统，相关的设置与使用自定义指标时类似。
外部度量指标使得你可以使用你的监控系统的任何指标来自动扩缩你的集群。
你需要在 <code>metric</code> 块中提供 <code>name</code> 和 <code>selector</code>，同时将类型由 <code>Object</code> 改为 <code>External</code>。
如果 <code>metricSelector</code> 匹配到多个度量指标，HorizontalPodAutoscaler 将会把它们加和。
外部度量指标同时支持 <code>Value</code> 和 <code>AverageValue</code> 类型，这与 <code>Object</code> 类型的度量指标相同。</p><p>例如，如果你的应用程序处理来自主机上消息队列的任务，
为了让每 30 个任务有 1 个工作者实例，你可以将下面的内容添加到
HorizontalPodAutoscaler 的配置中。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>External<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>external</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metric</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>queue_messages_ready<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>queue</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;worker_tasks&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>target</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>AverageValue<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>averageValue</span>:<span style=color:#bbb> </span><span style=color:#666>30</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>如果可能，还是推荐定制度量指标而不是外部度量指标，因为这便于让系统管理员加固定制度量指标 API。
而外部度量指标 API 可以允许访问所有的度量指标。
当暴露这些服务时，系统管理员需要仔细考虑这个问题。</p><h2 id=appendix-horizontal-pod-autoscaler-status-conditions>附录：Horizontal Pod Autoscaler 状态条件</h2><p>使用 <code>autoscaling/v2</code> 格式的 HorizontalPodAutoscaler 时，你将可以看到
Kubernetes 为 HorizongtalPodAutoscaler 设置的状态条件（Status Conditions）。
这些状态条件可以显示当前 HorizontalPodAutoscaler 是否能够执行扩缩以及是否受到一定的限制。</p><p><code>status.conditions</code> 字段展示了这些状态条件。
可以通过 <code>kubectl describe hpa</code> 命令查看当前影响 HorizontalPodAutoscaler
的各种状态条件信息：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe hpa cm-test
</span></span></code></pre></div><pre tabindex=0><code>Name:                           cm-test
Namespace:                      prom
Labels:                         &lt;none&gt;
Annotations:                    &lt;none&gt;
CreationTimestamp:              Fri, 16 Jun 2017 18:09:22 +0000
Reference:                      ReplicationController/cm-test
Metrics:                        ( current / target )
  &#34;http_requests&#34; on pods:      66m / 500m
Min replicas:                   1
Max replicas:                   4
ReplicationController pods:     1 current / 1 desired
Conditions:
  Type                  Status  Reason                  Message
  ----                  ------  ------                  -------
  AbleToScale           True    ReadyForNewScale        the last scale time was sufficiently old as to warrant a new scale
  ScalingActive         True    ValidMetricFound        the HPA was able to successfully calculate a replica count from pods metric http_requests
  ScalingLimited        False   DesiredWithinRange      the desired replica count is within the acceptable range
Events:
</code></pre><p>对于上面展示的这个 HorizontalPodAutoscaler，我们可以看出有若干状态条件处于健康状态。
首先，<code>AbleToScale</code> 表明 HPA 是否可以获取和更新扩缩信息，以及是否存在阻止扩缩的各种回退条件。
其次，<code>ScalingActive</code> 表明 HPA 是否被启用（即目标的副本数量不为零） 以及是否能够完成扩缩计算。
当这一状态为 <code>False</code> 时，通常表明获取度量指标存在问题。
最后一个条件 <code>ScalingLimited</code> 表明所需扩缩的值被 HorizontalPodAutoscaler
所定义的最大或者最小值所限制（即已经达到最大或者最小扩缩值）。
这通常表明你可能需要调整 HorizontalPodAutoscaler 所定义的最大或者最小副本数量的限制了。</p><h2 id=quantities>量纲</h2><p>HorizontalPodAutoscaler 和 度量指标 API 中的所有的度量指标使用 Kubernetes
中称为<a class=glossary-tooltip title='使用全数字来表示较小数值或使用 SI 后缀表示较大数值的表示法。' data-toggle=tooltip data-placement=top href='/zh-cn/docs/reference/glossary/?all=true#term-quantity' target=_blank aria-label=量纲（Quantity）>量纲（Quantity）</a>的特殊整数表示。
例如，数量 <code>10500m</code> 用十进制表示为 <code>10.5</code>。
如果可能的话，度量指标 API 将返回没有后缀的整数，否则返回以千分单位的数量。
这意味着你可能会看到你的度量指标在 <code>1</code> 和 <code>1500m</code>（也就是在十进制记数法中的 <code>1</code> 和 <code>1.5</code>）之间波动。</p><h2 id=other-possible-scenarios>其他可能的情况</h2><h3 id=creating-the-autoscaler-declaratively>以声明式方式创建 Autoscaler</h3><p>除了使用 <code>kubectl autoscale</code> 命令，也可以使用以下清单以声明方式创建 HorizontalPodAutoscaler：</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/application/hpa/php-apache.yaml download=application/hpa/php-apache.yaml><code>application/hpa/php-apache.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("application-hpa-php-apache-yaml")' title="Copy application/hpa/php-apache.yaml to clipboard"></img></div><div class=includecode id=application-hpa-php-apache-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>autoscaling/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>HorizontalPodAutoscaler<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>php-apache<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scaleTargetRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>php-apache<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>minReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>maxReplicas</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>targetCPUUtilizationPercentage</span>:<span style=color:#bbb> </span><span style=color:#666>50</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>使用如下命令创建 Autoscaler：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f https://k8s.io/examples/application/hpa/php-apache.yaml
</span></span></code></pre></div><pre tabindex=0><code>horizontalpodautoscaler.autoscaling/php-apache created
</code></pre></div><div class=td-content style=page-break-before:always><h1 id=pg-fbe2744f00d1aa4df4cdf4eea6a082d4>8 - 为应用程序设置干扰预算（Disruption Budget）</h1><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.21 [stable]</code></div><p>本文展示如何限制应用程序的并发干扰数量，在允许集群管理员管理集群节点的同时保证高可用。</p><h2 id=准备开始>准备开始</h2>你的 Kubernetes 服务器版本必须不低于版本 v1.21.
要获知版本信息，请输入 <code>kubectl version</code>.<ul><li>你是 Kubernetes 集群中某应用的所有者，该应用有高可用要求。</li><li>你应了解如何部署<a href=/zh-cn/docs/tasks/run-application/run-stateless-application-deployment/>无状态应用</a>
和/或<a href=/zh-cn/docs/tasks/run-application/run-replicated-stateful-application/>有状态应用</a>。</li><li>你应当已经阅读过关于 <a href=/zh-cn/docs/concepts/workloads/pods/disruptions/>Pod 干扰</a> 的文档。</li><li>用户应当与集群所有者或服务提供者确认其遵从 Pod 干扰预算（Pod Disruption Budgets）的规则。</li></ul><h2 id=用-poddisruptionbudget-来保护应用>用 PodDisruptionBudget 来保护应用</h2><ol><li>确定想要使用 PodDisruptionBudget (PDB) 来保护的应用。</li><li>考虑应用对干扰的反应。</li><li>以 YAML 文件形式定义 PDB 。</li><li>通过 YAML 文件创建 PDB 对象。</li></ol><h2 id=确定要保护的应用>确定要保护的应用</h2><p>用户想要保护通过内置的 Kubernetes 控制器指定的应用，这是最常见的使用场景：</p><ul><li>Deployment</li><li>ReplicationController</li><li>ReplicaSet</li><li>StatefulSet</li></ul><p>在这种情况下，在控制器的 <code>.spec.selector</code> 字段中做记录，并在 PDB 的
<code>.spec.selector</code> 字段中加入同样的选择算符。</p><p>从 1.15 版本开始，PDB 支持启用
<a href=/zh-cn/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#scale-subresource>Scale 子资源</a>
的自定义控制器。</p><p>用户也可以用 PDB 来保护不受上述控制器控制的 Pod，或任意的 Pod 集合，但是正如
<a href=#arbitrary-controllers-and-selectors>任意控制器和选择算符</a>中描述的，这里存在一些限制。</p><h2 id=考虑应用对干扰的反应>考虑应用对干扰的反应</h2><p>确定在自发干扰时，多少实例可以在短时间内同时关闭。</p><ul><li>无状态的前端：<ul><li>关注：不能降低服务能力 10% 以上。<ul><li>解决方案：例如，使用 PDB，指定其 minAvailable 值为 90%。</li></ul></li></ul></li><li>单实例有状态应用：<ul><li>关注：不要在不通知的情况下终止该应用。<ul><li>可能的解决方案 1：不使用 PDB，并忍受偶尔的停机。</li><li>可能的解决方案 2：设置 maxUnavailable=0 的 PDB。
意为（Kubernetes 范畴之外的）集群操作人员需要在终止应用前与用户协商，
协商后准备停机，然后删除 PDB 表示准备接受干扰，后续再重新创建。</li></ul></li></ul></li><li>多实例有状态应用，如 Consul、ZooKeeper 或 etcd：<ul><li>关注：不要将实例数量减少至低于仲裁规模，否则将出现写入失败。<ul><li>可能的解决方案 1：设置 maxUnavailable 值为 1 (适用于不同规模的应用)。</li><li>可能的解决方案 2：设置 minAvailable 值为仲裁规模（例如规模为 5 时设置为 3）。
(允许同时出现更多的干扰)。</li></ul></li></ul></li><li>可重新启动的批处理任务：<ul><li>关注：自发干扰的情况下，需要确保任务完成。<ul><li>可能的解决方案：不创建 PDB。 任务控制器会创建一个替换 Pod。</li></ul></li></ul></li></ul><h3 id=指定百分比时的舍入逻辑>指定百分比时的舍入逻辑</h3><p><code>minAvailable</code> 或 <code>maxUnavailable</code> 的值可以表示为整数或百分比。</p><ul><li>指定整数值时，它表示 Pod 个数。例如，如果将 minAvailable 设置为 10，
那么即使在干扰期间，也必须始终有 10 个Pod可用。</li><li>通过将值设置为百分比的字符串表示形式（例如 “50％”）来指定百分比时，它表示占总 Pod 数的百分比。
例如，如果将 "maxUnavailable" 设置为 “50％”，则干扰期间只允许 50％ 的 Pod 不可用。</li></ul><p>如果将值指定为百分比，则可能无法映射到确切数量的 Pod。例如，如果你有 7 个 Pod，
并且你将 <code>minAvailable</code> 设置为 <code>"50％"</code>，具体是 3 个 Pod 或 4 个 Pod 必须可用
并非显而易见。
Kubernetes 采用向上取整到最接近的整数的办法，因此在这种情况下，必须有 4 个 Pod。
你可以检查控制此行为的
<a href=https://github.com/kubernetes/kubernetes/blob/23be9587a0f8677eb8091464098881df939c44a9/pkg/controller/disruption/disruption.go#L539>代码</a>。</p><h2 id=指定-poddisruptionbudget>指定 PodDisruptionBudget</h2><p>一个 <code>PodDisruptionBudget</code> 有 3 个字段：</p><ul><li>标签选择算符 <code>.spec.selector</code> 用于指定其所作用的 Pod 集合，该字段为必需字段。</li><li><code>.spec.minAvailable</code> 表示驱逐后仍须保证可用的 Pod 数量。即使因此影响到 Pod 驱逐
（即该条件在和 Pod 驱逐发生冲突时优先保证）。
<code>minAvailable</code> 值可以是绝对值，也可以是百分比。</li><li><code>.spec.maxUnavailable</code> （Kubernetes 1.7 及更高的版本中可用）表示驱逐后允许不可用的
Pod 的最大数量。其值可以是绝对值或是百分比。</li></ul><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p><code>policy/v1beta1</code> 和 <code>policy/v1</code> API 中 PodDisruptionBudget 的空选择算符的行为
略有不同。在 <code>policy/v1beta1</code> 中，空的选择算符不会匹配任何 Pods，而
<code>policy/v1</code> 中，空的选择算符会匹配名字空间中所有 Pods。</div><p>用户在同一个 <code>PodDisruptionBudget</code> 中只能够指定 <code>maxUnavailable</code> 和 <code>minAvailable</code> 中的一个。
<code>maxUnavailable</code> 只能够用于控制存在相应控制器的 Pod 的驱逐（即不受控制器控制的 Pod 不在
<code>maxUnavailable</code> 控制范围内）。在下面的示例中，
“所需副本” 指的是相应控制器的 <code>scale</code>，控制器对 <code>PodDisruptionBudget</code> 所选择的 Pod 进行管理。</p><p>示例 1：设置 <code>minAvailable</code> 值为 5 的情况下，驱逐时需保证 PodDisruptionBudget 的 <code>selector</code>
选中的 Pod 中 5 个或 5 个以上处于健康状态。</p><p>示例 2：设置 <code>minAvailable</code> 值为 30% 的情况下，驱逐时需保证 Pod 所需副本的至少 30% 处于健康状态。</p><p>示例 3：设置 <code>maxUnavailable</code> 值为 5 的情况下，驱逐时需保证所需副本中最多 5 个处于不可用状态。</p><p>示例 4：设置 <code>maxUnavailable</code> 值为 30% 的情况下，驱逐时需保证所需副本中最多 30% 处于不可用状态。</p><p>在典型用法中，干扰预算会被用于一个控制器管理的一组 Pod 中 —— 例如：一个 ReplicaSet 或 StatefulSet
中的 Pod。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong> 干扰预算并不能真正保证指定数量/百分比的 Pod 一直处于运行状态。例如： 当 Pod 集合的
规模处于预算指定的最小值时，承载集合中某个 Pod 的节点发生了故障，这样就导致集合中可用 Pod 的
数量低于预算指定值。预算只能够针对自发的驱逐提供保护，而不能针对所有 Pod 不可用的诱因。</div><p>如果你将 <code>maxUnavailable</code> 的值设置为 0%（或 0）或设置 <code>minAvailable</code> 值为 100%（或等于副本数）
则会阻止所有的自愿驱逐。
当你为 ReplicaSet 等工作负载对象设置阻止自愿驱逐时，你将无法成功地腾空运行其中一个 Pod 的节点。
如果你尝试腾空正在运行着被阻止驱逐的 Pod 的节点，则腾空永远不会完成。
按照 <code>PodDisruptionBudget</code> 的语义，这是允许的。</p><p>用户可以在下面看到 pod 干扰预算定义的示例，它们与带有 <code>app: zookeeper</code> 标签的 pod 相匹配：</p><p>使用 minAvailable 的PDB 示例：</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/policy/zookeeper-pod-disruption-budget-minavailable.yaml download=policy/zookeeper-pod-disruption-budget-minavailable.yaml><code>policy/zookeeper-pod-disruption-budget-minavailable.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("policy-zookeeper-pod-disruption-budget-minavailable-yaml")' title="Copy policy/zookeeper-pod-disruption-budget-minavailable.yaml to clipboard"></img></div><div class=includecode id=policy-zookeeper-pod-disruption-budget-minavailable-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>policy/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PodDisruptionBudget<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>zk-pdb<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>minAvailable</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>zookeeper<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>使用 maxUnavailable 的 PDB 示例：</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/policy/zookeeper-pod-disruption-budget-maxunavailable.yaml download=policy/zookeeper-pod-disruption-budget-maxunavailable.yaml><code>policy/zookeeper-pod-disruption-budget-maxunavailable.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("policy-zookeeper-pod-disruption-budget-maxunavailable-yaml")' title="Copy policy/zookeeper-pod-disruption-budget-maxunavailable.yaml to clipboard"></img></div><div class=includecode id=policy-zookeeper-pod-disruption-budget-maxunavailable-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>policy/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PodDisruptionBudget<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>zk-pdb<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>maxUnavailable</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>zookeeper<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>例如，如果上述 <code>zk-pdb</code> 选择的是一个规格为 3 的 StatefulSet 对应的 Pod，
那么上面两种规范的含义完全相同。
推荐使用 <code>maxUnavailable</code> ，因为它自动响应控制器副本数量的变化。</p><h2 id=创建-pdb-对象>创建 PDB 对象</h2><p>你可以使用 kubectl 创建或更新 PDB 对象。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f mypdb.yaml
</span></span></code></pre></div><p>PDB 对象无法更新，必须删除后重新创建。</p><h2 id=检查-pdb-的状态>检查 PDB 的状态</h2><p>使用 kubectl 来确认 PDB 被创建。</p><p>假设用户的名字空间下没有匹配 <code>app: zookeeper</code> 的 Pod，用户会看到类似下面的信息：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get poddisruptionbudgets
</span></span></code></pre></div><pre tabindex=0><code>NAME     MIN AVAILABLE   MAX UNAVAILABLE   ALLOWED DISRUPTIONS   AGE
zk-pdb   2               N/A               0                     7s
</code></pre><p>假设有匹配的 Pod (比如说 3 个), 那么用户会看到类似下面的信息：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get poddisruptionbudgets
</span></span></code></pre></div><pre tabindex=0><code>NAME     MIN AVAILABLE   MAX UNAVAILABLE   ALLOWED DISRUPTIONS   AGE
zk-pdb   2               N/A               1                     7s
</code></pre><p><code>ALLOWED DISRUPTIONS</code> 值非 0 意味着干扰控制器已经感知到相应的 Pod，对匹配的 Pod 进行统计，
并更新了 PDB 的状态。</p><p>用户可以通过以下命令获取更多 PDB 状态相关信息：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get poddisruptionbudgets zk-pdb -o yaml
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>policy/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PodDisruptionBudget<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>…<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2020-03-04T04:22:56Z&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>generation</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>zk-pdb<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>…<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>currentHealthy</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>desiredHealthy</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>disruptionsAllowed</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>expectedPods</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>observedGeneration</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=arbitrary-controllers-and-selectors>任意控制器和选择算符</h2><p>如果你只使用与内置的应用控制器（Deployment、ReplicationController、ReplicaSet 和 StatefulSet）
对应的 PDB，也就是 PDB 的选择算符与 控制器的选择算符相匹配，那么可以跳过这一节。</p><p>你可以使用这样的 PDB：它对应的 Pod 可能由其他类型的控制器控制，可能由 "operator" 控制，
也可能为“裸的（不受控制器控制）” Pod，但该类 PDB 存在以下限制：</p><ul><li>只能够使用 <code>.spec.minAvailable</code> ，而不能够使用 <code>.spec.maxUnavailable。</code></li><li>只能够使用整数作为 <code>.spec.minAvailable</code> 的值，而不能使用百分比。</li></ul><p>你可以令选择算符选择一个内置控制器所控制 Pod 的子集或父集。
驱逐 API 将不允许驱逐被多个 PDB 覆盖的任何 Pod，因此大多数用户都希望避免重叠的选择算符。重叠 PDB 的一种合理用途是当 Pod 从一个 PDB 过渡到另一个 PDB 时再使用。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-52cd10ee3fc7c74a6c31043a2d489878>9 - 从 Pod 中访问 Kubernetes API</h1><p>本指南演示了如何从 Pod 中访问 Kubernetes API。</p><h2 id=准备开始>准备开始</h2><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li></ul><h3 id=accessing-the-api-from-within-a-pod>从 Pod 中访问 API</h3><p>从 Pod 内部访问 API 时，定位 API 服务器和向服务器认证身份的操作
与外部客户端场景不同。</p><p>从 Pod 使用 Kubernetes API 的最简单的方法就是使用官方的
<a href=/zh-cn/docs/reference/using-api/client-libraries/>客户端库</a>。
这些库可以自动发现 API 服务器并进行身份验证。</p><h4 id=using-official-client-libraries>使用官方客户端库</h4><p>从一个 Pod 内部连接到 Kubernetes API 的推荐方式为：</p><ul><li><p>对于 Go 语言客户端，使用官方的 <a href=https://github.com/kubernetes/client-go/>Go 客户端库</a>。
函数 <code>rest.InClusterConfig()</code> 自动处理 API 主机发现和身份认证。
参见<a href=https://git.k8s.io/client-go/examples/in-cluster-client-configuration/main.go>这里的一个例子</a>。</p></li><li><p>对于 Python 客户端，使用官方的 <a href=https://github.com/kubernetes-client/python/>Python 客户端库</a>。
函数 <code>config.load_incluster_config()</code> 自动处理 API 主机的发现和身份认证。
参见<a href=https://github.com/kubernetes-client/python/blob/master/examples/in_cluster_config.py>这里的一个例子</a>。</p></li><li><p>还有一些其他可用的客户端库，请参阅<a href=/zh-cn/docs/reference/using-api/client-libraries/>客户端库</a>页面。</p></li></ul><p>在以上场景中，客户端库都使用 Pod 的服务账号凭据来与 API 服务器安全地通信。</p><h4 id=directly-accessing-the-rest-api>直接访问 REST API</h4><p>在运行在 Pod 中时，可以通过 <code>default</code> 命名空间中的名为 <code>kubernetes</code> 的服务访问
Kubernetes API 服务器。也就是说，Pod 可以使用 <code>kubernetes.default.svc</code> 主机名
来查询 API 服务器。官方客户端库自动完成这个工作。</p><p>向 API 服务器进行身份认证的推荐做法是使用
<a href=/zh-cn/docs/tasks/configure-pod-container/configure-service-account/>服务账号</a>凭据。
默认情况下，每个 Pod 与一个服务账号关联，该服务账户的凭证（令牌）放置在此 Pod 中
每个容器的文件系统树中的 <code>/var/run/secrets/kubernetes.io/serviceaccount/token</code> 处。</p><p>如果证书包可用，则凭证包被放入每个容器的文件系统树中的
<code>/var/run/secrets/kubernetes.io/serviceaccount/ca.crt</code> 处，
且将被用于验证 API 服务器的服务证书。</p><p>最后，用于命名空间域 API 操作的默认命名空间放置在每个容器中的
<code>/var/run/secrets/kubernetes.io/serviceaccount/namespace</code> 文件中。</p><h4 id=use-kubectl-proxy>使用 kubectl proxy</h4><p>如果你希望不使用官方客户端库就完成 API 查询，可以将 <code>kubectl proxy</code> 作为
<a href=/zh-cn/docs/tasks/inject-data-application/define-command-argument-container/>command</a>
在 Pod 中启动一个边车（Sidecar）容器。这样，<code>kubectl proxy</code> 自动完成对 API
的身份认证，并将其暴露到 Pod 的 <code>localhost</code> 接口，从而 Pod 中的其他容器可以
直接使用 API。</p><h3 id=without-using-a-proxy>不使用代理</h3><p>通过将认证令牌直接发送到 API 服务器，也可以避免运行 kubectl proxy 命令。
内部的证书机制能够为链接提供保护。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 指向内部 API 服务器的主机名</span>
</span></span><span style=display:flex><span><span style=color:#b8860b>APISERVER</span><span style=color:#666>=</span>https://kubernetes.default.svc
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 服务账号令牌的路径</span>
</span></span><span style=display:flex><span><span style=color:#b8860b>SERVICEACCOUNT</span><span style=color:#666>=</span>/var/run/secrets/kubernetes.io/serviceaccount
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 读取 Pod 的名字空间</span>
</span></span><span style=display:flex><span><span style=color:#b8860b>NAMESPACE</span><span style=color:#666>=</span><span style=color:#a2f;font-weight:700>$(</span>cat <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>SERVICEACCOUNT</span><span style=color:#b68;font-weight:700>}</span>/namespace<span style=color:#a2f;font-weight:700>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 读取服务账号的持有者令牌</span>
</span></span><span style=display:flex><span><span style=color:#b8860b>TOKEN</span><span style=color:#666>=</span><span style=color:#a2f;font-weight:700>$(</span>cat <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>SERVICEACCOUNT</span><span style=color:#b68;font-weight:700>}</span>/token<span style=color:#a2f;font-weight:700>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 引用内部证书机构（CA）</span>
</span></span><span style=display:flex><span><span style=color:#b8860b>CACERT</span><span style=color:#666>=</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>SERVICEACCOUNT</span><span style=color:#b68;font-weight:700>}</span>/ca.crt
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 使用令牌访问 API</span>
</span></span><span style=display:flex><span>curl --cacert <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>CACERT</span><span style=color:#b68;font-weight:700>}</span> --header <span style=color:#b44>&#34;Authorization: Bearer </span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>TOKEN</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>&#34;</span> -X GET <span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>APISERVER</span><span style=color:#b68;font-weight:700>}</span>/api
</span></span></code></pre></div><p>输出类似于：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;APIVersions&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;versions&#34;</span>: [
</span></span><span style=display:flex><span>    <span style=color:#b44>&#34;v1&#34;</span>
</span></span><span style=display:flex><span>  ],
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;serverAddressByClientCIDRs&#34;</span>: [
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;clientCIDR&#34;</span>: <span style=color:#b44>&#34;0.0.0.0/0&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;serverAddress&#34;</span>: <span style=color:#b44>&#34;10.0.1.149:443&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  ]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div><div class=td-content style=page-break-before:always><h1 id=pg-7a9b5779e228083ba3fdeaf414fe704e>10 - 扩缩 StatefulSet</h1><p>本文介绍如何扩缩StatefulSet。StatefulSet 的扩缩指的是增加或者减少副本个数。</p><h2 id=准备开始>准备开始</h2><ul><li><p>StatefulSets 仅适用于 Kubernetes 1.5 及以上版本。</p></li><li><p>不是所有 Stateful 应用都能很好地执行扩缩操作。
如果你不是很确定是否要扩缩你的 StatefulSet，可先参阅
<a href=/zh-cn/docs/concepts/workloads/controllers/statefulset/>StatefulSet 概念</a>
或者 <a href=/zh-cn/docs/tutorials/stateful-application/basic-stateful-set/>StatefulSet 教程</a>。</p></li><li><p>仅当你确定你的有状态应用的集群是完全健康的，才可执行扩缩操作.</p></li></ul><h2 id=scaling-statefulset>扩缩 StatefulSet</h2><h2 id=使用-kubectl-扩缩-statefulset>使用 <code>kubectl</code> 扩缩 StatefulSet</h2><p>首先，找到你要扩缩的 StatefulSet。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get statefulsets &lt;statefulset 名称&gt;
</span></span></code></pre></div><p>更改 StatefulSet 中副本个数：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl scale statefulsets &lt;statefulset 名称&gt; --replicas<span style=color:#666>=</span>&lt;新的副本数&gt;
</span></span></code></pre></div><h3 id=对-statefulset-执行就地更新>对 StatefulSet 执行就地更新</h3><p>另外, 你可以<a href=/zh-cn/docs/concepts/cluster-administration/manage-deployment/#in-place-updates-of-resources>就地更新</a> StatefulSet。</p><p>如果你的 StatefulSet 最初通过 <code>kubectl apply</code> 或 <code>kubectl create --save-config</code> 创建,
你可以更新 StatefulSet 清单中的 <code>.spec.replicas</code>, 然后执行命令 <code>kubectl apply</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f &lt;更新后的 statefulset 文件&gt;
</span></span></code></pre></div><p>否则，可以使用 <code>kubectl edit</code> 编辑副本字段：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl edit statefulsets &lt;statefulset 名称&gt;
</span></span></code></pre></div><p>或者使用 <code>kubectl patch</code>：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl patch statefulsets &lt;statefulset 名称&gt; -p <span style=color:#b44>&#39;{&#34;spec&#34;:{&#34;replicas&#34;:&lt;new-replicas&gt;}}&#39;</span>
</span></span></code></pre></div><h2 id=troubleshooting>故障排查</h2><h3 id=缩容操作无法正常工作>缩容操作无法正常工作</h3><p>当 Stateful 所管理的任何 Pod 不健康时，你不能对该 StatefulSet 执行缩容操作。
仅当 StatefulSet 的所有 Pod 都处于运行状态和 Ready 状况后才可缩容.</p><p>如果 <code>spec.replicas</code> 大于 1，Kubernetes 无法判定 Pod 不健康的原因。
Pod 不健康可能是由于永久性故障造成也可能是瞬态故障。
瞬态故障可能是节点升级或维护而引起的节点重启造成的。</p><p>如果该 Pod 不健康是由于永久性故障导致, 则在不纠正该故障的情况下进行缩容可能会导致
StatefulSet 进入一种状态，其成员 Pod 数量低于应正常运行的副本数。
这种状态也许会导致 StatefulSet 不可用。</p><p>如果由于瞬态故障而导致 Pod 不健康并且 Pod 可能再次变为可用，那么瞬态错误可能会干扰
你对 StatefulSet 的扩容/缩容操作。 一些分布式数据库在同时有节点加入和离开时
会遇到问题。在这些情况下，最好是在应用级别进行分析扩缩操作的状态, 并且只有在确保
Stateful 应用的集群是完全健康时才执行扩缩操作。</p><h2 id=接下来>接下来</h2><ul><li>进一步了解<a href=/zh-cn/docs/tasks/run-application/delete-stateful-set/>删除 StatefulSet</a></li></ul></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/zh-cn/docs/home/>主页</a>
<a class=text-white href=/zh-cn/blog/>博客</a>
<a class=text-white href=/zh-cn/training/>培训</a>
<a class=text-white href=/zh-cn/partners/>合作伙伴</a>
<a class=text-white href=/zh-cn/community/>社区</a>
<a class=text-white href=/zh-cn/case-studies/>案例分析</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 The Kubernetes 作者 | 文档发布基于 <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a> 授权许可</small><br><small class=text-white>Copyright &copy; 2023 Linux 基金会&reg;。保留所有权利。Linux 基金会已注册并使用商标。如需了解 Linux 基金会的商标列表，请访问<a href=https://www.linuxfoundation.org/trademark-usage class=light-text>商标使用页面</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>