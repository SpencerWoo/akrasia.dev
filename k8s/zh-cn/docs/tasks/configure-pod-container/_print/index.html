<!doctype html><html lang=zh-cn class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=en href=https://kubernetes.io/docs/tasks/configure-pod-container/><link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/tasks/configure-pod-container/><link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/tasks/configure-pod-container/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/tasks/configure-pod-container/><link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/tasks/configure-pod-container/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/tasks/configure-pod-container/><link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/tasks/configure-pod-container/><link rel=alternate hreflang=ru href=https://kubernetes.io/ru/docs/tasks/configure-pod-container/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>配置 Pods 和容器 | Kubernetes</title><meta property="og:title" content="配置 Pods 和容器"><meta property="og:description" content="对 Pod 和容器执行常见的配置任务。"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="配置 Pods 和容器"><meta itemprop=description content="对 Pod 和容器执行常见的配置任务。"><meta name=twitter:card content="summary"><meta name=twitter:title content="配置 Pods 和容器"><meta name=twitter:description content="对 Pod 和容器执行常见的配置任务。"><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content="对 Pod 和容器执行常见的配置任务。"><meta property="og:description" content="对 Pod 和容器执行常见的配置任务。"><meta name=twitter:description content="对 Pod 和容器执行常见的配置任务。"><meta property="og:url" content="https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/"><meta property="og:title" content="配置 Pods 和容器"><meta name=twitter:title content="配置 Pods 和容器"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/zh-cn/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/zh-cn/docs/>文档</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/zh-cn/blog/>Kubernetes 博客</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/zh-cn/training/>培训</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/zh-cn/partners/>合作伙伴</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/zh-cn/community/>社区</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/zh-cn/case-studies/>案例分析</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>版本列表</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/zh-cn/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/zh-cn/docs/tasks/configure-pod-container/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/zh-cn/docs/tasks/configure-pod-container/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/zh-cn/docs/tasks/configure-pod-container/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/zh-cn/docs/tasks/configure-pod-container/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>中文 (Chinese)</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/docs/tasks/configure-pod-container/>English</a>
<a class=dropdown-item href=/ko/docs/tasks/configure-pod-container/>한국어 (Korean)</a>
<a class=dropdown-item href=/ja/docs/tasks/configure-pod-container/>日本語 (Japanese)</a>
<a class=dropdown-item href=/fr/docs/tasks/configure-pod-container/>Français (French)</a>
<a class=dropdown-item href=/de/docs/tasks/configure-pod-container/>Deutsch (German)</a>
<a class=dropdown-item href=/es/docs/tasks/configure-pod-container/>Español (Spanish)</a>
<a class=dropdown-item href=/id/docs/tasks/configure-pod-container/>Bahasa Indonesia</a>
<a class=dropdown-item href=/ru/docs/tasks/configure-pod-container/>Русский (Russian)</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>这是本节的多页打印视图。
<a href=# onclick="return print(),!1">点击此处打印</a>.</p><p><a href=/zh-cn/docs/tasks/configure-pod-container/>返回本页常规视图</a>.</p></div><h1 class=title>配置 Pods 和容器</h1><div class=lead>对 Pod 和容器执行常见的配置任务。</div><ul><li>1: <a href=#pg-e6dd9300cf3a955f7cdfe77fb5d15292>为容器和 Pod 分配内存资源</a></li><li>2: <a href=#pg-3fbf113e9e5f4b46f8ccb91a048509c0>创建 Windows HostProcess Pod</a></li><li>3: <a href=#pg-aa522472483f900008124a2809f2114b>为 Windows Pod 和容器配置 GMSA</a></li><li>4: <a href=#pg-f5da7517bee8a8807431d9fc65263b39>为 Windows 的 Pod 和容器配置 RunAsUserName</a></li><li>5: <a href=#pg-8555af270ae7122cc0464bab3f5d1609>为容器和 Pods 分配 CPU 资源</a></li><li>6: <a href=#pg-904cea8c8efd5c0d33adbfe579ec2dd2>配置 Pod 的服务质量</a></li><li>7: <a href=#pg-4219ac6ab56a3b88d20305083d57d03c>为容器分派扩展资源</a></li><li>8: <a href=#pg-484833fb880d1e179cc2965d15f84da5>配置 Pod 以使用卷进行存储</a></li><li>9: <a href=#pg-528d2422215cb9632b7b45e886b023b5>配置 Pod 以使用 PersistentVolume 作为存储</a></li><li>10: <a href=#pg-4621938ba53c04a77f51b5938a583439>配置 Pod 使用投射卷作存储</a></li><li>11: <a href=#pg-abd895c0803315e9717e6ff9ec4e3d30>为 Pod 或容器配置安全上下文</a></li><li>12: <a href=#pg-2c0d882359718c4c69c67099bed2156c>为 Pod 配置服务账号</a></li><li>13: <a href=#pg-d385b86a7cb496d3b1c3b2a47280ca70>从私有仓库拉取镜像</a></li><li>14: <a href=#pg-eb54daf87df373096b5e830680194dfc>配置存活、就绪和启动探针</a></li><li>15: <a href=#pg-bbc17480da6d051c696489654c64064a>将 Pod 分配给节点</a></li><li>16: <a href=#pg-fc3f4777ae8ea685d2b54e175277ac01>用节点亲和性把 Pods 分配到节点</a></li><li>17: <a href=#pg-1e7baac1825631a5af5d2aebcf059249>配置 Pod 初始化</a></li><li>18: <a href=#pg-efbc43486296f0439d1a89c12d944d94>为容器的生命周期事件设置处理函数</a></li><li>19: <a href=#pg-ed34e761c3dbd00fa79577fa78e30020>配置 Pod 使用 ConfigMap</a></li><li>20: <a href=#pg-18935633a984586fbb68b727f3f339bb>为 Pod 配置用户名字空间</a></li><li>21: <a href=#pg-3d7b9cb24a647c36ba63f7a02ec49010>在 Pod 中的容器之间共享进程命名空间</a></li><li>22: <a href=#pg-42a59b878d4c58e5c6f4bb87483dda93>创建静态 Pod</a></li><li>23: <a href=#pg-1bb997c61a85de753d9994e7a312a291>将 Docker Compose 文件转换为 Kubernetes 资源</a></li><li>24: <a href=#pg-0a91fdc1445a8c7f3563c41a9b9b3370>从 PodSecurityPolicy 迁移到内置的 PodSecurity 准入控制器</a></li><li>25: <a href=#pg-9c9966a13899846a35113763603cd6db>使用名字空间标签来实施 Pod 安全性标准</a></li><li>26: <a href=#pg-108be708e50a97cae1cc0b67d5f360b7>通过配置内置准入控制器实施 Pod 安全标准</a></li></ul><div class=content></div></div><div class=td-content><h1 id=pg-e6dd9300cf3a955f7cdfe77fb5d15292>1 - 为容器和 Pod 分配内存资源</h1><p>此页面展示如何将内存<strong>请求</strong>（request）和内存<strong>限制</strong>（limit）分配给一个容器。
我们保障容器拥有它请求数量的内存，但不允许使用超过限制数量的内存。</p><h2 id=准备开始>准备开始</h2><p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li></ul>要获知版本信息，请输入 <code>kubectl version</code>.</p><p>你集群中的每个节点必须拥有至少 300 MiB 的内存。</p><p>该页面上的一些步骤要求你在集群中运行
<a href=https://github.com/kubernetes-sigs/metrics-server>metrics-server</a> 服务。
如果你已经有在运行中的 metrics-server，则可以跳过这些步骤。</p><p>如果你运行的是 Minikube，可以运行下面的命令启用 metrics-server：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>minikube addons <span style=color:#a2f>enable</span> metrics-server
</span></span></code></pre></div><p>要查看 metrics-server 或资源指标 API (<code>metrics.k8s.io</code>) 是否已经运行，请运行以下命令：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get apiservices
</span></span></code></pre></div><p>如果资源指标 API 可用，则输出结果将包含对 <code>metrics.k8s.io</code> 的引用信息。</p><pre tabindex=0><code>NAME
v1beta1.metrics.k8s.io
</code></pre><h2 id=create-a-namespace>创建命名空间</h2><p>创建一个命名空间，以便将本练习中创建的资源与集群的其余部分隔离。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create namespace mem-example
</span></span></code></pre></div><h2 id=specify-a-memory-request-and-a-memory-limit>指定内存请求和限制</h2><p>要为容器指定内存请求，请在容器资源清单中包含 <code>resources：requests</code> 字段。
同理，要指定内存限制，请包含 <code>resources：limits</code>。</p><p>在本练习中，你将创建一个拥有一个容器的 Pod。
容器将会请求 100 MiB 内存，并且内存会被限制在 200 MiB 以内。
这是 Pod 的配置文件：</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/pods/resource/memory-request-limit.yaml download=pods/resource/memory-request-limit.yaml><code>pods/resource/memory-request-limit.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-resource-memory-request-limit-yaml")' title="Copy pods/resource/memory-request-limit.yaml to clipboard"></img></div><div class=includecode id=pods-resource-memory-request-limit-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>memory-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>mem-example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>memory-demo-ctr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>polinux/stress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;100Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;200Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;stress&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;--vm&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;--vm-bytes&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;150M&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;--vm-hang&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>配置文件的 <code>args</code> 部分提供了容器启动时的参数。
<code>"--vm-bytes", "150M"</code> 参数告知容器尝试分配 150 MiB 内存。</p><p>开始创建 Pod：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/resource/memory-request-limit.yaml --namespace<span style=color:#666>=</span>mem-example
</span></span></code></pre></div><p>验证 Pod 中的容器是否已运行：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod memory-demo --namespace<span style=color:#666>=</span>mem-example
</span></span></code></pre></div><p>查看 Pod 相关的详细信息：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod memory-demo --output<span style=color:#666>=</span>yaml --namespace<span style=color:#666>=</span>mem-example
</span></span></code></pre></div><p>输出结果显示：该 Pod 中容器的内存请求为 100 MiB，内存限制为 200 MiB。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>100Mi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>200Mi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>运行 <code>kubectl top</code> 命令，获取该 Pod 的指标数据：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl top pod memory-demo --namespace<span style=color:#666>=</span>mem-example
</span></span></code></pre></div><p>输出结果显示：Pod 正在使用的内存大约为 162,900,000 字节，约为 150 MiB。
这大于 Pod 请求的 100 MiB，但在 Pod 限制的 200 MiB之内。</p><pre tabindex=0><code>NAME                        CPU(cores)   MEMORY(bytes)
memory-demo                 &lt;something&gt;  162856960
</code></pre><p>删除 Pod：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pod memory-demo --namespace<span style=color:#666>=</span>mem-example
</span></span></code></pre></div><h2 id=exceed-a-container-s-memory-limit>超过容器限制的内存</h2><p>当节点拥有足够的可用内存时，容器可以使用其请求的内存。
但是，容器不允许使用超过其限制的内存。
如果容器分配的内存超过其限制，该容器会成为被终止的候选容器。
如果容器继续消耗超出其限制的内存，则终止容器。
如果终止的容器可以被重启，则 kubelet 会重新启动它，就像其他任何类型的运行时失败一样。</p><p>在本练习中，你将创建一个 Pod，尝试分配超出其限制的内存。
这是一个 Pod 的配置文件，其拥有一个容器，该容器的内存请求为 50 MiB，内存限制为 100 MiB：</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/pods/resource/memory-request-limit-2.yaml download=pods/resource/memory-request-limit-2.yaml><code>pods/resource/memory-request-limit-2.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-resource-memory-request-limit-2-yaml")' title="Copy pods/resource/memory-request-limit-2.yaml to clipboard"></img></div><div class=includecode id=pods-resource-memory-request-limit-2-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>memory-demo-2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>mem-example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>memory-demo-2-ctr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>polinux/stress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;50Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;100Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;stress&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;--vm&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;--vm-bytes&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;250M&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;--vm-hang&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>在配置文件的 <code>args</code> 部分中，你可以看到容器会尝试分配 250 MiB 内存，这远高于 100 MiB 的限制。</p><p>创建 Pod：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/resource/memory-request-limit-2.yaml --namespace<span style=color:#666>=</span>mem-example
</span></span></code></pre></div><p>查看 Pod 相关的详细信息：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod memory-demo-2 --namespace<span style=color:#666>=</span>mem-example
</span></span></code></pre></div><p>此时，容器可能正在运行或被杀死。重复前面的命令，直到容器被杀掉：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME            READY     STATUS      RESTARTS   AGE
</span></span><span style=display:flex><span>memory-demo-2   0/1       OOMKilled   <span style=color:#666>1</span>          24s
</span></span></code></pre></div><p>获取容器更详细的状态信息：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod memory-demo-2 --output<span style=color:#666>=</span>yaml --namespace<span style=color:#666>=</span>mem-example
</span></span></code></pre></div><p>输出结果显示：由于内存溢出（OOM），容器已被杀掉：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>lastState</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span><span style=color:green;font-weight:700>terminated</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>containerID</span>:<span style=color:#bbb> </span>65183c1877aaec2e8427bc95609cc52677a454b56fcb24340dbd22917c23b10f<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>exitCode</span>:<span style=color:#bbb> </span><span style=color:#666>137</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>finishedAt</span>:<span style=color:#bbb> </span>2017-06-20T20:52:19Z<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>reason</span>:<span style=color:#bbb> </span>OOMKilled<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:green;font-weight:700>startedAt</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>null</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>本练习中的容器可以被重启，所以 kubelet 会重启它。
多次运行下面的命令，可以看到容器在反复的被杀死和重启：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod memory-demo-2 --namespace<span style=color:#666>=</span>mem-example
</span></span></code></pre></div><p>输出结果显示：容器被杀掉、重启、再杀掉、再重启……：</p><pre tabindex=0><code>kubectl get pod memory-demo-2 --namespace=mem-example
NAME            READY     STATUS      RESTARTS   AGE
memory-demo-2   0/1       OOMKilled   1          37s
</code></pre><pre tabindex=0><code>
kubectl get pod memory-demo-2 --namespace=mem-example
NAME            READY     STATUS    RESTARTS   AGE
memory-demo-2   1/1       Running   2          40s
</code></pre><p>查看关于该 Pod 历史的详细信息：</p><pre tabindex=0><code>kubectl describe pod memory-demo-2 --namespace=mem-example
</code></pre><p>输出结果显示：该容器反复的在启动和失败：</p><pre tabindex=0><code>... Normal  Created   Created container with id 66a3a20aa7980e61be4922780bf9d24d1a1d8b7395c09861225b0eba1b1f8511
... Warning BackOff   Back-off restarting failed container
</code></pre><p>查看关于集群节点的详细信息：</p><pre tabindex=0><code>kubectl describe nodes
</code></pre><p>输出结果包含了一条练习中的容器由于内存溢出而被杀掉的记录：</p><pre tabindex=0><code>Warning OOMKilling Memory cgroup out of memory: Kill process 4481 (stress) score 1994 or sacrifice child
</code></pre><p>删除 Pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pod memory-demo-2 --namespace<span style=color:#666>=</span>mem-example
</span></span></code></pre></div><h2 id=specify-a-memory-request-that-is-too-big-for-your-nodes>超过整个节点容量的内存</h2><p>内存请求和限制是与容器关联的，但将 Pod 视为具有内存请求和限制，也是很有用的。
Pod 的内存请求是 Pod 中所有容器的内存请求之和。
同理，Pod 的内存限制是 Pod 中所有容器的内存限制之和。</p><p>Pod 的调度基于请求。只有当节点拥有足够满足 Pod 内存请求的内存时，才会将 Pod 调度至节点上运行。</p><p>在本练习中，你将创建一个 Pod，其内存请求超过了你集群中的任意一个节点所拥有的内存。
这是该 Pod 的配置文件，其拥有一个请求 1000 GiB 内存的容器，这应该超过了你集群中任何节点的容量。</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/pods/resource/memory-request-limit-3.yaml download=pods/resource/memory-request-limit-3.yaml><code>pods/resource/memory-request-limit-3.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-resource-memory-request-limit-3-yaml")' title="Copy pods/resource/memory-request-limit-3.yaml to clipboard"></img></div><div class=includecode id=pods-resource-memory-request-limit-3-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>memory-demo-3<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>mem-example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>memory-demo-3-ctr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>polinux/stress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1000Gi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1000Gi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;stress&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;--vm&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;--vm-bytes&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;150M&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;--vm-hang&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>创建 Pod：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/resource/memory-request-limit-3.yaml --namespace<span style=color:#666>=</span>mem-example
</span></span></code></pre></div><p>查看 Pod 状态：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod memory-demo-3 --namespace<span style=color:#666>=</span>mem-example
</span></span></code></pre></div><p>输出结果显示：Pod 处于 PENDING 状态。
这意味着，该 Pod 没有被调度至任何节点上运行，并且它会无限期的保持该状态：</p><pre tabindex=0><code>kubectl get pod memory-demo-3 --namespace=mem-example
NAME            READY     STATUS    RESTARTS   AGE
memory-demo-3   0/1       Pending   0          25s
</code></pre><p>查看关于 Pod 的详细信息，包括事件：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe pod memory-demo-3 --namespace<span style=color:#666>=</span>mem-example
</span></span></code></pre></div><p>输出结果显示：由于节点内存不足，该容器无法被调度：</p><pre tabindex=0><code>Events:
  ...  Reason            Message
       ------            -------
  ...  FailedScheduling  No nodes are available that match all of the following predicates:: Insufficient memory (3).
</code></pre><h2 id=memory-units>内存单位</h2><p>内存资源的基本单位是字节（byte）。你可以使用这些后缀之一，将内存表示为
纯整数或定点整数：E、P、T、G、M、K、Ei、Pi、Ti、Gi、Mi、Ki。
例如，下面是一些近似相同的值：</p><pre tabindex=0><code>128974848, 129e6, 129M, 123Mi
</code></pre><p>删除 Pod：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pod memory-demo-3 --namespace<span style=color:#666>=</span>mem-example
</span></span></code></pre></div><h2 id=if-you-do-not-specify-a-memory-limit>如果你没有指定内存限制</h2><p>如果你没有为一个容器指定内存限制，则自动遵循以下情况之一：</p><ul><li><p>容器可无限制地使用内存。容器可以使用其所在节点所有的可用内存，
进而可能导致该节点调用 OOM Killer。
此外，如果发生 OOM Kill，没有资源限制的容器将被杀掉的可行性更大。</p></li><li><p>运行的容器所在命名空间有默认的内存限制，那么该容器会被自动分配默认限制。
集群管理员可用使用 <a href=/docs/reference/generated/kubernetes-api/v1.25/#limitrange-v1-core>LimitRange</a>
来指定默认的内存限制。</p></li></ul><h2 id=motivation-for-memory-requests-and-limits>内存请求和限制的目的</h2><p>通过为集群中运行的容器配置内存请求和限制，你可以有效利用集群节点上可用的内存资源。
通过将 Pod 的内存请求保持在较低水平，你可以更好地安排 Pod 调度。
通过让内存限制大于内存请求，你可以完成两件事：</p><ul><li>Pod 可以进行一些突发活动，从而更好的利用可用内存。</li><li>Pod 在突发活动期间，可使用的内存被限制为合理的数量。</li></ul><h2 id=clean-up>清理</h2><p>删除命名空间。下面的命令会删除你根据这个任务创建的所有 Pod：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete namespace mem-example
</span></span></code></pre></div><h2 id=接下来>接下来</h2><h3 id=for-app-developers>应用开发者扩展阅读</h3><ul><li><p><a href=/zh-cn/docs/tasks/configure-pod-container/assign-cpu-resource/>为容器和 Pod 分配 CPU 资源</a></p></li><li><p><a href=/zh-cn/docs/tasks/configure-pod-container/quality-service-pod/>配置 Pod 的服务质量</a></p></li></ul><h3 id=for-cluster-administrators>集群管理员扩展阅读</h3><ul><li><a href=/zh-cn/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/>为命名空间配置默认的内存请求和限制</a></li><li><a href=/zh-cn/docs/tasks/administer-cluster/manage-resources/cpu-default-namespace/>为命名空间配置默认的 CPU 请求和限制</a></li><li><a href=/zh-cn/docs/tasks/administer-cluster/manage-resources/memory-constraint-namespace/>配置命名空间的最小和最大内存约束</a></li><li><a href=/zh-cn/docs/tasks/administer-cluster/manage-resources/cpu-constraint-namespace/>配置命名空间的最小和最大 CPU 约束</a></li><li><a href=/zh-cn/docs/tasks/administer-cluster/manage-resources/quota-memory-cpu-namespace/>为命名空间配置内存和 CPU 配额</a></li><li><a href=/zh-cn/docs/tasks/administer-cluster/manage-resources/quota-pod-namespace/>配置命名空间下 Pod 总数</a></li><li><a href=/zh-cn/docs/tasks/administer-cluster/quota-api-object/>配置 API 对象配额</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-3fbf113e9e5f4b46f8ccb91a048509c0>2 - 创建 Windows HostProcess Pod</h1><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.23 [beta]</code></div><p>Windows HostProcess 容器让你能够在 Windows 主机上运行容器化负载。
这类容器以普通的进程形式运行，但能够在具有合适用户特权的情况下，
访问主机网络名字空间、存储和设备。HostProcess 容器可用来在 Windows
节点上部署网络插件、存储配置、设备插件、kube-proxy 以及其他组件，
同时不需要配置专用的代理或者直接安装主机服务。</p><p>类似于安装安全补丁、事件日志收集等这类管理性质的任务可以在不需要集群操作员登录到每个
Windows 节点的前提下执行。HostProcess 容器可以以主机上存在的任何用户账户来运行，
也可以以主机所在域中的用户账户运行，这样管理员可以通过用户许可权限来限制资源访问。
尽管文件系统和进程隔离都不支持，在启动容器时会在主机上创建一个新的卷，
为其提供一个干净的、整合的工作空间。HostProcess 容器也可以基于现有的 Windows
基础镜像来制作，并且不再有 Windows 服务器容器所带有的那些
<a href=https://docs.microsoft.com/virtualization/windowscontainers/deploy-containers/version-compatibility>兼容性需求</a>，
这意味着基础镜像的版本不必与主机操作系统的版本匹配。
不过，仍然建议你像使用 Windows 服务器容器负载那样，使用相同的基础镜像版本，
这样你就不会有一些未使用的镜像占用节点上的存储空间。HostProcess 容器也支持
在容器卷内执行<a href=#volume-mounts>卷挂载</a>。</p><h3 id=我何时该使用-windows-hostprocess-容器>我何时该使用 Windows HostProcess 容器？</h3><ul><li>当你准备执行需要访问主机上网络名字空间的任务时，HostProcess
容器能够访问主机上的网络接口和 IP 地址。</li><li>当你需要访问主机上的资源，如文件系统、事件日志等等。</li><li>需要安装特定的设备驱动或者 Windows 服务时。</li><li>需要对管理任务和安全策略进行整合时。使用 HostProcess 容器能够缩小 Windows
节点上所需要的特权范围。</li></ul><h2 id=准备开始>准备开始</h2><p>本任务指南是特定于 Kubernetes v1.25 的。
如果你运行的不是 Kubernetes v1.25，请移步访问正确
版本的 Kubernetes 文档。</p><p>在 Kubernetes v1.25 中，HostProcess 容器功能特性默认是启用的。
kubelet 会直接与 containerd 通信，通过 CRI 将主机进程标志传递过去。
你可以使用 containerd 的最新版本（v1.6+）来运行 HostProcess 容器。
参阅<a href=/zh-cn/docs/setup/production-environment/container-runtimes/#containerd>如何安装 containerd</a>。</p><p>要 <em>禁用</em> HostProcess 容器特性，你需要为 <strong>kubelet</strong> 和 <strong>kube-apiserver</strong>
设置下面的特性门控标志：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span>--feature-gates=WindowsHostProcessContainers=false
</span></span></code></pre></div><p>进一步的细节可参阅<a href=/zh-cn/docs/reference/command-line-tools-reference/feature-gates/#overview>特性门控</a>文档。</p><h2 id=limitations>限制</h2><p>以下限制是与 Kubernetes v1.25 相关的：</p><ul><li>HostProcess 容器需要 containerd 1.6 或更高版本的
<a class=glossary-tooltip title=容器运行时是负责运行容器的软件。 data-toggle=tooltip data-placement=top href=/zh-cn/docs/setup/production-environment/container-runtimes target=_blank aria-label=容器运行时>容器运行时</a>。</li><li>HostProcess Pods 只能包含 HostProcess 容器。这是在 Windows 操作系统上的约束；
非特权的 Windows 容器不能与主机 IP 名字空间共享虚拟网卡（vNIC）。</li><li>HostProcess 在主机上以一个进程的形式运行，除了通过 HostProcess
用户账号所实施的资源约束外，不提供任何形式的隔离。HostProcess 容器不支持文件系统或
Hyper-V 隔离。</li></ul><ul><li>卷挂载是被支持的，并且要花在到容器卷下。参见<a href=#volume-mounts>卷挂载</a>。</li><li>默认情况下有一组主机用户账户可供 HostProcess 容器使用。
参见<a href=#choosing-a-user-account>选择用户账号</a>。</li><li>对资源约束（磁盘、内存、CPU 个数）的支持与主机上进程相同。</li><li><strong>不支持</strong>命名管道或者 UNIX 域套接字形式的挂载，需要使用主机上的路径名来访问
（例如，\\.\pipe\*）。</li></ul><h2 id=hostprocess-pod-configuration-requirements>HostProcess Pod 配置需求</h2><p>启用 Windows HostProcess Pod 需要在 Pod 安全配置中设置合适的选项。
在 <a href=/zh-cn/docs/concepts/security/pod-security-standards>Pod
安全标准</a>中所定义的策略中，
HostProcess Pod 默认是不被 basline 和 restricted 策略支持的。因此建议
HostProcess 运行在与 privileged 模式相看齐的策略下。</p><p>当运行在 privileged 策略下时，下面是要启用 HostProcess Pod 创建所需要设置的选项：</p><table><caption style=display:none>privileged 策略规约</caption><thead><tr><th>控制</th><th>策略</th></tr></thead><tbody><tr><td style=white-space:nowrap><a href=/zh-cn/docs/concepts/security/pod-security-standards><tt>securityContext.windowsOptions.hostProcess</tt></a></td><td><p>Windows Pods 提供运行<a href=/zh-cn/docs/tasks/configure-pod-container/create-hostprocess-pod>
HostProcess 容器</a>的能力，这类容器能够具有对 Windows 节点的特权访问权限。</p><p><strong>可选值</strong></p><ul><li><code>true</code></li></ul></td></tr><tr><td style=white-space:nowrap><a href=/zh-cn/docs/concepts/security/pod-security-standards><tt>hostNetwork</tt></a></td><td><p>初始时将默认位于主机网络中。在未来可能会希望将网络设置到不同的隔离环境中。</p><p><strong>可选值</strong></p><ul><li><code>true</code></li></ul></td></tr><tr><td style=white-space:nowrap><a href=/zh-cn/docs/tasks/configure-pod-container/configure-runasusername/><tt>securityContext.windowsOptions.runAsUsername</tt></a></td><td><p>关于 HostProcess 容器所要使用的用户的规约，需要设置在 Pod 的规约中。</p><p><strong>可选值</strong></p><ul><li><code>NT AUTHORITY\SYSTEM</code></li><li><code>NT AUTHORITY\Local service</code></li><li><code>NT AUTHORITY\NetworkService</code></li></ul></td></tr><tr><td style=white-space:nowrap><a href=/zh-cn/docs/concepts/security/pod-security-standards><tt>runAsNonRoot</tt></a></td><td><p>因为 HostProcess 容器有访问主机的特权，<tt>runAsNonRoot</tt> 字段不可以设置为 true。</p><p><strong>可选值</strong></p><ul><li>未定义/Nil</li><li><code>false</code></li></ul></td></tr></tbody></table><h3 id=manifest-example>配置清单示例（片段）</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>windowsOptions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>hostProcess</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>runAsUserName</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;NT AUTHORITY\\Local service&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostNetwork</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>image1:latest<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- ping<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- -t<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:#666>127.0.0.1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodeSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;kubernetes.io/os&#34;: </span>windows<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=volume-mounts>卷挂载</h2><p>HostProcess 容器支持在容器卷空间中挂载卷的能力。
在容器内运行的应用能够通过相对或者绝对路径直接访问卷挂载。
环境变量 <code>$CONTAINER_SANDBOX_MOUNT_POINT</code> 在容器创建时被设置为指向容器卷的绝对主机路径。
相对路径是基于 <code>.spec.containers.volumeMounts.mountPath</code> 配置来推导的。</p><h3 id=volume-mount-example>示例</h3><p>容器内支持通过下面的路径结构来访问服务账好令牌：</p><p><code>.\var\run\secrets\kubernetes.io\serviceaccount\</code></p><p><code>$CONTAINER_SANDBOX_MOUNT_POINT\var\run\secrets\kubernetes.io\serviceaccount\</code></p><h2 id=resource-limits>资源约束</h2><p>资源约束（磁盘、内存、CPU 个数）作用到任务之上，并在整个任务上起作用。
例如，如果内存限制设置为 10MB，任何 HostProcess 任务对象所分配的内存不会超过 10MB。
这一行为与其他 Windows 容器类型相同。资源限制的设置方式与编排系统或容器运行时无关。
唯一的区别是用来跟踪资源所进行的磁盘资源用量的计算，出现差异的原因是因为
HostProcess 容器启动引导的方式造成的。</p><h2 id=choosing-a-user-account>选择用户账号</h2><p>HostProcess 容器支持以三种被支持的 Windows 服务账号之一来运行：</p><ul><li><strong><a href=https://docs.microsoft.com/windows/win32/services/localsystem-account>LocalSystem</a></strong></li><li><strong><a href=https://docs.microsoft.com/windows/win32/services/localservice-account>LocalService</a></strong></li><li><strong><a href=https://docs.microsoft.com/windows/win32/services/networkservice-account>NetworkService</a></strong></li></ul><p>你应该为每个 HostProcess 容器选择一个合适的 Windows 服务账号，尝试限制特权范围，
避免给主机代理意外的（甚至是恶意的）伤害。LocalSystem 服务账号的特权级
在三者之中最高，只有在绝对需要的时候才应该使用。只要可能，应该使用
LocalService 服务账号，因为该账号在三者中特权最低。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-aa522472483f900008124a2809f2114b>3 - 为 Windows Pod 和容器配置 GMSA</h1><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.18 [stable]</code></div><p>本页展示如何为将运行在 Windows 节点上的 Pod 和容器配置
<a href=https://docs.microsoft.com/en-us/windows-server/security/group-managed-service-accounts/group-managed-service-accounts-overview>组管理的服务账号（Group Managed Service Accounts，GMSA）</a>。
组管理的服务账号是活动目录（Active Directory）的一种特殊类型，提供自动化的
密码管理、简化的服务主体名称（Service Principal Name，SPN）管理以及跨多个
服务器将管理操作委派给其他管理员等能力。</p><p>在 Kubernetes 环境中，GMSA 凭据规约配置为 Kubernetes 集群范围的自定义资源
（Custom Resources）形式。Windows Pod 以及各 Pod 中的每个容器可以配置为
使用 GMSA 来完成基于域（Domain）的操作（例如，Kerberos 身份认证），以便
与其他 Windows 服务相交互。</p><h2 id=准备开始>准备开始</h2><p>你需要一个 Kubernetes 集群，以及 <code>kubectl</code> 命令行工具，且工具必须已配置
为能够与你的集群通信。集群预期包含 Windows 工作节点。
本节讨论需要为每个集群执行一次的初始操作。</p><h3 id=安装-gmsacredentialspec-crd>安装 GMSACredentialSpec CRD</h3><p>你需要在集群上配置一个用于 GMSA 凭据规约资源的
<a href=/zh-cn/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/>CustomResourceDefinition</a>(CRD)，
以便定义类型为 <code>GMSACredentialSpec</code> 的自定义资源。
首先下载 GMSA CRD <a href=https://github.com/kubernetes-sigs/windows-gmsa/blob/master/admission-webhook/deploy/gmsa-crd.yml>YAML</a>
并将其保存为 <code>gmsa-crd.yaml</code>。接下来执行 <code>kubectl apply -f gmsa-crd.yaml</code>
安装 CRD。</p><h3 id=安装-webhook-来验证-gmsa-用户>安装 Webhook 来验证 GMSA 用户</h3><p>你需要为 Kubernetes 集群配置两个 Webhook，在 Pod 或容器级别填充和检查
GMSA 凭据规约引用。</p><ol><li><p>一个修改模式（Mutating）的 Webhook，将对 GMSA 的引用（在 Pod 规约中体现为名字）
展开为完整凭据规约的 JSON 形式，并保存回 Pod 规约中。</p></li><li><p>一个验证模式（Validating）的 Webhook，确保对 GMSA 的所有引用都是已经授权
给 Pod 的服务账号使用的。</p></li></ol><p>安装以上 Webhook 及其相关联的对象需要执行以下步骤：</p><ol><li><p>创建一个证书密钥对（用于允许 Webhook 容器与集群通信）</p></li><li><p>安装一个包含如上证书的 Secret</p></li><li><p>创建一个包含核心 Webhook 逻辑的 Deployment</p></li><li><p>创建引用该 Deployment 的 Validating Webhook 和 Mutating Webhook 配置</p></li></ol><p>你可以使用<a href=https://github.com/kubernetes-sigs/windows-gmsa/blob/master/admission-webhook/deploy/deploy-gmsa-webhook.sh>这个脚本</a>
来部署和配置上述 GMSA Webhook 及相关联的对象。你还可以在运行脚本时设置 <code>--dry-run=server</code>
选项以便审查脚本将会对集群做出的变更。</p><p>脚本所使用的 <a href=https://github.com/kubernetes-sigs/windows-gmsa/blob/master/admission-webhook/deploy/gmsa-webhook.yml.tpl>YAML 模板</a>
也可用于手动部署 Webhook 及相关联的对象，不过需要对其中的参数作适当替换。</p><h2 id=在活动目录中配置-gmsa-和-windows-节点>在活动目录中配置 GMSA 和 Windows 节点</h2><p>在配置 Kubernetes 中的 Pod 以使用 GMSA 之前，需要按
<a href=https://docs.microsoft.com/en-us/windows-server/security/group-managed-service-accounts/getting-started-with-group-managed-service-accounts#BKMK_Step1>Windows GMSA 文档</a>
中描述的那样先在活动目录中准备好期望的 GMSA。
Windows 工作节点（作为 Kubernetes 集群的一部分）需要被配置到活动目录中，以便
访问与期望的 GSMA 相关联的秘密凭据数据。这一操作的描述位于
<a href=https://docs.microsoft.com/en-us/windows-server/security/group-managed-service-accounts/getting-started-with-group-managed-service-accounts#to-add-member-hosts-using-the-set-adserviceaccount-cmdlet>Windows GMSA 文档</a>
中。</p><h2 id=创建-gmsa-凭据规约资源>创建 GMSA 凭据规约资源</h2><p>当（如前所述）安装了 GMSACredentialSpec CRD 之后，你就可以配置包含 GMSA 凭据
规约的自定义资源了。GMSA 凭据规约中并不包含秘密或敏感数据。
其中包含的信息主要用于容器运行时，便于后者向 Windows 描述容器所期望的 GMSA。
GMSA 凭据规约可以使用
<a href=https://github.com/kubernetes-sigs/windows-gmsa/tree/master/scripts/GenerateCredentialSpecResource.ps1>PowerShell 脚本</a>
以 YAML 格式生成。</p><p>下面是手动以 JSON 格式生成 GMSA 凭据规约并对其进行 YAML 转换的步骤：</p><ol><li><p>导入 CredentialSpec <a href=https://github.com/MicrosoftDocs/Virtualization-Documentation/blob/live/windows-server-container-tools/ServiceAccounts/CredentialSpec.psm1>模块</a>: <code>ipmo CredentialSpec.psm1</code></p></li><li><p>使用 <code>New-CredentialSpec</code> 来创建一个 JSON 格式的凭据规约。
要创建名为 <code>WebApp1</code> 的 GMSA 凭据规约，调用
<code>New-CredentialSpec -Name WebApp1 -AccountName WebApp1 -Domain $(Get-ADDomain -Current LocalComputer)</code>。</p></li><li><p>使用 <code>Get-CredentialSpec</code> 来显示 JSON 文件的路径。</p></li><li><p>将凭据规约从 JSON 格式转换为 YAML 格式，并添加必要的头部字段
<code>apiVersion</code>、<code>kind</code>、<code>metadata</code> 和 <code>credspec</code>，使其成为一个可以在
Kubernetes 中配置的 GMSACredentialSpec 自定义资源。</p></li></ol><p>下面的 YAML 配置描述的是一个名为 <code>gmsa-WebApp1</code> 的 GMSA 凭据规约：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>windows.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>GMSACredentialSpec<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>gmsa-WebApp1 <span style=color:#bbb> </span><span style=color:#080;font-style:italic># 这是随意起的一个名字，将用作引用</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>credspec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ActiveDirectoryConfig</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>GroupManagedServiceAccounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>Name</span>:<span style=color:#bbb> </span>WebApp1  <span style=color:#bbb> </span><span style=color:#080;font-style:italic># GMSA 账号的用户名</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>Scope</span>:<span style=color:#bbb> </span>CONTOSO <span style=color:#bbb> </span><span style=color:#080;font-style:italic># NETBIOS 域名</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>Name</span>:<span style=color:#bbb> </span>WebApp1  <span style=color:#bbb> </span><span style=color:#080;font-style:italic># GMSA 账号的用户名</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>Scope</span>:<span style=color:#bbb> </span>contoso.com<span style=color:#bbb> </span><span style=color:#080;font-style:italic># DNS 域名</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>CmsPlugins</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- ActiveDirectory<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>DomainJoinConfig</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>DnsName</span>:<span style=color:#bbb> </span>contoso.com <span style=color:#bbb> </span><span style=color:#080;font-style:italic># DNS 域名</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>DnsTreeName</span>:<span style=color:#bbb> </span>contoso.com<span style=color:#bbb> </span><span style=color:#080;font-style:italic># DNS 域名根</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>Guid</span>:<span style=color:#bbb> </span>244818ae-87ac-4fcd-92ec-e79e5252348a <span style=color:#bbb> </span><span style=color:#080;font-style:italic># GUID</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>MachineAccountName</span>:<span style=color:#bbb> </span>WebApp1<span style=color:#bbb> </span><span style=color:#080;font-style:italic># GMSA 账号的用户名</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>NetBiosName</span>:<span style=color:#bbb> </span>CONTOSO <span style=color:#bbb> </span><span style=color:#080;font-style:italic># NETBIOS 域名</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>Sid</span>:<span style=color:#bbb> </span>S-1-5-21-2126449477-2524075714-3094792973<span style=color:#bbb> </span><span style=color:#080;font-style:italic># GMSA 的 SID</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>上面的凭据规约资源可以保存为 <code>gmsa-Webapp1-credspec.yaml</code>，之后使用
<code>kubectl apply -f gmsa-Webapp1-credspec.yml</code> 应用到集群上。</p><h2 id=配置集群角色以启用对特定-gmsa-凭据规约的-rbac>配置集群角色以启用对特定 GMSA 凭据规约的 RBAC</h2><p>你需要为每个 GMSA 凭据规约资源定义集群角色。
该集群角色授权某主体（通常是一个服务账号）对特定的 GMSA 资源执行 <code>use</code> 动作。
下面的示例显示的是一个集群角色，对前文创建的凭据规约 <code>gmsa-WebApp1</code> 执行鉴权。
将此文件保存为 <code>gmsa-webapp1-role.yaml</code> 并执行 <code>kubectl apply -f gmsa-webapp1-role.yaml</code>。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#080;font-style:italic># 创建集群角色读取凭据规约</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>webapp1-role<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;windows.k8s.io&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;gmsacredentialspecs&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;use&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceNames</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;gmsa-WebApp1&#34;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=将角色指派给要使用特定-gmsa-凭据规约的服务账号>将角色指派给要使用特定 GMSA 凭据规约的服务账号</h2><p>你需要将某个服务账号（Pod 配置所对应的那个）绑定到前文创建的集群角色上。
这一绑定操作实际上授予该服务账号使用所指定的 GMSA 凭据规约资源的访问权限。
下面显示的是一个绑定到集群角色 <code>webapp1-role</code> 上的 default 服务账号，使之
能够使用前面所创建的 <code>gmsa-WebApp1</code> 凭据规约资源。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>RoleBinding<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>allow-default-svc-account-read-on-gmsa-WebApp1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ServiceAccount<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>roleRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>webapp1-role<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=在-pod-规约中配置-gmsa-凭据规约引用>在 Pod 规约中配置 GMSA 凭据规约引用</h2><p>Pod 规约字段 <code>securityContext.windowsOptions.gmsaCredentialSpecName</code> 可用来
设置对指定 GMSA 凭据规约自定义资源的引用。
设置此引用将会配置 Pod 中的所有容器使用所给的 GMSA。
下面是一个 Pod 规约示例，其中包含了对 <code>gmsa-WebApp1</code> 凭据规约的引用：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>with-creds<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>with-creds<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>with-creds<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>with-creds<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>windowsOptions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>gmsaCredentialSpecName</span>:<span style=color:#bbb> </span>gmsa-webapp1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>mcr.microsoft.com/windows/servercore/iis:windowsservercore-ltsc2019<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>Always<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>iis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>nodeSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>kubernetes.io/os</span>:<span style=color:#bbb> </span>windows<span style=color:#bbb>
</span></span></span></code></pre></div><p>Pod 中的各个容器也可以使用对应容器的 <code>securityContext.windowsOptions.gmsaCredentialSpecName</code>
字段来设置期望使用的 GMSA 凭据规约。
例如：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>with-creds<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>with-creds<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>with-creds<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>run</span>:<span style=color:#bbb> </span>with-creds<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>mcr.microsoft.com/windows/servercore/iis:windowsservercore-ltsc2019<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>Always<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>iis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>windowsOptions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>gmsaCredentialSpecName</span>:<span style=color:#bbb> </span>gmsa-Webapp1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>nodeSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>kubernetes.io/os</span>:<span style=color:#bbb> </span>windows<span style=color:#bbb>
</span></span></span></code></pre></div><p>当 Pod 规约中填充了 GMSA 相关字段（如上所述），在集群中应用 Pod 规约时会依次
发生以下事件：</p><ol><li><p>Mutating Webhook 解析对 GMSA 凭据规约资源的引用，并将其全部展开，
得到 GMSA 凭据规约的实际内容。</p></li><li><p>Validating Webhook 确保与 Pod 相关联的服务账号有权在所给的 GMSA 凭据规约
上执行 <code>use</code> 动作。</p></li><li><p>容器运行时为每个 Windows 容器配置所指定的 GMSA 凭据规约，这样容器就可以以
活动目录中该 GMSA 所代表的身份来执行操作，使用该身份来访问域中的服务。</p></li></ol><h2 id=使用主机名或-fqdn-对网络共享进行身份验证>使用主机名或 FQDN 对网络共享进行身份验证</h2><p>如果你在使用主机名或 FQDN 从 Pod 连接到 SMB 共享时遇到问题，但能够通过其 IPv4 地址访问共享，
请确保在 Windows 节点上设置了以下注册表项。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cmd data-lang=cmd><span style=display:flex><span>reg add <span style=color:#b44>&#34;HKLM\SYSTEM\CurrentControlSet\Services\hns\State&#34;</span> /v EnableCompartmentNamespace /t REG_DWORD /d 1
</span></span></code></pre></div><p>然后需要重新创建正在运行的 Pod 以使行为更改生效。
有关如何使用此注册表项的更多信息，请参见<a href=https://github.com/microsoft/hcsshim/blob/885f896c5a8548ca36c88c4b87fd2208c8d16543/internal/uvm/create.go#L74-L83>此处</a>。</p><h2 id=故障排查>故障排查</h2><p>如果在你的环境中配置 GMSA 时遇到了困难，你可以采取若干步骤来排查可能的故障。</p><p>首先，确保 credspec 已传递给 Pod。为此，你需要先运行 <code>exec</code>
进入到你的一个 Pod 中并检查 <code>nltest.exe /parentdomain</code> 命令的输出。</p><p>在下面的例子中，Pod 未能正确地获得凭据规约：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-PowerShell data-lang=PowerShell><span style=display:flex><span>kubectl exec -it <span style=color:#a2f>iis-auth</span>-<span style=color:#666>7776966999</span>-n5nzr powershell.exe
</span></span></code></pre></div><p><code>nltest.exe /parentdomain</code> 导致以下错误：</p><pre tabindex=0><code class=language-output data-lang=output>Getting parent domain failed: Status = 1722 0x6ba RPC_S_SERVER_UNAVAILABLE
</code></pre><p>如果 Pod 未能正确获得凭据规约，则下一步就要检查与域之间的通信。
首先，从 Pod 内部快速执行一个 nslookup 操作，找到域根。</p><p>这一操作会告诉我们三件事情：</p><ol><li>Pod 能否访问域控制器（DC）</li><li>DC 能否访问 Pod</li><li>DNS 是否正常工作</li></ol><p>如果 DNS 和通信测试通过，接下来你需要检查是否 Pod 已经与域之间建立了
安全通信通道。要执行这一检查，你需要再次通过 <code>exec</code> 进入到你的 Pod 中
并执行 <code>nltest.exe /query</code> 命令。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-PowerShell data-lang=PowerShell><span style=display:flex><span>nltest.exe /query
</span></span></code></pre></div><p>结果输出如下：</p><pre tabindex=0><code class=language-output data-lang=output>I_NetLogonControl failed: Status = 1722 0x6ba RPC_S_SERVER_UNAVAILABLE
</code></pre><p>这告诉我们，由于某种原因，Pod 无法使用 credspec 中指定的帐户登录到域。
你可以尝试通过运行以下命令来修复安全通道：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-PowerShell data-lang=PowerShell><span style=display:flex><span>nltest /sc_reset<span>:</span>domain.example
</span></span></code></pre></div><p>如果命令成功，你将看到类似以下内容的输出：</p><pre tabindex=0><code>Flags: 30 HAS_IP  HAS_TIMESERV
Trusted DC Name \\dc10.domain.example
Trusted DC Connection Status Status = 0 0x0 NERR_Success
The command completed successfully
</code></pre><p>如果以上命令修复了错误，你可以通过将以下生命周期回调添加到你的 Pod 规约中来自动执行该步骤。
如果这些操作没有修复错误，你将需要再次检查你的 credspec 并确认它是正确和完整的。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>registry.domain.example/iis-auth:1809v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>lifecycle</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>postStart</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>exec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;powershell.exe&#34;</span>,<span style=color:#b44>&#34;-command&#34;</span>,<span style=color:#b44>&#34;do { Restart-Service -Name netlogon } while ( $($Result = (nltest.exe /query); if ($Result -like &#39;*0x0 NERR_Success*&#39;) {return $true} else {return $false}) -eq $false)&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>IfNotPresent<span style=color:#bbb>
</span></span></span></code></pre></div><p>如果你向你的 Pod 规约中添加如上所示的 <code>lifecycle</code> 节，则 Pod 会自动执行所
列举的命令来重启 <code>netlogon</code> 服务，直到 <code>nltest.exe /query</code>
命令返回时没有错误信息。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-f5da7517bee8a8807431d9fc65263b39>4 - 为 Windows 的 Pod 和容器配置 RunAsUserName</h1><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.18 [stable]</code></div><p>本页展示如何为运行为在 Windows 节点上运行的 Pod 和容器配置 <code>RunAsUserName</code>。
大致相当于 Linux 上的 <code>runAsUser</code>，允许在容器中以与默认值不同的用户名运行应用。</p><h2 id=准备开始>准备开始</h2><p>你必须有一个 Kubernetes 集群，并且 kubectl 必须能和集群通信。
集群应该要有 Windows 工作节点，将在其中调度运行 Windows 工作负载的 pod 和容器。</p><h2 id=set-the-username-for-a-pod>为 Pod 设置 Username</h2><p>要指定运行 Pod 容器时所使用的用户名，请在 Pod 声明中包含 <code>securityContext</code>
(<a href=/docs/reference/generated/kubernetes-api/v1.25/#podsecuritycontext-v1-core>PodSecurityContext</a>) 字段，
并在其内部包含 <code>windowsOptions</code>
(<a href=/docs/reference/generated/kubernetes-api/v1.25/#windowssecuritycontextoptions-v1-core>WindowsSecurityContextOptions</a>)
字段的 <code>runAsUserName</code> 字段。</p><p>你为 Pod 指定的 Windows SecurityContext 选项适用于该 Pod 中（包括 init 容器）的所有容器。</p><p>这儿有一个已经设置了 <code>runAsUserName</code> 字段的 Windows Pod 的配置文件：</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/windows/run-as-username-pod.yaml download=windows/run-as-username-pod.yaml><code>windows/run-as-username-pod.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("windows-run-as-username-pod-yaml")' title="Copy windows/run-as-username-pod.yaml to clipboard"></img></div><div class=includecode id=windows-run-as-username-pod-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>run-as-username-pod-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>windowsOptions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>runAsUserName</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;ContainerUser&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>run-as-username-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>mcr.microsoft.com/windows/servercore:ltsc2019<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;ping&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-t&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;localhost&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodeSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/os</span>:<span style=color:#bbb> </span>windows<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>创建 Pod：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/windows/run-as-username-pod.yaml
</span></span></code></pre></div><p>验证 Pod 容器是否在运行：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod run-as-username-pod-demo
</span></span></code></pre></div><p>获取该容器的 shell：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> -it run-as-username-pod-demo -- powershell
</span></span></code></pre></div><p>检查运行 shell 的用户的用户名是否正确：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#a2f>echo </span><span style=color:#b8860b>$env:USERNAME</span>
</span></span></code></pre></div><p>输出结果应该是这样：</p><pre tabindex=0><code>ContainerUser
</code></pre><h2 id=set-the-username-for-a-container>为容器设置 Username</h2><p>要指定运行容器时所使用的用户名，请在容器清单中包含 <code>securityContext</code>
(<a href=/docs/reference/generated/kubernetes-api/v1.25/#securitycontext-v1-core>SecurityContext</a>)
字段，并在其内部包含 <code>windowsOptions</code>
（<a href=/docs/reference/generated/kubernetes-api/v1.25/#windowssecuritycontextoptions-v1-core>WindowsSecurityContextOptions</a>）
字段的 <code>runAsUserName</code> 字段。</p><p>你为容器指定的 Windows SecurityContext 选项仅适用于该容器，并且它会覆盖 Pod 级别设置。</p><p>这里有一个 Pod 的配置文件，其中只有一个容器，并且在 Pod 级别和容器级别都设置了 <code>runAsUserName</code>：</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/windows/run-as-username-container.yaml download=windows/run-as-username-container.yaml><code>windows/run-as-username-container.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("windows-run-as-username-container-yaml")' title="Copy windows/run-as-username-container.yaml to clipboard"></img></div><div class=includecode id=windows-run-as-username-container-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>run-as-username-container-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>windowsOptions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>runAsUserName</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;ContainerUser&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>run-as-username-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>mcr.microsoft.com/windows/servercore:ltsc2019<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;ping&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-t&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;localhost&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>windowsOptions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>runAsUserName</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;ContainerAdministrator&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodeSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/os</span>:<span style=color:#bbb> </span>windows<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>创建 Pod：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/windows/run-as-username-container.yaml
</span></span></code></pre></div><p>验证 Pod 容器是否在运行：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod run-as-username-container-demo
</span></span></code></pre></div><p>获取该容器的 shell：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> -it run-as-username-container-demo -- powershell
</span></span></code></pre></div><p>检查运行 shell 的用户的用户名是否正确（应该是容器级别设置的那个）：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#a2f>echo </span><span style=color:#b8860b>$env:USERNAME</span>
</span></span></code></pre></div><p>输出结果应该是这样：</p><pre tabindex=0><code>ContainerAdministrator
</code></pre><h2 id=windows-username-limitations>Windows Username 的局限性</h2><p>想要使用此功能，在 <code>runAsUserName</code> 字段中设置的值必须是有效的用户名。
它必须是 <code>DOMAIN\USER</code> 这种格式，其中 <code>DOMAIN\</code> 是可选的。
Windows 用户名不区分大小写。此外，关于 <code>DOMAIN</code> 和 <code>USER</code> 还有一些限制：</p><ul><li><code>runAsUserName</code> 字段不能为空，并且不能包含控制字符（ASCII 值：<code>0x00-0x1F</code>、<code>0x7F</code>）</li><li><code>DOMAIN</code> 必须是 NetBios 名称或 DNS 名称，每种名称都有各自的局限性：<ul><li>NetBios 名称：最多 15 个字符，不能以 <code>.</code>（点）开头，并且不能包含以下字符：<code>\ / : * ? " &lt; > |</code></li><li>DNS 名称：最多 255 个字符，只能包含字母、数字、点和中划线，并且不能以 <code>.</code>（点）或 <code>-</code>（中划线）开头和结尾。</li></ul></li><li><code>USER</code> 最多不超过 20 个字符，不能 <strong>只</strong> 包含点或空格，并且不能包含以下字符：<code>" / \ [ ] : ; | = , + * ? &lt; > @</code></li></ul><p><code>runAsUserName</code> 字段接受的值的一些示例：<code>ContainerAdministrator</code>、<code>ContainerUser</code>、
<code>NT AUTHORITY\NETWORK SERVICE</code>、<code>NT AUTHORITY\LOCAL SERVICE</code>。</p><p>关于这些限制的更多信息，可以查看<a href=https://support.microsoft.com/en-us/help/909264/naming-conventions-in-active-directory-for-computers-domains-sites-and>这里</a>和<a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.localaccounts/new-localuser?view=powershell-5.1">这里</a>。</p><h2 id=接下来>接下来</h2><ul><li><a href=/zh-cn/docs/concepts/windows/user-guide/>Kubernetes 中调度 Windows 容器的指南</a></li><li><a href=/zh-cn/docs/concepts/windows/user-guide/#managing-workload-identity-with-group-managed-service-accounts>使用组托管服务帐户（GMSA）管理工作负载身份</a></li><li><a href=/zh-cn/docs/tasks/configure-pod-container/configure-gmsa/>Windows 下 pod 和容器的 GMSA 配置</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-8555af270ae7122cc0464bab3f5d1609>5 - 为容器和 Pods 分配 CPU 资源</h1><p>本页面展示如何为容器设置 CPU <strong>request（请求）</strong> 和 CPU <strong>limit（限制）</strong>。
容器使用的 CPU 不能超过所配置的限制。
如果系统有空闲的 CPU 时间，则可以保证给容器分配其所请求数量的 CPU 资源。</p><h2 id=准备开始>准备开始</h2><p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li></ul>要获知版本信息，请输入 <code>kubectl version</code>.</p><p>集群中的每个节点必须至少有 1 个 CPU 可用才能运行本任务中的示例。</p><p>本页的一些步骤要求你在集群中运行
<a href=https://github.com/kubernetes-sigs/metrics-server>metrics-server</a>
服务。如果你的集群中已经有正在运行的 metrics-server 服务，可以跳过这些步骤。</p><p>如果你正在运行 <a class=glossary-tooltip title='Minikube 是用来在本地运行 Kubernetes 的一种工具。' data-toggle=tooltip data-placement=top href=/docs/getting-started-guides/minikube/ target=_blank aria-label=Minikube>Minikube</a>，请运行以下命令启用 metrics-server：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>minikube addons <span style=color:#a2f>enable</span> metrics-server
</span></span></code></pre></div><p>查看 metrics-server（或者其他资源指标 API <code>metrics.k8s.io</code> 服务提供者）是否正在运行，
请键入以下命令：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get apiservices
</span></span></code></pre></div><p>如果资源指标 API 可用，则会输出将包含一个对 <code>metrics.k8s.io</code> 的引用。</p><pre tabindex=0><code>NAME
v1beta1.metrics.k8s.io
</code></pre><h2 id=create-a-namespace>创建一个名字空间</h2><p>创建一个<a class=glossary-tooltip title='名字空间是 Kubernetes 用来支持隔离单个集群中的资源组的一种抽象。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/overview/working-with-objects/namespaces/ target=_blank aria-label=名字空间>名字空间</a>，以便将
本练习中创建的资源与集群的其余部分资源隔离。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create namespace cpu-example
</span></span></code></pre></div><h2 id=specify-a-CPU-request-and-a-CPU-limit>指定 CPU 请求和 CPU 限制</h2><p>要为容器指定 CPU 请求，请在容器资源清单中包含 <code>resources: requests</code> 字段。
要指定 CPU 限制，请包含 <code>resources:limits</code>。</p><p>在本练习中，你将创建一个具有一个容器的 Pod。容器将会请求 0.5 个 CPU，而且最多限制使用 1 个 CPU。
这是 Pod 的配置文件：</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/pods/resource/cpu-request-limit.yaml download=pods/resource/cpu-request-limit.yaml><code>pods/resource/cpu-request-limit.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-resource-cpu-request-limit-yaml")' title="Copy pods/resource/cpu-request-limit.yaml to clipboard"></img></div><div class=includecode id=pods-resource-cpu-request-limit-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cpu-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>cpu-example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cpu-demo-ctr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>vish/stress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;0.5&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- -cpus<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;2&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>配置文件的 <code>args</code> 部分提供了容器启动时的参数。
<code>-cpus "2"</code> 参数告诉容器尝试使用 2 个 CPU。</p><p>创建 Pod：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/resource/cpu-request-limit.yaml --namespace<span style=color:#666>=</span>cpu-example
</span></span></code></pre></div><p>验证所创建的 Pod 处于 Running 状态</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod cpu-demo --namespace<span style=color:#666>=</span>cpu-example
</span></span></code></pre></div><p>查看显示关于 Pod 的详细信息：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod cpu-demo --output<span style=color:#666>=</span>yaml --namespace<span style=color:#666>=</span>cpu-example
</span></span></code></pre></div><p>输出显示 Pod 中的一个容器的 CPU 请求为 500 milliCPU，并且 CPU 限制为 1 个 CPU。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>500m<span style=color:#bbb>
</span></span></span></code></pre></div><p>使用 <code>kubectl top</code> 命令来获取该 Pod 的指标：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl top pod cpu-demo --namespace<span style=color:#666>=</span>cpu-example
</span></span></code></pre></div><p>此示例输出显示 Pod 使用的是 974 milliCPU，即略低于 Pod 配置中指定的 1 个 CPU 的限制。</p><pre tabindex=0><code>NAME                        CPU(cores)   MEMORY(bytes)
cpu-demo                    974m         &lt;something&gt;
</code></pre><p>回想一下，通过设置 <code>-cpu "2"</code>，你将容器配置为尝试使用 2 个 CPU，
但是容器只被允许使用大约 1 个 CPU。
容器的 CPU 用量受到限制，因为该容器正尝试使用超出其限制的 CPU 资源。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong> CPU 使用率低于 1.0 的另一种可能的解释是，节点可能没有足够的 CPU 资源可用。
回想一下，此练习的先决条件需要你的节点至少具有 1 个 CPU 可用。
如果你的容器在只有 1 个 CPU 的节点上运行，则容器无论为容器指定的 CPU 限制如何，
都不能使用超过 1 个 CPU。</div><h2 id=cpu-units>CPU 单位</h2><p>CPU 资源以 <strong>CPU</strong> 单位度量。Kubernetes 中的一个 CPU 等同于：</p><ul><li>1 个 AWS vCPU</li><li>1 个 GCP核心</li><li>1 个 Azure vCore</li><li>裸机上具有超线程能力的英特尔处理器上的 1 个超线程</li></ul><p>小数值是可以使用的。一个请求 0.5 CPU 的容器保证会获得请求 1 个 CPU 的容器的 CPU 的一半。
你可以使用后缀 <code>m</code> 表示毫。例如 <code>100m</code> CPU、100 milliCPU 和 0.1 CPU 都相同。
精度不能超过 1m。</p><p>CPU 请求只能使用绝对数量，而不是相对数量。0.1 在单核、双核或 48 核计算机上的 CPU 数量值是一样的。</p><p>删除 Pod：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pod cpu-demo --namespace<span style=color:#666>=</span>cpu-example
</span></span></code></pre></div><h2 id=specify-a-CPU-request-that-is-too-big-for-your-nodes>设置超过节点能力的 CPU 请求</h2><p>CPU 请求和限制与都与容器相关，但是我们可以考虑一下 Pod 具有对应的 CPU 请求和限制这样的场景。
Pod 对 CPU 用量的请求等于 Pod 中所有容器的请求数量之和。
同样，Pod 的 CPU 资源限制等于 Pod 中所有容器 CPU 资源限制数之和。</p><p>Pod 调度是基于资源请求值来进行的。
仅在某节点具有足够的 CPU 资源来满足 Pod CPU 请求时，Pod 将会在对应节点上运行：</p><p>在本练习中，你将创建一个 Pod，该 Pod 的 CPU 请求对于集群中任何节点的容量而言都会过大。
下面是 Pod 的配置文件，其中有一个容器。容器请求 100 个 CPU，这可能会超出集群中任何节点的容量。</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/pods/resource/cpu-request-limit-2.yaml download=pods/resource/cpu-request-limit-2.yaml><code>pods/resource/cpu-request-limit-2.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-resource-cpu-request-limit-2-yaml")' title="Copy pods/resource/cpu-request-limit-2.yaml to clipboard"></img></div><div class=includecode id=pods-resource-cpu-request-limit-2-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cpu-demo-2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>cpu-example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cpu-demo-ctr-2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>vish/stress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;100&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;100&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- -cpus<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;2&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>创建 Pod：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/resource/cpu-request-limit-2.yaml --namespace<span style=color:#666>=</span>cpu-example
</span></span></code></pre></div><p>查看该 Pod 的状态：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod cpu-demo-2 --namespace<span style=color:#666>=</span>cpu-example
</span></span></code></pre></div><p>输出显示 Pod 状态为 Pending。也就是说，Pod 未被调度到任何节点上运行，
并且 Pod 将无限期地处于 Pending 状态：</p><pre tabindex=0><code>NAME         READY     STATUS    RESTARTS   AGE
cpu-demo-2   0/1       Pending   0          7m
</code></pre><p>查看有关 Pod 的详细信息，包含事件：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe pod cpu-demo-2 --namespace<span style=color:#666>=</span>cpu-example
</span></span></code></pre></div><p>输出显示由于节点上的 CPU 资源不足，无法调度容器：</p><pre tabindex=0><code>Events:
  Reason                        Message
  ------                        -------
  FailedScheduling      No nodes are available that match all of the following predicates:: Insufficient cpu (3).
</code></pre><p>删除你的 Pod：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pod cpu-demo-2 --namespace<span style=color:#666>=</span>cpu-example
</span></span></code></pre></div><h2 id=if-you-do-not-specify-a-cpu-limit>如果不指定 CPU 限制</h2><p>如果你没有为容器指定 CPU 限制，则会发生以下情况之一：</p><ul><li><p>容器在可以使用的 CPU 资源上没有上限。因而可以使用所在节点上所有的可用 CPU 资源。</p></li><li><p>容器在具有默认 CPU 限制的名字空间中运行，系统会自动为容器设置默认限制。
集群管理员可以使用
<a href=/docs/reference/generated/kubernetes-api/v1.25/#limitrange-v1-core/>LimitRange</a>
指定 CPU 限制的默认值。</p></li></ul><h2 id=if-you-specify-a-CPU-limit-but-do-not-specify-a-CPU-request>如果你设置了 CPU 限制但未设置 CPU 请求</h2><p>如果你为容器指定了 CPU 限制值但未为其设置 CPU 请求，Kubernetes 会自动为其
设置与 CPU 限制相同的 CPU 请求值。类似的，如果容器设置了内存限制值但未设置
内存请求值，Kubernetes 也会为其设置与内存限制值相同的内存请求。</p><h2 id=motivation-for-CPU-requests-and-limits>CPU 请求和限制的初衷</h2><p>通过配置你的集群中运行的容器的 CPU 请求和限制，你可以有效利用集群上可用的 CPU 资源。
通过将 Pod CPU 请求保持在较低水平，可以使 Pod 更有机会被调度。
通过使 CPU 限制大于 CPU 请求，你可以完成两件事：</p><ul><li><p>Pod 可能会有突发性的活动，它可以利用碰巧可用的 CPU 资源。</p></li><li><p>Pod 在突发负载期间可以使用的 CPU 资源数量仍被限制为合理的数量。</p></li></ul><h2 id=clean-up>清理</h2><p>删除名字空间：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete namespace cpu-example
</span></span></code></pre></div><h2 id=接下来>接下来</h2><h3 id=for-app-developers>针对应用开发者</h3><ul><li><p><a href=/zh-cn/docs/tasks/configure-pod-container/assign-memory-resource/>将内存资源分配给容器和 Pod</a></p></li><li><p><a href=/zh-cn/docs/tasks/configure-pod-container/quality-service-pod/>配置 Pod 服务质量</a></p></li></ul><h3 id=针对集群管理员-for-cluster-administrators>针对集群管理员 {for-cluster-administrators}</h3><ul><li><a href=/zh-cn/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/>配置名字空间的默认内存请求和限制</a></li><li><a href=/zh-cn/docs/tasks/administer-cluster/manage-resources/cpu-default-namespace/>为名字空间配置默认 CPU 请求和限制</a></li><li><a href=/zh-cn/docs/tasks/administer-cluster//manage-resources/memory-constraint-namespace/>为名字空间配置最小和最大内存限制</a></li><li><a href=/zh-cn/docs/tasks/administer-cluster/manage-resources/cpu-constraint-namespace/>为名字空间配置最小和最大 CPU 约束</a></li><li><a href=/zh-cn/docs/tasks/administer-cluster/manage-resources/quota-memory-cpu-namespace/>为名字空间配置内存和 CPU 配额</a></li><li><a href=/zh-cn/docs/tasks/administer-cluster/manage-resources/quota-pod-namespace/>为名字空间配置 Pod 配额</a></li><li><a href=/zh-cn/docs/tasks/administer-cluster/quota-api-object/>配置 API 对象的配额</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-904cea8c8efd5c0d33adbfe579ec2dd2>6 - 配置 Pod 的服务质量</h1><p>本页介绍怎样配置 Pod 让其获得特定的服务质量（QoS）类。Kubernetes 使用 QoS 类来决定 Pod 的调度和驱逐策略。</p><h2 id=准备开始>准备开始</h2><p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li></ul>要获知版本信息，请输入 <code>kubectl version</code>.</p><h2 id=qos-classes>QoS 类</h2><p>Kubernetes 创建 Pod 时就给它指定了下列一种 QoS 类：</p><ul><li>Guaranteed</li><li>Burstable</li><li>BestEffort</li></ul><h2 id=create-a-namespace>创建命名空间</h2><p>创建一个命名空间，以便将本练习所创建的资源与集群的其余资源相隔离。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create namespace qos-example
</span></span></code></pre></div><h2 id=create-a-pod-that-gets-assigned-a-qos-class-of-guaranteed>创建一个 QoS 类为 Guaranteed 的 Pod</h2><p>对于 QoS 类为 Guaranteed 的 Pod：</p><ul><li>Pod 中的每个容器都必须指定内存限制和内存请求。</li><li>对于 Pod 中的每个容器，内存限制必须等于内存请求。</li><li>Pod 中的每个容器都必须指定 CPU 限制和 CPU 请求。</li><li>对于 Pod 中的每个容器，CPU 限制必须等于 CPU 请求。</li></ul><p>这些限制同样适用于初始化容器和应用程序容器。</p><p>下面是包含一个容器的 Pod 配置文件。
该容器设置了内存请求和内存限制，值都是 200 MiB。
该容器设置了 CPU 请求和 CPU 限制，值都是 700 milliCPU：</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/pods/qos/qos-pod.yaml download=pods/qos/qos-pod.yaml><code>pods/qos/qos-pod.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-qos-qos-pod-yaml")' title="Copy pods/qos/qos-pod.yaml to clipboard"></img></div><div class=includecode id=pods-qos-qos-pod-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>qos-example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-ctr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;200Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;700m&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;200Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;700m&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>创建 Pod：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/qos/qos-pod.yaml --namespace<span style=color:#666>=</span>qos-example
</span></span></code></pre></div><p>查看 Pod 详情：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod qos-demo --namespace<span style=color:#666>=</span>qos-example --output<span style=color:#666>=</span>yaml
</span></span></code></pre></div><p>结果表明 Kubernetes 为 Pod 配置的 QoS 类为 Guaranteed。
结果也确认了 Pod 容器设置了与内存限制匹配的内存请求，设置了与 CPU 限制匹配的 CPU 请求。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>700m<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>200Mi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span>700m<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>200Mi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>qosClass</span>:<span style=color:#bbb> </span>Guaranteed<span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>如果容器指定了自己的内存限制，但没有指定内存请求，Kubernetes 会自动为它指定与内存限制匹配的内存请求。
同样，如果容器指定了自己的 CPU 限制，但没有指定 CPU 请求，Kubernetes 会自动为它指定与 CPU 限制匹配的 CPU 请求。</div><p>删除 Pod：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pod qos-demo --namespace<span style=color:#666>=</span>qos-example
</span></span></code></pre></div><h2 id=create-a-pod-that-gets-assigned-a-qos-class-of-burstable>创建一个 QoS 类为 Burstable 的 Pod</h2><p>如果满足下面条件，将会指定 Pod 的 QoS 类为 Burstable：</p><ul><li>Pod 不符合 Guaranteed QoS 类的标准。</li><li>Pod 中至少一个容器具有内存或 CPU 的请求或限制。</li></ul><p>下面是包含一个容器的 Pod 配置文件。
该容器设置了内存限制 200 MiB 和内存请求 100 MiB。</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/pods/qos/qos-pod-2.yaml download=pods/qos/qos-pod-2.yaml><code>pods/qos/qos-pod-2.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-qos-qos-pod-2-yaml")' title="Copy pods/qos/qos-pod-2.yaml to clipboard"></img></div><div class=includecode id=pods-qos-qos-pod-2-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>qos-example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-2-ctr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;200Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;100Mi&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>创建 Pod：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/qos/qos-pod-2.yaml --namespace<span style=color:#666>=</span>qos-example
</span></span></code></pre></div><p>查看 Pod 详情：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod qos-demo-2 --namespace<span style=color:#666>=</span>qos-example --output<span style=color:#666>=</span>yaml
</span></span></code></pre></div><p>结果表明 Kubernetes 为 Pod 配置的 QoS 类为 Burstable。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>Always<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-2-ctr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>200Mi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>100Mi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>qosClass</span>:<span style=color:#bbb> </span>Burstable<span style=color:#bbb>
</span></span></span></code></pre></div><p>删除 Pod：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pod qos-demo-2 --namespace<span style=color:#666>=</span>qos-example
</span></span></code></pre></div><h2 id=create-a-pod-that-gets-assigned-a-qos-class-of-besteffort>创建一个 QoS 类为 BestEffort 的 Pod</h2><p>对于 QoS 类为 BestEffort 的 Pod，Pod 中的容器必须没有设置内存和 CPU 限制或请求。</p><p>下面是包含一个容器的 Pod 配置文件。
该容器没有设置内存和 CPU 限制或请求。</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/pods/qos/qos-pod-3.yaml download=pods/qos/qos-pod-3.yaml><code>pods/qos/qos-pod-3.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-qos-qos-pod-3-yaml")' title="Copy pods/qos/qos-pod-3.yaml to clipboard"></img></div><div class=includecode id=pods-qos-qos-pod-3-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-3<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>qos-example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-3-ctr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>创建 Pod：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/qos/qos-pod-3.yaml --namespace<span style=color:#666>=</span>qos-example
</span></span></code></pre></div><p>查看 Pod 详情：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod qos-demo-3 --namespace<span style=color:#666>=</span>qos-example --output<span style=color:#666>=</span>yaml
</span></span></code></pre></div><p>结果表明 Kubernetes 为 Pod 配置的 QoS 类为 BestEffort。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>qosClass</span>:<span style=color:#bbb> </span>BestEffort<span style=color:#bbb>
</span></span></span></code></pre></div><p>删除 Pod：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pod qos-demo-3 --namespace<span style=color:#666>=</span>qos-example
</span></span></code></pre></div><h2 id=create-a-pod-that-has-two-containers>创建包含两个容器的 Pod</h2><p>下面是包含两个容器的 Pod 配置文件。
一个容器指定了内存请求 200 MiB。
另外一个容器没有指定任何请求和限制。</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/pods/qos/qos-pod-4.yaml download=pods/qos/qos-pod-4.yaml><code>pods/qos/qos-pod-4.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-qos-qos-pod-4-yaml")' title="Copy pods/qos/qos-pod-4.yaml to clipboard"></img></div><div class=includecode id=pods-qos-qos-pod-4-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-4<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>qos-example<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-4-ctr-1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;200Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-4-ctr-2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>注意此 Pod 满足 Burstable QoS 类的标准。
也就是说它不满足 Guaranteed QoS 类标准，因为它的一个容器设有内存请求。</p><p>创建 Pod：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/qos/qos-pod-4.yaml --namespace<span style=color:#666>=</span>qos-example
</span></span></code></pre></div><p>查看 Pod 详情：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod qos-demo-4 --namespace<span style=color:#666>=</span>qos-example --output<span style=color:#666>=</span>yaml
</span></span></code></pre></div><p>结果表明 Kubernetes 为 Pod 配置的 QoS 类为 Burstable：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-4-ctr-1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span>200Mi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>qos-demo-4-ctr-2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>qosClass</span>:<span style=color:#bbb> </span>Burstable<span style=color:#bbb>
</span></span></span></code></pre></div><p>删除 Pod：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pod qos-demo-4 --namespace<span style=color:#666>=</span>qos-example
</span></span></code></pre></div><h2 id=clean-up>环境清理</h2><p>删除命名空间：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete namespace qos-example
</span></span></code></pre></div><h2 id=接下来>接下来</h2><h3 id=应用开发者参考>应用开发者参考</h3><ul><li><p><a href=/zh-cn/docs/tasks/configure-pod-container/assign-memory-resource/>为 Pod 和容器分配内存资源</a></p></li><li><p><a href=/zh-cn/docs/tasks/configure-pod-container/assign-cpu-resource/>为 Pod 和容器分配 CPU 资源</a></p></li></ul><h3 id=集群管理员参考>集群管理员参考</h3><ul><li><p><a href=/zh-cn/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/>为命名空间配置默认的内存请求和限制</a></p></li><li><p><a href=/zh-cn/docs/tasks/administer-cluster/manage-resources/cpu-default-namespace/>为命名空间配置默认的 CPU 请求和限制</a></p></li><li><p><a href=/zh-cn/docs/tasks/administer-cluster/manage-resources/memory-constraint-namespace/>为命名空间配置最小和最大内存限制</a></p></li><li><p><a href=/zh-cn/docs/tasks/administer-cluster/manage-resources/cpu-constraint-namespace/>为命名空间配置最小和最大 CPU 限制</a></p></li><li><p><a href=/zh-cn/docs/tasks/administer-cluster/manage-resources/quota-memory-cpu-namespace/>为命名空间配置内存和 CPU 配额</a></p></li><li><p><a href=/zh-cn/docs/tasks/administer-cluster/manage-resources/quota-pod-namespace/>为命名空间配置 Pod 配额</a></p></li><li><p><a href=/zh-cn/docs/tasks/administer-cluster/quota-api-object/>为 API 对象配置配额</a></p></li><li><p><a href=/zh-cn/docs/tasks/administer-cluster/topology-manager/>控制节点上的拓扑管理策略</a></p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-4219ac6ab56a3b88d20305083d57d03c>7 - 为容器分派扩展资源</h1><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.25 [stable]</code></div><p>本文介绍如何为容器指定扩展资源。</p><h2 id=准备开始>准备开始</h2><p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li></ul>要获知版本信息，请输入 <code>kubectl version</code>.</p><p>在你开始此练习前，请先练习
<a href=/zh-cn/docs/tasks/administer-cluster/extended-resource-node/>为节点广播扩展资源</a>。
在那个练习中将配置你的一个节点来广播 dongle 资源。</p><h2 id=给-pod-分派扩展资源>给 Pod 分派扩展资源</h2><p>要请求扩展资源，需要在你的容器清单中包括 <code>resources:requests</code> 字段。
扩展资源可以使用任何完全限定名称，只是不能使用 <code>*.kubernetes.io/</code>。
有效的扩展资源名的格式为 <code>example.com/foo</code>，其中 <code>example.com</code> 应被替换为
你的组织的域名，而 <code>foo</code> 则是描述性的资源名称。</p><p>下面是包含一个容器的 Pod 配置文件：</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/pods/resource/extended-resource-pod.yaml download=pods/resource/extended-resource-pod.yaml><code>pods/resource/extended-resource-pod.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-resource-extended-resource-pod-yaml")' title="Copy pods/resource/extended-resource-pod.yaml to clipboard"></img></div><div class=includecode id=pods-resource-extended-resource-pod-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>extended-resource-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>extended-resource-demo-ctr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>example.com/dongle</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>example.com/dongle</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>在配置文件中，你可以看到容器请求了 3 个 dongles。</p><p>创建 Pod：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/resource/extended-resource-pod.yaml
</span></span></code></pre></div><p>检查 Pod 是否运行正常：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod extended-resource-demo
</span></span></code></pre></div><p>描述 Pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe pod extended-resource-demo
</span></span></code></pre></div><p>输出结果显示 dongle 请求如下：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>Limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>example.com/dongle</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>Requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>example.com/dongle</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=尝试创建第二个-pod>尝试创建第二个 Pod</h2><p>下面是包含一个容器的 Pod 配置文件，容器请求了 2 个 dongles。</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/pods/resource/extended-resource-pod-2.yaml download=pods/resource/extended-resource-pod-2.yaml><code>pods/resource/extended-resource-pod-2.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-resource-extended-resource-pod-2-yaml")' title="Copy pods/resource/extended-resource-pod-2.yaml to clipboard"></img></div><div class=includecode id=pods-resource-extended-resource-pod-2-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>extended-resource-demo-2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>extended-resource-demo-2-ctr<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>example.com/dongle</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>example.com/dongle</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Kubernetes 将不能满足 2 个 dongles 的请求，因为第一个 Pod 已经使用了 4 个可用 dongles 中的 3 个。</p><p>尝试创建 Pod：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/resource/extended-resource-pod-2.yaml
</span></span></code></pre></div><p>描述 Pod：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe pod extended-resource-demo-2
</span></span></code></pre></div><p>输出结果表明 Pod 不能被调度，因为没有一个节点上存在两个可用的 dongles。</p><pre tabindex=0><code>Conditions:
  Type    Status
  PodScheduled  False
...
Events:
  ...
  ... Warning   FailedScheduling  pod (extended-resource-demo-2) failed to fit in any node
fit failure summary on nodes : Insufficient example.com/dongle (1)
</code></pre><p>查看 Pod 的状态：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod extended-resource-demo-2
</span></span></code></pre></div><p>输出结果表明 Pod 虽然被创建了，但没有被调度到节点上正常运行。Pod 的状态为 Pending：</p><pre tabindex=0><code>NAME                       READY     STATUS    RESTARTS   AGE
extended-resource-demo-2   0/1       Pending   0          6m
</code></pre><h2 id=清理>清理</h2><p>删除本练习中创建的 Pod：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pod extended-resource-demo
</span></span><span style=display:flex><span>kubectl delete pod extended-resource-demo-2
</span></span></code></pre></div><h2 id=接下来>接下来</h2><h2 id=应用开发者参考>应用开发者参考</h2><ul><li><a href=/zh-cn/docs/tasks/configure-pod-container/assign-memory-resource/>为容器和 Pod 分配内存资源</a></li><li><a href=/zh-cn/docs/tasks/configure-pod-container/assign-cpu-resource/>为容器和 Pod 分配 CPU 资源</a></li></ul><h3 id=集群管理员参考>集群管理员参考</h3><ul><li><a href=/zh-cn/docs/tasks/administer-cluster/extended-resource-node/>为节点广播扩展资源</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-484833fb880d1e179cc2965d15f84da5>8 - 配置 Pod 以使用卷进行存储</h1><p>此页面展示了如何配置 Pod 以使用卷进行存储。</p><p>只要容器存在，容器的文件系统就会存在，因此当一个容器终止并重新启动，对该容器的文件系统改动将丢失。
对于独立于容器的持久化存储，你可以使用<a href=/zh-cn/docs/concepts/storage/volumes/>卷</a>。
这对于有状态应用程序尤为重要，例如键值存储（如 Redis）和数据库。</p><h2 id=准备开始>准备开始</h2><p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li></ul>要获知版本信息，请输入 <code>kubectl version</code>.</p><h2 id=configure-a-volume-for-a-pod>为 Pod 配置卷</h2><p>在本练习中，你将创建一个运行 Pod，该 Pod 仅运行一个容器并拥有一个类型为
<a href=/zh-cn/docs/concepts/storage/volumes/#emptydir>emptyDir</a> 的卷，
在整个 Pod 生命周期中一直存在，即使 Pod 中的容器被终止和重启。以下是 Pod 的配置：</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/pods/storage/redis.yaml download=pods/storage/redis.yaml><code>pods/storage/redis.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-storage-redis-yaml")' title="Copy pods/storage/redis.yaml to clipboard"></img></div><div class=includecode id=pods-storage-redis-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>redis-storage<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/data/redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>redis-storage<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><ol><li><p>创建 Pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/storage/redis.yaml
</span></span></code></pre></div></li></ol><ol start=2><li><p>验证 Pod 中的容器是否正在运行，然后留意 Pod 的更改：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod redis --watch
</span></span></code></pre></div><p>输出如下：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#888>NAME      READY     STATUS    RESTARTS   AGE
</span></span></span><span style=display:flex><span><span style=color:#888>redis     1/1       Running   0          13s
</span></span></span></code></pre></div></li></ol><ol start=3><li><p>在另一个终端，用 Shell 连接正在运行的容器：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> -it redis -- /bin/bash
</span></span></code></pre></div></li></ol><ol start=4><li><p>在你的 Shell 中，切换到 <code>/data/redis</code> 目录下，然后创建一个文件：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>root@redis:/data# <span style=color:#a2f>cd</span> /data/redis/
</span></span><span style=display:flex><span>root@redis:/data/redis# <span style=color:#a2f>echo</span> Hello &gt; test-file
</span></span></code></pre></div></li></ol><ol start=5><li><p>在你的 Shell 中，列出正在运行的进程：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>root@redis:/data/redis# apt-get update
</span></span><span style=display:flex><span>root@redis:/data/redis# apt-get install procps
</span></span><span style=display:flex><span>root@redis:/data/redis# ps aux
</span></span></code></pre></div><p>输出类似于：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#888>USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
</span></span></span><span style=display:flex><span><span style=color:#888>redis        1  0.1  0.1  33308  3828 ?        Ssl  00:46   0:00 redis-server *:6379
</span></span></span><span style=display:flex><span><span style=color:#888>root        12  0.0  0.0  20228  3020 ?        Ss   00:47   0:00 /bin/bash
</span></span></span><span style=display:flex><span><span style=color:#888>root        15  0.0  0.0  17500  2072 ?        R+   00:48   0:00 ps aux
</span></span></span></code></pre></div></li></ol><ol start=6><li><p>在你的 Shell 中，结束 Redis 进程：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>root@redis:/data/redis# <span style=color:#a2f>kill</span> &lt;pid&gt;
</span></span></code></pre></div><p>其中 <code>&lt;pid></code> 是 Redis 进程的 ID (PID)。</p></li></ol><ol start=7><li><p>在你原先终端中，留意 Redis Pod 的更改。最终你将会看到和下面类似的输出：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#888>NAME      READY     STATUS     RESTARTS   AGE
</span></span></span><span style=display:flex><span><span style=color:#888>redis     1/1       Running    0          13s
</span></span></span><span style=display:flex><span><span style=color:#888>redis     0/1       Completed  0         6m
</span></span></span><span style=display:flex><span><span style=color:#888>redis     1/1       Running    1         6m
</span></span></span></code></pre></div></li></ol><p>此时，容器已经终止并重新启动。这是因为 Redis Pod 的
<a href=/docs/reference/generated/kubernetes-api/v1.25/#podspec-v1-core>restartPolicy</a>
为 <code>Always</code>。</p><ol><li><p>用 Shell 进入重新启动的容器中：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> -it redis -- /bin/bash
</span></span></code></pre></div></li></ol><ol start=2><li><p>在你的 Shell 中，进入到 <code>/data/redis</code> 目录下，并确认 <code>test-file</code> 文件是否仍然存在。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>root@redis:/data/redis# <span style=color:#a2f>cd</span> /data/redis/
</span></span><span style=display:flex><span>root@redis:/data/redis# ls
</span></span><span style=display:flex><span>test-file
</span></span></code></pre></div></li></ol><ol start=3><li><p>删除为此练习所创建的 Pod：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pod redis
</span></span></code></pre></div></li></ol><h2 id=接下来>接下来</h2><ul><li>参阅 <a href=/docs/reference/generated/kubernetes-api/v1.25/#volume-v1-core>Volume</a>。</li><li>参阅 <a href=/docs/reference/generated/kubernetes-api/v1.25/#pod-v1-core>Pod</a>。</li><li>除了 <code>emptyDir</code> 提供的本地磁盘存储外，Kubernetes 还支持许多不同的网络附加存储解决方案，
包括 GCE 上的 PD 和 EC2 上的 EBS，它们是关键数据的首选，并将处理节点上的一些细节，
例如安装和卸载设备。了解更多详情请参阅<a href=/zh-cn/docs/concepts/storage/volumes/>卷</a>。</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-528d2422215cb9632b7b45e886b023b5>9 - 配置 Pod 以使用 PersistentVolume 作为存储</h1><p>本文将向你介绍如何配置 Pod 使用
<a class=glossary-tooltip title=声明在持久卷中定义的存储资源，以便可以将其挂载为容器中的卷。 data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims target=_blank aria-label=PersistentVolumeClaim>PersistentVolumeClaim</a>
作为存储。
以下是该过程的总结：</p><ol><li><p>你作为集群管理员创建由物理存储支持的 PersistentVolume。你不会将该卷与任何 Pod 关联。</p></li><li><p>你现在以开发人员或者集群用户的角色创建一个 PersistentVolumeClaim，
它将自动绑定到合适的 PersistentVolume。</p></li><li><p>你创建一个使用以上 PersistentVolumeClaim 作为存储的 Pod。</p></li></ol><h2 id=准备开始>准备开始</h2><ul><li><p>你需要一个包含单个节点的 Kubernetes 集群，并且必须配置
<a class=glossary-tooltip title='kubectl 是用来和 Kubernetes 集群进行通信的命令行工具。' data-toggle=tooltip data-placement=top href=/docs/user-guide/kubectl-overview/ target=_blank aria-label=kubectl>kubectl</a> 命令行工具以便与集群交互。
如果还没有单节点集群，可以使用
<a href=https://minikube.sigs.k8s.io/docs/>Minikube</a> 创建一个。</p></li><li><p>熟悉<a href=/zh-cn/docs/concepts/storage/persistent-volumes/>持久卷</a>文档。</p></li></ul><h2 id=create-an-index-file-on-your-node>在你的节点上创建一个 index.html 文件</h2><p>打开集群中的某个节点的 Shell。
如何打开 Shell 取决于集群的设置。
例如，如果你正在使用 Minikube，那么可以通过输入 <code>minikube ssh</code> 来打开节点的 Shell。</p><p>在该节点的 Shell 中，创建一个 <code>/mnt/data</code> 目录：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 这里假定你的节点使用 &#34;sudo&#34; 来以超级用户角色执行命令</span>
</span></span><span style=display:flex><span>sudo mkdir /mnt/data
</span></span></code></pre></div><p>在 <code>/mnt/data</code> 目录中创建一个 index.html 文件：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 这里再次假定你的节点使用 &#34;sudo&#34; 来以超级用户角色执行命令</span>
</span></span><span style=display:flex><span>sudo sh -c <span style=color:#b44>&#34;echo &#39;Hello from Kubernetes storage&#39; &gt; /mnt/data/index.html&#34;</span>
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>说明：</strong> 如果你的节点使用某工具而不是 <code>sudo</code> 来完成超级用户访问，你可以将上述命令中的 <code>sudo</code> 替换为该工具的名称。</div><p>测试 <code>index.html</code> 文件确实存在：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat /mnt/data/index.html
</span></span></code></pre></div><p>输出应该是：</p><pre tabindex=0><code>Hello from Kubernetes storage
</code></pre><p>现在你可以关闭节点的 Shell 了。</p><h2 id=create-a-pv>创建 PersistentVolume</h2><p>在本练习中，你将创建一个 <strong>hostPath</strong> 类型的 PersistentVolume。
Kubernetes 支持用于在单节点集群上开发和测试的 hostPath 类型的 PersistentVolume。
hostPath 类型的 PersistentVolume 使用节点上的文件或目录来模拟网络附加存储。</p><p>在生产集群中，你不会使用 hostPath。
集群管理员会提供网络存储资源，比如 Google Compute Engine 持久盘卷、NFS 共享卷或 Amazon Elastic Block Store 卷。
集群管理员还可以使用
<a href=/docs/reference/generated/kubernetes-api/v1.25/#storageclass-v1-storage-k8s-io>StorageClasses</a>
来设置<a href=/zh-cn/docs/concepts/storage/dynamic-provisioning/>动态制备存储</a>。</p><p>下面是 hostPath PersistentVolume 的配置文件：</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/pods/storage/pv-volume.yaml download=pods/storage/pv-volume.yaml><code>pods/storage/pv-volume.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-storage-pv-volume-yaml")' title="Copy pods/storage/pv-volume.yaml to clipboard"></img></div><div class=includecode id=pods-storage-pv-volume-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>task-pv-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>local<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>manual<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>capacity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>10Gi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/mnt/data&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>此配置文件指定卷位于集群节点上的 <code>/mnt/data</code> 路径。
其配置还指定了卷的容量大小为 10 GB，访问模式为 <code>ReadWriteOnce</code>，
这意味着该卷可以被单个节点以读写方式安装。
此配置文件还在 PersistentVolume 中定义了
<a href=/zh-cn/docs/concepts/storage/persistent-volumes/#class>StorageClass 的名称</a>为 <code>manual</code>。
它将用于将 PersistentVolumeClaim 的请求绑定到此 PersistentVolume。</p><p>创建 PersistentVolume：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/storage/pv-volume.yaml
</span></span></code></pre></div><p>查看 PersistentVolume 的信息：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pv task-pv-volume
</span></span></code></pre></div><p>输出结果显示该 PersistentVolume 的<code>状态（STATUS）</code>为 <code>Available</code>。
这意味着它还没有被绑定给 PersistentVolumeClaim。</p><pre tabindex=0><code>NAME             CAPACITY   ACCESSMODES   RECLAIMPOLICY   STATUS      CLAIM     STORAGECLASS   REASON    AGE
task-pv-volume   10Gi       RWO           Retain          Available             manual                   4s
</code></pre><h2 id=create-a-pvc>创建 PersistentVolumeClaim</h2><p>下一步是创建一个 PersistentVolumeClaim。
Pod 使用 PersistentVolumeClaim 来请求物理存储。
在本练习中，你将创建一个 PersistentVolumeClaim，它请求至少 3 GB 容量的卷，
该卷至少可以为一个节点提供读写访问。</p><p>下面是 PersistentVolumeClaim 的配置文件：</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/pods/storage/pv-claim.yaml download=pods/storage/pv-claim.yaml><code>pods/storage/pv-claim.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-storage-pv-claim-yaml")' title="Copy pods/storage/pv-claim.yaml to clipboard"></img></div><div class=includecode id=pods-storage-pv-claim-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>task-pv-claim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>manual<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>3Gi<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>创建 PersistentVolumeClaim：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/storage/pv-claim.yaml
</span></span></code></pre></div><p>创建 PersistentVolumeClaim 之后，Kubernetes 控制平面将查找满足申领要求的 PersistentVolume。
如果控制平面找到具有相同 StorageClass 的适当的 PersistentVolume，
则将 PersistentVolumeClaim 绑定到该 PersistentVolume 上。</p><p>再次查看 PersistentVolume 信息：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pv task-pv-volume
</span></span></code></pre></div><p>现在输出的 <code>STATUS</code> 为 <code>Bound</code>。</p><pre tabindex=0><code>NAME             CAPACITY   ACCESSMODES   RECLAIMPOLICY   STATUS    CLAIM                   STORAGECLASS   REASON    AGE
task-pv-volume   10Gi       RWO           Retain          Bound     default/task-pv-claim   manual                   2m
</code></pre><p>查看 PersistentVolumeClaim：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pvc task-pv-claim
</span></span></code></pre></div><p>输出结果表明该 PersistentVolumeClaim 绑定了你的 PersistentVolume <code>task-pv-volume</code>。</p><pre tabindex=0><code>NAME            STATUS    VOLUME           CAPACITY   ACCESSMODES   STORAGECLASS   AGE
task-pv-claim   Bound     task-pv-volume   10Gi       RWO           manual         30s
</code></pre><h2 id=create-a-pod>创建 Pod</h2><p>下一步是创建一个使用你的 PersistentVolumeClaim 作为存储卷的 Pod。</p><p>下面是此 Pod 的配置文件：</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/pods/storage/pv-pod.yaml download=pods/storage/pv-pod.yaml><code>pods/storage/pv-pod.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-storage-pv-pod-yaml")' title="Copy pods/storage/pv-pod.yaml to clipboard"></img></div><div class=includecode id=pods-storage-pv-pod-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>task-pv-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>task-pv-storage<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>persistentVolumeClaim</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>claimName</span>:<span style=color:#bbb> </span>task-pv-claim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>task-pv-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;http-server&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/usr/share/nginx/html&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>task-pv-storage<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>注意 Pod 的配置文件指定了 PersistentVolumeClaim，但没有指定 PersistentVolume。
对 Pod 而言，PersistentVolumeClaim 就是一个存储卷。</p><p>创建 Pod：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/storage/pv-pod.yaml
</span></span></code></pre></div><p>检查 Pod 中的容器是否运行正常：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod task-pv-pod
</span></span></code></pre></div><p>打开一个 Shell 访问 Pod 中的容器：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> -it task-pv-pod -- /bin/bash
</span></span></code></pre></div><p>在 Shell 中，验证 Nginx 是否正在从 hostPath 卷提供 <code>index.html</code> 文件：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 一定要在上一步 &#34;kubectl exec&#34; 所返回的 Shell 中执行下面三个命令</span>
</span></span><span style=display:flex><span>apt update
</span></span><span style=display:flex><span>apt install curl
</span></span><span style=display:flex><span>curl http://localhost/
</span></span></code></pre></div><p>输出结果是你之前写到 hostPath 卷中的 <code>index.html</code> 文件中的内容：</p><pre tabindex=0><code>Hello from Kubernetes storage
</code></pre><p>如果你看到此消息，则证明你已经成功地配置了 Pod 使用 PersistentVolumeClaim
的存储。</p><h2 id=clean-up>清理</h2><p>删除 Pod、PersistentVolumeClaim 和 PersistentVolume 对象：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pod task-pv-pod
</span></span><span style=display:flex><span>kubectl delete pvc task-pv-claim
</span></span><span style=display:flex><span>kubectl delete pv task-pv-volume
</span></span></code></pre></div><p>如果你还没有连接到集群中节点的 Shell，可以按之前所做操作，打开一个新的 Shell。</p><p>在节点的 Shell 上，删除你所创建的目录和文件：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 这里假定你使用 &#34;sudo&#34; 来以超级用户的角色执行命令</span>
</span></span><span style=display:flex><span>sudo rm /mnt/data/index.html
</span></span><span style=display:flex><span>sudo rmdir /mnt/data
</span></span></code></pre></div><p>你现在可以关闭连接到节点的 Shell。</p><h2 id=mounting-the-same-pv-in-two-places>在两个地方挂载相同的 persistentVolume</h2><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/pods/storage/pv-duplicate.yaml download=pods/storage/pv-duplicate.yaml><code>pods/storage/pv-duplicate.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-storage-pv-duplicate-yaml")' title="Copy pods/storage/pv-duplicate.yaml to clipboard"></img></div><div class=includecode id=pods-storage-pv-duplicate-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 网站数据挂载</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/usr/share/nginx/html<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>subPath</span>:<span style=color:#bbb> </span>html<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># Nginx 配置挂载</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/nginx/nginx.conf<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>subPath</span>:<span style=color:#bbb> </span>nginx.conf<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>persistentVolumeClaim</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>claimName</span>:<span style=color:#bbb> </span>test-nfs-claim<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>你可以在 nginx 容器上执行两个卷挂载:</p><p><code>/usr/share/nginx/html</code> 用于静态网站
<code>/etc/nginx/nginx.conf</code> 作为默认配置</p><h2 id=access-control>访问控制</h2><p>使用组 ID（GID）配置的存储仅允许 Pod 使用相同的 GID 进行写入。
GID 不匹配或缺失将会导致无权访问错误。
为了减少与用户的协调，管理员可以对 PersistentVolume 添加 GID 注解。
这样 GID 就能自动添加到使用 PersistentVolume 的任何 Pod 中。</p><p>使用 <code>pv.beta.kubernetes.io/gid</code> 注解的方法如下所示：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pv1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>pv.beta.kubernetes.io/gid</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1234&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>当 Pod 使用带有 GID 注解的 PersistentVolume 时，注解的 GID 会被应用于 Pod 中的所有容器，
应用的方法与 Pod 的安全上下文中指定的 GID 相同。
每个 GID，无论是来自 PersistentVolume 注解还是来自 Pod 规约，都会被应用于每个容器中运行的第一个进程。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong> 当 Pod 使用 PersistentVolume 时，与 PersistentVolume 关联的 GID 不会在 Pod
资源本身的对象上出现。</div><h2 id=接下来>接下来</h2><ul><li>进一步了解 <a href=/zh-cn/docs/concepts/storage/persistent-volumes/>PersistentVolumes</a></li><li>阅读<a href=https://git.k8s.io/design-proposals-archive/storage/persistent-storage.md>持久存储设计文档</a></li></ul><h3 id=参考>参考</h3><ul><li><a href=/docs/reference/generated/kubernetes-api/v1.25/#persistentvolume-v1-core>PersistentVolume</a></li><li><a href=/docs/reference/generated/kubernetes-api/v1.25/#persistentvolumespec-v1-core>PersistentVolumeSpec</a></li><li><a href=/docs/reference/generated/kubernetes-api/v1.25/#persistentvolumeclaim-v1-core>PersistentVolumeClaim</a></li><li><a href=/docs/reference/generated/kubernetes-api/v1.25/#persistentvolumeclaimspec-v1-core>PersistentVolumeClaimSpec</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-4621938ba53c04a77f51b5938a583439>10 - 配置 Pod 使用投射卷作存储</h1><p>本文介绍怎样通过<a href=/zh-cn/docs/concepts/storage/volumes/#projected><code>projected</code></a> 卷将现有的多个卷资源挂载到相同的目录。
当前，<code>secret</code>、<code>configMap</code>、<code>downwardAPI</code> 和 <code>serviceAccountToken</code> 卷可以被投射。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong> <code>serviceAccountToken</code> 不是一种卷类型</div><h2 id=准备开始>准备开始</h2><p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li></ul>要获知版本信息，请输入 <code>kubectl version</code>.</p><h2 id=为-pod-配置投射卷>为 Pod 配置投射卷</h2><p>本练习中，你将使用本地文件来创建用户名和密码 <a class=glossary-tooltip title='Secret 用于存储敏感信息，如密码、 OAuth 令牌和 SSH 密钥。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/configuration/secret/ target=_blank aria-label=Secret>Secret</a>，
然后创建运行一个容器的 Pod，
该 Pod 使用<a href=/zh-cn/docs/concepts/storage/volumes/#projected><code>projected</code></a> 卷将 Secret 挂载到相同的路径下。</p><p>下面是 Pod 的配置文件：</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/pods/storage/projected.yaml download=pods/storage/projected.yaml><code>pods/storage/projected.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-storage-projected-yaml")' title="Copy pods/storage/projected.yaml to clipboard"></img></div><div class=includecode id=pods-storage-projected-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-projected-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-projected-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- sleep<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;86400&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>all-in-one<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/projected-volume&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>all-in-one<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>projected</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>sources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>user<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pass<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><ol><li><p>创建 Secret:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 创建包含用户名和密码的文件:</span>
</span></span><span style=display:flex><span><span style=color:#a2f>echo</span> -n <span style=color:#b44>&#34;admin&#34;</span> &gt; ./username.txt
</span></span><span style=display:flex><span><span style=color:#a2f>echo</span> -n <span style=color:#b44>&#34;1f2d1e2e67df&#34;</span> &gt; ./password.txt
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 在 Secret 中引用上述文件</span>
</span></span><span style=display:flex><span>kubectl create secret generic user --from-file<span style=color:#666>=</span>./username.txt
</span></span><span style=display:flex><span>kubectl create secret generic pass --from-file<span style=color:#666>=</span>./password.txt
</span></span></code></pre></div></li><li><p>创建 Pod：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/storage/projected.yaml
</span></span></code></pre></div></li><li><p>确认 Pod 中的容器运行正常，然后监视 Pod 的变化：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get --watch pod test-projected-volume
</span></span></code></pre></div><p>输出结果和下面类似：</p><pre tabindex=0><code>NAME                    READY     STATUS    RESTARTS   AGE
test-projected-volume   1/1       Running   0          14s
</code></pre></li><li><p>在另外一个终端中，打开容器的 shell：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> -it test-projected-volume -- /bin/sh
</span></span></code></pre></div></li><li><p>在 shell 中，确认 <code>projected-volume</code> 目录包含你的投射源：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>ls /projected-volume/
</span></span></code></pre></div></li></ol><h2 id=清理>清理</h2><p>删除 Pod 和 Secret:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pod test-projected-volume
</span></span><span style=display:flex><span>kubectl delete secret user pass
</span></span></code></pre></div><h2 id=接下来>接下来</h2><ul><li>进一步了解<a href=/zh-cn/docs/concepts/storage/volumes/#projected><code>projected</code></a> 卷。</li><li>阅读<a href=https://git.k8s.io/design-proposals-archive/node/all-in-one-volume.md>一体卷</a>设计文档。</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-abd895c0803315e9717e6ff9ec4e3d30>11 - 为 Pod 或容器配置安全上下文</h1><p>安全上下文（Security Context）定义 Pod 或 Container 的特权与访问控制设置。
安全上下文包括但不限于：</p><ul><li>自主访问控制（Discretionary Access Control）：
基于<a href=https://wiki.archlinux.org/index.php/users_and_groups>用户 ID（UID）和组 ID（GID）</a>
来判定对对象（例如文件）的访问权限。</li><li><a href=https://zh.wikipedia.org/wiki/%E5%AE%89%E5%85%A8%E5%A2%9E%E5%BC%BA%E5%BC%8FLinux>安全性增强的 Linux（SELinux）</a>：
为对象赋予安全性标签。</li><li>以特权模式或者非特权模式运行。</li><li><a href=https://linux-audit.com/linux-capabilities-hardening-linux-binaries-by-removing-setuid/>Linux 权能</a>:
为进程赋予 root 用户的部分特权而非全部特权。</li></ul><ul><li><p><a href=/zh-cn/docs/tutorials/security/apparmor/>AppArmor</a>：使用程序配置来限制个别程序的权能。</p></li><li><p><a href=/zh-cn/docs/tutorials/security/seccomp/>Seccomp</a>：过滤进程的系统调用。</p></li><li><p><code>allowPrivilegeEscalation</code>：控制进程是否可以获得超出其父进程的特权。
此布尔值直接控制是否为容器进程设置
<a href=https://www.kernel.org/doc/Documentation/prctl/no_new_privs.txt><code>no_new_privs</code></a>标志。
当容器满足一下条件之一时，<code>allowPrivilegeEscalation</code> 总是为 true：</p><ul><li>以特权模式运行，或者</li><li>具有 <code>CAP_SYS_ADMIN</code> 权能</li></ul></li><li><p>readOnlyRootFilesystem：以只读方式加载容器的根文件系统。</p></li></ul><p>以上条目不是安全上下文设置的完整列表 -- 请参阅
<a href=/docs/reference/generated/kubernetes-api/v1.25/#securitycontext-v1-core>SecurityContext</a>
了解其完整列表。</p><h2 id=准备开始>准备开始</h2><p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li></ul>要获知版本信息，请输入 <code>kubectl version</code>.</p><h2 id=set-the-security-context-for-a-pod>为 Pod 设置安全性上下文</h2><p>要为 Pod 设置安全性设置，可在 Pod 规约中包含 <code>securityContext</code> 字段。<code>securityContext</code> 字段值是一个
<a href=/docs/reference/generated/kubernetes-api/v1.25/#podsecuritycontext-v1-core>PodSecurityContext</a>
对象。你为 Pod 所设置的安全性配置会应用到 Pod 中所有 Container 上。
下面是一个 Pod 的配置文件，该 Pod 定义了 <code>securityContext</code> 和一个 <code>emptyDir</code> 卷：</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/pods/security/security-context.yaml download=pods/security/security-context.yaml><code>pods/security/security-context.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-security-security-context-yaml")' title="Copy pods/security/security-context.yaml to clipboard"></img></div><div class=includecode id=pods-security-security-context-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>security-context-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>runAsUser</span>:<span style=color:#bbb> </span><span style=color:#666>1000</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>runAsGroup</span>:<span style=color:#bbb> </span><span style=color:#666>3000</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>fsGroup</span>:<span style=color:#bbb> </span><span style=color:#666>2000</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>sec-ctx-vol<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>sec-ctx-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;sleep 1h&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>sec-ctx-vol<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/data/demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>allowPrivilegeEscalation</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>在配置文件中，<code>runAsUser</code> 字段指定 Pod 中的所有容器内的进程都使用用户 ID 1000
来运行。<code>runAsGroup</code> 字段指定所有容器中的进程都以主组 ID 3000 来运行。
如果忽略此字段，则容器的主组 ID 将是 root（0）。
当 <code>runAsGroup</code> 被设置时，所有创建的文件也会划归用户 1000 和组 3000。
由于 <code>fsGroup</code> 被设置，容器中所有进程也会是附组 ID 2000 的一部分。
卷 <code>/data/demo</code> 及在该卷中创建的任何文件的属主都会是组 ID 2000。</p><p>创建该 Pod：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/security/security-context.yaml
</span></span></code></pre></div><p>检查 Pod 的容器处于运行状态：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod security-context-demo
</span></span></code></pre></div><p>开启一个 Shell 进入到运行中的容器：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> -it security-context-demo -- sh
</span></span></code></pre></div><p>在你的 Shell 中，列举运行中的进程：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>ps
</span></span></code></pre></div><p>输出显示进程以用户 1000 运行，即 <code>runAsUser</code> 所设置的值：</p><pre tabindex=0><code class=language-none data-lang=none>PID   USER     TIME  COMMAND
    1 1000      0:00 sleep 1h
    6 1000      0:00 sh
...
</code></pre><p>在你的 Shell 中，进入 <code>/data</code> 目录列举其内容：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>cd</span> /data
</span></span><span style=display:flex><span>ls -l
</span></span></code></pre></div><p>输出显示 <code>/data/demo</code> 目录的组 ID 为 2000，即 <code>fsGroup</code> 的设置值：</p><pre tabindex=0><code class=language-none data-lang=none>drwxrwsrwx 2 root 2000 4096 Jun  6 20:08 demo
</code></pre><p>在你的 Shell 中，进入到 <code>/data/demo</code> 目录下创建一个文件：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>cd</span> demo
</span></span><span style=display:flex><span><span style=color:#a2f>echo</span> hello &gt; testfile
</span></span></code></pre></div><p>列举 <code>/data/demo</code> 目录下的文件：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>ls -l
</span></span></code></pre></div><p>输出显示 <code>testfile</code> 的组 ID 为 2000，也就是 <code>fsGroup</code> 所设置的值：</p><pre tabindex=0><code class=language-none data-lang=none>-rw-r--r-- 1 1000 2000 6 Jun  6 20:08 testfile
</code></pre><p>运行下面的命令：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>id
</span></span></code></pre></div><p>输出类似于：</p><pre tabindex=0><code class=language-none data-lang=none>uid=1000 gid=3000 groups=2000
</code></pre><p>从输出中你会看到 <code>gid</code> 值为 3000，也就是 <code>runAsGroup</code> 字段的值。
如果 <code>runAsGroup</code> 被忽略，则 <code>gid</code> 会取值 0（root），而进程就能够与 root
用户组所拥有以及要求 root 用户组访问权限的文件交互。</p><p>退出你的 Shell：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>exit</span>
</span></span></code></pre></div><h2 id=为-pod-配置卷访问权限和属主变更策略>为 Pod 配置卷访问权限和属主变更策略</h2><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.23 [stable]</code></div><p>默认情况下，Kubernetes 在挂载一个卷时，会递归地更改每个卷中的内容的属主和访问权限，
使之与 Pod 的 <code>securityContext</code> 中指定的 <code>fsGroup</code> 匹配。
对于较大的数据卷，检查和变更属主与访问权限可能会花费很长时间，降低 Pod 启动速度。
你可以在 <code>securityContext</code> 中使用 <code>fsGroupChangePolicy</code> 字段来控制 Kubernetes
检查和管理卷属主和访问权限的方式。</p><p><strong>fsGroupChangePolicy</strong> - <code>fsGroupChangePolicy</code> 定义在卷被暴露给 Pod 内部之前对其
内容的属主和访问许可进行变更的行为。此字段仅适用于那些支持使用 <code>fsGroup</code> 来
控制属主与访问权限的卷类型。此字段的取值可以是：</p><ul><li><code>OnRootMismatch</code>：只有根目录的属主与访问权限与卷所期望的权限不一致时，
才改变其中内容的属主和访问权限。这一设置有助于缩短更改卷的属主与访问
权限所需要的时间。</li><li><code>Always</code>：在挂载卷时总是更改卷中内容的属主和访问权限。</li></ul><p>例如：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>runAsUser</span>:<span style=color:#bbb> </span><span style=color:#666>1000</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>runAsGroup</span>:<span style=color:#bbb> </span><span style=color:#666>3000</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>fsGroup</span>:<span style=color:#bbb> </span><span style=color:#666>2000</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>fsGroupChangePolicy</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;OnRootMismatch&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>说明：</strong> 此字段对于 <a href=/zh-cn/docs/concepts/storage/volumes/#secret><code>secret</code></a>、
<a href=/zh-cn/docs/concepts/storage/volumes/#configmap><code>configMap</code></a>
和 <a href=/zh-cn/docs/concepts/storage/volumes/#emptydir><code>emptydir</code></a>
这类临时性存储无效。</div><h2 id=将卷权限和所有权更改委派给-csi-驱动程序>将卷权限和所有权更改委派给 CSI 驱动程序</h2><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.23 [beta]</code></div><p>如果你部署了一个<a href=https://github.com/container-storage-interface/spec/blob/master/spec.md>容器存储接口 (CSI)</a>
驱动，而该驱动支持 <code>VOLUME_MOUNT_GROUP</code> <code>NodeServiceCapability</code>，
在 <code>securityContext</code> 中指定 <code>fsGroup</code> 来设置文件所有权和权限的过程将由 CSI
驱动而不是 Kubernetes 来执行，前提是 Kubernetes 的 <code>DelegateFSGroupToCSIDriver</code>
特性门控已启用。在这种情况下，由于 Kubernetes 不执行任何所有权和权限更改，
<code>fsGroupChangePolicy</code> 不会生效，并且按照 CSI 的规定，CSI 驱动应该使用所指定的
<code>fsGroup</code> 来挂载卷，从而生成了一个对 <code>fsGroup</code> 可读/可写的卷.</p><p>更多的信息请参考 <a href=https://github.com/gnufied/enhancements/blob/master/keps/sig-storage/2317-fsgroup-on-mount/README.md>KEP</a>
和 <a href=https://github.com/container-storage-interface/spec/blob/master/spec.md#createvolume>CSI 规范</a>
中的字段 <code>VolumeCapability.MountVolume.volume_mount_group</code> 的描述。</p><h2 id=set-the-security-context-for-a-container>为 Container 设置安全性上下文</h2><p>若要为 Container 设置安全性配置，可以在 Container 清单中包含 <code>securityContext</code>
字段。<code>securityContext</code> 字段的取值是一个
<a href=/docs/reference/generated/kubernetes-api/v1.25/#securitycontext-v1-core>SecurityContext</a>
对象。你为 Container 设置的安全性配置仅适用于该容器本身，并且所指定的设置在与
Pod 层面设置的内容发生重叠时，会重写 Pod 层面的设置。Container 层面的设置不会影响到 Pod 的卷。</p><p>下面是一个 Pod 的配置文件，其中包含一个 Container。Pod 和 Container 都有
<code>securityContext</code> 字段：</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/pods/security/security-context-2.yaml download=pods/security/security-context-2.yaml><code>pods/security/security-context-2.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-security-security-context-2-yaml")' title="Copy pods/security/security-context-2.yaml to clipboard"></img></div><div class=includecode id=pods-security-security-context-2-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>security-context-demo-2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>runAsUser</span>:<span style=color:#bbb> </span><span style=color:#666>1000</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>sec-ctx-demo-2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/google-samples/node-hello:1.0<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>runAsUser</span>:<span style=color:#bbb> </span><span style=color:#666>2000</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>allowPrivilegeEscalation</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>创建该 Pod：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/security/security-context-2.yaml
</span></span></code></pre></div><p>验证 Pod 中的容器处于运行状态：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod security-context-demo-2
</span></span></code></pre></div><p>启动一个 Shell 进入到运行中的容器内：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> -it security-context-demo-2 -- sh
</span></span></code></pre></div><p>在你的 Shell 中，列举运行中的进程：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>ps aux
</span></span></code></pre></div><p>输出显示进程以用户 2000 运行。该值是在 Container 的 <code>runAsUser</code> 中设置的。
该设置值重写了 Pod 层面所设置的值 1000。</p><pre tabindex=0><code>USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
2000         1  0.0  0.0   4336   764 ?        Ss   20:36   0:00 /bin/sh -c node server.js
2000         8  0.1  0.5 772124 22604 ?        Sl   20:36   0:00 node server.js
...
</code></pre><p>退出你的 Shell：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>exit</span>
</span></span></code></pre></div><h2 id=set-capabilities-for-a-container>为 Container 设置权能</h2><p>使用 <a href=https://man7.org/linux/man-pages/man7/capabilities.7.html>Linux 权能</a>，
你可以赋予进程 root 用户所拥有的某些特权，但不必赋予其全部特权。
要为 Container 添加或移除 Linux 权能，可以在 Container 清单的 <code>securityContext</code>
节包含 <code>capabilities</code> 字段。</p><p>首先，看一下不包含 <code>capabilities</code> 字段时候会发生什么。
下面是一个配置文件，其中没有添加或移除容器的权能：</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/pods/security/security-context-3.yaml download=pods/security/security-context-3.yaml><code>pods/security/security-context-3.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-security-security-context-3-yaml")' title="Copy pods/security/security-context-3.yaml to clipboard"></img></div><div class=includecode id=pods-security-security-context-3-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>security-context-demo-3<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>sec-ctx-3<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/google-samples/node-hello:1.0<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>创建该 Pod：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/security/security-context-3.yaml
</span></span></code></pre></div><p>验证 Pod 的容器处于运行状态：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod security-context-demo-3
</span></span></code></pre></div><p>启动一个 Shell 进入到运行中的容器：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> -it security-context-demo-3 -- sh
</span></span></code></pre></div><p>在你的 Shell 中，列举运行中的进程：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>ps aux
</span></span></code></pre></div><p>输出显示容器中进程 ID（PIDs）：</p><pre tabindex=0><code>USER  PID %CPU %MEM    VSZ   RSS TTY   STAT START   TIME COMMAND
root    1  0.0  0.0   4336   796 ?     Ss   18:17   0:00 /bin/sh -c node server.js
root    5  0.1  0.5 772124 22700 ?     Sl   18:17   0:00 node server.js
</code></pre><p>在你的 Shell 中，查看进程 1 的状态：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>cd</span> /proc/1
</span></span><span style=display:flex><span>cat status
</span></span></code></pre></div><p>输出显示进程的权能位图：</p><pre tabindex=0><code>...
CapPrm:	00000000a80425fb
CapEff:	00000000a80425fb
...
</code></pre><p>记下进程权能位图，之后退出你的 Shell：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>exit</span>
</span></span></code></pre></div><p>接下来运行一个与前例中容器相同的容器，只是这个容器有一些额外的权能设置。</p><p>下面是一个 Pod 的配置，其中运行一个容器。配置为容器添加 <code>CAP_NET_ADMIN</code> 和
<code>CAP_SYS_TIME</code> 权能：</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/pods/security/security-context-4.yaml download=pods/security/security-context-4.yaml><code>pods/security/security-context-4.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-security-security-context-4-yaml")' title="Copy pods/security/security-context-4.yaml to clipboard"></img></div><div class=includecode id=pods-security-security-context-4-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>security-context-demo-4<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>sec-ctx-4<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/google-samples/node-hello:1.0<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>capabilities</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>add</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;NET_ADMIN&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;SYS_TIME&#34;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>创建 Pod：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/security/security-context-4.yaml
</span></span></code></pre></div><p>启动一个 Shell，进入到运行中的容器：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> -it security-context-demo-4 -- sh
</span></span></code></pre></div><p>在你的 Shell 中，查看进程 1 的权能：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>cd</span> /proc/1
</span></span><span style=display:flex><span>cat status
</span></span></code></pre></div><p>输出显示的是进程的权能位图：</p><pre tabindex=0><code>...
CapPrm:	00000000aa0435fb
CapEff:	00000000aa0435fb
...
</code></pre><p>比较两个容器的权能位图：</p><pre tabindex=0><code>00000000a80425fb
00000000aa0435fb
</code></pre><p>在第一个容器的权能位图中，位 12 和 25 是没有设置的。在第二个容器中，位 12
和 25 是设置了的。位 12 是 <code>CAP_NET_ADMIN</code> 而位 25 则是 <code>CAP_SYS_TIME</code>。
参见 <a href=https://github.com/torvalds/linux/blob/master/include/uapi/linux/capability.h>capability.h</a>
了解权能常数的定义。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong> Linux 权能常数定义的形式为 <code>CAP_XXX</code>。但是你在 container 清单中列举权能时，
要将权能名称中的 <code>CAP_</code> 部分去掉。例如，要添加 <code>CAP_SYS_TIME</code>，
可在权能列表中添加 <code>SYS_TIME</code>。</div><h2 id=为容器设置-seccomp-配置>为容器设置 Seccomp 配置</h2><p>若要为容器设置 Seccomp 配置（Profile），可在你的 Pod 或 Container 清单的
<code>securityContext</code> 节中包含 <code>seccompProfile</code> 字段。该字段是一个
<a href=/docs/reference/generated/kubernetes-api/v1.25/#seccompprofile-v1-core>SeccompProfile</a>
对象，包含 <code>type</code> 和 <code>localhostProfile</code> 属性。
<code>type</code> 的合法选项包括 <code>RuntimeDefault</code>、<code>Unconfined</code> 和 <code>Localhost</code>。
<code>localhostProfile</code> 只能在 <code>type: Localhost</code> 配置下才可以设置。
该字段标明节点上预先设定的配置的路径，路径是相对于 kubelet 所配置的
Seccomp 配置路径（使用 <code>--root-dir</code> 设置）而言的。</p><p>下面是一个例子，设置容器使用节点上容器运行时的默认配置作为 Seccomp 配置：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>seccompProfile</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>RuntimeDefault<span style=color:#bbb>
</span></span></span></code></pre></div><p>下面是另一个例子，将 Seccomp 的样板设置为位于
<code>&lt;kubelet-根目录>/seccomp/my-profiles/profile-allow.json</code>
的一个预先配置的文件。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>seccompProfile</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Localhost<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>localhostProfile</span>:<span style=color:#bbb> </span>my-profiles/profile-allow.json<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=为-container-赋予-selinux-标签>为 Container 赋予 SELinux 标签</h2><p>若要给 Container 设置 SELinux 标签，可以在 Pod 或 Container 清单的
<code>securityContext</code> 节包含 <code>seLinuxOptions</code> 字段。
<code>seLinuxOptions</code> 字段的取值是一个
<a href=/docs/reference/generated/kubernetes-api/v1.25/#selinuxoptions-v1-core>SELinuxOptions</a>
对象。下面是一个应用 SELinux 标签的例子：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>seLinuxOptions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>level</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;s0:c123,c456&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>说明：</strong> 要指定 SELinux，需要在宿主操作系统中装载 SELinux 安全性模块。</div><h3 id=高效重打-selinux-卷标签>高效重打 SELinux 卷标签</h3><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.25 [alpha]</code></div><p>默认情况下，容器运行时递归地将 SELinux 标签赋予所有 Pod 卷上的所有文件。
为了加快该过程，Kubernetes 使用挂载可选项 <code>-o context=&lt;label></code> 可以立即改变卷的 SELinux 标签。</p><p>要使用这项加速功能，必须满足下列条件：</p><ul><li>必须启用 Alpha 特性门控 <code>ReadWriteOncePod</code> 和 <code>SELinuxMountReadWriteOncePod</code>。</li></ul><ul><li>Pod 必须以 <code>accessModes: ["ReadWriteOncePod"]</code> 模式使用 PersistentVolumeClaim。</li></ul><ul><li>Pod（或其中使用 PersistentVolumeClaim 的所有容器）必须设置 <code>seLinuxOptions</code>。</li></ul><ul><li>对应的 PersistentVolume 必须是使用 {&lt; glossary_tooltip text="CSI" term_id="csi" >}}
驱动程序的卷，或者是传统的 <code>iscsi</code> 卷类型的卷。<ul><li>如果使用基于 CSI 驱动程序的卷，CSI 驱动程序必须能够通过在 CSIDriver
实例中设置 <code>spec.seLinuxMount: true</code> 以支持 <code>-o context</code> 挂载。</li></ul></li></ul><p>对于所有其他卷类型，重打 SELinux 标签的方式有所不同：
容器运行时为卷中的所有节点（文件和目录）递归地修改 SELinux 标签。
卷中的文件和目录越多，重打标签需要耗费的时间就越长。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>在 Kubernetes 1.25 中，kubelet 在重启后会丢失对卷标签的追踪记录。
换言之，kubelet 可能会拒绝启动 Pod，原因类似于 “conflicting
SELinux labels of volume”，
但实际上 Pod 中并没有冲突的标签。在重启 kubelet
之前确保节点已被<a href=/zh-cn/docs/tasks/administer-cluster/safely-drain-node/>完全腾空</a>。</div><h2 id=discussion>讨论</h2><p>Pod 的安全上下文适用于 Pod 中的容器，也适用于 Pod 所挂载的卷（如果有的话）。
尤其是，<code>fsGroup</code> 和 <code>seLinuxOptions</code> 按下面的方式应用到挂载卷上：</p><ul><li><p><code>fsGroup</code>：支持属主管理的卷会被修改，将其属主变更为 <code>fsGroup</code> 所指定的 GID，
并且对该 GID 可写。进一步的细节可参阅
<a href=https://git.k8s.io/design-proposals-archive/storage/volume-ownership-management.md>属主变更设计文档</a>。</p></li><li><p><code>seLinuxOptions</code>：支持 SELinux 标签的卷会被重新打标签，以便可被 <code>seLinuxOptions</code>
下所设置的标签访问。通常你只需要设置 <code>level</code> 部分。
该部分设置的是赋予 Pod 中所有容器及卷的
<a href=https://selinuxproject.org/page/NB_MLS>多类别安全性（Multi-Category Security，MCS)</a>标签。</p><div class="alert alert-danger warning callout" role=alert><strong>警告：</strong> 在为 Pod 设置 MCS 标签之后，所有带有相同标签的 Pod 可以访问该卷。
如果你需要跨 Pod 的保护，你必须为每个 Pod 赋予独特的 MCS 标签。</div></li></ul><h2 id=清理>清理</h2><p>删除之前创建的所有 Pod：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pod security-context-demo
</span></span><span style=display:flex><span>kubectl delete pod security-context-demo-2
</span></span><span style=display:flex><span>kubectl delete pod security-context-demo-3
</span></span><span style=display:flex><span>kubectl delete pod security-context-demo-4
</span></span></code></pre></div><h2 id=接下来>接下来</h2><ul><li><a href=/docs/reference/generated/kubernetes-api/v1.25/#podsecuritycontext-v1-core>PodSecurityContext</a> API 定义</li><li><a href=/docs/reference/generated/kubernetes-api/v1.25/#securitycontext-v1-core>SecurityContext</a> API 定义</li><li><a href=https://github.com/containerd/containerd/blob/main/docs/cri/config.md>使用最新的安全性增强来调优 Docker（英文）</a></li><li><a href=https://github.com/kubernetes/design-proposals-archive/blob/main/auth/security_context.md>安全上下文的设计文档（英文）</a></li><li><a href=https://github.com/kubernetes/design-proposals-archive/blob/main/storage/volume-ownership-management.md>属主管理的设计文档（英文）</a></li><li><a href=zh-cn/docs/concepts/security/pod-security-admission/>Pod 安全性准入</a></li><li><a href=https://github.com/kubernetes/design-proposals-archive/blob/main/auth/no-new-privs.md>AllowPrivilegeEscalation 的设计文档（英文）</a></li><li>关于在 Linux 系统中的安全机制的更多信息，可参阅
<a href=https://www.linux.com/learn/overview-linux-kernel-security-features>Linux 内核安全性能力概述</a>（注意：部分信息已过时）。</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-2c0d882359718c4c69c67099bed2156c>12 - 为 Pod 配置服务账号</h1><p>服务账号为 Pod 中运行的进程提供了一个标识。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong> 本文是服务账号的用户使用介绍，描述服务账号在集群中如何起作用。
你的集群管理员可能已经对你的集群做了定制，因此导致本文中所讲述的内容并不适用。</div><p>当你（自然人）访问集群时（例如，使用 <code>kubectl</code>），API 服务器将你的身份验证为
特定的用户账号（当前这通常是 <code>admin</code>，除非你的集群管理员已经定制了你的集群配置）。
Pod 内的容器中的进程也可以与 API 服务器接触。
当它们进行身份验证时，它们被验证为特定的服务账号（例如，<code>default</code>）。</p><h2 id=准备开始>准备开始</h2><p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li></ul>要获知版本信息，请输入 <code>kubectl version</code>.</p><h2 id=使用默认的服务账号访问-api-服务器>使用默认的服务账号访问 API 服务器</h2><p>当你创建 Pod 时，如果没有指定服务账号，Pod 会被指定给命名空间中的 <code>default</code> 服务账号。
如果你查看 Pod 的原始 JSON 或 YAML（例如：<code>kubectl get pods/&lt;podname> -o yaml</code>），
你可以看到 <code>spec.serviceAccountName</code> 字段已经被<a href=/zh-cn/docs/concepts/overview/working-with-objects/object-management/>自动设置</a>了。</p><p>你可以使用自动挂载给 Pod 的服务账号凭据访问 API，
<a href=/zh-cn/docs/tasks/access-application-cluster/access-cluster>访问集群</a>页面中有相关描述。
服务账号的 API
许可取决于你所使用的<a href=/zh-cn/docs/reference/access-authn-authz/authorization/#authorization-modules>鉴权插件和策略</a>。</p><p>你可以通过在 ServiceAccount 上设置 <code>automountServiceAccountToken: false</code>
来实现不给服务账号自动挂载 API 凭据到 <code>/var/run/secrets/kubernetes.io/serviceaccount/token</code>
的目的：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ServiceAccount<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>build-robot<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>automountServiceAccountToken</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>在 1.6 以上版本中，你也可以选择不给特定 Pod 自动挂载 API 凭据：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>serviceAccountName</span>:<span style=color:#bbb> </span>build-robot<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>automountServiceAccountToken</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span></code></pre></div><p>如果 Pod 和服务账号都指定了 <code>automountServiceAccountToken</code> 值，则 Pod 的 spec 优先于服务账号。</p><h2 id=use-multiple-service-accounts>使用多个服务账号</h2><p>每个命名空间都有一个名为 <code>default</code> 的服务账号资源。
你可以用下面的命令查询这个服务账号以及命名空间中的其他 ServiceAccount 资源：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get serviceaccounts
</span></span></code></pre></div><p>输出类似于：</p><pre tabindex=0><code>NAME      SECRETS    AGE
default   1          1d
</code></pre><p>你可以像这样来创建额外的 ServiceAccount 对象：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f - <span style=color:#b44>&lt;&lt;EOF
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: ServiceAccount
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: build-robot
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>ServiceAccount 对象的名字必须是一个有效的
<a href=/zh-cn/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNS 子域名</a>.</p><p>如果你查询服务账号对象的完整信息，如下所示：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get serviceaccounts/build-robot -o yaml
</span></span></code></pre></div><p>输出类似于：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ServiceAccount<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2015-06-16T00:12:59Z<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>build-robot<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;272500&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>721ab723-13bc-11e5-aec2-42010af0021e<span style=color:#bbb>
</span></span></span></code></pre></div><p>你可以使用授权插件来<a href=/zh-cn/docs/reference/access-authn-authz/rbac/#service-account-permissions>设置服务账号的访问许可</a>。</p><p>要使用非默认的服务账号，将 Pod 的 <code>spec.serviceAccountName</code> 字段设置为你想用的服务账号名称。</p><p>Pod 被创建时服务账号必须存在，否则会被拒绝。</p><p>你不能更新已经创建好的 Pod 的服务账号。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p><code>spec.serviceAccount</code> 字段是 <code>spec.serviceAccountName</code> 的已弃用别名。
如果要从工作负载资源中删除这些字段，请在
<a href=/zh-cn/docs/concepts/workloads/pods#pod-templates>Pod 模板</a>上将这两个字段显式设置为空。</div><p>你可以清除服务账号，如下所示：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete serviceaccount/build-robot
</span></span></code></pre></div><h2 id=手动创建服务账号-api-令牌>手动创建服务账号 API 令牌</h2><p>假设我们有一个上面提到的名为 "build-robot" 的服务账号，现在我们手动创建一个新的 Secret。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f - <span style=color:#b44>&lt;&lt;EOF
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: Secret
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: build-robot-secret
</span></span></span><span style=display:flex><span><span style=color:#b44>  annotations:
</span></span></span><span style=display:flex><span><span style=color:#b44>    kubernetes.io/service-account.name: build-robot
</span></span></span><span style=display:flex><span><span style=color:#b44>type: kubernetes.io/service-account-token
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>现在，你可以确认新构建的 Secret 中填充了 "build-robot" 服务账号的 API 令牌。
令牌控制器将清理不存在的服务账号的所有令牌。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe secrets/build-robot-secret
</span></span></code></pre></div><p>输出类似于：</p><pre tabindex=0><code>Name:           build-robot-secret
Namespace:      default
Labels:         &lt;none&gt;
Annotations:    kubernetes.io/service-account.name: build-robot
                kubernetes.io/service-account.uid: da68f9c6-9d26-11e7-b84e-002dc52800da

Type:   kubernetes.io/service-account-token

Data
====
ca.crt:         1338 bytes
namespace:      7 bytes
token:          ...
</code></pre><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>这里省略了 <code>token</code> 的内容。</div><h2 id=add-imagepullsecrets-to-a-service-account>为服务账号添加 ImagePullSecrets</h2><h3 id=创建-imagepullsecret>创建 ImagePullSecret</h3><ul><li><p>创建一个 ImagePullSecret，如<a href=/zh-cn/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod>为 Pod 设置 ImagePullSecret</a> 所述。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret docker-registry myregistrykey --docker-server<span style=color:#666>=</span>DUMMY_SERVER <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>          --docker-username<span style=color:#666>=</span>DUMMY_USERNAME --docker-password<span style=color:#666>=</span>DUMMY_DOCKER_PASSWORD <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>          --docker-email<span style=color:#666>=</span>DUMMY_DOCKER_EMAIL
</span></span></code></pre></div></li></ul><ul><li><p>确认创建成功：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get secrets myregistrykey
</span></span></code></pre></div><p>输出类似于：</p><pre tabindex=0><code>NAME             TYPE                              DATA    AGE
myregistrykey    kubernetes.io/.dockerconfigjson   1       1d
</code></pre></li></ul><h3 id=将镜像拉取-secret-添加到服务账号>将镜像拉取 Secret 添加到服务账号</h3><p>接着修改命名空间的 <code>default</code> 服务账号，令其使用该 Secret 用作 <code>imagePullSecret</code>。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl patch serviceaccount default -p <span style=color:#b44>&#39;{&#34;imagePullSecrets&#34;: [{&#34;name&#34;: &#34;myregistrykey&#34;}]}&#39;</span>
</span></span></code></pre></div><p>你也可以使用 <code>kubectl edit</code>，或者如下所示手动编辑 YAML 清单：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get serviceaccounts default -o yaml &gt; ./sa.yaml
</span></span></code></pre></div><p><code>sa.yaml</code> 文件的输出类似这样：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ServiceAccount<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2015-08-07T22:02:39Z<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;243024&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>052fb0f4-3d50-11e5-b066-42010af0d7b6<span style=color:#bbb>
</span></span></span></code></pre></div><p>使用你常用的编辑器（例如 <code>vi</code>），打开 <code>sa.yaml</code> 文件，删除带有键名
<code>resourceVersion</code> 的行，添加带有 <code>imagePullSecrets:</code> 的行，最后保存文件。</p><p>所得到的 <code>sa.yaml</code> 文件类似于：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ServiceAccount<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2015-08-07T22:02:39Z<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>052fb0f4-3d50-11e5-b066-42010af0d7b6<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>imagePullSecrets</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myregistrykey<span style=color:#bbb>
</span></span></span></code></pre></div><p>最后，使用新更新的 <code>sa.yaml</code> 文件替换服务账号。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl replace serviceaccount default -f ./sa.yaml
</span></span></code></pre></div><h3 id=验证镜像拉取-secret-已经被添加到-pod-规约>验证镜像拉取 Secret 已经被添加到 Pod 规约</h3><p>现在，在当前命名空间中创建使用默认服务账号的新 Pod 时，新 Pod
会自动设置其 <code>.spec.imagePullSecrets</code> 字段：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl run nginx --image<span style=color:#666>=</span>nginx --restart<span style=color:#666>=</span>Never
</span></span><span style=display:flex><span>kubectl get pod nginx -o<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.spec.imagePullSecrets[0].name}{&#34;\n&#34;}&#39;</span>
</span></span></code></pre></div><p>输出为：</p><pre tabindex=0><code>myregistrykey
</code></pre><h2 id=service-account-token-volume-projection>服务账号令牌卷投射</h2><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.20 [stable]</code></div><p>为了启用令牌请求投射，你必须为 <code>kube-apiserver</code> 设置以下命令行参数：</p><ul><li><p><code>--service-account-issuer</code></p><p>此参数可作为服务账号令牌发放者的身份标识（Identifier）。你可以多次指定
<code>--service-account-issuer</code> 参数，对于要变更发放者而又不想带来业务中断的场景，
这样做是有用的。如果这个参数被多次指定，则第一个参数值会被用来生成令牌，
而所有参数值都会被用来确定哪些发放者是可接受的。你所运行的 Kubernetes
集群必须是 v1.22 或更高版本，才能多次指定 <code>--service-account-issuer</code>。</p></li></ul><ul><li><p><code>--service-account-key-file</code></p><p>包含 PEM 编码的 x509 RSA 或 ECDSA 私钥或公钥，用来检查 ServiceAccount
的令牌。所指定的文件中可以包含多个秘钥，并且你可以多次使用此参数，
每次参数值为不同的文件。多次使用此参数时，由所给的秘钥之一签名的令牌会被
Kubernetes API 服务器认为是合法令牌。</p></li></ul><ul><li><p><code>--service-account-signing-key-file</code></p><p>指向包含当前服务账号令牌发放者的私钥的文件路径。
此发放者使用此私钥来签署所发放的 ID 令牌。</p></li></ul><ul><li><p><code>--api-audiences</code> (可以省略)</p><p>服务账号令牌身份检查组件会检查针对 API 访问所使用的令牌，
确认令牌至少是被绑定到这里所给的受众（audiences）之一。
如果此参数被多次指定，则针对所给的多个受众中任何目标的令牌都会被
Kubernetes API 服务器当做合法的令牌。如果 <code>--service-account-issuer</code>
参数被设置，而这个参数未指定，则这个参数的默认值为一个只有一个元素的列表，
且该元素为令牌发放者的 URL。</p></li></ul><p>kubelet 还可以将服务账号令牌投射到 Pod 中。
你可以指定令牌的期望属性，例如受众和有效期限。
这些属性在 default 服务账号令牌上无法配置。
当删除 Pod 或 ServiceAccount 时，服务账号令牌也将对 API 无效。</p><p>使用名为 <a href=/zh-cn/docs/concepts/storage/volumes/#projected>ServiceAccountToken</a> 的
ProjectedVolume 类型在 PodSpec 上配置此功能。
要向 Pod 提供具有 "vault" 用户以及两个小时有效期的令牌，可以在 PodSpec 中配置以下内容：</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/pods/pod-projected-svc-token.yaml download=pods/pod-projected-svc-token.yaml><code>pods/pod-projected-svc-token.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-pod-projected-svc-token-yaml")' title="Copy pods/pod-projected-svc-token.yaml to clipboard"></img></div><div class=includecode id=pods-pod-projected-svc-token-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/run/secrets/tokens<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>vault-token<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>serviceAccountName</span>:<span style=color:#bbb> </span>build-robot<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>vault-token<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>projected</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>sources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>serviceAccountToken</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>vault-token<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>expirationSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>7200</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>audience</span>:<span style=color:#bbb> </span>vault<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>创建 Pod：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f https://k8s.io/examples/pods/pod-projected-svc-token.yaml
</span></span></code></pre></div><p><code>kubelet</code> 组件会替 Pod 请求令牌并将其保存起来，
通过将令牌存储到一个可配置的路径使之在 Pod 内可用，
并在令牌快要到期的时候刷新它。
<code>kubelet</code> 会在令牌存在期达到其 TTL 的 80% 的时候或者令牌生命期超过
24 小时的时候主动轮换它。</p><p>应用程序负责在令牌被轮换时重新加载其内容。对于大多数使用场景而言，
周期性地（例如，每隔 5 分钟）重新加载就足够了。</p><h2 id=发现服务账号分发者>发现服务账号分发者</h2><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.21 [stable]</code></div><p>当启用服务账号令牌投射时启用发现服务账号分发者（Service Account Issuer Discovery）
这一功能特性，如<a href=#service-account-token-volume-projection>上文所述</a>。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>分发者的 URL 必须遵从
<a href=https://openid.net/specs/openid-connect-discovery-1_0.html>OIDC 发现规范</a>。
这意味着 URL 必须使用 <code>https</code> 模式，并且必须在
<code>{service-account-issuer}/.well-known/openid-configuration</code>
路径给出 OpenID 提供者（Provider）配置。</p><p>如果 URL 没有遵从这一规范，<code>ServiceAccountIssuerDiscovery</code> 末端就不会被注册，
即使该特性已经被启用。</p></div><p>发现服务账号分发者这一功能使得用户能够用联邦的方式结合使用 Kubernetes
集群（“Identity Provider”，标识提供者）与外部系统（“Relying Parties”，
依赖方）所分发的服务账号令牌。</p><p>当此功能被启用时，Kubernetes API 服务器会在 <code>/.well-known/openid-configuration</code>
提供一个 OpenID 提供者配置文档，并在 <code>/openid/v1/jwks</code> 处提供与之关联的
JSON Web Key Set（JWKS）。
这里的 OpenID 提供者配置有时候也被称作“发现文档（Discovery Document）”。</p><p>集群包括一个的默认 RBAC ClusterRole, 名为 <code>system:service-account-issuer-discovery</code>。
默认的 RBAC ClusterRoleBinding 将此角色分配给 <code>system:serviceaccounts</code> 组，
所有服务账号隐式属于该组。这使得集群上运行的 Pod
能够通过它们所挂载的服务账号令牌访问服务账号发现文档。
此外，管理员可以根据其安全性需要以及期望集成的外部系统选择是否将该角色绑定到
<code>system:authenticated</code> 或 <code>system:unauthenticated</code>。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong> 对 <code>/.well-known/openid-configuration</code> 和 <code>/openid/v1/jwks</code> 路径请求的响应被设计为与
OIDC 兼容，但不是与其完全一致。
返回的文档仅包含对 Kubernetes 服务账号令牌进行验证所必须的参数。</div><p>JWKS 响应包含依赖方可以用来验证 Kubernetes 服务账号令牌的公钥数据。
依赖方先会查询 OpenID 提供者配置，之后使用返回响应中的 <code>jwks_uri</code> 来查找 JWKS。</p><p>在很多场合，Kubernetes API 服务器都不会暴露在公网上，不过对于缓存并向外提供 API
服务器响应数据的公开末端而言，用户或者服务提供商可以选择将其暴露在公网上。
在这种环境中，可能会重载 OpenID 提供者配置中的
<code>jwks_uri</code>，使之指向公网上可用的末端地址，而不是 API 服务器的地址。
这时需要向 API 服务器传递 <code>--service-account-jwks-uri</code> 参数。
与分发者 URL 类似，此 JWKS URI 也需要使用 <code>https</code> 模式。</p><h2 id=接下来>接下来</h2><p>另请参见：</p><ul><li><a href=/zh-cn/docs/reference/access-authn-authz/service-accounts-admin/>服务账号的集群管理员指南</a></li><li><a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-auth/1393-oidc-discovery>服务账号签署密钥检索 KEP</a></li><li><a href=https://openid.net/specs/openid-connect-discovery-1_0.html>OIDC 发现规范</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-d385b86a7cb496d3b1c3b2a47280ca70>13 - 从私有仓库拉取镜像</h1><p>本文介绍如何使用 <a class=glossary-tooltip title='Secret 用于存储敏感信息，如密码、 OAuth 令牌和 SSH 密钥。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/configuration/secret/ target=_blank aria-label=Secret>Secret</a>
从私有的镜像仓库或代码仓库拉取镜像来创建 Pod。
有很多私有镜像仓库正在使用中。这个任务使用的镜像仓库是
<a href=https://www.docker.com/products/docker-hub>Docker Hub</a>。</p><div class="alert alert-secondary callout third-party-content" role=alert>&#128711; 本条目指向第三方项目或产品，而该项目（产品）不是 Kubernetes 的一部分。<a class=alert-more-info href=#third-party-content-disclaimer>更多信息</a></div><h2 id=准备开始>准备开始</h2><ul><li><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li></ul></li></ul><ul><li>要进行此练习，你需要 <code>docker</code> 命令行工具和一个知道密码的
<a href=https://docs.docker.com/docker-id/>Docker ID</a>。</li><li>如果你要使用不同的私有的镜像仓库，你需要有对应镜像仓库的命令行工具和登录信息。</li></ul><h2 id=log-in-to-docker>登录 Docker 镜像仓库</h2><p>在个人电脑上，要想拉取私有镜像必须在镜像仓库上进行身份验证。</p><p>使用 <code>docker</code> 命令工具来登录到 Docker Hub。
更多详细信息，请查阅
<a href=https://docs.docker.com/docker-id/#log-in>Docker ID accounts</a> 中的 <strong>log in</strong> 部分。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker login
</span></span></code></pre></div><p>当出现提示时，输入你的 Docker ID 和登录凭证（访问令牌、
或 Docker ID 的密码）。</p><p>登录过程会创建或更新保存有授权令牌的 <code>config.json</code> 文件。
查看 <a href=/zh-cn/docs/concepts/containers/images#config-json>Kubernetes 中如何解析这个文件</a>。</p><p>查看 <code>config.json</code> 文件：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat ~/.docker/config.json
</span></span></code></pre></div><p>输出结果包含类似于以下内容的部分：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;auths&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;https://index.docker.io/v1/&#34;</span>: {
</span></span><span style=display:flex><span>            <span style=color:green;font-weight:700>&#34;auth&#34;</span>: <span style=color:#b44>&#34;c3R...zE2&#34;</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>如果使用 Docker 凭证仓库，则不会看到 <code>auth</code> 条目，看到的将是以仓库名称作为值的 <code>credsStore</code> 条目。
在这种情况下，你可以直接创建一个 Secret。请参阅<a href=#create-a-secret-by-providing-credentials-on-the-command-line>在命令行上提供凭证来创建 Secret</a>。</div><h2 id=registry-secret-existing-credentials>创建一个基于现有凭证的 Secret</h2><p>Kubernetes 集群使用 <code>kubernetes.io/dockerconfigjson</code> 类型的
Secret 来通过镜像仓库的身份验证，进而提取私有镜像。</p><p>如果你已经运行了 <code>docker login</code> 命令，你可以复制该镜像仓库的凭证到 Kubernetes:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret generic regcred <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    --from-file<span style=color:#666>=</span>.dockerconfigjson<span style=color:#666>=</span>&lt;path/to/.docker/config.json&gt; <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    --type<span style=color:#666>=</span>kubernetes.io/dockerconfigjson
</span></span></code></pre></div><p>如果你需要更多的设置（例如，为新 Secret 设置名字空间或标签），
则可以在存储 Secret 之前对它进行自定义。
请务必：</p><ul><li>将 data 项中的名称设置为 <code>.dockerconfigjson</code></li><li>使用 base64 编码方法对 Docker 配置文件进行编码，然后粘贴该字符串的内容，作为字段
<code>data[".dockerconfigjson"]</code> 的值</li><li>将 <code>type</code> 设置为 <code>kubernetes.io/dockerconfigjson</code></li></ul><p>示例：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myregistrykey<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>awesomeapps<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>.dockerconfigjson</span>:<span style=color:#bbb> </span>UmVhbGx5IHJlYWxseSByZWVlZWVlZWVlZWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGxsbGx5eXl5eXl5eXl5eXl5eXl5eXl5eSBsbGxsbGxsbGxsbGxsbG9vb29vb29vb29vb29vb29vb29vb29vb29vb25ubm5ubm5ubm5ubm5ubm5ubm5ubm5ubmdnZ2dnZ2dnZ2dnZ2dnZ2dnZ2cgYXV0aCBrZXlzCg==<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>kubernetes.io/dockerconfigjson<span style=color:#bbb>
</span></span></span></code></pre></div><p>如果你收到错误消息：<code>error: no objects passed to create</code>，
这可能意味着 base64 编码的字符串是无效的。如果你收到类似
<code>Secret "myregistrykey" is invalid: data[.dockerconfigjson]: invalid value ...</code>
的错误消息，则表示数据中的 base64 编码字符串已成功解码，
但无法解析为 <code>.docker/config.json</code> 文件。</p><h2 id=create-a-secret-by-providing-credentials-on-the-command-line>在命令行上提供凭证来创建 Secret</h2><p>创建 Secret，命名为 <code>regcred</code>：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret docker-registry regcred <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --docker-server<span style=color:#666>=</span>&lt;你的镜像仓库服务器&gt; <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --docker-username<span style=color:#666>=</span>&lt;你的用户名&gt; <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --docker-password<span style=color:#666>=</span>&lt;你的密码&gt; <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --docker-email<span style=color:#666>=</span>&lt;你的邮箱地址&gt;
</span></span></code></pre></div><p>在这里：</p><ul><li><code>&lt;your-registry-server></code> 是你的私有 Docker 仓库全限定域名（FQDN）。
DockerHub 使用 <code>https://index.docker.io/v1/</code>。</li><li><code>&lt;your-name></code> 是你的 Docker 用户名。</li><li><code>&lt;your-pword></code> 是你的 Docker 密码。</li><li><code>&lt;your-email></code> 是你的 Docker 邮箱。</li></ul><p>这样你就成功地将集群中的 Docker 凭证设置为名为 <code>regcred</code> 的 Secret。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong> 在命令行上键入 Secret 可能会将它们存储在你的 shell 历史记录中而不受保护，
并且这些 Secret 信息也可能在 <code>kubectl</code> 运行期间对你 PC 上的其他用户可见。</div><h2 id=inspecting-the-secret-regcred>检查 Secret <code>regcred</code></h2><p>要了解你创建的 <code>regcred</code> Secret 的内容，可以用 YAML 格式进行查看：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get secret regcred --output<span style=color:#666>=</span>yaml
</span></span></code></pre></div><p>输出和下面类似：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>.dockerconfigjson</span>:<span style=color:#bbb> </span>eyJodHRwczovL2luZGV4L ... J0QUl6RTIifX0=<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>regcred<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>.dockerconfigjson</span>:<span style=color:#bbb> </span>eyJodHRwczovL2luZGV4L ... J0QUl6RTIifX0=<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>kubernetes.io/dockerconfigjson<span style=color:#bbb>
</span></span></span></code></pre></div><p><code>.dockerconfigjson</code> 字段的值是 Docker 凭证的 base64 表示。</p><p>要了解 <code>dockerconfigjson</code> 字段中的内容，请将 Secret 数据转换为可读格式：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get secret regcred --output<span style=color:#666>=</span><span style=color:#b44>&#34;jsonpath={.data.\.dockerconfigjson}&#34;</span> | base64 --decode
</span></span></code></pre></div><p>输出和下面类似：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{<span style=color:green;font-weight:700>&#34;auths&#34;</span>:{<span style=color:green;font-weight:700>&#34;your.private.registry.example.com&#34;</span>:{<span style=color:green;font-weight:700>&#34;username&#34;</span>:<span style=color:#b44>&#34;janedoe&#34;</span>,<span style=color:green;font-weight:700>&#34;password&#34;</span>:<span style=color:#b44>&#34;xxxxxxxxxxx&#34;</span>,<span style=color:green;font-weight:700>&#34;email&#34;</span>:<span style=color:#b44>&#34;jdoe@example.com&#34;</span>,<span style=color:green;font-weight:700>&#34;auth&#34;</span>:<span style=color:#b44>&#34;c3R...zE2&#34;</span>}}}
</span></span></code></pre></div><p>要了解 <code>auth</code> 字段中的内容，请将 base64 编码过的数据转换为可读格式：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b44>&#34;c3R...zE2&#34;</span> | base64 --decode
</span></span></code></pre></div><p>输出结果中，用户名和密码用 <code>:</code> 链接，类似下面这样：</p><pre tabindex=0><code class=language-none data-lang=none>janedoe:xxxxxxxxxxx
</code></pre><p>注意，Secret 数据包含与本地 <code>~/.docker/config.json</code> 文件类似的授权令牌。</p><p>这样你就已经成功地将 Docker 凭证设置为集群中的名为 <code>regcred</code> 的 Secret。</p><h2 id=create-a-pod-that-uses-your-secret>创建一个使用你的 Secret 的 Pod</h2><p>下面是一个 Pod 配置清单示例，该示例中 Pod 需要访问你的 Docker 凭证 <code>regcred</code>：</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/pods/private-reg-pod.yaml download=pods/private-reg-pod.yaml><code>pods/private-reg-pod.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-private-reg-pod-yaml")' title="Copy pods/private-reg-pod.yaml to clipboard"></img></div><div class=includecode id=pods-private-reg-pod-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>private-reg<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>private-reg-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>&lt;your-private-image&gt;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>imagePullSecrets</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>regcred<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>将上述文件下载到你的计算机中：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -L -o my-private-reg-pod.yaml https://k8s.io/examples/pods/private-reg-pod.yaml
</span></span></code></pre></div><p>在 <code>my-private-reg-pod.yaml</code> 文件中，使用私有仓库的镜像路径替换 <code>&lt;your-private-image></code>，例如：</p><pre tabindex=0><code class=language-none data-lang=none>your.private.registry.example.com/janedoe/jdoe-private:v1
</code></pre><p>要从私有仓库拉取镜像，Kubernetes 需要凭证。
配置文件中的 <code>imagePullSecrets</code> 字段表明 Kubernetes 应该通过名为 <code>regcred</code> 的 Secret 获取凭证。</p><p>创建使用了你的 Secret 的 Pod，并检查它是否正常运行：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f my-private-reg-pod.yaml
</span></span><span style=display:flex><span>kubectl get pod private-reg
</span></span></code></pre></div><h2 id=接下来>接下来</h2><ul><li>进一步了解 <a href=/zh-cn/docs/concepts/configuration/secret/>Secret</a><ul><li>或阅读
<a href=/zh-cn/docs/reference/kubernetes-api/config-and-storage-resources/secret-v1/>Secret</a> 的 API 参考</li></ul></li><li>进一步了解<a href=/zh-cn/docs/concepts/containers/images/#using-a-private-registry>使用私有仓库</a></li><li>进一步了解<a href=/zh-cn/docs/tasks/configure-pod-container/configure-service-account/#add-imagepullsecrets-to-a-service-account>为服务账户添加拉取镜像凭证</a></li><li>查看 <a href=/docs/reference/generated/kubectl/kubectl-commands/#-em-secret-docker-registry-em->kubectl 创建 docker-registry 凭证</a></li><li>查看 Pod <a href=/zh-cn/docs/reference/kubernetes-api/workload-resources/pod-v1/#containers>容器定义</a>中的 <code>imagePullSecrets</code> 字段。</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-eb54daf87df373096b5e830680194dfc>14 - 配置存活、就绪和启动探针</h1><p>这篇文章介绍如何给容器配置存活（Liveness）、就绪（Readiness）和启动（Startup）探针。</p><p><a href=/zh-cn/docs/reference/command-line-tools-reference/kubelet/>kubelet</a>
使用存活探针来确定什么时候要重启容器。
例如，存活探针可以探测到应用死锁（应用程序在运行，但是无法继续执行后面的步骤）情况。
重启这种状态下的容器有助于提高应用的可用性，即使其中存在缺陷。</p><p>kubelet 使用就绪探针可以知道容器何时准备好接受请求流量，当一个 Pod
内的所有容器都就绪时，才能认为该 Pod 就绪。
这种信号的一个用途就是控制哪个 Pod 作为 Service 的后端。
若 Pod 尚未就绪，会被从 Service 的负载均衡器中剔除。</p><p>kubelet 使用启动探针来了解应用容器何时启动。
如果配置了这类探针，你就可以控制容器在启动成功后再进行存活性和就绪态检查，
确保这些存活、就绪探针不会影响应用的启动。
启动探针可以用于对慢启动容器进行存活性检测，避免它们在启动运行之前就被杀掉。</p><h2 id=准备开始>准备开始</h2><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li></ul><h2 id=define-a-liveness-command>定义存活命令</h2><p>许多长时间运行的应用最终会进入损坏状态，除非重新启动，否则无法被恢复。
Kubernetes 提供了存活探针来发现并处理这种情况。</p><p>在本练习中，你会创建一个 Pod，其中运行一个基于 <code>registry.k8s.io/busybox</code> 镜像的容器。
下面是这个 Pod 的配置文件。</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/pods/probe/exec-liveness.yaml download=pods/probe/exec-liveness.yaml><code>pods/probe/exec-liveness.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-probe-exec-liveness-yaml")' title="Copy pods/probe/exec-liveness.yaml to clipboard"></img></div><div class=includecode id=pods-probe-exec-liveness-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>test</span>:<span style=color:#bbb> </span>liveness<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>liveness-exec<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>liveness<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>registry.k8s.io/busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- /bin/sh<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- -c<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- touch /tmp/healthy; sleep 30; rm -f /tmp/healthy; sleep 600<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>livenessProbe</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>exec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- cat<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- /tmp/healthy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>initialDelaySeconds</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>在这个配置文件中，可以看到 Pod 中只有一个 <code>Container</code>。
<code>periodSeconds</code> 字段指定了 kubelet 应该每 5 秒执行一次存活探测。
<code>initialDelaySeconds</code> 字段告诉 kubelet 在执行第一次探测前应该等待 5 秒。
kubelet 在容器内执行命令 <code>cat /tmp/healthy</code> 来进行探测。
如果命令执行成功并且返回值为 0，kubelet 就会认为这个容器是健康存活的。
如果这个命令返回非 0 值，kubelet 会杀死这个容器并重新启动它。</p><p>当容器启动时，执行如下的命令：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>/bin/sh -c <span style=color:#b44>&#34;touch /tmp/healthy; sleep 30; rm -f /tmp/healthy; sleep 600&#34;</span>
</span></span></code></pre></div><p>这个容器生命的前 30 秒，<code>/tmp/healthy</code> 文件是存在的。
所以在这最开始的 30 秒内，执行命令 <code>cat /tmp/healthy</code> 会返回成功代码。
30 秒之后，执行命令 <code>cat /tmp/healthy</code> 就会返回失败代码。</p><p>创建 Pod：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/probe/exec-liveness.yaml
</span></span></code></pre></div><p>在 30 秒内，查看 Pod 的事件：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe pod liveness-exec
</span></span></code></pre></div><p>输出结果表明还没有存活探针失败：</p><pre tabindex=0><code>Type    Reason     Age   From               Message
  ----    ------     ----  ----               -------
  Normal  Scheduled  11s   default-scheduler  Successfully assigned default/liveness-exec to node01
  Normal  Pulling    9s    kubelet, node01    Pulling image &#34;registry.k8s.io/busybox&#34;
  Normal  Pulled     7s    kubelet, node01    Successfully pulled image &#34;registry.k8s.io/busybox&#34;
  Normal  Created    7s    kubelet, node01    Created container liveness
  Normal  Started    7s    kubelet, node01    Started container liveness
</code></pre><p>35 秒之后，再来看 Pod 的事件：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe pod liveness-exec
</span></span></code></pre></div><p>在输出结果的最下面，有信息显示存活探针失败了，这个失败的容器被杀死并且被重建了。</p><pre tabindex=0><code>  Type     Reason     Age                From               Message
  ----     ------     ----               ----               -------
  Normal   Scheduled  57s                default-scheduler  Successfully assigned default/liveness-exec to node01
  Normal   Pulling    55s                kubelet, node01    Pulling image &#34;registry.k8s.io/busybox&#34;
  Normal   Pulled     53s                kubelet, node01    Successfully pulled image &#34;registry.k8s.io/busybox&#34;
  Normal   Created    53s                kubelet, node01    Created container liveness
  Normal   Started    53s                kubelet, node01    Started container liveness
  Warning  Unhealthy  10s (x3 over 20s)  kubelet, node01    Liveness probe failed: cat: can&#39;t open &#39;/tmp/healthy&#39;: No such file or directory
  Normal   Killing    10s                kubelet, node01    Container liveness failed liveness probe, will be restarted
</code></pre><p>再等 30 秒，确认这个容器被重启了：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod liveness-exec
</span></span></code></pre></div><p>输出结果显示 <code>RESTARTS</code> 的值增加了 1。
请注意，一旦失败的容器恢复为运行状态，<code>RESTARTS</code> 计数器就会增加 1：</p><pre tabindex=0><code>NAME            READY     STATUS    RESTARTS   AGE
liveness-exec   1/1       Running   1          1m
</code></pre><h2 id=define-a-liveness-HTTP-request>定义一个存活态 HTTP 请求接口</h2><p>另外一种类型的存活探测方式是使用 HTTP GET 请求。
下面是一个 Pod 的配置文件，其中运行一个基于 <code>registry.k8s.io/liveness</code> 镜像的容器。</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/pods/probe/http-liveness.yaml download=pods/probe/http-liveness.yaml><code>pods/probe/http-liveness.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-probe-http-liveness-yaml")' title="Copy pods/probe/http-liveness.yaml to clipboard"></img></div><div class=includecode id=pods-probe-http-liveness-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>test</span>:<span style=color:#bbb> </span>liveness<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>liveness-http<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>liveness<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>registry.k8s.io/liveness<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- /server<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>livenessProbe</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>httpGet</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/healthz<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>httpHeaders</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>Custom-Header<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span>Awesome<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>initialDelaySeconds</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>在这个配置文件中，你可以看到 Pod 也只有一个容器。
<code>periodSeconds</code> 字段指定了 kubelet 每隔 3 秒执行一次存活探测。
<code>initialDelaySeconds</code> 字段告诉 kubelet 在执行第一次探测前应该等待 3 秒。
kubelet 会向容器内运行的服务（服务在监听 8080 端口）发送一个 HTTP GET 请求来执行探测。
如果服务器上 <code>/healthz</code> 路径下的处理程序返回成功代码，则 kubelet 认为容器是健康存活的。
如果处理程序返回失败代码，则 kubelet 会杀死这个容器并将其重启。</p><p>返回大于或等于 200 并且小于 400 的任何代码都标示成功，其它返回代码都标示失败。</p><p>你可以访问 <a href=https://github.com/kubernetes/kubernetes/blob/master/test/images/agnhost/liveness/server.go>server.go</a>。
阅读服务的源码。
容器存活期间的最开始 10 秒中，<code>/healthz</code> 处理程序返回 200 的状态码。
之后处理程序返回 500 的状态码。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>http.<span style=color:#00a000>HandleFunc</span>(<span style=color:#b44>&#34;/healthz&#34;</span>, <span style=color:#a2f;font-weight:700>func</span>(w http.ResponseWriter, r <span style=color:#666>*</span>http.Request) {
</span></span><span style=display:flex><span>    duration <span style=color:#666>:=</span> time.<span style=color:#00a000>Now</span>().<span style=color:#00a000>Sub</span>(started)
</span></span><span style=display:flex><span>    <span style=color:#a2f;font-weight:700>if</span> duration.<span style=color:#00a000>Seconds</span>() &gt; <span style=color:#666>10</span> {
</span></span><span style=display:flex><span>        w.<span style=color:#00a000>WriteHeader</span>(<span style=color:#666>500</span>)
</span></span><span style=display:flex><span>        w.<span style=color:#00a000>Write</span>([]<span style=color:#a2f>byte</span>(fmt.<span style=color:#00a000>Sprintf</span>(<span style=color:#b44>&#34;error: %v&#34;</span>, duration.<span style=color:#00a000>Seconds</span>())))
</span></span><span style=display:flex><span>    } <span style=color:#a2f;font-weight:700>else</span> {
</span></span><span style=display:flex><span>        w.<span style=color:#00a000>WriteHeader</span>(<span style=color:#666>200</span>)
</span></span><span style=display:flex><span>        w.<span style=color:#00a000>Write</span>([]<span style=color:#a2f>byte</span>(<span style=color:#b44>&#34;ok&#34;</span>))
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>})
</span></span></code></pre></div><p>kubelet 在容器启动之后 3 秒开始执行健康检测。所以前几次健康检查都是成功的。
但是 10 秒之后，健康检查会失败，并且 kubelet 会杀死容器再重新启动容器。</p><p>创建一个 Pod 来测试 HTTP 的存活检测：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/probe/http-liveness.yaml
</span></span></code></pre></div><p>10 秒之后，通过查看 Pod 事件来确认存活探针已经失败，并且容器被重新启动了。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe pod liveness-http
</span></span></code></pre></div><p>在 1.13 之前（包括 1.13）的版本中，如果在 Pod 运行的节点上设置了环境变量
<code>http_proxy</code>（或者 <code>HTTP_PROXY</code>），HTTP 的存活探测会使用这个代理。
在 1.13 之后的版本中，设置本地的 HTTP 代理环境变量不会影响 HTTP 的存活探测。</p><h2 id=define-a-TCP-liveness-probe>定义 TCP 的存活探测</h2><p>第三种类型的存活探测是使用 TCP 套接字。
使用这种配置时，kubelet 会尝试在指定端口和容器建立套接字链接。
如果能建立连接，这个容器就被看作是健康的，如果不能则这个容器就被看作是有问题的。</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/pods/probe/tcp-liveness-readiness.yaml download=pods/probe/tcp-liveness-readiness.yaml><code>pods/probe/tcp-liveness-readiness.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-probe-tcp-liveness-readiness-yaml")' title="Copy pods/probe/tcp-liveness-readiness.yaml to clipboard"></img></div><div class=includecode id=pods-probe-tcp-liveness-readiness-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>goproxy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>goproxy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>goproxy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>registry.k8s.io/goproxy:0.1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>readinessProbe</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>tcpSocket</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>initialDelaySeconds</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>livenessProbe</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>tcpSocket</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>initialDelaySeconds</span>:<span style=color:#bbb> </span><span style=color:#666>15</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>20</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>如你所见，TCP 检测的配置和 HTTP 检测非常相似。
下面这个例子同时使用就绪和存活探针。kubelet 会在容器启动 5 秒后发送第一个就绪探针。
探针会尝试连接 <code>goproxy</code> 容器的 8080 端口。
如果探测成功，这个 Pod 会被标记为就绪状态，kubelet 将继续每隔 10 秒运行一次探测。</p><p>除了就绪探针，这个配置包括了一个存活探针。
kubelet 会在容器启动 15 秒后进行第一次存活探测。
与就绪探针类似，存活探针会尝试连接 <code>goproxy</code> 容器的 8080 端口。
如果存活探测失败，容器会被重新启动。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/probe/tcp-liveness-readiness.yaml
</span></span></code></pre></div><p>15 秒之后，通过看 Pod 事件来检测存活探针：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe pod goproxy
</span></span></code></pre></div><h2 id=定义-grpc-存活探针>定义 gRPC 存活探针</h2><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.24 [beta]</code></div><p>如果你的应用实现了
<a href=https://github.com/grpc/grpc/blob/master/doc/health-checking.md>gRPC 健康检查协议</a>，
kubelet 可以配置为使用该协议来执行应用存活性检查。
你必须启用 <code>GRPCContainerProbe</code>
<a href=/zh-cn/docs/reference/command-line-tools-reference/feature-gates/>特性门控</a>
才能配置依赖于 gRPC 的检查机制。</p><p>下面是一个示例清单：</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/pods/probe/grpc-liveness.yaml download=pods/probe/grpc-liveness.yaml><code>pods/probe/grpc-liveness.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-probe-grpc-liveness-yaml")' title="Copy pods/probe/grpc-liveness.yaml to clipboard"></img></div><div class=includecode id=pods-probe-grpc-liveness-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>etcd-with-grpc<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>etcd<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>registry.k8s.io/etcd:3.5.1-0<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;/usr/local/bin/etcd&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;--data-dir&#34;</span>,<span style=color:#bbb>  </span><span style=color:#b44>&#34;/var/lib/etcd&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;--listen-client-urls&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;http://0.0.0.0:2379&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;--advertise-client-urls&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;http://127.0.0.1:2379&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;--log-level&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;debug&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>2379</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>livenessProbe</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>grpc</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>2379</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>initialDelaySeconds</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>要使用 gRPC 探针，必须配置 <code>port</code> 属性。如果健康状态端点配置在非默认服务之上，
你还必须设置 <code>service</code> 属性。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>与 HTTP 和 TCP 探针不同，gRPC 探测不能使用命名端口或定制主机。</div><p>配置问题（例如：错误的 <code>port</code> 和 <code>service</code>、未实现健康检查协议）
都被认作是探测失败，这一点与 HTTP 和 TCP 探针类似。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/probe/grpc-liveness.yaml
</span></span></code></pre></div><p>15 秒钟之后，查看 Pod 事件确认存活性检查并未失败：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe pod etcd-with-grpc
</span></span></code></pre></div><p>在 Kubernetes 1.23 之前，gRPC 健康探测通常使用
<a href=https://github.com/grpc-ecosystem/grpc-health-probe/>grpc-health-probe</a>
来实现，如博客 <a href=/blog/2018/10/01/health-checking-grpc-servers-on-kubernetes/>Health checking gRPC servers on Kubernetes（对 Kubernetes 上的 gRPC 服务器执行健康检查）</a>所描述。
内置的 gRPC 探针行为与 <code>grpc-health-probe</code> 所实现的行为类似。
从 <code>grpc-health-probe</code> 迁移到内置探针时，请注意以下差异：</p><ul><li>内置探针运行时针对的是 Pod 的 IP 地址，不像 <code>grpc-health-probe</code>
那样通常针对 <code>127.0.0.1</code> 执行探测；
请一定配置你的 gRPC 端点使之监听于 Pod 的 IP 地址之上。</li><li>内置探针不支持任何身份认证参数（例如 <code>-tls</code>）。</li><li>对于内置的探针而言，不存在错误代码。所有错误都被视作探测失败。</li><li>如果 <code>ExecProbeTimeout</code> 特性门控被设置为 <code>false</code>，则 <code>grpc-health-probe</code>
不会考虑 <code>timeoutSeconds</code> 设置状态（默认值为 1s），
而内置探针则会在超时时返回失败。</li></ul><h2 id=use-a-named-port>使用命名端口</h2><p>对于 HTTP 和 TCP 存活检测可以使用命名的
<a href=/zh-cn/docs/reference/kubernetes-api/workload-resources/pod-v1/#ports><code>port</code></a>（gRPC 探针不支持使用命名端口）。</p><p>例如：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>liveness-port<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostPort</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>livenessProbe</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>httpGet</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/healthz<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span>liveness-port<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=define-startup-probes>使用启动探针保护慢启动容器</h2><p>有时候，会有一些现有的应用在启动时需要较长的初始化时间。
要这种情况下，若要不影响对死锁作出快速响应的探测，设置存活探测参数是要技巧的。
技巧就是使用相同的命令来设置启动探测，针对 HTTP 或 TCP 检测，可以通过将
<code>failureThreshold * periodSeconds</code> 参数设置为足够长的时间来应对糟糕情况下的启动时间。</p><p>这样，前面的例子就变成了：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>liveness-port<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostPort</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>livenessProbe</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>httpGet</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/healthz<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span>liveness-port<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>failureThreshold</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>startupProbe</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>httpGet</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/healthz<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span>liveness-port<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>failureThreshold</span>:<span style=color:#bbb> </span><span style=color:#666>30</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>幸亏有启动探测，应用程序将会有最多 5 分钟（30 * 10 = 300s）的时间来完成其启动过程。
一旦启动探测成功一次，存活探测任务就会接管对容器的探测，对容器死锁作出快速响应。
如果启动探测一直没有成功，容器会在 300 秒后被杀死，并且根据 <code>restartPolicy</code>
来执行进一步处置。</p><h2 id=define-readiness-probes>定义就绪探针</h2><p>有时候，应用会暂时性地无法为请求提供服务。
例如，应用在启动时可能需要加载大量的数据或配置文件，或是启动后要依赖等待外部服务。
在这种情况下，既不想杀死应用，也不想给它发送请求。
Kubernetes 提供了就绪探针来发现并缓解这些情况。
容器所在 Pod 上报还未就绪的信息，并且不接受通过 Kubernetes Service 的流量。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>就绪探针在容器的整个生命周期中保持运行状态。</div><div class="alert alert-warning caution callout" role=alert><strong>注意：</strong><p>存活探针 <strong>不等待</strong> 就绪性探针成功。
如果要在执行存活探针之前等待，应该使用 <code>initialDelaySeconds</code> 或 <code>startupProbe</code>。</div><p>就绪探针的配置和存活探针的配置相似。
唯一区别就是要使用 <code>readinessProbe</code> 字段，而不是 <code>livenessProbe</code> 字段。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>readinessProbe</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>exec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- cat<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- /tmp/healthy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>initialDelaySeconds</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>HTTP 和 TCP 的就绪探针配置也和存活探针的配置完全相同。</p><p>就绪和存活探测可以在同一个容器上并行使用。
两者共同使用，可以确保流量不会发给还未就绪的容器，当这些探测失败时容器会被重新启动。</p><h2 id=configure-probes>配置探针</h2><p><a href=/docs/reference/generated/kubernetes-api/v1.25/#probe-v1-core>Probe</a>
有很多配置字段，可以使用这些字段精确地控制启动、存活和就绪检测的行为：</p><ul><li><code>initialDelaySeconds</code>：容器启动后要等待多少秒后才启动启动、存活和就绪探针，
默认是 0 秒，最小值是 0。</li><li><code>periodSeconds</code>：执行探测的时间间隔（单位是秒）。默认是 10 秒。最小值是 1。</li><li><code>timeoutSeconds</code>：探测的超时后等待多少秒。默认值是 1 秒。最小值是 1。</li><li><code>successThreshold</code>：探针在失败后，被视为成功的最小连续成功数。默认值是 1。
存活和启动探测的这个值必须是 1。最小值是 1。</li><li><code>failureThreshold</code>：当探测失败时，Kubernetes 的重试次数。
对存活探测而言，放弃就意味着重新启动容器。
对就绪探测而言，放弃意味着 Pod 会被打上未就绪的标签。默认值是 3。最小值是 1。</li></ul><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>在 Kubernetes 1.20 版本之前，<code>exec</code> 探针会忽略 <code>timeoutSeconds</code>：
探针会无限期地持续运行，甚至可能超过所配置的限期，直到返回结果为止。</p><p>这一缺陷在 Kubernetes v1.20 版本中得到修复。你可能一直依赖于之前错误的探测行为，
甚至都没有觉察到这一问题的存在，因为默认的超时值是 1 秒钟。
作为集群管理员，你可以在所有的 kubelet 上禁用 <code>ExecProbeTimeout</code>
<a href=/zh-cn/docs/reference/command-line-tools-reference/feature-gates/>特性门控</a>
（将其设置为 <code>false</code>），从而恢复之前版本中的运行行为。之后当集群中所有的
exec 探针都设置了 <code>timeoutSeconds</code> 参数后，移除此标志重载。
如果你有 Pod 受到此默认 1 秒钟超时值的影响，你应该更新这些 Pod 对应的探针的超时值，
这样才能为最终去除该特性门控做好准备。</p><p>当此缺陷被修复之后，在使用 <code>dockershim</code> 容器运行时的 Kubernetes <code>1.20+</code>
版本中，对于 exec 探针而言，容器中的进程可能会因为超时值的设置保持持续运行，
即使探针返回了失败状态。</p></div><div class="alert alert-warning caution callout" role=alert><strong>注意：</strong><p>如果就绪态探针的实现不正确，可能会导致容器中进程的数量不断上升。
如果不对其采取措施，很可能导致资源枯竭的状况。</div><h3 id=http-probes>HTTP 探测</h3><p><a href=/docs/reference/generated/kubernetes-api/v1.25/#httpgetaction-v1-core>HTTP Probes</a>
允许针对 <code>httpGet</code> 配置额外的字段：</p><ul><li><code>host</code>：连接使用的主机名，默认是 Pod 的 IP。也可以在 HTTP 头中设置 “Host” 来代替。</li><li><code>scheme</code> ：用于设置连接主机的方式（HTTP 还是 HTTPS）。默认是 "HTTP"。</li><li><code>path</code>：访问 HTTP 服务的路径。默认值为 "/"。</li><li><code>httpHeaders</code>：请求中自定义的 HTTP 头。HTTP 头字段允许重复。</li><li><code>port</code>：访问容器的端口号或者端口名。如果数字必须在 1～65535 之间。</li></ul><p>对于 HTTP 探测，kubelet 发送一个 HTTP 请求到指定的路径和端口来执行检测。
除非 <code>httpGet</code> 中的 <code>host</code> 字段设置了，否则 kubelet 默认是给 Pod 的 IP 地址发送探测。
如果 <code>scheme</code> 字段设置为了 <code>HTTPS</code>，kubelet 会跳过证书验证发送 HTTPS 请求。
大多数情况下，不需要设置 <code>host</code> 字段。
这里有个需要设置 <code>host</code> 字段的场景，假设容器监听 127.0.0.1，并且 Pod 的 <code>hostNetwork</code>
字段设置为了 <code>true</code>。那么 <code>httpGet</code> 中的 <code>host</code> 字段应该设置为 127.0.0.1。
可能更常见的情况是如果 Pod 依赖虚拟主机，你不应该设置 <code>host</code> 字段，而是应该在
<code>httpHeaders</code> 中设置 <code>Host</code>。</p><p>针对 HTTP 探针，kubelet 除了必需的 <code>Host</code> 头部之外还发送两个请求头部字段：
<code>User-Agent</code> 和 <code>Accept</code>。这些头部的默认值分别是 <code>kube-probe/{{ skew currentVersion >}}</code>
（其中 <code>1.25</code> 是 kubelet 的版本号）和 <code>*/*</code>。</p><p>你可以通过为探测设置 <code>.httpHeaders</code> 来重载默认的头部字段值；例如：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>livenessProbe</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>httpGet</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>httpHeaders</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>Accept<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span>application/json<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>startupProbe</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>httpGet</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>httpHeaders</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>User-Agent<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span>MyUserAgent<span style=color:#bbb>
</span></span></span></code></pre></div><p>你也可以通过将这些头部字段定义为空值，从请求中去掉这些头部字段。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>livenessProbe</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>httpGet</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>httpHeaders</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>Accept<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>startupProbe</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>httpGet</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>httpHeaders</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>User-Agent<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=tcp-probes>TCP 探测</h3><p>对于 TCP 探测而言，kubelet 在节点上（不是在 Pod 里面）发起探测连接，
这意味着你不能在 <code>host</code> 参数上配置服务名称，因为 kubelet 不能解析服务名称。</p><h3 id=探针层面的-terminationgraceperiodseconds>探针层面的 <code>terminationGracePeriodSeconds</code></h3><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.25 [beta]</code></div><p>在 1.21 发行版之前，Pod 层面的 <code>terminationGracePeriodSeconds</code>
被用来终止存活探测或启动探测失败的容器。
这一行为上的关联不是我们想要的，可能导致 Pod 层面设置了 <code>terminationGracePeriodSeconds</code>
时容器要花非常长的时间才能重新启动。</p><p>在 1.21 及更高版本中，用户可以指定一个探针层面的 <code>terminationGracePeriodSeconds</code>
作为探针规约的一部分。
当 Pod 层面和探针层面的 <code>terminationGracePeriodSeconds</code>
都已设置，kubelet 将使用探针层面设置的值。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>从 Kubernetes 1.25 开始，默认启用 <code>ProbeTerminationGracePeriod</code> 特性。
选择禁用此特性的用户，请注意以下事项:</p><ul><li><code>ProbeTerminationGracePeriod</code> 特性门控只能用在 API 服务器上。
kubelet 始终优先选用探针级别 <code>terminationGracePeriodSeconds</code> 字段
（如果它存在于 Pod 上）。</li></ul><ul><li>如果你已经为现有 Pod 设置了 <code>terminationGracePeriodSeconds</code>
字段并且不再希望使用针对每个探针的终止宽限期，则必须删除现有的这类 Pod。</li></ul><ul><li>当你（或控制平面或某些其他组件）创建替换 Pod，并且特性门控 <code>ProbeTerminationGracePeriod</code>
被禁用时，即使 Pod 或 Pod 模板指定了 <code>terminationGracePeriodSeconds</code> 字段，
API 服务器也会忽略探针级别的 <code>terminationGracePeriodSeconds</code> 字段设置。</li></ul></div><p>例如:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>terminationGracePeriodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>3600</span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># Pod 级别设置</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>liveness-port<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>hostPort</span>:<span style=color:#bbb> </span><span style=color:#666>8080</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>livenessProbe</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>httpGet</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/healthz<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span>liveness-port<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>failureThreshold</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>periodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>60</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 重载 Pod 级别的 terminationGracePeriodSeconds</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>terminationGracePeriodSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>60</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>探针层面的 <code>terminationGracePeriodSeconds</code> 不能用于就绪态探针。
这一设置将被 API 服务器拒绝。</p><h2 id=接下来>接下来</h2><ul><li>进一步了解<a href=/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#container-probes>容器探针</a>。</li></ul><p>你也可以阅读以下的 API 参考资料：</p><ul><li><a href=/zh-cn/docs/reference/kubernetes-api/workload-resources/pod-v1/>Pod</a>，尤其是：<ul><li><a href=/zh-cn/docs/reference/kubernetes-api/workload-resources/pod-v1/#Container>container</a></li><li><a href=/zh-cn/docs/reference/kubernetes-api/workload-resources/pod-v1/#Probe>probe</a></li></ul></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-bbc17480da6d051c696489654c64064a>15 - 将 Pod 分配给节点</h1><p>此页面显示如何将 Kubernetes Pod 指派给 Kubernetes 集群中的特定节点。</p><h2 id=准备开始>准备开始</h2><p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li></ul>要获知版本信息，请输入 <code>kubectl version</code>.</p><h2 id=给节点添加标签>给节点添加标签</h2><ol><li><p>列出你的集群中的<a class=glossary-tooltip title='Kubernetes 中的工作机器称作节点。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/architecture/nodes/ target=_blank aria-label=节点>节点</a>，
包括这些节点上的标签：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get nodes
</span></span></code></pre></div><p>输出类似如下：</p><pre tabindex=0><code>NAME      STATUS    AGE     VERSION
worker0   Ready     1d      v1.6.0+fff5156
worker1   Ready     1d      v1.6.0+fff5156
worker2   Ready     1d      v1.6.0+fff5156
</code></pre></li></ol><ol start=2><li><p>从你的节点中选择一个，为它添加标签：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl label nodes &lt;your-node-name&gt; <span style=color:#b8860b>disktype</span><span style=color:#666>=</span>ssd
</span></span></code></pre></div><p><code>&lt;your-node-name></code> 是你选择的节点的名称。</p></li></ol><ol start=3><li><p>验证你选择的节点确实带有 <code>disktype=ssd</code> 标签：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get nodes --show-labels
</span></span></code></pre></div><p>输出类似如下：</p><pre tabindex=0><code>NAME      STATUS    AGE     VERSION            LABELS
worker0   Ready     1d      v1.6.0+fff5156     ...,disktype=ssd,kubernetes.io/hostname=worker0
worker1   Ready     1d      v1.6.0+fff5156     ...,kubernetes.io/hostname=worker1
worker2   Ready     1d      v1.6.0+fff5156     ...,kubernetes.io/hostname=worker2
</code></pre><p>在前面的输出中，你可以看到 <code>worker0</code> 节点有 <code>disktype=ssd</code> 标签。</p></li></ol><h2 id=创建一个将被调度到你选择的节点的-pod>创建一个将被调度到你选择的节点的 Pod</h2><p>此 Pod 配置文件描述了一个拥有节点选择器 <code>disktype: ssd</code> 的 Pod。这表明该 Pod
将被调度到有 <code>disktype=ssd</code> 标签的节点。</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/pods/pod-nginx.yaml download=pods/pod-nginx.yaml><code>pods/pod-nginx.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-pod-nginx-yaml")' title="Copy pods/pod-nginx.yaml to clipboard"></img></div><div class=includecode id=pods-pod-nginx-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb> </span>test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>IfNotPresent<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodeSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>disktype</span>:<span style=color:#bbb> </span>ssd<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><ol><li><p>使用该配置文件创建一个 Pod，该 Pod 将被调度到你选择的节点上：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f https://k8s.io/examples/pods/pod-nginx.yaml
</span></span></code></pre></div></li></ol><ol start=2><li><p>验证 Pod 确实运行在你选择的节点上：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods --output<span style=color:#666>=</span>wide
</span></span></code></pre></div><p>输出类似如下：</p><pre tabindex=0><code>NAME     READY     STATUS    RESTARTS   AGE    IP           NODE
nginx    1/1       Running   0          13s    10.200.0.4   worker0
</code></pre></li></ol><h2 id=创建一个会被调度到特定节点上的-pod>创建一个会被调度到特定节点上的 Pod</h2><p>你也可以通过设置 <code>nodeName</code> 将某个 Pod 调度到特定的节点。</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/pods/pod-nginx-specific-node.yaml download=pods/pod-nginx-specific-node.yaml><code>pods/pod-nginx-specific-node.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-pod-nginx-specific-node-yaml")' title="Copy pods/pod-nginx-specific-node.yaml to clipboard"></img></div><div class=includecode id=pods-pod-nginx-specific-node-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodeName</span>:<span style=color:#bbb> </span>foo-node<span style=color:#bbb> </span><span style=color:#080;font-style:italic># 调度 Pod 到特定的节点</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>IfNotPresent<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>使用此配置文件来创建一个 Pod，该 Pod 将只能被调度到 <code>foo-node</code> 节点。</p><h2 id=接下来>接下来</h2><ul><li>进一步了解<a href=/zh-cn/docs/concepts/overview/working-with-objects/labels/>标签和选择算符</a></li><li>进一步了解<a href=/zh-cn/docs/concepts/architecture/nodes/>节点</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-fc3f4777ae8ea685d2b54e175277ac01>16 - 用节点亲和性把 Pods 分配到节点</h1><p>本页展示在 Kubernetes 集群中，如何使用节点亲和性把 Kubernetes Pod 分配到特定节点。</p><h2 id=准备开始>准备开始</h2><p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li></ul>你的 Kubernetes 服务器版本必须不低于版本 v1.10.
要获知版本信息，请输入 <code>kubectl version</code>.</p><h2 id=给节点添加标签>给节点添加标签</h2><ol><li><p>列出集群中的节点及其标签：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get nodes --show-labels
</span></span></code></pre></div><pre><code>输出类似于此：
</code></pre><pre tabindex=0><code>NAME      STATUS    ROLES    AGE     VERSION        LABELS
worker0   Ready     &lt;none&gt;   1d      v1.13.0        ...,kubernetes.io/hostname=worker0
worker1   Ready     &lt;none&gt;   1d      v1.13.0        ...,kubernetes.io/hostname=worker1
worker2   Ready     &lt;none&gt;   1d      v1.13.0        ...,kubernetes.io/hostname=worker2
</code></pre><ol><li>选择一个节点，给它添加一个标签：</li></ol><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl label nodes &lt;your-node-name&gt; <span style=color:#b8860b>disktype</span><span style=color:#666>=</span>ssd
</span></span></code></pre></div><p>其中 <code>&lt;your-node-name></code> 是你所选节点的名称。</p></li><li><p>验证你所选节点具有 <code>disktype=ssd</code> 标签：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get nodes --show-labels
</span></span></code></pre></div><pre><code>输出类似于此：
</code></pre><pre tabindex=0><code>NAME      STATUS    ROLES    AGE     VERSION        LABELS
worker0   Ready     &lt;none&gt;   1d      v1.13.0        ...,disktype=ssd,kubernetes.io/hostname=worker0
worker1   Ready     &lt;none&gt;   1d      v1.13.0        ...,kubernetes.io/hostname=worker1
worker2   Ready     &lt;none&gt;   1d      v1.13.0        ...,kubernetes.io/hostname=worker2
</code></pre><pre><code>在前面的输出中，可以看到 `worker0` 节点有一个 `disktype=ssd` 标签。
</code></pre></li></ol><h2 id=schedule-a-Pod-using-required-node-affinity>依据强制的节点亲和性调度 Pod</h2><p>下面清单描述了一个 Pod，它有一个节点亲和性配置 <code>requiredDuringSchedulingIgnoredDuringExecution</code>，<code>disktype=ssd</code>。
这意味着 pod 只会被调度到具有 <code>disktype=ssd</code> 标签的节点上。</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/pods/pod-nginx-required-affinity.yaml download=pods/pod-nginx-required-affinity.yaml><code>pods/pod-nginx-required-affinity.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-pod-nginx-required-affinity-yaml")' title="Copy pods/pod-nginx-required-affinity.yaml to clipboard"></img></div><div class=includecode id=pods-pod-nginx-required-affinity-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>affinity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>nodeAffinity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requiredDuringSchedulingIgnoredDuringExecution</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>nodeSelectorTerms</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>disktype<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- ssd            <span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>IfNotPresent<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><ol><li><p>执行（Apply）此清单来创建一个调度到所选节点上的 Pod：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/pod-nginx-required-affinity.yaml
</span></span></code></pre></div><ol><li>验证 pod 已经在所选节点上运行：</li></ol><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods --output<span style=color:#666>=</span>wide
</span></span></code></pre></div><pre><code>输出类似于此：
</code></pre><pre tabindex=0><code>NAME     READY     STATUS    RESTARTS   AGE    IP           NODE
nginx    1/1       Running   0          13s    10.200.0.4   worker0
</code></pre></li></ol><h2 id=schedule-a-Pod-using-preferred-node-affinity>使用首选的节点亲和性调度 Pod</h2><p>本清单描述了一个Pod，它有一个节点亲和性设置 <code>preferredDuringSchedulingIgnoredDuringExecution</code>，<code>disktype: ssd</code>。
这意味着 pod 将首选具有 <code>disktype=ssd</code> 标签的节点。</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/pods/pod-nginx-preferred-affinity.yaml download=pods/pod-nginx-preferred-affinity.yaml><code>pods/pod-nginx-preferred-affinity.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-pod-nginx-preferred-affinity-yaml")' title="Copy pods/pod-nginx-preferred-affinity.yaml to clipboard"></img></div><div class=includecode id=pods-pod-nginx-preferred-affinity-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>affinity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>nodeAffinity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>preferredDuringSchedulingIgnoredDuringExecution</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>weight</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>preference</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>disktype<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- ssd          <span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imagePullPolicy</span>:<span style=color:#bbb> </span>IfNotPresent<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><ol><li><p>执行此清单创建一个会调度到所选节点上的 Pod：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/pod-nginx-preferred-affinity.yaml
</span></span></code></pre></div><ol><li>验证 pod 是否在所选节点上运行：</li></ol><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods --output<span style=color:#666>=</span>wide
</span></span></code></pre></div><pre><code>输出类似于此：
</code></pre><pre tabindex=0><code>NAME     READY     STATUS    RESTARTS   AGE    IP           NODE
nginx    1/1       Running   0          13s    10.200.0.4   worker0
</code></pre></li></ol><h2 id=接下来>接下来</h2><p>进一步了解
<a href=/zh-cn/docs/concepts/scheduling-eviction/assign-pod-node/#node-affinity>节点亲和性</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-1e7baac1825631a5af5d2aebcf059249>17 - 配置 Pod 初始化</h1><p>本文介绍在应用容器运行前，怎样利用 Init 容器初始化 Pod。</p><h2 id=准备开始>准备开始</h2><p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li></ul>要获知版本信息，请输入 <code>kubectl version</code>.</p><h2 id=creating-a-pod-that-has-an-init-container>创建一个包含 Init 容器的 Pod</h2><p>本例中你将创建一个包含一个应用容器和一个 Init 容器的 Pod。Init 容器在应用容器启动前运行完成。</p><p>下面是 Pod 的配置文件：</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/pods/init-containers.yaml download=pods/init-containers.yaml><code>pods/init-containers.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-init-containers-yaml")' title="Copy pods/init-containers.yaml to clipboard"></img></div><div class=includecode id=pods-init-containers-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>init-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>workdir<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/usr/share/nginx/html<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 这些容器在 Pod 初始化期间运行</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>initContainers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>install<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- wget<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;-O&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;/work-dir/index.html&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- http://info.cern.ch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>workdir<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/work-dir&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>dnsPolicy</span>:<span style=color:#bbb> </span>Default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>workdir<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>配置文件中，你可以看到应用容器和 Init 容器共享了一个卷。</p><p>Init 容器将共享卷挂载到了 <code>/work-dir</code> 目录，应用容器将共享卷挂载到了 <code>/usr/share/nginx/html</code> 目录。
Init 容器执行完下面的命令就终止：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>wget -O /work-dir/index.html http://info.cern.ch
</span></span></code></pre></div><p>请注意 Init 容器在 nginx 服务器的根目录写入 <code>index.html</code>。</p><p>创建 Pod：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f https://k8s.io/examples/pods/init-containers.yaml
</span></span></code></pre></div><p>检查 nginx 容器运行正常：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod init-demo
</span></span></code></pre></div><p>结果表明 nginx 容器运行正常：</p><pre tabindex=0><code>NAME        READY     STATUS    RESTARTS   AGE
init-demo   1/1       Running   0          1m
</code></pre><p>通过 shell 进入 init-demo Pod 中的 nginx 容器：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> -it init-demo -- /bin/bash
</span></span></code></pre></div><p>在 shell 中，发送个 GET 请求到 nginx 服务器：</p><pre tabindex=0><code>root@nginx:~# apt-get update
root@nginx:~# apt-get install curl
root@nginx:~# curl localhost
</code></pre><p>结果表明 nginx 正在为 Init 容器编写的 web 页面服务：</p><pre tabindex=0><code>&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;header&gt;
&lt;title&gt;http://info.cern.ch&lt;/title&gt;
&lt;/header&gt;

&lt;h1&gt;http://info.cern.ch - home of the first website&lt;/h1&gt;
  ...
&lt;li&gt;&lt;a href=&#34;http://info.cern.ch/hypertext/WWW/TheProject.html&#34;&gt;Browse the first website&lt;/a&gt;&lt;/li&gt;
  ...
</code></pre><h2 id=接下来>接下来</h2><ul><li>进一步了解<a href=/zh-cn/docs/tasks/access-application-cluster/communicate-containers-same-pod-shared-volume/>同一 Pod 中的容器间的通信</a>。</li><li>进一步了解 <a href=/zh-cn/docs/concepts/workloads/pods/init-containers/>Init 容器</a>。</li><li>进一步了解<a href=/zh-cn/docs/concepts/storage/volumes/>卷</a>。</li><li>进一步了解 <a href=/zh-cn/docs/tasks/debug/debug-application/debug-init-containers/>Init 容器排错</a>。</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-efbc43486296f0439d1a89c12d944d94>18 - 为容器的生命周期事件设置处理函数</h1><p>这个页面将演示如何为容器的生命周期事件挂接处理函数。Kubernetes 支持 postStart 和 preStop 事件。
当一个容器启动后，Kubernetes 将立即发送 postStart 事件；在容器被终结之前，
Kubernetes 将发送一个 preStop 事件。容器可以为每个事件指定一个处理程序。</p><h2 id=准备开始>准备开始</h2><p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li></ul>要获知版本信息，请输入 <code>kubectl version</code>.</p><h2 id=定义-poststart-和-prestop-处理函数>定义 postStart 和 preStop 处理函数</h2><p>在本练习中，你将创建一个包含一个容器的 Pod，该容器为 postStart 和 preStop 事件提供对应的处理函数。</p><p>下面是对应 Pod 的配置文件：</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/pods/lifecycle-events.yaml download=pods/lifecycle-events.yaml><code>pods/lifecycle-events.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-lifecycle-events-yaml")' title="Copy pods/lifecycle-events.yaml to clipboard"></img></div><div class=includecode id=pods-lifecycle-events-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>lifecycle-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>lifecycle-demo-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>lifecycle</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>postStart</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>exec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;/bin/sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;echo Hello from the postStart handler &gt; /usr/share/message&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>preStop</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>exec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;/bin/sh&#34;</span>,<span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#b44>&#34;nginx -s quit; while killall -0 nginx; do sleep 1; done&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>在上述配置文件中，你可以看到 postStart 命令在容器的 <code>/usr/share</code> 目录下写入文件 <code>message</code>。
命令 preStop 负责优雅地终止 nginx 服务。当因为失效而导致容器终止时，这一处理方式很有用。</p><p>创建 Pod：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/lifecycle-events.yaml
</span></span></code></pre></div><p>验证 Pod 中的容器已经运行：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod lifecycle-demo
</span></span></code></pre></div><p>使用 shell 连接到你的 Pod 里的容器：</p><pre tabindex=0><code>kubectl exec -it lifecycle-demo -- /bin/bash
</code></pre><p>在 shell 中，验证 <code>postStart</code> 处理函数创建了 <code>message</code> 文件：</p><pre tabindex=0><code>root@lifecycle-demo:/# cat /usr/share/message
</code></pre><p>命令行输出的是 <code>postStart</code> 处理函数所写入的文本</p><pre tabindex=0><code>Hello from the postStart handler
</code></pre><h2 id=讨论>讨论</h2><p>Kubernetes 在容器创建后立即发送 postStart 事件。
然而，postStart 处理函数的调用不保证早于容器的入口点（entrypoint）
的执行。postStart 处理函数与容器的代码是异步执行的，但 Kubernetes
的容器管理逻辑会一直阻塞等待 postStart 处理函数执行完毕。
只有 postStart 处理函数执行完毕，容器的状态才会变成
RUNNING。</p><p>Kubernetes 在容器结束前立即发送 preStop 事件。除非 Pod 宽限期限超时，Kubernetes 的容器管理逻辑
会一直阻塞等待 preStop 处理函数执行完毕。更多的相关细节，可以参阅
<a href=/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination>Pods 的结束</a>。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong> Kubernetes 只有在 Pod <em>结束（Terminated）</em> 的时候才会发送 preStop 事件，
这意味着在 Pod <em>完成（Completed）</em> 时
preStop 的事件处理逻辑不会被触发。这个限制在
<a href=https://github.com/kubernetes/kubernetes/issues/55807>issue #55087</a> 中被追踪。</div><h2 id=接下来>接下来</h2><ul><li>进一步了解<a href=/zh-cn/docs/concepts/containers/container-lifecycle-hooks/>容器生命周期回调</a>。</li><li>进一步了解<a href=/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/>Pod 的生命周期</a>。</li></ul><h3 id=参考>参考</h3><ul><li><a href=/docs/reference/generated/kubernetes-api/v1.25/#lifecycle-v1-core>Lifecycle</a></li><li><a href=/docs/reference/generated/kubernetes-api/v1.25/#container-v1-core>Container</a></li><li>参阅 <a href=/docs/reference/generated/kubernetes-api/v1.25/#podspec-v1-core>PodSpec</a> 中关于<code>terminationGracePeriodSeconds</code> 的部分</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-ed34e761c3dbd00fa79577fa78e30020>19 - 配置 Pod 使用 ConfigMap</h1><p>很多应用在其初始化或运行期间要依赖一些配置信息。大多数时候，
存在要调整配置参数所设置的数值的需求。
ConfigMap 是 Kubernetes 用来向应用 Pod 中注入配置数据的方法。</p><p>ConfigMap 允许你将配置文件与镜像文件分离，以使容器化的应用程序具有可移植性。
本页提供了一系列使用示例，这些示例演示了如何创建 ConfigMap 以及配置 Pod
使用存储在 ConfigMap 中的数据。</p><h2 id=准备开始>准备开始</h2><p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li></ul>要获知版本信息，请输入 <code>kubectl version</code>.</p><h2 id=create-a-configmap>创建 ConfigMap</h2><p>你可以使用 <code>kubectl create configmap</code> 或者在 <code>kustomization.yaml</code> 中的 ConfigMap
生成器来创建 ConfigMap。注意，<code>kubectl</code> 从 1.14 版本开始支持 <code>kustomization.yaml</code>。</p><h3 id=create-a-configmap-using-kubectl-create-configmap>使用 kubectl create configmap 创建 ConfigMap</h3><p>你可以使用 <code>kubectl create configmap</code> 命令基于<a href=#create-configmaps-from-directories>目录</a>、
<a href=#create-configmaps-from-files>文件</a>或者<a href=#create-configmaps-from-literal-values>字面值</a>来创建
ConfigMap：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create configmap &lt;映射名称&gt; &lt;数据源&gt;
</span></span></code></pre></div><p>其中，<code>&lt;映射名称></code> 是为 ConfigMap 指定的名称，<code>&lt;数据源></code> 是要从中提取数据的目录、
文件或者字面值。ConfigMap 对象的名称必须是合法的
<a href=/zh-cn/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNS 子域名</a>.</p><p>在你基于文件来创建 ConfigMap 时，<code>&lt;数据源></code> 中的键名默认取自文件的基本名，
而对应的值则默认为文件的内容。</p><p>你可以使用 <a href=/docs/reference/generated/kubectl/kubectl-commands/#describe><code>kubectl describe</code></a> 或者
<a href=/docs/reference/generated/kubectl/kubectl-commands/#get><code>kubectl get</code></a> 获取有关 ConfigMap 的信息。</p><h4 id=create-configmaps-from-directories>基于目录创建 ConfigMap</h4><p>你可以使用 <code>kubectl create configmap</code> 基于同一目录中的多个文件创建 ConfigMap。
当你基于目录来创建 ConfigMap 时，kubectl 识别目录下基本名可以作为合法键名的文件，
并将这些文件打包到新的 ConfigMap 中。普通文件之外的所有目录项都会被忽略
（例如：子目录、符号链接、设备、管道等等）。</p><p>例如：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 创建本地目录</span>
</span></span><span style=display:flex><span>mkdir -p configure-pod-container/configmap/
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 将示例文件下载到 `configure-pod-container/configmap/` 目录</span>
</span></span><span style=display:flex><span>wget https://kubernetes.io/examples/configmap/game.properties -O configure-pod-container/configmap/game.properties
</span></span><span style=display:flex><span>wget https://kubernetes.io/examples/configmap/ui.properties -O configure-pod-container/configmap/ui.properties
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 创建 configmap</span>
</span></span><span style=display:flex><span>kubectl create configmap game-config --from-file<span style=color:#666>=</span>configure-pod-container/configmap/
</span></span></code></pre></div><p>以上命令将 <code>configure-pod-container/configmap</code> 目录下的所有文件，也就是
<code>game.properties</code> 和 <code>ui.properties</code> 打包到 game-config ConfigMap
中。你可以使用下面的命令显示 ConfigMap 的详细信息：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe configmaps game-config
</span></span></code></pre></div><p>输出类似以下内容：</p><pre tabindex=0><code>Name:         game-config
Namespace:    default
Labels:       &lt;none&gt;
Annotations:  &lt;none&gt;

Data
====
game.properties:
----
enemies=aliens
lives=3
enemies.cheat=true
enemies.cheat.level=noGoodRotten
secret.code.passphrase=UUDDLRLRBABAS
secret.code.allowed=true
secret.code.lives=30
ui.properties:
----
color.good=purple
color.bad=yellow
allow.textmode=true
how.nice.to.look=fairlyNice
</code></pre><p><code>configure-pod-container/configmap/</code> 目录中的 <code>game.properties</code> 和 <code>ui.properties</code>
文件出现在 ConfigMap 的 <code>data</code> 部分。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get configmaps game-config -o yaml
</span></span></code></pre></div><p>输出类似以下内容:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2016-02-18T18:52:05Z<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>game-config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;516&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>b4952dc3-d670-11e5-8cd0-68f728db1985<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>game.properties</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    enemies=aliens
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    lives=3
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    enemies.cheat=true
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    enemies.cheat.level=noGoodRotten
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    secret.code.passphrase=UUDDLRLRBABAS
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    secret.code.allowed=true
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    secret.code.lives=30</span><span style=color:#bbb>    
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ui.properties</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    color.good=purple
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    color.bad=yellow
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    allow.textmode=true
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    how.nice.to.look=fairlyNice</span><span style=color:#bbb>    
</span></span></span></code></pre></div><h4 id=create-configmaps-from-files>基于文件创建 ConfigMap</h4><p>你可以使用 <code>kubectl create configmap</code> 基于单个文件或多个文件创建 ConfigMap。</p><p>例如：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create configmap game-config-2 --from-file<span style=color:#666>=</span>configure-pod-container/configmap/game.properties
</span></span></code></pre></div><p>将产生以下 ConfigMap:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe configmaps game-config-2
</span></span></code></pre></div><p>输出类似以下内容:</p><pre tabindex=0><code>Name:         game-config-2
Namespace:    default
Labels:       &lt;none&gt;
Annotations:  &lt;none&gt;

Data
====
game.properties:
----
enemies=aliens
lives=3
enemies.cheat=true
enemies.cheat.level=noGoodRotten
secret.code.passphrase=UUDDLRLRBABAS
secret.code.allowed=true
secret.code.lives=30
</code></pre><p>你可以多次使用 <code>--from-file</code> 参数，从多个数据源创建 ConfigMap。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create configmap game-config-2 --from-file<span style=color:#666>=</span>configure-pod-container/configmap/game.properties --from-file<span style=color:#666>=</span>configure-pod-container/configmap/ui.properties
</span></span></code></pre></div><p>你可以使用以下命令显示 <code>game-config-2</code> ConfigMap 的详细信息：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe configmaps game-config-2
</span></span></code></pre></div><p>输出类似以下内容:</p><pre tabindex=0><code>Name:         game-config-2
Namespace:    default
Labels:       &lt;none&gt;
Annotations:  &lt;none&gt;

Data
====
game.properties:
----
enemies=aliens
lives=3
enemies.cheat=true
enemies.cheat.level=noGoodRotten
secret.code.passphrase=UUDDLRLRBABAS
secret.code.allowed=true
secret.code.lives=30
ui.properties:
----
color.good=purple
color.bad=yellow
allow.textmode=true
how.nice.to.look=fairlyNice
</code></pre><p>当 <code>kubectl</code> 基于非 ASCII 或 UTF-8 的输入创建 ConfigMap 时，
该工具将这些输入放入 ConfigMap 的 <code>binaryData</code> 字段，而不是 <code>data</code> 中。
同一个 ConfigMap 中可同时包含文本数据和二进制数据源。
如果你想查看 ConfigMap 中的 <code>binaryData</code> 键（及其值），
你可以运行 <code>kubectl get configmap -o jsonpath='{.binaryData}' &lt;name></code>。</p><p>使用 <code>--from-env-file</code> 选项从环境文件创建 ConfigMap，例如：</p><p>Env 文件包含环境变量列表。其中适用以下语法规则:</p><ul><li>Env 文件中的每一行必须为 VAR=VAL 格式。</li><li>以＃开头的行（即注释）将被忽略。</li><li>空行将被忽略。</li><li>引号不会被特殊处理（即它们将成为 ConfigMap 值的一部分）。</li></ul><p>将示例文件下载到 <code>configure-pod-container/configmap/</code> 目录：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>wget https://kubernetes.io/examples/configmap/game-env-file.properties -O configure-pod-container/configmap/game-env-file.properties
</span></span><span style=display:flex><span>wget https://kubernetes.io/examples/configmap/ui-env-file.properties -O configure-pod-container/configmap/ui-env-file.properties
</span></span></code></pre></div><p>Env 文件 <code>game-env-file.properties</code> 如下所示：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat configure-pod-container/configmap/game-env-file.properties
</span></span></code></pre></div><pre tabindex=0><code>enemies=aliens
lives=3
allowed=&#34;true&#34;
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create configmap game-config-env-file <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>       --from-env-file<span style=color:#666>=</span>configure-pod-container/configmap/game-env-file.properties
</span></span></code></pre></div><p>将产生以下 ConfigMap：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get configmap game-config-env-file -o yaml
</span></span></code></pre></div><p>输出类似以下内容：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2017-12-27T18:36:28Z<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>game-config-env-file<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;809965&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selfLink</span>:<span style=color:#bbb> </span>/api/v1/namespaces/default/configmaps/game-config-env-file<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>d9d1ca5b-eb34-11e7-887b-42010a8002b8<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>allowed</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;&#34;true&#34;&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>enemies</span>:<span style=color:#bbb> </span>aliens<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>lives</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;3&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>从 Kubernetes 1.23 版本开始，<code>kubectl</code> 支持多次指定 <code>--from-env-file</code> 参数来从多个数据源创建
ConfigMap。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create configmap config-multi-env-files <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>        --from-env-file<span style=color:#666>=</span>configure-pod-container/configmap/game-env-file.properties <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>        --from-env-file<span style=color:#666>=</span>configure-pod-container/configmap/ui-env-file.properties
</span></span></code></pre></div><p>将产生以下 ConfigMap:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get configmap config-multi-env-files -o yaml
</span></span></code></pre></div><p>输出类似以下内容:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2017-12-27T18:38:34Z<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config-multi-env-files<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;810136&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>252c4572-eb35-11e7-887b-42010a8002b8<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>allowed</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;&#34;true&#34;&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>color</span>:<span style=color:#bbb> </span>purple<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>enemies</span>:<span style=color:#bbb> </span>aliens<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>how</span>:<span style=color:#bbb> </span>fairlyNice<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>lives</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;3&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>textmode</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><h4 id=define-the-key-to-use-when-generating-a-configmap-from-a-file>定义从文件创建 ConfigMap 时要使用的键</h4><p>在使用 <code>--from-file</code> 参数时，你可以定义在 ConfigMap 的 <code>data</code> 部分出现键名，
而不是按默认行为使用文件名：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create configmap game-config-3 --from-file<span style=color:#666>=</span>&lt;我的键名&gt;<span style=color:#666>=</span>&lt;文件路径&gt;
</span></span></code></pre></div><p><code>&lt;我的键名></code> 是你要在 ConfigMap 中使用的键名，<code>&lt;文件路径></code> 是你想要键所表示的数据源文件的位置。</p><p>例如:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create configmap game-config-3 --from-file<span style=color:#666>=</span>game-special-key<span style=color:#666>=</span>configure-pod-container/configmap/game.properties
</span></span></code></pre></div><p>将产生以下 ConfigMap:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get configmaps game-config-3 -o yaml
</span></span></code></pre></div><p>输出类似以下内容：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2016-02-18T18:54:22Z<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>game-config-3<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;530&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>05f8da22-d671-11e5-8cd0-68f728db1985<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>game-special-key</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    enemies=aliens
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    lives=3
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    enemies.cheat=true
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    enemies.cheat.level=noGoodRotten
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    secret.code.passphrase=UUDDLRLRBABAS
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    secret.code.allowed=true
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    secret.code.lives=30</span><span style=color:#bbb>    
</span></span></span></code></pre></div><h4 id=create-configmaps-from-literal-values>根据字面值创建 ConfigMap</h4><p>你可以将 <code>kubectl create configmap</code> 与 <code>--from-literal</code> 参数一起使用，
通过命令行定义文字值：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create configmap special-config --from-literal<span style=color:#666>=</span>special.how<span style=color:#666>=</span>very --from-literal<span style=color:#666>=</span>special.type<span style=color:#666>=</span>charm
</span></span></code></pre></div><p>你可以传入多个键值对。命令行中提供的每对键值在 ConfigMap 的 <code>data</code> 部分中均表示为单独的条目。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get configmaps special-config -o yaml
</span></span></code></pre></div><p>输出类似以下内容:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2016-02-18T19:14:38Z<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>special-config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;651&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>dadce046-d673-11e5-8cd0-68f728db1985<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>special.how</span>:<span style=color:#bbb> </span>very<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>special.type</span>:<span style=color:#bbb> </span>charm<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=create-a-configmap-from-generator>基于生成器创建 ConfigMap</h3><p>自 1.14 开始，<code>kubectl</code> 开始支持 <code>kustomization.yaml</code>。
你还可以基于生成器（Generators）创建 ConfigMap，然后将其应用于 API 服务器上创建对象。
生成器应在目录内的 <code>kustomization.yaml</code> 中指定。</p><h4 id=generate-configmaps-from-files>基于文件生成 ConfigMap</h4><p>例如，要基于 <code>configure-pod-container/configmap/game.properties</code>
文件生成一个 ConfigMap：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 创建包含 ConfigMapGenerator 的 kustomization.yaml 文件</span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt;./kustomization.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>configMapGenerator:
</span></span></span><span style=display:flex><span><span style=color:#b44>- name: game-config-4
</span></span></span><span style=display:flex><span><span style=color:#b44>  files:
</span></span></span><span style=display:flex><span><span style=color:#b44>  - configure-pod-container/configmap/game.properties
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>应用（Apply）kustomization 目录创建 ConfigMap 对象：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -k .
</span></span></code></pre></div><pre tabindex=0><code>configmap/game-config-4-m9dm2f92bt created
</code></pre><p>你可以检查 ConfigMap 被创建如下：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get configmap
</span></span></code></pre></div><pre tabindex=0><code>NAME                       DATA   AGE
game-config-4-m9dm2f92bt   1      37s


kubectl describe configmaps/game-config-4-m9dm2f92bt
Name:         game-config-4-m9dm2f92bt
Namespace:    default
Labels:       &lt;none&gt;
Annotations:  kubectl.kubernetes.io/last-applied-configuration:
                {&#34;apiVersion&#34;:&#34;v1&#34;,&#34;data&#34;:{&#34;game.properties&#34;:&#34;enemies=aliens\nlives=3\nenemies.cheat=true\nenemies.cheat.level=noGoodRotten\nsecret.code.p...

Data
====
game.properties:
----
enemies=aliens
lives=3
enemies.cheat=true
enemies.cheat.level=noGoodRotten
secret.code.passphrase=UUDDLRLRBABAS
secret.code.allowed=true
secret.code.lives=30
Events:  &lt;none&gt;
</code></pre><p>请注意，生成的 ConfigMap 名称具有通过对内容进行散列而附加的后缀，
这样可以确保每次修改内容时都会生成新的 ConfigMap。</p><h4 id=define-the-key-to-use-when-generating-a-configmap-from-a-file>定义从文件生成 ConfigMap 时要使用的键</h4><p>在 ConfigMap 生成器中，你可以定义一个非文件名的键名。
例如，从 <code>configure-pod-container/configmap/game.properties</code> 文件生成 ConfigMap，
但使用 <code>game-special-key</code> 作为键名：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 创建包含 ConfigMapGenerator 的 kustomization.yaml 文件</span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt;./kustomization.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>configMapGenerator:
</span></span></span><span style=display:flex><span><span style=color:#b44>- name: game-config-5
</span></span></span><span style=display:flex><span><span style=color:#b44>  files:
</span></span></span><span style=display:flex><span><span style=color:#b44>  - game-special-key=configure-pod-container/configmap/game.properties
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>应用 Kustomization 目录创建 ConfigMap 对象。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -k .
</span></span></code></pre></div><pre tabindex=0><code>configmap/game-config-5-m67dt67794 created
</code></pre><h4 id=generate-configmaps-from-literals>基于字面值生成 ConfigMap</h4><p>要基于字符串 <code>special.type=charm</code> 和 <code>special.how=very</code> 生成 ConfigMap，
可以在 <code>kustomization.yaml</code> 中配置 ConfigMap 生成器：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 创建带有 ConfigMapGenerator 的 kustomization.yaml 文件</span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt;./kustomization.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>configMapGenerator:
</span></span></span><span style=display:flex><span><span style=color:#b44>- name: special-config-2
</span></span></span><span style=display:flex><span><span style=color:#b44>  literals:
</span></span></span><span style=display:flex><span><span style=color:#b44>  - special.how=very
</span></span></span><span style=display:flex><span><span style=color:#b44>  - special.type=charm
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>应用 Kustomization 目录创建 ConfigMap 对象。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -k .
</span></span></code></pre></div><pre tabindex=0><code>configmap/special-config-2-c92b5mmcf2 created
</code></pre><h2 id=define-container-environment-variables-using-configmap-data>使用 ConfigMap 数据定义容器环境变量</h2><h3 id=define-a-container-environment-variable-with-data-from-a-single-configmap>使用单个 ConfigMap 中的数据定义容器环境变量</h3><ol><li><p>在 ConfigMap 中将环境变量定义为键值对:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create configmap special-config --from-literal<span style=color:#666>=</span>special.how<span style=color:#666>=</span>very
</span></span></code></pre></div></li></ol><ol start=2><li><p>将 ConfigMap 中定义的 <code>special.how</code> 赋值给 Pod 规约中的 <code>SPECIAL_LEVEL_KEY</code> 环境变量。</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/pods/pod-single-configmap-env-variable.yaml download=pods/pod-single-configmap-env-variable.yaml><code>pods/pod-single-configmap-env-variable.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-pod-single-configmap-env-variable-yaml")' title="Copy pods/pod-single-configmap-env-variable.yaml to clipboard"></img></div><div class=includecode id=pods-pod-single-configmap-env-variable-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dapi-test-pod<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>registry.k8s.io/busybox<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;/bin/sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;env&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 定义环境变量</span><span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>SPECIAL_LEVEL_KEY<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>configMapKeyRef</span>:<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:#080;font-style:italic># ConfigMap 包含你要赋给 SPECIAL_LEVEL_KEY 的值</span><span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>special-config<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:#080;font-style:italic># 指定与取值相关的键名</span><span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>special.how<span style=color:#bbb>
   </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
   </span></span></span></code></pre></div></div></div><p>创建 Pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f https://kubernetes.io/examples/pods/pod-single-configmap-env-variable.yaml
</span></span></code></pre></div><p>现在，Pod 的输出包含环境变量 <code>SPECIAL_LEVEL_KEY=very</code>。</p></li></ol><h3 id=define-container-environment-variables-with-data-from-multiple-configmaps>使用来自多个 ConfigMap 的数据定义容器环境变量</h3><ul><li><p>与前面的示例一样，首先创建 ConfigMap。</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/configmap/configmaps.yaml download=configmap/configmaps.yaml><code>configmap/configmaps.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("configmap-configmaps-yaml")' title="Copy configmap/configmaps.yaml to clipboard"></img></div><div class=includecode id=configmap-configmaps-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>special-config<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>special.how</span>:<span style=color:#bbb> </span>very<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>env-config<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>log_level</span>:<span style=color:#bbb> </span>INFO<span style=color:#bbb>
  </span></span></span></code></pre></div></div></div><p>创建 ConfigMap:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f https://kubernetes.io/examples/configmap/configmaps.yaml
</span></span></code></pre></div></li></ul><ul><li><p>在 Pod 规约中定义环境变量。</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/pods/pod-multiple-configmap-env-variable.yaml download=pods/pod-multiple-configmap-env-variable.yaml><code>pods/pod-multiple-configmap-env-variable.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-pod-multiple-configmap-env-variable-yaml")' title="Copy pods/pod-multiple-configmap-env-variable.yaml to clipboard"></img></div><div class=includecode id=pods-pod-multiple-configmap-env-variable-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dapi-test-pod<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>registry.k8s.io/busybox<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;/bin/sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;env&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>SPECIAL_LEVEL_KEY<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>configMapKeyRef</span>:<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>special-config<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>special.how<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>LOG_LEVEL<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>configMapKeyRef</span>:<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>env-config<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>log_level<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
  </span></span></span></code></pre></div></div></div><p>创建 Pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f https://kubernetes.io/examples/pods/pod-multiple-configmap-env-variable.yaml
</span></span></code></pre></div><p>现在，Pod 的输出包含环境变量 <code>SPECIAL_LEVEL_KEY=very</code> 和 <code>LOG_LEVEL=INFO</code>。</p></li></ul><h2 id=configure-all-key-value-pairs-in-a-configmap-as-container-environment-variables>将 ConfigMap 中的所有键值对配置为容器环境变量</h2><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>Kubernetes v1.6 和更高版本支持此功能。</div><ul><li><p>创建一个包含多个键值对的 ConfigMap。</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/configmap/configmap-multikeys.yaml download=configmap/configmap-multikeys.yaml><code>configmap/configmap-multikeys.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("configmap-configmap-multikeys-yaml")' title="Copy configmap/configmap-multikeys.yaml to clipboard"></img></div><div class=includecode id=configmap-configmap-multikeys-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>special-config<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>SPECIAL_LEVEL</span>:<span style=color:#bbb> </span>very<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>SPECIAL_TYPE</span>:<span style=color:#bbb> </span>charm<span style=color:#bbb>
  </span></span></span></code></pre></div></div></div><p>创建 ConfigMap:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f https://kubernetes.io/examples/configmap/configmap-multikeys.yaml
</span></span></code></pre></div></li></ul><ul><li><p>使用 <code>envFrom</code> 将所有 ConfigMap 的数据定义为容器环境变量，ConfigMap
中的键成为 Pod 中的环境变量名称。</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/pods/pod-configmap-envFrom.yaml download=pods/pod-configmap-envFrom.yaml><code>pods/pod-configmap-envFrom.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-pod-configmap-envfrom-yaml")' title="Copy pods/pod-configmap-envFrom.yaml to clipboard"></img></div><div class=includecode id=pods-pod-configmap-envfrom-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dapi-test-pod<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>registry.k8s.io/busybox<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;/bin/sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;env&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>envFrom</span>:<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>configMapRef</span>:<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>special-config<span style=color:#bbb>
  </span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
  </span></span></span></code></pre></div></div></div><p>创建 Pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f https://kubernetes.io/examples/pods/pod-configmap-envFrom.yaml
</span></span></code></pre></div><p>现在，Pod 的输出包含环境变量 <code>SPECIAL_LEVEL=very</code> 和 <code>SPECIAL_TYPE=charm</code>。</p></li></ul><h2 id=use-configmap-defined-environment-variables-in-pod-commands>在 Pod 命令中使用 ConfigMap 定义的环境变量</h2><p>你可以使用 <code>$(VAR_NAME)</code> Kubernetes 替换语法在容器的 <code>command</code> 和 <code>args</code>
属性中使用 ConfigMap 定义的环境变量。</p><p>例如，以下 Pod 规约</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/pods/pod-configmap-env-var-valueFrom.yaml download=pods/pod-configmap-env-var-valueFrom.yaml><code>pods/pod-configmap-env-var-valueFrom.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-pod-configmap-env-var-valuefrom-yaml")' title="Copy pods/pod-configmap-env-var-valueFrom.yaml to clipboard"></img></div><div class=includecode id=pods-pod-configmap-env-var-valuefrom-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dapi-test-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>registry.k8s.io/busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;/bin/echo&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;$(SPECIAL_LEVEL_KEY) $(SPECIAL_TYPE_KEY)&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>SPECIAL_LEVEL_KEY<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>configMapKeyRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>special-config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>SPECIAL_LEVEL<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>SPECIAL_TYPE_KEY<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>configMapKeyRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>special-config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>SPECIAL_TYPE<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>通过运行下面命令创建 Pod：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f https://kubernetes.io/examples/pods/pod-configmap-env-var-valueFrom.yaml
</span></span></code></pre></div><p>在 <code>test-container</code> 容器中产生以下输出:</p><pre tabindex=0><code>very charm
</code></pre><h2 id=add-configmap-data-to-a-volume>将 ConfigMap 数据添加到一个卷中</h2><p>如基于文件创建 <a href=#create-configmaps-from-files>ConfigMap</a> 中所述，当你使用
<code>--from-file</code> 创建 ConfigMap 时，文件名成为存储在 ConfigMap 的 <code>data</code> 部分中的键，
文件内容成为键对应的值。</p><p>本节中的示例引用了一个名为 'special-config' 的 ConfigMap，如下所示：</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/configmap/configmap-multikeys.yaml download=configmap/configmap-multikeys.yaml><code>configmap/configmap-multikeys.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("configmap-configmap-multikeys-yaml")' title="Copy configmap/configmap-multikeys.yaml to clipboard"></img></div><div class=includecode id=configmap-configmap-multikeys-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>special-config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>SPECIAL_LEVEL</span>:<span style=color:#bbb> </span>very<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>SPECIAL_TYPE</span>:<span style=color:#bbb> </span>charm<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>创建 ConfigMap:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f https://kubernetes.io/examples/configmap/configmap-multikeys.yaml
</span></span></code></pre></div><h3 id=populate-a-volume-with-data-stored-in-a-configmap>使用存储在 ConfigMap 中的数据填充卷</h3><p>在 Pod 规约的 <code>volumes</code> 部分下添加 ConfigMap 名称。
这会将 ConfigMap 数据添加到 <code>volumeMounts.mountPath</code> 所指定的目录
（在本例中为 <code>/etc/config</code>）。
<code>command</code> 部分列出了名称与 ConfigMap 中的键匹配的目录文件。</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/pods/pod-configmap-volume.yaml download=pods/pod-configmap-volume.yaml><code>pods/pod-configmap-volume.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-pod-configmap-volume-yaml")' title="Copy pods/pod-configmap-volume.yaml to clipboard"></img></div><div class=includecode id=pods-pod-configmap-volume-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dapi-test-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>registry.k8s.io/busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;/bin/sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;ls /etc/config/&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>configMap</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 提供包含要添加到容器中的文件的 ConfigMap 的名称</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>special-config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>创建 Pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f https://kubernetes.io/examples/pods/pod-configmap-volume.yaml
</span></span></code></pre></div><p>Pod 运行时，命令 <code>ls /etc/config/</code> 产生下面的输出：</p><pre tabindex=0><code>SPECIAL_LEVEL
SPECIAL_TYPE
</code></pre><div class="alert alert-warning caution callout" role=alert><strong>注意：</strong><p>如果在 <code>/etc/config/</code> 目录中有一些文件，这些文件将被删除。</div><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>文本数据会展现为 UTF-8 字符编码的文件。如果使用其他字符编码，
可以使用 <code>binaryData</code>。</div><h3 id=add-configmap-data-to-a-specific-path-in-the-volume>将 ConfigMap 数据添加到卷中的特定路径</h3><p>使用 <code>path</code> 字段为特定的 ConfigMap 项目指定预期的文件路径。
在这里，ConfigMap 中键 <code>SPECIAL_LEVEL</code> 的内容将挂载在 <code>config-volume</code>
卷中 <code>/etc/config/keys</code> 文件中。</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/pods/pod-configmap-volume-specific-key.yaml download=pods/pod-configmap-volume-specific-key.yaml><code>pods/pod-configmap-volume-specific-key.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-pod-configmap-volume-specific-key-yaml")' title="Copy pods/pod-configmap-volume-specific-key.yaml to clipboard"></img></div><div class=includecode id=pods-pod-configmap-volume-specific-key-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dapi-test-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>registry.k8s.io/busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;/bin/sh&#34;</span>,<span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#b44>&#34;cat /etc/config/keys&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>configMap</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>special-config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>SPECIAL_LEVEL<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>keys<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>创建Pod：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create -f https://kubernetes.io/examples/pods/pod-configmap-volume-specific-key.yaml
</span></span></code></pre></div><p>当 Pod 运行时，命令 <code>cat /etc/config/keys</code> 产生以下输出：</p><pre tabindex=0><code>very
</code></pre><div class="alert alert-warning caution callout" role=alert><strong>注意：</strong><p>如前，<code>/etc/config/</code> 目录中所有先前的文件都将被删除。</div><h3 id=project-keys-to-specific-paths-and-file-permissions>映射键到指定路径并设置文件访问权限</h3><p>你可以将指定键名投射到特定目录，也可以逐个文件地设定访问权限。
<a href=/zh-cn/docs/concepts/configuration/secret/#using-secrets-as-files-from-a-pod>Secret 用户指南</a>
中为这一语法提供了解释。</p><h2 id=understanding-configmaps-and-pods>了解 ConfigMap 和 Pod</h2><p>ConfigMap API 资源将配置数据存储为键值对。
数据可以在 Pod 中使用，也可以用来提供系统组件（如控制器）的配置。
ConfigMap 与 <a href=/zh-cn/docs/concepts/configuration/secret/>Secret</a> 类似，
但是提供的是一种处理不含敏感信息的字符串的方法。
用户和系统组件都可以在 ConfigMap 中存储配置数据。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>ConfigMap 应该引用属性文件，而不是替换它们。可以将 ConfigMap 理解为类似于 Linux
<code>/etc</code> 目录及其内容的东西。例如，如果你基于 ConfigMap 创建
<a href=/zh-cn/docs/concepts/storage/volumes/>Kubernetes 卷</a>，则 ConfigMap
中的每个数据项都由该数据卷中的某个独立的文件表示。</div><p>ConfigMap 的 <code>data</code> 字段包含配置数据。如下例所示，它可以简单
（如用 <code>--from-literal</code> 的单个属性定义）或复杂
（如用 <code>--from-file</code> 的配置文件或 JSON blob定义）。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span>2016-02-18T19:14:38Z<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example-config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 使用 --from-literal 定义的简单属性</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>example.property.1</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>example.property.2</span>:<span style=color:#bbb> </span>world<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 使用 --from-file 定义复杂属性的例子</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>example.property.file</span>:<span style=color:#bbb> </span>|-<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    property.1=value-1
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    property.2=value-2
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    property.3=value-3</span><span style=color:#bbb>    
</span></span></span></code></pre></div><h3 id=restrictions>限制</h3><ul><li>在 Pod 规约中引用某个 <code>ConfigMap</code> 之前，必须先创建这个对象，
或者在 Pod 规约中将 ConfigMap 标记为 <code>optional</code>（请参阅<a href=#optional-configmaps>可选的 ConfigMaps</a>）。
如果所引用的 ConfigMap 不存在，并且没有将应用标记为 <code>optional</code> 则 Pod 将无法启动。
同样，引用 ConfigMap 中不存在的主键也会令 Pod 无法启动，除非你将 Configmap 标记为 <code>optional</code>。</li></ul><ul><li><p>如果你使用 <code>envFrom</code> 来基于 ConfigMap 定义环境变量，那么无效的键将被忽略。
Pod 可以被启动，但无效名称将被记录在事件日志中（<code>InvalidVariableNames</code>）。
日志消息列出了每个被跳过的键。例如:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get events
</span></span></code></pre></div><p>输出与此类似:</p><pre tabindex=0><code>LASTSEEN FIRSTSEEN COUNT NAME          KIND  SUBOBJECT  TYPE      REASON                            SOURCE                MESSAGE
0s       0s        1     dapi-test-pod Pod              Warning   InvalidEnvironmentVariableNames   {kubelet, 127.0.0.1}  Keys [1badkey, 2alsobad] from the EnvFrom configMap default/myconfig were skipped since they are considered invalid environment variable names.
</code></pre></li></ul><ul><li>ConfigMap 位于确定的<a class=glossary-tooltip title='名字空间是 Kubernetes 用来支持隔离单个集群中的资源组的一种抽象。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/overview/working-with-objects/namespaces/ target=_blank aria-label=名字空间>名字空间</a>中。
每个 ConfigMap 只能被同一名字空间中的 Pod 引用.</li></ul><ul><li>你不能将 ConfigMap 用于<a class=glossary-tooltip title='静态Pod（Static Pod）是指由特定节点上的 kubelet 守护进程直接管理的 Pod。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/tasks/configure-pod-container/static-pod/ target=_blank aria-label='静态 Pod'>静态 Pod</a>，
因为 Kubernetes 不支持这种用法。</li></ul><h3 id=optional-configmaps>可选的 ConfigMap</h3><p>你可以在 Pod 规约中将对 ConfigMap 的引用标记为 <strong>可选（optional）</strong>。
如果 ConfigMap 不存在，那么它在 Pod 中为其提供数据的配置（例如环境变量、挂载的卷）将为空。
如果 ConfigMap 存在，但引用的键不存在，那么数据也是空的。</p><p>例如，以下 Pod 规约将 ConfigMap 中的环境变量标记为可选：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dapi-test-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/google_containers/busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;/bin/sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;env&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>SPECIAL_LEVEL_KEY<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>configMapKeyRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>a-config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>akey<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>optional</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># 将环境变量标记为可选</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></span></span></code></pre></div><p>当你运行这个 Pod 并且名称为 <code>a-config</code> 的 ConfigMap 不存在时，输出空值。
当你运行这个 Pod 并且名称为 <code>a-config</code> 的 ConfigMap 存在，
但是在 ConfigMap 中没有名称为 <code>akey</code> 的键时，控制台输出也会为空。
如果你确实在名为 <code>a-config</code> 的 ConfigMap 中为 <code>akey</code> 设置了键值，
那么这个 Pod 会打印该值，然后终止。</p><p>你也可以在 Pod 规约中将 ConfigMap 提供的卷和文件标记为可选。
此时 Kubernetes 将总是为卷创建挂载路径，即使引用的 ConfigMap 或键不存在。
例如，以下 Pod 规约将所引用得 ConfigMap 的卷标记为可选：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dapi-test-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/google_containers/busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;/bin/sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;ls /etc/config&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>configMap</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>no</span>-config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>optional</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># 将引用的 ConfigMap 的卷标记为可选</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=mounted-configmaps-are-updated-automatically>挂载的 ConfigMap 将被自动更新</h3><p>当某个已被挂载的 ConfigMap 被更新，所投射的内容最终也会被更新。
对于 Pod 已经启动之后所引用的、可选的 ConfigMap 才出现的情形，
这一动态更新现象也是适用的。</p><p>kubelet 在每次周期性同步时都会检查已挂载的 ConfigMap 是否是最新的。
但是，它使用其本地的基于 TTL 的缓存来获取 ConfigMap 的当前值。
因此，从更新 ConfigMap 到将新键映射到 Pod 的总延迟可能等于 kubelet 同步周期
（默认 1 分钟） + ConfigMap 在 kubelet 中缓存的 TTL（默认 1 分钟）。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>使用 ConfigMap 作为 <a href=/zh-cn/docs/concepts/storage/volumes/#using-subpath>subPath</a>
的数据卷将不会收到 ConfigMap 更新。</div><h2 id=接下来>接下来</h2><ul><li>浏览<a href=/zh-cn/docs/tutorials/configuration/configure-redis-using-configmap/>使用 ConfigMap 配置 Redis</a>
真实示例。</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-18935633a984586fbb68b727f3f339bb>20 - 为 Pod 配置用户名字空间</h1><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.25 [alpha]</code></div><p>本页展示如何为无状态 Pod 配置用户名字空间。可以将容器内的用户与主机上的用户隔离开来。</p><p>在容器中以 root 用户运行的进程可以以不同的（非 root）用户在宿主机上运行；换句话说，
进程在用户名字空间内部拥有执行操作的全部特权，但在用户名字空间外部并没有执行操作的特权。</p><p>你可以使用这个特性来减少有害的容器对同一宿主机上其他容器的影响。
<a href=https://github.com/kubernetes/enhancements/tree/217d790720c5aef09b8bd4d6ca96284a0affe6c2/keps/sig-node/127-user-namespaces#motivation>有些安全脆弱性问题</a>被评为 <strong>HIGH</strong> or <strong>CRITICAL</strong>，但当用户名字空间被启用时，
它们是无法被利用的。相信用户名字空间也能减轻一些未来的漏洞的影响。</p><p>在不使用用户名字空间的情况下，对于以 root 用户运行的容器而言，发生容器逃逸时，
容器将拥有在宿主机上的 root 特权。如果容器被赋予了某些权限，则这些权限在宿主机上同样有效。
当使用用户名字空间时这些都不可能发生。</p><h2 id=准备开始>准备开始</h2><p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li></ul>你的 Kubernetes 服务器版本必须是 v1.25.
要获知版本信息，请输入 <code>kubectl version</code>.</p><div class="alert alert-secondary callout third-party-content" role=alert>&#128711; 本条目指向第三方项目或产品，而该项目（产品）不是 Kubernetes 的一部分。<a class=alert-more-info href=#third-party-content-disclaimer>更多信息</a></div><ul><li>节点上的操作系统必须为 Linux</li><li>你需要在宿主机上执行命令</li><li>你需要能够通过 exec 操作进入 Pod</li><li>特性 <code>UserNamespacesStatelessPodsSupport</code> 需要被启用。</li></ul><p>此外, 需要<a class=glossary-tooltip title=容器运行时是负责运行容器的软件。 data-toggle=tooltip data-placement=top href=/zh-cn/docs/setup/production-environment/container-runtimes target=_blank aria-label=容器运行时>容器运行时</a>提供相应的支持，
才能将此特性与 Kubernetes 无状态 Pod 一起使用：</p><ul><li>CRI-O: v1.25 支持用户名字空间。</li></ul><p>请注意 <strong>如果你的容器运行时环境不支持用户名字空间，字段 <code>pod.spec</code> 将被忽略，
并且系统会在没有用户名字空间的环境中创建 Pod。</strong></p><h2 id=create-pod>运行一个使用用户名字空间的 Pod</h2><p>为一个无状态的 Pod 启用用户名字空间需要设置 <code>.spec</code> 的 <code>hostUsers</code> 字段
为 <code>false</code>. 例如:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/pods/user-namespaces-stateless.yaml download=pods/user-namespaces-stateless.yaml><code>pods/user-namespaces-stateless.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-user-namespaces-stateless-yaml")' title="Copy pods/user-namespaces-stateless.yaml to clipboard"></img></div><div class=includecode id=pods-user-namespaces-stateless-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>userns<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>hostUsers</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>shell<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;sleep&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;infinity&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>debian<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><ol><li><p>在你的集群上创建 Pod：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/user-namespaces-stateless.yaml
</span></span></code></pre></div></li></ol><ol start=2><li><p>挂接到容器上并执行 <code>readlink /proc/self/ns/user</code>：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl attach -it userns bash
</span></span></code></pre></div></li></ol><p>执行命令的输出类似于：</p><pre tabindex=0><code class=language-none data-lang=none>readlink /proc/self/ns/user
user:[4026531837]
cat /proc/self/uid_map
0          0 4294967295
</code></pre><p>然后，在主机中打开一个 Shell 并运行相同的命令。</p><p>输出一定是不同的。这意味着主机和 Pod 使用不同的用户名字空间。当未启用用户名字空间时，
宿主机和 Pod 使用相同的用户名字空间。</p><p>如果你在用户名字空间中运行 kubelet，则需要将在 Pod 中运行命令的输出与在主机中运行的输出进行比较：</p><pre tabindex=0><code class=language-none data-lang=none>readlink /proc/$pid/ns/user
user:[4026534732]
</code></pre><p>使用 kubelet 的进程号代替 <code>$pid</code></p></div><div class=td-content style=page-break-before:always><h1 id=pg-3d7b9cb24a647c36ba63f7a02ec49010>21 - 在 Pod 中的容器之间共享进程命名空间</h1><p>此页面展示如何为 Pod 配置进程命名空间共享。
当启用进程命名空间共享时，容器中的进程对同一 Pod 中的所有其他容器都是可见的。</p><p>你可以使用此功能来配置协作容器，比如日志处理 sidecar 容器，
或者对那些不包含诸如 shell 等调试实用工具的镜像进行故障排查。</p><h2 id=准备开始>准备开始</h2><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li></ul><h2 id=配置-pod>配置 Pod</h2><p>使用 Pod <code>.spec</code> 中的 <code>shareProcessNamespace</code> 字段可以启用进程命名空间共享。例如：</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/pods/share-process-namespace.yaml download=pods/share-process-namespace.yaml><code>pods/share-process-namespace.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-share-process-namespace-yaml")' title="Copy pods/share-process-namespace.yaml to clipboard"></img></div><div class=includecode id=pods-share-process-namespace-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>shareProcessNamespace</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>shell<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>securityContext</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>capabilities</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>add</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- SYS_PTRACE<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>stdin</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>tty</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><ol><li><p>在集群中创建 <code>nginx</code> Pod：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/share-process-namespace.yaml
</span></span></code></pre></div></li></ol><ol start=2><li><p>获取容器 <code>shell</code>，执行 <code>ps</code>：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl attach -it nginx -c shell
</span></span></code></pre></div><p>如果没有看到命令提示符，请按 enter 回车键。在容器 shell 中：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 在 “shell” 容器中运行以下命令</span>
</span></span><span style=display:flex><span>ps ax
</span></span></code></pre></div><p>输出类似于：</p><pre tabindex=0><code class=language-none data-lang=none>PID   USER     TIME  COMMAND
    1 root      0:00 /pause
    8 root      0:00 nginx: master process nginx -g daemon off;
   14 101       0:00 nginx: worker process
   15 root      0:00 sh
   21 root      0:00 ps ax
</code></pre></li></ol><p>你可以在其他容器中对进程发出信号。例如，发送 <code>SIGHUP</code> 到 <code>nginx</code> 以重启工作进程。
此操作需要 <code>SYS_PTRACE</code> 权能。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 在 “shell” 容器中运行以下命令</span>
</span></span><span style=display:flex><span><span style=color:#a2f>kill</span> -HUP <span style=color:#666>8</span>   <span style=color:#080;font-style:italic># 如有必要，更改 “8” 以匹配 nginx 领导进程的 PID</span>
</span></span><span style=display:flex><span>ps ax
</span></span></code></pre></div><p>输出类似于：</p><pre tabindex=0><code class=language-none data-lang=none>PID   USER     TIME  COMMAND
    1 root      0:00 /pause
    8 root      0:00 nginx: master process nginx -g daemon off;
   15 root      0:00 sh
   22 101       0:00 nginx: worker process
   23 root      0:00 ps ax
</code></pre><p>甚至可以使用 <code>/proc/$pid/root</code> 链接访问另一个容器的文件系统。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 在 “shell” 容器中运行以下命令</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 如有必要，更改 “8” 为 Nginx 进程的 PID</span>
</span></span><span style=display:flex><span>head /proc/8/root/etc/nginx/nginx.conf
</span></span></code></pre></div><p>输出类似于：</p><pre tabindex=0><code class=language-none data-lang=none>user  nginx;
worker_processes  1;

error_log  /var/log/nginx/error.log warn;
pid        /var/run/nginx.pid;


events {
    worker_connections  1024;
</code></pre><h2 id=理解进程命名空间共享>理解进程命名空间共享</h2><p>Pod 共享许多资源，因此它们共享进程命名空间是很有意义的。
不过，有些容器可能希望与其他容器隔离，因此了解这些差异很重要:</p><ol><li><strong>容器进程不再具有 PID 1。</strong> 在没有 PID 1 的情况下，一些容器拒绝启动
（例如，使用 <code>systemd</code> 的容器)，或者拒绝执行 <code>kill -HUP 1</code> 之类的命令来通知容器进程。
在具有共享进程命名空间的 Pod 中，<code>kill -HUP 1</code> 将通知 Pod 沙箱（在上面的例子中是 <code>/pause</code>）。</li></ol><ol start=2><li><strong>进程对 Pod 中的其他容器可见。</strong> 这包括 <code>/proc</code> 中可见的所有信息，
例如作为参数或环境变量传递的密码。这些仅受常规 Unix 权限的保护。</li></ol><ol start=3><li><strong>容器文件系统通过 <code>/proc/$pid/root</code> 链接对 Pod 中的其他容器可见。</strong> 这使调试更加容易，
但也意味着文件系统安全性只受文件系统权限的保护。</li></ol></div><div class=td-content style=page-break-before:always><h1 id=pg-42a59b878d4c58e5c6f4bb87483dda93>22 - 创建静态 Pod</h1><p><strong>静态 Pod</strong> 在指定的节点上由 kubelet 守护进程直接管理，不需要
<a class=glossary-tooltip title='提供 Kubernetes API 服务的控制面组件。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label='API 服务器'>API 服务器</a>监管。
与由控制面管理的 Pod（例如，<a class=glossary-tooltip title=管理集群上的多副本应用。 data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Deployment>Deployment</a>）
不同；kubelet 监视每个静态 Pod（在它失败之后重新启动）。</p><p>静态 Pod 始终都会绑定到特定节点的 <a class=glossary-tooltip title='一个在集群中每个节点上运行的代理。它保证容器都运行在 Pod 中。' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=Kubelet>Kubelet</a> 上。</p><p>kubelet 会尝试通过 Kubernetes API 服务器为每个静态 Pod
自动创建一个<a class=glossary-tooltip title='API 服务器中的一个对象，用于跟踪 kubelet 上的静态 pod。' data-toggle=tooltip data-placement=top href='/zh-cn/docs/reference/glossary/?all=true#term-mirror-pod' target=_blank aria-label='镜像 Pod'>镜像 Pod</a>。
这意味着节点上运行的静态 Pod 对 API 服务来说是可见的，但是不能通过 API 服务器来控制。
Pod 名称将把以连字符开头的节点主机名作为后缀。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>如果你在运行一个 Kubernetes 集群，并且在每个节点上都运行一个静态 Pod，
就可能需要考虑使用 <a class=glossary-tooltip title='确保 Pod 的副本在集群中的一组节点上运行。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/workloads/controllers/daemonset/ target=_blank aria-label=DaemonSet>DaemonSet</a>
替代这种方式。</div><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>静态 Pod 的 <code>spec</code> 不能引用其他 API 对象
（如：<a class=glossary-tooltip title='为在 Pod 中运行的进程提供标识。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/tasks/configure-pod-container/configure-service-account/ target=_blank aria-label=ServiceAccount>ServiceAccount</a>、
<a class=glossary-tooltip title='ConfigMap 是一种 API 对象，用来将非机密性的数据保存到键值对中。使用时可以用作环境变量、命令行参数或者存储卷中的配置文件。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/tasks/configure-pod-container/configure-pod-configmap/ target=_blank aria-label=ConfigMap>ConfigMap</a>、
<a class=glossary-tooltip title='Secret 用于存储敏感信息，如密码、 OAuth 令牌和 SSH 密钥。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/configuration/secret/ target=_blank aria-label=Secret>Secret</a> 等）。</div><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>静态 Pod 不支持<a href=/zh-cn/docs/concepts/workloads/pods/ephemeral-containers/>临时容器</a>。</div><h2 id=准备开始>准备开始</h2><p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li></ul>要获知版本信息，请输入 <code>kubectl version</code>.</p><p>本文假定你在使用 <a class=glossary-tooltip title='Docker 是一种可以提供操作系统级别虚拟化（也称作容器）的软件技术。' data-toggle=tooltip data-placement=top href=https://docs.docker.com/engine/ target=_blank aria-label=Docker>Docker</a> 来运行 Pod，
并且你的节点是运行着 Fedora 操作系统。
其它发行版或者 Kubernetes 部署版本上操作方式可能不一样。</p><h2 id=static-pod-creation>创建静态 Pod</h2><p>可以通过<a href=/zh-cn/docs/tasks/configure-pod-container/static-pod/#configuration-files>文件系统上的配置文件</a>或者
<a href=/zh-cn/docs/tasks/configure-pod-container/static-pod/#pods-created-via-http>Web 网络上的配置文件</a>来配置静态 Pod。</p><h3 id=configuration-files>文件系统上的静态 Pod 声明文件</h3><p>声明文件是标准的 Pod 定义文件，以 JSON 或者 YAML 格式存储在指定目录。路径设置在
<a href=/zh-cn/docs/reference/config-api/kubelet-config.v1beta1/>Kubelet 配置文件</a>的
<code>staticPodPath: &lt;目录></code> 字段，kubelet 会定期的扫描这个文件夹下的 YAML/JSON
文件来创建/删除静态 Pod。
注意 kubelet 扫描目录的时候会忽略以点开头的文件。</p><p>例如：下面是如何以静态 Pod 的方式启动一个简单 web 服务：</p><ol><li><p>选择一个要运行静态 Pod 的节点。在这个例子中选择 <code>my-node1</code>。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>ssh my-node1
</span></span></code></pre></div></li></ol><ol start=2><li><p>选择一个目录，比如在 <code>/etc/kubernetes/manifests</code> 目录来保存 Web 服务 Pod 的定义文件，例如
<code>/etc/kubernetes/manifests/static-web.yaml</code>：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 在 kubelet 运行的节点上执行以下命令</span>
</span></span><span style=display:flex><span>mkdir -p /etc/kubernetes/manifests/
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt;/etc/kubernetes/manifests/static-web.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: Pod
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: static-web
</span></span></span><span style=display:flex><span><span style=color:#b44>  labels:
</span></span></span><span style=display:flex><span><span style=color:#b44>    role: myrole
</span></span></span><span style=display:flex><span><span style=color:#b44>spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>  containers:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - name: web
</span></span></span><span style=display:flex><span><span style=color:#b44>      image: nginx
</span></span></span><span style=display:flex><span><span style=color:#b44>      ports:
</span></span></span><span style=display:flex><span><span style=color:#b44>        - name: web
</span></span></span><span style=display:flex><span><span style=color:#b44>          containerPort: 80
</span></span></span><span style=display:flex><span><span style=color:#b44>          protocol: TCP
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div></li></ol><ol start=3><li><p>配置这个节点上的 kubelet，使用这个参数执行 <code>--pod-manifest-path=/etc/kubelet.d/</code>。
在 Fedora 上编辑 <code>/etc/kubernetes/kubelet</code> 以包含下面这行：</p><pre tabindex=0><code>KUBELET_ARGS=&#34;--cluster-dns=10.254.0.10 --cluster-domain=kube.local --pod-manifest-path=/etc/kubernetes/manifests/&#34;
</code></pre><p>或者在 <a href=/zh-cn/docs/reference/config-api/kubelet-config.v1beta1/>Kubelet 配置文件</a>中添加
<code>staticPodPath: &lt;目录></code>字段。</p></li></ol><ol start=4><li><p>重启 kubelet。在 Fedora 上，你将使用下面的命令：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 在 kubelet 运行的节点上执行以下命令</span>
</span></span><span style=display:flex><span>systemctl restart kubelet
</span></span></code></pre></div></li></ol><h3 id=pods-created-via-http>Web 网上的静态 Pod 声明文件</h3><p>Kubelet 根据 <code>--manifest-url=&lt;URL></code> 参数的配置定期的下载指定文件，并且转换成
JSON/YAML 格式的 Pod 定义文件。
与<a href=#configuration-files>文件系统上的清单文件</a>使用方式类似，kubelet 调度获取清单文件。
如果静态 Pod 的清单文件有改变，kubelet 会应用这些改变。</p><p>按照下面的方式来：</p><ol><li><p>创建一个 YAML 文件，并保存在 web 服务上，为 kubelet 生成一个 URL。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>static-web<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>role</span>:<span style=color:#bbb> </span>myrole<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>web<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>web<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span></code></pre></div></li></ol><ol start=2><li><p>通过在选择的节点上使用 <code>--manifest-url=&lt;manifest-url></code> 配置运行 kubelet。
在 Fedora 添加下面这行到 <code>/etc/kubernetes/kubelet</code>：</p><pre tabindex=0><code>KUBELET_ARGS=&#34;--cluster-dns=10.254.0.10 --cluster-domain=kube.local --manifest-url=&lt;manifest-url&gt;&#34;
</code></pre></li></ol><ol start=3><li><p>重启 kubelet。在 Fedora 上，你将运行如下命令：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 在 kubelet 运行的节点上执行以下命令</span>
</span></span><span style=display:flex><span>systemctl restart kubelet
</span></span></code></pre></div></li></ol><h2 id=behavior-of-static-pods>观察静态 Pod 的行为</h2><p>当 kubelet 启动时，会自动启动所有定义的静态 Pod。
当定义了一个静态 Pod 并重新启动 kubelet 时，新的静态 Pod 就应该已经在运行了。</p><p>可以在节点上运行下面的命令来查看正在运行的容器（包括静态 Pod）：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 在 kubelet 运行的节点上执行以下命令</span>
</span></span><span style=display:flex><span>crictl ps
</span></span></code></pre></div><p>输出可能会像这样：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#888>CONTAINER       IMAGE                                 CREATED           STATE      NAME    ATTEMPT    POD ID
</span></span></span><span style=display:flex><span><span style=color:#888>129fd7d382018   docker.io/library/nginx@sha256:...    11 minutes ago    Running    web     0          34533c6729106
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p><code>crictl</code> 会输出镜像 URI 和 SHA-256 校验和。<code>NAME</code> 看起来像：
<code>docker.io/library/nginx@sha256:0d17b565c37bcbd895e9d92315a05c1c3c9a29f762b011a10c54a66cd53c9b31</code>。</div><p>可以在 API 服务上看到镜像 Pod：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods
</span></span></code></pre></div><pre tabindex=0><code>NAME         READY   STATUS    RESTARTS        AGE
static-web   1/1     Running   0               2m
</code></pre><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>要确保 kubelet 在 API 服务上有创建镜像 Pod 的权限。如果没有，创建请求会被 API 服务拒绝。</div><p>静态 Pod 上的<a class=glossary-tooltip title=用来为对象设置可标识的属性标记；这些标记对用户而言是有意义且重要的。 data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/overview/working-with-objects/labels/ target=_blank aria-label=标签>标签</a>被传播到镜像 Pod。
你可以通过<a class=glossary-tooltip title=选择算符允许用户通过标签对一组资源对象进行筛选过滤。 data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/overview/working-with-objects/labels/ target=_blank aria-label=选择算符>选择算符</a>使用这些标签。</p><p>如果你用 <code>kubectl</code> 从 API 服务上删除镜像 Pod，kubelet <strong>不会</strong>移除静态 Pod：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete pod static-web
</span></span></code></pre></div><pre tabindex=0><code>pod &#34;static-web&#34; deleted
</code></pre><p>可以看到 Pod 还在运行：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods
</span></span></code></pre></div><pre tabindex=0><code>NAME         READY   STATUS    RESTARTS   AGE
static-web   1/1     Running   0          4s
</code></pre><p>回到 kubelet 运行所在的节点上，你可以手动停止容器。
可以看到过了一段时间后 kubelet 会发现容器停止了并且会自动重启 Pod：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 在 kubelet 运行的节点上执行以下命令</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 把 ID 换为你的容器的 ID</span>
</span></span><span style=display:flex><span>crictl stop 129fd7d382018
</span></span><span style=display:flex><span>sleep <span style=color:#666>20</span>
</span></span><span style=display:flex><span>crictl ps
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#888>CONTAINER       IMAGE                                 CREATED           STATE      NAME    ATTEMPT    POD ID
</span></span></span><span style=display:flex><span><span style=color:#888>89db4553e1eeb   docker.io/library/nginx@sha256:...    19 seconds ago    Running    web     1          34533c6729106
</span></span></span></code></pre></div><h2 id=dynamic-addition-and-removal-of-static-pods>动态增加和删除静态 Pod</h2><p>运行中的 kubelet 会定期扫描配置的目录（比如例子中的 <code>/etc/kubernetes/manifests</code> 目录）中的变化，
并且根据文件中出现/消失的 Pod 来添加/删除 Pod。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 这里假定你在用主机文件系统上的静态 Pod 配置文件</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 在 kubelet 运行的节点上执行以下命令</span>
</span></span><span style=display:flex><span>mv /etc/kubernetes/manifests/static-web.yaml /tmp
</span></span><span style=display:flex><span>sleep <span style=color:#666>20</span>
</span></span><span style=display:flex><span>crictl ps
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 可以看到没有 nginx 容器在运行</span>
</span></span><span style=display:flex><span>mv /tmp/static-web.yaml  /etc/kubernetes/manifests/
</span></span><span style=display:flex><span>sleep <span style=color:#666>20</span>
</span></span><span style=display:flex><span>crictl ps
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#888>CONTAINER       IMAGE                                 CREATED           STATE      NAME    ATTEMPT    POD ID
</span></span></span><span style=display:flex><span><span style=color:#888>f427638871c35   docker.io/library/nginx@sha256:...    19 seconds ago    Running    web     1          34533c6729106
</span></span></span></code></pre></div></div><div class=td-content style=page-break-before:always><h1 id=pg-1bb997c61a85de753d9994e7a312a291>23 - 将 Docker Compose 文件转换为 Kubernetes 资源</h1><p>Kompose 是什么？它是一个转换工具，可将 compose
（即 Docker Compose）所组装的所有内容转换成容器编排器（Kubernetes 或 OpenShift）可识别的形式。</p><p>更多信息请参考 Kompose 官网 <a href=http://kompose.io>http://kompose.io</a>。</p><h2 id=准备开始>准备开始</h2><p><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li></ul>要获知版本信息，请输入 <code>kubectl version</code>.</p><h2 id=install-kompose>安装 Kompose</h2><p>我们有很多种方式安装 Kompose。首选方式是从最新的 GitHub 发布页面下载二进制文件。</p><ul class="nav nav-tabs" id=install-ways role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#install-ways-0 role=tab aria-controls=install-ways-0 aria-selected=true>GitHub 下载</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#install-ways-1 role=tab aria-controls=install-ways-1>基于源代码构建</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#install-ways-2 role=tab aria-controls=install-ways-2>CentOS 包</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#install-ways-3 role=tab aria-controls=install-ways-3>Fedora 包</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#install-ways-4 role=tab aria-controls=install-ways-4>Homebrew (macOS)</a></li></ul><div class=tab-content id=install-ways><div id=install-ways-0 class="tab-pane show active" role=tabpanel aria-labelledby=install-ways-0><p><p>Kompose 通过 GitHub 发布，发布周期为三星期。
你可以在 <a href=https://github.com/kubernetes/kompose/releases>GitHub 发布页面</a>上看到所有当前版本。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Linux</span>
</span></span><span style=display:flex><span>curl -L https://github.com/kubernetes/kompose/releases/download/v1.26.0/kompose-linux-amd64 -o kompose
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># macOS</span>
</span></span><span style=display:flex><span>curl -L https://github.com/kubernetes/kompose/releases/download/v1.26.0/kompose-darwin-amd64 -o kompose
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Windows</span>
</span></span><span style=display:flex><span>curl -L https://github.com/kubernetes/kompose/releases/download/v1.26.0/kompose-windows-amd64.exe -o kompose.exe
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>chmod +x kompose
</span></span><span style=display:flex><span>sudo mv ./kompose /usr/local/bin/kompose
</span></span></code></pre></div><p>或者，你可以下载 <a href=https://github.com/kubernetes/kompose/releases>tar 包</a>。</p></div><div id=install-ways-1 class=tab-pane role=tabpanel aria-labelledby=install-ways-1><p><p>用 <code>go get</code> 命令从主分支拉取最新的开发变更的方法安装 Kompose。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>go get -u github.com/kubernetes/kompose
</span></span></code></pre></div></div><div id=install-ways-2 class=tab-pane role=tabpanel aria-labelledby=install-ways-2><p><p>Kompose 位于 <a href=https://fedoraproject.org/wiki/EPEL>EPEL</a> CentOS 代码仓库。
如果你还没有安装并启用 <a href=https://fedoraproject.org/wiki/EPEL>EPEL</a> 代码仓库，
请运行命令 <code>sudo yum install epel-release</code>。</p><p>如果你的系统中已经启用了 <a href=https://fedoraproject.org/wiki/EPEL>EPEL</a>，
你就可以像安装其他软件包一样安装 Kompose。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo yum -y install kompose
</span></span></code></pre></div></div><div id=install-ways-3 class=tab-pane role=tabpanel aria-labelledby=install-ways-3><p><p>Kompose 位于 Fedora 24、25 和 26 的代码仓库。你可以像安装其他软件包一样安装 Kompose。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>sudo dnf -y install kompose
</span></span></code></pre></div></div><div id=install-ways-4 class=tab-pane role=tabpanel aria-labelledby=install-ways-4><p><p>在 macOS 上你可以通过 <a href=https://brew.sh>Homebrew</a> 安装 Kompose 的最新版本：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>brew install kompose
</span></span></code></pre></div></div></div><h2 id=use-kompose>使用 Kompose</h2><p>只需几步，我们就把你从 Docker Compose 带到 Kubernetes。
你只需要一个现有的 <code>docker-compose.yml</code> 文件。</p><ol><li><p>进入 <code>docker-compose.yml</code> 文件所在的目录。如果没有，请使用下面这个进行测试。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>services</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>redis-master</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>registry.k8s.io/redis:e2e<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;6379&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>redis-slave</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/google_samples/gb-redisslave:v3<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;6379&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>environment</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- GET_HOSTS_FROM=dns<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>frontend</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>gcr.io/google-samples/gb-frontend:v4<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;80:80&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>environment</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- GET_HOSTS_FROM=dns<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>kompose.service.type</span>:<span style=color:#bbb> </span>LoadBalancer<span style=color:#bbb>
</span></span></span></code></pre></div></li></ol><ol start=2><li><p>要将 <code>docker-compose.yml</code> 转换为 <code>kubectl</code> 可用的文件，请运行 <code>kompose convert</code>
命令进行转换，然后运行 <code>kubectl apply -f &lt;output file></code> 进行创建。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kompose convert                           
</span></span></code></pre></div><p>输出类似于：</p><pre tabindex=0><code class=language-none data-lang=none>INFO Kubernetes file &#34;frontend-service.yaml&#34; created
   INFO Kubernetes file &#34;frontend-service.yaml&#34; created
INFO Kubernetes file &#34;frontend-service.yaml&#34; created
INFO Kubernetes file &#34;redis-master-service.yaml&#34; created
   INFO Kubernetes file &#34;redis-master-service.yaml&#34; created
INFO Kubernetes file &#34;redis-master-service.yaml&#34; created
INFO Kubernetes file &#34;redis-slave-service.yaml&#34; created
   INFO Kubernetes file &#34;redis-slave-service.yaml&#34; created
INFO Kubernetes file &#34;redis-slave-service.yaml&#34; created
INFO Kubernetes file &#34;frontend-deployment.yaml&#34; created
   INFO Kubernetes file &#34;frontend-deployment.yaml&#34; created
INFO Kubernetes file &#34;frontend-deployment.yaml&#34; created
INFO Kubernetes file &#34;redis-master-deployment.yaml&#34; created
   INFO Kubernetes file &#34;redis-master-deployment.yaml&#34; created
INFO Kubernetes file &#34;redis-master-deployment.yaml&#34; created
INFO Kubernetes file &#34;redis-slave-deployment.yaml&#34; created
   INFO Kubernetes file &#34;redis-slave-deployment.yaml&#34; created
INFO Kubernetes file &#34;redis-slave-deployment.yaml&#34; created
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl apply -f frontend-service.yaml,redis-master-service.yaml,redis-slave-service.yaml,frontend-deployment.yaml,redis-master-deployment.yaml,redis-slave-deployment.yaml
</span></span></code></pre></div><p>输出类似于：</p><pre tabindex=0><code class=language-none data-lang=none>service/frontend created
service/redis-master created
service/redis-slave created
deployment.apps/frontend created
deployment.apps/redis-master created
deployment.apps/redis-slave created
</code></pre><p>你部署的应用在 Kubernetes 中运行起来了。</p></li></ol><ol start=3><li><p>访问你的应用。</p><p>如果你在开发过程中使用 <code>minikube</code>，请执行：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>minikube service frontend
</span></span></code></pre></div><p>否则，我们要查看一下你的服务使用了什么 IP！</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl describe svc frontend
</span></span></code></pre></div><pre tabindex=0><code class=language-none data-lang=none>Name:                   frontend
Namespace:              default
Labels:                 service=frontend
Selector:               service=frontend
Type:                   LoadBalancer
IP:                     10.0.0.183
LoadBalancer Ingress:   192.0.2.89
Port:                   80      80/TCP
NodePort:               80      31144/TCP
Endpoints:              172.17.0.4:80
Session Affinity:       None
No events.
</code></pre><p>如果你使用的是云驱动，你的 IP 将在 <code>LoadBalancer Ingress</code> 字段给出。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>curl http://192.0.2.89
</span></span></code></pre></div></li></ol><h2 id=user-guide>用户指南</h2><ul><li><p>CLI</p><ul><li><a href=#kompose-convert><code>kompose convert</code></a></li></ul></li><li><p>文档</p><ul><li><a href=#alternative-conversions>其他转换方式</a></li><li><a href=#labels>标签</a></li><li><a href=#restart>重启</a></li><li><a href=#docker-compose-versions>Docker Compose 版本</a></li></ul></li></ul><p>Kompose 支持两种驱动：OpenShift 和 Kubernetes。
你可以通过全局选项 <code>--provider</code> 选择驱动。如果没有指定，
会将 Kubernetes 作为默认驱动。</p><h2 id=kompose-convert><code>kompose convert</code></h2><p>Kompose 支持将 V1、V2 和 V3 版本的 Docker Compose 文件转换为 Kubernetes 和 OpenShift 资源对象。</p><h3 id=kubernetes-kompose-convert-example>Kubernetes <code>kompose convert</code> 示例</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kompose --file docker-voting.yml convert
</span></span></code></pre></div><pre tabindex=0><code class=language-none data-lang=none>WARN Unsupported key networks - ignoring
WARN Unsupported key build - ignoring
INFO Kubernetes file &#34;worker-svc.yaml&#34; created
INFO Kubernetes file &#34;db-svc.yaml&#34; created
INFO Kubernetes file &#34;redis-svc.yaml&#34; created
INFO Kubernetes file &#34;result-svc.yaml&#34; created
INFO Kubernetes file &#34;vote-svc.yaml&#34; created
INFO Kubernetes file &#34;redis-deployment.yaml&#34; created
INFO Kubernetes file &#34;result-deployment.yaml&#34; created
INFO Kubernetes file &#34;vote-deployment.yaml&#34; created
INFO Kubernetes file &#34;worker-deployment.yaml&#34; created
INFO Kubernetes file &#34;db-deployment.yaml&#34; created
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>ls
</span></span></code></pre></div><pre tabindex=0><code class=language-none data-lang=none>db-deployment.yaml  docker-compose.yml         docker-gitlab.yml  redis-deployment.yaml  result-deployment.yaml  vote-deployment.yaml  worker-deployment.yaml
db-svc.yaml         docker-voting.yml          redis-svc.yaml     result-svc.yaml        vote-svc.yaml           worker-svc.yaml
</code></pre><p>你也可以同时提供多个 docker-compose 文件进行转换：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kompose -f docker-compose.yml -f docker-guestbook.yml convert
</span></span></code></pre></div><pre tabindex=0><code class=language-none data-lang=none>INFO Kubernetes file &#34;frontend-service.yaml&#34; created         
INFO Kubernetes file &#34;mlbparks-service.yaml&#34; created         
INFO Kubernetes file &#34;mongodb-service.yaml&#34; created          
INFO Kubernetes file &#34;redis-master-service.yaml&#34; created     
INFO Kubernetes file &#34;redis-slave-service.yaml&#34; created      
INFO Kubernetes file &#34;frontend-deployment.yaml&#34; created      
INFO Kubernetes file &#34;mlbparks-deployment.yaml&#34; created      
INFO Kubernetes file &#34;mongodb-deployment.yaml&#34; created       
INFO Kubernetes file &#34;mongodb-claim0-persistentvolumeclaim.yaml&#34; created
INFO Kubernetes file &#34;redis-master-deployment.yaml&#34; created  
INFO Kubernetes file &#34;redis-slave-deployment.yaml&#34; created   
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>ls
</span></span></code></pre></div><pre tabindex=0><code class=language-none data-lang=none>mlbparks-deployment.yaml  mongodb-service.yaml                       redis-slave-service.jsonmlbparks-service.yaml  
frontend-deployment.yaml  mongodb-claim0-persistentvolumeclaim.yaml  redis-master-service.yaml
frontend-service.yaml     mongodb-deployment.yaml                    redis-slave-deployment.yaml
redis-master-deployment.yaml
</code></pre><p>当提供多个 docker-compose 文件时，配置将会合并。任何通用的配置都将被后续文件覆盖。</p><h3 id=openshift-kompose-convert-example>OpenShift <code>kompose convert</code> 示例</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kompose --provider openshift --file docker-voting.yml convert
</span></span></code></pre></div><pre tabindex=0><code class=language-none data-lang=none>WARN [worker] Service cannot be created because of missing port.
INFO OpenShift file &#34;vote-service.yaml&#34; created             
INFO OpenShift file &#34;db-service.yaml&#34; created               
INFO OpenShift file &#34;redis-service.yaml&#34; created            
INFO OpenShift file &#34;result-service.yaml&#34; created           
INFO OpenShift file &#34;vote-deploymentconfig.yaml&#34; created    
INFO OpenShift file &#34;vote-imagestream.yaml&#34; created         
INFO OpenShift file &#34;worker-deploymentconfig.yaml&#34; created  
INFO OpenShift file &#34;worker-imagestream.yaml&#34; created       
INFO OpenShift file &#34;db-deploymentconfig.yaml&#34; created      
INFO OpenShift file &#34;db-imagestream.yaml&#34; created           
INFO OpenShift file &#34;redis-deploymentconfig.yaml&#34; created   
INFO OpenShift file &#34;redis-imagestream.yaml&#34; created        
INFO OpenShift file &#34;result-deploymentconfig.yaml&#34; created  
INFO OpenShift file &#34;result-imagestream.yaml&#34; created  
</code></pre><p>kompose 还支持为服务中的构建指令创建 buildconfig。
默认情况下，它使用当前 git 分支的 remote 仓库作为源仓库，使用当前分支作为构建的源分支。
你可以分别使用 <code>--build-repo</code> 和 <code>--build-branch</code> 选项指定不同的源仓库和分支。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kompose --provider openshift --file buildconfig/docker-compose.yml convert
</span></span></code></pre></div><pre tabindex=0><code class=language-none data-lang=none>WARN [foo] Service cannot be created because of missing port.
INFO OpenShift Buildconfig using git@github.com:rtnpro/kompose.git::master as source.
INFO OpenShift file &#34;foo-deploymentconfig.yaml&#34; created     
INFO OpenShift file &#34;foo-imagestream.yaml&#34; created          
INFO OpenShift file &#34;foo-buildconfig.yaml&#34; created
</code></pre><div class="alert alert-info note callout" role=alert><strong>说明：</strong> 如果使用 <code>oc create -f</code> 手动推送 OpenShift 工件，则需要确保在构建配置工件之前推送
imagestream 工件，以解决 OpenShift 的这个问题： <a href=https://github.com/openshift/origin/issues/4518>https://github.com/openshift/origin/issues/4518</a>。</div><h2 id=alternative-conversions>其他转换方式</h2><p>默认的 <code>kompose</code> 转换会生成 yaml 格式的 Kubernetes
<a href=/zh-cn/docs/concepts/workloads/controllers/deployment/>Deployment</a> 和
<a href=/zh-cn/docs/concepts/services-networking/service/>Service</a> 对象。
你可以选择通过 <code>-j</code> 参数生成 json 格式的对象。
你也可以替换生成 <a href=/zh-cn/docs/concepts/workloads/controllers/replicationcontroller/>Replication Controllers</a> 对象、
<a href=/zh-cn/docs/concepts/workloads/controllers/daemonset/>DaemonSet</a> 或
<a href=https://github.com/helm/helm>Helm</a> Chart。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kompose convert -j
</span></span></code></pre></div><pre tabindex=0><code class=language-none data-lang=none>INFO Kubernetes file &#34;redis-svc.json&#34; created
INFO Kubernetes file &#34;web-svc.json&#34; created
INFO Kubernetes file &#34;redis-deployment.json&#34; created
INFO Kubernetes file &#34;web-deployment.json&#34; created
</code></pre><p><code>*-deployment.json</code> 文件中包含 Deployment 对象。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kompose convert --replication-controller
</span></span></code></pre></div><pre tabindex=0><code class=language-none data-lang=none>INFO Kubernetes file &#34;redis-svc.yaml&#34; created
INFO Kubernetes file &#34;web-svc.yaml&#34; created
INFO Kubernetes file &#34;redis-replicationcontroller.yaml&#34; created
INFO Kubernetes file &#34;web-replicationcontroller.yaml&#34; created
</code></pre><p><code>*-replicationcontroller.yaml</code> 文件包含 Replication Controller 对象。
如果你想指定副本数（默认为 1），可以使用 <code>--replicas</code> 参数：
<code>kompose convert --replication-controller --replicas 3</code></p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kompose convert --daemon-set
</span></span></code></pre></div><pre tabindex=0><code class=language-none data-lang=none>INFO Kubernetes file &#34;redis-svc.yaml&#34; created
INFO Kubernetes file &#34;web-svc.yaml&#34; created
INFO Kubernetes file &#34;redis-daemonset.yaml&#34; created
INFO Kubernetes file &#34;web-daemonset.yaml&#34; created
</code></pre><p><code>*-daemonset.yaml</code> 文件包含 DaemonSet 对象。</p><p>如果你想生成 <a href=https://github.com/kubernetes/helm>Helm</a> 可用的 Chart，
只需简单的执行下面的命令：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kompose convert -c
</span></span></code></pre></div><pre tabindex=0><code class=language-none data-lang=none>INFO Kubernetes file &#34;web-svc.yaml&#34; created
INFO Kubernetes file &#34;redis-svc.yaml&#34; created
INFO Kubernetes file &#34;web-deployment.yaml&#34; created
INFO Kubernetes file &#34;redis-deployment.yaml&#34; created
chart created in &#34;./docker-compose/&#34;
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>tree docker-compose/
</span></span></code></pre></div><pre tabindex=0><code class=language-none data-lang=none>docker-compose
├── Chart.yaml
├── README.md
└── templates
    ├── redis-deployment.yaml
    ├── redis-svc.yaml
    ├── web-deployment.yaml
    └── web-svc.yaml
</code></pre><p>这个 Chart 结构旨在为构建 Helm Chart 提供框架。</p><h2 id=labels>标签</h2><p><code>kompose</code> 支持 <code>docker-compose.yml</code> 文件中用于 Kompose 的标签，
以便在转换时明确定义 Service 的行为。</p><ul><li><p><code>kompose.service.type</code> 定义要创建的 Service 类型。例如：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>services</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nginx</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>dockerfile</span>:<span style=color:#bbb> </span>foobar<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>build</span>:<span style=color:#bbb> </span>./foobar<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cap_add</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- ALL<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>container_name</span>:<span style=color:#bbb> </span>foobar<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>kompose.service.type</span>:<span style=color:#bbb> </span>nodeport<span style=color:#bbb>
</span></span></span></code></pre></div></li></ul><ul><li><p><code>kompose.service.expose</code> 定义是否允许从集群外部访问 Service。
如果该值被设置为 "true"，提供程序将自动设置端点，
对于任何其他值，该值将被设置为主机名。
如果在 Service 中定义了多个端口，则选择第一个端口作为公开端口。</p><ul><li>如果使用 Kubernetes 驱动，会有一个 Ingress 资源被创建，并且假定已经配置了相应的 Ingress 控制器。</li><li>如果使用 OpenShift 驱动，则会有一个 route 被创建。</li></ul><p>例如：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>services</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>web</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>tuna/docker-counter23<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span>- <span style=color:#b44>&#34;5000:5000&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>links</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span>- redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>kompose.service.expose</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;counter.example.com&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>redis</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis:3.0<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span>- <span style=color:#b44>&#34;6379&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div></li></ul><p>当前支持的选项有:</p><table><thead><tr><th>键</th><th>值</th></tr></thead><tbody><tr><td>kompose.service.type</td><td>nodeport / clusterip / loadbalancer</td></tr><tr><td>kompose.service.expose</td><td>true / hostname</td></tr></tbody></table><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p><code>kompose.service.type</code> 标签应该只用 <code>ports</code> 来定义，否则 <code>kompose</code> 会失败。</div><h2 id=restart>重启</h2><p>如果你想创建没有控制器的普通 Pod，可以使用 docker-compose 的 <code>restart</code>
结构来指定这一行为。请参考下表了解 <code>restart</code> 的不同参数。</p><table><thead><tr><th><code>docker-compose</code> <code>restart</code></th><th>创建的对象</th><th>Pod <code>restartPolicy</code></th></tr></thead><tbody><tr><td><code>""</code></td><td>控制器对象</td><td><code>Always</code></td></tr><tr><td><code>always</code></td><td>控制器对象</td><td><code>Always</code></td></tr><tr><td><code>on-failure</code></td><td>Pod</td><td><code>OnFailure</code></td></tr><tr><td><code>no</code></td><td>Pod</td><td><code>Never</code></td></tr></tbody></table><div class="alert alert-info note callout" role=alert><strong>说明：</strong> 控制器对象可以是 <code>deployment</code> 或 <code>replicationcontroller</code>。</div><p>例如，<code>pival</code> Service 将在这里变成 Pod。这个容器计算 <code>pi</code> 的取值。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;2&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>services</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>pival</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>perl<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;perl&#34;</span>,<span style=color:#bbb>  </span><span style=color:#b44>&#34;-Mbignum=bpi&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-wle&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;print bpi(2000)&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>restart</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;on-failure&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=warning-about-deployment-configurations>关于 Deployment Config 的提醒</h3><p>如果 Docker Compose 文件中为服务声明了卷，Deployment（Kubernetes）或
DeploymentConfig（OpenShift）策略会从 “RollingUpdate”（默认）变为 “Recreate”。
这样做的目的是为了避免服务的多个实例同时访问卷。</p><p>如果 Docker Compose 文件中的服务名包含 <code>_</code>（例如 <code>web_service</code>），
那么将会被替换为 <code>-</code>，服务也相应的会重命名（例如 <code>web-service</code>）。
Kompose 这样做的原因是 “Kubernetes” 不允许对象名称中包含 <code>_</code>。</p><p>请注意，更改服务名称可能会破坏一些 <code>docker-compose</code> 文件。</p><h2 id=docker-compose-versions>Docker Compose 版本</h2><p>Kompose 支持的 Docker Compose 版本包括：1、2 和 3。
对 2.1 和 3.2 版本的支持还有限，因为它们还在实验阶段。</p><p>所有三个版本的兼容性列表，
请查看我们的<a href=https://github.com/kubernetes/kompose/blob/master/docs/conversion.md>转换文档</a>，
文档中列出了所有不兼容的 Docker Compose 关键字。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-0a91fdc1445a8c7f3563c41a9b9b3370>24 - 从 PodSecurityPolicy 迁移到内置的 PodSecurity 准入控制器</h1><p>本页面描述从 PodSecurityPolicy 迁移到内置的 PodSecurity 准入控制器的过程。
这一迁移过程可以通过综合使用试运行、<code>audit</code> 和 <code>warn</code> 模式等来实现，
尽管在使用了变更式 PSP 时会变得有些困难。</p><h2 id=准备开始>准备开始</h2><p>你的 Kubernetes 服务器版本必须不低于版本 v1.22.
要获知版本信息，请输入 <code>kubectl version</code>.</p><p>如果你目前运行的 Kubernetes 版本不是 {{ skew currentVersion }}，
你可能要切换本页面以查阅你实际所运行的 Kubernetes 版本文档。</p><p>本页面假定你已经熟悉 <a href=/zh-cn/docs/concepts/security/pod-security-admission/>Pod 安全性准入</a>的基本概念。</p><h2 id=overall-approach>方法概览</h2><p>你可以采取多种策略来完成从 PodSecurityPolicy 到 Pod 安全性准入
（Pod Security Admission）的迁移。
下面是一种可能的迁移路径，其目标是尽可能降低生产环境不可用的风险，
以及安全性仍然不足的风险。</p><ol start=0><li>确定 Pod 安全性准入是否对于你的使用场景而言比较合适。</li><li>审查名字空间访问权限。</li><li>简化、标准化 PodSecurityPolicy。</li><li>更新名字空间：<ol><li>确定合适的 Pod 安全性级别；</li><li>验证该 Pod 安全性级别可工作；</li><li>实施该 Pod 安全性级别；</li><li>绕过 PodSecurityPolicy。</li></ol></li><li>审阅名字空间创建过程。</li><li>禁用 PodSecurityPolicy。</li></ol><h2 id=is-psa-right-for-you>0. 确定是否 Pod 安全性准入适合你</h2><p>Pod 安全性准入被设计用来直接满足最常见的安全性需求，并提供一组可用于多个集群的安全性级别。
不过，这一机制比 PodSecurityPolicy 的灵活度要低。
值得注意的是，PodSecurityPolicy 所支持的以下特性是 Pod 安全性准入所不支持的：</p><ul><li><strong>设置默认的安全性约束</strong> - Pod 安全性准入是一个非变更性质的准入控制器，
这就意味着它不会在对 Pod 进行合法性检查之前更改其配置。如果你之前依赖于 PSP 的这方面能力，
你或者需要更改你的负载以满足 Pod 安全性约束，或者需要使用一个
<a href=/zh-cn/docs/reference/access-authn-authz/extensible-admission-controllers/>变更性质的准入 Webhook</a>
来执行相应的变更。进一步的细节可参见后文的<a href=#simplify-psps>简化和标准化 PodSecurityPolicy</a>。</li></ul><ul><li><strong>对策略定义的细粒度控制</strong> - Pod 安全性准入仅支持
<a href=/zh-cn/docs/concepts/security/pod-security-standards/>三种标准级别</a>。
如果你需要对特定的约束施加更多的控制，你就需要使用一个
<a href=/zh-cn/docs/reference/access-authn-authz/extensible-admission-controllers/>验证性质的准入 Webhook</a>
以实施这列策略。</li></ul><ul><li><strong>粒度小于名字空间的策略</strong> - PodSecurityPolicy 允许你为不同的服务账户或用户绑定不同策略，
即使这些服务账户或用户隶属于同一个名字空间。这一方法有很多缺陷，不建议使用。
不过如果你的确需要这种功能，你就需要使用第三方的 Webhook。
唯一的例外是当你只需要完全针对某用户或者
<a href=/zh-cn/docs/concepts/containers/runtime-class/>RuntimeClasses</a> 赋予豁免规则时，
Pod 安全性准入的确也为豁免规则暴露一些
<a href=/zh-cn/docs/concepts/security/pod-security-admission/#exemptions>静态配置</a>。</li></ul><p>即便 Pod 安全性准入无法满足你的所有需求，该机制也是设计用作其他策略实施机制的
<strong>补充</strong>，因此可以和其他准入 Webhook 一起运行，进而提供一种有用的兜底机制。</p><h2 id=review-namespace-permissions>1. 审查名字空间访问权限</h2><p>Pod 安全性准入是通过<a href=/zh-cn/docs/concepts/security/pod-security-admission/#pod-security-admission-labels-for-namespaces>名字空间上的标签</a>
来控制的。这也就是说，任何能够更新（或通过 patch 部分更新或创建）
名字空间的人都可以更改该名字空间的 Pod 安全性级别，而这可能会被利用来绕过约束性更强的策略。
在继续执行迁移操作之前，请确保只有被信任的、有特权的用户具有这类名字空间访问权限。
不建议将这类强大的访问权限授予不应获得权限提升的用户，不过如果你必须这样做，
你需要使用一个<a href=/zh-cn/docs/reference/access-authn-authz/extensible-admission-controllers/>准入 Webhook</a>
来针对为 Namespace 对象设置 Pod 安全性级别设置额外的约束。</p><h2 id=simplify-psps>2. 简化、标准化 PodSecurityPolicy</h2><p>在本节中，你会削减变更性质的 PodSecurityPolicy，去掉 Pod 安全性标准范畴之外的选项。
针对要修改的、已存在的 PodSecurityPolicy，你应该将这里所建议的更改写入到其离线副本中。
所克隆的 PSP 应该与原来的副本名字不同，并且按字母序要排到原副本之前
（例如，可以向 PSP 名字前加一个 <code>0</code>）。
先不要在 Kubernetes 中创建新的策略 -
这类操作会在后文的<a href=#psp-update-rollout>推出更新的策略</a>部分讨论。</p><h3 id=eliminating-mutaging-fields>2.a. 去掉纯粹变更性质的字段</h3><p>如果某个 PodSecurityPolicy 能够变更字段，你可能会在关掉 PodSecurityPolicy
时发现有些 Pod 无法满足 Pod 安全性级别。为避免这类状况，
你应该在执行切换操作之前去掉所有 PSP 的变更操作。
不幸的是，PSP 没有对变更性和验证性字段做清晰的区分，所以这一迁移操作也不够简单直接。</p><p>你可以先去掉那些纯粹变更性质的字段，留下验证策略中的其他内容。
这些字段（也列举于<a href=/zh-cn/docs/reference/access-authn-authz/psp-to-pod-security-standards/>将 PodSecurityPolicy 映射到 Pod 安全性标准</a>参考中）
包括：</p><ul><li><code>.spec.defaultAllowPrivilegeEscalation</code></li><li><code>.spec.runtimeClass.defaultRuntimeClassName</code></li><li><code>.metadata.annotations['seccomp.security.alpha.kubernetes.io/defaultProfileName']</code></li><li><code>.metadata.annotations['apparmor.security.beta.kubernetes.io/defaultProfileName']</code></li><li><code>.spec.defaultAddCapabilities</code> - 尽管理论上是一个混合了变更性与验证性功能的字段，
这里的设置应该被合并到 <code>.spec.allowedCapabilities</code> 中，后者会执行相同的验证操作，
但不会执行任何变更动作。</li></ul><div class="alert alert-warning caution callout" role=alert><strong>注意：</strong><p>删除这些字段可能导致负载缺少所需的配置信息，进而导致一些问题。
参见后文<a href=#psp-update-rollout>退出更新的策略</a>以获得如何安全地将这些变更上线的建议。</div><h3 id=eliminate-non-standard-options>2.b. 去掉 Pod 安全性标准未涉及的选项</h3><p>PodSecurityPolicy 中有一些字段未被 Pod 安全性准入机制覆盖。如果你必须使用这些选项，
你需要在 Pod 安全性准入之外部署
<a href=/zh-cn/docs/reference/access-authn-authz/extensible-admission-controllers/>准入 Webhook</a>
以补充这一能力，而这类操作不在本指南范围。</p><p>首先，你可以去掉 Pod 安全性标准所未覆盖的那些验证性字段。这些字段（也列举于
<a href=/zh-cn/docs/reference/access-authn-authz/psp-to-pod-security-standards/>将 PodSecurityPolicy 映射到 Pod 安全性标准</a>参考中，标记为“无意见”）有：</p><ul><li><code>.spec.allowedHostPaths</code></li><li><code>.spec.allowedFlexVolumes</code></li><li><code>.spec.allowedCSIDrivers</code></li><li><code>.spec.forbiddenSysctls</code></li><li><code>.spec.runtimeClass</code></li></ul><p>你也可以去掉以下字段，这些字段与 POSIX/UNIX 用户组控制有关。</p><div class="alert alert-warning caution callout" role=alert><strong>注意：</strong><p>如果这些字段中存在使用 <code>MustRunAs</code> 策略的情况，则意味着对应字段是变更性质的。
去掉相应的字段可能导致负载无法设置所需的用户组，进而带来一些问题。
关于如何安全地将这类变更上线的相关建议，请参阅后文的<a href=#psp-update-rollout>推出更新的策略</a>部分。</div><ul><li><code>.spec.runAsGroup</code></li><li><code>.spec.supplementalGroups</code></li><li><code>.spec.fsGroup</code></li></ul><p>剩下的变更性字段是为了适当支持 Pod 安全性标准所需要的，因而需要逐个处理：</p><ul><li><code>.spec.requiredDropCapabilities</code> - 需要此字段来为 Restricted 配置去掉 <code>ALL</code> 设置。</li><li><code>.spec.seLinux</code> - （仅针对带有 <code>MustRunAs</code> 规则的变更性设置）需要此字段来满足
Baseline 和 Restricted 配置所需要的 SELinux 需求。</li><li><code>.spec.runAsUser</code> - （仅针对带有 <code>RunAsAny</code> 规则的非变更性设置）需要此字段来为
Restricted 配置保证 <code>RunAsNonRoot</code>。</li><li><code>.spec.allowPrivilegeEscalation</code> - （如果设置为 <code>false</code> 则为变更性设置）
需要此字段来支持 Restricted 配置。</li></ul><h3 id=psp-update-rollout>2.c. 推出更新的 PSP</h3><p>接下来，你可以将更新后的策略推出到你的集群上。在继续操作时，你要非常小心，
因为去掉变更性质的选项可能导致有些工作负载缺少必需的配置。</p><p>针对更新后的每个 PodSecurityPolicy：</p><ol><li><p>识别运行于原 PSP 之下的 Pod。可以通过 <code>kubernetes.io/psp</code> 注解来完成。
例如，使用 kubectl：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#b8860b>PSP_NAME</span><span style=color:#666>=</span><span style=color:#b44>&#34;original&#34;</span> <span style=color:#080;font-style:italic># 设置你要检查的 PSP 的名称</span>
</span></span><span style=display:flex><span>kubectl get pods --all-namespaces -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#34;{range .items[?(@.metadata.annotations.kubernetes\.io\/psp==&#39;</span><span style=color:#b8860b>$PSP_NAME</span><span style=color:#b44>&#39;)]}{.metadata.namespace} {.metadata.name}{&#39;\n&#39;}{end}&#34;</span>
</span></span></code></pre></div></li></ol><ol start=2><li><p>比较运行中的 Pod 与原来的 Pod 规约，确定 PodSecurityPolicy 是否更改过这些 Pod。
对于通过<a href=/zh-cn/docs/concepts/workloads/controllers/>工作负载资源</a>所创建的 Pod，
你可以比较 Pod 和控制器资源中的 PodTemplate。如果发现任何变更，则原来的 Pod
或者 PodTemplate 需要被更新以加上所希望的配置。要审查的字段包括：</p><ul><li><code>.metadata.annotations['container.apparmor.security.beta.kubernetes.io/*']</code>
（将 <code>*</code> 替换为每个容器的名称）</li><li><code>.spec.runtimeClassName</code></li><li><code>.spec.securityContext.fsGroup</code></li><li><code>.spec.securityContext.seccompProfile</code></li><li><code>.spec.securityContext.seLinuxOptions</code></li><li><code>.spec.securityContext.supplementalGroups</code></li></ul><ul><li>对于容器，在 <code>.spec.containers[*]</code> 和 <code>.spec.initContainers[*]</code> 之下，检查下面字段：</li><li><code>.securityContext.allowPrivilegeEscalation</code></li><li><code>.securityContext.capabilities.add</code></li><li><code>.securityContext.capabilities.drop</code></li><li><code>.securityContext.readOnlyRootFilesystem</code></li><li><code>.securityContext.runAsGroup</code></li><li><code>.securityContext.runAsNonRoot</code></li><li><code>.securityContext.runAsUser</code></li><li><code>.securityContext.seccompProfile</code></li><li><code>.securityContext.seLinuxOptions</code></li></ul></li></ol><ol start=3><li>创建新的 PodSecurityPolicy。如果存在 Role 或 ClusterRole 对象为用户授权了在所有 PSP
上使用 <code>use</code> 动词的权限，则所使用的的会是新创建的 PSP 而不是其变更性的副本。</li><li>更新你的鉴权配置，为访问新的 PSP 授权。在 RBAC 机制下，这意味着需要更新所有为原 PSP
授予 <code>use</code> 访问权限的 Role 或 ClusterRole 对象，使之也对更新后的 PSP 授权。</li></ol><ol start=5><li>验证：经过一段时间后，重新执行步骤 1 中所给的命令，查看是否有 Pod 仍在使用原来的 PSP。
注意，在新的策略被推出到集群之后，Pod 需要被重新创建才可以执行全面验证。</li><li>（可选）一旦你已经验证原来的 PSP 不再被使用，你就可以删除这些 PSP。</li></ol><h2 id=update-namespace>3. 更新名字空间</h2><p>下面的步骤需要在集群中的所有名字空间上执行。所列步骤中的命令使用变量
<code>$NAMESPACE</code> 来引用所更新的名字空间。</p><h3 id=identify-appropriate-level>3.a. 识别合适的 Pod 安全级别</h3><p>首先请回顾 <a href=/zh-cn/docs/concepts/security/pod-security-standards/>Pod 安全性标准</a>内容，
并了解三个安全级别。</p><p>为你的名字空间选择 Pod 安全性级别有几种方法：</p><ol><li><strong>根据名字空间的安全性需求来确定</strong> - 如果你熟悉某名字空间的预期访问级别，
你可以根据这类需求来选择合适的安全级别，就像大家在为新集群确定安全级别一样。</li></ol><ol start=2><li><p><strong>根据现有的 PodSecurityPolicy 来确定</strong> - 基于
<a href=/zh-cn/docs/reference/access-authn-authz/psp-to-pod-security-standards/>将 PodSecurityPolicy 映射到 Pod 安全性标准</a>
参考资料，你可以将各个 PSP 映射到某个 Pod 安全性标准级别。如果你的 PSP 不是基于
Pod 安全性标准的，你可能或者需要选择一个至少与该 PSP 一样宽松的级别，
或者选择一个至少与其一样严格的级别。使用下面的命令你可以查看被 Pod 使用的 PSP 有哪些：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl get pods -n <span style=color:#b8860b>$NAMESPACE</span> -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#34;{.items[*].metadata.annotations.kubernetes\.io\/psp}&#34;</span> | tr <span style=color:#b44>&#34; &#34;</span> <span style=color:#b44>&#34;\n&#34;</span> | sort -u
</span></span></code></pre></div></li></ol><ol start=3><li><strong>根据现有 Pod 来确定</strong> - 使用<a href=#verify-pss-level>检查 Pod 安全性级别</a>小节所述策略，
你可以测试 Baseline 和 Restricted 级别，检查它们是否对于现有负载而言足够宽松，
并选择二者之间特权级较低的合法级别。</li></ol><div class="alert alert-warning caution callout" role=alert><strong>注意：</strong><p>上面的第二和第三种方案是基于 <em>现有</em> Pod 的，因此可能错失那些当前未处于运行状态的
Pod，例如 CronJobs、缩容到零的负载，或者其他尚未全面铺开的负载。</div><h3 id=verify-pss-level>3.b. 检查 Pod 安全性级别</h3><p>一旦你已经为名字空间选择了 Pod 安全性级别（或者你正在尝试多个不同级别），
先进行测试是个不错的主意（如果使用 Privileged 级别，则可略过此步骤）。
Pod 安全性包含若干工具可用来测试和安全地推出安全性配置。</p><p>首先，你可以试运行新策略，这个过程可以针对所应用的策略评估当前在名字空间中运行的
Pod，但不会令新策略马上生效：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#080;font-style:italic># $LEVEL 是要试运行的级别，可以是 &#34;baseline&#34; 或 &#34;restricted&#34;</span>
</span></span><span style=display:flex><span>kubectl label --dry-run<span style=color:#666>=</span>server --overwrite ns <span style=color:#b8860b>$NAMESPACE</span> pod-security.kubernetes.io/enforce<span style=color:#666>=</span><span style=color:#b8860b>$LEVEL</span>
</span></span></code></pre></div><p>此命令会针对在所提议的级别下不再合法的所有 <strong>现存</strong> Pod 返回警告信息。</p><p>第二种办法在抓取当前未运行的负载方面表现的更好：audit 模式。
运行于 audit 模式（而非 enforcing 模式）下时，违反策略级别的 Pod 会被记录到审计日志中，
经过一段时间后可以在日志中查看到，但这些 Pod 不会被拒绝。
warning 模式的工作方式与此类似，不过会立即向用户返回告警信息。
你可以使用下面的命令为名字空间设置 audit 模式的级别：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl label --overwrite ns <span style=color:#b8860b>$NAMESPACE</span> pod-security.kubernetes.io/audit<span style=color:#666>=</span><span style=color:#b8860b>$LEVEL</span>
</span></span></code></pre></div><p>当以上两种方法输出意料之外的违例状况时，你就需要或者更新发生违例的负载以满足策略需求，
或者放宽名字空间上的 Pod 安全性级别。</p><h3 id=enforce-pod-security-level>3.c. 实施 Pod 安全性级别</h3><p>当你对可以安全地在名字空间上实施的级别比较满意时，你可以更新名字空间来实施所期望的级别：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl label --overwrite ns <span style=color:#b8860b>$NAMESPACE</span> pod-security.kubernetes.io/enforce<span style=color:#666>=</span><span style=color:#b8860b>$LEVEL</span>
</span></span></code></pre></div><h3 id=bypass-psp>3.d. 绕过 PodSecurityPolicy</h3><p>最后，你可以通过将
<a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/policy/privileged-psp.yaml download=policy/privileged-psp.yaml>完全特权的 PSP</a>
绑定到某名字空间中所有服务账户上，在名字空间层面绕过所有 PodSecurityPolicy。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#080;font-style:italic># 下面集群范围的命令只需要执行一次</span>
</span></span><span style=display:flex><span>kubectl apply -f privileged-psp.yaml
</span></span><span style=display:flex><span>kubectl create clusterrole privileged-psp --verb use --resource podsecuritypolicies.policy --resource-name privileged
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 逐个名字空间地禁用</span>
</span></span><span style=display:flex><span>kubectl create -n <span style=color:#b8860b>$NAMESPACE</span> rolebinding disable-psp --clusterrole privileged-psp --group system:serviceaccounts:<span style=color:#b8860b>$NAMESPACE</span>
</span></span></code></pre></div><p>由于特权 PSP 是非变更性的，PSP 准入控制器总是优选非变更性的 PSP，
上面的操作会确保对应名字空间中的所有 Pod 不再会被 PodSecurityPolicy
所更改或限制。</p><p>按上述操作逐个名字空间地禁用 PodSecurityPolicy 这种做法的好处是，
如果出现问题，你可以很方便地通过删除 RoleBinding 来回滚所作的更改。
你所要做的只是确保之前存在的 PodSecurityPolicy 还在。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#080;font-style:italic># 撤销 PodSecurityPolicy 的禁用</span>
</span></span><span style=display:flex><span>kubectl delete -n <span style=color:#b8860b>$NAMESPACE</span> rolebinding disable-psp
</span></span></code></pre></div><h2 id=review-namespace-creation-process>4. 审阅名字空间创建过程</h2><p>现在，现有的名字空间都已被更新，强制实施 Pod 安全性准入，
你应该确保你用来管控新名字空间创建的流程与/或策略也被更新，这样合适的 Pod
安全性配置会被应用到新的名字空间上。</p><p>你也可以静态配置 Pod 安全性准入控制器，为尚未打标签的名字空间设置默认的
enforce、audit 与/或 warn 级别。
详细信息可参阅<a href=/zh-cn/docs/tasks/configure-pod-container/enforce-standards-admission-controller/#configure-the-admission-controller>配置准入控制器</a>页面。</p><h2 id=disable-psp>5. 禁用 PodSecurityPolicy</h2><p>最后，你已为禁用 PodSecurityPolicy 做好准备。要禁用 PodSecurityPolicy，
你需要更改 API 服务器上的准入配置：
<a href=/zh-cn/docs/reference/access-authn-authz/admission-controllers/#how-do-i-turn-off-an-admission-controller>我如何关闭某个准入控制器？</a></p><p>如果需要验证 PodSecurityPolicy 准入控制器不再被启用，你可以通过扮演某个无法访问任何
PodSecurityPolicy 的用户来执行测试（参见
<a href=/zh-cn/docs/concepts/security/pod-security-policy/#example>PodSecurityPolicy 示例</a>），
或者通过检查 API 服务器的日志来进行验证。在启动期间，API
服务器会输出日志行，列举所挂载的准入控制器插件。</p><pre tabindex=0><code>I0218 00:59:44.903329      13 plugins.go:158] Loaded 16 mutating admission controller(s) successfully in the following order: NamespaceLifecycle,LimitRanger,ServiceAccount,NodeRestriction,TaintNodesByCondition,Priority,DefaultTolerationSeconds,ExtendedResourceToleration,PersistentVolumeLabel,DefaultStorageClass,StorageObjectInUseProtection,RuntimeClass,DefaultIngressClass,MutatingAdmissionWebhook.
I0218 00:59:44.903350      13 plugins.go:161] Loaded 14 validating admission controller(s) successfully in the following order: LimitRanger,ServiceAccount,PodSecurity,Priority,PersistentVolumeClaimResize,RuntimeClass,CertificateApproval,CertificateSigning,CertificateSubjectRestriction,DenyServiceExternalIPs,ValidatingAdmissionWebhook,ResourceQuota.
</code></pre><p>你应该会看到 <code>PodSecurity</code>（在 validating admission controllers 列表中），
并且两个列表中都不应该包含 <code>PodSecurityPolicy</code>。</p><p>一旦你确定 PSP 准入控制器已被禁用（并且这种状况已经持续了一段时间，
这样你才会比较确定不需要回滚），你就可以放心地删除你的 PodSecurityPolicy
以及所关联的所有 Role、ClusterRole、RoleBinding、ClusterRoleBinding 等对象
（仅需要确保他们不再授予其他不相关的访问权限）。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-9c9966a13899846a35113763603cd6db>25 - 使用名字空间标签来实施 Pod 安全性标准</h1><p><a href=/zh-cn/docs/concepts/security/pod-security-standards/#privileged>特权（privileged）</a>、
<a href=/zh-cn/docs/concepts/security/pod-security-standards/#baseline>基线（baseline）</a>和
<a href=/zh-cn/docs/concepts/security/pod-security-standards/#restricted>受限（restricted）</a>
这三种策略涵盖了广泛安全范围，并由 <a href=/zh-cn/docs/concepts/security/pod-security-admission/>Pod 安全</a>
<a class=glossary-tooltip title='在对象持久化之前拦截 Kubernetes API 服务器请求的一段代码。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/reference/access-authn-authz/admission-controllers/ target=_blank aria-label=准入控制器>准入控制器</a>实现。</p><h2 id=准备开始>准备开始</h2><p>你的 Kubernetes 服务器版本必须不低于版本 v1.22.
要获知版本信息，请输入 <code>kubectl version</code>.</p><ul><li>确保 <code>PodSecurity</code> <a href=/zh-cn/docs/reference/command-line-tools-reference/feature-gates/#feature-gates-for-alpha-or-beta-features>特性门控</a>已被启用。</li></ul><h2 id=通过名字空间标签来要求实施-baseline-pod-容器标准>通过名字空间标签来要求实施 <code>baseline</code> Pod 容器标准</h2><p>下面的清单定义了一个 <code>my-baseline-namespace</code> 名字空间，其中</p><ul><li><em>阻止</em>任何不满足 <code>baseline</code> 策略要求的 Pods；</li><li>针对任何无法满足 <code>restricted</code> 策略要求的、已创建的 Pod 为用户生成警告信息，
并添加审计注解；</li><li>将 <code>baseline</code> 和 <code>restricted</code> 策略的版本锁定到 v1.25。</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Namespace<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-baseline-namespace<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>pod-security.kubernetes.io/enforce</span>:<span style=color:#bbb> </span>baseline<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>pod-security.kubernetes.io/enforce-version</span>:<span style=color:#bbb> </span>v1.25<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 我们将这些标签设置为我们所 _期望_ 的 `enforce` 级别</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>pod-security.kubernetes.io/audit</span>:<span style=color:#bbb> </span>restricted<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>pod-security.kubernetes.io/audit-version</span>:<span style=color:#bbb> </span>v1.25<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>pod-security.kubernetes.io/warn</span>:<span style=color:#bbb> </span>restricted<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>pod-security.kubernetes.io/warn-version</span>:<span style=color:#bbb> </span>v1.25<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=使用-kubectl-label-为现有名字空间添加标签>使用 <code>kubectl label</code> 为现有名字空间添加标签</h2><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>在添加或变更 <code>enforce</code> 策略（或版本）标签时，准入插件会测试名字空间中的每个
Pod 以检查其是否满足新的策略。不符合策略的情况会被以警告的形式返回给用户。</div><p>在刚开始为名字空间评估安全性策略变更时，使用 <code>--dry-run</code> 标志是很有用的。
Pod 安全性标准会在 <em>dry run（试运行）</em>
模式下运行，在这种模式下会生成新策略如何处理现有 Pod 的信息，
但不会真正更新策略。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl label --dry-run<span style=color:#666>=</span>server --overwrite ns --all <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>    pod-security.kubernetes.io/enforce<span style=color:#666>=</span>baseline
</span></span></code></pre></div><h3 id=应用到所有名字空间>应用到所有名字空间</h3><p>如果你是刚刚开始使用 Pod 安全性标准，一种比较合适的初始步骤是针对所有名字空间为类似
<code>baseline</code> 这种比较严格的安全级别配置审计注解。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl label --overwrite ns --all <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  pod-security.kubernetes.io/audit<span style=color:#666>=</span>baseline <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  pod-security.kubernetes.io/warn<span style=color:#666>=</span>baseline
</span></span></code></pre></div><p>注意，这里没有设置 enforce 级别，因而没有被显式评估的名字空间可以被识别出来。
你可以使用下面的命令列举那些没有显式设置 enforce 级别的名字空间：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get namespaces --selector<span style=color:#666>=</span><span style=color:#b44>&#39;!pod-security.kubernetes.io/enforce&#39;</span>
</span></span></code></pre></div><h3 id=应用到单个名字空间>应用到单个名字空间</h3><p>你也可以更新特定的名字空间。下面的命令将 <code>enforce=restricted</code> 策略应用到
<code>my-existing-namespace</code> 名字空间，将 restricted 策略的版本锁定到 v1.25。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl label --overwrite ns my-existing-namespace <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  pod-security.kubernetes.io/enforce<span style=color:#666>=</span>restricted <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  pod-security.kubernetes.io/enforce-version<span style=color:#666>=</span>v1.25
</span></span></code></pre></div></div><div class=td-content style=page-break-before:always><h1 id=pg-108be708e50a97cae1cc0b67d5f360b7>26 - 通过配置内置准入控制器实施 Pod 安全标准</h1><p>在 v1.22 版本中，Kubernetes 提供一种内置的<a href=/zh-cn/docs/reference/access-authn-authz/admission-controllers/#podsecurity>准入控制器</a>
用来强制实施 <a href=/zh-cn/docs/concepts/security/pod-security-standards>Pod 安全标准</a>。
你可以配置此准入控制器来设置集群范围的默认值和<a href=/zh-cn/docs/concepts/security/pod-security-admission/#exemptions>豁免选项</a>。</p><h2 id=准备开始>准备开始</h2><p>你的 Kubernetes 服务器版本必须不低于版本 v1.22.
要获知版本信息，请输入 <code>kubectl version</code>.</p><ul><li>确保 <code>PodSecurity</code> <a href=/zh-cn/docs/reference/command-line-tools-reference/feature-gates/#feature-gates-for-alpha-or-beta-features>特性门控</a>已被启用。</li></ul><h2 id=configure-the-admission-controller>配置准入控制器</h2><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiserver.config.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>AdmissionConfiguration<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>plugins</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>PodSecurity<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>configuration</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>pod-security.admission.config.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PodSecurityConfiguration<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 当未设置 mode 标签时会应用的默认设置</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># level 标签必须是以下取值之一：</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># - &#34;privileged&#34; (默认)</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># - &#34;baseline&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># - &#34;restricted&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># version 标签必须是如下取值之一：</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># - &#34;latest&#34; (默认) </span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># - 诸如 &#34;v1.25&#34; 这类版本号</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>defaults</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>enforce</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;privileged&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>enforce-version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;latest&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>audit</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;privileged&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>audit-version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;latest&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>warn</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;privileged&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>warn-version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;latest&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>exemptions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 要豁免的已认证用户名列表</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>usernames</span>:<span style=color:#bbb> </span>[]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 要豁免的运行时类名称列表</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>runtimeClasses</span>:<span style=color:#bbb> </span>[]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 要豁免的名字空间列表</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>namespaces</span>:<span style=color:#bbb> </span>[]<span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p><code>pod-security.admission.config.k8s.io/v1</code> 配置需要 v1.25+。
对于 v1.23 和 v1.24，使用 <a href=https://v1-24.docs.kubernetes.io/zh-cn/docs/tasks/configure-pod-container/enforce-standards-admission-controller/>v1beta1</a>。
对于 v1.22，使用 <a href=https://v1-22.docs.kubernetes.io/docs/tasks/configure-pod-container/enforce-standards-admission-controller/>v1alpha1</a>。
v1beta1 配置结构需要使用 v1.23+ 版本；对于 v1.22 版本，可使用 v1alpha1。</div></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/zh-cn/docs/home/>主页</a>
<a class=text-white href=/zh-cn/blog/>博客</a>
<a class=text-white href=/zh-cn/training/>培训</a>
<a class=text-white href=/zh-cn/partners/>合作伙伴</a>
<a class=text-white href=/zh-cn/community/>社区</a>
<a class=text-white href=/zh-cn/case-studies/>案例分析</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 The Kubernetes 作者 | 文档发布基于 <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a> 授权许可</small><br><small class=text-white>Copyright &copy; 2023 Linux 基金会&reg;。保留所有权利。Linux 基金会已注册并使用商标。如需了解 Linux 基金会的商标列表，请访问<a href=https://www.linuxfoundation.org/trademark-usage class=light-text>商标使用页面</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>