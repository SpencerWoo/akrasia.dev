<!doctype html><html lang=zh-cn class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=en href=https://kubernetes.io/docs/concepts/storage/><link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/concepts/storage/><link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/concepts/storage/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/concepts/storage/><link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/concepts/storage/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/concepts/storage/><link rel=alternate hreflang=pt-br href=https://kubernetes.io/pt-br/docs/concepts/storage/><link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/concepts/storage/><link rel=alternate hreflang=uk href=https://kubernetes.io/uk/docs/concepts/storage/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/zh-cn/docs/concepts/storage/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>存储 | Kubernetes</title><meta property="og:title" content="存储"><meta property="og:description" content="为集群中的 Pods 提供长期和临时存储的方法。"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/zh-cn/docs/concepts/storage/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="存储"><meta itemprop=description content="为集群中的 Pods 提供长期和临时存储的方法。"><meta name=twitter:card content="summary"><meta name=twitter:title content="存储"><meta name=twitter:description content="为集群中的 Pods 提供长期和临时存储的方法。"><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content="为集群中的 Pods 提供长期和临时存储的方法。"><meta property="og:description" content="为集群中的 Pods 提供长期和临时存储的方法。"><meta name=twitter:description content="为集群中的 Pods 提供长期和临时存储的方法。"><meta property="og:url" content="https://kubernetes.io/zh-cn/docs/concepts/storage/"><meta property="og:title" content="存储"><meta name=twitter:title content="存储"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/zh-cn/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/zh-cn/docs/>文档</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/zh-cn/blog/>Kubernetes 博客</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/zh-cn/training/>培训</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/zh-cn/partners/>合作伙伴</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/zh-cn/community/>社区</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/zh-cn/case-studies/>案例分析</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>版本列表</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/zh-cn/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/zh-cn/docs/concepts/storage/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/zh-cn/docs/concepts/storage/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/zh-cn/docs/concepts/storage/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/zh-cn/docs/concepts/storage/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/zh-cn/docs/concepts/storage/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>中文 (Chinese)</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/docs/concepts/storage/>English</a>
<a class=dropdown-item href=/ko/docs/concepts/storage/>한국어 (Korean)</a>
<a class=dropdown-item href=/ja/docs/concepts/storage/>日本語 (Japanese)</a>
<a class=dropdown-item href=/fr/docs/concepts/storage/>Français (French)</a>
<a class=dropdown-item href=/de/docs/concepts/storage/>Deutsch (German)</a>
<a class=dropdown-item href=/es/docs/concepts/storage/>Español (Spanish)</a>
<a class=dropdown-item href=/pt-br/docs/concepts/storage/>Português (Portuguese)</a>
<a class=dropdown-item href=/id/docs/concepts/storage/>Bahasa Indonesia</a>
<a class=dropdown-item href=/uk/docs/concepts/storage/>Українська (Ukrainian)</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>这是本节的多页打印视图。
<a href=# onclick="return print(),!1">点击此处打印</a>.</p><p><a href=/zh-cn/docs/concepts/storage/>返回本页常规视图</a>.</p></div><h1 class=title>存储</h1><div class=lead>为集群中的 Pods 提供长期和临时存储的方法。</div><ul><li>1: <a href=#pg-27795584640a03bd2024f1fe3b3ab754>卷</a></li><li>2: <a href=#pg-ffd12528a12882b282e1bd19e29f9e75>持久卷</a></li><li>3: <a href=#pg-2db414b26d4daec3ebed19dd837830c3>投射卷</a></li><li>4: <a href=#pg-df33eab51202c17bb0fe551d1d5cc5d2>临时卷</a></li><li>5: <a href=#pg-f0276d05eef111249272a1c932a91e2c>存储类</a></li><li>6: <a href=#pg-4d00116c86dade62bdd5be7dc2afa1ca>卷快照类</a></li><li>7: <a href=#pg-018f0a7fc6e2f6d16da37702fc39b4f3>动态卷制备</a></li><li>8: <a href=#pg-707ca81a34eb1ca202f34692e9917d1e>CSI 卷克隆</a></li><li>9: <a href=#pg-c262af210c6828dec445d2f55a1d877a>卷快照</a></li><li>10: <a href=#pg-00cd24f4570b7acaac75c2551c948bc7>存储容量</a></li><li>11: <a href=#pg-055a8df536f8ba8f3aa0217bd2db5437>Windows 存储</a></li><li>12: <a href=#pg-4f40cb95a671e51b4f0156a409d95c6d>卷健康监测</a></li><li>13: <a href=#pg-b2e4b16ac37988c678a3312a4a6639f8>特定于节点的卷数限制</a></li></ul><div class=content></div></div><div class=td-content><h1 id=pg-27795584640a03bd2024f1fe3b3ab754>1 - 卷</h1><p>Container 中的文件在磁盘上是临时存放的，这给 Container 中运行的较重要的应用程序带来一些问题。
问题之一是当容器崩溃时文件丢失。
kubelet 会重新启动容器，但容器会以干净的状态重启。
第二个问题会在同一 <code>Pod</code> 中运行多个容器并共享文件时出现。
Kubernetes <a class=glossary-tooltip title='包含可被 Pod 中容器访问的数据的目录。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/storage/volumes/ target=_blank aria-label=卷（Volume）>卷（Volume）</a>
这一抽象概念能够解决这两个问题。</p><p>阅读本文前建议你熟悉一下 <a href=/zh-cn/docs/concepts/workloads/pods>Pod</a>。</p><h2 id=background>背景</h2><p>Docker 也有<a href=https://docs.docker.com/storage/>卷（Volume）</a> 的概念，但对它只有少量且松散的管理。
Docker 卷是磁盘上或者另外一个容器内的一个目录。
Docker 提供卷驱动程序，但是其功能非常有限。</p><p>Kubernetes 支持很多类型的卷。
<a class=glossary-tooltip title='Pod 表示你的集群上一组正在运行的容器。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/workloads/pods/ target=_blank aria-label=Pod>Pod</a> 可以同时使用任意数目的卷类型。
临时卷类型的生命周期与 Pod 相同，但持久卷可以比 Pod 的存活期长。
当 Pod 不再存在时，Kubernetes 也会销毁临时卷；不过 Kubernetes 不会销毁持久卷。
对于给定 Pod 中任何类型的卷，在容器重启期间数据都不会丢失。</p><p>卷的核心是一个目录，其中可能存有数据，Pod 中的容器可以访问该目录中的数据。
所采用的特定的卷类型将决定该目录如何形成的、使用何种介质保存数据以及目录中存放的内容。</p><p>使用卷时, 在 <code>.spec.volumes</code> 字段中设置为 Pod 提供的卷，并在
<code>.spec.containers[*].volumeMounts</code> 字段中声明卷在容器中的挂载位置。
容器中的进程看到的文件系统视图是由它们的<a class=glossary-tooltip title=镜像（Image）是保存的容器实例，它打包了应用运行所需的一组软件。 data-toggle=tooltip data-placement=top href='/zh-cn/docs/reference/glossary/?all=true#term-image' target=_blank aria-label=容器镜像>容器镜像</a>
的初始内容以及挂载在容器中的卷（如果定义了的话）所组成的。
其中根文件系统同容器镜像的内容相吻合。
任何在该文件系统下的写入操作，如果被允许的话，都会影响接下来容器中进程访问文件系统时所看到的内容。</p><p>卷挂载在镜像中的<a href=#using-subpath>指定路径</a>下。
Pod 配置中的每个容器必须独立指定各个卷的挂载位置。</p><p>卷不能挂载到其他卷之上（不过存在一种<a href=#using-subpath>使用 subPath</a> 的相关机制），也不能与其他卷有硬链接。</p><h2 id=volume-types>卷类型</h2><p>Kubernetes 支持下列类型的卷：</p><h3 id=awselasticblockstore>awsElasticBlockStore （已弃用）</h3><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.17 [deprecated]</code></div><p><code>awsElasticBlockStore</code> 卷将 Amazon Web 服务（AWS）<a href=https://aws.amazon.com/ebs/>EBS 卷</a>挂载到你的
Pod 中。<code>emptyDir</code> 在 Pod 被删除时也会一起被删除，但 EBS 卷的内容在删除
Pod 时会被保留，卷只是被卸载掉了。
这意味着 EBS 卷可以预先填充数据，并且该数据可以在 Pod 之间共享。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>你在使用 EBS 卷之前必须使用 <code>aws ec2 create-volume</code> 命令或者 AWS API 创建该卷。</div><p>使用 <code>awsElasticBlockStore</code> 卷时有一些限制：</p><ul><li>Pod 运行所在的节点必须是 AWS EC2 实例。</li><li>这些实例需要与 EBS 卷在相同的地域（Region）和可用区（Availability-Zone）。</li><li>EBS 卷只支持被挂载到单个 EC2 实例上。</li></ul><h4 id=创建-aws-ebs-卷>创建 AWS EBS 卷</h4><p>在将 EBS 卷用到 Pod 上之前，你首先要创建它。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>aws ec2 create-volume --availability-zone<span style=color:#666>=</span>eu-west-1a --size<span style=color:#666>=</span><span style=color:#666>10</span> --volume-type<span style=color:#666>=</span>gp2
</span></span></code></pre></div><p>确保该区域与你的集群所在的区域相匹配。还要检查卷的大小和 EBS 卷类型都适合你的用途。</p><h4 id=aws-ebs-配置示例>AWS EBS 配置示例</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-ebs<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>registry.k8s.io/test-webserver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/test-ebs<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 此 AWS EBS 卷必须已经存在</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>awsElasticBlockStore</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeID</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&lt;volume id&gt;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>fsType</span>:<span style=color:#bbb> </span>ext4<span style=color:#bbb>
</span></span></span></code></pre></div><p>如果 EBS 卷是分区的，你可以提供可选的字段 <code>partition: "&lt;partition number>"</code> 来指定要挂载到哪个分区上。</p><h4 id=aws-ebs-csi-卷迁移>AWS EBS CSI 卷迁移</h4><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.25 [stable]</code></div><p>启用 <code>awsElasticBlockStore</code> 的 <code>CSIMigration</code> 特性后，所有插件操作将从现有的树内插件重定向到
<code>ebs.csi.aws.com</code> 容器存储接口（CSI）驱动程序。
为了使用此特性，必须在集群中安装
<a href=https://github.com/kubernetes-sigs/aws-ebs-csi-driver>AWS EBS CSI 驱动</a>。</p><h4 id=aws-ebs-csi-迁移结束>AWS EBS CSI 迁移结束</h4><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.17 [alpha]</code></div><p>要禁止控制器管理器和 kubelet 加载 <code>awsElasticBlockStore</code> 存储插件，
请将 <code>InTreePluginAWSUnregister</code> 标志设置为 <code>true</code>。</p><h3 id=azuredisk>azureDisk （已弃用）</h3><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.19 [deprecated]</code></div><p><code>azureDisk</code> 卷类型用来在 Pod 上挂载 Microsoft Azure
<a href=https://azure.microsoft.com/en-us/documentation/articles/virtual-machines-linux-about-disks-vhds/>数据盘（Data Disk）</a> 。
若需了解更多详情，请参考 <a href=https://github.com/kubernetes/examples/tree/master/staging/volumes/azure_disk/README.md><code>azureDisk</code> 卷插件</a>。</p><h4 id=azuredisk-csi-migration>azureDisk 的 CSI 迁移</h4><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.24 [stable]</code></div><p>启用 <code>azureDisk</code> 的 <code>CSIMigration</code> 特性后，所有插件操作从现有的树内插件重定向到
<code>disk.csi.azure.com</code> 容器存储接口（CSI）驱动程序。
为了使用此特性，必须在集群中安装
<a href=https://github.com/kubernetes-sigs/azuredisk-csi-driver>Azure 磁盘 CSI 驱动程序</a>。</p><h4 id=azuredisk-csi-迁移完成>azureDisk CSI 迁移完成</h4><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.21 [alpha]</code></div><p>要禁止控制器管理器和 kubelet 加载 <code>azureDisk</code> 存储插件，
请将 <code>InTreePluginAzureDiskUnregister</code> 标志设置为 <code>true</code>。</p><h3 id=azurefile>azureFile （已弃用）</h3><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.21 [deprecated]</code></div><p><code>azureFile</code> 卷类型用来在 Pod 上挂载 Microsoft Azure 文件卷（File Volume）（SMB 2.1 和 3.0）。
更多详情请参考 <a href=https://github.com/kubernetes/examples/tree/master/staging/volumes/azure_file/README.md><code>azureFile</code> 卷插件</a>。</p><h4 id=azurefile-csi-migration>azureFile CSI 迁移</h4><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.21 [beta]</code></div><p>启用 <code>azureFile</code> 的 <code>CSIMigration</code> 特性后，所有插件操作将从现有的树内插件重定向到
<code>file.csi.azure.com</code> 容器存储接口（CSI）驱动程序。要使用此特性，必须在集群中安装
<a href=https://github.com/kubernetes-sigs/azurefile-csi-driver>Azure 文件 CSI 驱动程序</a>，
并且 <code>CSIMigrationAzureFile</code>
<a href=/zh-cn/docs/reference/command-line-tools-reference/feature-gates/>特性门控</a>
必须被启用。</p><p>Azure 文件 CSI 驱动尚不支持为同一卷设置不同的 fsgroup。
如果 <code>CSIMigrationAzureFile</code> 特性被启用，用不同的 fsgroup 来使用同一卷也是不被支持的。</p><h4 id=azurefile-csi-迁移完成>azureFile CSI 迁移完成</h4><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.21 [alpha]</code></div><p>要禁止控制器管理器和 kubelet 加载 <code>azureFile</code> 存储插件，
请将 <code>InTreePluginAzureFileUnregister</code> 标志设置为 <code>true</code>。</p><h3 id=cephfs>cephfs</h3><p><code>cephfs</code> 卷允许你将现存的 CephFS 卷挂载到 Pod 中。
不像 <code>emptyDir</code> 那样会在 Pod 被删除的同时也会被删除，<code>cephfs</code>
卷的内容在 Pod 被删除时会被保留，只是卷被卸载了。
这意味着 <code>cephfs</code> 卷可以被预先填充数据，且这些数据可以在
Pod 之间共享。同一 <code>cephfs</code> 卷可同时被多个写者挂载。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>在使用 Ceph 卷之前，你的 Ceph 服务器必须已经运行并将要使用的 share 导出（exported）。</div><p>更多信息请参考 <a href=https://github.com/kubernetes/examples/tree/master/volumes/cephfs/>CephFS 示例</a>。</p><h3 id=cinder>cinder （已弃用）</h3><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.18 [deprecated]</code></div><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>Kubernetes 必须配置了 OpenStack Cloud Provider。</div><p><code>cinder</code> 卷类型用于将 OpenStack Cinder 卷挂载到 Pod 中。</p><h4 id=cinder-volume-example-configuration>Cinder 卷示例配置</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-cinder<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>registry.k8s.io/test-webserver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-cinder-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/test-cinder<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 此 OpenStack 卷必须已经存在</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cinder</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeID</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&lt;volume id&gt;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>fsType</span>:<span style=color:#bbb> </span>ext4<span style=color:#bbb>
</span></span></span></code></pre></div><h4 id=openstack-csi-迁移>OpenStack CSI 迁移</h4><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.24 [stable]</code></div><p>自 Kubernetes 1.21 版本起，Cinder 的 <code>CSIMigration</code> 特性是默认被启用的。
此特性会将插件的所有操作从现有的树内插件重定向到
<code>cinder.csi.openstack.org</code> 容器存储接口（CSI）驱动程序。
为了使用此特性，必须在集群中安装
<a href=https://github.com/kubernetes/cloud-provider-openstack/blob/master/docs/cinder-csi-plugin/using-cinder-csi-plugin.md>OpenStack Cinder CSI 驱动程序</a>，
你可以通过设置 <code>CSIMigrationOpenStack</code>
<a href=/zh-cn/docs/reference/command-line-tools-reference/feature-gates/>特性门控</a>
为 <code>false</code> 来禁止 Cinder CSI 迁移。</p><p>要禁止控制器管理器和 kubelet 加载树内 Cinder 插件，你可以启用
<code>InTreePluginOpenStackUnregister</code> <a href=/zh-cn/docs/reference/command-line-tools-reference/feature-gates/>特性门控</a>。</p><h3 id=configmap>configMap</h3><p><a href=/zh-cn/docs/tasks/configure-pod-container/configure-pod-configmap/><code>configMap</code></a>
卷提供了向 Pod 注入配置数据的方法。
ConfigMap 对象中存储的数据可以被 <code>configMap</code> 类型的卷引用，然后被 Pod 中运行的容器化应用使用。</p><p>引用 configMap 对象时，你可以在卷中通过它的名称来引用。
你可以自定义 ConfigMap 中特定条目所要使用的路径。
下面的配置显示了如何将名为 <code>log-config</code> 的 ConfigMap 挂载到名为 <code>configmap-pod</code>
的 Pod 中：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>configmap-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config-vol<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/etc/config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config-vol<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>configMap</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>log-config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>log_level<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>log_level<span style=color:#bbb>
</span></span></span></code></pre></div><p><code>log-config</code> ConfigMap 以卷的形式挂载，并且存储在 <code>log_level</code>
条目中的所有内容都被挂载到 Pod 的 <code>/etc/config/log_level</code> 路径下。
请注意，这个路径来源于卷的 <code>mountPath</code> 和 <code>log_level</code> 键对应的 <code>path</code>。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong><ul><li>在使用 <a href=/zh-cn/docs/tasks/configure-pod-container/configure-pod-configmap/>ConfigMap</a> 之前你首先要创建它。</li><li>容器以 <a href=#using-subpath>subPath</a> 卷挂载方式使用 ConfigMap 时，将无法接收 ConfigMap 的更新。</li><li>文本数据挂载成文件时采用 UTF-8 字符编码。如果使用其他字符编码形式，可使用
<code>binaryData</code> 字段。</li></ul></div><h3 id=downwardapi>downwardAPI</h3><p><code>downwardAPI</code> 卷用于为应用提供 <a class=glossary-tooltip title='将 Pod 和容器字段值暴露给容器中运行的代码的机制。' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/downward-api/ target=_blank aria-label='downward API'>downward API</a> 数据。
在这类卷中，所公开的数据以纯文本格式的只读文件形式存在。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong> 容器以 <a href=#using-subpath>subPath</a> 卷挂载方式使用 downward API 时，在字段值更改时将不能接收到它的更新。</div><p>更多详细信息请参考<a href=/zh-cn/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information/>通过文件将 Pod 信息呈现给容器</a>。</p><h3 id=emptydir>emptyDir</h3><p>当 Pod 分派到某个节点上时，<code>emptyDir</code> 卷会被创建，并且在 Pod 在该节点上运行期间，卷一直存在。
就像其名称表示的那样，卷最初是空的。
尽管 Pod 中的容器挂载 <code>emptyDir</code> 卷的路径可能相同也可能不同，这些容器都可以读写
<code>emptyDir</code> 卷中相同的文件。
当 Pod 因为某些原因被从节点上删除时，<code>emptyDir</code> 卷中的数据也会被永久删除。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>容器崩溃并<strong>不</strong>会导致 Pod 被从节点上移除，因此容器崩溃期间 <code>emptyDir</code> 卷中的数据是安全的。</div><p><code>emptyDir</code> 的一些用途：</p><ul><li>缓存空间，例如基于磁盘的归并排序。</li><li>为耗时较长的计算任务提供检查点，以便任务能方便地从崩溃前状态恢复执行。</li><li>在 Web 服务器容器服务数据时，保存内容管理器容器获取的文件。</li></ul><p><code>emptyDir.medium</code> 字段用来控制 <code>emptyDir</code> 卷的存储位置。
默认情况下，<code>emptyDir</code> 卷存储在该节点所使用的介质上；
此处的介质可以是磁盘、SSD 或网络存储，这取决于你的环境。
你可以将 <code>emptyDir.medium</code> 字段设置为 <code>"Memory"</code>，
以告诉 Kubernetes 为你挂载 tmpfs（基于 RAM 的文件系统）。
虽然 tmpfs 速度非常快，但是要注意它与磁盘不同：tmpfs 在节点重启时会被清除，
并且你所写入的所有文件都会计入容器的内存消耗，受容器内存限制约束。</p><p>你可以通过为默认介质指定大小限制，来限制 <code>emptyDir</code> 卷的存储容量。
此存储是从<a href=/zh-cn/docs/concepts/configuration/manage-resources-containers/#setting-requests-and-limits-for-local-ephemeral-storage>节点临时存储</a>中分配的。
如果来自其他来源（如日志文件或镜像分层数据）的数据占满了存储，<code>emptyDir</code>
可能会在达到此限制之前发生存储容量不足的问题。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>当启用 <code>SizeMemoryBackedVolumes</code> <a href=/zh-cn/docs/reference/command-line-tools-reference/feature-gates/>特性门控</a>时，
你可以为基于内存提供的卷指定大小。
如果未指定大小，则基于内存的卷的大小为 Linux 主机上内存的 50%。</div><h4 id=emptydir-配置示例>emptyDir 配置示例</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-pd<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>registry.k8s.io/test-webserver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/cache<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cache-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cache-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>sizeLimit</span>:<span style=color:#bbb> </span>500Mi<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=fc>fc (光纤通道)</h3><p><code>fc</code> 卷类型允许将现有的光纤通道块存储卷挂载到 Pod 中。
可以使用卷配置中的参数 <code>targetWWNs</code> 来指定单个或多个目标 WWN（World Wide Names）。
如果指定了多个 WWN，targetWWNs 期望这些 WWN 来自多路径连接。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>你必须配置 FC SAN Zoning，以便预先向目标 WWN 分配和屏蔽这些 LUN（卷），这样
Kubernetes 主机才可以访问它们。</div><p>更多详情请参考 <a href=https://github.com/kubernetes/examples/tree/master/staging/volumes/fibre_channel>FC 示例</a>。</p><h3 id=gcepersistentdisk>gcePersistentDisk（已弃用）</h3><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.17 [deprecated]</code></div><p><code>gcePersistentDisk</code> 卷能将谷歌计算引擎 (GCE) <a href=http://cloud.google.com/compute/docs/disks>持久盘（PD）</a>
挂载到你的 Pod 中。
不像 <code>emptyDir</code> 那样会在 Pod 被删除的同时也会被删除，持久盘卷的内容在删除 Pod
时会被保留，卷只是被卸载了。
这意味着持久盘卷可以被预先填充数据，并且这些数据可以在 Pod 之间共享。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>在使用 PD 前，你必须使用 <code>gcloud</code> 或者 GCE API 或 UI 创建它。</div><p>使用 <code>gcePersistentDisk</code> 时有一些限制：</p><ul><li>运行 Pod 的节点必须是 GCE VM</li><li>这些 VM 必须和持久盘位于相同的 GCE 项目和区域（zone）</li></ul><p>GCE PD 的一个特点是它们可以同时被多个消费者以只读方式挂载。
这意味着你可以用数据集预先填充 PD，然后根据需要并行地在尽可能多的 Pod 中提供该数据集。
不幸的是，PD 只能由单个使用者以读写模式挂载，即不允许同时写入。</p><p>在由 ReplicationController 所管理的 Pod 上使用 GCE PD 将会失败，除非 PD
是只读模式或者副本的数量是 0 或 1。</p><h4 id=gce-create-persistent-disk>创建 GCE 持久盘（PD）</h4><p>在 Pod 中使用 GCE 持久盘之前，你首先要创建它。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>gcloud compute disks create --size<span style=color:#666>=</span>500GB --zone<span style=color:#666>=</span>us-central1-a my-data-disk
</span></span></code></pre></div><h4 id=gce-pd-configuration-example>GCE 持久盘配置示例</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-pd<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>registry.k8s.io/test-webserver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/test-pd<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 此 GCE PD 必须已经存在</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>gcePersistentDisk</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>pdName</span>:<span style=color:#bbb> </span>my-data-disk<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>fsType</span>:<span style=color:#bbb> </span>ext4<span style=color:#bbb>
</span></span></span></code></pre></div><h4 id=regional-persistent-disks>区域持久盘</h4><p><a href=https://cloud.google.com/compute/docs/disks/#repds>区域持久盘</a>特性允许你创建能在同一区域的两个可用区中使用的持久盘。
要使用这个特性，必须以持久卷（PersistentVolume）的方式提供卷；直接从
Pod 引用这种卷是不可以的。</p><h4 id=manually-provisioning-regional-pd-pv>手动供应基于区域 PD 的 PersistentVolume</h4><p>使用<a href=/zh-cn/docs/concepts/storage/storage-classes/#gce-pd>为 GCE PD 定义的存储类</a>
可以实现动态供应。在创建 PersistentVolume 之前，你首先要创建 PD。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>gcloud compute disks create --size<span style=color:#666>=</span>500GB my-data-disk
</span></span><span style=display:flex><span>  --region us-central1
</span></span><span style=display:flex><span>  --replica-zones us-central1-a,us-central1-b
</span></span></code></pre></div><h4 id=区域持久盘配置示例>区域持久盘配置示例</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>capacity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>400Gi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- ReadWriteOnce<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>gcePersistentDisk</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>pdName</span>:<span style=color:#bbb> </span>my-data-disk<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>fsType</span>:<span style=color:#bbb> </span>ext4<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodeAffinity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>required</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>nodeSelectorTerms</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># failure-domain.beta.kubernetes.io/zone 应在 1.21 之前使用</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>topology.kubernetes.io/zone<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>- us-central1-a<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>- us-central1-b<span style=color:#bbb>
</span></span></span></code></pre></div><h4 id=gce-csi-migration>GCE CSI 迁移</h4><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.25 [stable]</code></div><p>启用 GCE PD 的 <code>CSIMigration</code> 特性后，所有插件操作将从现有的树内插件重定向到
<code>pd.csi.storage.gke.io</code> 容器存储接口（CSI）驱动程序。
为了使用此特性，必须在集群中上安装
<a href=https://github.com/kubernetes-sigs/gcp-compute-persistent-disk-csi-driver>GCE PD CSI 驱动程序</a>。</p><h4 id=gce-csi-迁移完成>GCE CSI 迁移完成</h4><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.21 [alpha]</code></div><p>要禁止控制器管理器和 kubelet 加载 <code>gcePersistentDisk</code> 存储插件，请将
<code>InTreePluginGCEUnregister</code> 标志设置为 <code>true</code>。</p><h3 id=gitrepo>gitRepo (已弃用)</h3><div class="alert alert-danger warning callout" role=alert><strong>警告：</strong><p><code>gitRepo</code> 卷类型已经被废弃。如果需要在容器中提供 git 仓库，请将一个
<a href=#emptydir>EmptyDir</a> 卷挂载到 InitContainer 中，使用 git
命令完成仓库的克隆操作，然后将 <a href=#emptydir>EmptyDir</a> 卷挂载到 Pod 的容器中。</div><p><code>gitRepo</code> 卷是一个卷插件的例子。
该查卷挂载一个空目录，并将一个 Git 代码仓库克隆到这个目录中供 Pod 使用。</p><p>下面给出一个 <code>gitRepo</code> 卷的示例：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>server<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/mypath<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>git-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>git-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>gitRepo</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>repository</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;git@somewhere:me/my-git-repository.git&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>revision</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;22f1d8406d464b0c0874075539c1f2e96c253775&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=glusterfs>glusterfs（已弃用）</h3><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.25 [deprecated]</code></div><p><code>glusterfs</code> 卷能将 <a href=https://www.gluster.org>Glusterfs</a> (一个开源的网络文件系统)
挂载到你的 Pod 中。不像 <code>emptyDir</code> 那样会在删除 Pod 的同时也会被删除，<code>glusterfs</code>
卷的内容在删除 Pod 时会被保存，卷只是被卸载。
这意味着 <code>glusterfs</code> 卷可以被预先填充数据，并且这些数据可以在 Pod 之间共享。
GlusterFS 可以被多个写者同时挂载。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>在使用前你必须先安装运行自己的 GlusterFS。</div><p>更多详情请参考 <a href=https://github.com/kubernetes/examples/tree/master/volumes/glusterfs>GlusterFS 示例</a>。</p><h3 id=hostpath>hostPath</h3><div class="alert alert-danger warning callout" role=alert><strong>警告：</strong><p>HostPath 卷存在许多安全风险，最佳做法是尽可能避免使用 HostPath。
当必须使用 HostPath 卷时，它的范围应仅限于所需的文件或目录，并以只读方式挂载。</p><p>如果通过 AdmissionPolicy 限制 HostPath 对特定目录的访问，则必须要求
<code>volumeMounts</code> 使用 <code>readOnly</code> 挂载以使策略生效。</p></div><p><code>hostPath</code> 卷能将主机节点文件系统上的文件或目录挂载到你的 Pod 中。
虽然这不是大多数 Pod 需要的，但是它为一些应用程序提供了强大的逃生舱。</p><p>例如，<code>hostPath</code> 的一些用法有：</p><ul><li>运行一个需要访问 Docker 内部机制的容器；可使用 <code>hostPath</code> 挂载 <code>/var/lib/docker</code> 路径。</li><li>在容器中运行 cAdvisor 时，以 <code>hostPath</code> 方式挂载 <code>/sys</code>。</li><li>允许 Pod 指定给定的 <code>hostPath</code> 在运行 Pod 之前是否应该存在，是否应该创建以及应该以什么方式存在。</li></ul><p>除了必需的 <code>path</code> 属性之外，你可以选择性地为 <code>hostPath</code> 卷指定 <code>type</code>。</p><p>支持的 <code>type</code> 值如下：</p><table><thead><tr><th style=text-align:left>取值</th><th style=text-align:left>行为</th></tr></thead><tbody><tr><td style=text-align:left></td><td style=text-align:left>空字符串（默认）用于向后兼容，这意味着在安装 hostPath 卷之前不会执行任何检查。</td></tr><tr><td style=text-align:left><code>DirectoryOrCreate</code></td><td style=text-align:left>如果在给定路径上什么都不存在，那么将根据需要创建空目录，权限设置为 0755，具有与 kubelet 相同的组和属主信息。</td></tr><tr><td style=text-align:left><code>Directory</code></td><td style=text-align:left>在给定路径上必须存在的目录。</td></tr><tr><td style=text-align:left><code>FileOrCreate</code></td><td style=text-align:left>如果在给定路径上什么都不存在，那么将在那里根据需要创建空文件，权限设置为 0644，具有与 kubelet 相同的组和所有权。</td></tr><tr><td style=text-align:left><code>File</code></td><td style=text-align:left>在给定路径上必须存在的文件。</td></tr><tr><td style=text-align:left><code>Socket</code></td><td style=text-align:left>在给定路径上必须存在的 UNIX 套接字。</td></tr><tr><td style=text-align:left><code>CharDevice</code></td><td style=text-align:left>在给定路径上必须存在的字符设备。</td></tr><tr><td style=text-align:left><code>BlockDevice</code></td><td style=text-align:left>在给定路径上必须存在的块设备。</td></tr></tbody></table><p>当使用这种类型的卷时要小心，因为：</p><ul><li>HostPath 卷可能会暴露特权系统凭据（例如 Kubelet）或特权
API（例如容器运行时套接字），可用于容器逃逸或攻击集群的其他部分。</li><li>具有相同配置（例如基于同一 PodTemplate 创建）的多个 Pod
会由于节点上文件的不同而在不同节点上有不同的行为。</li><li>下层主机上创建的文件或目录只能由 root 用户写入。
你需要在<a href=/zh-cn/docs/tasks/configure-pod-container/security-context/>特权容器</a>中以
root 身份运行进程，或者修改主机上的文件权限以便容器能够写入 <code>hostPath</code> 卷。</li></ul><h4 id=hostpath-配置示例>hostPath 配置示例</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-pd<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>registry.k8s.io/test-webserver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/test-pd<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 宿主上目录位置</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/data<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 此字段为可选</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Directory<span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-warning caution callout" role=alert><strong>注意：</strong><p><code>FileOrCreate</code> 模式不会负责创建文件的父目录。
如果欲挂载的文件的父目录不存在，Pod 启动会失败。
为了确保这种模式能够工作，可以尝试把文件和它对应的目录分开挂载，如
<a href=#hostpath-fileorcreate-example><code>FileOrCreate</code> 配置</a> 所示。</div><h4 id=hostpath-fileorcreate-example>hostPath FileOrCreate 配置示例</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-webserver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-webserver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>registry.k8s.io/test-webserver:latest<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/local/aaa<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mydir<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/local/aaa/1.txt<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myfile<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mydir<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 确保文件所在目录成功创建。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/var/local/aaa<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>DirectoryOrCreate<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myfile<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/var/local/aaa/1.txt<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>FileOrCreate<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=iscsi>iscsi</h3><p><code>iscsi</code> 卷能将 iSCSI (基于 IP 的 SCSI) 卷挂载到你的 Pod 中。
不像 <code>emptyDir</code> 那样会在删除 Pod 的同时也会被删除，<code>iscsi</code>
卷的内容在删除 Pod 时会被保留，卷只是被卸载。
这意味着 <code>iscsi</code> 卷可以被预先填充数据，并且这些数据可以在 Pod 之间共享。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>在使用 iSCSI 卷之前，你必须拥有自己的 iSCSI 服务器，并在上面创建卷。</div><p>iSCSI 的一个特点是它可以同时被多个用户以只读方式挂载。
这意味着你可以用数据集预先填充卷，然后根据需要在尽可能多的 Pod 上使用它。
不幸的是，iSCSI 卷只能由单个使用者以读写模式挂载。不允许同时写入。</p><p>更多详情请参考 <a href=https://github.com/kubernetes/examples/tree/master/volumes/iscsi>iSCSI 示例</a>。</p><h3 id=local>local</h3><p><code>local</code> 卷所代表的是某个被挂载的本地存储设备，例如磁盘、分区或者目录。</p><p><code>local</code> 卷只能用作静态创建的持久卷。不支持动态配置。</p><p>与 <code>hostPath</code> 卷相比，<code>local</code> 卷能够以持久和可移植的方式使用，而无需手动将 Pod
调度到节点。系统通过查看 PersistentVolume 的节点亲和性配置，就能了解卷的节点约束。</p><p>然而，<code>local</code> 卷仍然取决于底层节点的可用性，并不适合所有应用程序。
如果节点变得不健康，那么 <code>local</code> 卷也将变得不可被 Pod 访问。使用它的 Pod 将不能运行。
使用 <code>local</code> 卷的应用程序必须能够容忍这种可用性的降低，以及因底层磁盘的耐用性特征而带来的潜在的数据丢失风险。</p><p>下面是一个使用 <code>local</code> 卷和 <code>nodeAffinity</code> 的持久卷示例：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example-pv<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>capacity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>100Gi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeMode</span>:<span style=color:#bbb> </span>Filesystem<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- ReadWriteOnce<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>persistentVolumeReclaimPolicy</span>:<span style=color:#bbb> </span>Delete<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>local-storage<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>local</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/mnt/disks/ssd1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodeAffinity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>required</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>nodeSelectorTerms</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>kubernetes.io/hostname<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span>- example-node<span style=color:#bbb>
</span></span></span></code></pre></div><p>使用 <code>local</code> 卷时，你需要设置 PersistentVolume 对象的 <code>nodeAffinity</code> 字段。
Kubernetes 调度器使用 PersistentVolume 的 <code>nodeAffinity</code> 信息来将使用 <code>local</code>
卷的 Pod 调度到正确的节点。</p><p>PersistentVolume 对象的 <code>volumeMode</code> 字段可被设置为 "Block"
（而不是默认值 "Filesystem"），以将 <code>local</code> 卷作为原始块设备暴露出来。</p><p>使用 <code>local</code> 卷时，建议创建一个 StorageClass 并将其 <code>volumeBindingMode</code> 设置为
<code>WaitForFirstConsumer</code>。要了解更多详细信息，请参考
<a href=/zh-cn/docs/concepts/storage/storage-classes/#local>local StorageClass 示例</a>。
延迟卷绑定的操作可以确保 Kubernetes 在为 PersistentVolumeClaim 作出绑定决策时，会评估
Pod 可能具有的其他节点约束，例如：如节点资源需求、节点选择器、Pod 亲和性和 Pod 反亲和性。</p><p>你可以在 Kubernetes 之外单独运行静态驱动以改进对 local 卷的生命周期管理。
请注意，此驱动尚不支持动态配置。
有关如何运行外部 <code>local</code> 卷驱动，请参考
<a href=https://github.com/kubernetes-sigs/sig-storage-local-static-provisioner>local 卷驱动用户指南</a>。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>如果不使用外部静态驱动来管理卷的生命周期，用户需要手动清理和删除 local 类型的持久卷。</div><h3 id=nfs>nfs</h3><p><code>nfs</code> 卷能将 NFS (网络文件系统) 挂载到你的 Pod 中。
不像 <code>emptyDir</code> 那样会在删除 Pod 的同时也会被删除，<code>nfs</code> 卷的内容在删除 Pod
时会被保存，卷只是被卸载。
这意味着 <code>nfs</code> 卷可以被预先填充数据，并且这些数据可以在 Pod 之间共享。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-pd<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>registry.k8s.io/test-webserver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/my-nfs-data<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>nfs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>server</span>:<span style=color:#bbb> </span>my-nfs-server.example.com<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/my-nfs-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>在使用 NFS 卷之前，你必须运行自己的 NFS 服务器并将目标 share 导出备用。</p><p>还需要注意，不能在 Pod spec 中指定 NFS 挂载可选项。
可以选择设置服务端的挂载可选项，或者使用
<a href=https://man7.org/linux/man-pages/man5/nfsmount.conf.5.html>/etc/nfsmount.conf</a>。
此外，还可以通过允许设置挂载可选项的持久卷挂载 NFS 卷。</p></div><p>如需了解用持久卷挂载 NFS 卷的示例，请参考 <a href=https://github.com/kubernetes/examples/tree/master/staging/volumes/nfs>NFS 示例</a>。</p><h3 id=persistentvolumeclaim>persistentVolumeClaim</h3><p><code>persistentVolumeClaim</code> 卷用来将<a href=/zh-cn/docs/concepts/storage/persistent-volumes/>持久卷</a>（PersistentVolume）挂载到 Pod 中。
持久卷申领（PersistentVolumeClaim）是用户在不知道特定云环境细节的情况下“申领”持久存储（例如
GCE PersistentDisk 或者 iSCSI 卷）的一种方法。</p><p>更多详情请参考<a href=/zh-cn/docs/concepts/storage/persistent-volumes/>持久卷</a>。</p><h3 id=portworxvolume>portworxVolume（已弃用）</h3><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.25 [deprecated]</code></div><p><code>portworxVolume</code> 是一个可伸缩的块存储层，能够以超融合（hyperconverged）的方式与 Kubernetes 一起运行。
<a href=https://portworx.com/use-case/kubernetes-storage/>Portworx</a>
支持对服务器上存储的指纹处理、基于存储能力进行分层以及跨多个服务器整合存储容量。
Portworx 可以以 in-guest 方式在虚拟机中运行，也可以在裸金属 Linux 节点上运行。</p><p><code>portworxVolume</code> 类型的卷可以通过 Kubernetes 动态创建，也可以预先配备并在 Pod 内引用。
下面是一个引用预先配备的 Portworx 卷的示例 Pod：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-portworx-volume-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>registry.k8s.io/test-webserver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/mnt<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pxvol<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pxvol<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 此 Portworx 卷必须已经存在</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>portworxVolume</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeID</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;pxvol&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>fsType</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&lt;fs-type&gt;&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>在 Pod 中使用 portworxVolume 之前，你要确保有一个名为 <code>pxvol</code> 的 PortworxVolume 存在。</div><p>更多详情可以参考 <a href=https://github.com/kubernetes/examples/tree/master/staging/volumes/portworx/README.md>Portworx 卷</a>。</p><h4 id=portworx-csi-迁移>Portworx CSI 迁移</h4><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.25 [beta]</code></div><p>已针对 Portworx 添加 <code>CSIMigration</code> 特性，但在 Kubernetes 1.23 中默认禁用，因为它处于 Alpha 状态。
自 v1.25 以来它已进入 Beta 阶段，但默认仍关闭。
它将所有插件操作不再指向树内插件（In-Tree Plugin），转而指向
<code>pxd.portworx.com</code> 容器存储接口（Container Storage Interface，CSI）驱动。
<a href=https://docs.portworx.com/portworx-install-with-kubernetes/storage-operations/csi/>Portworx CSI 驱动程序</a>必须安装在集群上。
要启用此特性，需在 kube-controller-manager 和 kubelet 中设置 <code>CSIMigrationPortworx=true</code>。</p><h3 id=projected>projected （投射）</h3><p>投射卷能将若干现有的卷来源映射到同一目录上。更多详情请参考<a href=/zh-cn/docs/concepts/storage/projected-volumes/>投射卷</a>。</p><h3 id=rbd>rbd</h3><p><code>rbd</code> 卷允许将 <a href=https://docs.ceph.com/en/latest/rbd/>Rados 块设备</a>卷挂载到你的 Pod 中。
不像 <code>emptyDir</code> 那样会在删除 Pod 的同时也会被删除，<code>rbd</code> 卷的内容在删除 Pod 时会被保存，卷只是被卸载。
这意味着 <code>rbd</code> 卷可以被预先填充数据，并且这些数据可以在 Pod 之间共享。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>在使用 RBD 之前，你必须安装运行 Ceph。</div><p>RBD 的一个特性是它可以同时被多个用户以只读方式挂载。
这意味着你可以用数据集预先填充卷，然后根据需要在尽可能多的 Pod 中并行地使用卷。
不幸的是，RBD 卷只能由单个使用者以读写模式安装。不允许同时写入。</p><p>更多详情请参考
<a href=https://github.com/kubernetes/examples/tree/master/volumes/rbd>RBD 示例</a>。</p><h4 id=rbd-csi-migration>RBD CSI 迁移</h4><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.23 [alpha]</code></div><p>启用 RBD 的 <code>CSIMigration</code> 特性后，所有插件操作从现有的树内插件重定向到
<code>rbd.csi.ceph.com</code> <a class=glossary-tooltip title='容器存储接口 （CSI）定义了存储系统暴露给容器的标准接口。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/storage/volumes/#csi target=_blank aria-label=CSI>CSI</a> 驱动程序。
要使用该特性，必须在集群内安装
<a href=https://github.com/ceph/ceph-csi>Ceph CSI 驱动</a>，并启用 <code>csiMigrationRBD</code>
<a href=/zh-cn/docs/reference/command-line-tools-reference/feature-gates/>特性门控</a>。
（请注意，<code>csiMigrationRBD</code> 标志已在 v1.24 版本中移除且替换为 <code>CSIMigrationRBD</code>。）</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>作为一位管理存储的 Kubernetes 集群操作者，在尝试迁移到 RBD CSI 驱动前，你必须完成下列先决事项：</p><ul><li>你必须在集群中安装 v3.5.0 或更高版本的 Ceph CSI 驱动（<code>rbd.csi.ceph.com</code>）。</li><li>因为 <code>clusterID</code> 是 CSI 驱动程序必需的参数，而树内存储类又将 <code>monitors</code>
作为一个必需的参数，所以 Kubernetes 存储管理者需要根据 <code>monitors</code>
的哈希值（例：<code>#echo -n '&lt;monitors_string>' | md5sum</code>）来创建
<code>clusterID</code>，并保持该 <code>monitors</code> 存在于该 <code>clusterID</code> 的配置中。</li><li>同时，如果树内存储类的 <code>adminId</code> 的值不是 <code>admin</code>，那么其 <code>adminSecretName</code>
就需要被修改成 <code>adminId</code> 参数的 base64 编码值。</li></ul></div><h3 id=secret>secret</h3><p><code>secret</code> 卷用来给 Pod 传递敏感信息，例如密码。你可以将 Secret 存储在 Kubernetes
API 服务器上，然后以文件的形式挂载到 Pod 中，无需直接与 Kubernetes 耦合。
<code>secret</code> 卷由 tmpfs（基于 RAM 的文件系统）提供存储，因此它们永远不会被写入非易失性（持久化的）存储器。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>使用前你必须在 Kubernetes API 中创建 Secret。</div><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>容器以 <a href=#using-subpath><code>subPath</code></a> 卷挂载方式挂载 Secret 时，将感知不到 Secret 的更新。</div><p>更多详情请参考<a href=/zh-cn/docs/concepts/configuration/secret/>配置 Secrets</a>。</p><h3 id=vspherevolume>vsphereVolume（已弃用）</h3><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>建议你改用 vSphere CSI 树外驱动程序。</div><p><code>vsphereVolume</code> 用来将 vSphere VMDK 卷挂载到你的 Pod 中。
在卸载卷时，卷的内容会被保留。
vSphereVolume 卷类型支持 VMFS 和 VSAN 数据仓库。</p><p>进一步信息可参考
<a href=https://github.com/kubernetes/examples/tree/master/staging/volumes/vsphere>vSphere 卷</a>。</p><h4 id=vsphere-csi-migration>vSphere CSI 迁移</h4><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.19 [beta]</code></div><p>从 Kubernetes v1.25 开始，针对 <code>vsphereVolume</code> 的 <code>CSIMigrationvSphere</code> 特性默认被启用。
来自树内 <code>vspherevolume</code> 的所有插件操作将被重新指向到
<code>csi.vsphere.vmware.com</code> <a class=glossary-tooltip title='容器存储接口 （CSI）定义了存储系统暴露给容器的标准接口。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/storage/volumes/#csi target=_blank aria-label=CSI>CSI</a> 驱动，
除非 <code>CSIMigrationvSphere</code> 特性门控被禁用。</p><p><a href=https://github.com/kubernetes-sigs/vsphere-csi-driver>vSphere CSI 驱动</a>必须安装到集群上。
你可以在 VMware 的文档页面<a href=https://docs.vmware.com/en/VMware-vSphere-Container-Storage-Plug-in/2.0/vmware-vsphere-csp-getting-started/GUID-968D421F-D464-4E22-8127-6CB9FF54423F.html>迁移树内 vSphere 卷插件到 vSphere 容器存储插件</a>
中找到有关如何迁移树内 <code>vsphereVolume</code> 的其他建议。</p><p>从 Kubernetes v1.25 开始，（已弃用）树内 vSphere 存储驱动不支持低于 7.0u2 的 vSphere 版本。
你必须运行 vSphere 7.0u2 或更高版本才能继续使用这个已弃用的驱动，或迁移到替代的 CSI 驱动。</p><p>如果你正在运行 Kubernetes v1.25，请查阅该 Kubernetes 版本的文档。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>vSphere CSI 驱动不支持内置 <code>vsphereVolume</code> 的以下 StorageClass 参数：</p><ul><li><code>diskformat</code></li><li><code>hostfailurestotolerate</code></li><li><code>forceprovisioning</code></li><li><code>cachereservation</code></li><li><code>diskstripes</code></li><li><code>objectspacereservation</code></li><li><code>iopslimit</code></li></ul><p>使用这些参数创建的现有卷将被迁移到 vSphere CSI 驱动，不过使用 vSphere
CSI 驱动所创建的新卷都不会理会这些参数。</p></div><h4 id=vsphere-csi-migration-complete>vSphere CSI 迁移完成</h4><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.19 [beta]</code></div><p>为了避免控制器管理器和 kubelet 加载 <code>vsphereVolume</code> 插件，你需要将
<code>InTreePluginvSphereUnregister</code> 特性设置为 <code>true</code>。你还必须在所有工作节点上安装
<code>csi.vsphere.vmware.com</code> <a class=glossary-tooltip title='容器存储接口 （CSI）定义了存储系统暴露给容器的标准接口。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/storage/volumes/#csi target=_blank aria-label=CSI>CSI</a> 驱动。</p><h2 id=using-subpath>使用 subPath</h2><p>有时，在单个 Pod 中共享卷以供多方使用是很有用的。
<code>volumeMounts.subPath</code> 属性可用于指定所引用的卷内的子路径，而不是其根路径。</p><p>下面例子展示了如何配置某包含 LAMP 堆栈（Linux Apache MySQL PHP）的 Pod 使用同一共享卷。
此示例中的 <code>subPath</code> 配置不建议在生产环境中使用。
PHP 应用的代码和相关数据映射到卷的 <code>html</code> 文件夹，MySQL 数据库存储在卷的 <code>mysql</code> 文件夹中：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-lamp-site<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MYSQL_ROOT_PASSWORD<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;rootpasswd&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/lib/mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>site-data<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>subPath</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>php<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>php:7.0-apache<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/var/www/html<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>site-data<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>subPath</span>:<span style=color:#bbb> </span>html<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>site-data<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>persistentVolumeClaim</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>claimName</span>:<span style=color:#bbb> </span>my-lamp-site-data<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=using-subpath-expanded-environment>使用带有扩展环境变量的 subPath</h3><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.17 [stable]</code></div><p>使用 <code>subPathExpr</code> 字段可以基于 downward API 环境变量来构造 <code>subPath</code> 目录名。
<code>subPath</code> 和 <code>subPathExpr</code> 属性是互斥的。</p><p>在这个示例中，<code>Pod</code> 使用 <code>subPathExpr</code> 来 <code>hostPath</code> 卷 <code>/var/log/pods</code> 中创建目录 <code>pod1</code>。
<code>hostPath</code> 卷采用来自 <code>downwardAPI</code> 的 Pod 名称生成目录名。
宿主目录 <code>/var/log/pods/pod1</code> 被挂载到容器的 <code>/logs</code> 中。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pod1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>container1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>POD_NAME<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>fieldRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>fieldPath</span>:<span style=color:#bbb> </span>metadata.name<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;while [ true ]; do echo &#39;Hello&#39;; sleep 10; done | tee -a /logs/hello.txt&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>workdir1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/logs<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 包裹变量名的是小括号，而不是大括号</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>subPathExpr</span>:<span style=color:#bbb> </span>$(POD_NAME)<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>workdir1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/var/log/pods<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=resources>资源</h2><p><code>emptyDir</code> 卷的存储介质（例如磁盘、SSD 等）是由保存 kubelet
数据的根目录（通常是 <code>/var/lib/kubelet</code>）的文件系统的介质确定。
Kubernetes 对 <code>emptyDir</code> 卷或者 <code>hostPath</code> 卷可以消耗的空间没有限制，容器之间或 Pod 之间也没有隔离。</p><p>要了解如何使用资源规约来请求空间，
可参考<a href=/zh-cn/docs/concepts/configuration/manage-resources-containers/>如何管理资源</a>。</p><h2 id=out-of-tree-volume-plugins>树外（Out-of-Tree）卷插件</h2><p>Out-of-Tree 卷插件包括<a class=glossary-tooltip title='容器存储接口 （CSI）定义了存储系统暴露给容器的标准接口。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/storage/volumes/#csi target=_blank aria-label=容器存储接口（CSI）>容器存储接口（CSI）</a>和
FlexVolume（已弃用）。它们使存储供应商能够创建自定义存储插件，而无需将插件源码添加到
Kubernetes 代码仓库。</p><p>以前，所有卷插件（如上面列出的卷类型）都是“树内（In-Tree）”的。
“树内”插件是与 Kubernetes 的核心组件一同构建、链接、编译和交付的。
这意味着向 Kubernetes 添加新的存储系统（卷插件）需要将代码合并到 Kubernetes 核心代码库中。</p><p>CSI 和 FlexVolume 都允许独立于 Kubernetes 代码库开发卷插件，并作为扩展部署（安装）在 Kubernetes 集群上。</p><p>对于希望创建树外（Out-Of-Tree）卷插件的存储供应商，请参考
<a href=https://github.com/kubernetes/community/blob/master/sig-storage/volume-plugin-faq.md>卷插件常见问题</a>。</p><h3 id=csi>CSI</h3><p><a href=https://github.com/container-storage-interface/spec/blob/master/spec.md>容器存储接口</a> (CSI)
为容器编排系统（如 Kubernetes）定义标准接口，以将任意存储系统暴露给它们的容器工作负载。</p><p>更多详情请阅读 <a href=https://git.k8s.io/design-proposals-archive/storage/container-storage-interface.md>CSI 设计方案</a>。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>Kubernetes v1.13 废弃了对 CSI 规范版本 0.2 和 0.3 的支持，并将在以后的版本中删除。</div><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>CSI 驱动可能并非兼容所有的 Kubernetes 版本。
请查看特定 CSI 驱动的文档，以了解各个 Kubernetes 版本所支持的部署步骤以及兼容性列表。</div><p>一旦在 Kubernetes 集群上部署了 CSI 兼容卷驱动程序，用户就可以使用
<code>csi</code> 卷类型来挂接、挂载 CSI 驱动所提供的卷。</p><p><code>csi</code> 卷可以在 Pod 中以三种方式使用：</p><ul><li>通过 PersistentVolumeClaim(#persistentvolumeclaim) 对象引用</li><li>使用<a href=/zh-cn/docs/concepts/storage/ephemeral-volumes/#generic-ephemeral-volumes>一般性的临时卷</a></li><li>使用 <a href=/zh-cn/docs/concepts/storage/ephemeral-volumes/#csi-ephemeral-volumes>CSI 临时卷</a>，
前提是驱动支持这种用法</li></ul><p>存储管理员可以使用以下字段来配置 CSI 持久卷：</p><ul><li><code>driver</code>：指定要使用的卷驱动名称的字符串值。
这个值必须与 CSI 驱动程序在 <code>GetPluginInfoResponse</code> 中返回的值相对应；该接口定义在
<a href=https://github.com/container-storage-interface/spec/blob/master/spec.md#getplugininfo>CSI 规范</a>中。
Kubernetes 使用所给的值来标识要调用的 CSI 驱动程序；CSI
驱动程序也使用该值来辨识哪些 PV 对象属于该 CSI 驱动程序。</li></ul><ul><li><code>volumeHandle</code>：唯一标识卷的字符串值。
该值必须与 CSI 驱动在 <code>CreateVolumeResponse</code> 的 <code>volume_id</code> 字段中返回的值相对应；接口定义在
<a href=https://github.com/container-storage-interface/spec/blob/master/spec.md#createvolume>CSI 规范</a> 中。
在所有对 CSI 卷驱动程序的调用中，引用该 CSI 卷时都使用此值作为 <code>volume_id</code> 参数。</li></ul><ul><li><code>readOnly</code>：一个可选的布尔值，指示通过 <code>ControllerPublished</code> 关联该卷时是否设置该卷为只读。默认值是 false。
该值通过 <code>ControllerPublishVolumeRequest</code> 中的 <code>readonly</code> 字段传递给 CSI 驱动。</li></ul><ul><li><code>fsType</code>：如果 PV 的 <code>VolumeMode</code> 为 <code>Filesystem</code>，那么此字段指定挂载卷时应该使用的文件系统。
如果卷尚未格式化，并且支持格式化，此值将用于格式化卷。
此值可以通过 <code>ControllerPublishVolumeRequest</code>、<code>NodeStageVolumeRequest</code> 和
<code>NodePublishVolumeRequest</code> 的 <code>VolumeCapability</code> 字段传递给 CSI 驱动。</li></ul><ul><li><code>volumeAttributes</code>：一个字符串到字符串的映射表，用来设置卷的静态属性。
该映射必须与 CSI 驱动程序返回的 <code>CreateVolumeResponse</code> 中的 <code>volume.attributes</code>
字段的映射相对应；
<a href=https://github.com/container-storage-interface/spec/blob/master/spec.md#createvolume>CSI 规范</a>中有相应的定义。
该映射通过<code>ControllerPublishVolumeRequest</code>、<code>NodeStageVolumeRequest</code>、和
<code>NodePublishVolumeRequest</code> 中的 <code>volume_context</code> 字段传递给 CSI 驱动。</li></ul><ul><li><code>controllerPublishSecretRef</code>：对包含敏感信息的 Secret 对象的引用；
该敏感信息会被传递给 CSI 驱动来完成 CSI <code>ControllerPublishVolume</code> 和
<code>ControllerUnpublishVolume</code> 调用。
此字段是可选的；在不需要 Secret 时可以是空的。
如果 Secret 包含多个 Secret 条目，则所有的 Secret 条目都会被传递。</li></ul><ul><li><code>nodeExpandSecretRef</code>：对包含敏感信息的 Secret 对象的引用，
该信息会传递给 CSI 驱动以完成 CSI <code>NodeExpandVolume</code> 调用。
此字段是可选的，如果不需要 Secret，则可能是空的。
如果 Secret 包含多个 Secret 条目，则传递所有 Secret 条目。
当你为节点初始化的卷扩展配置 Secret 数据时，kubelet 会通过 <code>NodeExpandVolume()</code> 调用将该数据传递给 CSI 驱动。
为了使用 <code>nodeExpandSecretRef</code> 字段，你的集群应运行 Kubernetes 1.25 或更高版本，
并且你必须为每个 kube-apiserver 和每个节点上的 kubelet 启用名为 <code>CSINodeExpandSecret</code>
的<a href=/zh-cn/docs/reference/command-line-tools-reference/feature-gates/>特性门控</a>。
在节点初始化的存储大小调整操作期间，你还必须使用支持或需要 Secret 数据的 CSI 驱动。</li></ul><ul><li><code>nodePublishSecretRef</code>：对包含敏感信息的 Secret 对象的引用。
该信息传递给 CSI 驱动来完成 CSI <code>NodePublishVolume</code> 调用。
此字段是可选的，如果不需要 Secret，则可能是空的。
如果 Secret 对象包含多个 Secret 条目，则传递所有 Secret 条目。</li></ul><ul><li><code>nodeStageSecretRef</code>：对包含敏感信息的 Secret 对象的引用，
该信息会传递给 CSI 驱动以完成 CSI <code>NodeStageVolume</code> 调用。
此字段是可选的，如果不需要 Secret，则可能是空的。
如果 Secret 包含多个 Secret 条目，则传递所有 Secret 条目。</li></ul><h4 id=csi-raw-block-volume-support>CSI 原始块卷支持</h4><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.18 [stable]</code></div><p>具有外部 CSI 驱动程序的供应商能够在 Kubernetes 工作负载中实现原始块卷支持。</p><p>你可以和以前一样，
安装自己的<a href=/zh-cn/docs/concepts/storage/persistent-volumes/#raw-block-volume-support>带有原始块卷支持的 PV/PVC</a>，
采用 CSI 对此过程没有影响。</p><h4 id=csi-ephemeral-volumes>CSI 临时卷</h4><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.25 [stable]</code></div><p>你可以直接在 Pod 规约中配置 CSI 卷。采用这种方式配置的卷都是临时卷，
无法在 Pod 重新启动后继续存在。
进一步的信息可参阅<a href=/zh-cn/docs/concepts/storage/ephemeral-volumes/#csi-ephemeral-volumes>临时卷</a>。</p><p>有关如何开发 CSI 驱动的更多信息，请参考 <a href=https://kubernetes-csi.github.io/docs/>kubernetes-csi 文档</a>。</p><h4 id=windows-csi-proxy>Windows CSI 代理</h4><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.22 [stable]</code></div><p>CSI 节点插件需要执行多种特权操作，例如扫描磁盘设备和挂载文件系统等。
这些操作在每个宿主操作系统上都是不同的。对于 Linux 工作节点而言，容器化的 CSI
节点插件通常部署为特权容器。对于 Windows 工作节点而言，容器化 CSI
节点插件的特权操作是通过 <a href=https://github.com/kubernetes-csi/csi-proxy>csi-proxy</a>
来支持的。csi-proxy 是一个由社区管理的、独立的可执行二进制文件，
需要被预安装到每个 Windows 节点上。</p><p>要了解更多的细节，可以参考你要部署的 CSI 插件的部署指南。</p><h4 id=migrating-to-csi-drivers-from-in-tree-plugins>从树内插件迁移到 CSI 驱动程序</h4><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.25 [stable]</code></div><p><code>CSIMigration</code> 特性针对现有树内插件的操作会被定向到相应的 CSI 插件（应已安装和配置）。
因此，操作员在过渡到取代树内插件的 CSI 驱动时，无需对现有存储类、PV 或 PVC（指树内插件）进行任何配置更改。</p><p>所支持的操作和特性包括：配备（Provisioning）/删除、挂接（Attach）/解挂（Detach）、
挂载（Mount）/卸载（Unmount）和调整卷大小。</p><p>上面的<a href=#volume-types>卷类型</a>节列出了支持 <code>CSIMigration</code> 并已实现相应 CSI
驱动程序的树内插件。</p><p>下面是支持 Windows 节点上持久性存储的树内插件：</p><ul><li><a href=#awselasticblockstore><code>awsElasticBlockStore</code></a></li><li><a href=#azuredisk><code>azureDisk</code></a></li><li><a href=#azurefile><code>azureFile</code></a></li><li><a href=#gcepersistentdisk><code>gcePersistentDisk</code></a></li><li><a href=#vspherevolume><code>vsphereVolume</code></a></li></ul><h3 id=flexvolume>flexVolume（已弃用）</h3><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.23 [deprecated]</code></div><p>FlexVolume 是一个使用基于 exec 的模型来与驱动程序对接的树外插件接口。
用户必须在每个节点上的预定义卷插件路径中安装 FlexVolume
驱动程序可执行文件，在某些情况下，控制平面节点中也要安装。</p><p>Pod 通过 <code>flexvolume</code> 树内插件与 FlexVolume 驱动程序交互。
更多详情请参考 FlexVolume <a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-storage/flexvolume.md#readme>README</a> 文档。</p><p>下面的 FlexVolume <a href=https://github.com/Microsoft/K8s-Storage-Plugins/tree/master/flexvolume/windows>插件</a>
以 PowerShell 脚本的形式部署在宿主系统上，支持 Windows 节点：</p><ul><li><a href=https://github.com/microsoft/K8s-Storage-Plugins/tree/master/flexvolume/windows/plugins/microsoft.com~smb.cmd>SMB</a></li><li><a href=https://github.com/microsoft/K8s-Storage-Plugins/tree/master/flexvolume/windows/plugins/microsoft.com~iscsi.cmd>iSCSI</a></li></ul><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>FlexVolume 已被弃用。推荐使用树外 CSI 驱动来将外部存储整合进 Kubernetes。</p><p>FlexVolume 驱动的维护者应开发一个 CSI 驱动并帮助用户从 FlexVolume 驱动迁移到 CSI。
FlexVolume 用户应迁移工作负载以使用对等的 CSI 驱动。</p></div><h2 id=mount-propagation>挂载卷的传播</h2><p>挂载卷的传播能力允许将容器安装的卷共享到同一 Pod 中的其他容器，甚至共享到同一节点上的其他 Pod。</p><p>卷的挂载传播特性由 <code>Container.volumeMounts</code> 中的 <code>mountPropagation</code> 字段控制。
它的值包括：</p><ul><li><p><code>None</code> - 此卷挂载将不会感知到主机后续在此卷或其任何子目录上执行的挂载变化。
类似的，容器所创建的卷挂载在主机上是不可见的。这是默认模式。</p><p>该模式等同于 <a href=https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt>Linux 内核文档</a>中描述的
<code>private</code> 挂载传播选项。</p></li></ul><ul><li><p><code>HostToContainer</code> - 此卷挂载将会感知到主机后续针对此卷或其任何子目录的挂载操作。</p><p>换句话说，如果主机在此挂载卷中挂载任何内容，容器将能看到它被挂载在那里。</p><p>类似的，配置了 <code>Bidirectional</code> 挂载传播选项的 Pod 如果在同一卷上挂载了内容，挂载传播设置为
<code>HostToContainer</code> 的容器都将能看到这一变化。</p><p>该模式等同于 <a href=https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt>Linux 内核文档</a>中描述的
<code>rslave</code> 挂载传播选项。</p></li></ul><ul><li><p><code>Bidirectional</code> - 这种卷挂载和 <code>HostToContainer</code> 挂载表现相同。
另外，容器创建的卷挂载将被传播回至主机和使用同一卷的所有 Pod 的所有容器。</p><p>该模式等同于 <a href=https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt>Linux 内核文档</a>中描述的
<code>rshared</code> 挂载传播选项。</p><div class="alert alert-danger warning callout" role=alert><strong>警告：</strong><p><code>Bidirectional</code> 形式的挂载传播可能比较危险。
它可以破坏主机操作系统，因此它只被允许在特权容器中使用。
强烈建议你熟悉 Linux 内核行为。
此外，由 Pod 中的容器创建的任何卷挂载必须在终止时由容器销毁（卸载）。</div></li></ul><h3 id=configuration>配置</h3><p>在某些部署环境中，挂载传播正常工作前，必须在 Docker 中正确配置挂载共享（mount share），如下所示。</p><p>编辑你的 Docker <code>systemd</code> 服务文件，按下面的方法设置 <code>MountFlags</code>：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#b8860b>MountFlags</span><span style=color:#666>=</span>shared
</span></span></code></pre></div><p>或者，如果存在 <code>MountFlags=slave</code> 就删除掉。然后重启 Docker 守护进程：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sudo systemctl daemon-reload
</span></span><span style=display:flex><span>sudo systemctl restart docker
</span></span></code></pre></div><h2 id=接下来>接下来</h2><p>参考<a href=/zh-cn/docs/tutorials/stateful-application/mysql-wordpress-persistent-volume/>使用持久卷部署 WordPress 和 MySQL</a> 示例。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-ffd12528a12882b282e1bd19e29f9e75>2 - 持久卷</h1><p>本文描述 Kubernetes 中的<strong>持久卷（Persistent Volume）</strong> 。
建议先熟悉<a href=/zh-cn/docs/concepts/storage/volumes/>卷（Volume）</a>的概念。</p><h2 id=introduction>介绍</h2><p>存储的管理是一个与计算实例的管理完全不同的问题。
PersistentVolume 子系统为用户和管理员提供了一组 API，
将存储如何制备的细节从其如何被使用中抽象出来。
为了实现这点，我们引入了两个新的 API 资源：PersistentVolume 和
PersistentVolumeClaim。</p><p><strong>持久卷（PersistentVolume，PV）</strong> 是集群中的一块存储，可以由管理员事先制备，
或者使用<a href=/zh-cn/docs/concepts/storage/storage-classes/>存储类（Storage Class）</a>来动态制备。
持久卷是集群资源，就像节点也是集群资源一样。PV 持久卷和普通的 Volume 一样，
也是使用卷插件来实现的，只是它们拥有独立于任何使用 PV 的 Pod 的生命周期。
此 API 对象中记述了存储的实现细节，无论其背后是 NFS、iSCSI 还是特定于云平台的存储系统。</p><p><strong>持久卷申领（PersistentVolumeClaim，PVC）</strong> 表达的是用户对存储的请求。概念上与 Pod 类似。
Pod 会耗用节点资源，而 PVC 申领会耗用 PV 资源。Pod 可以请求特定数量的资源（CPU
和内存）；同样 PVC 申领也可以请求特定的大小和访问模式
（例如，可以要求 PV 卷能够以 ReadWriteOnce、ReadOnlyMany 或 ReadWriteMany
模式之一来挂载，参见<a href=#access-modes>访问模式</a>）。</p><p>尽管 PersistentVolumeClaim 允许用户消耗抽象的存储资源，
常见的情况是针对不同的问题用户需要的是具有不同属性（如，性能）的 PersistentVolume 卷。
集群管理员需要能够提供不同性质的 PersistentVolume，
并且这些 PV 卷之间的差别不仅限于卷大小和访问模式，同时又不能将卷是如何实现的这些细节暴露给用户。
为了满足这类需求，就有了<strong>存储类（StorageClass）</strong> 资源。</p><p>参见<a href=/zh-cn/docs/tasks/configure-pod-container/configure-persistent-volume-storage/>基于运行示例的详细演练</a>。</p><h2 id=lifecycle-of-a-volume-and-claim>卷和申领的生命周期</h2><p>PV 卷是集群中的资源。PVC 申领是对这些资源的请求，也被用来执行对资源的申领检查。
PV 卷和 PVC 申领之间的互动遵循如下生命周期：</p><h3 id=provisioning>制备</h3><p>PV 卷的制备有两种方式：静态制备或动态制备。</p><h4 id=static>静态制备</h4><p>集群管理员创建若干 PV 卷。这些卷对象带有真实存储的细节信息，
并且对集群用户可用（可见）。PV 卷对象存在于 Kubernetes API 中，可供用户消费（使用）。</p><h4 id=dynamic>动态制备</h4><p>如果管理员所创建的所有静态 PV 卷都无法与用户的 PersistentVolumeClaim 匹配，
集群可以尝试为该 PVC 申领动态制备一个存储卷。
这一制备操作是基于 StorageClass 来实现的：PVC 申领必须请求某个
<a href=/zh-cn/docs/concepts/storage/storage-classes/>存储类</a>，
同时集群管理员必须已经创建并配置了该类，这样动态制备卷的动作才会发生。
如果 PVC 申领指定存储类为 <code>""</code>，则相当于为自身禁止使用动态制备的卷。</p><p>为了基于存储类完成动态的存储制备，集群管理员需要在 API 服务器上启用
<code>DefaultStorageClass</code> <a href=/zh-cn/docs/reference/access-authn-authz/admission-controllers/#defaultstorageclass>准入控制器</a>。
举例而言，可以通过保证 <code>DefaultStorageClass</code> 出现在 API 服务器组件的
<code>--enable-admission-plugins</code> 标志值中实现这点；该标志的值可以是逗号分隔的有序列表。
关于 API 服务器标志的更多信息，可以参考
<a href=/zh-cn/docs/reference/command-line-tools-reference/kube-apiserver/>kube-apiserver</a>
文档。</p><h3 id=binding>绑定</h3><p>用户创建一个带有特定存储容量和特定访问模式需求的 PersistentVolumeClaim 对象；
在动态制备场景下，这个 PVC 对象可能已经创建完毕。
主控节点中的控制回路监测新的 PVC 对象，寻找与之匹配的 PV 卷（如果可能的话），
并将二者绑定到一起。
如果为了新的 PVC 申领动态制备了 PV 卷，则控制回路总是将该 PV 卷绑定到这一 PVC 申领。
否则，用户总是能够获得他们所请求的资源，只是所获得的 PV 卷可能会超出所请求的配置。
一旦绑定关系建立，则 PersistentVolumeClaim 绑定就是排他性的，
无论该 PVC 申领是如何与 PV 卷建立的绑定关系。
PVC 申领与 PV 卷之间的绑定是一种一对一的映射，实现上使用 ClaimRef 来记述
PV 卷与 PVC 申领间的双向绑定关系。</p><p>如果找不到匹配的 PV 卷，PVC 申领会无限期地处于未绑定状态。
当与之匹配的 PV 卷可用时，PVC 申领会被绑定。
例如，即使某集群上制备了很多 50 Gi 大小的 PV 卷，也无法与请求
100 Gi 大小的存储的 PVC 匹配。当新的 100 Gi PV 卷被加入到集群时，
该 PVC 才有可能被绑定。</p><h3 id=using>使用</h3><p>Pod 将 PVC 申领当做存储卷来使用。集群会检视 PVC 申领，找到所绑定的卷，
并为 Pod 挂载该卷。对于支持多种访问模式的卷，
用户要在 Pod 中以卷的形式使用申领时指定期望的访问模式。</p><p>一旦用户有了申领对象并且该申领已经被绑定，
则所绑定的 PV 卷在用户仍然需要它期间一直属于该用户。
用户通过在 Pod 的 <code>volumes</code> 块中包含 <code>persistentVolumeClaim</code>
节区来调度 Pod，访问所申领的 PV 卷。
相关细节可参阅<a href=#claims-as-volumes>使用申领作为卷</a>。</p><h3 id=storage-object-in-use-protection>保护使用中的存储对象</h3><p>保护使用中的存储对象（Storage Object in Use Protection）
这一功能特性的目的是确保仍被 Pod 使用的 PersistentVolumeClaim（PVC）
对象及其所绑定的 PersistentVolume（PV）对象在系统中不会被删除，因为这样做可能会引起数据丢失。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong> 当使用某 PVC 的 Pod 对象仍然存在时，认为该 PVC 仍被此 Pod 使用。</div><p>如果用户删除被某 Pod 使用的 PVC 对象，该 PVC 申领不会被立即移除。
PVC 对象的移除会被推迟，直至其不再被任何 Pod 使用。
此外，如果管理员删除已绑定到某 PVC 申领的 PV 卷，该 PV 卷也不会被立即移除。
PV 对象的移除也要推迟到该 PV 不再绑定到 PVC。</p><p>你可以看到当 PVC 的状态为 <code>Terminating</code> 且其 <code>Finalizers</code> 列表中包含
<code>kubernetes.io/pvc-protection</code> 时，PVC 对象是处于被保护状态的。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe pvc hostpath
</span></span></code></pre></div><pre tabindex=0><code>Name:          hostpath
Namespace:     default
StorageClass:  example-hostpath
Status:        Terminating
Volume:
Labels:        &lt;none&gt;
Annotations:   volume.beta.kubernetes.io/storage-class=example-hostpath
               volume.beta.kubernetes.io/storage-provisioner=example.com/hostpath
Finalizers:    [kubernetes.io/pvc-protection]
...
</code></pre><p>你也可以看到当 PV 对象的状态为 <code>Terminating</code> 且其 <code>Finalizers</code> 列表中包含
<code>kubernetes.io/pv-protection</code> 时，PV 对象是处于被保护状态的。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe pv task-pv-volume
</span></span></code></pre></div><pre tabindex=0><code>Name:            task-pv-volume
Labels:          type=local
Annotations:     &lt;none&gt;
Finalizers:      [kubernetes.io/pv-protection]
StorageClass:    standard
Status:          Terminating
Claim:
Reclaim Policy:  Delete
Access Modes:    RWO
Capacity:        1Gi
Message:
Source:
    Type:          HostPath (bare host directory volume)
    Path:          /tmp/data
    HostPathType:
Events:            &lt;none&gt;
</code></pre><h3 id=reclaiming>回收（Reclaiming）</h3><p>当用户不再使用其存储卷时，他们可以从 API 中将 PVC 对象删除，
从而允许该资源被回收再利用。PersistentVolume 对象的回收策略告诉集群，
当其被从申领中释放时如何处理该数据卷。
目前，数据卷可以被 Retained（保留）、Recycled（回收）或 Deleted（删除）。</p><h4 id=retain>保留（Retain）</h4><p>回收策略 <code>Retain</code> 使得用户可以手动回收资源。当 PersistentVolumeClaim
对象被删除时，PersistentVolume 卷仍然存在，对应的数据卷被视为"已释放（released）"。
由于卷上仍然存在这前一申领人的数据，该卷还不能用于其他申领。
管理员可以通过下面的步骤来手动回收该卷：</p><ol><li>删除 PersistentVolume 对象。与之相关的、位于外部基础设施中的存储资产
（例如 AWS EBS、GCE PD、Azure Disk 或 Cinder 卷）在 PV 删除之后仍然存在。</li><li>根据情况，手动清除所关联的存储资产上的数据。</li><li>手动删除所关联的存储资产。</li></ol><p>如果你希望重用该存储资产，可以基于存储资产的定义创建新的 PersistentVolume 卷对象。</p><h4 id=delete>删除（Delete）</h4><p>对于支持 <code>Delete</code> 回收策略的卷插件，删除动作会将 PersistentVolume 对象从
Kubernetes 中移除，同时也会从外部基础设施（如 AWS EBS、GCE PD、Azure Disk 或
Cinder 卷）中移除所关联的存储资产。
动态制备的卷会继承<a href=#reclaim-policy>其 StorageClass 中设置的回收策略</a>，
该策略默认为 <code>Delete</code>。管理员需要根据用户的期望来配置 StorageClass；
否则 PV 卷被创建之后必须要被编辑或者修补。
参阅<a href=/zh-cn/docs/tasks/administer-cluster/change-pv-reclaim-policy/>更改 PV 卷的回收策略</a>。</p><h4 id=recycle>回收（Recycle）</h4><div class="alert alert-danger warning callout" role=alert><strong>警告：</strong> 回收策略 <code>Recycle</code> 已被废弃。取而代之的建议方案是使用动态制备。</div><p>如果下层的卷插件支持，回收策略 <code>Recycle</code> 会在卷上执行一些基本的擦除
（<code>rm -rf /thevolume/*</code>）操作，之后允许该卷用于新的 PVC 申领。</p><p>不过，管理员可以按
<a href=/zh-cn/docs/reference/command-line-tools-reference/kube-controller-manager/>参考资料</a>
中所述，使用 Kubernetes 控制器管理器命令行参数来配置一个定制的回收器（Recycler）
Pod 模板。此定制的回收器 Pod 模板必须包含一个 <code>volumes</code> 规约，如下例所示：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pv-recycler<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>vol<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>hostPath</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/any/path/it/will/be/replaced<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pv-recycler<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;registry.k8s.io/busybox&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;/bin/sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;test -e /scrub &amp;&amp; rm -rf /scrub/..?* /scrub/.[!.]* /scrub/*  &amp;&amp; test -z \&#34;$(ls -A /scrub)\&#34; || exit 1&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>vol<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span>/scrub<span style=color:#bbb>
</span></span></span></code></pre></div><p>定制回收器 Pod 模板中在 <code>volumes</code> 部分所指定的特定路径要替换为正被回收的卷的路径。</p><h3 id=persistentvolume-deletion-protection-finalizer>PersistentVolume 删除保护 finalizer</h3><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.23 [alpha]</code></div><p>可以在 PersistentVolume 上添加终结器（Finalizer），
以确保只有在删除对应的存储后才删除具有 <code>Delete</code> 回收策略的 PersistentVolume。</p><p>新引入的 <code>kubernetes.io/pv-controller</code> 和 <code>external-provisioner.volume.kubernetes.io/finalizer</code>
终结器仅会被添加到动态制备的卷上。</p><p>终结器 <code>kubernetes.io/pv-controller</code> 会被添加到树内插件卷上。
下面是一个例子：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe pv pvc-74a498d6-3929-47e8-8c02-078c1ece4d78
</span></span><span style=display:flex><span>Name:            pvc-74a498d6-3929-47e8-8c02-078c1ece4d78
</span></span><span style=display:flex><span>Labels:          &lt;none&gt;
</span></span><span style=display:flex><span>Annotations:     kubernetes.io/createdby: vsphere-volume-dynamic-provisioner
</span></span><span style=display:flex><span>                 pv.kubernetes.io/bound-by-controller: yes
</span></span><span style=display:flex><span>                 pv.kubernetes.io/provisioned-by: kubernetes.io/vsphere-volume
</span></span><span style=display:flex><span>Finalizers:      <span style=color:#666>[</span>kubernetes.io/pv-protection kubernetes.io/pv-controller<span style=color:#666>]</span>
</span></span><span style=display:flex><span>StorageClass:    vcp-sc
</span></span><span style=display:flex><span>Status:          Bound
</span></span><span style=display:flex><span>Claim:           default/vcp-pvc-1
</span></span><span style=display:flex><span>Reclaim Policy:  Delete
</span></span><span style=display:flex><span>Access Modes:    RWO
</span></span><span style=display:flex><span>VolumeMode:      Filesystem
</span></span><span style=display:flex><span>Capacity:        1Gi
</span></span><span style=display:flex><span>Node Affinity:   &lt;none&gt;
</span></span><span style=display:flex><span>Message:         
</span></span><span style=display:flex><span>Source:
</span></span><span style=display:flex><span>    Type:               vSphereVolume <span style=color:#666>(</span>a Persistent Disk resource in vSphere<span style=color:#666>)</span>
</span></span><span style=display:flex><span>    VolumePath:         <span style=color:#666>[</span>vsanDatastore<span style=color:#666>]</span> d49c4a62-166f-ce12-c464-020077ba5d46/kubernetes-dynamic-pvc-74a498d6-3929-47e8-8c02-078c1ece4d78.vmdk
</span></span><span style=display:flex><span>    FSType:             ext4
</span></span><span style=display:flex><span>    StoragePolicyName:  vSAN Default Storage Policy
</span></span><span style=display:flex><span>Events:                 &lt;none&gt;
</span></span></code></pre></div><p>终结器 <code>external-provisioner.volume.kubernetes.io/finalizer</code> 会被添加到 CSI 卷上。下面是一个例子：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>Name:            pvc-2f0bab97-85a8-4552-8044-eb8be45cf48d
</span></span><span style=display:flex><span>Labels:          &lt;none&gt;
</span></span><span style=display:flex><span>Annotations:     pv.kubernetes.io/provisioned-by: csi.vsphere.vmware.com
</span></span><span style=display:flex><span>Finalizers:      <span style=color:#666>[</span>kubernetes.io/pv-protection external-provisioner.volume.kubernetes.io/finalizer<span style=color:#666>]</span>
</span></span><span style=display:flex><span>StorageClass:    fast
</span></span><span style=display:flex><span>Status:          Bound
</span></span><span style=display:flex><span>Claim:           demo-app/nginx-logs
</span></span><span style=display:flex><span>Reclaim Policy:  Delete
</span></span><span style=display:flex><span>Access Modes:    RWO
</span></span><span style=display:flex><span>VolumeMode:      Filesystem
</span></span><span style=display:flex><span>Capacity:        200Mi
</span></span><span style=display:flex><span>Node Affinity:   &lt;none&gt;
</span></span><span style=display:flex><span>Message:         
</span></span><span style=display:flex><span>Source:
</span></span><span style=display:flex><span>    Type:              CSI <span style=color:#666>(</span>a Container Storage Interface <span style=color:#666>(</span>CSI<span style=color:#666>)</span> volume <span style=color:#a2f>source</span><span style=color:#666>)</span>
</span></span><span style=display:flex><span>    Driver:            csi.vsphere.vmware.com
</span></span><span style=display:flex><span>    FSType:            ext4
</span></span><span style=display:flex><span>    VolumeHandle:      44830fa8-79b4-406b-8b58-621ba25353fd
</span></span><span style=display:flex><span>    ReadOnly:          <span style=color:#a2f>false</span>
</span></span><span style=display:flex><span>    VolumeAttributes:      storage.kubernetes.io/csiProvisionerIdentity<span style=color:#666>=</span>1648442357185-8081-csi.vsphere.vmware.com
</span></span><span style=display:flex><span>                           <span style=color:#b8860b>type</span><span style=color:#666>=</span>vSphere CNS Block Volume
</span></span><span style=display:flex><span>Events:                &lt;none&gt;
</span></span></code></pre></div><p>当为特定的树内卷插件启用了 <code>CSIMigration{provider}</code> 特性标志时，<code>kubernetes.io/pv-controller</code>
终结器将被替换为 <code>external-provisioner.volume.kubernetes.io/finalizer</code> 终结器。</p><h3 id=reserving-a-persistentvolume>预留 PersistentVolume</h3><p>控制平面可以在集群中<a href=#binding>将 PersistentVolumeClaims 绑定到匹配的 PersistentVolumes</a>。
但是，如果你希望 PVC 绑定到特定 PV，则需要预先绑定它们。</p><p>通过在 PersistentVolumeClaim 中指定 PersistentVolume，你可以声明该特定
PV 与 PVC 之间的绑定关系。如果该 PersistentVolume 存在且未被通过其
<code>claimRef</code> 字段预留给 PersistentVolumeClaim，则该 PersistentVolume
会和该 PersistentVolumeClaim 绑定到一起。</p><p>绑定操作不会考虑某些卷匹配条件是否满足，包括节点亲和性等等。
控制面仍然会检查<a href=/zh-cn/docs/concepts/storage/storage-classes/>存储类</a>、
访问模式和所请求的存储尺寸都是合法的。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo-pvc<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># 此处须显式设置空字符串，否则会被设置为默认的 StorageClass</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeName</span>:<span style=color:#bbb> </span>foo-pv<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span></code></pre></div><p>此方法无法对 PersistentVolume 的绑定特权做出任何形式的保证。
如果有其他 PersistentVolumeClaim 可以使用你所指定的 PV，
则你应该首先预留该存储卷。你可以将 PV 的 <code>claimRef</code> 字段设置为相关的
PersistentVolumeClaim 以确保其他 PVC 不会绑定到该 PV 卷。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo-pv<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>claimRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo-pvc<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span></code></pre></div><p>如果你想要使用 <code>claimPolicy</code> 属性设置为 <code>Retain</code> 的 PersistentVolume 卷时，
包括你希望复用现有的 PV 卷时，这点是很有用的</p><h3 id=expanding-persistent-volumes-claims>扩充 PVC 申领</h3><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.24 [stable]</code></div><p>现在，对扩充 PVC 申领的支持默认处于被启用状态。你可以扩充以下类型的卷：</p><ul><li>azureDisk</li><li>azureFile</li><li>awsElasticBlockStore</li><li>cinder (deprecated)</li><li><a class=glossary-tooltip title='容器存储接口 （CSI）定义了存储系统暴露给容器的标准接口。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/storage/volumes/#csi target=_blank aria-label=csi>csi</a></li><li>flexVolume (deprecated)</li><li>gcePersistentDisk</li><li>glusterfs</li><li>rbd</li><li>portworxVolume</li></ul><p>只有当 PVC 的存储类中将 <code>allowVolumeExpansion</code> 设置为 true 时，你才可以扩充该 PVC 申领。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>gluster-vol-default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/glusterfs<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resturl</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;http://192.168.10.100:8080&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restuser</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>secretNamespace</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>allowVolumeExpansion</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>如果要为某 PVC 请求较大的存储卷，可以编辑 PVC 对象，设置一个更大的尺寸值。
这一编辑操作会触发为下层 PersistentVolume 提供存储的卷的扩充。
Kubernetes 不会创建新的 PV 卷来满足此申领的请求。
与之相反，现有的卷会被调整大小。</p><div class="alert alert-danger warning callout" role=alert><strong>警告：</strong> 直接编辑 PersistentVolume 的大小可以阻止该卷自动调整大小。
如果对 PersistentVolume 的容量进行编辑，然后又将其所对应的
PersistentVolumeClaim 的 <code>.spec</code> 进行编辑，使该 PersistentVolumeClaim
的大小匹配 PersistentVolume 的话，则不会发生存储大小的调整。
Kubernetes 控制平面将看到两个资源的所需状态匹配，
并认为其后备卷的大小已被手动增加，无需调整。</div><h4 id=csi-volume-expansion>CSI 卷的扩充</h4><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.24 [stable]</code></div><p>对 CSI 卷的扩充能力默认是被启用的，不过扩充 CSI 卷要求 CSI
驱动支持卷扩充操作。可参阅特定 CSI 驱动的文档了解更多信息。</p><h4 id=resizing-a-volume-containing-a-file-system>重设包含文件系统的卷的大小</h4><p>只有卷中包含的文件系统是 XFS、Ext3 或者 Ext4 时，你才可以重设卷的大小。</p><p>当卷中包含文件系统时，只有在 Pod 使用 <code>ReadWrite</code> 模式来使用 PVC
申领的情况下才能重设其文件系统的大小。文件系统扩充的操作或者是在 Pod
启动期间完成，或者在下层文件系统支持在线扩充的前提下在 Pod 运行期间完成。</p><p>如果 FlexVolumes 的驱动将 <code>RequiresFSResize</code> 能力设置为 <code>true</code>，
则该 FlexVolume 卷（于 Kubernetes v1.23 弃用）可以在 Pod 重启期间调整大小。</p><h4 id=resizing-an-in-use-persistentvolumevlaim>重设使用中 PVC 申领的大小</h4><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.24 [stable]</code></div><p>在这种情况下，你不需要删除和重建正在使用某现有 PVC 的 Pod 或 Deployment。
所有使用中的 PVC 在其文件系统被扩充之后，立即可供其 Pod 使用。
此功能特性对于没有被 Pod 或 Deployment 使用的 PVC 而言没有效果。
你必须在执行扩展操作之前创建一个使用该 PVC 的 Pod。</p><p>与其他卷类型类似，FlexVolume 卷也可以在被 Pod 使用期间执行扩充操作。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong> FlexVolume 卷的重设大小只能在下层驱动支持重设大小的时候才可进行。</div><div class="alert alert-info note callout" role=alert><strong>说明：</strong> 扩充 EBS 卷的操作非常耗时。同时还存在另一个配额限制：
每 6 小时只能执行一次（尺寸）修改操作。</div><h4 id=recovering-from-failure-when-expanding-volumes>处理扩充卷过程中的失败</h4><p>如果用户指定的新大小过大，底层存储系统无法满足，PVC 的扩展将不断重试，
直到用户或集群管理员采取一些措施。这种情况是不希望发生的，因此 Kubernetes
提供了以下从此类故障中恢复的方法。</p><ul class="nav nav-tabs" id=recovery-methods role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#recovery-methods-0 role=tab aria-controls=recovery-methods-0 aria-selected=true>集群管理员手动处理</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#recovery-methods-1 role=tab aria-controls=recovery-methods-1>通过请求扩展为更小尺寸</a></li></ul><div class=tab-content id=recovery-methods><div id=recovery-methods-0 class="tab-pane show active" role=tabpanel aria-labelledby=recovery-methods-0><p><p>如果扩充下层存储的操作失败，集群管理员可以手动地恢复 PVC
申领的状态并取消重设大小的请求。否则，在没有管理员干预的情况下，
控制器会反复重试重设大小的操作。</p><ol><li>将绑定到 PVC 申领的 PV 卷标记为 <code>Retain</code> 回收策略。</li><li>删除 PVC 对象。由于 PV 的回收策略为 <code>Retain</code>，我们不会在重建 PVC 时丢失数据。</li><li>删除 PV 规约中的 <code>claimRef</code> 项，这样新的 PVC 可以绑定到该卷。
这一操作会使得 PV 卷变为 "可用（Available）"。</li><li>使用小于 PV 卷大小的尺寸重建 PVC，设置 PVC 的 <code>volumeName</code> 字段为 PV 卷的名称。
这一操作将把新的 PVC 对象绑定到现有的 PV 卷。</li><li>不要忘记恢复 PV 卷上设置的回收策略。</li></ol></div><div id=recovery-methods-1 class=tab-pane role=tabpanel aria-labelledby=recovery-methods-1><p><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.23 [alpha]</code></div><div class="alert alert-info note callout" role=alert><strong>说明：</strong> Kubernetes 从 1.23 版本开始将允许用户恢复失败的 PVC 扩展这一能力作为
alpha 特性支持。<code>RecoverVolumeExpansionFailure</code> 必须被启用以允许使用此特性。
可参考<a href=/zh-cn/docs/reference/command-line-tools-reference/feature-gates/>特性门控</a>
文档了解更多信息。</div><p>如果集群中的特性门控 <code>RecoverVolumeExpansionFailure</code>
已启用，在 PVC 的扩展发生失败时，你可以使用比先前请求的值更小的尺寸来重试扩展。
要使用一个更小的尺寸尝试请求新的扩展，请编辑该 PVC 的 <code>.spec.resources</code>
并选择一个比你之前所尝试的值更小的值。
如果由于容量限制而无法成功扩展至更高的值，这将很有用。
如果发生了这种情况，或者你怀疑可能发生了这种情况，
你可以通过指定一个在底层存储制备容量限制内的尺寸来重试扩展。
你可以通过查看 <code>.status.resizeStatus</code> 以及 PVC 上的事件来监控调整大小操作的状态。</p><p>请注意，
尽管你可以指定比之前的请求更低的存储量，新值必须仍然高于 <code>.status.capacity</code>。
Kubernetes 不支持将 PVC 缩小到小于其当前的尺寸。</p></div></div><h2 id=types-of-persistent-volumes>持久卷的类型</h2><p>PV 持久卷是用插件的形式来实现的。Kubernetes 目前支持以下插件：</p><ul><li><a href=/zh-cn/docs/concepts/storage/volumes/#cephfs><code>cephfs</code></a> - CephFS volume</li><li><a href=/zh-cn/docs/concepts/storage/volumes/#csi><code>csi</code></a> - 容器存储接口 (CSI)</li><li><a href=/zh-cn/docs/concepts/storage/volumes/#fc><code>fc</code></a> - Fibre Channel (FC) 存储</li><li><a href=/zh-cn/docs/concepts/storage/volumes/#hostpath><code>hostPath</code></a> - HostPath 卷
（仅供单节点测试使用；不适用于多节点集群；请尝试使用 <code>local</code> 卷作为替代）</li><li><a href=/zh-cn/docs/concepts/storage/volumes/#iscsi><code>iscsi</code></a> - iSCSI (SCSI over IP) 存储</li><li><a href=/zh-cn/docs/concepts/storage/volumes/#local><code>local</code></a> - 节点上挂载的本地存储设备</li><li><a href=/zh-cn/docs/concepts/storage/volumes/#nfs><code>nfs</code></a> - 网络文件系统 (NFS) 存储</li><li><a href=/zh-cn/docs/concepts/storage/volumes/#rbd><code>rbd</code></a> - Rados 块设备 (RBD) 卷</li></ul><p>以下的持久卷已被弃用。这意味着当前仍是支持的，但是 Kubernetes 将来的发行版会将其移除。</p><ul><li><a href=/zh-cn/docs/concepts/storage/volumes/#awselasticblockstore><code>awsElasticBlockStore</code></a> - AWS 弹性块存储（EBS）
（于 v1.17 <strong>弃用</strong>）</li><li><a href=/zh-cn/docs/concepts/storage/volumes/#azuredisk><code>azureDisk</code></a> - Azure Disk
（于 v1.19 <strong>弃用</strong>）</li><li><a href=/zh-cn/docs/concepts/storage/volumes/#azurefile><code>azureFile</code></a> - Azure File
（于 v1.21 <strong>弃用</strong>）</li><li><a href=/zh-cn/docs/concepts/storage/volumes/#cinder><code>cinder</code></a> - Cinder（OpenStack 块存储）（于 v1.18 <strong>弃用</strong>）</li><li><a href=/zh-cn/docs/concepts/storage/volumes/#flexVolume><code>flexVolume</code></a> - FlexVolume （于 v1.23 <strong>弃用</strong>）</li><li><a href=/zh-cn/docs/concepts/storage/volumes/#gcepersistentdisk><code>gcePersistentDisk</code></a> - GCE Persistent Disk
（于 v1.17 <strong>弃用</strong>）</li><li><a href=/zh-cn/docs/concepts/storage/volumes/#glusterfs><code>glusterfs</code></a> - Glusterfs 卷
（于 v1.25 <strong>弃用</strong>）</li><li><a href=/zh-cn/docs/concepts/storage/volumes/#portworxvolume><code>portworxVolume</code></a> - Portworx 卷
（于 v1.25 <strong>弃用</strong>）</li><li><a href=/zh-cn/docs/concepts/storage/volumes/#vspherevolume><code>vsphereVolume</code></a> - vSphere VMDK 卷
（于 v1.19 <strong>弃用</strong>）</li></ul><p>旧版本的 Kubernetes 仍支持这些“树内（In-Tree）”持久卷类型：</p><ul><li><code>photonPersistentDisk</code> - Photon 控制器持久化盘。（从 v1.15 版本开始将<strong>不可用</strong>）</li><li><a href=/zh-cn/docs/concepts/storage/volumes/#scaleio><code>scaleIO</code></a> - ScaleIO 卷（v1.21 之后<strong>不可用</strong>）</li><li><a href=/zh-cn/docs/concepts/storage/volumes/#flocker><code>flocker</code></a> - Flocker 存储
（v1.25 之后<strong>不可用</strong>）</li><li><a href=/zh-cn/docs/concepts/storage/volumes/#quobyte><code>quobyte</code></a> - Quobyte 卷
（v1.25 之后<strong>不可用</strong>）</li><li><a href=/zh-cn/docs/concepts/storage/volumes/#storageos><code>storageos</code></a> - StorageOS 卷
（v1.25 之后<strong>不可用</strong>）</li></ul><h2 id=persistent-volumes>持久卷</h2><p>每个 PV 对象都包含 <code>spec</code> 部分和 <code>status</code> 部分，分别对应卷的规约和状态。
PersistentVolume 对象的名称必须是合法的
<a href=/zh-cn/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNS 子域名</a>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pv0003<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>capacity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>5Gi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeMode</span>:<span style=color:#bbb> </span>Filesystem<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>persistentVolumeReclaimPolicy</span>:<span style=color:#bbb> </span>Recycle<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>slow<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>mountOptions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- hard<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- nfsvers=4.1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nfs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/tmp<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>server</span>:<span style=color:#bbb> </span><span style=color:#666>172.17.0.2</span><span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>说明：</strong> 在集群中使用持久卷存储通常需要一些特定于具体卷类型的辅助程序。
在这个例子中，PersistentVolume 是 NFS 类型的，因此需要辅助程序 <code>/sbin/mount.nfs</code>
来支持挂载 NFS 文件系统。</div><h3 id=capacity>容量</h3><p>一般而言，每个 PV 卷都有确定的存储容量。
容量属性是使用 PV 对象的 <code>capacity</code> 属性来设置的。
参考词汇表中的<a href="/zh-cn/docs/reference/glossary/?all=true#term-quantity">量纲（Quantity）</a>
词条，了解 <code>capacity</code> 字段可以接受的单位。</p><p>目前，存储大小是可以设置和请求的唯一资源。
未来可能会包含 IOPS、吞吐量等属性。</p><h3 id=volume-mode>卷模式</h3><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.18 [stable]</code></div><p>针对 PV 持久卷，Kubernetes
支持两种卷模式（<code>volumeModes</code>）：<code>Filesystem（文件系统）</code> 和 <code>Block（块）</code>。
<code>volumeMode</code> 是一个可选的 API 参数。
如果该参数被省略，默认的卷模式是 <code>Filesystem</code>。</p><p><code>volumeMode</code> 属性设置为 <code>Filesystem</code> 的卷会被 Pod <strong>挂载（Mount）</strong> 到某个目录。
如果卷的存储来自某块设备而该设备目前为空，Kuberneretes 会在第一次挂载卷之前在设备上创建文件系统。</p><p>你可以将 <code>volumeMode</code> 设置为 <code>Block</code>，以便将卷作为原始块设备来使用。
这类卷以块设备的方式交给 Pod 使用，其上没有任何文件系统。
这种模式对于为 Pod 提供一种使用最快可能方式来访问卷而言很有帮助，
Pod 和卷之间不存在文件系统层。另外，Pod 中运行的应用必须知道如何处理原始块设备。
关于如何在 Pod 中使用 <code>volumeMode: Block</code> 的卷，
可参阅<a href=#raw-block-volume-support>原始块卷支持</a>。</p><h3 id=access-modes>访问模式</h3><p>PersistentVolume 卷可以用资源提供者所支持的任何方式挂载到宿主系统上。
如下表所示，提供者（驱动）的能力不同，每个 PV 卷的访问模式都会设置为对应卷所支持的模式值。
例如，NFS 可以支持多个读写客户，但是某个特定的 NFS PV 卷可能在服务器上以只读的方式导出。
每个 PV 卷都会获得自身的访问模式集合，描述的是特定 PV 卷的能力。</p><p>访问模式有：</p><dl><dt><code>ReadWriteOnce</code></dt><dd>卷可以被一个节点以读写方式挂载。
ReadWriteOnce 访问模式也允许运行在同一节点上的多个 Pod 访问卷。</dd><dt><code>ReadOnlyMany</code></dt><dd>卷可以被多个节点以只读方式挂载。</dd><dt><code>ReadWriteMany</code></dt><dd>卷可以被多个节点以读写方式挂载。</dd><dt><code>ReadWriteOncePod</code></dt><dd>卷可以被单个 Pod 以读写方式挂载。
如果你想确保整个集群中只有一个 Pod 可以读取或写入该 PVC，
请使用 ReadWriteOncePod 访问模式。这只支持 CSI 卷以及需要 Kubernetes 1.22 以上版本。</dd></dl><p>这篇博客文章 <a href=/blog/2021/09/13/read-write-once-pod-access-mode-alpha/>Introducing Single Pod Access Mode for PersistentVolumes</a>
描述了更详细的内容。</p><p>在命令行接口（CLI）中，访问模式也使用以下缩写形式：</p><ul><li>RWO - ReadWriteOnce</li><li>ROX - ReadOnlyMany</li><li>RWX - ReadWriteMany</li><li>RWOP - ReadWriteOncePod</li></ul><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>Kubernetes 使用卷访问模式来匹配 PersistentVolumeClaim 和 PersistentVolume。
在某些场合下，卷访问模式也会限制 PersistentVolume 可以挂载的位置。
卷访问模式并<strong>不会</strong>在存储已经被挂载的情况下为其实施写保护。
即使访问模式设置为 ReadWriteOnce、ReadOnlyMany 或 ReadWriteMany，它们也不会对卷形成限制。
例如，即使某个卷创建时设置为 ReadOnlyMany，也无法保证该卷是只读的。
如果访问模式设置为 ReadWriteOncePod，则卷会被限制起来并且只能挂载到一个 Pod 上。</div><blockquote><p><strong>重要提醒！</strong> 每个卷同一时刻只能以一种访问模式挂载，即使该卷能够支持多种访问模式。
例如，一个 GCEPersistentDisk 卷可以被某节点以 ReadWriteOnce
模式挂载，或者被多个节点以 ReadOnlyMany 模式挂载，但不可以同时以两种模式挂载。</p></blockquote><table><thead><tr><th style=text-align:left>卷插件</th><th style=text-align:center>ReadWriteOnce</th><th style=text-align:center>ReadOnlyMany</th><th style=text-align:center>ReadWriteMany</th><th>ReadWriteOncePod</th></tr></thead><tbody><tr><td style=text-align:left>AWSElasticBlockStore</td><td style=text-align:center>✓</td><td style=text-align:center>-</td><td style=text-align:center>-</td><td>-</td></tr><tr><td style=text-align:left>AzureFile</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td>-</td></tr><tr><td style=text-align:left>AzureDisk</td><td style=text-align:center>✓</td><td style=text-align:center>-</td><td style=text-align:center>-</td><td>-</td></tr><tr><td style=text-align:left>CephFS</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td>-</td></tr><tr><td style=text-align:left>Cinder</td><td style=text-align:center>✓</td><td style=text-align:center>-</td><td style=text-align:center>(<a href=https://github.com/kubernetes/cloud-provider-openstack/blob/master/docs/cinder-csi-plugin/features.md#multi-attach-volumes>如果多次挂接卷可用</a>)</td><td>-</td></tr><tr><td style=text-align:left>CSI</td><td style=text-align:center>取决于驱动</td><td style=text-align:center>取决于驱动</td><td style=text-align:center>取决于驱动</td><td>取决于驱动</td></tr><tr><td style=text-align:left>FC</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td style=text-align:center>-</td><td>-</td></tr><tr><td style=text-align:left>FlexVolume</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td style=text-align:center>取决于驱动</td><td>-</td></tr><tr><td style=text-align:left>GCEPersistentDisk</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td style=text-align:center>-</td><td>-</td></tr><tr><td style=text-align:left>Glusterfs</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td>-</td></tr><tr><td style=text-align:left>HostPath</td><td style=text-align:center>✓</td><td style=text-align:center>-</td><td style=text-align:center>-</td><td>-</td></tr><tr><td style=text-align:left>iSCSI</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td style=text-align:center>-</td><td>-</td></tr><tr><td style=text-align:left>NFS</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td>-</td></tr><tr><td style=text-align:left>RBD</td><td style=text-align:center>✓</td><td style=text-align:center>✓</td><td style=text-align:center>-</td><td>-</td></tr><tr><td style=text-align:left>VsphereVolume</td><td style=text-align:center>✓</td><td style=text-align:center>-</td><td style=text-align:center>-（Pod 运行于同一节点上时可行）</td><td>-</td></tr><tr><td style=text-align:left>PortworxVolume</td><td style=text-align:center>✓</td><td style=text-align:center>-</td><td style=text-align:center>✓</td><td>-</td></tr></tbody></table><h3 id=class>类</h3><p>每个 PV 可以属于某个类（Class），通过将其 <code>storageClassName</code> 属性设置为某个
<a href=/zh-cn/docs/concepts/storage/storage-classes/>StorageClass</a> 的名称来指定。
特定类的 PV 卷只能绑定到请求该类存储卷的 PVC 申领。
未设置 <code>storageClassName</code> 的 PV 卷没有类设定，只能绑定到那些没有指定特定存储类的 PVC 申领。</p><p>早前，Kubernetes 使用注解 <code>volume.beta.kubernetes.io/storage-class</code> 而不是
<code>storageClassName</code> 属性。这一注解目前仍然起作用，不过在将来的 Kubernetes
发布版本中该注解会被彻底废弃。</p><h3 id=reclaim-policy>回收策略</h3><p>目前的回收策略有：</p><ul><li>Retain -- 手动回收</li><li>Recycle -- 基本擦除 (<code>rm -rf /thevolume/*</code>)</li><li>Delete -- 诸如 AWS EBS、GCE PD、Azure Disk 或 OpenStack Cinder 卷这类关联存储资产也被删除</li></ul><p>目前，仅 NFS 和 HostPath 支持回收（Recycle）。
AWS EBS、GCE PD、Azure Disk 和 Cinder 卷都支持删除（Delete）。</p><h3 id=mount-options>挂载选项</h3><p>Kubernetes 管理员可以指定持久卷被挂载到节点上时使用的附加挂载选项。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong> 并非所有持久卷类型都支持挂载选项。</div><p>以下卷类型支持挂载选项：</p><ul><li><code>awsElasticBlockStore</code></li><li><code>azureDisk</code></li><li><code>azureFile</code></li><li><code>cephfs</code></li><li><code>cinder</code>（于 v1.18 <strong>弃用</strong>）</li><li><code>gcePersistentDisk</code></li><li><code>glusterfs</code></li><li><code>iscsi</code></li><li><code>nfs</code></li><li><code>rbd</code></li><li><code>vsphereVolume</code></li></ul><p>Kubernetes 不对挂载选项执行合法性检查。如果挂载选项是非法的，挂载就会失败。</p><p>早前，Kubernetes 使用注解 <code>volume.beta.kubernetes.io/mount-options</code> 而不是
<code>mountOptions</code> 属性。这一注解目前仍然起作用，不过在将来的 Kubernetes
发布版本中该注解会被彻底废弃。</p><h3 id=node-affinity>节点亲和性</h3><div class="alert alert-info note callout" role=alert><strong>说明：</strong> 对大多数类型的卷而言，你不需要设置节点亲和性字段。
<a href=/zh-cn/docs/concepts/storage/volumes/#awselasticblockstore>AWS EBS</a>、
<a href=/zh-cn/docs/concepts/storage/volumes/#gcepersistentdisk>GCE PD</a> 和
<a href=/zh-cn/docs/concepts/storage/volumes/#azuredisk>Azure Disk</a> 卷类型都能自动设置相关字段。
你需要为 <a href=/zh-cn/docs/concepts/storage/volumes/#local>local</a> 卷显式地设置此属性。</div><p>每个 PV 卷可以通过设置节点亲和性来定义一些约束，进而限制从哪些节点上可以访问此卷。
使用这些卷的 Pod 只会被调度到节点亲和性规则所选择的节点上执行。
要设置节点亲和性，配置 PV 卷 <code>.spec</code> 中的 <code>nodeAffinity</code>。
<a href=/zh-cn/docs/reference/kubernetes-api/config-and-storage-resources/persistent-volume-v1/#PersistentVolumeSpec>持久卷</a>
API 参考关于该字段的更多细节。</p><h3 id=phase>阶段</h3><p>每个卷会处于以下阶段（Phase）之一：</p><ul><li>Available（可用）-- 卷是一个空闲资源，尚未绑定到任何申领；</li><li>Bound（已绑定）-- 该卷已经绑定到某申领；</li><li>Released（已释放）-- 所绑定的申领已被删除，但是资源尚未被集群回收；</li><li>Failed（失败）-- 卷的自动回收操作失败。</li></ul><p>命令行接口能够显示绑定到某 PV 卷的 PVC 对象。</p><h2 id=persistentvolumeclaims>PersistentVolumeClaims</h2><p>每个 PVC 对象都有 <code>spec</code> 和 <code>status</code> 部分，分别对应申领的规约和状态。
PersistentVolumeClaim 对象的名称必须是合法的
<a href=/zh-cn/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNS 子域名</a>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myclaim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeMode</span>:<span style=color:#bbb> </span>Filesystem<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>8Gi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>slow<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>release</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;stable&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- {<span style=color:green;font-weight:700>key: environment, operator: In, values</span>:<span style=color:#bbb> </span>[dev]}<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=access-modes>访问模式</h3><p>申领在请求具有特定访问模式的存储时，使用与卷相同的<a href=#access-modes>访问模式约定</a>。</p><h3 id=volume-modes>卷模式</h3><p>申领使用<a href=#volume-mode>与卷相同的约定</a>来表明是将卷作为文件系统还是块设备来使用。</p><h3 id=resources>资源</h3><p>申领和 Pod 一样，也可以请求特定数量的资源。在这个上下文中，请求的资源是存储。
卷和申领都使用相同的
<a href=https://git.k8s.io/design-proposals-archive/scheduling/resources.md>资源模型</a>。</p><h3 id=selector>选择算符</h3><p>申领可以设置<a href=/zh-cn/docs/concepts/overview/working-with-objects/labels/#label-selectors>标签选择算符</a>
来进一步过滤卷集合。只有标签与选择算符相匹配的卷能够绑定到申领上。
选择算符包含两个字段：</p><ul><li><code>matchLabels</code> - 卷必须包含带有此值的标签</li><li><code>matchExpressions</code> - 通过设定键（key）、值列表和操作符（operator）
来构造的需求。合法的操作符有 In、NotIn、Exists 和 DoesNotExist。</li></ul><p>来自 <code>matchLabels</code> 和 <code>matchExpressions</code> 的所有需求都按逻辑与的方式组合在一起。
这些需求都必须被满足才被视为匹配。</p><h3 id=class>类</h3><p>申领可以通过为 <code>storageClassName</code> 属性设置
<a href=/zh-cn/docs/concepts/storage/storage-classes/>StorageClass</a> 的名称来请求特定的存储类。
只有所请求的类的 PV 卷，即 <code>storageClassName</code> 值与 PVC 设置相同的 PV 卷，
才能绑定到 PVC 申领。</p><p>PVC 申领不必一定要请求某个类。如果 PVC 的 <code>storageClassName</code> 属性值设置为 <code>""</code>，
则被视为要请求的是没有设置存储类的 PV 卷，因此这一 PVC 申领只能绑定到未设置存储类的
PV 卷（未设置注解或者注解值为 <code>""</code> 的 PersistentVolume（PV）对象在系统中不会被删除，
因为这样做可能会引起数据丢失。未设置 <code>storageClassName</code> 的 PVC 与此大不相同，
也会被集群作不同处理。具体筛查方式取决于
<a href=/zh-cn/docs/reference/access-authn-authz/admission-controllers/#defaultstorageclass><code>DefaultStorageClass</code> 准入控制器插件</a>
是否被启用。</p><ul><li>如果准入控制器插件被启用，则管理员可以设置一个默认的 StorageClass。
所有未设置 <code>storageClassName</code> 的 PVC 都只能绑定到隶属于默认存储类的 PV 卷。
设置默认 StorageClass 的工作是通过将对应 StorageClass 对象的注解
<code>storageclass.kubernetes.io/is-default-class</code> 赋值为 <code>true</code> 来完成的。
如果管理员未设置默认存储类，集群对 PVC 创建的处理方式与未启用准入控制器插件时相同。
如果设定的默认存储类不止一个，准入控制插件会禁止所有创建 PVC 操作。</li><li>如果准入控制器插件被关闭，则不存在默认 StorageClass 的说法。
所有将 <code>storageClassName</code> 设为 <code>""</code> 的 PVC 只能被绑定到也将 <code>storageClassName</code> 设为 <code>""</code> 的 PV。
不过，只要默认的 StorageClass 可用，就可以稍后更新缺少 <code>storageClassName</code> 的 PVC。
如果这个 PVC 更新了，它将不再绑定到也将 <code>storageClassName</code> 设为 <code>""</code> 的 PV。</li></ul><p>参阅<a href=#retroactive-default-storageclass-assignment>可追溯的默认 StorageClass 赋值</a>了解更多详细信息。</p><p>取决于安装方法，默认的 StorageClass 可能在集群安装期间由插件管理器（Addon
Manager）部署到集群中。</p><p>当某 PVC 除了请求 StorageClass 之外还设置了 <code>selector</code>，则这两种需求会按逻辑与关系处理：
只有隶属于所请求类且带有所请求标签的 PV 才能绑定到 PVC。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong> 目前，设置了非空 <code>selector</code> 的 PVC 对象无法让集群为其动态制备 PV 卷。</div><p>早前，Kubernetes 使用注解 <code>volume.beta.kubernetes.io/storage-class</code> 而不是
<code>storageClassName</code> 属性。这一注解目前仍然起作用，不过在将来的 Kubernetes
发布版本中该注解会被彻底废弃。</p><h4 id=retroactive-default-storageclass-assignment>可追溯的默认 StorageClass 赋值</h4><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.25 [alpha]</code></div><p>你可以创建 PersistentVolumeClaim，而无需为新 PVC 指定 <code>storageClassName</code>。
即使你的集群中不存在默认 StorageClass，你也可以这样做。
在这种情况下，新的 PVC 会按照你的定义进行创建，并且在默认值可用之前，该 PVC 的 <code>storageClassName</code> 保持不设置。
但是，如果你启用了 <a href=/zh-cn/docs/reference/command-line-tools-reference/feature-gates/><code>RetroactiveDefaultStorageClass</code> 特性门控</a>，
则 Kubernetes 的行为会有所不同：现有 PVC 无需更新 <code>storageClassName</code> 就能使用新的默认 StorageClass。</p><p>当一个默认的 StorageClass 变得可用时，控制平面会识别所有未设置 <code>storageClassName</code> 的现有 PVC。
对于 <code>storageClassName</code> 为空值或没有此主键的 PVC，
控制平面会更新这些 PVC 以设置其 <code>storageClassName</code> 与新的默认 StorageClass 匹配。
如果你有一个现有的 PVC，其中 <code>storageClassName</code> 是 <code>""</code>，
并且你配置了默认 StorageClass，则此 PVC 将不会得到更新。</p><p>为了保持绑定到 <code>storageClassName</code> 设为 <code>""</code> 的 PV（当存在默认 StorageClass 时），
你需要将关联 PVC 的 <code>storageClassName</code> 设置为 <code>""</code>。</p><p>此行为可帮助管理员更改默认 StorageClass，方法是先移除旧的 PVC，然后再创建或设置另一个 PVC。
这一时间窗口内因为没有指定默认值，会导致所创建的未设置 <code>storageClassName</code> 的 PVC 也没有默认值设置，
但由于默认 StorageClass 赋值是可追溯的，这种更改默认值的方式是安全的。</p><h2 id=claims-as-volumes>使用申领作为卷</h2><p>Pod 将申领作为卷来使用，并藉此访问存储资源。
申领必须位于使用它的 Pod 所在的同一名字空间内。
集群在 Pod 的名字空间中查找申领，并使用它来获得申领所使用的 PV 卷。
之后，卷会被挂载到宿主上并挂载到 Pod 中。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myfrontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/var/www/html&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypd<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypd<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>persistentVolumeClaim</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>claimName</span>:<span style=color:#bbb> </span>myclaim<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=a-note-on-namespaces>关于名字空间的说明</h3><p>PersistentVolume 卷的绑定是排他性的。
由于 PersistentVolumeClaim 是名字空间作用域的对象，使用
"Many" 模式（<code>ROX</code>、<code>RWX</code>）来挂载申领的操作只能在同一名字空间内进行。</p><h3 id=persistentvolumes-typed-hostpath>类型为 <code>hostpath</code> 的 PersistentVolume</h3><p><code>hostPath</code> PersistentVolume 使用节点上的文件或目录来模拟网络附加（network-attached）存储。
相关细节可参阅 <a href=/zh-cn/docs/tasks/configure-pod-container/configure-persistent-volume-storage/#create-a-persistentvolume><code>hostPath</code> 卷示例</a>。</p><h2 id=raw-block-volume-support>原始块卷支持</h2><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.18 [stable]</code></div><p>以下卷插件支持原始块卷，包括其动态制备（如果支持的话）的卷：</p><ul><li>AWSElasticBlockStore</li><li>AzureDisk</li><li>CSI</li><li>FC （光纤通道）</li><li>GCEPersistentDisk</li><li>iSCSI</li><li>Local 卷</li><li>OpenStack Cinder</li><li>RBD （Ceph 块设备）</li><li>VsphereVolume</li></ul><h3 id=persistent-volume-using-a-raw-block-volume>使用原始块卷的持久卷</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>block-pv<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>capacity</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>10Gi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeMode</span>:<span style=color:#bbb> </span>Block<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>persistentVolumeReclaimPolicy</span>:<span style=color:#bbb> </span>Retain<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>fc</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetWWNs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;50060e801049cfd1&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>lun</span>:<span style=color:#bbb> </span><span style=color:#666>0</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=persistent-volume-claim-requesting-a-raw-block-volume>申请原始块卷的 PVC 申领</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>block-pvc<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeMode</span>:<span style=color:#bbb> </span>Block<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>10Gi<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=pod-spec-adding-raw-block-device-path-in-container>在容器中添加原始块设备路径的 Pod 规约</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pod-with-block-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fc-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>fedora:26<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;/bin/sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;tail -f /dev/null&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeDevices</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>data<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>devicePath</span>:<span style=color:#bbb> </span>/dev/xvda<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>data<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>persistentVolumeClaim</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>claimName</span>:<span style=color:#bbb> </span>block-pvc<span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>说明：</strong> 向 Pod 中添加原始块设备时，你要在容器内设置设备路径而不是挂载路径。</div><h3 id=binding-block-volumes>绑定块卷</h3><p>如果用户通过 PersistentVolumeClaim 规约的 <code>volumeMode</code> 字段来表明对原始块设备的请求，
绑定规则与之前版本中未在规约中考虑此模式的实现略有不同。
下面列举的表格是用户和管理员可以为请求原始块设备所作设置的组合。
此表格表明在不同的组合下卷是否会被绑定。</p><p>静态制备卷的卷绑定矩阵：</p><table><thead><tr><th>PV volumeMode</th><th style=text-align:center>PVC volumeMode</th><th style=text-align:right>Result</th></tr></thead><tbody><tr><td>未指定</td><td style=text-align:center>未指定</td><td style=text-align:right>绑定</td></tr><tr><td>未指定</td><td style=text-align:center>Block</td><td style=text-align:right>不绑定</td></tr><tr><td>未指定</td><td style=text-align:center>Filesystem</td><td style=text-align:right>绑定</td></tr><tr><td>Block</td><td style=text-align:center>未指定</td><td style=text-align:right>不绑定</td></tr><tr><td>Block</td><td style=text-align:center>Block</td><td style=text-align:right>绑定</td></tr><tr><td>Block</td><td style=text-align:center>Filesystem</td><td style=text-align:right>不绑定</td></tr><tr><td>Filesystem</td><td style=text-align:center>Filesystem</td><td style=text-align:right>绑定</td></tr><tr><td>Filesystem</td><td style=text-align:center>Block</td><td style=text-align:right>不绑定</td></tr><tr><td>Filesystem</td><td style=text-align:center>未指定</td><td style=text-align:right>绑定</td></tr></tbody></table><div class="alert alert-info note callout" role=alert><strong>说明：</strong> Alpha 发行版本中仅支持静态制备的卷。
管理员需要在处理原始块设备时小心处理这些值。</div><h2 id=volume-snapshot-and-restore-volume-from-snapshot-support>对卷快照及从卷快照中恢复卷的支持</h2><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.20 [stable]</code></div><p>卷快照（Volume Snapshot）仅支持树外 CSI 卷插件。
有关细节可参阅<a href=/zh-cn/docs/concepts/storage/volume-snapshots/>卷快照</a>文档。
树内卷插件被弃用。你可以查阅<a href=https://git.k8s.io/community/sig-storage/volume-plugin-faq.md>卷插件 FAQ</a>
了解已弃用的卷插件。</p><h3 id=create-persistent-volume-claim-from-volume-snapshot>基于卷快照创建 PVC 申领</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>restore-pvc<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>csi-hostpath-sc<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>dataSource</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>new-snapshot-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>VolumeSnapshot<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>snapshot.storage.k8s.io<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>10Gi<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=volume-cloning>卷克隆</h2><p><a href=/zh-cn/docs/concepts/storage/volume-pvc-datasource/>卷克隆</a>功能特性仅适用于 CSI 卷插件。</p><h3 id=create-persistent-volume-claim-from-an-existing-pvc>基于现有 PVC 创建新的 PVC 申领</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cloned-pvc<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>my-csi-plugin<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>dataSource</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>existing-src-pvc-name<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>10Gi<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=volume-populators-and-data-sources>卷填充器（Populator）与数据源</h2><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.24 [beta]</code></div><p>Kubernetes 支持自定义的卷填充器。要使用自定义的卷填充器，你必须为
kube-apiserver 和 kube-controller-manager 启用 <code>AnyVolumeDataSource</code>
<a href=/zh-cn/docs/reference/command-line-tools-reference/feature-gates/>特性门控</a>。</p><p>卷填充器利用了 PVC 规约字段 <code>dataSourceRef</code>。
不像 <code>dataSource</code> 字段只能包含对另一个持久卷申领或卷快照的引用，
<code>dataSourceRef</code> 字段可以包含对同一命名空间中任何对象的引用（不包含除 PVC 以外的核心资源）。
对于启用了特性门控的集群，使用 <code>dataSourceRef</code> 比 <code>dataSource</code> 更好。</p><h2 id=data-source-references>数据源引用</h2><p><code>dataSourceRef</code> 字段的行为与 <code>dataSource</code> 字段几乎相同。
如果其中一个字段被指定而另一个字段没有被指定，API 服务器将给两个字段相同的值。
这两个字段都不能在创建后改变，如果试图为这两个字段指定不同的值，将导致验证错误。
因此，这两个字段将总是有相同的内容。</p><p>在 <code>dataSourceRef</code> 字段和 <code>dataSource</code> 字段之间有两个用户应该注意的区别：</p><ul><li><code>dataSource</code> 字段会忽略无效的值（如同是空值），
而 <code>dataSourceRef</code> 字段永远不会忽略值，并且若填入一个无效的值，会导致错误。
无效值指的是 PVC 之外的核心对象（没有 apiGroup 的对象）。</li><li><code>dataSourceRef</code> 字段可以包含不同类型的对象，而 <code>dataSource</code> 字段只允许 PVC 和卷快照。</li></ul><p>用户应该始终在启用了特性门控的集群上使用 <code>dataSourceRef</code>，而在没有启用特性门控的集群上使用 <code>dataSource</code>。
在任何情况下都没有必要查看这两个字段。
这两个字段的值看似相同但是语义稍微不一样，是为了向后兼容。
特别是混用旧版本和新版本的控制器时，它们能够互通。</p><h2 id=using-volume-populators>使用卷填充器</h2><p>卷填充器是能创建非空卷的<a class=glossary-tooltip title='控制器通过 API 服务器监控集群的公共状态，并致力于将当前状态转变为期望的状态。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/architecture/controller/ target=_blank aria-label=控制器>控制器</a>，
其卷的内容通过一个自定义资源决定。
用户通过使用 <code>dataSourceRef</code> 字段引用自定义资源来创建一个被填充的卷：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>populated-pvc<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>dataSourceRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example-name<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ExampleDataSource<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>example.storage.k8s.io<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>10Gi<span style=color:#bbb>
</span></span></span></code></pre></div><p>因为卷填充器是外部组件，如果没有安装所有正确的组件，试图创建一个使用卷填充器的 PVC 就会失败。
外部控制器应该在 PVC 上产生事件，以提供创建状态的反馈，包括在由于缺少某些组件而无法创建 PVC 的情况下发出警告。</p><p>你可以把 alpha 版本的<a href=https://github.com/kubernetes-csi/volume-data-source-validator>卷数据源验证器</a>
控制器安装到你的集群中。
如果没有填充器处理该数据源的情况下，该控制器会在 PVC 上产生警告事件。
当一个合适的填充器被安装到 PVC 上时，该控制器的职责是上报与卷创建有关的事件，以及在该过程中发生的问题。</p><h2 id=writing-portable-configuration>编写可移植的配置</h2><p>如果你要编写配置模板和示例用来在很多集群上运行并且需要持久性存储，建议你使用以下模式：</p><ul><li>将 PersistentVolumeClaim 对象包含到你的配置包（Bundle）中，和 Deployment
以及 ConfigMap 等放在一起。</li><li>不要在配置中包含 PersistentVolume 对象，因为对配置进行实例化的用户很可能
没有创建 PersistentVolume 的权限。</li></ul><ul><li>为用户提供在实例化模板时指定存储类名称的能力。<ul><li>仍按用户提供存储类名称，将该名称放到 <code>persistentVolumeClaim.storageClassName</code> 字段中。
这样会使得 PVC 在集群被管理员启用了存储类支持时能够匹配到正确的存储类，</li><li>如果用户未指定存储类名称，将 <code>persistentVolumeClaim.storageClassName</code> 留空（nil）。
这样，集群会使用默认 <code>StorageClass</code> 为用户自动制备一个存储卷。
很多集群环境都配置了默认的 <code>StorageClass</code>，或者管理员也可以自行创建默认的
<code>StorageClass</code>。</li></ul></li></ul><ul><li>在你的工具链中，监测经过一段时间后仍未被绑定的 PVC 对象，要让用户知道这些对象，
因为这可能意味着集群不支持动态存储（因而用户必须先创建一个匹配的 PV），或者
集群没有配置存储系统（因而用户无法配置需要 PVC 的工作负载配置）。</li></ul><h2 id=接下来>接下来</h2><ul><li>进一步了解<a href=/zh-cn/docs/tasks/configure-pod-container/configure-persistent-volume-storage/#create-a-persistentvolume>创建持久卷</a>。</li><li>进一步学习<a href=/zh-cn/docs/tasks/configure-pod-container/configure-persistent-volume-storage/#create-a-persistentvolumeclaim>创建 PVC 申领</a>。</li><li>阅读<a href=https://git.k8s.io/design-proposals-archive/storage/persistent-storage.md>持久存储的设计文档</a>。</li></ul><h3 id=reference>API 参考</h3><p>阅读以下页面中描述的 API：</p><ul><li><a href=/zh-cn/docs/reference/kubernetes-api/config-and-storage-resources/persistent-volume-v1/><code>PersistentVolume</code></a></li><li><a href=/zh-cn/docs/reference/kubernetes-api/config-and-storage-resources/persistent-volume-claim-v1/><code>PersistentVolumeClaim</code></a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-2db414b26d4daec3ebed19dd837830c3>3 - 投射卷</h1><p>本文档描述 Kubernetes 中的<strong>投射卷（Projected Volumes）</strong>。
建议先熟悉<a href=/zh-cn/docs/concepts/storage/volumes/>卷</a>概念。</p><h2 id=introduction>介绍</h2><p>一个 <code>projected</code> 卷可以将若干现有的卷源映射到同一个目录之上。</p><p>目前，以下类型的卷源可以被投射：</p><ul><li><a href=/zh-cn/docs/concepts/storage/volumes/#secret><code>secret</code></a></li><li><a href=/zh-cn/docs/concepts/storage/volumes/#downwardapi><code>downwardAPI</code></a></li><li><a href=/zh-cn/docs/concepts/storage/volumes/#configmap><code>configMap</code></a></li><li><a href=#serviceaccounttoken><code>serviceAccountToken</code></a></li></ul><p>所有的卷源都要求处于 Pod 所在的同一个名字空间内。更多详细信息，
可参考<a href=https://git.k8s.io/design-proposals-archive/node/all-in-one-volume.md>一体化卷</a>设计文档。</p><h3 id=example-configuration-secret-downwardapi-configmap>带有 Secret、DownwardAPI 和 ConfigMap 的配置示例</h3><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/pods/storage/projected-secret-downwardapi-configmap.yaml download=pods/storage/projected-secret-downwardapi-configmap.yaml><code>pods/storage/projected-secret-downwardapi-configmap.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-storage-projected-secret-downwardapi-configmap-yaml")' title="Copy pods/storage/projected-secret-downwardapi-configmap.yaml to clipboard"></img></div><div class=includecode id=pods-storage-projected-secret-downwardapi-configmap-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>volume-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>container-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>all-in-one<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/projected-volume&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>all-in-one<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>projected</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>sources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>username<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>my-group/my-username<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>downwardAPI</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- <span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;labels&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>fieldRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>fieldPath</span>:<span style=color:#bbb> </span>metadata.labels<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- <span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;cpu_limit&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>resourceFieldRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>containerName</span>:<span style=color:#bbb> </span>container-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>resource</span>:<span style=color:#bbb> </span>limits.cpu<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>configMap</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myconfigmap<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>my-group/my-config<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><h3 id=example-configuration-secrets-nondefault-permission-mode>带有非默认权限模式设置的 Secret 的配置示例</h3><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/pods/storage/projected-secrets-nondefault-permission-mode.yaml download=pods/storage/projected-secrets-nondefault-permission-mode.yaml><code>pods/storage/projected-secrets-nondefault-permission-mode.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-storage-projected-secrets-nondefault-permission-mode-yaml")' title="Copy pods/storage/projected-secrets-nondefault-permission-mode.yaml to clipboard"></img></div><div class=includecode id=pods-storage-projected-secrets-nondefault-permission-mode-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>volume-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>container-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>all-in-one<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/projected-volume&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>all-in-one<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>projected</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>sources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>username<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>my-group/my-username<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>password<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>my-group/my-password<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>mode</span>:<span style=color:#bbb> </span><span style=color:#666>511</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>每个被投射的卷源都列举在规约中的 <code>sources</code> 下面。参数几乎相同，只有两个例外：</p><ul><li>对于 Secret，<code>secretName</code> 字段被改为 <code>name</code> 以便于 ConfigMap 的命名一致；</li><li><code>defaultMode</code> 只能在投射层级设置，不能在卷源层级设置。不过，正如上面所展示的，
你可以显式地为每个投射单独设置 <code>mode</code> 属性。</li></ul><h2 id=serviceaccounttoken>serviceAccountToken 投射卷</h2><p>你可以将当前<a href=/zh-cn/docs/reference/access-authn-authz/authentication/#service-account-tokens>服务账号</a>的令牌注入到
Pod 中特定路径下。例如：</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/pods/storage/projected-service-account-token.yaml download=pods/storage/projected-service-account-token.yaml><code>pods/storage/projected-service-account-token.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-storage-projected-service-account-token-yaml")' title="Copy pods/storage/projected-service-account-token.yaml to clipboard"></img></div><div class=includecode id=pods-storage-projected-service-account-token-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>sa-token-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>container-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>token-vol<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/service-account&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>serviceAccountName</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>token-vol<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>projected</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>sources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>serviceAccountToken</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>audience</span>:<span style=color:#bbb> </span>api<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>expirationSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>3600</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>token<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>示例 Pod 中包含一个投射卷，其中包含注入的服务账号令牌。
此 Pod 中的容器可以使用该令牌访问 Kubernetes API 服务器， 使用
<a href=/zh-cn/docs/tasks/configure-pod-container/configure-service-account/>Pod 的 ServiceAccount</a>
进行身份验证。<code>audience</code> 字段包含令牌所针对的受众。
收到令牌的主体必须使用令牌受众中所指定的某个标识符来标识自身，否则应该拒绝该令牌。
此字段是可选的，默认值为 API 服务器的标识。</p><p>字段 <code>expirationSeconds</code> 是服务账号令牌预期的生命期长度。默认值为 1 小时，
必须至少为 10 分钟（600 秒）。管理员也可以通过设置 API 服务器的命令行参数
<code>--service-account-max-token-expiration</code> 来为其设置最大值上限。
<code>path</code> 字段给出与投射卷挂载点之间的相对路径。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>以 <a href=/zh-cn/docs/concepts/storage/volumes/#using-subpath><code>subPath</code></a>
形式使用投射卷源的容器无法收到对应卷源的更新。</div><h2 id=securitycontext-interactions>与 SecurityContext 间的关系</h2><p>关于在投射的服务账号卷中处理文件访问权限的<a href=https://git.k8s.io/enhancements/keps/sig-storage/2451-service-account-token-volumes#proposal>提案</a>
介绍了如何使得所投射的文件具有合适的属主访问权限。</p><h3 id=linux>Linux</h3><p>在包含了投射卷并在
<a href=/zh-cn/docs/reference/kubernetes-api/workload-resources/pod-v1/#security-context><code>SecurityContext</code></a>
中设置了 <code>RunAsUser</code> 属性的 Linux Pod 中，投射文件具有正确的属主属性设置，
其中包含了容器用户属主。</p><p>当 Pod 中的所有容器在其
<a href=/zh-cn/docs/reference/kubernetes-api/workload-resources/pod-v1/#security-context><code>PodSecurityContext</code></a>
或容器
<a href=/zh-cn/docs/reference/kubernetes-api/workload-resources/pod-v1/#security-context-1><code>SecurityContext</code></a>
中设置了相同的 <code>runAsUser</code> 时，kubelet 将确保 <code>serviceAccountToken</code>
卷的内容归该用户所有，并且令牌文件的权限模式会被设置为 <code>0600</code>。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>在某 Pod 被创建后为其添加的<a class=glossary-tooltip title='你可以在 Pod 中临时运行的一种容器类型' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/workloads/pods/ephemeral-containers/ target=_blank aria-label=临时容器>临时容器</a><strong>不会</strong>更改创建该
Pod 时设置的卷权限。</p><p>如果 Pod 的 <code>serviceAccountToken</code> 卷权限被设为 <code>0600</code>
是因为 Pod 中的其他所有容器都具有相同的 <code>runAsUser</code>，
则临时容器必须使用相同的 <code>runAsUser</code> 才能读取令牌。</p></div><h3 id=windows>Windows</h3><p>在包含了投射卷并在 <code>SecurityContext</code> 中设置了 <code>RunAsUsername</code> 的 Windows Pod 中,
由于 Windows 中用户账号的管理方式问题，文件的属主无法正确设置。
Windows 在名为安全账号管理器（Security Account Manager，SAM）
的数据库中保存本地用户和组信息。每个容器会维护其自身的 SAM 数据库实例，
宿主系统无法窥视到容器运行期间数据库内容。Windows 容器被设计用来运行操作系统的用户态部分，
与宿主系统之间隔离，因此维护了一个虚拟的 SAM 数据库。
所以，在宿主系统上运行的 kubelet 无法动态为虚拟的容器账号配置宿主文件的属主。
如果需要将宿主机器上的文件与容器共享，建议将它们放到挂载于 <code>C:\</code> 之外的独立卷中。</p><p>默认情况下，所投射的文件会具有如下例所示的属主属性设置：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-powershell data-lang=powershell><span style=display:flex><span><span style=color:#a2f>PS </span>C:\&gt; <span style=color:#a2f>Get-Acl</span> C:\var\run\secrets\kubernetes.io\serviceaccount\..2021_08_31_22_22_18.<span style=color:#666>318230061</span>\ca.crt | <span style=color:#a2f>Format-List</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Path   <span>:</span> Microsoft.PowerShell.Core\FileSystem::C:\var\run\secrets\kubernetes.io\serviceaccount\..2021_08_31_22_22_18.<span style=color:#666>318230061</span>\ca.crt
</span></span><span style=display:flex><span>Owner  <span>:</span> BUILTIN\Administrators
</span></span><span style=display:flex><span><span style=color:#a2f>Group </span> <span>:</span> NT AUTHORITY\SYSTEM
</span></span><span style=display:flex><span>Access <span>:</span> NT AUTHORITY\SYSTEM Allow  FullControl
</span></span><span style=display:flex><span>         BUILTIN\Administrators Allow  FullControl
</span></span><span style=display:flex><span>         BUILTIN\Users Allow  ReadAndExecute, Synchronize
</span></span><span style=display:flex><span>Audit  <span>:</span>
</span></span><span style=display:flex><span>Sddl   <span>:</span> O:BAG<span>:</span>SYD<span>:</span>AI(A;ID;FA;;;SY)(A;ID;FA;;;BA)(A;ID;0x1200a9;;;BU)
</span></span></code></pre></div><p>这意味着，所有类似 <code>ContainerAdministrator</code> 的管理员用户都具有读、写和执行访问权限，
而非管理员用户将具有读和执行访问权限。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>总体而言，为容器授予访问宿主系统的权限这种做法是不推荐的，因为这样做可能会打开潜在的安全性攻击之门。</p><p>在创建 Windows Pod 时，如果在其 <code>SecurityContext</code> 中设置了 <code>RunAsUser</code>，
Pod 会一直阻塞在 <code>ContainerCreating</code> 状态。因此，建议不要在 Windows
节点上使用仅针对 Linux 的 <code>RunAsUser</code> 选项。</p></div></div><div class=td-content style=page-break-before:always><h1 id=pg-df33eab51202c17bb0fe551d1d5cc5d2>4 - 临时卷</h1><p>本文档描述 Kubernetes 中的 <strong>临时卷（Ephemeral Volume）</strong>。
建议先了解<a href=/zh-cn/docs/concepts/storage/volumes/>卷</a>，特别是 PersistentVolumeClaim 和 PersistentVolume。</p><p>有些应用程序需要额外的存储，但并不关心数据在重启后是否仍然可用。
例如，缓存服务经常受限于内存大小，而且可以将不常用的数据转移到比内存慢的存储中，对总体性能的影响并不大。</p><p>另有些应用程序需要以文件形式注入的只读数据，比如配置数据或密钥。</p><p><strong>临时卷</strong> 就是为此类用例设计的。因为卷会遵从 Pod 的生命周期，与 Pod 一起创建和删除，
所以停止和重新启动 Pod 时，不会受持久卷在何处可用的限制。</p><p>临时卷在 Pod 规约中以 <strong>内联</strong> 方式定义，这简化了应用程序的部署和管理。</p><h3 id=types-of-ephemeral-volumes>临时卷的类型</h3><p>Kubernetes 为了不同的用途，支持几种不同类型的临时卷：</p><ul><li><a href=/zh-cn/docs/concepts/storage/volumes/#emptydir>emptyDir</a>：
Pod 启动时为空，存储空间来自本地的 kubelet 根目录（通常是根磁盘）或内存</li><li><a href=/zh-cn/docs/concepts/storage/volumes/#configmap>configMap</a>、
<a href=/zh-cn/docs/concepts/storage/volumes/#downwardapi>downwardAPI</a>、
<a href=/zh-cn/docs/concepts/storage/volumes/#secret>secret</a>：
将不同类型的 Kubernetes 数据注入到 Pod 中</li><li><a href=/zh-cn/docs/concepts/storage/volumes/#csi-ephemeral-volumes>CSI 临时卷</a>：
类似于前面的卷类型，但由专门<a href=https://kubernetes-csi.github.io/docs/drivers.html>支持此特性</a>
的指定
<a href=https://github.com/container-storage-interface/spec/blob/master/spec.md>CSI 驱动程序</a>提供</li><li><a href=#generic-ephemeral-volumes>通用临时卷</a>：
它可以由所有支持持久卷的存储驱动程序提供</li></ul><p><code>emptyDir</code>、<code>configMap</code>、<code>downwardAPI</code>、<code>secret</code> 是作为
<a href=/zh-cn/docs/concepts/configuration/manage-resources-containers/#local-ephemeral-storage>本地临时存储</a>
提供的。它们由各个节点上的 kubelet 管理。</p><p>CSI 临时卷 <strong>必须</strong> 由第三方 CSI 存储驱动程序提供。</p><p>通用临时卷 <strong>可以</strong> 由第三方 CSI 存储驱动程序提供，也可以由支持动态制备的任何其他存储驱动程序提供。
一些专门为 CSI 临时卷编写的 CSI 驱动程序，不支持动态制备：因此这些驱动程序不能用于通用临时卷。</p><p>使用第三方驱动程序的优势在于，它们可以提供 Kubernetes 本身不支持的功能，
例如，与 kubelet 管理的磁盘具有不同性能特征的存储，或者用来注入不同的数据。</p><h3 id=csi-ephemeral-volumes>CSI 临时卷</h3><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.25 [stable]</code></div><div class="alert alert-info note callout" role=alert><strong>说明：</strong> 只有一部分 CSI 驱动程序支持 CSI 临时卷。Kubernetes CSI
<a href=https://kubernetes-csi.github.io/docs/drivers.html>驱动程序列表</a>
显示了支持临时卷的驱动程序。</div><p>从概念上讲，CSI 临时卷类似于 <code>configMap</code>、<code>downwardAPI</code> 和 <code>secret</code> 类型的卷：
在各个本地节点管理卷的存储，并在 Pod 调度到节点后与其他本地资源一起创建。
在这个阶段，Kubernetes 没有重新调度 Pod 的概念。卷创建不太可能失败，否则 Pod 启动将会受阻。
特别是，这些卷 <strong>不</strong> 支持<a href=/zh-cn/docs/concepts/storage/storage-capacity/>感知存储容量的 Pod 调度</a>。
它们目前也没包括在 Pod 的存储资源使用限制中，因为 kubelet 只能对它自己管理的存储强制执行。</p><p>下面是使用 CSI 临时存储的 Pod 的示例清单：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-csi-app<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/data&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-csi-inline-vol<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;sleep&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;1000000&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-csi-inline-vol<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>csi</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>driver</span>:<span style=color:#bbb> </span>inline.storage.kubernetes.io<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeAttributes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>foo</span>:<span style=color:#bbb> </span>bar<span style=color:#bbb>
</span></span></span></code></pre></div><p><code>volumeAttributes</code> 决定驱动程序准备什么样的卷。每个驱动程序的属性不尽相同，没有实现标准化。
有关进一步的说明，请参阅每个 CSI 驱动程序的文档。</p><h3 id=csi-driver-restrictions>CSI 驱动程序限制</h3><p>CSI 临时卷允许用户直接向 CSI 驱动程序提供 <code>volumeAttributes</code>，它会作为 Pod 规约的一部分。
有些 <code>volumeAttributes</code> 通常仅限于管理员使用，允许这一类 <code>volumeAttributes</code> 的 CSI 驱动程序不适合在内联临时卷中使用。
例如，通常在 StorageClass 中定义的参数不应通过使用内联临时卷向用户公开。</p><p>如果集群管理员需要限制在 Pod 规约中作为内联卷使用的 CSI 驱动程序，可以这样做：</p><ul><li>从 CSIDriver 规约的 <code>volumeLifecycleModes</code> 中删除 <code>Ephemeral</code>，这可以防止驱动程序被用作内联临时卷。</li><li>使用<a href=/zh-cn/docs/reference/access-authn-authz/extensible-admission-controllers/>准入 Webhook</a>
来限制如何使用此驱动程序。</li></ul><h3 id=generic-ephemeral-volumes>通用临时卷</h3><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.23 [stable]</code></div><p>通用临时卷类似于 <code>emptyDir</code> 卷，因为它为每个 Pod 提供临时数据存放目录，
在最初制备完毕时一般为空。不过通用临时卷也有一些额外的功能特性：</p><ul><li>存储可以是本地的，也可以是网络连接的。</li><li>卷可以有固定的大小，Pod 不能超量使用。</li><li>卷可能有一些初始数据，这取决于驱动程序和参数。</li></ul><ul><li>支持典型的卷操作，前提是相关的驱动程序也支持该操作，包括
<a href=/zh-cn/docs/concepts/storage/volume-snapshots/>快照</a>、
<a href=/zh-cn/docs/concepts/storage/volume-pvc-datasource/>克隆</a>、
<a href=/zh-cn/docs/concepts/storage/persistent-volumes/#expanding-persistent-volumes-claims>调整大小</a>和
<a href=/zh-cn/docs/concepts/storage/storage-capacity/>存储容量跟踪</a>）。</li></ul><p>示例：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-app<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/scratch&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>scratch-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;sleep&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;1000000&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>scratch-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>ephemeral</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>volumeClaimTemplate</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>my-frontend-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;ReadWriteOnce&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;scratch-storage-class&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>1Gi<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=lifecycle-and-persistentvolumeclaim>生命周期和 PersistentVolumeClaim</h3><p>关键的设计思想是在 Pod 的卷来源中允许使用
<a href=/docs/reference/generated/kubernetes-api/v1.25/#ephemeralvolumesource-v1alpha1-core>卷申领的参数</a>。
PersistentVolumeClaim 的标签、注解和整套字段集均被支持。
创建这样一个 Pod 后，
临时卷控制器在 Pod 所属的命名空间中创建一个实际的 PersistentVolumeClaim 对象，
并确保删除 Pod 时，同步删除 PersistentVolumeClaim。</p><p>如上设置将触发卷的绑定与/或制备，相应动作或者在
<a class=glossary-tooltip title='StorageClass 是管理员用来描述可用的不同存储类型的一种方法。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/storage/storage-classes/ target=_blank aria-label=StorageClass>StorageClass</a>
使用即时卷绑定时立即执行，
或者当 Pod 被暂时性调度到某节点时执行 (<code>WaitForFirstConsumer</code> 卷绑定模式)。
对于通用的临时卷，建议采用后者，这样调度器就可以自由地为 Pod 选择合适的节点。
对于即时绑定，调度器则必须选出一个节点，使得在卷可用时，能立即访问该卷。</p><p>就<a href=/zh-cn/docs/concepts/architecture/garbage-collection/#owners-dependents>资源所有权</a>而言，
拥有通用临时存储的 Pod 是提供临时存储 (ephemeral storage) 的 PersistentVolumeClaim 的所有者。
当 Pod 被删除时，Kubernetes 垃圾收集器会删除 PVC，
然后 PVC 通常会触发卷的删除，因为存储类的默认回收策略是删除卷。
你可以使用带有 <code>retain</code> 回收策略的 StorageClass 创建准临时 (quasi-ephemeral) 本地存储：
该存储比 Pod 寿命长，在这种情况下，你需要确保单独进行卷清理。</p><p>当这些 PVC 存在时，它们可以像其他 PVC 一样使用。
特别是，它们可以被引用作为批量克隆或快照的数据源。
PVC 对象还保持着卷的当前状态。</p><h3 id=persistentvolumeclaim-naming>PersistentVolumeClaim 的命名</h3><p>自动创建的 PVC 采取确定性的命名机制：名称是 Pod 名称和卷名称的组合，中间由连字符(<code>-</code>)连接。
在上面的示例中，PVC 将命名为 <code>my-app-scratch-volume</code> 。
这种确定性的命名机制使得与 PVC 交互变得更容易，因为一旦知道 Pod 名称和卷名，就不必搜索它。</p><p>这种命名机制也引入了潜在的冲突，
不同的 Pod 之间（名为 “Pod-a” 的 Pod 挂载名为 "scratch" 的卷，
和名为 "pod" 的 Pod 挂载名为 “a-scratch” 的卷，这两者均会生成名为
"pod-a-scratch" 的 PVC），或者在 Pod 和手工创建的 PVC 之间可能出现冲突。</p><p>以下冲突会被检测到：如果 PVC 是为 Pod 创建的，那么它只用于临时卷。
此检测基于所有权关系。现有的 PVC 不会被覆盖或修改。
但这并不能解决冲突，因为如果没有正确的 PVC，Pod 就无法启动。</p><div class="alert alert-warning caution callout" role=alert><strong>注意：</strong> 当同一个命名空间中命名 Pod 和卷时，要小心，以防止发生此类冲突。</div><h3 id=security>安全</h3><p>启用 GenericEphemeralVolume 特性会有一些副作用，用户能创建 Pod 就能间接地创建 PVC，
即使他们没有权限直接创建 PVC。
集群管理员必须意识到这一点。
如果这不符合他们的安全模型，他们应该使用<a href=/zh-cn/docs/reference/access-authn-authz/extensible-admission-controllers/>准入 Webhook</a>
拒绝包含通用临时卷的对象，例如 Pod。</p><p>正常的 <a href=/zh-cn/docs/concepts/policy/resource-quotas/#storage-resource-quota>PVC 的名字空间配额</a>
仍然有效，因此即使允许用户使用这种新机制，他们也不能使用它来规避其他策略。</p><h2 id=接下来>接下来</h2><h3 id=ephemeral-volumes-managed-by-kubelet>kubelet 管理的临时卷</h3><p>参阅<a href=/zh-cn/docs/concepts/configuration/manage-resources-containers/#local-ephemeral-storage>本地临时存储</a>。</p><h3 id=csi-ephemeral-volumes>CSI 临时卷</h3><ul><li>有关设计的更多信息，参阅
<a href=https://github.com/kubernetes/enhancements/blob/ad6021b3d61a49040a3f835e12c8bb5424db2bbb/keps/sig-storage/20190122-csi-inline-volumes.md>Ephemeral Inline CSI volumes KEP</a>。</li><li>本特性下一步开发的更多信息，参阅
<a href=https://github.com/kubernetes/enhancements/issues/596>enhancement tracking issue #596</a>。</li></ul><h3 id=generic-ephemeral-volumes>通用临时卷</h3><ul><li>有关设计的更多信息，参阅
<a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-storage/1698-generic-ephemeral-volumes/README.md>Generic ephemeral inline volumes KEP</a>。</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-f0276d05eef111249272a1c932a91e2c>5 - 存储类</h1><p>本文描述了 Kubernetes 中 StorageClass 的概念。
建议先熟悉<a href=/zh-cn/docs/concepts/storage/volumes/>卷</a>和<a href=/zh-cn/docs/concepts/storage/persistent-volumes>持久卷</a>的概念。</p><h2 id=introduction>介绍</h2><p>StorageClass 为管理员提供了描述存储 "类" 的方法。
不同的类型可能会映射到不同的服务质量等级或备份策略，或是由集群管理员制定的任意策略。
Kubernetes 本身并不清楚各种类代表的什么。这个类的概念在其他存储系统中有时被称为 "配置文件"。</p><h2 id=the-storageclass-resource>StorageClass 资源</h2><p>每个 StorageClass 都包含 <code>provisioner</code>、<code>parameters</code> 和 <code>reclaimPolicy</code> 字段，
这些字段会在 StorageClass 需要动态制备 PersistentVolume 时会使用到。</p><p>StorageClass 对象的命名很重要，用户使用这个命名来请求生成一个特定的类。
当创建 StorageClass 对象时，管理员设置 StorageClass 对象的命名和其他参数，一旦创建了对象就不能再对其更新。</p><p>管理员可以为没有申请绑定到特定 StorageClass 的 PVC 指定一个默认的存储类：
更多详情请参阅
<a href=/zh-cn/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims>PersistentVolumeClaim 章节</a>。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>standard<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/aws-ebs<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>gp2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>reclaimPolicy</span>:<span style=color:#bbb> </span>Retain<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>allowVolumeExpansion</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>mountOptions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- debug<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>volumeBindingMode</span>:<span style=color:#bbb> </span>Immediate<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=provisioner>存储制备器</h3><p>每个 StorageClass 都有一个制备器（Provisioner），用来决定使用哪个卷插件制备 PV。
该字段必须指定。</p><table><thead><tr><th style=text-align:left>卷插件</th><th style=text-align:center>内置制备器</th><th style=text-align:center>配置例子</th></tr></thead><tbody><tr><td style=text-align:left>AWSElasticBlockStore</td><td style=text-align:center>✓</td><td style=text-align:center><a href=#aws-ebs>AWS EBS</a></td></tr><tr><td style=text-align:left>AzureFile</td><td style=text-align:center>✓</td><td style=text-align:center><a href=#azure-%E6%96%87%E4%BB%B6>Azure File</a></td></tr><tr><td style=text-align:left>AzureDisk</td><td style=text-align:center>✓</td><td style=text-align:center><a href=#azure-%E7%A3%81%E7%9B%98>Azure Disk</a></td></tr><tr><td style=text-align:left>CephFS</td><td style=text-align:center>-</td><td style=text-align:center>-</td></tr><tr><td style=text-align:left>Cinder</td><td style=text-align:center>✓</td><td style=text-align:center><a href=#openstack-cinder>OpenStack Cinder</a></td></tr><tr><td style=text-align:left>FC</td><td style=text-align:center>-</td><td style=text-align:center>-</td></tr><tr><td style=text-align:left>FlexVolume</td><td style=text-align:center>-</td><td style=text-align:center>-</td></tr><tr><td style=text-align:left>GCEPersistentDisk</td><td style=text-align:center>✓</td><td style=text-align:center><a href=#gce-pd>GCE PD</a></td></tr><tr><td style=text-align:left>Glusterfs</td><td style=text-align:center>✓</td><td style=text-align:center><a href=#glusterfs>Glusterfs</a></td></tr><tr><td style=text-align:left>iSCSI</td><td style=text-align:center>-</td><td style=text-align:center>-</td></tr><tr><td style=text-align:left>NFS</td><td style=text-align:center>-</td><td style=text-align:center><a href=#nfs>NFS</a></td></tr><tr><td style=text-align:left>RBD</td><td style=text-align:center>✓</td><td style=text-align:center><a href=#ceph-rbd>Ceph RBD</a></td></tr><tr><td style=text-align:left>VsphereVolume</td><td style=text-align:center>✓</td><td style=text-align:center><a href=#vsphere>vSphere</a></td></tr><tr><td style=text-align:left>PortworxVolume</td><td style=text-align:center>✓</td><td style=text-align:center><a href=#portworx-%E5%8D%B7>Portworx Volume</a></td></tr><tr><td style=text-align:left>Local</td><td style=text-align:center>-</td><td style=text-align:center><a href=#%E6%9C%AC%E5%9C%B0>Local</a></td></tr></tbody></table><p>你不限于指定此处列出的 "内置" 制备器（其名称前缀为 "kubernetes.io" 并打包在 Kubernetes 中）。
你还可以运行和指定外部制备器，这些独立的程序遵循由 Kubernetes
定义的<a href=https://git.k8s.io/design-proposals-archive/storage/volume-provisioning.md>规范</a>。
外部供应商的作者完全可以自由决定他们的代码保存于何处、打包方式、运行方式、使用的插件（包括 Flex）等。
代码仓库 <a href=https://github.com/kubernetes-sigs/sig-storage-lib-external-provisioner>kubernetes-sigs/sig-storage-lib-external-provisioner</a>
包含一个用于为外部制备器编写功能实现的类库。你可以访问代码仓库
<a href=https://github.com/kubernetes-sigs/sig-storage-lib-external-provisioner>kubernetes-sigs/sig-storage-lib-external-provisioner</a>
了解外部驱动列表。</p><p>例如，NFS 没有内部制备器，但可以使用外部制备器。
也有第三方存储供应商提供自己的外部制备器。</p><h3 id=reclaim-policy>回收策略</h3><p>由 StorageClass 动态创建的 PersistentVolume 会在类的 <code>reclaimPolicy</code> 字段中指定回收策略，可以是
<code>Delete</code> 或者 <code>Retain</code>。如果 StorageClass 对象被创建时没有指定 <code>reclaimPolicy</code>，它将默认为 <code>Delete</code>。</p><p>通过 StorageClass 手动创建并管理的 PersistentVolume 会使用它们被创建时指定的回收策略。</p><h3 id=allow-volume-expansion>允许卷扩展</h3><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.11 [beta]</code></div><p>PersistentVolume 可以配置为可扩展。将此功能设置为 <code>true</code> 时，允许用户通过编辑相应的 PVC 对象来调整卷大小。</p><p>当下层 StorageClass 的 <code>allowVolumeExpansion</code> 字段设置为 true 时，以下类型的卷支持卷扩展。</p><table><caption style=display:none>Table of Volume types and the version of Kubernetes they require</caption><thead><tr><th style=text-align:left>卷类型</th><th style=text-align:left>Kubernetes 版本要求</th></tr></thead><tbody><tr><td style=text-align:left>gcePersistentDisk</td><td style=text-align:left>1.11</td></tr><tr><td style=text-align:left>awsElasticBlockStore</td><td style=text-align:left>1.11</td></tr><tr><td style=text-align:left>Cinder</td><td style=text-align:left>1.11</td></tr><tr><td style=text-align:left>glusterfs</td><td style=text-align:left>1.11</td></tr><tr><td style=text-align:left>rbd</td><td style=text-align:left>1.11</td></tr><tr><td style=text-align:left>Azure File</td><td style=text-align:left>1.11</td></tr><tr><td style=text-align:left>Azure Disk</td><td style=text-align:left>1.11</td></tr><tr><td style=text-align:left>Portworx</td><td style=text-align:left>1.11</td></tr><tr><td style=text-align:left>FlexVolume</td><td style=text-align:left>1.13</td></tr><tr><td style=text-align:left>CSI</td><td style=text-align:left>1.14 (alpha), 1.16 (beta)</td></tr></tbody></table><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>此功能仅可用于扩容卷，不能用于缩小卷。</div><h3 id=mount-options>挂载选项</h3><p>由 StorageClass 动态创建的 PersistentVolume 将使用类中 <code>mountOptions</code> 字段指定的挂载选项。</p><p>如果卷插件不支持挂载选项，却指定了挂载选项，则制备操作会失败。
挂载选项在 StorageClass 和 PV 上都不会做验证，如果其中一个挂载选项无效，那么这个 PV 挂载操作就会失败。</p><h3 id=volume-binding-mode>卷绑定模式</h3><p><code>volumeBindingMode</code>
字段控制了<a href=/zh-cn/docs/concepts/storage/persistent-volumes/#provisioning>卷绑定和动态制备</a>应该发生在什么时候。</p><p>默认情况下，<code>Immediate</code> 模式表示一旦创建了 PersistentVolumeClaim 也就完成了卷绑定和动态制备。
对于由于拓扑限制而非集群所有节点可达的存储后端，PersistentVolume
会在不知道 Pod 调度要求的情况下绑定或者制备。</p><p>集群管理员可以通过指定 <code>WaitForFirstConsumer</code> 模式来解决此问题。
该模式将延迟 PersistentVolume 的绑定和制备，直到使用该 PersistentVolumeClaim 的 Pod 被创建。
PersistentVolume 会根据 Pod 调度约束指定的拓扑来选择或制备。
这些包括但不限于<a href=/zh-cn/docs/concepts/configuration/manage-resources-containers/>资源需求</a>、
<a href=/zh-cn/docs/concepts/scheduling-eviction/assign-pod-node/#nodeselector>节点筛选器</a>、
<a href=/zh-cn/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity/>Pod 亲和性和互斥性</a>、
以及<a href=/zh-cn/docs/concepts/scheduling-eviction/taint-and-toleration>污点和容忍度</a>。</p><p>以下插件支持动态制备的 <code>WaitForFirstConsumer</code> 模式:</p><ul><li><a href=#aws-ebs>AWSElasticBlockStore</a></li><li><a href=#gce-pd>GCEPersistentDisk</a></li><li><a href=#azure-disk>AzureDisk</a></li></ul><p>以下插件支持预创建绑定 PersistentVolume 的 <code>WaitForFirstConsumer</code> 模式：</p><ul><li>上述全部</li><li><a href=#local>Local</a></li></ul><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.17 [stable]</code></div><p>动态制备和预先创建的 PV 也支持 <a href=/zh-cn/docs/concepts/storage/volumes/#csi>CSI 卷</a>，
但是你需要查看特定 CSI 驱动的文档以查看其支持的拓扑键名和例子。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>如果你选择使用 <code>WaitForFirstConsumer</code>，请不要在 Pod 规约中使用 <code>nodeName</code> 来指定节点亲和性。
如果在这种情况下使用 <code>nodeName</code>，Pod 将会绕过调度程序，PVC 将停留在 <code>pending</code> 状态。</p><p>相反，在这种情况下，你可以使用节点选择器作为主机名，如下所示</p></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>task-pv-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodeSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/hostname</span>:<span style=color:#bbb> </span>kube-01<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>task-pv-storage<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>persistentVolumeClaim</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>claimName</span>:<span style=color:#bbb> </span>task-pv-claim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>task-pv-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;http-server&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/usr/share/nginx/html&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>task-pv-storage<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=allowed-topologies>允许的拓扑结构</h3><p>当集群操作人员使用了 <code>WaitForFirstConsumer</code> 的卷绑定模式，
在大部分情况下就没有必要将制备限制为特定的拓扑结构。
然而，如果还有需要的话，可以使用 <code>allowedTopologies</code>。</p><p>这个例子描述了如何将制备卷的拓扑限制在特定的区域，
在使用时应该根据插件支持情况替换 <code>zone</code> 和 <code>zones</code> 参数。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>standard<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/gce-pd<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>pd-standard<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>volumeBindingMode</span>:<span style=color:#bbb> </span>WaitForFirstConsumer<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>allowedTopologies</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>matchLabelExpressions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>failure-domain.beta.kubernetes.io/zone<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- us-central-1a<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- us-central-1b<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=parameters>参数</h2><p>Storage Classes 的参数描述了存储类的卷。取决于制备器，可以接受不同的参数。
例如，参数 type 的值 io1 和参数 iopsPerGB 特定于 EBS PV。
当参数被省略时，会使用默认值。</p><p>一个 StorageClass 最多可以定义 512 个参数。这些参数对象的总长度不能超过 256 KiB, 包括参数的键和值。</p><h3 id=aws-ebs>AWS EBS</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>slow<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/aws-ebs<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>io1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>iopsPerGB</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;10&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>fsType</span>:<span style=color:#bbb> </span>ext4<span style=color:#bbb>
</span></span></span></code></pre></div><ul><li><code>type</code>：<code>io1</code>，<code>gp2</code>，<code>sc1</code>，<code>st1</code>。详细信息参见
<a href=https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html>AWS 文档</a>。默认值：<code>gp2</code>。</li><li><code>zone</code>(弃用)：AWS 区域。如果没有指定 <code>zone</code> 和 <code>zones</code>，
通常卷会在 Kubernetes 集群节点所在的活动区域中轮询调度分配。
<code>zone</code> 和 <code>zones</code> 参数不能同时使用。</li><li><code>zones</code>(弃用)：以逗号分隔的 AWS 区域列表。
如果没有指定 <code>zone</code> 和 <code>zones</code>，通常卷会在 Kubernetes 集群节点所在的活动区域中轮询调度分配。
<code>zone</code>和<code>zones</code>参数不能同时使用。</li><li><code>iopsPerGB</code>：只适用于 <code>io1</code> 卷。每 GiB 每秒 I/O 操作。
AWS 卷插件将其与请求卷的大小相乘以计算 IOPS 的容量，
并将其限制在 20000 IOPS（AWS 支持的最高值，请参阅
<a href=https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSVolumeTypes.html>AWS 文档</a>）。
这里需要输入一个字符串，即 <code>"10"</code>，而不是 <code>10</code>。</li><li><code>fsType</code>：受 Kubernetes 支持的文件类型。默认值：<code>"ext4"</code>。</li><li><code>encrypted</code>：指定 EBS 卷是否应该被加密。合法值为 <code>"true"</code> 或者 <code>"false"</code>。
这里需要输入字符串，即 <code>"true"</code>, 而非 <code>true</code>。</li><li><code>kmsKeyId</code>：可选。加密卷时使用密钥的完整 Amazon 资源名称。
如果没有提供，但 <code>encrypted</code> 值为 true，AWS 生成一个密钥。关于有效的 ARN 值，请参阅 AWS 文档。</li></ul><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p><code>zone</code> 和 <code>zones</code> 已被弃用并被<a href=#allowed-topologies>允许的拓扑结构</a>取代。</div><h3 id=gce-pd>GCE PD</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>slow<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/gce-pd<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>pd-standard<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span><span style=color:green;font-weight:700>fstype</span>:<span style=color:#bbb> </span>ext4<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replication-type</span>:<span style=color:#bbb> </span>none<span style=color:#bbb>
</span></span></span></code></pre></div><ul><li><code>type</code>：<code>pd-standard</code> 或者 <code>pd-ssd</code>。默认：<code>pd-standard</code></li><li><code>zone</code>(弃用)：GCE 区域。如果没有指定 <code>zone</code> 和 <code>zones</code>，
通常卷会在 Kubernetes 集群节点所在的活动区域中轮询调度分配。
<code>zone</code> 和 <code>zones</code> 参数不能同时使用。</li><li><code>zones</code>(弃用)：逗号分隔的 GCE 区域列表。如果没有指定 <code>zone</code> 和 <code>zones</code>，
通常卷会在 Kubernetes 集群节点所在的活动区域中轮询调度（round-robin）分配。
<code>zone</code> 和 <code>zones</code> 参数不能同时使用。</li><li><code>fstype</code>：<code>ext4</code> 或 <code>xfs</code>。 默认：<code>ext4</code>。宿主机操作系统必须支持所定义的文件系统类型。</li><li><code>replication-type</code>：<code>none</code> 或者 <code>regional-pd</code>。默认值：<code>none</code>。</li></ul><p>如果 <code>replication-type</code> 设置为 <code>none</code>，会制备一个常规（当前区域内的）持久化磁盘。</p><p>如果 <code>replication-type</code> 设置为 <code>regional-pd</code>，
会制备一个<a href=https://cloud.google.com/compute/docs/disks/#repds>区域性持久化磁盘（Regional Persistent Disk）</a>。</p><p>强烈建议设置 <code>volumeBindingMode: WaitForFirstConsumer</code>，这样设置后，
当你创建一个 Pod，它使用的 PersistentVolumeClaim 使用了这个 StorageClass，
区域性持久化磁盘会在两个区域里制备。 其中一个区域是 Pod 所在区域。
另一个区域是会在集群管理的区域中任意选择。磁盘区域可以通过 <code>allowedTopologies</code> 加以限制。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p><code>zone</code> 和 <code>zones</code> 已被弃用并被 <a href=#allowed-topologies>allowedTopologies</a> 取代。</div><h3 id=glusterfs>Glusterfs（已弃用）</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>slow<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/glusterfs<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resturl</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;http://127.0.0.1:8081&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clusterid</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;630372ccdc720a92c681fb928f27b53f&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restauthenabled</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restuser</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;admin&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>secretNamespace</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;default&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;heketi-secret&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>gidMin</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;40000&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>gidMax</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;50000&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumetype</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;replicate:3&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><ul><li><code>resturl</code>：制备 gluster 卷的需求的 Gluster REST 服务/Heketi 服务 url。
通用格式应该是 <code>IPaddress:Port</code>，这是 GlusterFS 动态制备器的必需参数。
如果 Heketi 服务在 OpenShift/kubernetes 中安装并暴露为可路由服务，则可以使用类似于
<code>http://heketi-storage-project.cloudapps.mystorage.com</code> 的格式，其中 fqdn 是可解析的 heketi 服务网址。</li><li><code>restauthenabled</code>：Gluster REST 服务身份验证布尔值，用于启用对 REST 服务器的身份验证。
如果此值为 'true'，则必须填写 <code>restuser</code> 和 <code>restuserkey</code> 或 <code>secretNamespace</code> + <code>secretName</code>。
此选项已弃用，当在指定 <code>restuser</code>、<code>restuserkey</code>、<code>secretName</code> 或 <code>secretNamespace</code> 时，身份验证被启用。</li><li><code>restuser</code>：在 Gluster 可信池中有权创建卷的 Gluster REST服务/Heketi 用户。</li><li><code>restuserkey</code>：Gluster REST 服务/Heketi 用户的密码将被用于对 REST 服务器进行身份验证。
此参数已弃用，取而代之的是 <code>secretNamespace</code> + <code>secretName</code>。</li></ul><ul><li><p><code>secretNamespace</code>，<code>secretName</code>：Secret 实例的标识，包含与 Gluster
REST 服务交互时使用的用户密码。
这些参数是可选的，<code>secretNamespace</code> 和 <code>secretName</code> 都省略时使用空密码。
所提供的 Secret 必须将类型设置为 "kubernetes.io/glusterfs"，例如以这种方式创建：</p><pre tabindex=0><code>kubectl create secret generic heketi-secret \
  --type=&#34;kubernetes.io/glusterfs&#34; --from-literal=key=&#39;opensesame&#39; \
  --namespace=default
</code></pre><p>Secret 的例子可以在
<a href=https://github.com/kubernetes/examples/tree/master/staging/persistent-volume-provisioning/glusterfs/glusterfs-secret.yaml>glusterfs-provisioning-secret.yaml</a> 中找到。</p></li></ul><ul><li><code>clusterid</code>：<code>630372ccdc720a92c681fb928f27b53f</code> 是集群的 ID，当制备卷时，
Heketi 将会使用这个文件。它也可以是一个 clusterid 列表，例如：
<code>"8452344e2becec931ece4e33c4674e4e,42982310de6c63381718ccfa6d8cf397"</code>。这个是可选参数。</li><li><code>gidMin</code>，<code>gidMax</code>：StorageClass GID 范围的最小值和最大值。
在此范围（gidMin-gidMax）内的唯一值（GID）将用于动态制备卷。这些是可选的值。
如果不指定，所制备的卷为一个 2000-2147483647 之间的值，这是 gidMin 和
gidMax 的默认值。</li></ul><ul><li><p><code>volumetype</code>：卷的类型及其参数可以用这个可选值进行配置。如果未声明卷类型，则由制备器决定卷的类型。</p><p>例如：</p><ul><li>'Replica volume'：<code>volumetype: replicate:3</code> 其中 '3' 是 replica 数量。</li><li>'Disperse/EC volume'：<code>volumetype: disperse:4:2</code> 其中 '4' 是数据，'2' 是冗余数量。</li><li>'Distribute volume'：<code>volumetype: none</code></li></ul><p>有关可用的卷类型和管理选项，
请参阅<a href=https://access.redhat.com/documentation/en-us/red_hat_gluster_storage/>管理指南</a>。</p><p>更多相关的参考信息，
请参阅<a href=https://github.com/heketi/heketi/wiki/Setting-up-the-topology>如何配置 Heketi</a>。</p><p>当动态制备持久卷时，Gluster 插件自动创建名为 <code>gluster-dynamic-&lt;claimname></code>
的端点和无头服务。在 PVC 被删除时动态端点和无头服务会自动被删除。</p></li></ul><h3 id=nfs>NFS</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example-nfs<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>example.com/external-nfs<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>server</span>:<span style=color:#bbb> </span>nfs-server.example.com<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/share<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;false&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><ul><li><code>server</code>：NFS 服务器的主机名或 IP 地址。</li><li><code>path</code>：NFS 服务器导出的路径。</li><li><code>readOnly</code>：是否将存储挂载为只读的标志（默认为 false）。</li></ul><p>Kubernetes 不包含内部 NFS 驱动。你需要使用外部驱动为 NFS 创建 StorageClass。
这里有些例子：</p><ul><li><a href=https://github.com/kubernetes-sigs/nfs-ganesha-server-and-external-provisioner>NFS Ganesha 服务器和外部驱动</a></li><li><a href=https://github.com/kubernetes-sigs/nfs-subdir-external-provisioner>NFS subdir 外部驱动</a></li></ul><h3 id=openstack-cinder>OpenStack Cinder</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>gold<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/cinder<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>availability</span>:<span style=color:#bbb> </span>nova<span style=color:#bbb>
</span></span></span></code></pre></div><ul><li><code>availability</code>：可用区域。如果没有指定，通常卷会在 Kubernetes 集群节点所在的活动区域中轮转调度。</li></ul><div class="alert alert-info note callout" role=alert><strong>说明：</strong><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes 1.11 [deprecated]</code></div><p>OpenStack 的内部驱动已经被弃用。请使用
<a href=https://github.com/kubernetes/cloud-provider-openstack>OpenStack 的外部云驱动</a>。</div><h3 id=vsphere>vSphere</h3><p>vSphere 存储类有两种制备器：</p><ul><li><a href=#vsphere-provisioner-csi>CSI 制备器</a>：<code>csi.vsphere.vmware.com</code></li><li><a href=#vcp-provisioner>vCP 制备器</a>：<code>kubernetes.io/vsphere-volume</code></li></ul><p>树内制备器已经被
<a href=/blog/2019/12/09/kubernetes-1-17-feature-csi-migration-beta/#why-are-we-migrating-in-tree-plugins-to-csi>弃用</a>。
更多关于 CSI 制备器的详情，请参阅
<a href=https://vsphere-csi-driver.sigs.k8s.io/>Kubernetes vSphere CSI 驱动</a>
和 <a href=/zh-cn/docs/concepts/storage/volumes/#vsphere-csi-migration>vSphereVolume CSI 迁移</a>。</p><h4 id=vsphere-provisioner-csi>CSI 制备器</h4><p>vSphere CSI StorageClass 制备器在 Tanzu Kubernetes 集群下运行。示例请参阅
<a href=https://github.com/kubernetes-sigs/vsphere-csi-driver/blob/master/example/vanilla-k8s-RWM-filesystem-volumes/example-sc.yaml>vSphere CSI 仓库</a>。</p><h4 id=vcp-provisioner>vCP 制备器</h4><p>以下示例使用 VMware Cloud Provider (vCP) StorageClass 制备器。</p><ol><li><p>使用用户指定的磁盘格式创建一个 StorageClass。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fast<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/vsphere-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>diskformat</span>:<span style=color:#bbb> </span>zeroedthick<span style=color:#bbb>
</span></span></span></code></pre></div><p><code>diskformat</code>：<code>thin</code>、<code>zeroedthick</code> 和 <code>eagerzeroedthick</code>。默认值：<code>"thin"</code>。</p></li></ol><ol start=2><li><p>在用户指定的数据存储上创建磁盘格式的 StorageClass。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fast<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/vsphere-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>diskformat</span>:<span style=color:#bbb> </span>zeroedthick<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>datastore</span>:<span style=color:#bbb> </span>VSANDatastore<span style=color:#bbb>
</span></span></span></code></pre></div><p><code>datastore</code>：用户也可以在 StorageClass 中指定数据存储。
卷将在 storage class 中指定的数据存储上创建，在这种情况下是 <code>VSANDatastore</code>。
该字段是可选的。
如果未指定数据存储，则将在用于初始化 vSphere Cloud Provider 的 vSphere
配置文件中指定的数据存储上创建该卷。</p></li></ol><ol start=3><li><p>Kubernetes 中的存储策略管理</p><ul><li><p>使用现有的 vCenter SPBM 策略</p><p>vSphere 用于存储管理的最重要特性之一是基于策略的管理。
基于存储策略的管理（SPBM）是一个存储策略框架，提供单一的统一控制平面的跨越广泛的数据服务和存储解决方案。
SPBM 使得 vSphere 管理员能够克服先期的存储配置挑战，如容量规划、差异化服务等级和管理容量空间。</p><p>SPBM 策略可以在 StorageClass 中使用 <code>storagePolicyName</code> 参数声明。</p></li></ul><ul><li><p>Kubernetes 内的 Virtual SAN 策略支持</p><p>Vsphere Infrastructure（VI）管理员将能够在动态卷配置期间指定自定义 Virtual SAN
存储功能。你现在可以在动态制备卷期间以存储能力的形式定义存储需求，例如性能和可用性。
存储能力需求会转换为 Virtual SAN 策略，之后当持久卷（虚拟磁盘）被创建时，
会将其推送到 Virtual SAN 层。虚拟磁盘分布在 Virtual SAN 数据存储中以满足要求。</p><p>你可以参考<a href=https://github.com/vmware-archive/vsphere-storage-for-kubernetes/blob/fa4c8b8ad46a85b6555d715dd9d27ff69839df53/documentation/policy-based-mgmt.md>基于存储策略的动态制备卷管理</a>，
进一步了解有关持久卷管理的存储策略的详细信息。</p></li></ul></li></ol><p>有几个 <a href=https://github.com/kubernetes/examples/tree/master/staging/volumes/vsphere>vSphere 例子</a>供你在
Kubernetes for vSphere 中尝试进行持久卷管理。</p><h3 id=ceph-rbd>Ceph RBD</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fast<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/rbd<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>monitors</span>:<span style=color:#bbb> </span><span style=color:#666>10.16.153.105</span>:<span style=color:#666>6789</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>adminId</span>:<span style=color:#bbb> </span>kube<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>adminSecretName</span>:<span style=color:#bbb> </span>ceph-secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>adminSecretNamespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>pool</span>:<span style=color:#bbb> </span>kube<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>userId</span>:<span style=color:#bbb> </span>kube<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>userSecretName</span>:<span style=color:#bbb> </span>ceph-secret-user<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>userSecretNamespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>fsType</span>:<span style=color:#bbb> </span>ext4<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>imageFormat</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>imageFeatures</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;layering&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><ul><li><code>monitors</code>：Ceph monitor，逗号分隔。该参数是必需的。</li><li><code>adminId</code>：Ceph 客户端 ID，用于在池 ceph 池中创建映像。默认是 "admin"。</li><li><code>adminSecret</code>：<code>adminId</code> 的 Secret 名称。该参数是必需的。
提供的 secret 必须有值为 "kubernetes.io/rbd" 的 type 参数。</li><li><code>adminSecretNamespace</code>：<code>adminSecret</code> 的命名空间。默认是 "default"。</li><li><code>pool</code>：Ceph RBD 池。默认是 "rbd"。</li><li><code>userId</code>：Ceph 客户端 ID，用于映射 RBD 镜像。默认与 <code>adminId</code> 相同。</li></ul><ul><li><p><code>userSecretName</code>：用于映射 RBD 镜像的 <code>userId</code> 的 Ceph Secret 的名字。
它必须与 PVC 存在于相同的 namespace 中。该参数是必需的。
提供的 secret 必须具有值为 "kubernetes.io/rbd" 的 type 参数，例如以这样的方式创建：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret generic ceph-secret --type<span style=color:#666>=</span><span style=color:#b44>&#34;kubernetes.io/rbd&#34;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --from-literal<span style=color:#666>=</span><span style=color:#b8860b>key</span><span style=color:#666>=</span><span style=color:#b44>&#39;QVFEQ1pMdFhPUnQrSmhBQUFYaERWNHJsZ3BsMmNjcDR6RFZST0E9PQ==&#39;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --namespace<span style=color:#666>=</span>kube-system
</span></span></code></pre></div></li></ul><ul><li><code>userSecretNamespace</code>：<code>userSecretName</code> 的命名空间。</li><li><code>fsType</code>：Kubernetes 支持的 fsType。默认：<code>"ext4"</code>。</li><li><code>imageFormat</code>：Ceph RBD 镜像格式，"1" 或者 "2"。默认值是 "1"。</li><li><code>imageFeatures</code>：这个参数是可选的，只能在你将 <code>imageFormat</code> 设置为 "2" 才使用。
目前支持的功能只是 <code>layering</code>。默认是 ""，没有功能打开。</li></ul><h3 id=azure-disk>Azure 磁盘</h3><h4 id=azure-unmanaged-disk-storage-class>Azure Unmanaged Disk Storage Class（非托管磁盘存储类）</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>slow<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/azure-disk<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>skuName</span>:<span style=color:#bbb> </span>Standard_LRS<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>location</span>:<span style=color:#bbb> </span>eastus<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageAccount</span>:<span style=color:#bbb> </span>azure_storage_account_name<span style=color:#bbb>
</span></span></span></code></pre></div><ul><li><code>skuName</code>：Azure 存储帐户 Sku 层。默认为空。</li><li><code>location</code>：Azure 存储帐户位置。默认为空。</li><li><code>storageAccount</code>：Azure 存储帐户名称。
如果提供存储帐户，它必须位于与集群相同的资源组中，并且 <code>location</code>
是被忽略的。如果未提供存储帐户，则会在与集群相同的资源组中创建新的存储帐户。</li></ul><h4 id=azure-disk-storage-class>Azure 磁盘 Storage Class（从 v1.7.2 开始）</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>slow<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/azure-disk<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageaccounttype</span>:<span style=color:#bbb> </span>Standard_LRS<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>managed<span style=color:#bbb>
</span></span></span></code></pre></div><ul><li><code>storageaccounttype</code>：Azure 存储帐户 Sku 层。默认为空。</li><li><code>kind</code>：可能的值是 <code>shared</code>、<code>dedicated</code> 和 <code>managed</code>（默认）。
当 <code>kind</code> 的值是 <code>shared</code> 时，所有非托管磁盘都在集群的同一个资源组中的几个共享存储帐户中创建。
当 <code>kind</code> 的值是 <code>dedicated</code> 时，将为在集群的同一个资源组中新的非托管磁盘创建新的专用存储帐户。</li><li><code>resourceGroup</code>：指定要创建 Azure 磁盘所属的资源组。必须是已存在的资源组名称。
若未指定资源组，磁盘会默认放入与当前 Kubernetes 集群相同的资源组中。</li></ul><ul><li>Premium VM 可以同时添加 Standard_LRS 和 Premium_LRS 磁盘，而 Standard
虚拟机只能添加 Standard_LRS 磁盘。</li><li>托管虚拟机只能连接托管磁盘，非托管虚拟机只能连接非托管磁盘。</li></ul><h3 id=azure-file>Azure 文件</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>azurefile<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/azure-file<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>skuName</span>:<span style=color:#bbb> </span>Standard_LRS<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>location</span>:<span style=color:#bbb> </span>eastus<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageAccount</span>:<span style=color:#bbb> </span>azure_storage_account_name<span style=color:#bbb>
</span></span></span></code></pre></div><ul><li><code>skuName</code>：Azure 存储帐户 Sku 层。默认为空。</li><li><code>location</code>：Azure 存储帐户位置。默认为空。</li><li><code>storageAccount</code>：Azure 存储帐户名称。默认为空。
如果不提供存储帐户，会搜索所有与资源相关的存储帐户，以找到一个匹配
<code>skuName</code> 和 <code>location</code> 的账号。
如果提供存储帐户，它必须存在于与集群相同的资源组中，<code>skuName</code> 和 <code>location</code> 会被忽略。</li><li><code>secretNamespace</code>：包含 Azure 存储帐户名称和密钥的密钥的名字空间。
默认值与 Pod 相同。</li><li><code>secretName</code>：包含 Azure 存储帐户名称和密钥的密钥的名称。
默认值为 <code>azure-storage-account-&lt;accountName>-secret</code></li><li><code>readOnly</code>：指示是否将存储安装为只读的标志。默认为 false，表示"读/写"挂载。
该设置也会影响VolumeMounts中的 <code>ReadOnly</code> 设置。</li></ul><p>在存储制备期间，为挂载凭证创建一个名为 <code>secretName</code> 的 Secret。如果集群同时启用了
<a href=/zh-cn/docs/reference/access-authn-authz/rbac/>RBAC</a>
和<a href=/zh-cn/docs/reference/access-authn-authz/rbac/#controller-roles>控制器角色</a>，
为 <code>system:controller:persistent-volume-binder</code> 的 clusterrole 添加
<code>Secret</code> 资源的 <code>create</code> 权限。</p><p>在多租户上下文中，强烈建议显式设置 <code>secretNamespace</code> 的值，否则其他用户可能会读取存储帐户凭据。</p><h3 id=portworx-volume>Portworx 卷</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>portworx-io-priority-high<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/portworx-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>repl</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>snap_interval</span>:<span style=color:#bbb>   </span><span style=color:#b44>&#34;70&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>priority_io</span>:<span style=color:#bbb>  </span><span style=color:#b44>&#34;high&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><ul><li><code>fs</code>：选择的文件系统：<code>none/xfs/ext4</code>（默认：<code>ext4</code>）。</li><li><code>block_size</code>：以 Kbytes 为单位的块大小（默认值：<code>32</code>）。</li><li><code>repl</code>：同步副本数量，以复制因子 <code>1..3</code>（默认值：<code>1</code>）的形式提供。
这里需要填写字符串，即，<code>"1"</code> 而不是 <code>1</code>。</li><li><code>io_priority</code>：决定是否从更高性能或者较低优先级存储创建卷
<code>high/medium/low</code>（默认值：<code>low</code>）。</li><li><code>snap_interval</code>：触发快照的时钟/时间间隔（分钟）。
快照是基于与先前快照的增量变化，0 是禁用快照（默认：<code>0</code>）。
这里需要填写字符串，即，是 <code>"70"</code> 而不是 <code>70</code>。</li><li><code>aggregation_level</code>：指定卷分配到的块数量，0 表示一个非聚合卷（默认：<code>0</code>）。
这里需要填写字符串，即，是 <code>"0"</code> 而不是 <code>0</code>。</li><li><code>ephemeral</code>：指定卷在卸载后进行清理还是持久化。
<code>emptyDir</code> 的使用场景可以将这个值设置为 true，
<code>persistent volumes</code> 的使用场景可以将这个值设置为 false
（例如 Cassandra 这样的数据库）
<code>true/false</code>（默认为 <code>false</code>）。这里需要填写字符串，即，
是 <code>"true"</code> 而不是 <code>true</code>。</li></ul><h3 id=local>本地</h3><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.14 [stable]</code></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>local-storage<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/no-provisioner<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>volumeBindingMode</span>:<span style=color:#bbb> </span>WaitForFirstConsumer<span style=color:#bbb>
</span></span></span></code></pre></div><p>本地卷还不支持动态制备，然而还是需要创建 StorageClass 以延迟卷绑定，
直到完成 Pod 的调度。这是由 <code>WaitForFirstConsumer</code> 卷绑定模式指定的。</p><p>延迟卷绑定使得调度器在为 PersistentVolumeClaim 选择一个合适的
PersistentVolume 时能考虑到所有 Pod 的调度限制。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-4d00116c86dade62bdd5be7dc2afa1ca>6 - 卷快照类</h1><p>本文档描述了 Kubernetes 中 VolumeSnapshotClass 的概念。建议熟悉
<a href=/zh-cn/docs/concepts/storage/volume-snapshots/>卷快照（Volume Snapshots）</a>和
<a href=/zh-cn/docs/concepts/storage/storage-classes>存储类（Storage Class）</a>。</p><h2 id=introduction>介绍</h2><p>就像 StorageClass 为管理员提供了一种在配置卷时描述存储“类”的方法，
VolumeSnapshotClass 提供了一种在配置卷快照时描述存储“类”的方法。</p><h2 id=the-volumesnapshortclass-resource>VolumeSnapshotClass 资源</h2><p>每个 VolumeSnapshotClass 都包含 <code>driver</code>、<code>deletionPolicy</code> 和 <code>parameters</code> 字段，
在需要动态配置属于该类的 VolumeSnapshot 时使用。</p><p>VolumeSnapshotClass 对象的名称很重要，是用户可以请求特定类的方式。
管理员在首次创建 VolumeSnapshotClass 对象时设置类的名称和其他参数，
对象一旦创建就无法更新。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong> CRD 的安装是 Kubernetes 发行版的责任。 如果不存在所需的 CRD，则 VolumeSnapshotClass 的创建将失败。</div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>snapshot.storage.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>VolumeSnapshotClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>csi-hostpath-snapclass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>driver</span>:<span style=color:#bbb> </span>hostpath.csi.k8s.io<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>deletionPolicy</span>:<span style=color:#bbb> </span>Delete<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span></span></span></code></pre></div><p>管理员可以为未请求任何特定类绑定的 VolumeSnapshots 指定默认的 VolumeSnapshotClass，
方法是设置注解 <code>snapshot.storage.kubernetes.io/is-default-class: "true"</code>：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>snapshot.storage.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>VolumeSnapshotClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>csi-hostpath-snapclass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>snapshot.storage.kubernetes.io/is-default-class</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>driver</span>:<span style=color:#bbb> </span>hostpath.csi.k8s.io<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>deletionPolicy</span>:<span style=color:#bbb> </span>Delete<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=driver>驱动程序</h3><p>卷快照类有一个驱动程序，用于确定配置 VolumeSnapshot 的 CSI 卷插件。
此字段必须指定。</p><h3 id=deletion-policy>删除策略</h3><p>卷快照类具有 <code>deletionPolicy</code> 属性。用户可以配置当所绑定的 VolumeSnapshot
对象将被删除时，如何处理 VolumeSnapshotContent 对象。
卷快照类的这个策略可以是 <code>Retain</code> 或者 <code>Delete</code>。这个策略字段必须指定。</p><p>如果删除策略是 <code>Delete</code>，那么底层的存储快照会和 VolumeSnapshotContent 对象
一起删除。如果删除策略是 <code>Retain</code>，那么底层快照和 VolumeSnapshotContent
对象都会被保留。</p><h2 id=parameters>参数</h2><p>卷快照类具有描述属于该卷快照类的卷快照的参数，可根据 <code>driver</code> 接受不同的参数。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-018f0a7fc6e2f6d16da37702fc39b4f3>7 - 动态卷制备</h1><p>动态卷制备允许按需创建存储卷。
如果没有动态制备，集群管理员必须手动地联系他们的云或存储提供商来创建新的存储卷，
然后在 Kubernetes 集群创建
<a href=/zh-cn/docs/concepts/storage/persistent-volumes/><code>PersistentVolume</code> 对象</a>来表示这些卷。
动态制备功能消除了集群管理员预先配置存储的需要。相反，它在用户请求时自动制备存储。</p><h2 id=background>背景</h2><p>动态卷制备的实现基于 <code>storage.k8s.io</code> API 组中的 <code>StorageClass</code> API 对象。
集群管理员可以根据需要定义多个 <code>StorageClass</code> 对象，每个对象指定一个<strong>卷插件</strong>（又名 <strong>provisioner</strong>），
卷插件向卷制备商提供在创建卷时需要的数据卷信息及相关参数。</p><p>集群管理员可以在集群中定义和公开多种存储（来自相同或不同的存储系统），每种都具有自定义参数集。
该设计也确保终端用户不必担心存储制备的复杂性和细微差别，但仍然能够从多个存储选项中进行选择。</p><p>点击<a href=/zh-cn/docs/concepts/storage/storage-classes/>这里</a>查阅有关存储类的更多信息。</p><h2 id=enabling-dynamic-provisioning>启用动态卷制备</h2><p>要启用动态制备功能，集群管理员需要为用户预先创建一个或多个 <code>StorageClass</code> 对象。
<code>StorageClass</code> 对象定义当动态制备被调用时，哪一个驱动将被使用和哪些参数将被传递给驱动。
StorageClass 对象的名字必须是一个合法的
<a href=/zh-cn/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNS 子域名</a>。
以下清单创建了一个 <code>StorageClass</code> 存储类 "slow"，它提供类似标准磁盘的永久磁盘。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>slow<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/gce-pd<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>pd-standard<span style=color:#bbb>
</span></span></span></code></pre></div><p>以下清单创建了一个 "fast" 存储类，它提供类似 SSD 的永久磁盘。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fast<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/gce-pd<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>pd-ssd<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=using-dynamic-provisioning>使用动态卷制备</h2><p>用户通过在 <code>PersistentVolumeClaim</code> 中包含存储类来请求动态制备的存储。
在 Kubernetes v1.9 之前，这通过 <code>volume.beta.kubernetes.io/storage-class</code> 注解实现。
然而，这个注解自 v1.6 起就不被推荐使用了。
用户现在能够而且应该使用 <code>PersistentVolumeClaim</code> 对象的 <code>storageClassName</code> 字段。
这个字段的值必须能够匹配到集群管理员配置的 <code>StorageClass</code> 名称（见<a href=#enabling-dynamic-provisioning>下面</a>）。</p><p>例如，要选择 “fast” 存储类，用户将创建如下的 PersistentVolumeClaim：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>claim1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- ReadWriteOnce<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>fast<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>30Gi<span style=color:#bbb>
</span></span></span></code></pre></div><p>该声明会自动制备一块类似 SSD 的永久磁盘。
在删除该声明后，这个卷也会被销毁。</p><h2 id=defaulting-behavior>设置默认值的行为</h2><p>可以在集群上启用动态卷制备，以便在未指定存储类的情况下动态设置所有声明。
集群管理员可以通过以下方式启用此行为：</p><ul><li>标记一个 <code>StorageClass</code> 为 <strong>默认</strong>；</li><li>确保 <a href=/zh-cn/docs/reference/access-authn-authz/admission-controllers/#defaultstorageclass><code>DefaultStorageClass</code> 准入控制器</a>在
API 服务器端被启用。</li></ul><p>管理员可以通过向其添加
<a href=/zh-cn/docs/reference/labels-annotations-taints/#storageclass-kubernetes-io-is-default-class><code>storageclass.kubernetes.io/is-default-class</code> 注解</a>
来将特定的 <code>StorageClass</code> 标记为默认。
当集群中存在默认的 <code>StorageClass</code> 并且用户创建了一个未指定 <code>storageClassName</code> 的 <code>PersistentVolumeClaim</code> 时，
<code>DefaultStorageClass</code> 准入控制器会自动向其中添加指向默认存储类的 <code>storageClassName</code> 字段。</p><p>请注意，集群上最多只能有一个 <strong>默认</strong> 存储类，否则无法创建没有明确指定
<code>storageClassName</code> 的 <code>PersistentVolumeClaim</code>。</p><h2 id=topology-awareness>拓扑感知</h2><p>在<a href=/zh-cn/docs/setup/best-practices/multiple-zones/>多可用区</a>集群中，Pod 可以被分散到某个区域的多个可用区。
单可用区存储后端应该被制备到 Pod 被调度到的可用区。
这可以通过设置<a href=/zh-cn/docs/concepts/storage/storage-classes/#volume-binding-mode>卷绑定模式</a>来实现。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-707ca81a34eb1ca202f34692e9917d1e>8 - CSI 卷克隆</h1><p>本文档介绍 Kubernetes 中克隆现有 CSI 卷的概念。阅读前建议先熟悉
<a href=/zh-cn/docs/concepts/storage/volumes>卷</a>。</p><h2 id=介绍>介绍</h2><p><a class=glossary-tooltip title='容器存储接口 （CSI）定义了存储系统暴露给容器的标准接口。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/storage/volumes/#csi target=_blank aria-label=CSI>CSI</a> 卷克隆功能增加了通过在
<code>dataSource</code> 字段中指定存在的
<a class=glossary-tooltip title=声明在持久卷中定义的存储资源，以便可以将其挂载为容器中的卷。 data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims target=_blank aria-label=PVC>PVC</a>，
来表示用户想要克隆的 <a class=glossary-tooltip title='包含可被 Pod 中容器访问的数据的目录。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/storage/volumes/ target=_blank aria-label=卷（Volume）>卷（Volume）</a>。</p><p>克隆（Clone），意思是为已有的 Kubernetes 卷创建副本，它可以像任何其它标准卷一样被使用。
唯一的区别就是配置后，后端设备将创建指定完全相同的副本，而不是创建一个“新的”空卷。</p><p>从 Kubernetes API 的角度看，克隆的实现只是在创建新的 PVC 时，
增加了指定一个现有 PVC 作为数据源的能力。源 PVC 必须是 bound
状态且可用的（不在使用中）。</p><p>用户在使用该功能时，需要注意以下事项：</p><ul><li>克隆支持（<code>VolumePVCDataSource</code>）仅适用于 CSI 驱动。</li><li>克隆支持仅适用于 动态供应器。</li><li>CSI 驱动可能实现，也可能未实现卷克隆功能。</li><li>仅当 PVC 与目标 PVC 存在于同一命名空间（源和目标 PVC 必须在相同的命名空间）时，才可以克隆 PVC。</li><li>支持用一个不同存储类进行克隆。<ul><li>目标卷和源卷可以是相同的存储类，也可以不同。</li><li>可以使用默认的存储类，也可以在 spec 中省略 storageClassName 字段。</li></ul></li><li>克隆只能在两个使用相同 VolumeMode 设置的卷中进行
（如果请求克隆一个块存储模式的卷，源卷必须也是块存储模式）。</li></ul><h2 id=制备>制备</h2><p>克隆卷与其他任何 PVC 一样配置，除了需要增加 dataSource 来引用同一命名空间中现有的 PVC。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>clone-of-pvc-1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>myns<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>accessModes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- ReadWriteOnce<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>storageClassName</span>:<span style=color:#bbb> </span>cloning<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>storage</span>:<span style=color:#bbb> </span>5Gi<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>dataSource</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>PersistentVolumeClaim<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pvc-1<span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>你必须为 <code>spec.resources.requests.storage</code> 指定一个值，并且你指定的值必须大于或等于源卷的值。</div><p>结果是一个名称为 <code>clone-of-pvc-1</code> 的新 PVC 与指定的源 <code>pvc-1</code> 拥有相同的内容。</p><h2 id=使用>使用</h2><p>一旦新的 PVC 可用，被克隆的 PVC 像其他 PVC 一样被使用。
可以预期的是，新创建的 PVC 是一个独立的对象。
可以独立使用、克隆、快照或删除它，而不需要考虑它的原始数据源 PVC。
这也意味着，源没有以任何方式链接到新创建的 PVC，它也可以被修改或删除，而不会影响到新创建的克隆。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-c262af210c6828dec445d2f55a1d877a>9 - 卷快照</h1><p>在 Kubernetes 中，<strong>卷快照</strong> 是一个存储系统上卷的快照，本文假设你已经熟悉了 Kubernetes
的<a href=/zh-cn/docs/concepts/storage/persistent-volumes/>持久卷</a>。</p><h2 id=introduction>介绍</h2><p>与 <code>PersistentVolume</code> 和 <code>PersistentVolumeClaim</code> 这两个 API 资源用于给用户和管理员制备卷类似，
<code>VolumeSnapshotContent</code> 和 <code>VolumeSnapshot</code> 这两个 API 资源用于给用户和管理员创建卷快照。</p><p><code>VolumeSnapshotContent</code> 是从一个卷获取的一种快照，该卷由管理员在集群中进行制备。
就像持久卷（PersistentVolume）是集群的资源一样，它也是集群中的资源。</p><p><code>VolumeSnapshot</code> 是用户对于卷的快照的请求。它类似于持久卷声明（PersistentVolumeClaim）。</p><p><code>VolumeSnapshotClass</code> 允许指定属于 <code>VolumeSnapshot</code> 的不同属性。在从存储系统的相同卷上获取的快照之间，
这些属性可能有所不同，因此不能通过使用与 <code>PersistentVolumeClaim</code> 相同的 <code>StorageClass</code> 来表示。</p><p>卷快照能力为 Kubernetes 用户提供了一种标准的方式来在指定时间点复制卷的内容，并且不需要创建全新的卷。
例如，这一功能使得数据库管理员能够在执行编辑或删除之类的修改之前对数据库执行备份。</p><p>当使用该功能时，用户需要注意以下几点：</p><ul><li>API 对象 <code>VolumeSnapshot</code>，<code>VolumeSnapshotContent</code> 和 <code>VolumeSnapshotClass</code>
是 <a class=glossary-tooltip title='通过定制化的代码给你的 Kubernetes API 服务器增加资源对象，而无需编译完整的定制 API 服务器。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/ target=_blank aria-label=CRD>CRD</a>，
不属于核心 API。</li><li><code>VolumeSnapshot</code> 支持仅可用于 CSI 驱动。</li><li>作为 <code>VolumeSnapshot</code> 部署过程的一部分，Kubernetes 团队提供了一个部署于控制平面的快照控制器，
并且提供了一个叫做 <code>csi-snapshotter</code> 的边车（Sidecar）辅助容器，和 CSI 驱动程序一起部署。
快照控制器监视 <code>VolumeSnapshot</code> 和 <code>VolumeSnapshotContent</code> 对象，
并且负责创建和删除 <code>VolumeSnapshotContent</code> 对象。
边车 csi-snapshotter 监视 <code>VolumeSnapshotContent</code> 对象，
并且触发针对 CSI 端点的 <code>CreateSnapshot</code> 和 <code>DeleteSnapshot</code> 的操作。</li><li>还有一个验证性质的 Webhook 服务器，可以对快照对象进行更严格的验证。
Kubernetes 发行版应将其与快照控制器和 CRD（而非 CSI 驱动程序）一起安装。
此服务器应该安装在所有启用了快照功能的 Kubernetes 集群中。</li><li>CSI 驱动可能实现，也可能没有实现卷快照功能。CSI 驱动可能会使用 csi-snapshotter
来提供对卷快照的支持。详见 <a href=https://kubernetes-csi.github.io/docs/>CSI 驱动程序文档</a></li><li>Kubernetes 负责 CRD 和快照控制器的安装。</li></ul><h2 id=lifecycle-of-a-volume-snapshot-and-volume-snapshot-content>卷快照和卷快照内容的生命周期</h2><p><code>VolumeSnapshotContents</code> 是集群中的资源。<code>VolumeSnapshots</code> 是对于这些资源的请求。
<code>VolumeSnapshotContents</code> 和 <code>VolumeSnapshots</code> 之间的交互遵循以下生命周期：</p><h3 id=provisioning-volume-snapshot>制备卷快照</h3><p>快照可以通过两种方式进行制备：预制备或动态制备。</p><h4 id=static>预制备</h4><p>集群管理员创建多个 <code>VolumeSnapshotContents</code>。它们带有存储系统上实际卷快照的详细信息，可以供集群用户使用。
它们存在于 Kubernetes API 中，并且能够被使用。</p><h4 id=dynamic>动态制备</h4><p>可以从 <code>PersistentVolumeClaim</code> 中动态获取快照，而不用使用已经存在的快照。
在获取快照时，<a href=/zh-cn/docs/concepts/storage/volume-snapshot-classes/>卷快照类</a>
指定要用的特定于存储提供程序的参数。</p><h3 id=binding>绑定</h3><p>在预制备和动态制备场景下，快照控制器处理绑定 <code>VolumeSnapshot</code> 对象和其合适的 <code>VolumeSnapshotContent</code> 对象。
绑定关系是一对一的。</p><p>在预制备快照绑定场景下，<code>VolumeSnapshotContent</code> 对象创建之后，才会和 <code>VolumeSnapshot</code> 进行绑定。</p><h3 id=persistent-volume-claim-as-snapshot-source-protection>快照源的持久性卷声明保护</h3><p>这种保护的目的是确保在从系统中获取快照时，不会将正在使用的
<a class=glossary-tooltip title=声明在持久卷中定义的存储资源，以便可以将其挂载为容器中的卷。 data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims target=_blank aria-label=PersistentVolumeClaim>PersistentVolumeClaim</a>
API 对象从系统中删除（因为这可能会导致数据丢失）。</p><p>在为某 <code>PersistentVolumeClaim</code> 生成快照时，该 <code>PersistentVolumeClaim</code> 处于被使用状态。
如果删除一个正作为快照源使用的 <code>PersistentVolumeClaim</code> API 对象，该 <code>PersistentVolumeClaim</code> 对象不会立即被移除。
相反，移除 <code>PersistentVolumeClaim</code> 对象的动作会被推迟，直到快照状态变为 ReadyToUse 或快照操作被中止时再执行。</p><h3 id=delete>删除</h3><p>删除 <code>VolumeSnapshot</code> 对象触发删除 <code>VolumeSnapshotContent</code> 操作，并且 <code>DeletionPolicy</code> 会紧跟着执行。
如果 <code>DeletionPolicy</code> 是 <code>Delete</code>，那么底层存储快照会和 <code>VolumeSnapshotContent</code> 一起被删除。
如果 <code>DeletionPolicy</code> 是 <code>Retain</code>，那么底层快照和 <code>VolumeSnapshotContent</code> 都会被保留。</p><h2 id=volume-snapshots>卷快照</h2><p>每个 <code>VolumeSnapshot</code> 包含一个 spec 和一个 status。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>snapshot.storage.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>VolumeSnapshot<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>new-snapshot-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeSnapshotClassName</span>:<span style=color:#bbb> </span>csi-hostpath-snapclass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>source</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>persistentVolumeClaimName</span>:<span style=color:#bbb> </span>pvc-test<span style=color:#bbb>
</span></span></span></code></pre></div><p><code>persistentVolumeClaimName</code> 是 <code>PersistentVolumeClaim</code> 数据源对快照的名称。
这个字段是动态制备快照中的必填字段。</p><p>卷快照可以通过指定 <a href=/zh-cn/docs/concepts/storage/volume-snapshot-classes/>VolumeSnapshotClass</a>
使用 <code>volumeSnapshotClassName</code> 属性来请求特定类。如果没有设置，那么使用默认类（如果有）。</p><p>如下面例子所示，对于预制备的快照，需要给快照指定 <code>volumeSnapshotContentName</code> 作为来源。
对于预制备的快照 <code>source</code> 中的<code>volumeSnapshotContentName</code> 字段是必填的。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>snapshot.storage.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>VolumeSnapshot<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-snapshot<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>source</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeSnapshotContentName</span>:<span style=color:#bbb> </span>test-content<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=volume-snapshot-contents>卷快照内容</h2><p>每个 VolumeSnapshotContent 对象包含 spec 和 status。
在动态制备时，快照通用控制器创建 <code>VolumeSnapshotContent</code> 对象。下面是例子：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>snapshot.storage.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>VolumeSnapshotContent<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>snapcontent-72d9a349-aacd-42d2-a240-d775650d2455<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>deletionPolicy</span>:<span style=color:#bbb> </span>Delete<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>driver</span>:<span style=color:#bbb> </span>hostpath.csi.k8s.io<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>source</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeHandle</span>:<span style=color:#bbb> </span>ee0cfb94-f8d4-11e9-b2d8-0242ac110002<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>sourceVolumeMode</span>:<span style=color:#bbb> </span>Filesystem<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeSnapshotClassName</span>:<span style=color:#bbb> </span>csi-hostpath-snapclass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeSnapshotRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>new-snapshot-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>72d9a349-aacd-42d2-a240-d775650d2455<span style=color:#bbb>
</span></span></span></code></pre></div><p><code>volumeHandle</code> 是存储后端创建卷的唯一标识符，在卷创建期间由 CSI 驱动程序返回。
动态设置快照需要此字段。它指出了快照的卷源。</p><p>对于预制备快照，你（作为集群管理员）要按如下命令来创建 <code>VolumeSnapshotContent</code> 对象。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>snapshot.storage.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>VolumeSnapshotContent<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>new-snapshot-content-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>deletionPolicy</span>:<span style=color:#bbb> </span>Delete<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>driver</span>:<span style=color:#bbb> </span>hostpath.csi.k8s.io<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>source</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>snapshotHandle</span>:<span style=color:#bbb> </span>7bdd0de3-aaeb-11e8-9aae-0242ac110002<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>sourceVolumeMode</span>:<span style=color:#bbb> </span>Filesystem<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeSnapshotRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>new-snapshot-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span></code></pre></div><p><code>snapshotHandle</code> 是存储后端创建卷的唯一标识符。对于预制备的快照，这个字段是必需的。
它指定此 <code>VolumeSnapshotContent</code> 表示的存储系统上的 CSI 快照 ID。</p><p><code>sourceVolumeMode</code> 是创建快照的卷的模式。<code>sourceVolumeMode</code> 字段的值可以是
<code>Filesystem</code> 或 <code>Block</code>。如果没有指定源卷模式，Kubernetes 会将快照视为未知的源卷模式。</p><p><code>volumeSnapshotRef</code> 字段是对相应的 <code>VolumeSnapshot</code> 的引用。
请注意，当 <code>VolumeSnapshotContent</code> 被创建为预配置快照时。
<code>volumeSnapshotRef</code> 中引用的 <code>VolumeSnapshot</code> 可能还不存在。</p><h2 id=convert-volume-mode>转换快照的卷模式</h2><p>如果在你的集群上安装的 <code>VolumeSnapshots</code> API 支持 <code>sourceVolumeMode</code>
字段，则该 API 可以防止未经授权的用户转换卷的模式。</p><p>要检查你的集群是否具有此特性的能力，可以运行如下命令：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get crd volumesnapshotcontent -o yaml
</span></span></code></pre></div><p>如果你希望允许用户从现有的 <code>VolumeSnapshot</code> 创建 <code>PersistentVolumeClaim</code>，
但是使用与源卷不同的卷模式，则需要添加注解
<code>snapshot.storage.kubernetes.io/allowVolumeModeChange: "true"</code>
到对应 <code>VolumeSnapshot</code> 的 <code>VolumeSnapshotContent</code> 中。</p><p>对于预制备的快照，<code>Spec.SourceVolumeMode</code> 需要由集群管理员填充。</p><p>启用此特性的 <code>VolumeSnapshotContent</code> 资源示例如下所示：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>snapshot.storage.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>VolumeSnapshotContent<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>new-snapshot-content-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>snapshot.storage.kubernetes.io/allowVolumeModeChange</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>deletionPolicy</span>:<span style=color:#bbb> </span>Delete<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>driver</span>:<span style=color:#bbb> </span>hostpath.csi.k8s.io<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>source</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>snapshotHandle</span>:<span style=color:#bbb> </span>7bdd0de3-aaeb-11e8-9aae-0242ac110002<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>sourceVolumeMode</span>:<span style=color:#bbb> </span>Filesystem<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumeSnapshotRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>new-snapshot-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=provisioning-volumes-from-snapshots>从快照制备卷</h2><p>你可以制备一个新卷，该卷预填充了快照中的数据，在 <code>PersistentVolumeClaim</code> 对象中使用 <strong>dataSource</strong> 字段。</p><p>更多详细信息，
请参阅<a href=/zh-cn/docs/concepts/storage/persistent-volumes/#volume-snapshot-and-restore-volume-from-snapshot-support>卷快照和从快照还原卷</a>。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-00cd24f4570b7acaac75c2551c948bc7>10 - 存储容量</h1><p>存储容量是有限的，并且会因为运行 Pod 的节点不同而变化：
网络存储可能并非所有节点都能够访问，或者对于某个节点存储是本地的。</p><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.24 [stable]</code></div><p>本页面描述了 Kubernetes 如何跟踪存储容量以及调度程序如何为了余下的尚未挂载的卷使用该信息将
<a href=/zh-cn/docs/concepts/scheduling-eviction/>Pod 调度</a>到能够访问到足够存储容量的节点上。
如果没有跟踪存储容量，调度程序可能会选择一个没有足够容量来提供卷的节点，并且需要多次调度重试。</p><h2 id=准备开始>准备开始</h2><p>Kubernetes v1.25 包含了对存储容量跟踪的集群级 API 支持。
要使用它，你还必须使用支持容量跟踪的 CSI 驱动程序。请查阅你使用的 CSI 驱动程序的文档，
以了解此支持是否可用，如果可用，该如何使用它。如果你运行的不是
Kubernetes v1.25，请查看对应版本的 Kubernetes 文档。</p><h2 id=api>API</h2><p>这个特性有两个 API 扩展接口：</p><ul><li><a href=/zh-cn/docs/reference/kubernetes-api/config-and-storage-resources/csi-storage-capacity-v1/>CSIStorageCapacity</a> 对象：这些对象由
CSI 驱动程序在安装驱动程序的命名空间中产生。
每个对象都包含一个存储类的容量信息，并定义哪些节点可以访问该存储。</li><li><a href=/zh-cn/docs/reference/kubernetes-api/config-and-storage-resources/csi-driver-v1/#CSIDriverSpec><code>CSIDriverSpec.StorageCapacity</code> 字段</a>：
设置为 true 时，Kubernetes 调度程序将考虑使用 CSI 驱动程序的卷的存储容量。</li></ul><h2 id=scheduling>调度</h2><p>如果有以下情况，存储容量信息将会被 Kubernetes 调度程序使用：</p><ul><li>Pod 使用的卷还没有被创建，</li><li>卷使用引用了 CSI 驱动的 <a class=glossary-tooltip title='StorageClass 是管理员用来描述可用的不同存储类型的一种方法。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/storage/storage-classes/ target=_blank aria-label=StorageClass>StorageClass</a>，
并且使用了 <code>WaitForFirstConsumer</code> <a href=/zh-cn/docs/concepts/storage/storage-classes/#volume-binding-mode>卷绑定模式</a>，</li><li>驱动程序的 <code>CSIDriver</code> 对象的 <code>StorageCapacity</code> 被设置为 true。</li></ul><p>在这种情况下，调度程序仅考虑将 Pod 调度到有足够存储容量的节点上。这个检测非常简单，
仅将卷的大小与 <code>CSIStorageCapacity</code> 对象中列出的容量进行比较，并使用包含该节点的拓扑。</p><p>对于具有 <code>Immediate</code> 卷绑定模式的卷，存储驱动程序将决定在何处创建该卷，而不取决于将使用该卷的 Pod。
然后，调度程序将 Pod 调度到创建卷后可使用该卷的节点上。</p><p>对于 <a href=/zh-cn/docs/concepts/storage/ephemeral-volumes/#csi-ephemeral-volumes>CSI 临时卷</a>，
调度总是在不考虑存储容量的情况下进行。
这是基于这样的假设：该卷类型仅由节点本地的特殊 CSI 驱动程序使用，并且不需要大量资源。</p><h2 id=rescheduling>重新调度</h2><p>当为带有 <code>WaitForFirstConsumer</code> 的卷的 Pod 来选择节点时，该决定仍然是暂定的。
下一步是要求 CSI 存储驱动程序创建卷，并提示该卷在被选择的节点上可用。</p><p>因为 Kubernetes 可能会根据已经过时的存储容量信息来选择一个节点，因此可能无法真正创建卷。
然后就会重置节点选择，Kubernetes 调度器会再次尝试为 Pod 查找节点。</p><h2 id=limitations>限制</h2><p>存储容量跟踪增加了调度器第一次尝试即成功的机会，但是并不能保证这一点，因为调度器必须根据可能过期的信息来进行决策。
通常，与没有任何存储容量信息的调度相同的重试机制可以处理调度失败。</p><p>当 Pod 使用多个卷时，调度可能会永久失败：一个卷可能已经在拓扑段中创建，而该卷又没有足够的容量来创建另一个卷，
要想从中恢复，必须要进行手动干预，比如通过增加存储容量或者删除已经创建的卷。</p><h2 id=接下来>接下来</h2><ul><li>想要获得更多该设计的信息，查看
<a href=https://github.com/kubernetes/enhancements/blob/master/keps/sig-storage/1472-storage-capacity-tracking/README.md>Storage Capacity Constraints for Pod Scheduling KEP</a>。</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-055a8df536f8ba8f3aa0217bd2db5437>11 - Windows 存储</h1><p>此页面提供特定于 Windows 操作系统的存储概述。</p><h2 id=storage>持久存储</h2><p>Windows 有一个分层文件系统驱动程序用来挂载容器层和创建基于 NTFS 的文件系统拷贝。
容器中的所有文件路径仅在该容器的上下文中解析。</p><ul><li>使用 Docker 时，卷挂载只能是容器中的目录，而不能是单个文件。此限制不适用于 containerd。</li><li>卷挂载不能将文件或目录映射回宿主文件系统。</li><li>不支持只读文件系统，因为 Windows 注册表和 SAM 数据库始终需要写访问权限。不过，Windows 支持只读的卷。</li><li>不支持卷的用户掩码和访问许可，因为宿主与容器之间并不共享 SAM，二者之间不存在映射关系。
所有访问许可都是在容器上下文中解析的。</li></ul><p>因此，Windows 节点不支持以下存储功能：</p><ul><li>卷子路径挂载：只能在 Windows 容器上挂载整个卷</li><li>Secret 的子路径挂载</li><li>宿主挂载映射</li><li>只读的根文件系统（映射的卷仍然支持 <code>readOnly</code>）</li><li>块设备映射</li><li>内存作为存储介质（例如 <code>emptyDir.medium</code> 设置为 <code>Memory</code>）</li><li>类似 UID/GID、各用户不同的 Linux 文件系统访问许可等文件系统特性</li><li>使用 <a href=/zh-cn/docs/concepts/configuration/secret/#secret-files-permissions>DefaultMode 设置 Secret 权限</a>
（因为该特性依赖 UID/GID）</li><li>基于 NFS 的存储和卷支持</li><li>扩展已挂载卷（resizefs）</li></ul><p>使用 Kubernetes <a class=glossary-tooltip title='包含可被 Pod 中容器访问的数据的目录。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/storage/volumes/ target=_blank aria-label=卷>卷</a>，
对数据持久性和 Pod 卷共享有需求的复杂应用也可以部署到 Kubernetes 上。
管理与特定存储后端或协议相关的持久卷时，相关的操作包括：对卷的制备（Provisioning）、
去配（De-provisioning）和调整大小，将卷挂接到 Kubernetes 节点或从节点上解除挂接，
将卷挂载到需要持久数据的 Pod 中的某容器上或从容器上卸载。</p><p>卷管理组件作为 Kubernetes 卷<a href=/zh-cn/docs/concepts/storage/volumes/#types-of-volumes>插件</a>发布。
Windows 支持以下类型的 Kubernetes 卷插件：</p><ul><li><a href=/zh-cn/docs/concepts/storage/volumes/#flexvolume><code>FlexVolume plugins</code></a><ul><li>请注意自 1.23 版本起，FlexVolume 已被弃用</li></ul></li><li><a href=/zh-cn/docs/concepts/storage/volumes/#csi><code>CSI Plugins</code></a></li></ul><h5 id=in-tree-volume-plugins>树内（In-Tree）卷插件</h5><p>以下树内（In-Tree）插件支持 Windows 节点上的持久存储：</p><ul><li><a href=/zh-cn/docs/concepts/storage/volumes/#awselasticblockstore><code>awsElasticBlockStore</code></a></li><li><a href=/zh-cn/docs/concepts/storage/volumes/#azuredisk><code>azureDisk</code></a></li><li><a href=/zh-cn/docs/concepts/storage/volumes/#azurefile><code>azureFile</code></a></li><li><a href=/zh-cn/docs/concepts/storage/volumes/#gcepersistentdisk><code>gcePersistentDisk</code></a></li><li><a href=/zh-cn/docs/concepts/storage/volumes/#vspherevolume><code>vsphereVolume</code></a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-4f40cb95a671e51b4f0156a409d95c6d>12 - 卷健康监测</h1><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.21 [alpha]</code></div><p><a class=glossary-tooltip title='容器存储接口 （CSI）定义了存储系统暴露给容器的标准接口。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/storage/volumes/#csi target=_blank aria-label=CSI>CSI</a> 卷健康监测支持 CSI 驱动从底层的存储系统着手，
探测异常的卷状态，并以事件的形式上报到 <a class=glossary-tooltip title=声明在持久卷中定义的存储资源，以便可以将其挂载为容器中的卷。 data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims target=_blank aria-label=PVCs>PVCs</a>
或 <a class=glossary-tooltip title='Pod 表示你的集群上一组正在运行的容器。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/workloads/pods/ target=_blank aria-label=Pods>Pods</a>.</p><h2 id=volume-health-monitoring>卷健康监测</h2><p>Kubernetes <em>卷健康监测</em> 是 Kubernetes 容器存储接口（CSI）实现的一部分。
卷健康监测特性由两个组件实现：外部健康监测控制器和 <a class=glossary-tooltip title='一个在集群中每个节点上运行的代理。它保证容器都运行在 Pod 中。' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a>。</p><p>如果 CSI 驱动器通过控制器的方式支持卷健康监测特性，那么只要在 CSI 卷上监测到异常卷状态，就会在
<a class=glossary-tooltip title=声明在持久卷中定义的存储资源，以便可以将其挂载为容器中的卷。 data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims target=_blank aria-label=PersistentVolumeClaim>PersistentVolumeClaim</a> (PVC)
中上报一个事件。</p><p>外部健康监测<a class=glossary-tooltip title='控制器通过 API 服务器监控集群的公共状态，并致力于将当前状态转变为期望的状态。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/architecture/controller/ target=_blank aria-label=控制器>控制器</a>也会监测节点失效事件。
如果要启动节点失效监测功能，你可以设置标志 <code>enable-node-watcher</code> 为 <code>true</code>。
当外部健康监测器检测到节点失效事件，控制器会报送一个事件，该事件会在 PVC 上继续上报，
以表明使用此 PVC 的 Pod 正位于一个失效的节点上。</p><p>如果 CSI 驱动程序支持节点测的卷健康检测，那当在 CSI 卷上检测到异常卷时，
会在使用该 PVC 的每个Pod 上触发一个事件。
此外，卷运行状况信息作为 Kubelet VolumeStats 指标公开。
添加了一个新的指标 kubelet_volume_stats_health_status_abnormal。
该指标包括两个标签：<code>namespace</code> 和 <code>persistentvolumeclaim</code>。
计数为 1 或 0。1 表示卷不正常，0 表示卷正常。更多信息请访问<a href=https://github.com/kubernetes/enhancements/tree/master/keps/sig-storage/1432-volume-health-monitor#kubelet-metrics-changes>KEP</a>。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong> 你需要启用 <code>CSIVolumeHealth</code>
<a href=/zh-cn/docs/reference/command-line-tools-reference/feature-gates/>特性门控</a>，
才能在节点上使用此特性。</div><h2 id=接下来>接下来</h2><p>参阅 <a href=https://kubernetes-csi.github.io/docs/drivers.html>CSI 驱动程序文档</a>，
可以找出有哪些 CSI 驱动程序实现了此特性。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-b2e4b16ac37988c678a3312a4a6639f8>13 - 特定于节点的卷数限制</h1><p>此页面描述了各个云供应商可关联至一个节点的最大卷数。</p><p>谷歌、亚马逊和微软等云供应商通常对可以关联到节点的卷数量进行限制。
Kubernetes 需要尊重这些限制。 否则，在节点上调度的 Pod 可能会卡住去等待卷的关联。</p><h2 id=kubernetes-的默认限制>Kubernetes 的默认限制</h2><p>The Kubernetes 调度器对关联于一个节点的卷数有默认限制：</p><table><tr><th>云服务</th><th>每节点最大卷数</th></tr><tr><td><a href=https://aws.amazon.com/ebs/>Amazon Elastic Block Store (EBS)</a></td><td>39</td></tr><tr><td><a href=https://cloud.google.com/persistent-disk/>Google Persistent Disk</a></td><td>16</td></tr><tr><td><a href=https://azure.microsoft.com/en-us/services/storage/main-disks/>Microsoft Azure Disk Storage</a></td><td>16</td></tr></table><h2 id=自定义限制>自定义限制</h2><p>你可以通过设置 <code>KUBE_MAX_PD_VOLS</code> 环境变量的值来设置这些限制，然后再启动调度器。
CSI 驱动程序可能具有不同的过程，关于如何自定义其限制请参阅相关文档。</p><p>如果设置的限制高于默认限制，请谨慎使用。请参阅云提供商的文档以确保节点可支持你设置的限制。</p><p>此限制应用于整个集群，所以它会影响所有节点。</p><h2 id=动态卷限制>动态卷限制</h2><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.17 [stable]</code></div><p>以下卷类型支持动态卷限制。</p><ul><li>Amazon EBS</li><li>Google Persistent Disk</li><li>Azure Disk</li><li>CSI</li></ul><p>对于由内建插件管理的卷，Kubernetes 会自动确定节点类型并确保节点上可关联的卷数目合规。 例如：</p><ul><li><p>在
<a href=https://cloud.google.com/compute/>Google Compute Engine</a>环境中,
<a href=https://cloud.google.com/compute/docs/disks/#pdnumberlimits>根据节点类型</a>最多可以将127个卷关联到节点。</p></li><li><p>对于 M5、C5、R5、T3 和 Z1D 类型实例的 Amazon EBS 磁盘，Kubernetes 仅允许 25 个卷关联到节点。
对于 ec2 上的其他实例类型
<a href=https://aws.amazon.com/ec2/>Amazon Elastic Compute Cloud (EC2)</a>,
Kubernetes 允许 39 个卷关联至节点。</p></li><li><p>在 Azure 环境中, 根据节点类型，最多 64 个磁盘可以关联至一个节点。
更多详细信息，请参阅<a href=https://docs.microsoft.com/en-us/azure/virtual-machines/windows/sizes>Azure 虚拟机的数量大小</a>。</p></li><li><p>如果 CSI 存储驱动程序（使用 <code>NodeGetInfo</code> ）为节点通告卷数上限，则 <a class=glossary-tooltip title='控制平面组件，负责监视新创建的、未指定运行节点的 Pod，选择节点让 Pod 在上面运行。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/reference/command-line-tools-reference/kube-scheduler/ target=_blank aria-label=kube-scheduler>kube-scheduler</a> 将遵守该限制值。
参考 <a href=https://github.com/container-storage-interface/spec/blob/master/spec.md#nodegetinfo>CSI 规范</a> 获取更多详细信息。</p></li><li><p>对于由已迁移到 CSI 驱动程序的树内插件管理的卷，最大卷数将是 CSI 驱动程序报告的卷数。</p></li></ul></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/zh-cn/docs/home/>主页</a>
<a class=text-white href=/zh-cn/blog/>博客</a>
<a class=text-white href=/zh-cn/training/>培训</a>
<a class=text-white href=/zh-cn/partners/>合作伙伴</a>
<a class=text-white href=/zh-cn/community/>社区</a>
<a class=text-white href=/zh-cn/case-studies/>案例分析</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 The Kubernetes 作者 | 文档发布基于 <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a> 授权许可</small><br><small class=text-white>Copyright &copy; 2023 Linux 基金会&reg;。保留所有权利。Linux 基金会已注册并使用商标。如需了解 Linux 基金会的商标列表，请访问<a href=https://www.linuxfoundation.org/trademark-usage class=light-text>商标使用页面</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>