<!doctype html><html lang=zh-cn class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=en href=https://kubernetes.io/docs/concepts/configuration/><link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/concepts/configuration/><link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/concepts/configuration/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/concepts/configuration/><link rel=alternate hreflang=it href=https://kubernetes.io/it/docs/concepts/configuration/><link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/concepts/configuration/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/concepts/configuration/><link rel=alternate hreflang=pt-br href=https://kubernetes.io/pt-br/docs/concepts/configuration/><link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/concepts/configuration/><link rel=alternate hreflang=uk href=https://kubernetes.io/uk/docs/concepts/configuration/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/zh-cn/docs/concepts/configuration/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>配置 | Kubernetes</title><meta property="og:title" content="配置"><meta property="og:description" content="Kubernetes 为配置 Pods 提供的资源。"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/zh-cn/docs/concepts/configuration/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="配置"><meta itemprop=description content="Kubernetes 为配置 Pods 提供的资源。"><meta name=twitter:card content="summary"><meta name=twitter:title content="配置"><meta name=twitter:description content="Kubernetes 为配置 Pods 提供的资源。"><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content="Kubernetes 为配置 Pods 提供的资源。"><meta property="og:description" content="Kubernetes 为配置 Pods 提供的资源。"><meta name=twitter:description content="Kubernetes 为配置 Pods 提供的资源。"><meta property="og:url" content="https://kubernetes.io/zh-cn/docs/concepts/configuration/"><meta property="og:title" content="配置"><meta name=twitter:title content="配置"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/zh-cn/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/zh-cn/docs/>文档</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/zh-cn/blog/>Kubernetes 博客</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/zh-cn/training/>培训</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/zh-cn/partners/>合作伙伴</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/zh-cn/community/>社区</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/zh-cn/case-studies/>案例分析</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>版本列表</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/zh-cn/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/zh-cn/docs/concepts/configuration/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/zh-cn/docs/concepts/configuration/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/zh-cn/docs/concepts/configuration/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/zh-cn/docs/concepts/configuration/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/zh-cn/docs/concepts/configuration/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>中文 (Chinese)</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/docs/concepts/configuration/>English</a>
<a class=dropdown-item href=/ko/docs/concepts/configuration/>한국어 (Korean)</a>
<a class=dropdown-item href=/ja/docs/concepts/configuration/>日本語 (Japanese)</a>
<a class=dropdown-item href=/fr/docs/concepts/configuration/>Français (French)</a>
<a class=dropdown-item href=/it/docs/concepts/configuration/>Italiano (Italian)</a>
<a class=dropdown-item href=/de/docs/concepts/configuration/>Deutsch (German)</a>
<a class=dropdown-item href=/es/docs/concepts/configuration/>Español (Spanish)</a>
<a class=dropdown-item href=/pt-br/docs/concepts/configuration/>Português (Portuguese)</a>
<a class=dropdown-item href=/id/docs/concepts/configuration/>Bahasa Indonesia</a>
<a class=dropdown-item href=/uk/docs/concepts/configuration/>Українська (Ukrainian)</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>这是本节的多页打印视图。
<a href=# onclick="return print(),!1">点击此处打印</a>.</p><p><a href=/zh-cn/docs/concepts/configuration/>返回本页常规视图</a>.</p></div><h1 class=title>配置</h1><div class=lead>Kubernetes 为配置 Pods 提供的资源。</div><ul><li>1: <a href=#pg-ddef6fd0e47bb51c6f05e8e7fb11d2dd>配置最佳实践</a></li><li>2: <a href=#pg-6b5ccadd699df0904e8e9917c5450c4b>ConfigMap</a></li><li>3: <a href=#pg-e511ed821ada65d0053341dbd8ad2bb5>Secret</a></li><li>4: <a href=#pg-436057b96151ecb8a4a9a9f456b5d0fc>为 Pod 和容器管理资源</a></li><li>5: <a href=#pg-ab6d20f33ad930a67ee7ef57bff6c75e>使用 kubeconfig 文件组织集群访问</a></li><li>6: <a href=#pg-0f628478dbd58516389164933f9d7da2>Windows 节点的资源管理</a></li></ul><div class=content></div></div><div class=td-content><h1 id=pg-ddef6fd0e47bb51c6f05e8e7fb11d2dd>1 - 配置最佳实践</h1><p>本文档重点介绍并整合了整个用户指南、入门文档和示例中介绍的配置最佳实践。</p><p>这是一份不断改进的文件。
如果你认为某些内容缺失但可能对其他人有用，请不要犹豫，提交 Issue 或提交 PR。</p><h2 id=general-configuration-tips>一般配置提示</h2><ul><li>定义配置时，请指定最新的稳定 API 版本。</li></ul><ul><li>在推送到集群之前，配置文件应存储在版本控制中。
这允许你在必要时快速回滚配置更改。
它还有助于集群重新创建和恢复。</li></ul><ul><li>使用 YAML 而不是 JSON 编写配置文件。虽然这些格式几乎可以在所有场景中互换使用，但 YAML 往往更加用户友好。</li></ul><ul><li>只要有意义，就将相关对象分组到一个文件中。一个文件通常比几个文件更容易管理。
请参阅 <a href=https://github.com/kubernetes/examples/tree/master/guestbook/all-in-one/guestbook-all-in-one.yaml>guestbook-all-in-one.yaml</a>
文件作为此语法的示例。</li></ul><ul><li>另请注意，可以在目录上调用许多 <code>kubectl</code> 命令。
例如，你可以在配置文件的目录中调用 <code>kubectl apply</code>。</li></ul><ul><li>除非必要，否则不指定默认值：简单的最小配置会降低错误的可能性。</li></ul><ul><li>将对象描述放在注释中，以便更好地进行内省。</li></ul><h2 id=naked-pods-vs-replicasets-deployments-and-jobs>“独立的“ Pod 与 ReplicaSet 、Deployment 和 Job</h2><ul><li><p>如果可能，不要使用独立的 Pod（即，未绑定到
<a href=/zh-cn/docs/concepts/workloads/controllers/replicaset/>ReplicaSet</a> 或
<a href=/zh-cn/docs/concepts/workloads/controllers/deployment/>Deployment</a> 的 Pod）。
如果节点发生故障，将不会重新调度这些独立的 Pod。</p><p>Deployment 既可以创建一个 ReplicaSet 来确保预期个数的 Pod 始终可用，也可以指定替换 Pod 的策略（例如
<a href=/zh-cn/docs/concepts/workloads/controllers/deployment/#rolling-update-deployment>RollingUpdate</a>）。
除了一些显式的 <a href=/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy><code>restartPolicy: Never</code></a>
场景外，Deployment 通常比直接创建 Pod 要好得多。
<a href=/zh-cn/docs/concepts/workloads/controllers/job/>Job</a> 也可能是合适的选择。</p></li></ul><h2 id=services>服务</h2><ul><li><p>在创建相应的后端工作负载（Deployment 或 ReplicaSet），以及在需要访问它的任何工作负载之前创建
<a href=/zh-cn/docs/concepts/services-networking/service/>服务</a>。
当 Kubernetes 启动容器时，它提供指向启动容器时正在运行的所有服务的环境变量。
例如，如果存在名为 <code>foo</code> 的服务，则所有容器将在其初始环境中获得以下变量。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#b8860b>FOO_SERVICE_HOST</span><span style=color:#666>=</span>&lt;the host the Service is running on&gt;
</span></span><span style=display:flex><span><span style=color:#b8860b>FOO_SERVICE_PORT</span><span style=color:#666>=</span>&lt;the port the Service is running on&gt;
</span></span></code></pre></div><p><strong>这确实意味着在顺序上的要求</strong> - 必须在 <code>Pod</code> 本身被创建之前创建 <code>Pod</code> 想要访问的任何 <code>Service</code>，
否则将环境变量不会生效。DNS 没有此限制。</p></li></ul><ul><li>一个可选（尽管强烈推荐）的<a href=/zh-cn/docs/concepts/cluster-administration/addons/>集群插件</a>
是 DNS 服务器。DNS 服务器为新的 <code>Services</code> 监视 Kubernetes API，并为每个创建一组 DNS 记录。
如果在整个集群中启用了 DNS，则所有 <code>Pod</code> 应该能够自动对 <code>Services</code> 进行名称解析。</li></ul><ul><li><p>不要为 Pod 指定 <code>hostPort</code>，除非非常有必要这样做。
当你为 Pod 绑定了 <code>hostPort</code>，那么能够运行该 Pod 的节点就有限了，因为每个 <code>&lt;hostIP, hostPort, protocol></code> 组合必须是唯一的。
如果你没有明确指定 <code>hostIP</code> 和 <code>protocol</code>，
Kubernetes 将使用 <code>0.0.0.0</code> 作为默认的 <code>hostIP</code>，使用 <code>TCP</code> 作为默认的 <code>protocol</code>。</p><p>如果你只需要访问端口以进行调试，则可以使用
<a href=/zh-cn/docs/tasks/access-application-cluster/access-cluster/#manually-constructing-apiserver-proxy-urls>apiserver proxy</a>
或
<a href=/zh-cn/docs/tasks/access-application-cluster/port-forward-access-application-cluster/><code>kubectl port-forward</code></a>。</p><p>如果你明确需要在节点上公开 Pod 的端口，请在使用 <code>hostPort</code> 之前考虑使用
<a href=/zh-cn/docs/concepts/services-networking/service/#type-nodeport>NodePort</a> 服务。</p></li></ul><ul><li>避免使用 <code>hostNetwork</code>，原因与 <code>hostPort</code> 相同。</li></ul><ul><li>当你不需要 <code>kube-proxy</code> 负载均衡时，
使用<a href=/zh-cn/docs/concepts/services-networking/service/#headless-services>无头服务</a>
（<code>ClusterIP</code> 被设置为 <code>None</code>）进行服务发现。</li></ul><h2 id=using-labels>使用标签</h2><ul><li><p>定义并使用<a href=/zh-cn/docs/concepts/overview/working-with-objects/labels/>标签</a>来识别应用程序
或 Deployment 的 <strong>语义属性</strong>，例如 <code>{ app.kubernetes.io/name: MyApp, tier: frontend, phase: test, deployment: v3 }</code>。
你可以使用这些标签为其他资源选择合适的 Pod；
例如，一个选择所有 <code>tier: frontend</code> Pod 的服务，或者 <code>app.kubernetes.io/name: MyApp</code> 的所有 <code>phase: test</code> 组件。
有关此方法的示例，请参阅 <a href=https://github.com/kubernetes/examples/tree/master/guestbook/>guestbook</a> 。</p><p>通过从选择器中省略特定发行版的标签，可以使服务跨越多个 Deployment。
当你需要不停机的情况下更新正在运行的服务，可以使用 <a href=/zh-cn/docs/concepts/workloads/controllers/deployment/>Deployment</a>。</p><p>Deployment 描述了对象的期望状态，并且如果对该规约的更改被成功应用，则 Deployment
控制器以受控速率将实际状态改变为期望状态。</p></li></ul><ul><li>对于常见场景，应使用 <a href=/zh-cn/docs/concepts/overview/working-with-objects/common-labels/>Kubernetes 通用标签</a>。
这些标准化的标签丰富了对象的元数据，使得包括 <code>kubectl</code> 和
<a href=/zh-cn/docs/tasks/access-application-cluster/web-ui-dashboard>仪表板（Dashboard）</a>
这些工具能够以可互操作的方式工作。</li></ul><ul><li>你可以操纵标签进行调试。
由于 Kubernetes 控制器（例如 ReplicaSet）和服务使用选择器标签来匹配 Pod，
从 Pod 中删除相关标签将阻止其被控制器考虑或由服务提供服务流量。
如果删除现有 Pod 的标签，其控制器将创建一个新的 Pod 来取代它。
这是在“隔离“环境中调试先前“活跃“的 Pod 的有用方法。
要以交互方式删除或添加标签，请使用 <a href=/docs/reference/generated/kubectl/kubectl-commands#label><code>kubectl label</code></a>。</li></ul><h2 id=using-kubectl>使用 kubectl</h2><ul><li>使用 <code>kubectl apply -f &lt;directory></code>。
它在 <code>&lt;directory></code> 中的所有<code> .yaml</code>、<code>.yml</code> 和 <code>.json</code> 文件中查找 Kubernetes 配置，并将其传递给 <code>apply</code>。</li></ul><ul><li>使用标签选择器进行 <code>get</code> 和 <code>delete</code> 操作，而不是特定的对象名称。</li><li>请参阅<a href=/zh-cn/docs/concepts/overview/working-with-objects/labels/#label-selectors>标签选择器</a>和
<a href=/zh-cn/docs/concepts/cluster-administration/manage-deployment/#using-labels-effectively>有效使用标签</a>部分。</li></ul><ul><li>使用 <code>kubectl create deployment</code> 和 <code>kubectl expose</code> 来快速创建单容器 Deployment 和 Service。
有关示例，请参阅<a href=/zh-cn/docs/tasks/access-application-cluster/service-access-application-cluster/>使用服务访问集群中的应用程序</a>。</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-6b5ccadd699df0904e8e9917c5450c4b>2 - ConfigMap</h1><p>ConfigMap 是一种 API 对象，用来将非机密性的数据保存到键值对中。使用时， <a class=glossary-tooltip title='Pod 表示你的集群上一组正在运行的容器。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/workloads/pods/ target=_blank aria-label=Pods>Pods</a> 可以将其用作环境变量、命令行参数或者存储卷中的配置文件。</p><p>ConfigMap 将你的环境配置信息和 <a class=glossary-tooltip title=镜像（Image）是保存的容器实例，它打包了应用运行所需的一组软件。 data-toggle=tooltip data-placement=top href='/zh-cn/docs/reference/glossary/?all=true#term-image' target=_blank aria-label=容器镜像>容器镜像</a> 解耦，便于应用配置的修改。</p><div class="alert alert-warning caution callout" role=alert><strong>注意：</strong><p>ConfigMap 并不提供保密或者加密功能。
如果你想存储的数据是机密的，请使用 <a class=glossary-tooltip title='Secret 用于存储敏感信息，如密码、 OAuth 令牌和 SSH 密钥。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/configuration/secret/ target=_blank aria-label=Secret>Secret</a>，
或者使用其他第三方工具来保证你的数据的私密性，而不是用 ConfigMap。</div><h2 id=motivation>动机</h2><p>使用 ConfigMap 来将你的配置数据和应用程序代码分开。</p><p>比如，假设你正在开发一个应用，它可以在你自己的电脑上（用于开发）和在云上
（用于实际流量）运行。
你的代码里有一段是用于查看环境变量 <code>DATABASE_HOST</code>，在本地运行时，
你将这个变量设置为 <code>localhost</code>，在云上，你将其设置为引用 Kubernetes 集群中的
公开数据库组件的 <a class=glossary-tooltip title='将运行在一组 Pods 上的应用程序公开为网络服务的抽象方法。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/services-networking/service/ target=_blank aria-label=服务>服务</a>。</p><p>这让你可以获取在云中运行的容器镜像，并且如果有需要的话，在本地调试完全相同的代码。</p><p>ConfigMap 在设计上不是用来保存大量数据的。在 ConfigMap 中保存的数据不可超过
1 MiB。如果你需要保存超出此尺寸限制的数据，你可能希望考虑挂载存储卷
或者使用独立的数据库或者文件服务。</p><h2 id=configmap-对象>ConfigMap 对象</h2><p>ConfigMap 是一个 API <a href=/zh-cn/docs/concepts/overview/working-with-objects/kubernetes-objects/>对象</a>，
让你可以存储其他对象所需要使用的配置。
和其他 Kubernetes 对象都有一个 <code>spec</code> 不同的是，ConfigMap 使用 <code>data</code> 和
<code>binaryData</code> 字段。这些字段能够接收键-值对作为其取值。<code>data</code> 和 <code>binaryData</code>
字段都是可选的。<code>data</code> 字段设计用来保存 UTF-8 字符串，而 <code>binaryData</code>
则被设计用来保存二进制数据作为 base64 编码的字串。</p><p>ConfigMap 的名字必须是一个合法的
<a href=/zh-cn/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNS 子域名</a>。</p><p><code>data</code> 或 <code>binaryData</code> 字段下面的每个键的名称都必须由字母数字字符或者
<code>-</code>、<code>_</code> 或 <code>.</code> 组成。在 <code>data</code> 下保存的键名不可以与在 <code>binaryData</code>
下出现的键名有重叠。</p><p>从 v1.19 开始，你可以添加一个 <code>immutable</code> 字段到 ConfigMap 定义中，
创建<a href=#configmap-immutable>不可变更的 ConfigMap</a>。</p><h2 id=configmaps-和-pods>ConfigMaps 和 Pods</h2><p>你可以写一个引用 ConfigMap 的 Pod 的 <code>spec</code>，并根据 ConfigMap 中的数据在该
Pod 中配置容器。这个 Pod 和 ConfigMap 必须要在同一个
<a class=glossary-tooltip title='名字空间是 Kubernetes 用来支持隔离单个集群中的资源组的一种抽象。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/overview/working-with-objects/namespaces/ target=_blank aria-label=名字空间>名字空间</a> 中。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong> <a class=glossary-tooltip title='静态Pod（Static Pod）是指由特定节点上的 kubelet 守护进程直接管理的 Pod。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/tasks/configure-pod-container/static-pod/ target=_blank aria-label='静态 Pod'>静态 Pod</a> 中的 <code>spec</code>
字段不能引用 ConfigMap 或任何其他 API 对象。</div><p>这是一个 ConfigMap 的示例，它的一些键只有一个值，其他键的值看起来像是
配置的片段格式。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>game-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 类属性键；每一个键都映射到一个简单的值</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>player_initial_lives</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;3&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ui_properties_file_name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;user-interface.properties&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 类文件键</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>game.properties</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    enemy.types=aliens,monsters
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    player.maximum-lives=5</span><span style=color:#bbb>    
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>user-interface.properties</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    color.good=purple
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    color.bad=yellow
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    allow.textmode=true</span><span style=color:#bbb>    
</span></span></span></code></pre></div><p>你可以使用四种方式来使用 ConfigMap 配置 Pod 中的容器：</p><ol><li>在容器命令和参数内</li><li>容器的环境变量</li><li>在只读卷里面添加一个文件，让应用来读取</li><li>编写代码在 Pod 中运行，使用 Kubernetes API 来读取 ConfigMap</li></ol><p>这些不同的方法适用于不同的数据使用方式。
对前三个方法，<a class=glossary-tooltip title='一个在集群中每个节点上运行的代理。它保证容器都运行在 Pod 中。' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a>
使用 ConfigMap 中的数据在 Pod 中启动容器。</p><p>第四种方法意味着你必须编写代码才能读取 ConfigMap 和它的数据。然而，
由于你是直接使用 Kubernetes API，因此只要 ConfigMap 发生更改，
你的应用就能够通过订阅来获取更新，并且在这样的情况发生的时候做出反应。
通过直接进入 Kubernetes API，这个技术也可以让你能够获取到不同的名字空间里的 ConfigMap。</p><p>下面是一个 Pod 的示例，它通过使用 <code>game-demo</code> 中的值来配置一个 Pod：</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/configmap/configure-pod.yaml download=configmap/configure-pod.yaml><code>configmap/configure-pod.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("configmap-configure-pod-yaml")' title="Copy configmap/configure-pod.yaml to clipboard"></img></div><div class=includecode id=configmap-configure-pod-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>configmap-demo-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>alpine<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;sleep&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;3600&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 定义环境变量</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>PLAYER_INITIAL_LIVES<span style=color:#bbb> </span><span style=color:#080;font-style:italic># 请注意这里和 ConfigMap 中的键名是不一样的</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>configMapKeyRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>game-demo          <span style=color:#bbb> </span><span style=color:#080;font-style:italic># 这个值来自 ConfigMap</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>player_initial_lives<span style=color:#bbb> </span><span style=color:#080;font-style:italic># 需要取值的键</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>UI_PROPERTIES_FILE_NAME<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>configMapKeyRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>game-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>ui_properties_file_name<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/config&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 你可以在 Pod 级别设置卷，然后将其挂载到 Pod 内的容器中</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>configMap</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 提供你想要挂载的 ConfigMap 的名字</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>game-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 来自 ConfigMap 的一组键，将被创建为文件</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;game.properties&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;game.properties&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;user-interface.properties&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;user-interface.properties&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>ConfigMap 不会区分单行属性值和多行类似文件的值，重要的是 Pods
和其他对象如何使用这些值。</p><p>上面的例子定义了一个卷并将它作为 <code>/config</code> 文件夹挂载到 <code>demo</code> 容器内，
创建两个文件，<code>/config/game.properties</code> 和
<code>/config/user-interface.properties</code>，
尽管 ConfigMap 中包含了四个键。
这是因为 Pod 定义中在 <code>volumes</code> 节指定了一个 <code>items</code> 数组。
如果你完全忽略 <code>items</code> 数组，则 ConfigMap 中的每个键都会变成一个与该键同名的文件，
因此你会得到四个文件。</p><h2 id=using-configmaps>使用 ConfigMap</h2><p>ConfigMap 可以作为数据卷挂载。ConfigMap 也可被系统的其他组件使用，
而不一定直接暴露给 Pod。例如，ConfigMap 可以保存系统中其他组件要使用的配置数据。</p><p>ConfigMap 最常见的用法是为同一命名空间里某 Pod 中运行的容器执行配置。
你也可以单独使用 ConfigMap。</p><p>比如，你可能会遇到基于 ConfigMap 来调整其行为的
<a class=glossary-tooltip title='扩展 Kubernetes 功能的资源。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/cluster-administration/addons/ target=_blank aria-label=插件>插件</a> 或者
<a class=glossary-tooltip title=一种用于管理自定义资源的专用控制器 data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/extend-kubernetes/operator/ target=_blank aria-label=operator>operator</a>。</p><h3 id=在-pod-中将-configmap-当做文件使用>在 Pod 中将 ConfigMap 当做文件使用</h3><p>要在一个 Pod 的存储卷中使用 ConfigMap:</p><ol><li>创建一个 ConfigMap 对象或者使用现有的 ConfigMap 对象。多个 Pod 可以引用同一个
ConfigMap。</li><li>修改 Pod 定义，在 <code>spec.volumes[]</code> 下添加一个卷。
为该卷设置任意名称，之后将 <code>spec.volumes[].configMap.name</code> 字段设置为对你的
ConfigMap 对象的引用。</li><li>为每个需要该 ConfigMap 的容器添加一个 <code>.spec.containers[].volumeMounts[]</code>。
设置 <code>.spec.containers[].volumeMounts[].readOnly=true</code> 并将
<code>.spec.containers[].volumeMounts[].mountPath</code> 设置为一个未使用的目录名，
ConfigMap 的内容将出现在该目录中。</li><li>更改你的镜像或者命令行，以便程序能够从该目录中查找文件。ConfigMap 中的每个
<code>data</code> 键会变成 <code>mountPath</code> 下面的一个文件名。</li></ol><p>下面是一个将 ConfigMap 以卷的形式进行挂载的 Pod 示例：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/foo&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>configMap</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myconfigmap<span style=color:#bbb>
</span></span></span></code></pre></div><p>你希望使用的每个 ConfigMap 都需要在 <code>spec.volumes</code> 中被引用到。</p><p>如果 Pod 中有多个容器，则每个容器都需要自己的 <code>volumeMounts</code> 块，但针对每个
ConfigMap，你只需要设置一个 <code>spec.volumes</code> 块。</p><h4 id=被挂载的-configmap-内容会被自动更新>被挂载的 ConfigMap 内容会被自动更新</h4><p>当卷中使用的 ConfigMap 被更新时，所投射的键最终也会被更新。
kubelet 组件会在每次周期性同步时检查所挂载的 ConfigMap 是否为最新。
不过，kubelet 使用的是其本地的高速缓存来获得 ConfigMap 的当前值。
高速缓存的类型可以通过
<a href=/zh-cn/docs/reference/config-api/kubelet-config.v1beta1/>KubeletConfiguration 结构</a>.
的 <code>ConfigMapAndSecretChangeDetectionStrategy</code> 字段来配置。</p><p>ConfigMap 既可以通过 watch 操作实现内容传播（默认形式），也可实现基于 TTL
的缓存，还可以直接经过所有请求重定向到 API 服务器。
因此，从 ConfigMap 被更新的那一刻算起，到新的主键被投射到 Pod 中去，
这一时间跨度可能与 kubelet 的同步周期加上高速缓存的传播延迟相等。
这里的传播延迟取决于所选的高速缓存类型
（分别对应 watch 操作的传播延迟、高速缓存的 TTL 时长或者 0）。</p><p>以环境变量方式使用的 ConfigMap 数据不会被自动更新。
更新这些数据需要重新启动 Pod。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong> 使用 ConfigMap 作为 <a href=/zh-cn/docs/concepts/storage/volumes#using-subpath>subPath</a> 卷挂载的容器将不会收到 ConfigMap 的更新。</div><h2 id=configmap-immutable>不可变更的 ConfigMap</h2><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.21 [stable]</code></div><p>Kubernetes 特性 <em>Immutable Secret 和 ConfigMaps</em> 提供了一种将各个
Secret 和 ConfigMap 设置为不可变更的选项。对于大量使用 ConfigMap 的集群
（至少有数万个各不相同的 ConfigMap 给 Pod 挂载）而言，禁止更改
ConfigMap 的数据有以下好处：</p><ul><li>保护应用，使之免受意外（不想要的）更新所带来的负面影响。</li><li>通过大幅降低对 kube-apiserver 的压力提升集群性能，
这是因为系统会关闭对已标记为不可变更的 ConfigMap 的监视操作。</li></ul><p>此功能特性由 <code>ImmutableEphemeralVolumes</code>
<a href=/zh-cn/docs/reference/command-line-tools-reference/feature-gates/>特性门控</a>来控制。
你可以通过将 <code>immutable</code> 字段设置为 <code>true</code> 创建不可变更的 ConfigMap。
例如：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>immutable</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>一旦某 ConfigMap 被标记为不可变更，则 <em>无法</em> 逆转这一变化，，也无法更改
<code>data</code> 或 <code>binaryData</code> 字段的内容。你只能删除并重建 ConfigMap。
因为现有的 Pod 会维护一个已被删除的 ConfigMap 的挂载点，建议重新创建这些 Pods。</p><h2 id=接下来>接下来</h2><ul><li>阅读 <a href=/zh-cn/docs/concepts/configuration/secret/>Secret</a>。</li><li>阅读<a href=/zh-cn/docs/tasks/configure-pod-container/configure-pod-configmap/>配置 Pod 使用 ConfigMap</a>。</li><li>阅读<a href=/zh-cn/docs/tasks/manage-kubernetes-objects/update-api-object-kubectl-patch/>修改 ConfigMap（或任何其他 Kubernetes 对象）</a>。</li><li>阅读 <a href=https://12factor.net/zh_cn/>Twelve-Factor 应用</a>来了解将代码和配置分开的动机。</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-e511ed821ada65d0053341dbd8ad2bb5>3 - Secret</h1><p>Secret 是一种包含少量敏感信息例如密码、令牌或密钥的对象。
这样的信息可能会被放在 <a class=glossary-tooltip title='Pod 表示你的集群上一组正在运行的容器。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/workloads/pods/ target=_blank aria-label=Pod>Pod</a> 规约中或者镜像中。
使用 Secret 意味着你不需要在应用程序代码中包含机密数据。</p><p>由于创建 Secret 可以独立于使用它们的 Pod，
因此在创建、查看和编辑 Pod 的工作流程中暴露 Secret（及其数据）的风险较小。
Kubernetes 和在集群中运行的应用程序也可以对 Secret 采取额外的预防措施，
例如避免将机密数据写入非易失性存储。</p><p>Secret 类似于 <a class=glossary-tooltip title='ConfigMap 是一种 API 对象，用来将非机密性的数据保存到键值对中。使用时可以用作环境变量、命令行参数或者存储卷中的配置文件。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/tasks/configure-pod-container/configure-pod-configmap/ target=_blank aria-label=ConfigMap>ConfigMap</a>
但专门用于保存机密数据。</p><div class="alert alert-warning caution callout" role=alert><strong>注意：</strong><p>默认情况下，Kubernetes Secret 未加密地存储在 API 服务器的底层数据存储（etcd）中。
任何拥有 API 访问权限的人都可以检索或修改 Secret，任何有权访问 etcd 的人也可以。
此外，任何有权限在命名空间中创建 Pod 的人都可以使用该访问权限读取该命名空间中的任何 Secret；
这包括间接访问，例如创建 Deployment 的能力。</p><p>为了安全地使用 Secret，请至少执行以下步骤：</p><ol><li>为 Secret <a href=/zh-cn/docs/tasks/administer-cluster/encrypt-data/>启用静态加密</a>。</li><li>以最小特权访问 Secret 并<a href=/zh-cn/docs/reference/access-authn-authz/authorization/>启用或配置 RBAC 规则</a>。</li><li>限制 Secret 对特定容器的访问。</li><li><a href=https://secrets-store-csi-driver.sigs.k8s.io/concepts.html#provider-for-the-secrets-store-csi-driver>考虑使用外部 Secret 存储驱动</a>。</li></ol><p>有关管理和提升 Secret 安全性的指南，请参阅
<a href=/zh-cn/docs/concepts/security/secrets-good-practices>Kubernetes Secret 良好实践</a>。</p></div><p>参见 <a href=#information-security-for-secrets>Secret 的信息安全</a>了解详情。</p><h2 id=uses-for-secrets>Secret 的使用</h2><p>Pod 可以用三种方式之一来使用 Secret：</p><ul><li>作为挂载到一个或多个容器上的<a class=glossary-tooltip title='包含可被 Pod 中容器访问的数据的目录。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/storage/volumes/ target=_blank aria-label=卷>卷</a>
中的<a href=#using-secrets-as-files-from-a-pod>文件</a>。</li><li>作为<a href=#using-secrets-as-environment-variables>容器的环境变量</a>。</li><li>由 <a href=#using-imagepullsecrets>kubelet 在为 Pod 拉取镜像时使用</a>。</li></ul><p>Kubernetes 控制面也使用 Secret；
例如，<a href=#bootstrap-token-secrets>引导令牌 Secret</a>
是一种帮助自动化节点注册的机制。</p><h3 id=alternatives-to-secrets>Secret 的替代方案</h3><p>除了使用 Secret 来保护机密数据，你也可以选择一些替代方案。</p><p>下面是一些选项：</p><ul><li>如果你的云原生组件需要执行身份认证来访问你所知道的、在同一 Kubernetes 集群中运行的另一个应用，
你可以使用 <a href=/zh-cn/docs/reference/access-authn-authz/authentication/#service-account-tokens>ServiceAccount</a>
及其令牌来标识你的客户端身份。</li><li>你可以运行的第三方工具也有很多，这些工具可以运行在集群内或集群外，提供机密数据管理。
例如，这一工具可能是 Pod 通过 HTTPS 访问的一个服务，该服务在客户端能够正确地通过身份认证
（例如，通过 ServiceAccount 令牌）时，提供机密数据内容。</li></ul><ul><li>就身份认证而言，你可以为 X.509 证书实现一个定制的签名者，并使用
<a href=/zh-cn/docs/reference/access-authn-authz/certificate-signing-requests/>CertificateSigningRequest</a>
来让该签名者为需要证书的 Pod 发放证书。</li><li>你可以使用一个<a href=/zh-cn/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/>设备插件</a>
来将节点本地的加密硬件暴露给特定的 Pod。例如，你可以将可信任的 Pod
调度到提供可信平台模块（Trusted Platform Module，TPM）的节点上。
这类节点是另行配置的。</li></ul><p>你还可以将如上选项的两种或多种进行组合，包括直接使用 Secret 对象本身也是一种选项。</p><p>例如：实现（或部署）一个 <a class=glossary-tooltip title=一种用于管理自定义资源的专用控制器 data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/extend-kubernetes/operator/ target=_blank aria-label=operator>operator</a>，
从外部服务取回生命期很短的会话令牌，之后基于这些生命期很短的会话令牌来创建 Secret。
运行在集群中的 Pod 可以使用这些会话令牌，而 Operator 则确保这些令牌是合法的。
这种责权分离意味着你可以运行那些不了解会话令牌如何发放与刷新的确切机制的 Pod。</p><h2 id=working-with-secrets>使用 Secret</h2><h3 id=creating-a-secret>创建 Secret</h3><p>创建 Secret 有以下几种可选方式：</p><ul><li><a href=/zh-cn/docs/tasks/configmap-secret/managing-secret-using-kubectl/>使用 <code>kubectl</code></a></li><li><a href=/zh-cn/docs/tasks/configmap-secret/managing-secret-using-config-file/>使用配置文件</a></li><li><a href=/zh-cn/docs/tasks/configmap-secret/managing-secret-using-kustomize/>使用 Kustomize 工具</a></li></ul><h4 id=restriction-names-data>对 Secret 名称与数据的约束</h4><p>Secret 对象的名称必须是合法的
<a href=/zh-cn/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNS 子域名</a>。</p><p>在为创建 Secret 编写配置文件时，你可以设置 <code>data</code> 与/或 <code>stringData</code> 字段。
<code>data</code> 和 <code>stringData</code> 字段都是可选的。<code>data</code> 字段中所有键值都必须是 base64
编码的字符串。如果不希望执行这种 base64 字符串的转换操作，你可以选择设置
<code>stringData</code> 字段，其中可以使用任何字符串作为其取值。</p><p><code>data</code> 和 <code>stringData</code> 中的键名只能包含字母、数字、<code>-</code>、<code>_</code> 或 <code>.</code> 字符。
<code>stringData</code> 字段中的所有键值对都会在内部被合并到 <code>data</code> 字段中。
如果某个主键同时出现在 <code>data</code> 和 <code>stringData</code> 字段中，<code>stringData</code>
所指定的键值具有高优先级。</p><h4 id=restriction-data-size>尺寸限制</h4><p>每个 Secret 的尺寸最多为 1MiB。施加这一限制是为了避免用户创建非常大的 Secret，
进而导致 API 服务器和 kubelet 内存耗尽。不过创建很多小的 Secret 也可能耗尽内存。
你可以使用<a href=/zh-cn/docs/concepts/policy/resource-quotas/>资源配额</a>来约束每个名字空间中
Secret（或其他资源）的个数。</p><h3 id=editing-a-secret>编辑 Secret</h3><p>你可以编辑一个已有的 Secret，除非它是<a href=#secret-immutable>不可变更的</a>。
要编辑一个 Secret，可使用以下方法之一：</p><ul><li><a href=/zh-cn/docs/tasks/configmap-secret/managing-secret-using-kubectl/#edit-secret>使用 <code>kubectl</code></a></li><li><a href=/zh-cn/docs/tasks/configmap-secret/managing-secret-using-config-file/#edit-secret>使用配置文件</a></li></ul><p>你也可以使用
<a href=/zh-cn/docs/tasks/configmap-secret/managing-secret-using-kustomize/#edit-secret>Kustomize 工具</a>编辑数据。
然而这种方法会用编辑过的数据创建新的 <code>Secret</code> 对象。</p><p>根据你创建 Secret 的方式以及该 Secret 在 Pod 中被使用的方式，对已有 <code>Secret</code>
对象的更新将自动扩散到使用此数据的 Pod。有关更多信息，
请参阅<a href=#mounted-secrets-are-updated-automatically>自动更新挂载的 Secret</a>。</p><h3 id=using-a-secret>使用 Secret</h3><p>Secret 可以以数据卷的形式挂载，也可以作为<a class=glossary-tooltip title='容器环境变量提供了 name=value 形式的、运行容器化应用所必须的一些重要信息。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/containers/container-environment/ target=_blank aria-label=环境变量>环境变量</a>
暴露给 Pod 中的容器使用。Secret 也可用于系统中的其他部分，而不是一定要直接暴露给 Pod。
例如，Secret 也可以包含系统中其他部分在替你与外部系统交互时要使用的凭证数据。</p><p>Kubernetes 会检查 Secret 的卷数据源，确保所指定的对象引用确实指向类型为 Secret
的对象。因此，如果 Pod 依赖于某 Secret，该 Secret 必须先于 Pod 被创建。</p><p>如果 Secret 内容无法取回（可能因为 Secret 尚不存在或者临时性地出现 API
服务器网络连接问题），kubelet 会周期性地重试 Pod 运行操作。kubelet 也会为该 Pod
报告 Event 事件，给出读取 Secret 时遇到的问题细节。</p><h4 id=restriction-secret-must-exist>可选的 Secret</h4><p>当你定义一个基于 Secret 的环境变量时，你可以将其标记为可选。
默认情况下，所引用的 Secret 都是必需的。</p><p>只有所有非可选的 Secret 都可用时，Pod 中的容器才能启动运行。</p><p>如果 Pod 引用了 Secret 中的特定主键，而虽然 Secret 本身存在，对应的主键不存在，
Pod 启动也会失败。</p><h3 id=using-secrets-as-files-from-a-pod>在 Pod 中以文件形式使用 Secret</h3><p>如果你希望在 Pod 中访问 Secret 内的数据，一种方式是让 Kubernetes 将 Secret
以 Pod 中一个或多个容器的文件系统中的文件的形式呈现出来。</p><p>要配置这种行为，你需要：</p><ol><li>创建一个 Secret 或者使用已有的 Secret。多个 Pod 可以引用同一个 Secret。</li><li>更改 Pod 定义，在 <code>.spec.volumes[]</code> 下添加一个卷。根据需要为卷设置其名称，
并将 <code>.spec.volumes[].secret.secretName</code> 字段设置为 Secret 对象的名称。</li><li>为每个需要该 Secret 的容器添加 <code>.spec.containers[].volumeMounts[]</code>。
并将 <code>.spec.containers[].volumeMounts[].readOnly</code> 设置为 <code>true</code>，
将 <code>.spec.containers[].volumeMounts[].mountPath</code> 设置为希望 Secret
被放置的、目前尚未被使用的路径名。</li><li>更改你的镜像或命令行，以便程序读取所设置的目录下的文件。Secret 的 <code>data</code>
映射中的每个主键都成为 <code>mountPath</code> 下面的文件名。</li></ol><p>下面是一个通过卷来挂载名为 <code>mysecret</code> 的 Secret 的 Pod 示例：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/foo&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>optional</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># 默认设置，意味着 &#34;mysecret&#34; 必须已经存在</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>你要访问的每个 Secret 都需要通过 <code>.spec.volumes</code> 来引用。</p><p>如果 Pod 中包含多个容器，则每个容器需要自己的 <code>volumeMounts</code> 块，
不过针对每个 Secret 而言，只需要一份 <code>.spec.volumes</code> 设置。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>Kubernetes v1.22 版本之前都会自动创建用来访问 Kubernetes API 的凭证。
这一老的机制是基于创建可被挂载到 Pod 中的令牌 Secret 来实现的。
在最近的版本中，包括 Kubernetes v1.25 中，API 凭据是直接通过
<a href=/zh-cn/docs/reference/kubernetes-api/authentication-resources/token-request-v1/>TokenRequest</a>
API 来获得的，这一凭据会使用<a href=/zh-cn/docs/reference/access-authn-authz/service-accounts-admin/#bound-service-account-token-volume>投射卷</a>
挂载到 Pod 中。使用这种方式获得的令牌有确定的生命期，并且在挂载它们的 Pod
被删除时自动作废。</p><p>你仍然可以<a href=/zh-cn/docs/tasks/configure-pod-container/configure-service-account/#manually-create-a-service-account-api-token>手动创建</a>
服务账号令牌。例如，当你需要一个永远都不过期的令牌时。
不过，仍然建议使用 <a href=/zh-cn/docs/reference/kubernetes-api/authentication-resources/token-request-v1/>TokenRequest</a>
子资源来获得访问 API 服务器的令牌。
你可以使用 <a href=/docs/reference/generated/kubectl/kubectl-commands#-em-token-em-><code>kubectl create token</code></a>
命令调用 <code>TokenRequest</code> API 获得令牌。</p></div><h4 id=projection-of-secret-keys-to-specific-paths>将 Secret 键投射到特定目录</h4><p>你也可以控制 Secret 键所投射到的卷中的路径。
你可以使用 <code>.spec.volumes[].secret.items</code> 字段来更改每个主键的目标路径：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/foo&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>username<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>my-group/my-username<span style=color:#bbb>
</span></span></span></code></pre></div><p>将发生的事情如下：</p><ul><li><code>mysecret</code> 中的键 <code>username</code> 会出现在容器中的路径为 <code>/etc/foo/my-group/my-username</code>，
而不是 <code>/etc/foo/username</code>。</li><li>Secret 对象的 <code>password</code> 键不会被投射。</li></ul><p>如果使用了 <code>.spec.volumes[].secret.items</code>，则只有 <code>items</code> 中指定了的主键会被投射。
如果要使用 Secret 中的所有主键，则需要将它们全部枚举到 <code>items</code> 字段中。</p><p>如果你显式地列举了主键，则所列举的主键都必须在对应的 Secret 中存在。
否则所在的卷不会被创建。</p><h4 id=secret-files-permissions>Secret 文件的访问权限</h4><p>你可以为某个 Secret 主键设置 POSIX 文件访问权限位。
如果你不指定访问权限，默认会使用 <code>0644</code>。
你也可以为整个 Secret 卷设置默认的访问模式，然后再根据需要在主键层面重载。</p><p>例如，你可以像下面这样设置默认的模式：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mypod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/foo&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>defaultMode</span>:<span style=color:#bbb> </span><span style=color:#666>0400</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>该 Secret 被挂载在 <code>/etc/foo</code> 下，Secret 卷挂载所创建的所有文件的访问模式都是 <code>0400</code>。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>如果你是使用 JSON 来定义 Pod 或 Pod 模板，需要注意 JSON 规范不支持八进制的记数方式。
你可以在 <code>defaultMode</code> 中设置十进制的值（例如，八进制中的 0400 在十进制中为 256）。
如果你使用 YAML 来编写定义，你可以用八进制值来设置 <code>defaultMode</code>。</div><h4 id=consuming-secret-values-from-volumes>使用来自卷中的 Secret 值</h4><p>在挂载了 Secret 卷的容器内，Secret 的主键都呈现为文件。
Secret 的取值都是 Base64 编码的，保存在这些文件中。</p><p>下面是在上例中的容器内执行命令的结果：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>ls /etc/foo/
</span></span></code></pre></div><p>输出类似于：</p><pre tabindex=0><code>username
password
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat /etc/foo/username
</span></span></code></pre></div><p>输出类似于：</p><pre tabindex=0><code>admin
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat /etc/foo/password
</span></span></code></pre></div><p>输出类似于：</p><pre tabindex=0><code>1f2d1e2e67df
</code></pre><p>容器中的程序要负责根据需要读取 Secret 数据。</p><h4 id=mounted-secrets-are-updated-automatically>挂载的 Secret 是被自动更新的</h4><p>当卷中包含来自 Secret 的数据，而对应的 Secret 被更新，Kubernetes
会跟踪到这一操作并更新卷中的数据。更新的方式是保证最终一致性。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>对于以 <a href=/zh-cn/docs/concepts/storage/volumes#using-subpath>subPath</a> 形式挂载 Secret 卷的容器而言，
它们无法收到自动的 Secret 更新。</div><p>Kubelet 组件会维护一个缓存，在其中保存节点上 Pod 卷中使用的 Secret 的当前主键和取值。
你可以配置 kubelet 如何检测所缓存数值的变化。
<a href=/zh-cn/docs/reference/config-api/kubelet-config.v1beta1/>kubelet 配置</a>中的
<code>configMapAndSecretChangeDetectionStrategy</code> 字段控制 kubelet 所采用的策略。
默认的策略是 <code>Watch</code>。</p><p>对 Secret 的更新操作既可以通过 API 的 watch 机制（默认）来传播，
基于设置了生命期的缓存获取，也可以通过 kubelet 的同步回路来从集群的 API
服务器上轮询获取。</p><p>因此，从 Secret 被更新到新的主键被投射到 Pod 中，中间存在一个延迟。
这一延迟的上限是 kubelet 的同步周期加上缓存的传播延迟，
其中缓存的传播延迟取决于所选择的缓存类型。
对应上一段中提到的几种传播机制，延迟时长为 watch 的传播延迟、所配置的缓存 TTL
或者对于直接轮询而言是零。</p><h3 id=using-secrets-as-environment-variables>以环境变量的方式使用 Secret</h3><p>如果需要在 Pod
中以<a class=glossary-tooltip title='容器环境变量提供了 name=value 形式的、运行容器化应用所必须的一些重要信息。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/containers/container-environment/ target=_blank aria-label=环境变量>环境变量</a>的形式使用 Secret：</p><ol><li>创建 Secret（或者使用现有 Secret）。多个 Pod 可以引用同一个 Secret。</li><li>更改 Pod 定义，在要使用 Secret 键值的每个容器中添加与所使用的主键对应的环境变量。
读取 Secret 主键的环境变量应该在 <code>env[].valueFrom.secretKeyRef</code> 中填写 Secret
的名称和主键名称。</li><li>更改你的镜像或命令行，以便程序读取环境变量中保存的值。</li></ol><p>下面是一个通过环境变量来使用 Secret 的示例 Pod：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-env-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mycontainer<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>SECRET_USERNAME<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>secretKeyRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>username<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>optional</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># 此值为默认值；意味着 &#34;mysecret&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                            </span><span style=color:#080;font-style:italic># 必须存在且包含名为 &#34;username&#34; 的主键</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>SECRET_PASSWORD<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>valueFrom</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>secretKeyRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>password<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>optional</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># 此值为默认值；意味着 &#34;mysecret&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                            </span><span style=color:#080;font-style:italic># 必须存在且包含名为 &#34;password&#34; 的主键</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></span></span></code></pre></div><h4 id=restriction-env-from-invalid>非法环境变量</h4><p>对于通过 <code>envFrom</code> 字段来填充环境变量的 Secret 而言，
如果其中包含的主键不能被当做合法的环境变量名，这些主键会被忽略掉。
Pod 仍然可以启动。</p><p>如果你定义的 Pod 中包含非法的变量名称，则 Pod 可能启动失败，
会形成 reason 为 <code>InvalidVariableNames</code> 的事件，以及列举被略过的非法主键的消息。
下面的例子中展示了一个 Pod，引用的是名为 <code>mysecret</code> 的 Secret，
其中包含两个非法的主键：<code>1badkey</code> 和 <code>2alsobad</code>。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get events
</span></span></code></pre></div><p>输出类似于：</p><pre tabindex=0><code>LASTSEEN   FIRSTSEEN   COUNT     NAME            KIND      SUBOBJECT                         TYPE      REASON
0s         0s          1         dapi-test-pod   Pod                                         Warning   InvalidEnvironmentVariableNames   kubelet, 127.0.0.1      Keys [1badkey, 2alsobad] from the EnvFrom secret default/mysecret were skipped since they are considered invalid environment variable names.
</code></pre><h4 id=consuming-secret-values-from-environment-variables>通过环境变量使用 Secret 值</h4><p>在通过环境变量来使用 Secret 的容器中，Secret 主键展现为普通的环境变量。
这些变量的取值是 Secret 数据的 Base64 解码值。</p><p>下面是在前文示例中的容器内执行命令的结果：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b44>&#34;</span><span style=color:#b8860b>$SECRET_USERNAME</span><span style=color:#b44>&#34;</span>
</span></span></code></pre></div><p>输出类似于：</p><pre tabindex=0><code>admin
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b44>&#34;</span><span style=color:#b8860b>$SECRET_PASSWORD</span><span style=color:#b44>&#34;</span>
</span></span></code></pre></div><p>输出类似于：</p><pre tabindex=0><code>1f2d1e2e67df
</code></pre><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>如果容器已经在通过环境变量来使用 Secret，Secret 更新在容器内是看不到的，
除非容器被重启。有一些第三方的解决方案，能够在 Secret 发生变化时触发容器重启。</div><h3 id=using-imagepullsecrets>容器镜像拉取 Secret</h3><p>如果你尝试从私有仓库拉取容器镜像，你需要一种方式让每个节点上的 kubelet
能够完成与镜像库的身份认证。你可以配置 <strong>镜像拉取 Secret</strong> 来实现这点。
Secret 是在 Pod 层面来配置的。</p><p>Pod 的 <code>imagePullSecrets</code> 字段是一个对 Pod 所在的名字空间中的 Secret
的引用列表。你可以使用 <code>imagePullSecrets</code> 来将镜像仓库访问凭据传递给 kubelet。
kubelet 使用这个信息来替你的 Pod 拉取私有镜像。
参阅 <a href=/zh-cn/docs/reference/kubernetes-api/workload-resources/pod-v1/#PodSpec>Pod API 参考</a>
中的 <code>PodSpec</code> 进一步了解 <code>imagePullSecrets</code> 字段。</p><h4 id=using-imagepullsecrets-1>使用 imagePullSecrets</h4><p><code>imagePullSecrets</code> 字段是一个列表，包含对同一名字空间中 Secret 的引用。
你可以使用 <code>imagePullSecrets</code> 将包含 Docker（或其他）镜像仓库密码的 Secret
传递给 kubelet。kubelet 使用此信息来替 Pod 拉取私有镜像。
参阅 <a href=/zh-cn/docs/reference/kubernetes-api/workload-resources/pod-v1/#PodSpec>PodSpec API</a>
进一步了解 <code>imagePullSecrets</code> 字段。</p><h5 id=manually-specifying-an-imagepullsecret>手动设定 imagePullSecret</h5><p>你可以通过阅读<a href=/zh-cn/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod>容器镜像</a>
文档了解如何设置 <code>imagePullSecrets</code>。</p><h5 id=arranging-for-imagepullsecrets-to-be-automatically-attached>设置 imagePullSecrets 为自动挂载</h5><p>你可以手动创建 <code>imagePullSecret</code>，并在一个 ServiceAccount 中引用它。
对使用该 ServiceAccount 创建的所有 Pod，或者默认使用该 ServiceAccount 创建的 Pod
而言，其 <code>imagePullSecrets</code> 字段都会设置为该服务账号。
请阅读<a href=/zh-cn/docs/tasks/configure-pod-container/configure-service-account/#add-imagepullsecrets-to-a-service-account>向服务账号添加 ImagePullSecrets</a>
来详细了解这一过程。</p><h3 id=restriction-static-pod>在静态 Pod 中使用 Secret</h3><p>你不可以在<a class=glossary-tooltip title='静态Pod（Static Pod）是指由特定节点上的 kubelet 守护进程直接管理的 Pod。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/tasks/configure-pod-container/static-pod/ target=_blank aria-label='静态 Pod'>静态 Pod</a>
中使用 ConfigMap 或 Secret。</p><h2 id=use-case>使用场景</h2><h3 id=use-case-as-container-environment-variables>使用场景：作为容器环境变量</h3><p>创建 Secret：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Opaque<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>USER_NAME</span>:<span style=color:#bbb> </span>YWRtaW4=<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>PASSWORD</span>:<span style=color:#bbb> </span>MWYyZDFlMmU2N2Rm<span style=color:#bbb>
</span></span></span></code></pre></div><p>创建 Secret：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f mysecret.yaml
</span></span></code></pre></div><p>使用 <code>envFrom</code> 来将 Secret 的所有数据定义为容器的环境变量。
来自 Secret 的主键成为 Pod 中的环境变量名称：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-test-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>registry.k8s.io/busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#bbb> </span><span style=color:#b44>&#34;/bin/sh&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;-c&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;env&#34;</span><span style=color:#bbb> </span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>envFrom</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>secretRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=use-case-pod-with-ssh-keys>使用场景：带 SSH 密钥的 Pod</h3><p>创建包含一些 SSH 密钥的 Secret：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret generic ssh-key-secret --from-file<span style=color:#666>=</span>ssh-privatekey<span style=color:#666>=</span>/path/to/.ssh/id_rsa --from-file<span style=color:#666>=</span>ssh-publickey<span style=color:#666>=</span>/path/to/.ssh/id_rsa.pub
</span></span></code></pre></div><p>输出类似于：</p><pre tabindex=0><code>secret &#34;ssh-key-secret&#34; created
</code></pre><p>你也可以创建一个 <code>kustomization.yaml</code> 文件，在其 <code>secretGenerator</code>
字段中包含 SSH 密钥。</p><div class="alert alert-warning caution callout" role=alert><strong>注意：</strong><p>在提供你自己的 SSH 密钥之前要仔细思考：集群的其他用户可能有权访问该 Secret。</p><p>你也可以创建一个 SSH 私钥，代表一个你希望与你共享 Kubernetes 集群的其他用户分享的服务标识。
当凭据信息被泄露时，你可以收回该访问权限。</p></div><p>现在你可以创建一个 Pod，在其中访问包含 SSH 密钥的 Secret，并通过卷的方式来使用它：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-test-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>ssh-key-secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>ssh-test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>mySshImage<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/secret-volume&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>容器命令执行时，秘钥的数据可以在下面的位置访问到：</p><pre tabindex=0><code>/etc/secret-volume/ssh-publickey
/etc/secret-volume/ssh-privatekey
</code></pre><p>容器就可以随便使用 Secret 数据来建立 SSH 连接。</p><h3 id=use-case-pods-with-prod-test-credentials>使用场景：带有生产、测试环境凭据的 Pod</h3><p>这一示例所展示的一个 Pod 会使用包含生产环境凭据的 Secret，另一个 Pod
使用包含测试环境凭据的 Secret。</p><p>你可以创建一个带有 <code>secretGenerator</code> 字段的 <code>kustomization.yaml</code> 文件或者运行
<code>kubectl create secret</code> 来创建 Secret。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret generic prod-db-secret --from-literal<span style=color:#666>=</span><span style=color:#b8860b>username</span><span style=color:#666>=</span>produser --from-literal<span style=color:#666>=</span><span style=color:#b8860b>password</span><span style=color:#666>=</span>Y4nys7f11
</span></span></code></pre></div><p>输出类似于：</p><pre tabindex=0><code>secret &#34;prod-db-secret&#34; created
</code></pre><p>你也可以创建一个包含测试环境凭据的 Secret：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret generic test-db-secret --from-literal<span style=color:#666>=</span><span style=color:#b8860b>username</span><span style=color:#666>=</span>testuser --from-literal<span style=color:#666>=</span><span style=color:#b8860b>password</span><span style=color:#666>=</span>iluvtests
</span></span></code></pre></div><p>输出类似于：</p><pre tabindex=0><code>secret &#34;test-db-secret&#34; created
</code></pre><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>特殊字符（例如 <code>$</code>、<code>\</code>、<code>*</code>、<code>=</code> 和 <code>!</code>）会被你的
<a href=https://zh.wikipedia.org/wiki/%E6%AE%BC%E5%B1%A4>Shell</a> 解释，因此需要转义。</p><p>在大多数 Shell 中，对密码进行转义的最简单方式是用单引号（<code>'</code>）将其括起来。
例如，如果你的实际密码是 <code>S!B\*d$zDsb</code>，则应通过以下方式执行命令：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret generic dev-db-secret --from-literal<span style=color:#666>=</span><span style=color:#b8860b>username</span><span style=color:#666>=</span>devuser --from-literal<span style=color:#666>=</span><span style=color:#b8860b>password</span><span style=color:#666>=</span><span style=color:#b44>&#39;S!B\*d$zDsb=&#39;</span>
</span></span></code></pre></div><p>你无需对文件中的密码（<code>--from-file</code>）中的特殊字符进行转义。</p></div><p>现在生成 Pod：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt; pod.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: List
</span></span></span><span style=display:flex><span><span style=color:#b44>items:
</span></span></span><span style=display:flex><span><span style=color:#b44>- kind: Pod
</span></span></span><span style=display:flex><span><span style=color:#b44>  apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>  metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>    name: prod-db-client-pod
</span></span></span><span style=display:flex><span><span style=color:#b44>    labels:
</span></span></span><span style=display:flex><span><span style=color:#b44>      name: prod-db-client
</span></span></span><span style=display:flex><span><span style=color:#b44>  spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>    volumes:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - name: secret-volume
</span></span></span><span style=display:flex><span><span style=color:#b44>      secret:
</span></span></span><span style=display:flex><span><span style=color:#b44>        secretName: prod-db-secret
</span></span></span><span style=display:flex><span><span style=color:#b44>    containers:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - name: db-client-container
</span></span></span><span style=display:flex><span><span style=color:#b44>      image: myClientImage
</span></span></span><span style=display:flex><span><span style=color:#b44>      volumeMounts:
</span></span></span><span style=display:flex><span><span style=color:#b44>      - name: secret-volume
</span></span></span><span style=display:flex><span><span style=color:#b44>        readOnly: true
</span></span></span><span style=display:flex><span><span style=color:#b44>        mountPath: &#34;/etc/secret-volume&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44>- kind: Pod
</span></span></span><span style=display:flex><span><span style=color:#b44>  apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>  metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>    name: test-db-client-pod
</span></span></span><span style=display:flex><span><span style=color:#b44>    labels:
</span></span></span><span style=display:flex><span><span style=color:#b44>      name: test-db-client
</span></span></span><span style=display:flex><span><span style=color:#b44>  spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>    volumes:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - name: secret-volume
</span></span></span><span style=display:flex><span><span style=color:#b44>      secret:
</span></span></span><span style=display:flex><span><span style=color:#b44>        secretName: test-db-secret
</span></span></span><span style=display:flex><span><span style=color:#b44>    containers:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - name: db-client-container
</span></span></span><span style=display:flex><span><span style=color:#b44>      image: myClientImage
</span></span></span><span style=display:flex><span><span style=color:#b44>      volumeMounts:
</span></span></span><span style=display:flex><span><span style=color:#b44>      - name: secret-volume
</span></span></span><span style=display:flex><span><span style=color:#b44>        readOnly: true
</span></span></span><span style=display:flex><span><span style=color:#b44>        mountPath: &#34;/etc/secret-volume&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>将 Pod 添加到同一 <code>kustomization.yaml</code> 文件中：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF &gt;&gt; kustomization.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>resources:
</span></span></span><span style=display:flex><span><span style=color:#b44>- pod.yaml
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>通过下面的命令在 API 服务器上应用所有这些对象：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -k .
</span></span></code></pre></div><p>两个文件都会在其文件系统中出现下面的文件，文件中内容是各个容器的环境值：</p><pre tabindex=0><code>/etc/secret-volume/username
/etc/secret-volume/password
</code></pre><p>注意这两个 Pod 的规约中只有一个字段不同。
这便于基于相同的 Pod 模板生成具有不同能力的 Pod。</p><p>你可以通过使用两个服务账号来进一步简化这一基本的 Pod 规约：</p><ol><li><code>prod-user</code> 服务账号使用 <code>prod-db-secret</code></li><li><code>test-user</code> 服务账号使用 <code>test-db-secret</code></li></ol><p>Pod 规约简化为：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>prod-db-client-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>prod-db-client<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>serviceAccount</span>:<span style=color:#bbb> </span>prod-db-client<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>db-client-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>myClientImage<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=use-case-dotfiles-in-a-secret-volume>使用场景：在 Secret 卷中带句点的文件</h3><p>通过定义以句点（<code>.</code>）开头的主键，你可以“隐藏”你的数据。
这些主键代表的是以句点开头的文件或“隐藏”文件。
例如，当下面的 Secret 被挂载到 <code>secret-volume</code> 卷中时：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dotfile-secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>.secret-file</span>:<span style=color:#bbb> </span>dmFsdWUtMg0KDQo=<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-dotfiles-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>secret</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span>dotfile-secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dotfile-test-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>registry.k8s.io/busybox<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- ls<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;-l&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:#b44>&#34;/etc/secret-volume&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-volume<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>readOnly</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/secret-volume&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>卷中会包含一个名为 <code>.secret-file</code> 的文件，并且容器 <code>dotfile-test-container</code>
中此文件位于路径 <code>/etc/secret-volume/.secret-file</code> 处。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>以句点开头的文件会在 <code>ls -l</code> 的输出中被隐藏起来；
列举目录内容时你必须使用 <code>ls -la</code> 才能看到它们。</div><h3 id=use-case-secret-visible-to-one-container-in-a-pod>使用场景：仅对 Pod 中一个容器可见的 Secret</h3><p>考虑一个需要处理 HTTP 请求，执行某些复杂的业务逻辑，之后使用 HMAC
来对某些消息进行签名的程序。因为这一程序的应用逻辑很复杂，
其中可能包含未被注意到的远程服务器文件读取漏洞，
这种漏洞可能会把私钥暴露给攻击者。</p><p>这一程序可以分隔成两个容器中的两个进程：前端容器要处理用户交互和业务逻辑，
但无法看到私钥；签名容器可以看到私钥，并对来自前端的简单签名请求作出响应
（例如，通过本地主机网络）。</p><p>采用这种划分的方法，攻击者现在必须欺骗应用服务器来做一些其他操作，
而这些操作可能要比读取一个文件要复杂很多。</p><h2 id=secret-types>Secret 的类型</h2><p>创建 Secret 时，你可以使用 <a href=/zh-cn/docs/reference/kubernetes-api/config-and-storage-resources/secret-v1/>Secret</a>
资源的 <code>type</code> 字段，或者与其等价的 <code>kubectl</code> 命令行参数（如果有的话）为其设置类型。
Secret 类型有助于对 Secret 数据进行编程处理。</p><p>Kubernetes 提供若干种内置的类型，用于一些常见的使用场景。
针对这些类型，Kubernetes 所执行的合法性检查操作以及对其所实施的限制各不相同。</p><table><thead><tr><th>内置类型</th><th>用法</th></tr></thead><tbody><tr><td><code>Opaque</code></td><td>用户定义的任意数据</td></tr><tr><td><code>kubernetes.io/service-account-token</code></td><td>服务账号令牌</td></tr><tr><td><code>kubernetes.io/dockercfg</code></td><td><code>~/.dockercfg</code> 文件的序列化形式</td></tr><tr><td><code>kubernetes.io/dockerconfigjson</code></td><td><code>~/.docker/config.json</code> 文件的序列化形式</td></tr><tr><td><code>kubernetes.io/basic-auth</code></td><td>用于基本身份认证的凭据</td></tr><tr><td><code>kubernetes.io/ssh-auth</code></td><td>用于 SSH 身份认证的凭据</td></tr><tr><td><code>kubernetes.io/tls</code></td><td>用于 TLS 客户端或者服务器端的数据</td></tr><tr><td><code>bootstrap.kubernetes.io/token</code></td><td>启动引导令牌数据</td></tr></tbody></table><p>通过为 Secret 对象的 <code>type</code> 字段设置一个非空的字符串值，你也可以定义并使用自己
Secret 类型（如果 <code>type</code> 值为空字符串，则被视为 <code>Opaque</code> 类型）。</p><p>Kubernetes 并不对类型的名称作任何限制。不过，如果你要使用内置类型之一，
则你必须满足为该类型所定义的所有要求。</p><p>如果你要定义一种公开使用的 Secret 类型，请遵守 Secret 类型的约定和结构，
在类型名签名添加域名，并用 <code>/</code> 隔开。
例如：<code>cloud-hosting.example.net/cloud-api-credentials</code>。</p><h3 id=opaque-secret>Opaque Secret</h3><p>当 Secret 配置文件中未作显式设定时，默认的 Secret 类型是 <code>Opaque</code>。
当你使用 <code>kubectl</code> 来创建一个 Secret 时，你会使用 <code>generic</code>
子命令来标明要创建的是一个 <code>Opaque</code> 类型 Secret。
例如，下面的命令会创建一个空的 <code>Opaque</code> 类型 Secret 对象：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret generic empty-secret
</span></span><span style=display:flex><span>kubectl get secret empty-secret
</span></span></code></pre></div><p>输出类似于</p><pre tabindex=0><code>NAME           TYPE     DATA   AGE
empty-secret   Opaque   0      2m6s
</code></pre><p><code>DATA</code> 列显示 Secret 中保存的数据条目个数。
在这个例子种，<code>0</code> 意味着你刚刚创建了一个空的 Secret。</p><h3 id=service-account-token-secrets>服务账号令牌 Secret</h3><p>类型为 <code>kubernetes.io/service-account-token</code> 的 Secret
用来存放标识某<a class=glossary-tooltip title='为在 Pod 中运行的进程提供标识。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/tasks/configure-pod-container/configure-service-account/ target=_blank aria-label=服务账号>服务账号</a>的令牌凭据。</p><p>从 v1.22 开始，这种类型的 Secret 不再被用来向 Pod 中加载凭据数据，
建议通过 <a href=/zh-cn/docs/reference/kubernetes-api/authentication-resources/token-request-v1/>TokenRequest</a>
API 来获得令牌，而不是使用服务账号令牌 Secret 对象。
通过 <code>TokenRequest</code> API 获得的令牌比保存在 Secret 对象中的令牌更加安全，
因为这些令牌有着被限定的生命期，并且不会被其他 API 客户端读取。
你可以使用 <a href=/docs/reference/generated/kubectl/kubectl-commands#-em-token-em-><code>kubectl create token</code></a>
命令调用 <code>TokenRequest</code> API 获得令牌。</p><p>只有在你无法使用 <code>TokenRequest</code> API 来获取令牌，
并且你能够接受因为将永不过期的令牌凭据写入到可读取的 API 对象而带来的安全风险时，
才应该创建服务账号令牌 Secret 对象。</p><p>使用这种 Secret 类型时，你需要确保对象的注解 <code>kubernetes.io/service-account-name</code>
被设置为某个已有的服务账号名称。
如果你同时负责 ServiceAccount 和 Secret 对象的创建，应该先创建 ServiceAccount 对象。</p><p>当 Secret 对象被创建之后，某个 Kubernetes<a class=glossary-tooltip title='控制器通过 API 服务器监控集群的公共状态，并致力于将当前状态转变为期望的状态。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/architecture/controller/ target=_blank aria-label=控制器>控制器</a>会填写
Secret 的其它字段，例如 <code>kubernetes.io/service-account.uid</code> 注解以及 <code>data</code> 字段中的
<code>token</code> 键值，使之包含实际的令牌内容。</p><p>下面的配置实例声明了一个服务账号令牌 Secret：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-sa-sample<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/service-account.name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;sa-name&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>kubernetes.io/service-account-token<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 你可以像 Opaque Secret 一样在这里添加额外的键/值偶对</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>extra</span>:<span style=color:#bbb> </span>YmFyCg==<span style=color:#bbb>
</span></span></span></code></pre></div><p>创建了 Secret 之后，等待 Kubernetes 在 <code>data</code> 字段中填充 <code>token</code> 主键。</p><p>参考 <a href=/zh-cn/docs/tasks/configure-pod-container/configure-service-account/>ServiceAccount</a>
文档了解服务账号的工作原理。你也可以查看
<a href=/docs/reference/generated/kubernetes-api/v1.25/#pod-v1-core><code>Pod</code></a>
资源中的 <code>automountServiceAccountToken</code> 和 <code>serviceAccountName</code> 字段文档，
进一步了解从 Pod 中引用服务账号凭据。</p><h3 id=docker-config-secrets>Docker 配置 Secret</h3><p>你可以使用下面两种 <code>type</code> 值之一来创建 Secret，用以存放用于访问容器镜像仓库的凭据：</p><ul><li><code>kubernetes.io/dockercfg</code></li><li><code>kubernetes.io/dockerconfigjson</code></li></ul><p><code>kubernetes.io/dockercfg</code> 是一种保留类型，用来存放 <code>~/.dockercfg</code> 文件的序列化形式。
该文件是配置 Docker 命令行的一种老旧形式。使用此 Secret 类型时，你需要确保
Secret 的 <code>data</code> 字段中包含名为 <code>.dockercfg</code> 的主键，其对应键值是用 base64
编码的某 <code>~/.dockercfg</code> 文件的内容。</p><p>类型 <code>kubernetes.io/dockerconfigjson</code> 被设计用来保存 JSON 数据的序列化形式，
该 JSON 也遵从 <code>~/.docker/config.json</code> 文件的格式规则，而后者是 <code>~/.dockercfg</code>
的新版本格式。使用此 Secret 类型时，Secret 对象的 <code>data</code> 字段必须包含
<code>.dockerconfigjson</code> 键，其键值为 base64 编码的字符串包含 <code>~/.docker/config.json</code>
文件的内容。</p><p>下面是一个 <code>kubernetes.io/dockercfg</code> 类型 Secret 的示例：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-dockercfg<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>kubernetes.io/dockercfg<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>.dockercfg</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    </span><span style=color:#bbb>    </span><span style=color:#b44>&#34;&lt;base64 encoded ~/.dockercfg file&gt;&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>如果你不希望执行 base64 编码转换，可以使用 <code>stringData</code> 字段代替。</div><p>当你使用清单文件来创建这两类 Secret 时，API 服务器会检查 <code>data</code> 字段中是否存在所期望的主键，
并且验证其中所提供的键值是否是合法的 JSON 数据。
不过，API 服务器不会检查 JSON 数据本身是否是一个合法的 Docker 配置文件内容。</p><p>当你没有 Docker 配置文件，或者你想使用 <code>kubectl</code> 创建一个 Secret
来访问容器仓库时，你可以这样做：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret docker-registry secret-tiger-docker <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --docker-email<span style=color:#666>=</span>tiger@acme.example <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --docker-username<span style=color:#666>=</span>tiger <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --docker-password<span style=color:#666>=</span>pass1234 <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --docker-server<span style=color:#666>=</span>my-registry.example:5000
</span></span></code></pre></div><p>上面的命令创建一个类型为 <code>kubernetes.io/dockerconfigjson</code> 的 Secret。
如果你对 <code>.data.dockerconfigjson</code> 内容进行转储并执行 base64 解码：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get secret secret-tiger-docker -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.data.*}&#39;</span> | base64 -d
</span></span></code></pre></div><p>那么输出等价于这个 JSON 文档（这也是一个有效的 Docker 配置文件）：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;auths&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;my-registry.example:5000&#34;</span>: {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;username&#34;</span>: <span style=color:#b44>&#34;tiger&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;password&#34;</span>: <span style=color:#b44>&#34;pass1234&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;email&#34;</span>: <span style=color:#b44>&#34;tiger@acme.example&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;auth&#34;</span>: <span style=color:#b44>&#34;dGlnZXI6cGFzczEyMzQ=&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p><code>auths</code> 值是 base64 编码的，其内容被屏蔽但未被加密。
任何能够读取该 Secret 的人都可以了解镜像库的访问令牌。</div><h3 id=basic-authentication-secret>基本身份认证 Secret</h3><p><code>kubernetes.io/basic-auth</code> 类型用来存放用于基本身份认证所需的凭据信息。
使用这种 Secret 类型时，Secret 的 <code>data</code> 字段必须包含以下两个键之一：</p><ul><li><code>username</code>: 用于身份认证的用户名；</li><li><code>password</code>: 用于身份认证的密码或令牌。</li></ul><p>以上两个键的键值都是 base64 编码的字符串。
当然你也可以在创建 Secret 时使用 <code>stringData</code> 字段来提供明文形式的内容。
以下清单是基本身份验证 Secret 的示例：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-basic-auth<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>kubernetes.io/basic-auth<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>stringData</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>username</span>:<span style=color:#bbb> </span>admin     <span style=color:#bbb> </span><span style=color:#080;font-style:italic># kubernetes.io/basic-auth 类型的必需字段</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>password</span>:<span style=color:#bbb> </span>t0p-Secret<span style=color:#bbb> </span><span style=color:#080;font-style:italic># kubernetes.io/basic-auth 类型的必需字段</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>提供基本身份认证类型的 Secret 仅仅是出于方便性考虑。
你也可以使用 <code>Opaque</code> 类型来保存用于基本身份认证的凭据。
不过，使用预定义的、公开的 Secret 类型（<code>kubernetes.io/basic-auth</code>）
有助于帮助其他用户理解 Secret 的目的，并且对其中存在的主键形成一种约定。
API 服务器会检查 Secret 配置中是否提供了所需要的主键。</p><h3 id=ssh-authentication-secrets>SSH 身份认证 Secret</h3><p>Kubernetes 所提供的内置类型 <code>kubernetes.io/ssh-auth</code> 用来存放 SSH 身份认证中所需要的凭据。
使用这种 Secret 类型时，你就必须在其 <code>data</code> （或 <code>stringData</code>）
字段中提供一个 <code>ssh-privatekey</code> 键值对，作为要使用的 SSH 凭据。</p><p>下面的清单是一个 SSH 公钥/私钥身份认证的 Secret 示例：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-ssh-auth<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>kubernetes.io/ssh-auth<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 此例中的实际数据被截断</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ssh-privatekey</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>     </span><span style=color:#bbb>     </span>MIIEpQIBAAKCAQEAulqb/Y ...<span style=color:#bbb>
</span></span></span></code></pre></div><p>提供 SSH 身份认证类型的 Secret 仅仅是出于用户方便性考虑。
你也可以使用 <code>Opaque</code> 类型来保存用于 SSH 身份认证的凭据。
不过，使用预定义的、公开的 Secret 类型（<code>kubernetes.io/ssh-auth</code>）
有助于其他人理解你的 Secret 的用途，也可以就其中包含的主键名形成约定。
API 服务器确实会检查 Secret 配置中是否提供了所需要的主键。</p><div class="alert alert-warning caution callout" role=alert><strong>注意：</strong><p>SSH 私钥自身无法建立 SSH 客户端与服务器端之间的可信连接。
需要其它方式来建立这种信任关系，以缓解“中间人（Man In The Middle）”
攻击，例如向 ConfigMap 中添加一个 <code>known_hosts</code> 文件。</div><h3 id=tls-secret>TLS Secret</h3><p>Kubernetes 提供一种内置的 <code>kubernetes.io/tls</code> Secret 类型，用来存放 TLS
场合通常要使用的证书及其相关密钥。
TLS Secret 的一种典型用法是为 <a href=/zh-cn/docs/concepts/services-networking/ingress/>Ingress</a>
资源配置传输过程中的数据加密，不过也可以用于其他资源或者直接在负载中使用。
当使用此类型的 Secret 时，Secret 配置中的 <code>data</code> （或 <code>stringData</code>）字段必须包含
<code>tls.key</code> 和 <code>tls.crt</code> 主键，尽管 API 服务器实际上并不会对每个键的取值作进一步的合法性检查。</p><p>下面的 YAML 包含一个 TLS Secret 的配置示例：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-tls<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>kubernetes.io/tls<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 此例中的数据被截断</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>tls.crt</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    </span><span style=color:#bbb>    </span>MIIC2DCCAcCgAwIBAgIBATANBgkqh ...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>tls.key</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    </span><span style=color:#bbb>    </span>MIIEpgIBAAKCAQEA7yn3bRHQ5FHMQ ...<span style=color:#bbb>
</span></span></span></code></pre></div><p>提供 TLS 类型的 Secret 仅仅是出于用户方便性考虑。
你也可以使用 <code>Opaque</code> 类型来保存用于 TLS 服务器与/或客户端的凭据。
不过，使用内置的 Secret 类型的有助于对凭据格式进行归一化处理，并且
API 服务器确实会检查 Secret 配置中是否提供了所需要的主键。</p><p>当使用 <code>kubectl</code> 来创建 TLS Secret 时，你可以像下面的例子一样使用 <code>tls</code>
子命令：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret tls my-tls-secret <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --cert<span style=color:#666>=</span>path/to/cert/file <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --key<span style=color:#666>=</span>path/to/key/file
</span></span></code></pre></div><p>这里的公钥/私钥对都必须事先已存在。用于 <code>--cert</code> 的公钥证书必须是
<a href=https://datatracker.ietf.org/doc/html/rfc7468#section-5.1>RFC 7468 中 5.1 节</a>
中所规定的 DER 格式，且与 <code>--key</code> 所给定的私钥匹配。
私钥必须是 DER 格式的 PKCS #8
（参见 <a href=https://datatracker.ietf.org/doc/html/rfc7468#section-11>RFC 7468 第 11节</a>）。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>类型为 <code>kubernetes.io/tls</code> 的 Secret 中包含密钥和证书的 DER 数据，以 Base64 格式编码。
如果你熟悉私钥和证书的 PEM 格式，base64 与该格式相同，只是你需要略过 PEM
数据中所包含的第一行和最后一行。</p><p>例如，对于证书而言，你 <strong>不要</strong> 包含 <code>--------BEGIN CERTIFICATE-----</code>
和 <code>-------END CERTIFICATE----</code> 这两行。</p></div><h3 id=bootstrap-token-secrets>启动引导令牌 Secret</h3><p>通过将 Secret 的 <code>type</code> 设置为 <code>bootstrap.kubernetes.io/token</code>
可以创建启动引导令牌类型的 Secret。这种类型的 Secret 被设计用来支持节点的启动引导过程。
其中包含用来为周知的 ConfigMap 签名的令牌。</p><p>启动引导令牌 Secret 通常创建于 <code>kube-system</code> 名字空间内，并以
<code>bootstrap-token-&lt;令牌 ID></code> 的形式命名；
其中 <code>&lt;令牌 ID></code> 是一个由 6 个字符组成的字符串，用作令牌的标识。</p><p>以 Kubernetes 清单文件的形式，某启动引导令牌 Secret 可能看起来像下面这样：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>bootstrap-token-5emitj<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>bootstrap.kubernetes.io/token<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>auth-extra-groups</span>:<span style=color:#bbb> </span>c3lzdGVtOmJvb3RzdHJhcHBlcnM6a3ViZWFkbTpkZWZhdWx0LW5vZGUtdG9rZW4=<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>expiration</span>:<span style=color:#bbb> </span>MjAyMC0wOS0xM1QwNDozOToxMFo=<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>token-id</span>:<span style=color:#bbb> </span>NWVtaXRq<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>token-secret</span>:<span style=color:#bbb> </span>a3E0Z2lodnN6emduMXAwcg==<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>usage-bootstrap-authentication</span>:<span style=color:#bbb> </span>dHJ1ZQ==<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>usage-bootstrap-signing</span>:<span style=color:#bbb> </span>dHJ1ZQ==<span style=color:#bbb>
</span></span></span></code></pre></div><p>启动引导令牌类型的 Secret 会在 <code>data</code> 字段中包含如下主键：</p><ul><li><code>token-id</code>：由 6 个随机字符组成的字符串，作为令牌的标识符。必需。</li><li><code>token-secret</code>：由 16 个随机字符组成的字符串，包含实际的令牌机密。必需。</li><li><code>description</code>：供用户阅读的字符串，描述令牌的用途。可选。</li><li><code>expiration</code>：一个使用 <a href=https://datatracker.ietf.org/doc/html/rfc3339>RFC3339</a>
来编码的 UTC 绝对时间，给出令牌要过期的时间。可选。</li><li><code>usage-bootstrap-&lt;usage></code>：布尔类型的标志，用来标明启动引导令牌的其他用途。</li><li><code>auth-extra-groups</code>：用逗号分隔的组名列表，身份认证时除被认证为
<code>system:bootstrappers</code> 组之外，还会被添加到所列的用户组中。</li></ul><p>上面的 YAML 文件可能看起来令人费解，因为其中的数值均为 base64 编码的字符串。
实际上，你完全可以使用下面的 YAML 来创建一个一模一样的 Secret：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 注意 Secret 的命名方式</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>bootstrap-token-5emitj<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 启动引导令牌 Secret 通常位于 kube-system 名字空间</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>bootstrap.kubernetes.io/token<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>stringData</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>auth-extra-groups</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;system:bootstrappers:kubeadm:default-node-token&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>expiration</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2020-09-13T04:39:10Z&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 此令牌 ID 被用于生成 Secret 名称</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>token-id</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;5emitj&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>token-secret</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;kq4gihvszzgn1p0r&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 此令牌还可用于 authentication （身份认证）</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>usage-bootstrap-authentication</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 且可用于 signing （证书签名）</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>usage-bootstrap-signing</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=secret-immutable>不可更改的 Secret</h2><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.21 [stable]</code></div><p>Kubernetes 允许你将特定的 Secret（和 ConfigMap）标记为 <strong>不可更改（Immutable）</strong>。
禁止更改现有 Secret 的数据有下列好处：</p><ul><li>防止意外（或非预期的）更新导致应用程序中断</li><li>（对于大量使用 Secret 的集群而言，至少数万个不同的 Secret 供 Pod 挂载），
通过将 Secret 标记为不可变，可以极大降低 kube-apiserver 的负载，提升集群性能。
kubelet 不需要监视那些被标记为不可更改的 Secret。</li></ul><h3 id=secret-immutable-create>将 Secret 标记为不可更改</h3><p>你可以通过将 Secret 的 <code>immutable</code> 字段设置为 <code>true</code> 创建不可更改的 Secret。
例如：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>immutable</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>你也可以更改现有的 Secret，令其不可更改。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>一旦一个 Secret 或 ConfigMap 被标记为不可更改，撤销此操作或者更改 <code>data</code>
字段的内容都是 <strong>不</strong> 可能的。
只能删除并重新创建这个 Secret。现有的 Pod 将维持对已删除 Secret 的挂载点 --
建议重新创建这些 Pod。</div><h2 id=information-security-for-secrets>Secret 的信息安全问题</h2><p>尽管 ConfigMap 和 Secret 的工作方式类似，但 Kubernetes 对 Secret 有一些额外的保护。</p><p>Secret 通常保存重要性各异的数值，其中很多都可能会导致 Kubernetes 中
（例如，服务账号令牌）或对外部系统的特权提升。
即使某些个别应用能够推导它期望使用的 Secret 的能力，
同一名字空间中的其他应用可能会让这种假定不成立。</p><p>只有当某个节点上的 Pod 需要某 Secret 时，对应的 Secret 才会被发送到该节点上。
如果将 Secret 挂载到 Pod 中，kubelet 会将数据的副本保存在在 <code>tmpfs</code> 中，
这样机密的数据不会被写入到持久性存储中。
一旦依赖于该 Secret 的 Pod 被删除，kubelet 会删除来自于该 Secret 的机密数据的本地副本。</p><p>同一个 Pod 中可能包含多个容器。默认情况下，你所定义的容器只能访问默认 ServiceAccount
及其相关 Secret。你必须显式地定义环境变量或者将卷映射到容器中，才能为容器提供对其他
Secret 的访问。</p><p>针对同一节点上的多个 Pod 可能有多个 Secret。不过，只有某个 Pod 所请求的 Secret
才有可能对 Pod 中的容器可见。因此，一个 Pod 不会获得访问其他 Pod 的 Secret 的权限。</p><div class="alert alert-danger warning callout" role=alert><strong>警告：</strong><p>在一个节点上以 <code>privileged: true</code> 运行的所有容器可以访问该节点上使用的所有 Secret。</div><h2 id=接下来>接下来</h2><ul><li>有关管理和提升 Secret 安全性的指南，请参阅 <a href=/zh-cn/docs/concepts/security/secrets-good-practices>Kubernetes Secret 良好实践</a></li><li>学习如何<a href=/zh-cn/docs/tasks/configmap-secret/managing-secret-using-kubectl/>使用 <code>kubectl</code> 管理 Secret</a></li><li>学习如何<a href=/zh-cn/docs/tasks/configmap-secret/managing-secret-using-config-file/>使用配置文件管理 Secret</a></li><li>学习如何<a href=/zh-cn/docs/tasks/configmap-secret/managing-secret-using-kustomize/>使用 kustomize 管理 Secret</a></li><li>阅读 <a href=/zh-cn/docs/reference/kubernetes-api/config-and-storage-resources/secret-v1/>API 参考</a>了解 <code>Secret</code></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-436057b96151ecb8a4a9a9f456b5d0fc>4 - 为 Pod 和容器管理资源</h1><p>当你定义 <a class=glossary-tooltip title='Pod 表示你的集群上一组正在运行的容器。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/workloads/pods/ target=_blank aria-label=Pod>Pod</a> 时可以选择性地为每个
<a class=glossary-tooltip title=容器是可移植、可执行的轻量级的镜像，镜像中包含软件及其相关依赖。 data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/overview/what-is-kubernetes/#why-containers target=_blank aria-label=容器>容器</a>设定所需要的资源数量。
最常见的可设定资源是 CPU 和内存（RAM）大小；此外还有其他类型的资源。</p><p>当你为 Pod 中的 Container 指定了资源 <strong>请求</strong> 时，
<a class=glossary-tooltip title='控制平面组件，负责监视新创建的、未指定运行节点的 Pod，选择节点让 Pod 在上面运行。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/reference/command-line-tools-reference/kube-scheduler/ target=_blank aria-label=kube-scheduler>kube-scheduler</a>
就利用该信息决定将 Pod 调度到哪个节点上。
当你还为 Container 指定了资源 <strong>限制</strong> 时，kubelet 就可以确保运行的容器不会使用超出所设限制的资源。
kubelet 还会为容器预留所 <strong>请求</strong> 数量的系统资源，供其使用。</p><h2 id=requests-and-limits>请求和限制</h2><p>如果 Pod 运行所在的节点具有足够的可用资源，容器可能（且可以）使用超出对应资源
<code>request</code> 属性所设置的资源量。不过，容器不可以使用超出其资源 <code>limit</code>
属性所设置的资源量。</p><p>例如，如果你将容器的 <code>memory</code> 的请求量设置为 256 MiB，而该容器所处的 Pod
被调度到一个具有 8 GiB 内存的节点上，并且该节点上没有其他 Pod
运行，那么该容器就可以尝试使用更多的内存。</p><p>如果你将某容器的 <code>memory</code> 限制设置为 4 GiB，kubelet
（和<a class=glossary-tooltip title=容器运行时是负责运行容器的软件。 data-toggle=tooltip data-placement=top href=/zh-cn/docs/setup/production-environment/container-runtimes target=_blank aria-label=容器运行时>容器运行时</a>）就会确保该限制生效。
容器运行时会禁止容器使用超出所设置资源限制的资源。
例如：当容器中进程尝试使用超出所允许内存量的资源时，系统内核会将尝试申请内存的进程终止，
并引发内存不足（OOM）错误。</p><p>限制可以以被动方式来实现（系统会在发现违例时进行干预），或者通过强制生效的方式实现
（系统会避免容器用量超出限制）。不同的容器运行时采用不同方式来实现相同的限制。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>如果你为某个资源指定了限制，但不指定请求，
并且没有应用准入时机制为该资源设置默认请求，
然后 Kubernetes 复制你所指定的限制值，将其用作资源的请求值。</div><h2 id=resource-types>资源类型</h2><p><strong>CPU</strong> 和 <strong>内存</strong> 都是 <strong>资源类型</strong>。每种资源类型具有其基本单位。
CPU 表达的是计算处理能力，其单位是 <a href=#meaning-of-cpu>Kubernetes CPU</a>。
内存的单位是字节。
对于 Linux 负载，则可以指定巨页（Huge Page）资源。
巨页是 Linux 特有的功能，节点内核在其中分配的内存块比默认页大小大得多。</p><p>例如，在默认页面大小为 4KiB 的系统上，你可以指定限制 <code>hugepages-2Mi: 80Mi</code>。
如果容器尝试分配 40 个 2MiB 大小的巨页（总共 80 MiB ），则分配请求会失败。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>你不能过量使用 <code>hugepages- *</code> 资源。
这与 <code>memory</code> 和 <code>cpu</code> 资源不同。</div><p>CPU 和内存统称为 <strong>计算资源</strong>，或简称为 <strong>资源</strong>。
计算资源的数量是可测量的，可以被请求、被分配、被消耗。
它们与 <a href=/zh-cn/docs/concepts/overview/kubernetes-api/>API 资源</a>不同。
API 资源（如 Pod 和 <a href=/zh-cn/docs/concepts/services-networking/service/>Service</a>）是可通过
Kubernetes API 服务器读取和修改的对象。</p><h2 id=resource-requests-and-limits-of-pod-and-container>Pod 和 容器的资源请求和限制</h2><p>针对每个容器，你都可以指定其资源限制和请求，包括如下选项：</p><ul><li><code>spec.containers[].resources.limits.cpu</code></li><li><code>spec.containers[].resources.limits.memory</code></li><li><code>spec.containers[].resources.limits.hugepages-&lt;size></code></li><li><code>spec.containers[].resources.requests.cpu</code></li><li><code>spec.containers[].resources.requests.memory</code></li><li><code>spec.containers[].resources.requests.hugepages-&lt;size></code></li></ul><p>尽管你只能逐个容器地指定请求和限制值，考虑 Pod 的总体资源请求和限制也是有用的。
对特定资源而言，<strong>Pod 的资源请求/限制</strong> 是 Pod 中各容器对该类型资源的请求/限制的总和。</p><h2 id=resource-units-in-kubernetes>Kubernetes 中的资源单位</h2><h3 id=meaning-of-cpu>CPU 资源单位</h3><p>CPU 资源的限制和请求以 “cpu” 为单位。
在 Kubernetes 中，一个 CPU 等于 <strong>1 个物理 CPU 核</strong> 或者 <strong>1 个虚拟核</strong>，
取决于节点是一台物理主机还是运行在某物理主机上的虚拟机。</p><p>你也可以表达带小数 CPU 的请求。
当你定义一个容器，将其 <code>spec.containers[].resources.requests.cpu</code> 设置为 0.5 时，
你所请求的 CPU 是你请求 <code>1.0</code> CPU 时的一半。
对于 CPU 资源单位，<a href=/zh-cn/docs/reference/kubernetes-api/common-definitions/quantity/>数量</a>
表达式 <code>0.1</code> 等价于表达式 <code>100m</code>，可以看作 “100 millicpu”。
有些人说成是“一百毫核”，其实说的是同样的事情。</p><p>CPU 资源总是设置为资源的绝对数量而非相对数量值。
例如，无论容器运行在单核、双核或者 48-核的机器上，<code>500m</code> CPU 表示的是大约相同的计算能力。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>Kubernetes 不允许设置精度小于 <code>1m</code> 的 CPU 资源。
因此，当 CPU 单位小于 <code>1</code> 或 <code>1000m</code> 时，使用毫核的形式是有用的；
例如 <code>5m</code> 而不是 <code>0.005</code>。</div><h2 id=meaning-of-memory>内存资源单位</h2><p><code>memory</code> 的限制和请求以字节为单位。
你可以使用普通的整数，或者带有以下
<a href=/zh-cn/docs/reference/kubernetes-api/common-definitions/quantity/>数量</a>后缀
的定点数字来表示内存：E、P、T、G、M、k。
你也可以使用对应的 2 的幂数：Ei、Pi、Ti、Gi、Mi、Ki。
例如，以下表达式所代表的是大致相同的值：</p><pre tabindex=0><code>128974848、129e6、129M、128974848000m、123Mi
</code></pre><p>请注意后缀的大小写。如果你请求 <code>400m</code> 临时存储，实际上所请求的是 0.4 字节。
如果有人这样设定资源请求或限制，可能他的实际想法是申请 400Mi 字节（<code>400Mi</code>）
或者 400M 字节。</p><h2 id=example-1>容器资源示例</h2><p>以下 Pod 有两个容器。每个容器的请求为 0.25 CPU 和 64MiB（2<sup>26</sup> 字节）内存，
每个容器的资源限制为 0.5 CPU 和 128MiB 内存。
你可以认为该 Pod 的资源请求为 0.5 CPU 和 128 MiB 内存，资源限制为 1 CPU 和 256MiB 内存。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>app<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>images.my-company.example/app:v4<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;64Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;250m&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;128Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;500m&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>log-aggregator<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>images.my-company.example/log-aggregator:v6<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;64Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;250m&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>memory</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;128Mi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;500m&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=how-pods-with-resource-limits-are-run>带资源请求的 Pod 如何调度</h2><p>当你创建一个 Pod 时，Kubernetes 调度程序将为 Pod 选择一个节点。
每个节点对每种资源类型都有一个容量上限：可为 Pod 提供的 CPU 和内存量。
调度程序确保对于每种资源类型，所调度的容器的资源请求的总和小于节点的容量。
请注意，尽管节点上的实际内存或 CPU 资源使用量非常低，如果容量检查失败，
调度程序仍会拒绝在该节点上放置 Pod。
当稍后节点上资源用量增加，例如到达请求率的每日峰值区间时，节点上也不会出现资源不足的问题。</p><h2 id=how-pods-with-resource-limits-are-run>Kubernetes 应用资源请求与限制的方式</h2><p>当 kubelet 将容器作为 Pod 的一部分启动时，它会将容器的 CPU 和内存请求与限制信息传递给容器运行时。</p><p>在 Linux 系统上，容器运行时通常会配置内核
<a class=glossary-tooltip title='一组具有可选资源隔离、审计和限制的 Linux 进程。' data-toggle=tooltip data-placement=top href='/zh-cn/docs/reference/glossary/?all=true#term-cgroup' target=_blank aria-label=CGroups>CGroups</a>，负责应用并实施所定义的请求。</p><ul><li>CPU 限制定义的是容器可使用的 CPU 时间的硬性上限。
在每个调度周期（时间片）期间，Linux 内核检查是否已经超出该限制；
内核会在允许该 cgroup 恢复执行之前会等待。</li></ul><ul><li>CPU 请求值定义的是一个权重值。如果若干不同的容器（CGroups）需要在一个共享的系统上竞争运行，
CPU 请求值大的负载会获得比请求值小的负载更多的 CPU 时间。</li></ul><ul><li>内存请求值主要用于（Kubernetes）Pod 调度期间。在一个启用了 CGroup v2 的节点上，
容器运行时可能会使用内存请求值作为设置 <code>memory.min</code> 和 <code>memory.low</code> 的提示值。</li></ul><ul><li>内存限制定义的是 cgroup 的内存限制。如果容器尝试分配的内存量超出限制，
则 Linux 内核的内存不足处理子系统会被激活，并停止尝试分配内存的容器中的某个进程。
如果该进程在容器中 PID 为 1，而容器被标记为可重新启动，则 Kubernetes
会重新启动该容器。</li></ul><ul><li>Pod 或容器的内存限制也适用于通过内存供应的卷，例如 <code>emptyDir</code> 卷。
kubelet 会跟踪 <code>tmpfs</code> 形式的 emptyDir 卷用量，将其作为容器的内存用量，
而不是临时存储用量。</li></ul><p>如果某容器内存用量超过其内存请求值并且所在节点内存不足时，容器所处的 Pod
可能被<a class=glossary-tooltip title='终止节点上一个或多个 Pod 的过程。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/scheduling-eviction/ target=_blank aria-label=逐出>逐出</a>。</p><p>每个容器可能被允许也可能不被允许使用超过其 CPU 限制的处理时间。
但是，容器运行时不会由于 CPU 使用率过高而杀死 Pod 或容器。</p><p>要确定某容器是否会由于资源限制而无法调度或被杀死，请参阅<a href=#troubleshooting>疑难解答</a>节。</p><h3 id=monitoring-compute-memory-resource-usage>监控计算和内存资源用量</h3><p>kubelet 会将 Pod 的资源使用情况作为 Pod
<a href=/zh-cn/docs/concepts/overview/working-with-objects/kubernetes-objects/#object-spec-and-status><code>status</code></a>
的一部分来报告的。</p><p>如果为集群配置了可选的<a href=/zh-cn/docs/tasks/debug/debug-cluster/resource-usage-monitoring/>监控工具</a>，
则可以直接从<a href=/zh-cn/docs/tasks/debug/debug-cluster/resource-metrics-pipeline/#metrics-api>指标 API</a>
或者监控工具获得 Pod 的资源使用情况。</p><h2 id=local-ephemeral-storage>本地临时存储</h2><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.25 [stable]</code></div><p>节点通常还可以具有本地的临时性存储，由本地挂接的可写入设备或者有时也用 RAM
来提供支持。
“临时（Ephemeral）”意味着对所存储的数据不提供长期可用性的保证。</p><p>Pods 通常可以使用临时性本地存储来实现缓冲区、保存日志等功能。
kubelet 可以为使用本地临时存储的 Pods 提供这种存储空间，允许后者使用
<a href=/zh-cn/docs/concepts/storage/volumes/#emptydir><code>emptyDir</code></a>
类型的<a class=glossary-tooltip title='包含可被 Pod 中容器访问的数据的目录。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/storage/volumes/ target=_blank aria-label=卷>卷</a>将其挂载到容器中。</p><p>kubelet 也使用此类存储来保存<a href=/zh-cn/docs/concepts/cluster-administration/logging/#logging-at-the-node-level>节点层面的容器日志</a>、
容器镜像文件以及运行中容器的可写入层。</p><div class="alert alert-warning caution callout" role=alert><strong>注意：</strong> 如果节点失效，存储在临时性存储中的数据会丢失。
你的应用不能对本地临时性存储的性能 SLA（例如磁盘 IOPS）作任何假定。</div><p>作为一种 beta 阶段功能特性，Kubernetes 允许你跟踪、预留和限制 Pod
可消耗的临时性本地存储数量。</p><h3 id=configurations-for-local-ephemeral-storage>本地临时性存储的配置</h3><p>Kubernetes 有两种方式支持节点上配置本地临时性存储：</p><ul class="nav nav-tabs" id=local-storage-configurations role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#local-storage-configurations-0 role=tab aria-controls=local-storage-configurations-0 aria-selected=true>单一文件系统</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#local-storage-configurations-1 role=tab aria-controls=local-storage-configurations-1>双文件系统</a></li></ul><div class=tab-content id=local-storage-configurations><div id=local-storage-configurations-0 class="tab-pane show active" role=tabpanel aria-labelledby=local-storage-configurations-0><p><p>采用这种配置时，你会把所有类型的临时性本地数据（包括 <code>emptyDir</code>
卷、可写入容器层、容器镜像、日志等）放到同一个文件系统中。
作为最有效的 kubelet 配置方式，这意味着该文件系统是专门提供给 Kubernetes
（kubelet）来保存数据的。</p><p>kubelet 也会生成<a href=/zh-cn/docs/concepts/cluster-administration/logging/#logging-at-the-node-level>节点层面的容器日志</a>，
并按临时性本地存储的方式对待之。</p><p>kubelet 会将日志写入到所配置的日志目录（默认为 <code>/var/log</code>）下的文件中；
还会针对其他本地存储的数据使用同一个基础目录（默认为 <code>/var/lib/kubelet</code>）。</p><p>通常，<code>/var/lib/kubelet</code> 和 <code>/var/log</code> 都是在系统的根文件系统中。kubelet
的设计也考虑到这一点。</p><p>你的集群节点当然可以包含其他的、并非用于 Kubernetes 的很多文件系统。</p></div><div id=local-storage-configurations-1 class=tab-pane role=tabpanel aria-labelledby=local-storage-configurations-1><p><p>你使用节点上的某个文件系统来保存运行 Pods 时产生的临时性数据：日志和
<code>emptyDir</code> 卷等。你可以使用这个文件系统来保存其他数据（例如：与 Kubernetes
无关的其他系统日志）；这个文件系统还可以是根文件系统。</p><p>kubelet 也将<a href=/zh-cn/docs/concepts/cluster-administration/logging/#logging-at-the-node-level>节点层面的容器日志</a>
写入到第一个文件系统中，并按临时性本地存储的方式对待之。</p><p>同时你使用另一个由不同逻辑存储设备支持的文件系统。在这种配置下，你会告诉
kubelet 将容器镜像层和可写层保存到这第二个文件系统上的某个目录中。</p><p>第一个文件系统中不包含任何镜像层和可写层数据。</p><p>当然，你的集群节点上还可以有很多其他与 Kubernetes 没有关联的文件系统。</p></div></div><p>kubelet 能够度量其本地存储的用量。
实现度量机制的前提是你已使用本地临时存储所支持的配置之一对节点进行配置。</p><p>如果你的节点配置不同于以上预期，kubelet 就无法对临时性本地存储实施资源限制。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>kubelet 会将 <code>tmpfs</code> emptyDir 卷的用量当作容器内存用量，而不是本地临时性存储来统计。</div><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>kubelet 将仅跟踪临时存储的根文件系统。
挂载一个单独磁盘到 <code>/var/lib/kubelet</code> 或 <code>/var/lib/containers</code> 的操作系统布局将不会正确地报告临时存储。</div><h3 id=setting-requests-and-limits-for-local-ephemeral-storage>为本地临时性存储设置请求和限制</h3><p>你可以指定 <code>ephemeral-storage</code> 来管理本地临时性存储。
Pod 中的每个容器可以设置以下属性：</p><ul><li><code>spec.containers[].resources.limits.ephemeral-storage</code></li><li><code>spec.containers[].resources.requests.ephemeral-storage</code></li></ul><p><code>ephemeral-storage</code> 的请求和限制是按量纲计量的。
你可以使用一般整数或者定点数字加上下面的后缀来表达存储量：E、P、T、G、M、k。
你也可以使用对应的 2 的幂级数来表达：Ei、Pi、Ti、Gi、Mi、Ki。
例如，下面的表达式所表达的大致是同一个值：</p><ul><li><code>128974848</code></li><li><code>129e6</code></li><li><code>129M</code></li><li><code>123Mi</code></li></ul><p>请注意后缀的大小写。如果你请求 <code>400m</code> 临时存储，实际上所请求的是 0.4 字节。
如果有人这样设定资源请求或限制，可能他的实际想法是申请 400Mi 字节（<code>400Mi</code>）
或者 400M 字节。</p><p>在下面的例子中，Pod 包含两个容器。每个容器请求 2 GiB 大小的本地临时性存储。
每个容器都设置了 4 GiB 作为其本地临时性存储的限制。
因此，整个 Pod 的本地临时性存储请求是 4 GiB，且其本地临时性存储的限制为 8 GiB。
该限制值中有 500Mi 可供 <code>emptyDir</code> 卷使用。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>frontend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>app<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>images.my-company.example/app:v4<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ephemeral-storage</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2Gi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ephemeral-storage</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;4Gi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>ephemeral<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/tmp&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>log-aggregator<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>images.my-company.example/log-aggregator:v6<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ephemeral-storage</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2Gi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ephemeral-storage</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;4Gi&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>volumeMounts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>ephemeral<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>mountPath</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/tmp&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>volumes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>ephemeral<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>emptyDir</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>sizeLimit</span>:<span style=color:#bbb> </span>500Mi<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=how-pods-with-ephemeral-storage-requests-are-scheduled>带临时性存储的 Pods 的调度行为</h3><p>当你创建一个 Pod 时，Kubernetes 调度器会为 Pod 选择一个节点来运行之。
每个节点都有一个本地临时性存储的上限，是其可提供给 Pod 使用的总量。
欲了解更多信息，
可参考<a href=/zh-cn/docs/tasks/administer-cluster/reserve-compute-resources/#node-allocatable>节点可分配资源</a>节。</p><p>调度器会确保所调度的容器的资源请求总和不会超出节点的资源容量。</p><h3 id=resource-emphemeralstorage-consumption>临时性存储消耗的管理</h3><p>如果 kubelet 将本地临时性存储作为资源来管理，则 kubelet 会度量以下各处的存储用量：</p><ul><li><code>emptyDir</code> 卷，除了 <strong>tmpfs</strong> <code>emptyDir</code> 卷</li><li>保存节点层面日志的目录</li><li>可写入的容器镜像层</li></ul><p>如果某 Pod 的临时存储用量超出了你所允许的范围，kubelet
会向其发出逐出（eviction）信号，触发该 Pod 被逐出所在节点。</p><p>就容器层面的隔离而言，如果某容器的可写入镜像层和日志用量超出其存储限制，
kubelet 也会将所在的 Pod 标记为逐出候选。</p><p>就 Pod 层面的隔离而言，kubelet 会将 Pod 中所有容器的限制相加，得到 Pod
存储限制的总值。如果所有容器的本地临时性存储用量总和加上 Pod 的 <code>emptyDir</code>
卷的用量超出 Pod 存储限制，kubelet 也会将该 Pod 标记为逐出候选。</p><div class="alert alert-warning caution callout" role=alert><strong>注意：</strong><p>如果 kubelet 没有度量本地临时性存储的用量，即使 Pod
的本地存储用量超出其限制也不会被逐出。</p><p>不过，如果用于可写入容器镜像层、节点层面日志或者 <code>emptyDir</code> 卷的文件系统中可用空间太少，
节点会为自身设置本地存储不足的<a class=glossary-tooltip title='污点是一种一个核心对象，包含三个必需的属性：key、value 和 effect。 污点会阻止在节点或节点组上调度 Pod。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/scheduling-eviction/taint-and-toleration/ target=_blank aria-label=污点>污点</a>标签。
这一污点会触发对那些无法容忍该污点的 Pod 的逐出操作。</p><p>关于临时性本地存储的配置信息，请参考<a href=#configurations-for-local-ephemeral-storage>这里</a></p></div><p>kubelet 支持使用不同方式来度量 Pod 的存储用量：</p><ul class="nav nav-tabs" id=resource-emphemeralstorage-measurement role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#resource-emphemeralstorage-measurement-0 role=tab aria-controls=resource-emphemeralstorage-measurement-0 aria-selected=true>周期性扫描</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#resource-emphemeralstorage-measurement-1 role=tab aria-controls=resource-emphemeralstorage-measurement-1>文件系统项目配额</a></li></ul><div class=tab-content id=resource-emphemeralstorage-measurement><div id=resource-emphemeralstorage-measurement-0 class="tab-pane show active" role=tabpanel aria-labelledby=resource-emphemeralstorage-measurement-0><p><p>kubelet 按预定周期执行扫描操作，检查 <code>emptyDir</code> 卷、容器日志目录以及可写入容器镜像层。</p><p>这一扫描会度量存储空间用量。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>项目配额（Project Quota）是一个操作系统层的功能特性，用来管理文件系统中的存储用量。
在 Kubernetes 中，你可以启用项目配额以监视存储用量。
你需要确保节点上为 <code>emptyDir</code> 提供存储的文件系统支持项目配额。
例如，XFS 和 ext4fs 文件系统都支持项目配额。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>项目配额可以帮你监视存储用量，但无法强制执行限制。</div><p>Kubernetes 所使用的项目 ID 始于 <code>1048576</code>。
所使用的 IDs 会注册在 <code>/etc/projects</code> 和 <code>/etc/projid</code> 文件中。
如果该范围中的项目 ID 已经在系统中被用于其他目的，则已占用的项目 ID
也必须注册到 <code>/etc/projects</code> 和 <code>/etc/projid</code> 中，这样 Kubernetes
才不会使用它们。</p><p>配额方式与目录扫描方式相比速度更快，结果更精确。当某个目录被分配给某个项目时，
该目录下所创建的所有文件都属于该项目，内核只需要跟踪该项目中的文件所使用的存储块个数。
如果某文件被创建后又被删除，但对应文件描述符仍处于打开状态，
该文件会继续耗用存储空间。配额跟踪技术能够精确第记录对应存储空间的状态，
而目录扫描方式会忽略被删除文件所占用的空间。</p><p>如果你希望使用项目配额，你需要：</p><ul><li><p>在 <a href=/zh-cn/docs/reference/config-api/kubelet-config.v1beta1/>kubelet 配置</a>中使用
<code>featureGates</code> 字段或者使用 <code>--feature-gates</code> 命令行参数启用
<code>LocalStorageCapacityIsolationFSQuotaMonitoring=true</code> <a href=/zh-cn/docs/reference/command-line-tools-reference/feature-gates/>特性门控</a>。</p></li><li><p>确保根文件系统（或者可选的运行时文件系统）启用了项目配额。所有 XFS
文件系统都支持项目配额。
对 extf 文件系统而言，你需要在文件系统尚未被挂载时启用项目配额跟踪特性：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#080;font-style:italic># 对 ext4 而言，在 /dev/block-device 尚未被挂载时执行下面操作</span>
</span></span><span style=display:flex><span>sudo tune2fs -O project -Q prjquota /dev/block-device
</span></span></code></pre></div></li><li><p>确保根文件系统（或者可选的运行时文件系统）在挂载时项目配额特性是被启用了的。
对于 XFS 和 ext4fs 而言，对应的挂载选项称作 <code>prjquota</code>。</p></li></ul></div></div><h2 id=extended-resources>扩展资源（Extended Resources）</h2><p>扩展资源是 <code>kubernetes.io</code> 域名之外的标准资源名称。
它们使得集群管理员能够颁布非 Kubernetes 内置资源，而用户可以使用他们。</p><p>使用扩展资源需要两个步骤。首先，集群管理员必须颁布扩展资源。
其次，用户必须在 Pod 中请求扩展资源。</p><h3 id=managing-extended-resources>管理扩展资源</h3><h4 id=node-level-extended-resources>节点级扩展资源</h4><p>节点级扩展资源绑定到节点。</p><h5 id=device-plugin-managed-resources>设备插件管理的资源</h5><p>有关如何颁布在各节点上由设备插件所管理的资源，
请参阅<a href=/zh-cn/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/>设备插件</a>。</p><h5 id=other-resources>其他资源</h5><p>为了颁布新的节点级扩展资源，集群操作员可以向 API 服务器提交 <code>PATCH</code> HTTP 请求，
以在集群中节点的 <code>status.capacity</code> 中为其配置可用数量。
完成此操作后，节点的 <code>status.capacity</code> 字段中将包含新资源。
kubelet 会异步地对 <code>status.allocatable</code> 字段执行自动更新操作，使之包含新资源。</p><p>由于调度器在评估 Pod 是否适合在某节点上执行时会使用节点的 <code>status.allocatable</code> 值，
调度器只会考虑异步更新之后的新值。
在更新节点容量使之包含新资源之后和请求该资源的第一个 Pod 被调度到该节点之间，
可能会有短暂的延迟。</p><p><strong>示例：</strong></p><p>这是一个示例，显示了如何使用 <code>curl</code> 构造 HTTP 请求，公告主节点为 <code>k8s-master</code>
的节点 <code>k8s-node-1</code> 上存在五个 <code>example.com/foo</code> 资源。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl --header <span style=color:#b44>&#34;Content-Type: application/json-patch+json&#34;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>--request PATCH <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>--data <span style=color:#b44>&#39;[{&#34;op&#34;: &#34;add&#34;, &#34;path&#34;: &#34;/status/capacity/example.com~1foo&#34;, &#34;value&#34;: &#34;5&#34;}]&#39;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>http://k8s-master:8080/api/v1/nodes/k8s-node-1/status
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>在前面的请求中，<code>~1</code> 是在 patch 路径中对字符 <code>/</code> 的编码。
JSON-Patch 中的操作路径的值被视为 JSON-Pointer 类型。
有关更多详细信息，请参见
<a href=https://tools.ietf.org/html/rfc6901#section-3>IETF RFC 6901 第 3 节</a>。</div><h4 id=cluster-level-extended-resources>集群层面的扩展资源</h4><p>集群层面的扩展资源并不绑定到具体节点。
它们通常由调度器扩展程序（Scheduler Extenders）管理，这些程序处理资源消耗和资源配额。</p><p>你可以在<a href=/zh-cn/docs/reference/config-api/kube-scheduler-config.v1beta3/>调度器配置</a>
中指定由调度器扩展程序处理的扩展资源。</p><p><strong>示例：</strong></p><p>下面的调度器策略配置标明集群层扩展资源 "example.com/foo" 由调度器扩展程序处理。</p><ul><li>仅当 Pod 请求 "example.com/foo" 时，调度器才会将 Pod 发送到调度器扩展程序。</li><li><code>ignoredByScheduler</code> 字段指定调度器不要在其 <code>PodFitsResources</code> 断言中检查
"example.com/foo" 资源。</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;Policy&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;v1&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;extenders&#34;</span>: [
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;urlPrefix&#34;</span>:<span style=color:#b44>&#34;&lt;extender-endpoint&gt;&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;bindVerb&#34;</span>: <span style=color:#b44>&#34;bind&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;managedResources&#34;</span>: [
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>          <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;example.com/foo&#34;</span>,
</span></span><span style=display:flex><span>          <span style=color:green;font-weight:700>&#34;ignoredByScheduler&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>      ]
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  ]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=consuming-extended-resources>使用扩展资源</h3><p>就像 CPU 和内存一样，用户可以在 Pod 的规约中使用扩展资源。
调度器负责资源的核算，确保同时分配给 Pod 的资源总量不会超过可用数量。</p><p>API 服务器将扩展资源的数量限制为整数。
<strong>有效</strong> 数量的示例是 <code>3</code>、<code>3000m</code> 和 <code>3Ki</code>。
<strong>无效</strong> 数量的示例是 <code>0.5</code> 和 <code>1500m</code>。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>扩展资源取代了非透明整数资源（Opaque Integer Resources，OIR）。
用户可以使用 <code>kubernetes.io</code>（保留）以外的任何域名前缀。</div><p>要在 Pod 中使用扩展资源，请在容器规约的 <code>spec.containers[].resources.limits</code>
映射中包含资源名称作为键。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>扩展资源不能过量使用，因此如果容器规约中同时存在请求和限制，则它们的取值必须相同。</div><p>仅当所有资源请求（包括 CPU、内存和任何扩展资源）都被满足时，Pod 才能被调度。
在资源请求无法满足时，Pod 会保持在 <code>PENDING</code> 状态。</p><p><strong>示例：</strong></p><p>下面的 Pod 请求 2 个 CPU 和 1 个 "example.com/foo"（扩展资源）。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>myimage<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>requests</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>cpu</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>example.com/foo</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>example.com/foo</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=pid-limiting>PID 限制</h2><p>进程 ID（PID）限制允许对 kubelet 进行配置，以限制给定 Pod 可以消耗的 PID 数量。
有关信息，请参见 <a href=/zh-cn/docs/concepts/policy/pid-limiting/>PID 限制</a>。</p><h2 id=troubleshooting>疑难解答</h2><h3 id=my-pods-are-pending-with-event-message-failedscheduling>我的 Pod 处于悬决状态且事件信息显示 <code>FailedScheduling</code></h3><p>如果调度器找不到该 Pod 可以匹配的任何节点，则该 Pod 将保持未被调度状态，
直到找到一个可以被调度到的位置。每当调度器找不到 Pod 可以调度的地方时，
会产生一个 <a href=/zh-cn/docs/reference/kubernetes-api/cluster-resources/event-v1/>Event</a>。
你可以使用 <code>kubectl</code> 来查看 Pod 的事件；例如：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe pod frontend | grep -A <span style=color:#666>9999999999</span> Events
</span></span></code></pre></div><pre tabindex=0><code>Events:
  Type     Reason            Age   From               Message
  ----     ------            ----  ----               -------
  Warning  FailedScheduling  23s   default-scheduler  0/42 nodes available: insufficient cpu
</code></pre><p>在上述示例中，由于节点上的 CPU 资源不足，名为 “frontend” 的 Pod 无法被调度。
由于内存不足（PodExceedsFreeMemory）而导致失败时，也有类似的错误消息。
一般来说，如果 Pod 处于悬决状态且有这种类型的消息时，你可以尝试如下几件事情：</p><ul><li>向集群添加更多节点。</li><li>终止不需要的 Pod，为悬决的 Pod 腾出空间。</li><li>检查 Pod 所需的资源是否超出所有节点的资源容量。例如，如果所有节点的容量都是<code>cpu：1</code>，
那么一个请求为 <code>cpu: 1.1</code> 的 Pod 永远不会被调度。</li><li>检查节点上的污点设置。如果集群中节点上存在污点，而新的 Pod 不能容忍污点，
调度器只会考虑将 Pod 调度到不带有该污点的节点上。</li></ul><p>你可以使用 <code>kubectl describe nodes</code> 命令检查节点容量和已分配的资源数量。 例如：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe nodes e2e-test-node-pool-4lw4
</span></span></code></pre></div><pre tabindex=0><code>Name:            e2e-test-node-pool-4lw4
[ ... 这里忽略了若干行以便阅读 ...]
Capacity:
 cpu:                               2
 memory:                            7679792Ki
 pods:                              110
Allocatable:
 cpu:                               1800m
 memory:                            7474992Ki
 pods:                              110
[ ... 这里忽略了若干行以便阅读 ...]
Non-terminated Pods:        (5 in total)
  Namespace    Name                                  CPU Requests  CPU Limits  Memory Requests  Memory Limits
  ---------    ----                                  ------------  ----------  ---------------  -------------
  kube-system  fluentd-gcp-v1.38-28bv1               100m (5%)     0 (0%)      200Mi (2%)       200Mi (2%)
  kube-system  kube-dns-3297075139-61lj3             260m (13%)    0 (0%)      100Mi (1%)       170Mi (2%)
  kube-system  kube-proxy-e2e-test-...               100m (5%)     0 (0%)      0 (0%)           0 (0%)
  kube-system  monitoring-influxdb-grafana-v4-z1m12  200m (10%)    200m (10%)  600Mi (8%)       600Mi (8%)
  kube-system  node-problem-detector-v0.1-fj7m3      20m (1%)      200m (10%)  20Mi (0%)        100Mi (1%)
Allocated resources:
  (Total limits may be over 100 percent, i.e., overcommitted.)
  CPU Requests    CPU Limits    Memory Requests    Memory Limits
  ------------    ----------    ---------------    -------------
  680m (34%)      400m (20%)    920Mi (11%)        1070Mi (13%)
</code></pre><p>在上面的输出中，你可以看到如果 Pod 请求超过 1.120 CPU 或者 6.23Gi 内存，节点将无法满足。</p><p>通过查看 "Pods" 部分，你将看到哪些 Pod 占用了节点上的资源。</p><p>Pods 可用的资源量低于节点的资源总量，因为系统守护进程也会使用一部分可用资源。
在 Kubernetes API 中，每个 Node 都有一个 <code>.status.allocatable</code> 字段
（详情参见 <a href=/zh-cn/docs/reference/kubernetes-api/cluster-resources/node-v1/#NodeStatus>NodeStatus</a>）。</p><p>字段 <code>.status.allocatable</code> 描述节点上可以用于 Pod 的资源总量（例如：15 个虚拟
CPU、7538 MiB 内存）。关于 Kubernetes 中节点可分配资源的信息，
可参阅<a href=/zh-cn/docs/tasks/administer-cluster/reserve-compute-resources/>为系统守护进程预留计算资源</a>。</p><p>你可以配置<a href=/zh-cn/docs/concepts/policy/resource-quotas/>资源配额</a>功能特性以限制每个名字空间可以使用的资源总量。
当某名字空间中存在 ResourceQuota 时，Kubernetes 会在该名字空间中的对象强制实施配额。
例如，如果你为不同的团队分配名字空间，你可以为这些名字空间添加 ResourceQuota。
设置资源配额有助于防止一个团队占用太多资源，以至于这种占用会影响其他团队。</p><p>你还需要考虑为这些名字空间设置授权访问：
为名字空间提供 <strong>全部</strong> 的写权限时，具有合适权限的人可能删除所有资源，
包括所配置的 ResourceQuota。</p><h3 id=my-container-is-terminated>我的容器被终止了</h3><p>你的容器可能因为资源紧张而被终止。要查看容器是否因为遇到资源限制而被杀死，
请针对相关的 Pod 执行 <code>kubectl describe pod</code>：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe pod simmemleak-hra99
</span></span></code></pre></div><p>输出类似于：</p><pre tabindex=0><code>Name:                           simmemleak-hra99
Namespace:                      default
Image(s):                       saadali/simmemleak
Node:                           kubernetes-node-tf0f/10.240.216.66
Labels:                         name=simmemleak
Status:                         Running
Reason:
Message:
IP:                             10.244.2.75
Containers:
  simmemleak:
    Image:  saadali/simmemleak:latest
    Limits:
      cpu:          100m
      memory:       50Mi
    State:          Running
      Started:      Tue, 07 Jul 2019 12:54:41 -0700
    Last State:     Terminated
      Reason:       OOMKilled
      Exit Code:    137
      Started:      Fri, 07 Jul 2019 12:54:30 -0700
      Finished:     Fri, 07 Jul 2019 12:54:33 -0700
    Ready:          False
    Restart Count:  5
Conditions:
  Type      Status
  Ready     False
Events:
  Type    Reason     Age   From               Message
  ----    ------     ----  ----               -------
  Normal  Scheduled  42s   default-scheduler  Successfully assigned simmemleak-hra99 to kubernetes-node-tf0f
  Normal  Pulled     41s   kubelet            Container image &#34;saadali/simmemleak:latest&#34; already present on machine
  Normal  Created    41s   kubelet            Created container simmemleak
  Normal  Started    40s   kubelet            Started container simmemleak
  Normal  Killing    32s   kubelet            Killing container with id ead3fb35-5cf5-44ed-9ae1-488115be66c6: Need to kill Pod
</code></pre><p>在上面的例子中，<code>Restart Count: 5</code> 意味着 Pod 中的 <code>simmemleak</code>
容器被终止并且（到目前为止）重启了五次。
原因 <code>OOMKilled</code> 显示容器尝试使用超出其限制的内存量。</p><p>你接下来要做的或许是检查应用代码，看看是否存在内存泄露。
如果你发现应用的行为与你所预期的相同，则可以考虑为该容器设置一个更高的内存限制
（也可能需要设置请求值）。</p><h2 id=接下来>接下来</h2><ul><li>获取<a href=/zh-cn/docs/tasks/configure-pod-container/assign-memory-resource/>分配内存资源给容器和 Pod</a> 的实践经验</li><li>获取<a href=/zh-cn/docs/tasks/configure-pod-container/assign-cpu-resource/>分配 CPU 资源给容器和 Pod</a> 的实践经验</li><li>阅读 API 参考如何定义<a href=/zh-cn/docs/reference/kubernetes-api/workload-resources/pod-v1/#Container>容器</a>
及其<a href=/zh-cn/docs/reference/kubernetes-api/workload-resources/pod-v1/#resources>资源请求</a>。</li><li>阅读 XFS 中<a href=https://xfs.org/index.php/XFS_FAQ#Q:_Quota:_Do_quotas_work_on_XFS.3F>配额</a>的文档</li><li>进一步阅读 <a href=/zh-cn/docs/reference/config-api/kube-scheduler-config.v1beta3/>kube-scheduler 配置参考 (v1beta3)</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-ab6d20f33ad930a67ee7ef57bff6c75e>5 - 使用 kubeconfig 文件组织集群访问</h1><p>使用 kubeconfig 文件来组织有关集群、用户、命名空间和身份认证机制的信息。
<code>kubectl</code> 命令行工具使用 kubeconfig 文件来查找选择集群所需的信息，并与集群的 API 服务器进行通信。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong> 用于配置集群访问的文件称为“kubeconfig 文件”。
这是引用配置文件的通用方法，并不意味着有一个名为 <code>kubeconfig</code> 的文件</div><div class="alert alert-danger warning callout" role=alert><strong>警告：</strong> 只使用来源可靠的 kubeconfig 文件。使用特制的 kubeconfig 文件可能会导致恶意代码执行或文件暴露。
如果必须使用不受信任的 kubeconfig 文件，请首先像检查 shell 脚本一样仔细检查它。</div><p>默认情况下，<code>kubectl</code> 在 <code>$HOME/.kube</code> 目录下查找名为 <code>config</code> 的文件。
你可以通过设置 <code>KUBECONFIG</code> 环境变量或者设置
<a href=/docs/reference/generated/kubectl/kubectl/><code>--kubeconfig</code></a>参数来指定其他 kubeconfig 文件。</p><p>有关创建和指定 kubeconfig 文件的分步说明，请参阅
<a href=/zh-cn/docs/tasks/access-application-cluster/configure-access-multiple-clusters>配置对多集群的访问</a>。</p><h2 id=支持多集群-用户和身份认证机制>支持多集群、用户和身份认证机制</h2><p>假设你有多个集群，并且你的用户和组件以多种方式进行身份认证。比如：</p><ul><li>正在运行的 kubelet 可能使用证书在进行认证。</li><li>用户可能通过令牌进行认证。</li><li>管理员可能拥有多个证书集合提供给各用户。</li></ul><p>使用 kubeconfig 文件，你可以组织集群、用户和命名空间。你还可以定义上下文，以便在集群和命名空间之间快速轻松地切换。</p><h2 id=上下文-context>上下文（Context）</h2><p>通过 kubeconfig 文件中的 <em>context</em> 元素，使用简便的名称来对访问参数进行分组。
每个 context 都有三个参数：cluster、namespace 和 user。
默认情况下，<code>kubectl</code> 命令行工具使用 <strong>当前上下文</strong> 中的参数与集群进行通信。</p><p>选择当前上下文</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config use-context
</span></span></code></pre></div><h2 id=kubeconfig-环境变量>KUBECONFIG 环境变量</h2><p><code>KUBECONFIG</code> 环境变量包含一个 kubeconfig 文件列表。
对于 Linux 和 Mac，列表以冒号分隔。对于 Windows，列表以分号分隔。
<code>KUBECONFIG</code> 环境变量不是必要的。
如果 <code>KUBECONFIG</code> 环境变量不存在，<code>kubectl</code> 使用默认的 kubeconfig 文件，<code>$HOME/.kube/config</code>。</p><p>如果 <code>KUBECONFIG</code> 环境变量存在，<code>kubectl</code> 使用 <code>KUBECONFIG</code> 环境变量中列举的文件合并后的有效配置。</p><h2 id=合并-kubeconfig-文件>合并 kubeconfig 文件</h2><p>要查看配置，输入以下命令：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config view
</span></span></code></pre></div><p>如前所述，输出可能来自 kubeconfig 文件，也可能是合并多个 kubeconfig 文件的结果。</p><p>以下是 <code>kubectl</code> 在合并 kubeconfig 文件时使用的规则。</p><ol><li><p>如果设置了 <code>--kubeconfig</code> 参数，则仅使用指定的文件。不进行合并。此参数只能使用一次。</p><p>否则，如果设置了 <code>KUBECONFIG</code> 环境变量，将它用作应合并的文件列表。根据以下规则合并 <code>KUBECONFIG</code> 环境变量中列出的文件：</p><ul><li>忽略空文件名。</li><li>对于内容无法反序列化的文件，产生错误信息。</li><li>第一个设置特定值或者映射键的文件将生效。</li><li>永远不会更改值或者映射键。示例：保留第一个文件的上下文以设置 <code>current-context</code>。示例：如果两个文件都指定了 <code>red-user</code>，则仅使用第一个文件的 <code>red-user</code> 中的值。即使第二个文件在 <code>red-user</code> 下有非冲突条目，也要丢弃它们。</li></ul></li></ol><p>有关设置 <code>KUBECONFIG</code> 环境变量的示例，请参阅
<a href=/zh-cn/docs/tasks/access-application-cluster/configure-access-multiple-clusters/#set-the-kubeconfig-environment-variable>设置 KUBECONFIG 环境变量</a>。</p><p>否则，使用默认的 kubeconfig 文件， <code>$HOME/.kube/config</code>，不进行合并。</p><ol start=2><li><p>根据此链中的第一个匹配确定要使用的上下文。</p><ol><li>如果存在，使用 <code>--context</code> 命令行参数。</li><li>使用合并的 kubeconfig 文件中的 <code>current-context</code>。</li></ol></li></ol><p>这种场景下允许空上下文。</p><ol start=3><li><p>确定集群和用户。此时，可能有也可能没有上下文。根据此链中的第一个匹配确定集群和用户，这将运行两次：一次用于用户，一次用于集群。</p><ol><li>如果存在，使用命令行参数：<code>--user</code> 或者 <code>--cluster</code>。</li><li>如果上下文非空，从上下文中获取用户或集群。</li></ol></li></ol><p>这种场景下用户和集群可以为空。</p><ol start=4><li><p>确定要使用的实际集群信息。此时，可能有也可能没有集群信息。基于此链构建每个集群信息；第一个匹配项会被采用：</p><ol><li>如果存在：<code>--server</code>、<code>--certificate-authority</code> 和 <code>--insecure-skip-tls-verify</code>，使用命令行参数。</li><li>如果合并的 kubeconfig 文件中存在集群信息属性，则使用它们。</li><li>如果没有 server 配置，则配置无效。</li></ol></li></ol><ol start=5><li><p>确定要使用的实际用户信息。使用与集群信息相同的规则构建用户信息，但每个用户只允许一种身份认证技术：</p><ol><li>如果存在：<code>--client-certificate</code>、<code>--client-key</code>、<code>--username</code>、<code>--password</code> 和 <code>--token</code>，使用命令行参数。</li><li>使用合并的 kubeconfig 文件中的 <code>user</code> 字段。</li><li>如果存在两种冲突技术，则配置无效。</li></ol></li></ol><ol start=6><li>对于仍然缺失的任何信息，使用其对应的默认值，并可能提示输入身份认证信息。</li></ol><h2 id=文件引用>文件引用</h2><p>kubeconfig 文件中的文件和路径引用是相对于 kubeconfig 文件的位置。
命令行上的文件引用是相对于当前工作目录的。
在 <code>$HOME/.kube/config</code> 中，相对路径按相对路径存储，绝对路径按绝对路径存储。</p><h2 id=代理>代理</h2><p>你可以在 <code>kubeconfig</code> 文件中，为每个集群配置 <code>proxy-url</code> 来让 <code>kubectl</code> 使用代理，例如：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>clusters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>proxy-url</span>:<span style=color:#bbb> </span>http://proxy.example.org:3128<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>server</span>:<span style=color:#bbb> </span>https://k8s.example.org/k8s/clusters/c-xxyyzz<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>development<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>users</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>developer<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>contexts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>context</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>development<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=接下来>接下来</h2><ul><li><a href=/zh-cn/docs/tasks/access-application-cluster/configure-access-multiple-clusters/>配置对多集群的访问</a></li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#config><code>kubectl config</code></a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-0f628478dbd58516389164933f9d7da2>6 - Windows 节点的资源管理</h1><p>本页概述了 Linux 和 Windows 在资源管理方式上的区别。</p><p>在 Linux 节点上，<a class=glossary-tooltip title='一组具有可选资源隔离、审计和限制的 Linux 进程。' data-toggle=tooltip data-placement=top href='/zh-cn/docs/reference/glossary/?all=true#term-cgroup' target=_blank aria-label=cgroup>cgroup</a> 用作资源控制的 Pod 边界。
在这个边界内创建容器以便于隔离网络、进程和文件系统。
Linux cgroup API 可用于收集 CPU、I/O 和内存使用统计数据。</p><p>与此相反，Windows 中每个容器对应一个<a href=https://docs.microsoft.com/zh-cn/windows/win32/procthread/job-objects><strong>作业对象</strong></a>，
与系统命名空间过滤器一起使用，将所有进程包含在一个容器中，提供与主机的逻辑隔离。
（作业对象是一种 Windows 进程隔离机制，不同于 Kubernetes 提及的 <a class=glossary-tooltip title='Job 是需要运行完成的确定性的或批量的任务。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/workloads/controllers/job/ target=_blank aria-label=Job>Job</a>)。</p><p>如果没有命名空间过滤，就无法运行 Windows 容器。
这意味着在主机环境中无法让系统特权生效，因此特权容器在 Windows 上不可用。
容器不能使用来自主机的标识，因为安全帐户管理器（Security Account Manager，SAM）是独立的。</p><h2 id=resource-management-memory>内存管理</h2><p>Windows 不像 Linux 一样提供杀手（killer）机制，杀死内存不足的进程。
Windows 始终将所有用户态内存分配视为虚拟内存，并强制使用页面文件（pagefile）。</p><p>Windows 节点不会为进程过量使用内存。
最终结果是 Windows 不会像 Linux 那样达到内存不足的情况，Windows 将进程页面放到磁盘，
不会因为内存不足（OOM）而终止进程。
如果内存配置过量且所有物理内存都已耗尽，则换页性能就会降低。</p><h2 id=resource-management-cpu>CPU 管理</h2><p>Windows 可以限制为不同进程分配的 CPU 时间长度，但无法保证最小的 CPU 时间长度。</p><p>在 Windows 上，kubelet 支持使用命令行标志来设置 kubelet 进程的<a href=https://docs.microsoft.com/zh-cn/windows/win32/procthread/scheduling-priorities>调度优先级</a>：
<code>--windows-priorityclass</code>。
与 Windows 主机上运行的其他进程相比，此标志允许 kubelet 进程获取更多的 CPU 时间片。
有关允许值及其含义的更多信息，请访问 <a href=https://docs.microsoft.com/zh-cn/windows/win32/procthread/scheduling-priorities#priority-class>Windows 优先级类</a>。
为了确保运行的 Pod 不会耗尽 kubelet 的 CPU 时钟周期，
要将此标志设置为 <code>ABOVE_NORMAL_PRIORITY_CLASS</code> 或更高。</p><h2 id=resource-reservation>资源预留</h2><p>为了满足操作系统、容器运行时和 kubelet 等 Kubernetes 主机进程使用的内存和 CPU，
你可以（且应该）用 <code>--kube-reserved</code> 和/或 <code>--system-reserved</code> kubelet 标志来预留内存和 CPU 资源。
在 Windows 上，这些值仅用于计算节点的<a href=/zh-cn/docs/tasks/administer-cluster/reserve-compute-resources/#node-allocatable>可分配</a>资源。</p><div class="alert alert-warning caution callout" role=alert><strong>注意：</strong><p>在你部署工作负载时，需对容器设置内存和 CPU 资源的限制。
这也会从 <code>NodeAllocatable</code> 中减去，帮助集群范围的调度器决定哪些 Pod 放到哪些节点上。</p><p>若调度 Pod 时未设置限制值，可能对 Windows 节点过量配置资源。
在极端情况下，这会让节点变得不健康。</p></div><p>在 Windows 上，一种好的做法是预留至少 2GiB 的内存。</p><p>要决定预留多少 CPU，需明确每个节点的最大 Pod 密度，
并监控节点上运行的系统服务的 CPU 使用率，然后选择一个满足工作负载需求的值。</p></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/zh-cn/docs/home/>主页</a>
<a class=text-white href=/zh-cn/blog/>博客</a>
<a class=text-white href=/zh-cn/training/>培训</a>
<a class=text-white href=/zh-cn/partners/>合作伙伴</a>
<a class=text-white href=/zh-cn/community/>社区</a>
<a class=text-white href=/zh-cn/case-studies/>案例分析</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 The Kubernetes 作者 | 文档发布基于 <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a> 授权许可</small><br><small class=text-white>Copyright &copy; 2023 Linux 基金会&reg;。保留所有权利。Linux 基金会已注册并使用商标。如需了解 Linux 基金会的商标列表，请访问<a href=https://www.linuxfoundation.org/trademark-usage class=light-text>商标使用页面</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>