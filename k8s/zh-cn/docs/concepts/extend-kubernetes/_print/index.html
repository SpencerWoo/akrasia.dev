<!doctype html><html lang=zh-cn class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=en href=https://kubernetes.io/docs/concepts/extend-kubernetes/><link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/concepts/extend-kubernetes/><link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/concepts/extend-kubernetes/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/concepts/extend-kubernetes/><link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/concepts/extend-kubernetes/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/concepts/extend-kubernetes/><link rel=alternate hreflang=pt-br href=https://kubernetes.io/pt-br/docs/concepts/extend-kubernetes/><link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/concepts/extend-kubernetes/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/zh-cn/docs/concepts/extend-kubernetes/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>扩展 Kubernetes | Kubernetes</title><meta property="og:title" content="扩展 Kubernetes"><meta property="og:description" content="改变你的 Kubernetes 集群的行为的若干方法。"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/zh-cn/docs/concepts/extend-kubernetes/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="扩展 Kubernetes"><meta itemprop=description content="改变你的 Kubernetes 集群的行为的若干方法。"><meta name=twitter:card content="summary"><meta name=twitter:title content="扩展 Kubernetes"><meta name=twitter:description content="改变你的 Kubernetes 集群的行为的若干方法。"><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content="改变你的 Kubernetes 集群的行为的若干方法。"><meta property="og:description" content="改变你的 Kubernetes 集群的行为的若干方法。"><meta name=twitter:description content="改变你的 Kubernetes 集群的行为的若干方法。"><meta property="og:url" content="https://kubernetes.io/zh-cn/docs/concepts/extend-kubernetes/"><meta property="og:title" content="扩展 Kubernetes"><meta name=twitter:title content="扩展 Kubernetes"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/zh-cn/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/zh-cn/docs/>文档</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/zh-cn/blog/>Kubernetes 博客</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/zh-cn/training/>培训</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/zh-cn/partners/>合作伙伴</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/zh-cn/community/>社区</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/zh-cn/case-studies/>案例分析</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>版本列表</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/zh-cn/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/zh-cn/docs/concepts/extend-kubernetes/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/zh-cn/docs/concepts/extend-kubernetes/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/zh-cn/docs/concepts/extend-kubernetes/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/zh-cn/docs/concepts/extend-kubernetes/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/zh-cn/docs/concepts/extend-kubernetes/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>中文 (Chinese)</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/docs/concepts/extend-kubernetes/>English</a>
<a class=dropdown-item href=/ko/docs/concepts/extend-kubernetes/>한국어 (Korean)</a>
<a class=dropdown-item href=/ja/docs/concepts/extend-kubernetes/>日本語 (Japanese)</a>
<a class=dropdown-item href=/fr/docs/concepts/extend-kubernetes/>Français (French)</a>
<a class=dropdown-item href=/de/docs/concepts/extend-kubernetes/>Deutsch (German)</a>
<a class=dropdown-item href=/es/docs/concepts/extend-kubernetes/>Español (Spanish)</a>
<a class=dropdown-item href=/pt-br/docs/concepts/extend-kubernetes/>Português (Portuguese)</a>
<a class=dropdown-item href=/id/docs/concepts/extend-kubernetes/>Bahasa Indonesia</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>这是本节的多页打印视图。
<a href=# onclick="return print(),!1">点击此处打印</a>.</p><p><a href=/zh-cn/docs/concepts/extend-kubernetes/>返回本页常规视图</a>.</p></div><h1 class=title>扩展 Kubernetes</h1><div class=lead>改变你的 Kubernetes 集群的行为的若干方法。</div><ul><li>1: <a href=#pg-3131452556176159fb269593c1a52012>Operator 模式</a></li><li>2: <a href=#pg-c8937cdc9df96f3328becf04f8211292>计算、存储和网络扩展</a></li><ul><li>2.1: <a href=#pg-1ac2260db9ecccbf0303a899bc27ce6d>网络插件</a></li><li>2.2: <a href=#pg-53e1ea8892ceca307ba19e8d6a7b8d32>设备插件</a></li></ul><li>3: <a href=#pg-0af41d3bd7c785621b58b7564793396a>扩展 Kubernetes API</a></li><ul><li>3.1: <a href=#pg-342388440304e19ce30c0f8ada1c77ce>定制资源</a></li><li>3.2: <a href=#pg-1ea4977c0ebf97569bf54a477faa7fa5>Kubernetes API 聚合层</a></li></ul></ul><div class=content><p>Kubernetes 是高度可配置且可扩展的。因此，大多数情况下，
你不需要派生自己的 Kubernetes 副本或者向项目代码提交补丁。</p><p>本指南描述定制 Kubernetes 的可选方式。主要针对的读者是希望了解如何针对自身工作环境需要来调整
Kubernetes 的<a class=glossary-tooltip title=配置、控制、监控集群的人。 data-toggle=tooltip data-placement=top href='/zh-cn/docs/reference/glossary/?all=true#term-cluster-operator' target=_blank aria-label=集群管理者>集群管理者</a>。
对于那些充当<a class=glossary-tooltip title='定制 Kubernetes 平台以满足自己的项目需求的人。' data-toggle=tooltip data-placement=top href='/zh-cn/docs/reference/glossary/?all=true#term-platform-developer' target=_blank aria-label=平台开发人员>平台开发人员</a>的开发人员或
Kubernetes 项目的<a class=glossary-tooltip title='通过贡献代码、文档或者投入时间等方式来帮助 Kubernetes 项目或社区的人。' data-toggle=tooltip data-placement=top href='/zh-cn/docs/reference/glossary/?all=true#term-contributor' target=_blank aria-label=贡献者>贡献者</a>而言，
他们也会在本指南中找到有用的介绍信息，了解系统中存在哪些扩展点和扩展模式，
以及它们所附带的各种权衡和约束等等。</p><p>定制化的方法主要可分为<a href=#configuration>配置</a>和<a href=#extensions>扩展</a>两种。
前者主要涉及更改命令行参数、本地配置文件或者 API 资源；
后者则需要额外运行一些程序、网络服务或两者。
本文主要关注<strong>扩展</strong>。</p><h2 id=configuration>配置</h2><p><strong>配置文件</strong>和<strong>命令参数</strong>的说明位于在线文档的<a href=/zh-cn/docs/reference/>参考</a>一节，
每个可执行文件一个页面：</p><ul><li><a href=/zh-cn/docs/reference/command-line-tools-reference/kube-apiserver/><code>kube-apiserver</code></a></li><li><a href=/zh-cn/docs/reference/command-line-tools-reference/kube-controller-manager/><code>kube-controller-manager</code></a></li><li><a href=/zh-cn/docs/reference/command-line-tools-reference/kube-scheduler/><code>kube-scheduler</code></a></li><li><a href=/zh-cn/docs/reference/command-line-tools-reference/kubelet/><code>kubelet</code></a></li><li><a href=/zh-cn/docs/reference/command-line-tools-reference/kube-proxy/><code>kube-proxy</code></a></li></ul><p>在托管的 Kubernetes 服务中或者受控安装的发行版本中，命令参数和配置文件不总是可以修改的。
即使它们是可修改的，通常其修改权限也仅限于集群操作员。
此外，这些内容在将来的 Kubernetes 版本中很可能发生变化，设置新参数或配置文件可能需要重启进程。
有鉴于此，应该在没有其他替代方案时才会使用这些命令参数和配置文件。</p><p>诸如 <a href=/zh-cn/docs/concepts/policy/resource-quotas/>ResourceQuota</a>、
<a href=/zh-cn/docs/concepts/services-networking/network-policies/>NetworkPolicy</a>
和基于角色的访问控制（<a href=/zh-cn/docs/reference/access-authn-authz/rbac/>RBAC</a>）
等<strong>内置策略 API</strong> 都是以声明方式配置策略选项的内置 Kubernetes API。
即使在托管的 Kubernetes 服务和受控的 Kubernetes 安装环境中，API 通常也是可用的。
内置策略 API 遵循与 Pod 这类其他 Kubernetes 资源相同的约定。
当你使用<a href=/zh-cn/docs/reference/using-api/#api-versioning>稳定版本</a>的策略 API，
它们与其他 Kubernetes API 一样，采纳的是一种<a href=/zh-cn/docs/reference/using-api/deprecation-policy/>预定义的支持策略</a>。
出于以上原因，在条件允许的情况下，基于策略 API 的方案应该优先于<strong>配置文件</strong>和<strong>命令参数</strong>。</p><h2 id=extensions>扩展</h2><p>扩展（Extensions）是一些扩充 Kubernetes 能力并与之深度集成的软件组件。
它们调整 Kubernetes 的工作方式使之支持新的类型和新的硬件种类。</p><p>大多数集群管理员会使用一种托管的 Kubernetes 服务或者其某种发行版本。
这类集群通常都预先安装了扩展。因此，大多数 Kubernetes 用户不需要安装扩展，
至于需要自己编写新的扩展的情况就更少了。</p><h3 id=extension-patterns>扩展模式</h3><p>Kubernetes 从设计上即支持通过编写客户端程序来将其操作自动化。
任何能够对 Kubernetes API 发出读写指令的程序都可以提供有用的自动化能力。
<strong>自动化组件</strong>可以运行在集群上，也可以运行在集群之外。
通过遵从本文中的指南，你可以编写高度可用的、运行稳定的自动化组件。
自动化组件通常可以用于所有 Kubernetes 集群，包括托管的集群和受控的安装环境。</p><p>编写客户端程序有一种特殊的<a class=glossary-tooltip title='控制器通过 API 服务器监控集群的公共状态，并致力于将当前状态转变为期望的状态。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/architecture/controller/ target=_blank aria-label=控制器（Controller）>控制器（Controller）</a>模式，
能够与 Kubernetes 很好地协同工作。控制器通常会读取某个对象的 <code>.spec</code>，或许还会执行一些操作，
之后更新对象的 <code>.status</code>。</p><p>控制器是 Kubernetes API 的客户端。当 Kubernetes 充当客户端且调用某远程服务时，
Kubernetes 将此称作 <strong>Webhook</strong>。该远程服务称作 <strong>Webhook 后端</strong>。
与定制的控制器相似，Webhook 也会引入失效点（Point of Failure）。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>在 Kubernetes 之外，“Webhook” 这个词通常是指一种异步通知机制，
其中 Webhook 调用将用作对另一个系统或组件的单向通知。
在 Kubernetes 生态系统中，甚至同步的 HTTP 调用也经常被描述为 “Webhook”。</div><p>在 Webhook 模型中，Kubernetes 向远程服务发起网络请求。
在另一种称作<strong>可执行文件插件（Binary Plugin）</strong> 模型中，Kubernetes 执行某个可执行文件（程序）。
这些可执行文件插件由 kubelet（例如，<a href=https://kubernetes-csi.github.io/docs/>CSI 存储插件</a>和
<a href=/zh-cn/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/>CNI 网络插件</a>）
和 kubectl 使用。</p><h3 id=extension-points>扩展点</h3><p>下图展示了 Kubernetes 集群中的这些扩展点及其访问集群的客户端。</p><figure class=diagram-large><img src=/docs/concepts/extend-kubernetes/extension-points.png alt="用符号表示的七个编号的 Kubernetes 扩展点"><figcaption><p>Kubernetes 扩展点</p></figcaption></figure><h4 id=key-to-the-figure>图示要点</h4><ol><li><p>用户通常使用 <code>kubectl</code> 与 Kubernetes API 交互。
<a href=#client-extensions>插件</a>定制客户端的行为。
有一些通用的扩展可以应用到不同的客户端，还有一些特定的方式可以扩展 <code>kubectl</code>。</p></li><li><p>API 服务器处理所有请求。API 服务器中的几种扩展点能够使用户对请求执行身份认证、
基于其内容阻止请求、编辑请求内容、处理删除操作等等。
这些扩展点在 <a href=#api-access-extensions>API 访问扩展</a>节详述。</p></li><li><p>API 服务器能提供各种类型的<strong>资源（Resources）</strong> 服务。
诸如 <code>pods</code> 的<strong>内置资源类型</strong>是由 Kubernetes 项目所定义的，无法改变。
请查阅 <a href=#api-extensions>API 扩展</a>了解如何扩展 Kubernetes API。</p></li></ol><ol start=4><li><p>Kubernetes 调度器负责<a href=/zh-cn/docs/concepts/scheduling-eviction/assign-pod-node/>决定</a>
Pod 要放置到哪些节点上执行。有几种方式来扩展调度行为，这些方法将在<a href=#scheduling-extensions>调度器扩展</a>节中展开说明。</p></li><li><p>Kubernetes 中的很多行为都是通过称为<a class=glossary-tooltip title='控制器通过 API 服务器监控集群的公共状态，并致力于将当前状态转变为期望的状态。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/architecture/controller/ target=_blank aria-label=控制器（Controller）>控制器（Controller）</a>的程序来实现的，
这些程序也都是 API 服务器的客户端。控制器常常与定制资源结合使用。
进一步了解请查阅<a href=#combining-new-apis-with-automation>结合使用新的 API 与自动化组件</a>和<a href=#changing-built-in-resources>更改内置资源</a>。</p></li></ol><ol start=6><li><p>Kubelet 运行在各个服务器（节点）上，帮助 Pod 展现为虚拟的服务器并在集群网络中拥有自己的 IP。
<a href=#network-plugins>网络插件</a>使得 Kubernetes 能够采用不同实现技术来连接 Pod 网络。</p></li><li><p>你可以使用<a href=#device-plugins>设备插件</a>集成定制硬件或其他专用的节点本地设施，
使得这些设施可用于集群中运行的 Pod。Kubelet 包括了对使用设备插件的支持。</p><p>kubelet 也会为 Pod 及其容器增加或解除<a class=glossary-tooltip title='包含可被 Pod 中容器访问的数据的目录。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/storage/volumes/ target=_blank aria-label=卷>卷</a>的挂载。
你可以使用<a href=#storage-plugins>存储插件</a>增加对新存储类别和其他卷类型的支持。</p></li></ol><h4 id=extension-flowchart>扩展点选择流程图</h4><p>如果你无法确定从何处入手，下面的流程图可能对你有些帮助。
注意，某些方案可能需要同时采用几种类型的扩展。</p><figure class=diagram-large><img src=/zh-cn/docs/concepts/extend-kubernetes/flowchart.png alt=附带使用场景问题和实现指南的流程图。绿圈表示是；红圈表示否。><figcaption><p>选择一个扩展方式的流程图指导</p></figcaption></figure><hr><h2 id=client-extensions>客户端扩展</h2><p>kubectl 所用的插件是单独的二进制文件，用于添加或替换特定子命令的行为。
<code>kubectl</code> 工具还可以与<a href=/zh-cn/docs/reference/access-authn-authz/authentication/#client-go-credential-plugins>凭据插件</a>集成。
这些扩展只影响单个用户的本地环境，因此不能强制执行站点范围的策略。</p><p>如果你要扩展 <code>kubectl</code> 工具，请阅读<a href=/zh-cn/docs/tasks/extend-kubectl/kubectl-plugins/>用插件扩展 kubectl</a>。</p><h2 id=api-extensions>API 扩展</h2><h3 id=custom-resource-definitions>定制资源对象</h3><p>如果你想要定义新的控制器、应用配置对象或者其他声明式 API，并且使用 Kubernetes
工具（如 <code>kubectl</code>）来管理它们，可以考虑向 Kubernetes 添加<strong>定制资源</strong>。</p><p>关于定制资源的更多信息，可参见<a href=/zh-cn/docs/concepts/extend-kubernetes/api-extension/custom-resources/>定制资源概念指南</a>。</p><h3 id=api-aggregation-layer>API 聚合层</h3><p>你可以使用 Kubernetes 的
<a href=/zh-cn/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>API 聚合层</a>将
Kubernetes API 与其他服务集成，例如<a href=/zh-cn/docs/tasks/debug/debug-cluster/resource-metrics-pipeline/>指标</a>。</p><h3 id=combinding-new-apis-with-automation>结合使用新 API 与自动化组件</h3><p>定制资源 API 与控制回路的组合称作<a class=glossary-tooltip title='控制器通过 API 服务器监控集群的公共状态，并致力于将当前状态转变为期望的状态。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/architecture/controller/ target=_blank aria-label=控制器>控制器</a>模式。
如果你的控制器代替人工操作员根据所需状态部署基础设施，那么控制器也可以遵循
<a class=glossary-tooltip title=一种用于管理自定义资源的专用控制器 data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/extend-kubernetes/operator/ target=_blank aria-label='Operator 模式'>Operator 模式</a>。
Operator 模式用于管理特定的应用；通常，这些应用需要维护状态并需要仔细考虑状态的管理方式。</p><p>你还可以创建自己的定制 API 和控制回路来管理其他资源（例如存储）或定义策略（例如访问控制限制）。</p><h3 id=changing-built-in-resources>更改内置资源</h3><p>当你通过添加定制资源来扩展 Kubernetes 时，所添加的资源总是会被放在一个新的 API 组中。
你不可以替换或更改现有的 API 组。添加新的 API 不会直接让你影响现有
API（如 Pod）的行为，不过 <strong>API 访问扩展</strong>能够实现这点。</p><h2 id=api-access-extensions>API 访问扩展</h2><p>当请求到达 Kubernetes API 服务器时，首先要经过<strong>身份认证</strong>，之后是<strong>鉴权</strong>操作，
再之后要经过若干类型的<strong>准入控制</strong>（某些请求实际上未通过身份认证，需要特殊处理）。
参见<a href=/zh-cn/docs/concepts/security/controlling-access/>控制 Kubernetes API 访问</a>以了解此流程的细节。</p><p>Kubernetes 身份认证/授权流程中的每个步骤都提供了扩展点。</p><h3 id=authentication>身份认证</h3><p><a href=/zh-cn/docs/reference/access-authn-authz/authentication/>身份认证</a>负责将所有请求中的头部或证书映射到发出该请求的客户端的用户名。</p><p>Kubernetes 提供若干内置的身份认证方法。它也可以运行在某种身份认证代理的后面，
并且可以将来自 <code>Authorization:</code> 头部的令牌发送到某个远程服务
（<a href=/zh-cn/docs/reference/access-authn-authz/authentication/#webhook-token-authentication>认证 Webhook</a>
来执行验证操作，以备内置方法无法满足你的要求。</p><h3 id=authorization>鉴权</h3><p><a href=/zh-cn/docs/reference/access-authn-authz/authorization/>鉴权</a>操作负责确定特定的用户是否可以读、写 API
资源或对其执行其他操作。此操作仅在整个资源集合的层面进行。
换言之，它不会基于对象的特定字段作出不同的判决。</p><p>如果内置的鉴权选项无法满足你的需要，
你可以使用<a href=/zh-cn/docs/reference/access-authn-authz/webhook/>鉴权 Webhook</a> 来调用用户提供的代码，
执行定制的鉴权决定。</p><h3 id=dynamic-admission-control>动态准入控制</h3><p>请求的鉴权操作结束之后，如果请求的是写操作，
还会经过<a href=/zh-cn/docs/reference/access-authn-authz/admission-controllers/>准入控制</a>处理步骤。
除了内置的处理步骤，还存在一些扩展点：</p><ul><li><a href=/zh-cn/docs/reference/access-authn-authz/admission-controllers/#imagepolicywebhook>镜像策略 Webhook</a>
能够限制容器中可以运行哪些镜像。</li><li>为了执行任意的准入控制决定，
可以使用一种通用的<a href=/zh-cn/docs/reference/access-authn-authz/extensible-admission-controllers/#admission-webhooks>准入 Webhook</a>
机制。这类准入 Webhook 可以拒绝创建或更新请求。
一些准入 Webhook 会先修改传入的请求数据，才会由 Kubernetes 进一步处理这些传入请求数据。</li></ul><h2 id=infrastructure-extensions>基础设施扩展</h2><h3 id=device-plugins>设备插件</h3><p><strong>设备插件</strong>允许一个节点通过<a href=/zh-cn/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/>设备插件</a>发现新的
Node 资源（除了内置的类似 CPU 和内存这类资源之外）。</p><h3 id=storage-plugins>存储插件</h3><p><a class=glossary-tooltip title='容器存储接口 （CSI）定义了存储系统暴露给容器的标准接口。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/storage/volumes/#csi target=_blank aria-label=容器存储接口>容器存储接口</a> (CSI) 插件提供了一种扩展
Kubernetes 的方式使其支持新类别的卷。
这些卷可以由持久的外部存储提供支持，可以提供临时存储，还可以使用文件系统范型为信息提供只读接口。</p><p>Kubernetes 还包括对 <a href=/zh-cn/docs/concepts/storage/volumes/#flexvolume-deprecated>FlexVolume</a>
插件的支持，该插件自 Kubernetes v1.23 起被弃用（被 CSI 替代）。</p><p>FlexVolume 插件允许用户挂载 Kubernetes 本身不支持的卷类型。
当你运行依赖于 FlexVolume 存储的 Pod 时，kubelet 会调用一个二进制插件来挂载该卷。
归档的 <a href=https://git.k8s.io/design-proposals-archive/storage/flexvolume-deployment.md>FlexVolume</a>
设计提案对此方法有更多详细说明。</p><p><a href=https://github.com/kubernetes/community/blob/master/sig-storage/volume-plugin-faq.md#kubernetes-volume-plugin-faq-for-storage-vendors>Kubernetes 存储供应商的卷插件 FAQ</a>
包含了有关存储插件的通用信息。</p><h3 id=network-plugins>网络插件</h3><p>你的 Kubernetes 集群需要一个<strong>网络插件</strong>才能拥有一个正常工作的 Pod 网络，
才能支持 Kubernetes 网络模型的其他方面。</p><p>[网络插件](/zh-cn/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/可以让
Kubernetes 使用不同的网络拓扑和技术。</p><h2 id=scheduling-extensions>调度扩展</h2><p>调度器是一种特殊的控制器，负责监视 Pod 变化并将 Pod 分派给节点。
默认的调度器可以被整体替换掉，同时继续使用其他 Kubernetes 组件。
或者也可以在同一时刻使用<a href=/zh-cn/docs/tasks/extend-kubernetes/configure-multiple-schedulers/>多个调度器</a>。</p><p>这是一项非同小可的任务，几乎绝大多数 Kubernetes
用户都会发现其实他们不需要修改调度器。</p><p>你可以控制哪些<a href=/zh-cn/docs/reference/scheduling/config/#scheduling-plugins>调度插件</a>处于激活状态，
或将插件集关联到名字不同的<a href=/zh-cn/docs/reference/scheduling/config/#multiple-profiles>调度器配置文件</a>上。
你还可以编写自己的插件，与一个或多个 kube-scheduler
的<a href=/zh-cn/docs/concepts/scheduling-eviction/scheduling-framework/#extension-points>扩展点</a>集成。</p><p>最后，内置的 <code>kube-scheduler</code> 组件支持
<a href=https://git.k8s.io/design-proposals-archive/scheduling/scheduler_extender.md>Webhook</a>，
从而允许远程 HTTP 后端（调度器扩展）来为 kube-scheduler 选择的 Pod 所在节点执行过滤和优先排序操作。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>你只能使用调度器扩展程序 Webhook 来影响节点过滤和节点优先排序；
其他扩展点无法通过集成 Webhook 获得。</div><h2 id=接下来>接下来</h2><ul><li>进一步了解基础设施扩展<ul><li><a href=/zh-cn/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/>设备插件</a></li><li><a href=/zh-cn/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/>网络插件</a></li><li>CSI <a href=https://kubernetes-csi.github.io/docs/>存储插件</a></li></ul></li><li>进一步了解 <a href=/zh-cn/docs/tasks/extend-kubectl/kubectl-plugins/>kubectl 插件</a></li><li>进一步了解<a href=/zh-cn/docs/concepts/extend-kubernetes/api-extension/custom-resources/>定制资源</a></li><li>进一步了解<a href=/zh-cn/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>扩展 API 服务器</a></li><li>进一步了解<a href=/zh-cn/docs/reference/access-authn-authz/extensible-admission-controllers/>动态准入控制</a></li><li>进一步了解 <a href=/zh-cn/docs/concepts/extend-kubernetes/operator/>Operator 模式</a></li></ul></div></div><div class=td-content style=page-break-before:always><h1 id=pg-3131452556176159fb269593c1a52012>1 - Operator 模式</h1><p>Operator 是 Kubernetes 的扩展软件，
它利用<a href=/zh-cn/docs/concepts/extend-kubernetes/api-extension/custom-resources/>定制资源</a>管理应用及其组件。
Operator 遵循 Kubernetes 的理念，特别是在<a href=/zh-cn/docs/concepts/architecture/controller>控制器</a>方面。</p><h2 id=motivation>初衷</h2><p><strong>Operator 模式</strong> 旨在记述（正在管理一个或一组服务的）运维人员的关键目标。
这些运维人员负责一些特定的应用和 Service，他们需要清楚地知道系统应该如何运行、如何部署以及出现问题时如何处理。</p><p>在 Kubernetes 上运行工作负载的人们都喜欢通过自动化来处理重复的任务。
Operator 模式会封装你编写的（Kubernetes 本身提供功能以外的）任务自动化代码。</p><h2 id=operators-in-kubernetes>Kubernetes 上的 Operator</h2><p>Kubernetes 为自动化而生。无需任何修改，你即可以从 Kubernetes 核心中获得许多内置的自动化功能。
你可以使用 Kubernetes 自动化部署和运行工作负载， <strong>甚至</strong> 可以自动化 Kubernetes 自身。</p><p>Kubernetes 的 <a class=glossary-tooltip title=一种用于管理自定义资源的专用控制器 data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/extend-kubernetes/operator/ target=_blank aria-label='Operator 模式'>Operator 模式</a>概念允许你在不修改
Kubernetes 自身代码的情况下，
通过为一个或多个自定义资源关联<a class=glossary-tooltip title='控制器通过 API 服务器监控集群的公共状态，并致力于将当前状态转变为期望的状态。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/architecture/controller/ target=_blank aria-label=控制器>控制器</a>来扩展集群的能力。
Operator 是 Kubernetes API 的客户端，
充当<a href=/zh-cn/docs/concepts/extend-kubernetes/api-extension/custom-resources/>自定义资源</a>的控制器。</p><h2 id=example>Operator 示例</h2><p>使用 Operator 可以自动化的事情包括：</p><ul><li>按需部署应用</li><li>获取/还原应用状态的备份</li><li>处理应用代码的升级以及相关改动。例如，数据库 schema 或额外的配置设置</li><li>发布一个 service，要求不支持 Kubernetes API 的应用也能发现它</li><li>模拟整个或部分集群中的故障以测试其稳定性</li><li>在没有内部成员选举程序的情况下，为分布式应用选择首领角色</li></ul><p>想要更详细的了解 Operator？下面是一个示例：</p><ol><li>有一个名为 SampleDB 的自定义资源，你可以将其配置到集群中。</li><li>一个包含 Operator 控制器部分的 Deployment，用来确保 Pod 处于运行状态。</li><li>Operator 代码的容器镜像。</li><li>控制器代码，负责查询控制平面以找出已配置的 SampleDB 资源。</li><li>Operator 的核心是告诉 API 服务器，如何使现实与代码里配置的资源匹配。<ul><li>如果添加新的 SampleDB，Operator 将设置 PersistentVolumeClaims 以提供持久化的数据库存储，
设置 StatefulSet 以运行 SampleDB，并设置 Job 来处理初始配置。</li><li>如果你删除它，Operator 将建立快照，然后确保 StatefulSet 和 Volume 已被删除。</li></ul></li><li>Operator 也可以管理常规数据库的备份。对于每个 SampleDB 资源，Operator
会确定何时创建（可以连接到数据库并进行备份的）Pod。这些 Pod 将依赖于
ConfigMap 和/或具有数据库连接详细信息和凭据的 Secret。</li><li>由于 Operator 旨在为其管理的资源提供强大的自动化功能，因此它还需要一些额外的支持性代码。
在这个示例中，代码将检查数据库是否正运行在旧版本上，
如果是，则创建 Job 对象为你升级数据库。</li></ol><h2 id=deploying-operators>部署 Operator</h2><p>部署 Operator 最常见的方法是将自定义资源及其关联的控制器添加到你的集群中。
跟运行容器化应用一样，控制器通常会运行在<a class=glossary-tooltip title='控制平面是指容器编排层，它暴露 API 和接口来定义、部署容器和管理容器的生命周期。' data-toggle=tooltip data-placement=top href='/zh-cn/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label=控制平面>控制平面</a>之外。
例如，你可以在集群中将控制器作为 Deployment 运行。</p><h2 id=using-operators>使用 Operator</h2><p>部署 Operator 后，你可以对 Operator 所使用的资源执行添加、修改或删除操作。
按照上面的示例，你将为 Operator 本身建立一个 Deployment，然后：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get SampleDB                   <span style=color:#080;font-style:italic># 查找所配置的数据库</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl edit SampleDB/example-database <span style=color:#080;font-style:italic># 手动修改某些配置</span>
</span></span></code></pre></div><p>可以了！Operator 会负责应用所作的更改并保持现有服务处于良好的状态。</p><h2 id=writing-operator>编写你自己的 Operator</h2><p>如果生态系统中没可以实现你目标的 Operator，你可以自己编写代码。</p><p>你还可以使用任何支持
<a href=/zh-cn/docs/reference/using-api/client-libraries/>Kubernetes API 客户端</a>的语言或运行时来实现
Operator（即控制器）。</p><p>以下是一些库和工具，你可用于编写自己的云原生 Operator。</p><div class="alert alert-secondary callout third-party-content" role=alert><strong>说明：</strong>
本部分链接到提供 Kubernetes 所需功能的第三方项目。Kubernetes 项目作者不负责这些项目。此页面遵循<a href=https://github.com/cncf/foundation/blob/master/website-guidelines.md target=_blank>CNCF 网站指南</a>，按字母顺序列出项目。要将项目添加到此列表中，请在提交更改之前阅读<a href=/docs/contribute/style/content-guide/#third-party-content>内容指南</a>。</div><ul><li><a href=https://juju.is/>Charmed Operator Framework</a></li><li><a href=https://github.com/java-operator-sdk/java-operator-sdk>Java Operator SDK</a></li><li><a href=https://github.com/nolar/kopf>Kopf</a> (Kubernetes Operator Pythonic Framework)</li><li><a href=https://kube.rs/>kube-rs</a> (Rust)</li><li><a href=https://book.kubebuilder.io/>kubebuilder</a></li><li><a href=https://buehler.github.io/dotnet-operator-sdk/>KubeOps</a> (.NET operator SDK)</li><li><a href=https://kudo.dev/>KUDO</a>（Kubernetes 通用声明式 Operator）</li><li><a href=https://metacontroller.github.io/metacontroller/intro.html>Metacontroller</a>，可与 Webhooks 结合使用，以实现自己的功能。</li><li><a href=https://operatorframework.io>Operator Framework</a></li><li><a href=https://github.com/flant/shell-operator>shell-operator</a></li></ul><h2 id=接下来>接下来</h2><ul><li>阅读 <a class=glossary-tooltip title='云原生计算基金会（Cloud Native Computing Foundation）' data-toggle=tooltip data-placement=top href=https://cncf.io/ target=_blank aria-label=CNCF>CNCF</a> <a href=https://github.com/cncf/tag-app-delivery/blob/eece8f7307f2970f46f100f51932db106db46968/operator-wg/whitepaper/Operator-WhitePaper_v1-0.md>Operator 白皮书</a>。</li><li>详细了解<a href=/zh-cn/docs/concepts/extend-kubernetes/api-extension/custom-resources/>定制资源</a></li><li>在 <a href=https://operatorhub.io/>OperatorHub.io</a> 上找到现成的、适合你的 Operator</li><li><a href=https://operatorhub.io/>发布</a>你的 Operator，让别人也可以使用</li><li>阅读 <a href=https://web.archive.org/web/20170129131616/https://coreos.com/blog/introducing-operators.html>CoreOS 原始文章</a>，它介绍了 Operator 模式（这是一个存档版本的原始文章）。</li><li>阅读这篇来自谷歌云的关于构建 Operator
最佳实践的<a href=https://cloud.google.com/blog/products/containers-kubernetes/best-practices-for-building-kubernetes-operators-and-stateful-apps>文章</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-c8937cdc9df96f3328becf04f8211292>2 - 计算、存储和网络扩展</h1><p>本节介绍不属于 Kubernetes 本身组成部分的一些集群扩展。
你可以使用这些扩展来增强集群中的节点，或者提供将 Pod 关联在一起的网络结构。</p><ul><li><p><a href=/zh-cn/docs/concepts/storage/volumes/#csi>CSI</a> 和
<a href=/zh-cn/docs/concepts/storage/volumes/#flexvolume>FlexVolume</a> 存储插件</p><p><a class=glossary-tooltip title='容器存储接口 （CSI）定义了存储系统暴露给容器的标准接口。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/storage/volumes/#csi target=_blank aria-label=容器存储接口>容器存储接口</a> (CSI) 插件提供了一种扩展
Kubernetes 的方式使其支持新类别的卷。
这些卷可以由持久的外部存储提供支持，可以提供临时存储，还可以使用文件系统范型为信息提供只读接口。</p><p>Kubernetes 还包括对 <a href=/zh-cn/docs/concepts/storage/volumes/#flexvolume>FlexVolume</a>
插件的扩展支持，该插件自 Kubernetes v1.23 起被弃用（被 CSI 替代）。</p><p>FlexVolume 插件允许用户挂载 Kubernetes 本身不支持的卷类型。
当你运行依赖于 FlexVolume 存储的 Pod 时，kubelet 会调用一个二进制插件来挂载该卷。
归档的 <a href=https://git.k8s.io/design-proposals-archive/storage/flexvolume-deployment.md>FlexVolume</a>
设计提案对此方法有更多详细说明。</p><p><a href=https://github.com/kubernetes/community/blob/master/sig-storage/volume-plugin-faq.md#kubernetes-volume-plugin-faq-for-storage-vendors>Kubernetes 存储供应商的卷插件 FAQ</a>
包含了有关存储插件的通用信息。</p></li></ul><ul><li><p><a href=/zh-cn/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/>设备插件</a></p><p>设备插件允许一个节点发现新的 Node 设施（除了 <code>cpu</code> 和 <code>memory</code> 等内置的节点资源之外），
并向请求资源的 Pod 提供了这些自定义的节点本地设施。</p></li></ul><ul><li><p><a href=/zh-cn/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/>网络插件</a></p><p>网络插件可以让 Kubernetes 使用不同的网络拓扑和技术。
你的 Kubernetes 集群需要一个 <strong>网络插件</strong> 才能拥有一个正常工作的 Pod 网络，
才能支持 Kubernetes 网络模型的其他方面。</p><p>Kubernetes 1.25 兼容
<a class=glossary-tooltip title='容器网络接口 (Container network interface；CNI) 插件是遵循 appc/CNI 协议的一类网络插件。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/ target=_blank aria-label=CNI>CNI</a> 网络插件。</p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-1ac2260db9ecccbf0303a899bc27ce6d>2.1 - 网络插件</h1><p>Kubernetes 1.25 支持用于集群联网的<a href=https://github.com/containernetworking/cni>容器网络接口</a> (CNI) 插件。
你必须使用和你的集群相兼容并且满足你的需求的 CNI 插件。
在更广泛的 Kubernetes 生态系统中你可以使用不同的插件（开源和闭源）。</p><p>要实现 <a href=/zh-cn/docs/concepts/services-networking/#the-kubernetes-network-model>Kubernetes 网络模型</a>，你需要一个 CNI 插件。</p><p>你必须使用与 <a href=https://github.com/containernetworking/cni/blob/spec-v0.4.0/SPEC.md>v0.4.0</a>
或更高版本的 CNI 规范相符合的 CNI 插件。
Kubernetes 推荐使用一个兼容 <a href=https://github.com/containernetworking/cni/blob/spec-v1.0.0/SPEC.md>v1.0.0</a>
CNI 规范的插件（插件可以兼容多个规范版本）。</p><h2 id=installation>安装</h2><p>在网络语境中，容器运行时（Container Runtime）是在节点上的守护进程，
被配置用来为 kubelet 提供 CRI 服务。具体而言，容器运行时必须配置为加载所需的
CNI 插件，从而实现 Kubernetes 网络模型。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>在 Kubernetes 1.24 之前，CNI 插件也可以由 kubelet 使用命令行参数 <code>cni-bin-dir</code>
和 <code>network-plugin</code> 管理。Kubernetes 1.24 移除了这些命令行参数，
CNI 的管理不再是 kubelet 的工作。</p><p>如果你在移除 dockershim 之后遇到问题，
请参阅<a href=/zh-cn/docs/tasks/administer-cluster/migrating-from-dockershim/troubleshooting-cni-plugin-related-errors/>排查 CNI 插件相关的错误</a>。</p></div><p>要了解容器运行时如何管理 CNI 插件的具体信息，可参见对应容器运行时的文档，例如：</p><ul><li><a href=https://github.com/containerd/containerd/blob/main/script/setup/install-cni>containerd</a></li><li><a href=https://github.com/cri-o/cri-o/blob/main/contrib/cni/README.md>CRI-O</a></li></ul><p>要了解如何安装和管理 CNI 插件的具体信息，可参阅对应的插件或
<a href=/zh-cn/docs/concepts/cluster-administration/networking/#how-to-implement-the-kubernetes-networking-model>网络驱动（Networking Provider）</a>
的文档。</p><h2 id=network-plugin-requirements>网络插件要求</h2><p>对于插件开发人员以及时常会构建并部署 Kubernetes 的用户而言，
插件可能也需要特定的配置来支持 kube-proxy。
iptables 代理依赖于 iptables，插件可能需要确保 iptables 能够监控容器的网络通信。
例如，如果插件将容器连接到 Linux 网桥，插件必须将 <code>net/bridge/bridge-nf-call-iptables</code>
sysctl 参数设置为 <code>1</code>，以确保 iptables 代理正常工作。
如果插件不使用 Linux 网桥，而是使用类似于 Open vSwitch 或者其它一些机制，
它应该确保为代理对容器通信执行正确的路由。</p><p>默认情况下，如果未指定 kubelet 网络插件，则使用 <code>noop</code> 插件，
该插件设置 <code>net/bridge/bridge-nf-call-iptables=1</code>，以确保简单的配置
（如带网桥的 Docker ）与 iptables 代理正常工作。</p><h3 id=loopback-cni>本地回路 CNI</h3><p>除了安装到节点上用于实现 Kubernetes 网络模型的 CNI 插件外，Kubernetes
还需要容器运行时提供一个本地回路接口 <code>lo</code>，用于各个沙箱（Pod 沙箱、虚机沙箱……）。
实现本地回路接口的工作可以通过复用
<a href=https://github.com/containernetworking/plugins/blob/master/plugins/main/loopback/loopback.go>CNI 本地回路插件</a>来实现，
也可以通过开发自己的代码来实现
（参阅 <a href=https://github.com/cri-o/ocicni/blob/release-1.24/pkg/ocicni/util_linux.go#L91>CRI-O 中的示例</a>）。</p><h3 id=support-hostport>支持 hostPort</h3><p>CNI 网络插件支持 <code>hostPort</code>。你可以使用官方
<a href=https://github.com/containernetworking/plugins/tree/master/plugins/meta/portmap>portmap</a>
插件，它由 CNI 插件团队提供，或者使用你自己的带有 portMapping 功能的插件。</p><p>如果你想要启动 <code>hostPort</code> 支持，则必须在 <code>cni-conf-dir</code> 指定 <code>portMappings capability</code>。
例如：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;k8s-pod-network&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;cniVersion&#34;</span>: <span style=color:#b44>&#34;0.4.0&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;plugins&#34;</span>: [
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;calico&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;log_level&#34;</span>: <span style=color:#b44>&#34;info&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;datastore_type&#34;</span>: <span style=color:#b44>&#34;kubernetes&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;nodename&#34;</span>: <span style=color:#b44>&#34;127.0.0.1&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;ipam&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;host-local&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;subnet&#34;</span>: <span style=color:#b44>&#34;usePodCidr&#34;</span>
</span></span><span style=display:flex><span>      },
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;policy&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;k8s&#34;</span>
</span></span><span style=display:flex><span>      },
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;kubernetes&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;kubeconfig&#34;</span>: <span style=color:#b44>&#34;/etc/cni/net.d/calico-kubeconfig&#34;</span>
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;portmap&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;capabilities&#34;</span>: {<span style=color:green;font-weight:700>&#34;portMappings&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>}
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  ]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=support-traffic-shaping>支持流量整形</h3><p><strong>实验功能</strong></p><p>CNI 网络插件还支持 Pod 入站和出站流量整形。
你可以使用 CNI 插件团队提供的
<a href=https://github.com/containernetworking/plugins/tree/master/plugins/meta/bandwidth>bandwidth</a>
插件，也可以使用你自己的具有带宽控制功能的插件。</p><p>如果你想要启用流量整形支持，你必须将 <code>bandwidth</code> 插件添加到 CNI 配置文件
（默认是 <code>/etc/cni/net.d</code>）并保证该可执行文件包含在你的 CNI 的 bin
文件夹内 (默认为 <code>/opt/cni/bin</code>)。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;k8s-pod-network&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;cniVersion&#34;</span>: <span style=color:#b44>&#34;0.4.0&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;plugins&#34;</span>: [
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;calico&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;log_level&#34;</span>: <span style=color:#b44>&#34;info&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;datastore_type&#34;</span>: <span style=color:#b44>&#34;kubernetes&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;nodename&#34;</span>: <span style=color:#b44>&#34;127.0.0.1&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;ipam&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;host-local&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;subnet&#34;</span>: <span style=color:#b44>&#34;usePodCidr&#34;</span>
</span></span><span style=display:flex><span>      },
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;policy&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;k8s&#34;</span>
</span></span><span style=display:flex><span>      },
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;kubernetes&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;kubeconfig&#34;</span>: <span style=color:#b44>&#34;/etc/cni/net.d/calico-kubeconfig&#34;</span>
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;bandwidth&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;capabilities&#34;</span>: {<span style=color:green;font-weight:700>&#34;bandwidth&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>}
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  ]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>现在，你可以将 <code>kubernetes.io/ingress-bandwidth</code> 和 <code>kubernetes.io/egress-bandwidth</code>
注解添加到 Pod 中。例如：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/ingress-bandwidth</span>:<span style=color:#bbb> </span>1M<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/egress-bandwidth</span>:<span style=color:#bbb> </span>1M<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=接下来>接下来</h2></div><div class=td-content style=page-break-before:always><h1 id=pg-53e1ea8892ceca307ba19e8d6a7b8d32>2.2 - 设备插件</h1><div class=lead>设备插件可以让你配置集群以支持需要特定于供应商设置的设备或资源，例如 GPU、NIC、FPGA 或非易失性主存储器。</div><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.10 [beta]</code></div><p>Kubernetes 提供了一个
<a href=https://git.k8s.io/design-proposals-archive/resource-management/device-plugin.md>设备插件框架</a>，
你可以用它来将系统硬件资源发布到 <a class=glossary-tooltip title='一个在集群中每个节点上运行的代理。它保证容器都运行在 Pod 中。' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=Kubelet>Kubelet</a>。</p><p>供应商可以实现设备插件，由你手动部署或作为 <a class=glossary-tooltip title='确保 Pod 的副本在集群中的一组节点上运行。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/workloads/controllers/daemonset/ target=_blank aria-label=DaemonSet>DaemonSet</a>
来部署，而不必定制 Kubernetes 本身的代码。目标设备包括 GPU、高性能 NIC、FPGA、
InfiniBand 适配器以及其他类似的、可能需要特定于供应商的初始化和设置的计算资源。</p><h2 id=device-plugin-registration>注册设备插件</h2><p><code>kubelet</code> 提供了一个 <code>Registration</code> 的 gRPC 服务：</p><pre tabindex=0><code class=language-gRPC data-lang=gRPC>service Registration {
	rpc Register(RegisterRequest) returns (Empty) {}
}
</code></pre><p>设备插件可以通过此 gRPC 服务在 kubelet 进行注册。在注册期间，设备插件需要发送下面几样内容：</p><ul><li>设备插件的 Unix 套接字。</li><li>设备插件的 API 版本。</li><li><code>ResourceName</code> 是需要公布的。这里 <code>ResourceName</code>
需要遵循<a href=/zh-cn/docs/concepts/configuration/manage-resources-containers/#extended-resources>扩展资源命名方案</a>，
类似于 <code>vendor-domain/resourcetype</code>。（比如 NVIDIA GPU 就被公布为 <code>nvidia.com/gpu</code>。）</li></ul><p>成功注册后，设备插件就向 kubelet 发送它所管理的设备列表，然后 kubelet
负责将这些资源发布到 API 服务器，作为 kubelet 节点状态更新的一部分。</p><p>比如，设备插件在 kubelet 中注册了 <code>hardware-vendor.example/foo</code>
并报告了节点上的两个运行状况良好的设备后，节点状态将更新以通告该节点已安装 2 个
"Foo" 设备并且是可用的。</p><p>然后，用户可以请求设备作为 Pod 规范的一部分，
参见 <a href=/zh-cn/docs/reference/kubernetes-api/workload-resources/pod-v1/#Container>Container</a>。
请求扩展资源类似于管理请求和限制的方式，
其他资源，有以下区别：</p><ul><li>扩展资源仅可作为整数资源使用，并且不能被过量使用</li><li>设备不能在容器之间共享</li></ul><h3 id=example-pod>示例</h3><p>假设 Kubernetes 集群正在运行一个设备插件，该插件在一些节点上公布的资源为 <code>hardware-vendor.example/foo</code>。
下面就是一个 Pod 示例，请求此资源以运行一个工作负载的示例：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>demo-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>demo-container-1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>registry.k8s.io/pause:2.0<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>hardware-vendor.example/foo</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 这个 pod 需要两个 hardware-vendor.example/foo 设备</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 而且只能够调度到满足需求的节点上</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 如果该节点中有 2 个以上的设备可用，其余的可供其他 Pod 使用</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=device-plugin-implementation>设备插件的实现</h2><p>设备插件的常规工作流程包括以下几个步骤：</p><ul><li><p>初始化。在这个阶段，设备插件将执行供应商特定的初始化和设置，
以确保设备处于就绪状态。</p></li><li><p>插件使用主机路径 <code>/var/lib/kubelet/device-plugins/</code> 下的 Unix 套接字启动一个
gRPC 服务，该服务实现以下接口：</p><pre tabindex=0><code class=language-gRPC data-lang=gRPC>service DevicePlugin {
    // GetDevicePluginOptions 返回与设备管理器沟通的选项。
    rpc GetDevicePluginOptions(Empty) returns (DevicePluginOptions) {}

    // ListAndWatch 返回 Device 列表构成的数据流。
    // 当 Device 状态发生变化或者 Device 消失时，ListAndWatch
    // 会返回新的列表。
    rpc ListAndWatch(Empty) returns (stream ListAndWatchResponse) {}

    // Allocate 在容器创建期间调用，这样设备插件可以运行一些特定于设备的操作，
    // 并告诉 kubelet 如何令 Device 可在容器中访问的所需执行的具体步骤
    rpc Allocate(AllocateRequest) returns (AllocateResponse) {}

    // GetPreferredAllocation 从一组可用的设备中返回一些优选的设备用来分配，
    // 所返回的优选分配结果不一定会是设备管理器的最终分配方案。
    // 此接口的设计仅是为了让设备管理器能够在可能的情况下做出更有意义的决定。
    rpc GetPreferredAllocation(PreferredAllocationRequest) returns (PreferredAllocationResponse) {}

    // PreStartContainer 在设备插件注册阶段根据需要被调用，调用发生在容器启动之前。
    // 在将设备提供给容器使用之前，设备插件可以运行一些诸如重置设备之类的特定于
    // 具体设备的操作，
    rpc PreStartContainer(PreStartContainerRequest) returns (PreStartContainerResponse) {}
}
</code></pre><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>插件并非必须为 <code>GetPreferredAllocation()</code> 或 <code>PreStartContainer()</code> 提供有用的实现逻辑，
调用 <code>GetDevicePluginOptions()</code> 时所返回的 <code>DevicePluginOptions</code>
消息中应该设置这些调用是否可用。<code>kubelet</code> 在真正调用这些函数之前，总会调用
<code>GetDevicePluginOptions()</code> 来查看是否存在这些可选的函数。</div></li></ul><ul><li>插件通过 Unix socket 在主机路径 <code>/var/lib/kubelet/device-plugins/kubelet.sock</code>
处向 kubelet 注册自身。</li><li>成功注册自身后，设备插件将以服务模式运行，在此期间，它将持续监控设备运行状况，
并在设备状态发生任何变化时向 kubelet 报告。它还负责响应 <code>Allocate</code> gRPC 请求。
在 <code>Allocate</code> 期间，设备插件可能还会做一些设备特定的准备；例如 GPU 清理或 QRNG 初始化。
如果操作成功，则设备插件将返回 <code>AllocateResponse</code>，其中包含用于访问被分配的设备容器运行时的配置。
kubelet 将此信息传递到容器运行时。</li></ul><h3 id=handling-kubelet-restarts>处理 kubelet 重启</h3><p>设备插件应能监测到 kubelet 重启，并且向新的 kubelet 实例来重新注册自己。
在当前实现中，当 kubelet 重启的时候，新的 kubelet 实例会删除 <code>/var/lib/kubelet/device-plugins</code>
下所有已经存在的 Unix 套接字。
设备插件需要能够监控到它的 Unix 套接字被删除，并且当发生此类事件时重新注册自己。</p><h2 id=device-plugin-depoloyments>设备插件部署</h2><p>你可以将你的设备插件作为节点操作系统的软件包来部署、作为 DaemonSet 来部署或者手动部署。</p><p>规范目录 <code>/var/lib/kubelet/device-plugins</code> 是需要特权访问的，
所以设备插件必须要在被授权的安全的上下文中运行。
如果你将设备插件部署为 DaemonSet，<code>/var/lib/kubelet/device-plugins</code> 目录必须要在插件的
<a href=/docs/reference/generated/kubernetes-api/v1.25/#podspec-v1-core>PodSpec</a>
中声明作为 <a class=glossary-tooltip title='包含可被 Pod 中容器访问的数据的目录。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/storage/volumes/ target=_blank aria-label=卷（Volume）>卷（Volume）</a> 被挂载到插件中。</p><p>如果你选择 DaemonSet 方法，你可以通过 Kubernetes 进行以下操作：
将设备插件的 Pod 放置在节点上，在出现故障后重新启动守护进程 Pod，来进行自动升级。</p><h2 id=api-compatibility>API 兼容性</h2><p>Kubernetes 设备插件支持还处于 beta 版本。所以在稳定版本出来之前 API 会以不兼容的方式进行更改。
作为一个项目，Kubernetes 建议设备插件开发者：</p><ul><li>注意未来版本的更改</li><li>支持多个版本的设备插件 API，以实现向后/向前兼容性。</li></ul><p>如果你启用 DevicePlugins 功能，并在需要升级到 Kubernetes 版本来获得较新的设备插件 API
版本的节点上运行设备插件，请在升级这些节点之前先升级设备插件以支持这两个版本。
采用该方法将确保升级期间设备分配的连续运行。</p><h2 id=monitoring-device-plugin-resources>监控设备插件资源</h2><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.15 [beta]</code></div><p>为了监控设备插件提供的资源，监控代理程序需要能够发现节点上正在使用的设备，
并获取元数据来描述哪个指标与容器相关联。
设备监控代理暴露给 <a href=https://prometheus.io/>Prometheus</a> 的指标应该遵循
<a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-instrumentation/instrumentation.md>Kubernetes Instrumentation Guidelines</a>，
使用 <code>pod</code>、<code>namespace</code> 和 <code>container</code> 标签来标识容器。</p><p>kubelet 提供了 gRPC 服务来使得正在使用中的设备被发现，并且还为这些设备提供了元数据：</p><pre tabindex=0><code class=language-gRPC data-lang=gRPC>// PodResourcesLister 是一个由 kubelet 提供的服务，用来提供供节点上 
// Pod 和容器使用的节点资源的信息
service PodResourcesLister {
    rpc List(ListPodResourcesRequest) returns (ListPodResourcesResponse) {}
    rpc GetAllocatableResources(AllocatableResourcesRequest) returns (AllocatableResourcesResponse) {}
}
</code></pre><h3 id=grpc-endpoint-list><code>List</code> gRPC 端点</h3><p>这一 <code>List</code> 端点提供运行中 Pod 的资源信息，包括类似独占式分配的
CPU ID、设备插件所报告的设备 ID 以及这些设备分配所处的 NUMA 节点 ID。
此外，对于基于 NUMA 的机器，它还会包含为容器保留的内存和大页的信息。</p><pre tabindex=0><code class=language-gRPC data-lang=gRPC>// ListPodResourcesResponse 是 List 函数的响应
message ListPodResourcesResponse {
    repeated PodResources pod_resources = 1;
}

// PodResources 包含关于分配给 Pod 的节点资源的信息
message PodResources {
    string name = 1;
    string namespace = 2;
    repeated ContainerResources containers = 3;
}

// ContainerResources 包含分配给容器的资源的信息
message ContainerResources {
    string name = 1;
    repeated ContainerDevices devices = 2;
    repeated int64 cpu_ids = 3;
    repeated ContainerMemory memory = 4;
}

// ContainerMemory 包含分配给容器的内存和大页信息
message ContainerMemory {
    string memory_type = 1;
    uint64 size = 2;
    TopologyInfo topology = 3;
}

// Topology 描述资源的硬件拓扑结构
message TopologyInfo {
        repeated NUMANode nodes = 1;
}

// NUMA 代表的是 NUMA 节点
message NUMANode {
        int64 ID = 1;
}

// ContainerDevices 包含分配给容器的设备信息
message ContainerDevices {
    string resource_name = 1;
    repeated string device_ids = 2;
    TopologyInfo topology = 3;
}
</code></pre><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p><code>List</code> 端点中的 <code>ContainerResources</code> 中的 cpu_ids 对应于分配给某个容器的专属 CPU。
如果要统计共享池中的 CPU，<code>List</code> 端点需要与 <code>GetAllocatableResources</code> 端点一起使用，如下所述:</p><ol><li>调用 <code>GetAllocatableResources</code> 获取所有可用的 CPU。</li><li>在系统中所有的 <code>ContainerResources</code> 上调用 <code>GetCpuIds</code>。</li><li>用 <code>GetAllocatableResources</code> 获取的 CPU 数减去 <code>GetCpuIds</code> 获取的 CPU 数。</li></ol></div><h3 id=grpc-endpoint-getallocatableresources><code>GetAllocatableResources</code> gRPC 端点</h3><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.23 [beta]</code></div><p>端点 <code>GetAllocatableResources</code> 提供工作节点上原始可用的资源信息。
此端点所提供的信息比导出给 API 服务器的信息更丰富。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p><code>GetAllocatableResources</code> 应该仅被用于评估一个节点上的<a href=/zh-cn/docs/tasks/administer-cluster/reserve-compute-resources/#node-allocatable>可分配的</a>资源。
如果目标是评估空闲/未分配的资源，此调用应该与 List() 端点一起使用。
除非暴露给 kubelet 的底层资源发生变化，否则 <code>GetAllocatableResources</code> 得到的结果将保持不变。
这种情况很少发生，但当发生时（例如：热插拔，设备健康状况改变），客户端应该调用 <code>GetAlloctableResources</code> 端点。
然而，调用 <code>GetAllocatableResources</code> 端点在 cpu、内存被更新的情况下是不够的，
Kubelet 需要重新启动以获取正确的资源容量和可分配的资源。</div><pre tabindex=0><code class=language-gRPC data-lang=gRPC>// AllocatableResourcesResponses 包含 kubelet 所了解到的所有设备的信息
message AllocatableResourcesResponse {
    repeated ContainerDevices devices = 1;
    repeated int64 cpu_ids = 2;
    repeated ContainerMemory memory = 3;
}
</code></pre><p>从 Kubernetes v1.23 开始，<code>GetAllocatableResources</code> 被默认启用。
你可以通过关闭 <code>KubeletPodResourcesGetAllocatable</code>
<a href=/zh-cn/docs/reference/command-line-tools-reference/feature-gates/>特性门控</a>来禁用。</p><p>在 Kubernetes v1.23 之前，要启用这一功能，<code>kubelet</code> 必须用以下标志启动：</p><p><code>--feature-gates=KubeletPodResourcesGetAllocatable=true</code></p><p><code>ContainerDevices</code> 会向外提供各个设备所隶属的 NUMA 单元这类拓扑信息。
NUMA 单元通过一个整数 ID 来标识，其取值与设备插件所报告的一致。
<a href=/zh-cn/docs/concepts/extend-kubernetes/compute-storage-net/device-plugins/>设备插件注册到 kubelet 时</a>
会报告这类信息。</p><p>gRPC 服务通过 <code>/var/lib/kubelet/pod-resources/kubelet.sock</code> 的 UNIX 套接字来提供服务。
设备插件资源的监控代理程序可以部署为守护进程或者 DaemonSet。
规范的路径 <code>/var/lib/kubelet/pod-resources</code> 需要特权来进入，
所以监控代理程序必须要在获得授权的安全的上下文中运行。
如果设备监控代理以 DaemonSet 形式运行，必须要在插件的
<a href=/docs/reference/generated/kubernetes-api/v1.25/#podspec-v1-core>PodSpec</a>
中声明将 <code>/var/lib/kubelet/pod-resources</code>
目录以<a class=glossary-tooltip title='包含可被 Pod 中容器访问的数据的目录。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/storage/volumes/ target=_blank aria-label=卷>卷</a>的形式被挂载到设备监控代理中。</p><p>对 “PodResourcesLister 服务”的支持要求启用 <code>KubeletPodResources</code>
<a href=/zh-cn/docs/reference/command-line-tools-reference/feature-gates/>特性门控</a>。
从 Kubernetes 1.15 开始默认启用，自从 Kubernetes 1.20 开始为 v1。</p><h2 id=device-plugin-integration-with-the-topology-manager>设备插件与拓扑管理器的集成</h2><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.18 [beta]</code></div><p>拓扑管理器是 Kubelet 的一个组件，它允许以拓扑对齐方式来调度资源。
为了做到这一点，设备插件 API 进行了扩展来包括一个 <code>TopologyInfo</code> 结构体。</p><pre tabindex=0><code class=language-gRPC data-lang=gRPC>message TopologyInfo {
    repeated NUMANode nodes = 1;
}

message NUMANode {
    int64 ID = 1;
}
</code></pre><p>设备插件希望拓扑管理器可以将填充的 TopologyInfo 结构体作为设备注册的一部分以及设备 ID
和设备的运行状况发送回去。然后设备管理器将使用此信息来咨询拓扑管理器并做出资源分配决策。</p><p><code>TopologyInfo</code> 支持将 <code>nodes</code> 字段设置为 <code>nil</code> 或一个 NUMA 节点的列表。
这样就可以使设备插件通告跨越多个 NUMA 节点的设备。</p><p>将 <code>TopologyInfo</code> 设置为 <code>nil</code> 或为给定设备提供一个空的
NUMA 节点列表表示设备插件没有该设备的 NUMA 亲和偏好。</p><p>下面是一个由设备插件为设备填充 <code>TopologyInfo</code> 结构体的示例：</p><pre tabindex=0><code>pluginapi.Device{ID: &#34;25102017&#34;, Health: pluginapi.Healthy, Topology:&amp;pluginapi.TopologyInfo{Nodes: []*pluginapi.NUMANode{&amp;pluginapi.NUMANode{ID: 0,},}}}
</code></pre><h2 id=examples>设备插件示例</h2><div class="alert alert-secondary callout third-party-content" role=alert><strong>说明：</strong>
本部分链接到提供 Kubernetes 所需功能的第三方项目。Kubernetes 项目作者不负责这些项目。此页面遵循<a href=https://github.com/cncf/foundation/blob/master/website-guidelines.md target=_blank>CNCF 网站指南</a>，按字母顺序列出项目。要将项目添加到此列表中，请在提交更改之前阅读<a href=/docs/contribute/style/content-guide/#third-party-content>内容指南</a>。</div><p>下面是一些设备插件实现的示例：</p><ul><li><a href=https://github.com/RadeonOpenCompute/k8s-device-plugin>AMD GPU 设备插件</a></li><li><a href=https://github.com/intel/intel-device-plugins-for-kubernetes>Intel 设备插件</a>支持 Intel GPU、FPGA、QAT、VPU、SGX、DSA、DLB 和 IAA 设备</li><li><a href=https://github.com/kubevirt/kubernetes-device-plugins>KubeVirt 设备插件</a> 用于硬件辅助的虚拟化</li><li><a href=https://github.com/GoogleCloudPlatform/container-engine-accelerators/tree/master/cmd/nvidia_gpu>为 Container-Optimized OS 所提供的 NVIDIA GPU 设备插件</a></li><li><a href=https://github.com/hustcat/k8s-rdma-device-plugin>RDMA 设备插件</a></li><li><a href=https://github.com/collabora/k8s-socketcan>SocketCAN 设备插件</a></li><li><a href=https://github.com/vikaschoudhary16/sfc-device-plugin>Solarflare 设备插件</a></li><li><a href=https://github.com/intel/sriov-network-device-plugin>SR-IOV 网络设备插件</a></li><li><a href=https://github.com/Xilinx/FPGA_as_a_Service/tree/master/k8s-device-plugin>Xilinx FPGA 设备插件</a></li></ul><h2 id=接下来>接下来</h2><ul><li>查看<a href=/zh-cn/docs/tasks/manage-gpus/scheduling-gpus/>调度 GPU 资源</a>来学习使用设备插件</li><li>查看在上如何<a href=/zh-cn/docs/tasks/administer-cluster/extended-resource-node/>公布节点上的扩展资源</a></li><li>学习<a href=/zh-cn/docs/tasks/administer-cluster/topology-manager/>拓扑管理器</a></li><li>阅读如何在 Kubernetes 中使用 <a href=/zh-cn/blog/2019/04/24/hardware-accelerated-ssl/tls-termination-in-ingress-controllers-using-kubernetes-device-plugins-and-runtimeclass/>TLS Ingress 的硬件加速</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-0af41d3bd7c785621b58b7564793396a>3 - 扩展 Kubernetes API</h1></div><div class=td-content><h1 id=pg-342388440304e19ce30c0f8ada1c77ce>3.1 - 定制资源</h1><p><strong>定制资源（Custom Resource）</strong> 是对 Kubernetes API 的扩展。
本页讨论何时向 Kubernetes 集群添加定制资源，何时使用独立的服务。
本页描述添加定制资源的两种方法以及怎样在二者之间做出抉择。</p><h2 id=定制资源>定制资源</h2><p><strong>资源（Resource）</strong> 是
<a href=/zh-cn/docs/concepts/overview/kubernetes-api/>Kubernetes API</a> 中的一个端点，
其中存储的是某个类别的
<a href=/zh-cn/docs/concepts/overview/working-with-objects/kubernetes-objects/>API 对象</a>的一个集合。
例如内置的 <strong>Pod</strong> 资源包含一组 Pod 对象。</p><p><strong>定制资源（Custom Resource）</strong> 是对 Kubernetes API 的扩展，不一定在默认的
Kubernetes 安装中就可用。
定制资源所代表的是对特定 Kubernetes 安装的一种定制。
不过，很多 Kubernetes 核心功能现在都用定制资源来实现，这使得 Kubernetes 更加模块化。</p><p>定制资源可以通过动态注册的方式在运行中的集群内或出现或消失，集群管理员可以独立于集群更新定制资源。
一旦某定制资源被安装，用户可以使用 <a class=glossary-tooltip title='kubectl 是用来和 Kubernetes 集群进行通信的命令行工具。' data-toggle=tooltip data-placement=top href=/docs/user-guide/kubectl-overview/ target=_blank aria-label=kubectl>kubectl</a> 来创建和访问其中的对象，
就像他们为 <strong>Pod</strong> 这种内置资源所做的一样。</p><h2 id=custom-controllers>定制控制器</h2><p>就定制资源本身而言，它只能用来存取结构化的数据。
当你将定制资源与<strong>定制控制器（Custom Controller）</strong> 结合时，
定制资源就能够提供真正的<strong>声明式 API（Declarative API）</strong>。</p><p>Kubernetes <a href=/zh-cn/docs/concepts/overview/kubernetes-api/>声明式 API</a> 强制对职权做了一次分离操作。
你声明所用资源的期望状态，而 Kubernetes 控制器使 Kubernetes 对象的当前状态与你所声明的期望状态保持同步。
声明式 API 的这种机制与命令式 API（你<strong>指示</strong>服务器要做什么，服务器就去做什么）形成鲜明对比。</p><p>你可以在一个运行中的集群上部署和更新定制控制器，这类操作与集群的生命周期无关。
定制控制器可以用于任何类别的资源，不过它们与定制资源结合起来时最为有效。
<a href=/zh-cn/docs/concepts/extend-kubernetes/operator/>Operator 模式</a>就是将定制资源与定制控制器相结合的。
你可以使用定制控制器来将特定于某应用的领域知识组织起来，以编码的形式构造对 Kubernetes API 的扩展。</p><h2 id=should-i-add-a-cr-to-my-k8s-cluster>我是否应该向我的 Kubernetes 集群添加定制资源？</h2><p>在创建新的 API 时，
请考虑是<a href=/zh-cn/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>将你的 API 与 Kubernetes 集群 API 聚合起来</a>，
还是让你的 API 独立运行。</p><table><thead><tr><th>考虑 API 聚合的情况</th><th>优选独立 API 的情况</th></tr></thead><tbody><tr><td>你的 API 是<a href=#declarative-apis>声明式的</a>。</td><td>你的 API 不符合<a href=#declarative-apis>声明式</a>模型。</td></tr><tr><td>你希望可以是使用 <code>kubectl</code> 来读写你的新资源类别。</td><td>不要求 <code>kubectl</code> 支持。</td></tr><tr><td>你希望在 Kubernetes UI （如仪表板）中和其他内置类别一起查看你的新资源类别。</td><td>不需要 Kubernetes UI 支持。</td></tr><tr><td>你在开发新的 API。</td><td>你已经有一个提供 API 服务的程序并且工作良好。</td></tr><tr><td>你有意愿取接受 Kubernetes 对 REST 资源路径所作的格式限制，例如 API 组和名字空间。（参阅 <a href=/zh-cn/docs/concepts/overview/kubernetes-api/>API 概述</a>）</td><td>你需要使用一些特殊的 REST 路径以便与已经定义的 REST API 保持兼容。</td></tr><tr><td>你的资源可以自然地界定为集群作用域或集群中某个名字空间作用域。</td><td>集群作用域或名字空间作用域这种二分法很不合适；你需要对资源路径的细节进行控制。</td></tr><tr><td>你希望复用 <a href=#common-features>Kubernetes API 支持特性</a>。</td><td>你不需要这类特性。</td></tr></tbody></table><h3 id=declarative-apis>声明式 API</h3><p>典型地，在声明式 API 中：</p><ul><li>你的 API 包含相对而言为数不多的、尺寸较小的对象（资源）。</li><li>对象定义了应用或者基础设施的配置信息。</li><li>对象更新操作频率较低。</li><li>通常需要人来读取或写入对象。</li><li>对象的主要操作是 CRUD 风格的（创建、读取、更新和删除）。</li><li>不需要跨对象的事务支持：API 对象代表的是期望状态而非确切实际状态。</li></ul><p>命令式 API（Imperative API）与声明式有所不同。
以下迹象表明你的 API 可能不是声明式的：</p><ul><li>客户端发出“做这个操作”的指令，之后在该操作结束时获得同步响应。</li><li>客户端发出“做这个操作”的指令，并获得一个操作 ID，之后需要检查一个 Operation（操作）
对象来判断请求是否成功完成。</li><li>你会将你的 API 类比为远程过程调用（Remote Procedure Call，RPC）。</li><li>直接存储大量数据；例如每个对象几 kB，或者存储上千个对象。</li><li>需要较高的访问带宽（长期保持每秒数十个请求）。</li><li>存储有应用来处理的最终用户数据（如图片、个人标识信息（PII）等）或者其他大规模数据。</li><li>在对象上执行的常规操作并非 CRUD 风格。</li><li>API 不太容易用对象来建模。</li><li>你决定使用操作 ID 或者操作对象来表现悬决的操作。</li></ul><h2 id=should-i-use-a-configmap-or-a-cr>我应该使用一个 ConfigMap 还是一个定制资源？</h2><p>如果满足以下条件之一，应该使用 ConfigMap：</p><ul><li>存在一个已有的、文档完备的配置文件格式约定，例如 <code>mysql.cnf</code> 或 <code>pom.xml</code>。</li><li>你希望将整个配置文件放到某 configMap 中的一个主键下面。</li><li>配置文件的主要用途是针对运行在集群中 Pod 内的程序，供后者依据文件数据配置自身行为。</li><li>文件的使用者期望以 Pod 内文件或者 Pod 内环境变量的形式来使用文件数据，
而不是通过 Kubernetes API。</li><li>你希望当文件被更新时通过类似 Deployment 之类的资源完成滚动更新操作。</li></ul><div class="alert alert-info note callout" role=alert><strong>说明：</strong> 请使用 <a class=glossary-tooltip title='Secret 用于存储敏感信息，如密码、 OAuth 令牌和 SSH 密钥。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/configuration/secret/ target=_blank aria-label=Secret>Secret</a> 来保存敏感数据。
Secret 类似于 configMap，但更为安全。</div><p>如果以下条件中大多数都被满足，你应该使用定制资源（CRD 或者 聚合 API）：</p><ul><li>你希望使用 Kubernetes 客户端库和 CLI 来创建和更改新的资源。</li><li>你希望 <code>kubectl</code> 能够直接支持你的资源；例如，<code>kubectl get my-object object-name</code>。</li><li>你希望构造新的自动化机制，监测新对象上的更新事件，并对其他对象执行 CRUD
操作，或者监测后者更新前者。</li><li>你希望编写自动化组件来处理对对象的更新。</li><li>你希望使用 Kubernetes API 对诸如 <code>.spec</code>、<code>.status</code> 和 <code>.metadata</code> 等字段的约定。</li><li>你希望对象是对一组受控资源的抽象，或者对其他资源的归纳提炼。</li></ul><h2 id=adding-custom-resources>添加定制资源</h2><p>Kubernetes 提供了两种方式供你向集群中添加定制资源：</p><ul><li>CRD 相对简单，创建 CRD 可以不必编程。</li><li><a href=/zh-cn/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>API 聚合</a>需要编程，
但支持对 API 行为进行更多的控制，例如数据如何存储以及在不同 API 版本间如何转换等。</li></ul><p>Kubernetes 提供这两种选项以满足不同用户的需求，这样就既不会牺牲易用性也不会牺牲灵活性。</p><p>聚合 API 指的是一些下位的 API 服务器，运行在主 API 服务器后面；主 API
服务器以代理的方式工作。这种组织形式称作
<a href=/zh-cn/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>API 聚合（API Aggregation，AA）</a> 。
对用户而言，看起来仅仅是 Kubernetes API 被扩展了。</p><p>CRD 允许用户创建新的资源类别同时又不必添加新的 API 服务器。
使用 CRD 时，你并不需要理解 API 聚合。</p><p>无论以哪种方式安装定制资源，新的资源都会被当做定制资源，以便与内置的
Kubernetes 资源（如 Pods）相区分。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>避免将定制资源用于存储应用、最终用户或监控数据：
将应用数据存储在 Kubernetes API 内的架构设计通常代表一种过于紧密耦合的设计。</p><p>在架构上，<a href=https://www.cncf.io/about/faq/#what-is-cloud-native>云原生</a>应用架构倾向于各组件之间的松散耦合。
如果部分工作负载需要支持服务来维持其日常运转，则这种支持服务应作为一个组件运行或作为一个外部服务来使用。
这样，工作负载的正常运转就不会依赖 Kubernetes API 了。</p></div><h2 id=customresourcedefinitions>CustomResourceDefinitions</h2><p><a href=/zh-cn/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/>CustomResourceDefinition</a>
API 资源允许你定义定制资源。
定义 CRD 对象的操作会使用你所设定的名字和模式定义（Schema）创建一个新的定制资源，
Kubernetes API 负责为你的定制资源提供存储和访问服务。
CRD 对象的名称必须是合法的
<a href=/zh-cn/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNS 子域名</a>。</p><p>CRD 使得你不必编写自己的 API 服务器来处理定制资源，不过其背后实现的通用性也意味着
你所获得的灵活性要比 <a href=#api-server-aggregation>API 服务器聚合</a>少很多。</p><p>关于如何注册新的定制资源、使用新资源类别的实例以及如何使用控制器来处理事件，
相关的例子可参见<a href=https://github.com/kubernetes/sample-controller>定制控制器示例</a>。</p><h2 id=api-server-aggregation>API 服务器聚合</h2><p>通常，Kubernetes API 中的每个资源都需要处理 REST 请求和管理对象持久性存储的代码。
Kubernetes API 主服务器能够处理诸如 <em>pods</em> 和 <em>services</em> 这些内置资源，也可以
按通用的方式通过 <a href=#customresourcedefinitions>CRD</a> 来处理定制资源。</p><p><a href=/zh-cn/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>聚合层（Aggregation Layer）</a>
使得你可以通过编写和部署你自己的 API 服务器来为定制资源提供特殊的实现。
主 API 服务器将针对你要处理的定制资源的请求全部委托给你自己的 API 服务器来处理，同时将这些资源
提供给其所有客户端。</p><h2 id=choosing-a-method-for-adding-cr>选择添加定制资源的方法</h2><p>CRD 更为易用；聚合 API 则更为灵活。请选择最符合你的需要的方法。</p><p>通常，如何存在以下情况，CRD 可能更合适：</p><ul><li>定制资源的字段不多；</li><li>你在组织内部使用该资源或者在一个小规模的开源项目中使用该资源，而不是在商业产品中使用。</li></ul><h3 id=compare-ease-of-use>比较易用性</h3><p>CRD 比聚合 API 更容易创建。</p><table><thead><tr><th>CRD</th><th>聚合 API</th></tr></thead><tbody><tr><td>无需编程。用户可选择任何语言来实现 CRD 控制器。</td><td>需要编程，并构建可执行文件和镜像。</td></tr><tr><td>无需额外运行服务；CRD 由 API 服务器处理。</td><td>需要额外创建服务，且该服务可能失效。</td></tr><tr><td>一旦 CRD 被创建，不需要持续提供支持。Kubernetes 主控节点升级过程中自动会带入缺陷修复。</td><td>可能需要周期性地从上游提取缺陷修复并更新聚合 API 服务器。</td></tr><tr><td>无需处理 API 的多个版本；例如，当你控制资源的客户端时，你可以更新它使之与 API 同步。</td><td>你需要处理 API 的多个版本；例如，在开发打算与很多人共享的扩展时。</td></tr></tbody></table><h3 id=advanced-features-and-flexibility>高级特性与灵活性</h3><p>聚合 API 可提供更多的高级 API 特性，也可对其他特性实行定制；例如，对存储层进行定制。</p><table><thead><tr><th>特性</th><th>描述</th><th>CRD</th><th>聚合 API</th></tr></thead><tbody><tr><td>合法性检查</td><td>帮助用户避免错误，允许你独立于客户端版本演化 API。这些特性对于由很多无法同时更新的客户端的场合。</td><td>可以。大多数验证可以使用 <a href=/zh-cn/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#validation>OpenAPI v3.0 合法性检查</a> 来设定。其他合法性检查操作可以通过添加<a href=/zh-cn/docs/reference/access-authn-authz/admission-controllers/#validatingadmissionwebhook-alpha-in-1-8-beta-in-1-9>合法性检查 Webhook</a>来实现。</td><td>可以，可执行任何合法性检查。</td></tr><tr><td>默认值设置</td><td>同上</td><td>可以。可通过 <a href=/zh-cn/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#defaulting>OpenAPI v3.0 合法性检查</a>的 <code>default</code> 关键词（自 1.17 正式发布）或<a href=/zh-cn/docs/reference/access-authn-authz/admission-controllers/#mutatingadmissionwebhook>更改性（Mutating）Webhook</a>来实现（不过从 etcd 中读取老的对象时不会执行这些 Webhook）。</td><td>可以。</td></tr><tr><td>多版本支持</td><td>允许通过两个 API 版本同时提供同一对象。可帮助简化类似字段更名这类 API 操作。如果你能控制客户端版本，这一特性将不再重要。</td><td><a href=/zh-cn/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definition-versioning>可以</a>。</td><td>可以。</td></tr><tr><td>定制存储</td><td>支持使用具有不同性能模式的存储（例如，要使用时间序列数据库而不是键值存储），或者因安全性原因对存储进行隔离（例如对敏感信息执行加密）。</td><td>不可以。</td><td>可以。</td></tr><tr><td>定制业务逻辑</td><td>在创建、读取、更新或删除对象时，执行任意的检查或操作。</td><td>可以。要使用 <a href=/zh-cn/docs/reference/access-authn-authz/extensible-admission-controllers/#admission-webhooks>Webhook</a>。</td><td>可以。</td></tr><tr><td>支持 scale 子资源</td><td>允许 HorizontalPodAutoscaler 和 PodDisruptionBudget 这类子系统与你的新资源交互。</td><td><a href=/zh-cn/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#scale-subresource>可以</a>。</td><td>可以。</td></tr><tr><td>支持 status 子资源</td><td>允许在用户写入 spec 部分而控制器写入 status 部分时执行细粒度的访问控制。允许在对定制资源的数据进行更改时增加对象的代际（Generation）；这需要资源对 spec 和 status 部分有明确划分。</td><td><a href=/zh-cn/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#status-subresource>可以</a>。</td><td>可以。</td></tr><tr><td>其他子资源</td><td>添加 CRUD 之外的操作，例如 "logs" 或 "exec"。</td><td>不可以。</td><td>可以。</td></tr><tr><td>strategic-merge-patch</td><td>新的端点要支持标记了 <code>Content-Type: application/strategic-merge-patch+json</code> 的 PATCH 操作。对于更新既可在本地更改也可在服务器端更改的对象而言是有用的。要了解更多信息，可参见<a href=/zh-cn/docs/tasks/manage-kubernetes-objects/update-api-object-kubectl-patch/>使用 <code>kubectl patch</code> 来更新 API 对象</a>。</td><td>不可以。</td><td>可以。</td></tr><tr><td>支持协议缓冲区</td><td>新的资源要支持想要使用协议缓冲区（Protocol Buffer）的客户端。</td><td>不可以。</td><td>可以。</td></tr><tr><td>OpenAPI Schema</td><td>是否存在新资源类别的 OpenAPI（Swagger）Schema 可供动态从服务器上读取？是否存在机制确保只能设置被允许的字段以避免用户犯字段拼写错误？是否实施了字段类型检查（换言之，不允许在 <code>string</code> 字段设置 <code>int</code> 值）？</td><td>可以，依据 <a href=/zh-cn/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#validation>OpenAPI v3.0 合法性检查</a> 模式（1.16 中进入正式发布状态）。</td><td>可以。</td></tr></tbody></table><h3 id=common-features>公共特性</h3><p>与在 Kubernetes 平台之外实现定制资源相比，
无论是通过 CRD 还是通过聚合 API 来创建定制资源，你都会获得很多 API 特性：</p><table><thead><tr><th>功能特性</th><th>具体含义</th></tr></thead><tbody><tr><td>CRUD</td><td>新的端点支持通过 HTTP 和 <code>kubectl</code> 发起的 CRUD 基本操作</td></tr><tr><td>监测（Watch）</td><td>新的端点支持通过 HTTP 发起的 Kubernetes Watch 操作</td></tr><tr><td>发现（Discovery）</td><td>类似 <code>kubectl</code> 和仪表盘（Dashboard）这类客户端能够自动提供列举、显示、在字段级编辑你的资源的操作</td></tr><tr><td>json-patch</td><td>新的端点支持带 <code>Content-Type: application/json-patch+json</code> 的 PATCH 操作</td></tr><tr><td>merge-patch</td><td>新的端点支持带 <code>Content-Type: application/merge-patch+json</code> 的 PATCH 操作</td></tr><tr><td>HTTPS</td><td>新的端点使用 HTTPS</td></tr><tr><td>内置身份认证</td><td>对扩展的访问会使用核心 API 服务器（聚合层）来执行身份认证操作</td></tr><tr><td>内置鉴权授权</td><td>对扩展的访问可以复用核心 API 服务器所使用的鉴权授权机制；例如，RBAC</td></tr><tr><td>Finalizers</td><td>在外部清除工作结束之前阻止扩展资源被删除</td></tr><tr><td>准入 Webhooks</td><td>在创建、更新和删除操作中对扩展资源设置默认值和执行合法性检查</td></tr><tr><td>UI/CLI 展示</td><td><code>kubectl</code> 和仪表盘（Dashboard）可以显示扩展资源</td></tr><tr><td>区分未设置值和空值</td><td>客户端能够区分哪些字段是未设置的，哪些字段的值是被显式设置为零值的。</td></tr><tr><td>生成客户端库</td><td>Kubernetes 提供通用的客户端库，以及用来生成特定类别客户端库的工具</td></tr><tr><td>标签和注解</td><td>提供涵盖所有对象的公共元数据结构，且工具知晓如何编辑核心资源和定制资源的这些元数据</td></tr></tbody></table><h2 id=preparing-to-install-a-cr>准备安装定制资源</h2><p>在向你的集群添加定制资源之前，有些事情需要搞清楚。</p><h3 id=third-party-code-and-new-points-of-failure>第三方代码和新的失效点的问题</h3><p>尽管添加新的 CRD 不会自动带来新的失效点（Point of
Failure），例如导致第三方代码被在 API 服务器上运行，
类似 Helm Charts 这种软件包或者其他安装包通常在提供 CRD
的同时还包含带有第三方代码的 Deployment，负责实现新的定制资源的业务逻辑。</p><p>安装聚合 API 服务器时，也总会牵涉到运行一个新的 Deployment。</p><h3 id=storage>存储</h3><p>定制资源和 ConfigMap 一样也会消耗存储空间。创建过多的定制资源可能会导致
API 服务器上的存储空间超载。</p><p>聚合 API 服务器可以使用主 API 服务器相同的存储。如果是这样，你也要注意此警告。</p><h3 id=authentication-authorization-and-auditing>身份认证、鉴权授权以及审计</h3><p>CRD 通常与 API 服务器上的内置资源一样使用相同的身份认证、鉴权授权和审计日志机制。</p><p>如果你使用 RBAC 来执行鉴权授权，大多数 RBAC 角色都不会授权对新资源的访问
（除了 cluster-admin 角色以及使用通配符规则创建的其他角色）。
你要显式地为新资源的访问授权。CRD 和聚合 API 通常在交付时会包含针对所添加的类别的新的角色定义。</p><p>聚合 API 服务器可能会使用主 API 服务器相同的身份认证、鉴权授权和审计机制，也可能不会。</p><h2 id=accessing-a-custom-resources>访问定制资源</h2><p>Kubernetes <a href=/zh-cn/docs/reference/using-api/client-libraries/>客户端库</a>可用来访问定制资源。
并非所有客户端库都支持定制资源。<strong>Go</strong> 和 <strong>Python</strong> 客户端库是支持的。</p><p>当你添加了新的定制资源后，可以用如下方式之一访问它们：</p><ul><li><code>kubectl</code></li><li>Kubernetes 动态客户端</li><li>你所编写的 REST 客户端</li><li>使用 <a href=https://github.com/kubernetes/code-generator>Kubernetes 客户端生成工具</a>所生成的客户端。
生成客户端的工作有些难度，不过某些项目可能会随着 CRD 或聚合 API 一起提供一个客户端。</li></ul><h2 id=接下来>接下来</h2><ul><li>了解如何<a href=/zh-cn/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>使用聚合层扩展 Kubernetes API</a></li><li>了解如何<a href=/zh-cn/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/>使用 CustomResourceDefinition 来扩展 Kubernetes API</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-1ea4977c0ebf97569bf54a477faa7fa5>3.2 - Kubernetes API 聚合层</h1><p>使用聚合层（Aggregation Layer），用户可以通过附加的 API 扩展 Kubernetes，
而不局限于 Kubernetes 核心 API 提供的功能。
这里的附加 API 可以是现成的解决方案，比如
<a href=https://github.com/kubernetes-sigs/metrics-server>metrics server</a>，
或者你自己开发的 API。</p><p>聚合层不同于
<a href=/zh-cn/docs/concepts/extend-kubernetes/api-extension/custom-resources/>定制资源（Custom Resources）</a>。
后者的目的是让 <a class=glossary-tooltip title='提供 Kubernetes API 服务的控制面组件。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label=kube-apiserver>kube-apiserver</a>
能够识别新的对象类别（Kind）。</p><h2 id=aggregation-layer>聚合层</h2><p>聚合层在 kube-apiserver 进程内运行。在扩展资源注册之前，聚合层不做任何事情。
要注册 API，你可以添加一个 <strong>APIService</strong> 对象，用它来 “申领” Kubernetes API 中的 URL 路径。
自此以后，聚合层将把发给该 API 路径的所有内容（例如 <code>/apis/myextension.mycompany.io/v1/…</code>）
转发到已注册的 APIService。</p><p>APIService 的最常见实现方式是在集群中某 Pod 内运行 <strong>扩展 API 服务器</strong>。
如果你在使用扩展 API 服务器来管理集群中的资源，该扩展 API 服务器（也被写成“extension-apiserver”）
一般需要和一个或多个<a class=glossary-tooltip title='控制器通过 API 服务器监控集群的公共状态，并致力于将当前状态转变为期望的状态。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/architecture/controller/ target=_blank aria-label=控制器>控制器</a>一起使用。
apiserver-builder 库同时提供构造扩展 API 服务器和控制器框架代码。</p><h3 id=response-latency>响应延迟</h3><p>扩展 API 服务器与 kube-apiserver 之间需要存在低延迟的网络连接。
发现请求需要在五秒钟或更短的时间内完成到 kube-apiserver 的往返。</p><p>如果你的扩展 API 服务器无法满足这一延迟要求，应考虑如何更改配置以满足需要。</p><h2 id=接下来>接下来</h2><ul><li>阅读<a href=/zh-cn/docs/tasks/extend-kubernetes/configure-aggregation-layer/>配置聚合层</a> 文档，
了解如何在自己的环境中启用聚合器。</li><li>接下来，了解<a href=/zh-cn/docs/tasks/extend-kubernetes/setup-extension-api-server/>安装扩展 API 服务器</a>，
开始使用聚合层。</li><li>从 API 参考资料中研究关于 <a href=/zh-cn/docs/reference/kubernetes-api/cluster-resources/api-service-v1/>APIService</a> 的内容。</li></ul><p>或者，学习如何<a href=/zh-cn/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/>使用 CustomResourceDefinition 扩展 Kubernetes API</a>。</p></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/zh-cn/docs/home/>主页</a>
<a class=text-white href=/zh-cn/blog/>博客</a>
<a class=text-white href=/zh-cn/training/>培训</a>
<a class=text-white href=/zh-cn/partners/>合作伙伴</a>
<a class=text-white href=/zh-cn/community/>社区</a>
<a class=text-white href=/zh-cn/case-studies/>案例分析</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 The Kubernetes 作者 | 文档发布基于 <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a> 授权许可</small><br><small class=text-white>Copyright &copy; 2023 Linux 基金会&reg;。保留所有权利。Linux 基金会已注册并使用商标。如需了解 Linux 基金会的商标列表，请访问<a href=https://www.linuxfoundation.org/trademark-usage class=light-text>商标使用页面</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>