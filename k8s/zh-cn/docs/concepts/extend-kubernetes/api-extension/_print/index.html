<!doctype html><html lang=zh-cn class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=en href=https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/><link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/concepts/extend-kubernetes/api-extension/><link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/concepts/extend-kubernetes/api-extension/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/concepts/extend-kubernetes/api-extension/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/concepts/extend-kubernetes/api-extension/><link rel=alternate hreflang=pt-br href=https://kubernetes.io/pt-br/docs/concepts/extend-kubernetes/api-extension/><link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/concepts/extend-kubernetes/api-extension/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/zh-cn/docs/concepts/extend-kubernetes/api-extension/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>扩展 Kubernetes API | Kubernetes</title><meta property="og:title" content="扩展 Kubernetes API"><meta property="og:description" content="生产级别的容器编排系统"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/zh-cn/docs/concepts/extend-kubernetes/api-extension/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="扩展 Kubernetes API"><meta itemprop=description content="生产级别的容器编排系统"><meta name=twitter:card content="summary"><meta name=twitter:title content="扩展 Kubernetes API"><meta name=twitter:description content="生产级别的容器编排系统"><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content><meta property="og:description" content><meta name=twitter:description content><meta property="og:url" content="https://kubernetes.io/zh-cn/docs/concepts/extend-kubernetes/api-extension/"><meta property="og:title" content="扩展 Kubernetes API"><meta name=twitter:title content="扩展 Kubernetes API"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/zh-cn/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/zh-cn/docs/>文档</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/zh-cn/blog/>Kubernetes 博客</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/zh-cn/training/>培训</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/zh-cn/partners/>合作伙伴</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/zh-cn/community/>社区</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/zh-cn/case-studies/>案例分析</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>版本列表</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/zh-cn/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/zh-cn/docs/concepts/extend-kubernetes/api-extension/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/zh-cn/docs/concepts/extend-kubernetes/api-extension/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/zh-cn/docs/concepts/extend-kubernetes/api-extension/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/zh-cn/docs/concepts/extend-kubernetes/api-extension/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/zh-cn/docs/concepts/extend-kubernetes/api-extension/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>中文 (Chinese)</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/docs/concepts/extend-kubernetes/api-extension/>English</a>
<a class=dropdown-item href=/ko/docs/concepts/extend-kubernetes/api-extension/>한국어 (Korean)</a>
<a class=dropdown-item href=/ja/docs/concepts/extend-kubernetes/api-extension/>日本語 (Japanese)</a>
<a class=dropdown-item href=/fr/docs/concepts/extend-kubernetes/api-extension/>Français (French)</a>
<a class=dropdown-item href=/es/docs/concepts/extend-kubernetes/api-extension/>Español (Spanish)</a>
<a class=dropdown-item href=/pt-br/docs/concepts/extend-kubernetes/api-extension/>Português (Portuguese)</a>
<a class=dropdown-item href=/id/docs/concepts/extend-kubernetes/api-extension/>Bahasa Indonesia</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>这是本节的多页打印视图。
<a href=# onclick="return print(),!1">点击此处打印</a>.</p><p><a href=/zh-cn/docs/concepts/extend-kubernetes/api-extension/>返回本页常规视图</a>.</p></div><h1 class=title>扩展 Kubernetes API</h1><ul><li>1: <a href=#pg-342388440304e19ce30c0f8ada1c77ce>定制资源</a></li><li>2: <a href=#pg-1ea4977c0ebf97569bf54a477faa7fa5>Kubernetes API 聚合层</a></li></ul><div class=content></div></div><div class=td-content><h1 id=pg-342388440304e19ce30c0f8ada1c77ce>1 - 定制资源</h1><p><strong>定制资源（Custom Resource）</strong> 是对 Kubernetes API 的扩展。
本页讨论何时向 Kubernetes 集群添加定制资源，何时使用独立的服务。
本页描述添加定制资源的两种方法以及怎样在二者之间做出抉择。</p><h2 id=定制资源>定制资源</h2><p><strong>资源（Resource）</strong> 是
<a href=/zh-cn/docs/concepts/overview/kubernetes-api/>Kubernetes API</a> 中的一个端点，
其中存储的是某个类别的
<a href=/zh-cn/docs/concepts/overview/working-with-objects/kubernetes-objects/>API 对象</a>的一个集合。
例如内置的 <strong>Pod</strong> 资源包含一组 Pod 对象。</p><p><strong>定制资源（Custom Resource）</strong> 是对 Kubernetes API 的扩展，不一定在默认的
Kubernetes 安装中就可用。
定制资源所代表的是对特定 Kubernetes 安装的一种定制。
不过，很多 Kubernetes 核心功能现在都用定制资源来实现，这使得 Kubernetes 更加模块化。</p><p>定制资源可以通过动态注册的方式在运行中的集群内或出现或消失，集群管理员可以独立于集群更新定制资源。
一旦某定制资源被安装，用户可以使用 <a class=glossary-tooltip title='kubectl 是用来和 Kubernetes 集群进行通信的命令行工具。' data-toggle=tooltip data-placement=top href=/docs/user-guide/kubectl-overview/ target=_blank aria-label=kubectl>kubectl</a> 来创建和访问其中的对象，
就像他们为 <strong>Pod</strong> 这种内置资源所做的一样。</p><h2 id=custom-controllers>定制控制器</h2><p>就定制资源本身而言，它只能用来存取结构化的数据。
当你将定制资源与<strong>定制控制器（Custom Controller）</strong> 结合时，
定制资源就能够提供真正的<strong>声明式 API（Declarative API）</strong>。</p><p>Kubernetes <a href=/zh-cn/docs/concepts/overview/kubernetes-api/>声明式 API</a> 强制对职权做了一次分离操作。
你声明所用资源的期望状态，而 Kubernetes 控制器使 Kubernetes 对象的当前状态与你所声明的期望状态保持同步。
声明式 API 的这种机制与命令式 API（你<strong>指示</strong>服务器要做什么，服务器就去做什么）形成鲜明对比。</p><p>你可以在一个运行中的集群上部署和更新定制控制器，这类操作与集群的生命周期无关。
定制控制器可以用于任何类别的资源，不过它们与定制资源结合起来时最为有效。
<a href=/zh-cn/docs/concepts/extend-kubernetes/operator/>Operator 模式</a>就是将定制资源与定制控制器相结合的。
你可以使用定制控制器来将特定于某应用的领域知识组织起来，以编码的形式构造对 Kubernetes API 的扩展。</p><h2 id=should-i-add-a-cr-to-my-k8s-cluster>我是否应该向我的 Kubernetes 集群添加定制资源？</h2><p>在创建新的 API 时，
请考虑是<a href=/zh-cn/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>将你的 API 与 Kubernetes 集群 API 聚合起来</a>，
还是让你的 API 独立运行。</p><table><thead><tr><th>考虑 API 聚合的情况</th><th>优选独立 API 的情况</th></tr></thead><tbody><tr><td>你的 API 是<a href=#declarative-apis>声明式的</a>。</td><td>你的 API 不符合<a href=#declarative-apis>声明式</a>模型。</td></tr><tr><td>你希望可以是使用 <code>kubectl</code> 来读写你的新资源类别。</td><td>不要求 <code>kubectl</code> 支持。</td></tr><tr><td>你希望在 Kubernetes UI （如仪表板）中和其他内置类别一起查看你的新资源类别。</td><td>不需要 Kubernetes UI 支持。</td></tr><tr><td>你在开发新的 API。</td><td>你已经有一个提供 API 服务的程序并且工作良好。</td></tr><tr><td>你有意愿取接受 Kubernetes 对 REST 资源路径所作的格式限制，例如 API 组和名字空间。（参阅 <a href=/zh-cn/docs/concepts/overview/kubernetes-api/>API 概述</a>）</td><td>你需要使用一些特殊的 REST 路径以便与已经定义的 REST API 保持兼容。</td></tr><tr><td>你的资源可以自然地界定为集群作用域或集群中某个名字空间作用域。</td><td>集群作用域或名字空间作用域这种二分法很不合适；你需要对资源路径的细节进行控制。</td></tr><tr><td>你希望复用 <a href=#common-features>Kubernetes API 支持特性</a>。</td><td>你不需要这类特性。</td></tr></tbody></table><h3 id=declarative-apis>声明式 API</h3><p>典型地，在声明式 API 中：</p><ul><li>你的 API 包含相对而言为数不多的、尺寸较小的对象（资源）。</li><li>对象定义了应用或者基础设施的配置信息。</li><li>对象更新操作频率较低。</li><li>通常需要人来读取或写入对象。</li><li>对象的主要操作是 CRUD 风格的（创建、读取、更新和删除）。</li><li>不需要跨对象的事务支持：API 对象代表的是期望状态而非确切实际状态。</li></ul><p>命令式 API（Imperative API）与声明式有所不同。
以下迹象表明你的 API 可能不是声明式的：</p><ul><li>客户端发出“做这个操作”的指令，之后在该操作结束时获得同步响应。</li><li>客户端发出“做这个操作”的指令，并获得一个操作 ID，之后需要检查一个 Operation（操作）
对象来判断请求是否成功完成。</li><li>你会将你的 API 类比为远程过程调用（Remote Procedure Call，RPC）。</li><li>直接存储大量数据；例如每个对象几 kB，或者存储上千个对象。</li><li>需要较高的访问带宽（长期保持每秒数十个请求）。</li><li>存储有应用来处理的最终用户数据（如图片、个人标识信息（PII）等）或者其他大规模数据。</li><li>在对象上执行的常规操作并非 CRUD 风格。</li><li>API 不太容易用对象来建模。</li><li>你决定使用操作 ID 或者操作对象来表现悬决的操作。</li></ul><h2 id=should-i-use-a-configmap-or-a-cr>我应该使用一个 ConfigMap 还是一个定制资源？</h2><p>如果满足以下条件之一，应该使用 ConfigMap：</p><ul><li>存在一个已有的、文档完备的配置文件格式约定，例如 <code>mysql.cnf</code> 或 <code>pom.xml</code>。</li><li>你希望将整个配置文件放到某 configMap 中的一个主键下面。</li><li>配置文件的主要用途是针对运行在集群中 Pod 内的程序，供后者依据文件数据配置自身行为。</li><li>文件的使用者期望以 Pod 内文件或者 Pod 内环境变量的形式来使用文件数据，
而不是通过 Kubernetes API。</li><li>你希望当文件被更新时通过类似 Deployment 之类的资源完成滚动更新操作。</li></ul><div class="alert alert-info note callout" role=alert><strong>说明：</strong> 请使用 <a class=glossary-tooltip title='Secret 用于存储敏感信息，如密码、 OAuth 令牌和 SSH 密钥。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/configuration/secret/ target=_blank aria-label=Secret>Secret</a> 来保存敏感数据。
Secret 类似于 configMap，但更为安全。</div><p>如果以下条件中大多数都被满足，你应该使用定制资源（CRD 或者 聚合 API）：</p><ul><li>你希望使用 Kubernetes 客户端库和 CLI 来创建和更改新的资源。</li><li>你希望 <code>kubectl</code> 能够直接支持你的资源；例如，<code>kubectl get my-object object-name</code>。</li><li>你希望构造新的自动化机制，监测新对象上的更新事件，并对其他对象执行 CRUD
操作，或者监测后者更新前者。</li><li>你希望编写自动化组件来处理对对象的更新。</li><li>你希望使用 Kubernetes API 对诸如 <code>.spec</code>、<code>.status</code> 和 <code>.metadata</code> 等字段的约定。</li><li>你希望对象是对一组受控资源的抽象，或者对其他资源的归纳提炼。</li></ul><h2 id=adding-custom-resources>添加定制资源</h2><p>Kubernetes 提供了两种方式供你向集群中添加定制资源：</p><ul><li>CRD 相对简单，创建 CRD 可以不必编程。</li><li><a href=/zh-cn/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>API 聚合</a>需要编程，
但支持对 API 行为进行更多的控制，例如数据如何存储以及在不同 API 版本间如何转换等。</li></ul><p>Kubernetes 提供这两种选项以满足不同用户的需求，这样就既不会牺牲易用性也不会牺牲灵活性。</p><p>聚合 API 指的是一些下位的 API 服务器，运行在主 API 服务器后面；主 API
服务器以代理的方式工作。这种组织形式称作
<a href=/zh-cn/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>API 聚合（API Aggregation，AA）</a> 。
对用户而言，看起来仅仅是 Kubernetes API 被扩展了。</p><p>CRD 允许用户创建新的资源类别同时又不必添加新的 API 服务器。
使用 CRD 时，你并不需要理解 API 聚合。</p><p>无论以哪种方式安装定制资源，新的资源都会被当做定制资源，以便与内置的
Kubernetes 资源（如 Pods）相区分。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>避免将定制资源用于存储应用、最终用户或监控数据：
将应用数据存储在 Kubernetes API 内的架构设计通常代表一种过于紧密耦合的设计。</p><p>在架构上，<a href=https://www.cncf.io/about/faq/#what-is-cloud-native>云原生</a>应用架构倾向于各组件之间的松散耦合。
如果部分工作负载需要支持服务来维持其日常运转，则这种支持服务应作为一个组件运行或作为一个外部服务来使用。
这样，工作负载的正常运转就不会依赖 Kubernetes API 了。</p></div><h2 id=customresourcedefinitions>CustomResourceDefinitions</h2><p><a href=/zh-cn/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/>CustomResourceDefinition</a>
API 资源允许你定义定制资源。
定义 CRD 对象的操作会使用你所设定的名字和模式定义（Schema）创建一个新的定制资源，
Kubernetes API 负责为你的定制资源提供存储和访问服务。
CRD 对象的名称必须是合法的
<a href=/zh-cn/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNS 子域名</a>。</p><p>CRD 使得你不必编写自己的 API 服务器来处理定制资源，不过其背后实现的通用性也意味着
你所获得的灵活性要比 <a href=#api-server-aggregation>API 服务器聚合</a>少很多。</p><p>关于如何注册新的定制资源、使用新资源类别的实例以及如何使用控制器来处理事件，
相关的例子可参见<a href=https://github.com/kubernetes/sample-controller>定制控制器示例</a>。</p><h2 id=api-server-aggregation>API 服务器聚合</h2><p>通常，Kubernetes API 中的每个资源都需要处理 REST 请求和管理对象持久性存储的代码。
Kubernetes API 主服务器能够处理诸如 <em>pods</em> 和 <em>services</em> 这些内置资源，也可以
按通用的方式通过 <a href=#customresourcedefinitions>CRD</a> 来处理定制资源。</p><p><a href=/zh-cn/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>聚合层（Aggregation Layer）</a>
使得你可以通过编写和部署你自己的 API 服务器来为定制资源提供特殊的实现。
主 API 服务器将针对你要处理的定制资源的请求全部委托给你自己的 API 服务器来处理，同时将这些资源
提供给其所有客户端。</p><h2 id=choosing-a-method-for-adding-cr>选择添加定制资源的方法</h2><p>CRD 更为易用；聚合 API 则更为灵活。请选择最符合你的需要的方法。</p><p>通常，如何存在以下情况，CRD 可能更合适：</p><ul><li>定制资源的字段不多；</li><li>你在组织内部使用该资源或者在一个小规模的开源项目中使用该资源，而不是在商业产品中使用。</li></ul><h3 id=compare-ease-of-use>比较易用性</h3><p>CRD 比聚合 API 更容易创建。</p><table><thead><tr><th>CRD</th><th>聚合 API</th></tr></thead><tbody><tr><td>无需编程。用户可选择任何语言来实现 CRD 控制器。</td><td>需要编程，并构建可执行文件和镜像。</td></tr><tr><td>无需额外运行服务；CRD 由 API 服务器处理。</td><td>需要额外创建服务，且该服务可能失效。</td></tr><tr><td>一旦 CRD 被创建，不需要持续提供支持。Kubernetes 主控节点升级过程中自动会带入缺陷修复。</td><td>可能需要周期性地从上游提取缺陷修复并更新聚合 API 服务器。</td></tr><tr><td>无需处理 API 的多个版本；例如，当你控制资源的客户端时，你可以更新它使之与 API 同步。</td><td>你需要处理 API 的多个版本；例如，在开发打算与很多人共享的扩展时。</td></tr></tbody></table><h3 id=advanced-features-and-flexibility>高级特性与灵活性</h3><p>聚合 API 可提供更多的高级 API 特性，也可对其他特性实行定制；例如，对存储层进行定制。</p><table><thead><tr><th>特性</th><th>描述</th><th>CRD</th><th>聚合 API</th></tr></thead><tbody><tr><td>合法性检查</td><td>帮助用户避免错误，允许你独立于客户端版本演化 API。这些特性对于由很多无法同时更新的客户端的场合。</td><td>可以。大多数验证可以使用 <a href=/zh-cn/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#validation>OpenAPI v3.0 合法性检查</a> 来设定。其他合法性检查操作可以通过添加<a href=/zh-cn/docs/reference/access-authn-authz/admission-controllers/#validatingadmissionwebhook-alpha-in-1-8-beta-in-1-9>合法性检查 Webhook</a>来实现。</td><td>可以，可执行任何合法性检查。</td></tr><tr><td>默认值设置</td><td>同上</td><td>可以。可通过 <a href=/zh-cn/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#defaulting>OpenAPI v3.0 合法性检查</a>的 <code>default</code> 关键词（自 1.17 正式发布）或<a href=/zh-cn/docs/reference/access-authn-authz/admission-controllers/#mutatingadmissionwebhook>更改性（Mutating）Webhook</a>来实现（不过从 etcd 中读取老的对象时不会执行这些 Webhook）。</td><td>可以。</td></tr><tr><td>多版本支持</td><td>允许通过两个 API 版本同时提供同一对象。可帮助简化类似字段更名这类 API 操作。如果你能控制客户端版本，这一特性将不再重要。</td><td><a href=/zh-cn/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definition-versioning>可以</a>。</td><td>可以。</td></tr><tr><td>定制存储</td><td>支持使用具有不同性能模式的存储（例如，要使用时间序列数据库而不是键值存储），或者因安全性原因对存储进行隔离（例如对敏感信息执行加密）。</td><td>不可以。</td><td>可以。</td></tr><tr><td>定制业务逻辑</td><td>在创建、读取、更新或删除对象时，执行任意的检查或操作。</td><td>可以。要使用 <a href=/zh-cn/docs/reference/access-authn-authz/extensible-admission-controllers/#admission-webhooks>Webhook</a>。</td><td>可以。</td></tr><tr><td>支持 scale 子资源</td><td>允许 HorizontalPodAutoscaler 和 PodDisruptionBudget 这类子系统与你的新资源交互。</td><td><a href=/zh-cn/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#scale-subresource>可以</a>。</td><td>可以。</td></tr><tr><td>支持 status 子资源</td><td>允许在用户写入 spec 部分而控制器写入 status 部分时执行细粒度的访问控制。允许在对定制资源的数据进行更改时增加对象的代际（Generation）；这需要资源对 spec 和 status 部分有明确划分。</td><td><a href=/zh-cn/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#status-subresource>可以</a>。</td><td>可以。</td></tr><tr><td>其他子资源</td><td>添加 CRUD 之外的操作，例如 "logs" 或 "exec"。</td><td>不可以。</td><td>可以。</td></tr><tr><td>strategic-merge-patch</td><td>新的端点要支持标记了 <code>Content-Type: application/strategic-merge-patch+json</code> 的 PATCH 操作。对于更新既可在本地更改也可在服务器端更改的对象而言是有用的。要了解更多信息，可参见<a href=/zh-cn/docs/tasks/manage-kubernetes-objects/update-api-object-kubectl-patch/>使用 <code>kubectl patch</code> 来更新 API 对象</a>。</td><td>不可以。</td><td>可以。</td></tr><tr><td>支持协议缓冲区</td><td>新的资源要支持想要使用协议缓冲区（Protocol Buffer）的客户端。</td><td>不可以。</td><td>可以。</td></tr><tr><td>OpenAPI Schema</td><td>是否存在新资源类别的 OpenAPI（Swagger）Schema 可供动态从服务器上读取？是否存在机制确保只能设置被允许的字段以避免用户犯字段拼写错误？是否实施了字段类型检查（换言之，不允许在 <code>string</code> 字段设置 <code>int</code> 值）？</td><td>可以，依据 <a href=/zh-cn/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#validation>OpenAPI v3.0 合法性检查</a> 模式（1.16 中进入正式发布状态）。</td><td>可以。</td></tr></tbody></table><h3 id=common-features>公共特性</h3><p>与在 Kubernetes 平台之外实现定制资源相比，
无论是通过 CRD 还是通过聚合 API 来创建定制资源，你都会获得很多 API 特性：</p><table><thead><tr><th>功能特性</th><th>具体含义</th></tr></thead><tbody><tr><td>CRUD</td><td>新的端点支持通过 HTTP 和 <code>kubectl</code> 发起的 CRUD 基本操作</td></tr><tr><td>监测（Watch）</td><td>新的端点支持通过 HTTP 发起的 Kubernetes Watch 操作</td></tr><tr><td>发现（Discovery）</td><td>类似 <code>kubectl</code> 和仪表盘（Dashboard）这类客户端能够自动提供列举、显示、在字段级编辑你的资源的操作</td></tr><tr><td>json-patch</td><td>新的端点支持带 <code>Content-Type: application/json-patch+json</code> 的 PATCH 操作</td></tr><tr><td>merge-patch</td><td>新的端点支持带 <code>Content-Type: application/merge-patch+json</code> 的 PATCH 操作</td></tr><tr><td>HTTPS</td><td>新的端点使用 HTTPS</td></tr><tr><td>内置身份认证</td><td>对扩展的访问会使用核心 API 服务器（聚合层）来执行身份认证操作</td></tr><tr><td>内置鉴权授权</td><td>对扩展的访问可以复用核心 API 服务器所使用的鉴权授权机制；例如，RBAC</td></tr><tr><td>Finalizers</td><td>在外部清除工作结束之前阻止扩展资源被删除</td></tr><tr><td>准入 Webhooks</td><td>在创建、更新和删除操作中对扩展资源设置默认值和执行合法性检查</td></tr><tr><td>UI/CLI 展示</td><td><code>kubectl</code> 和仪表盘（Dashboard）可以显示扩展资源</td></tr><tr><td>区分未设置值和空值</td><td>客户端能够区分哪些字段是未设置的，哪些字段的值是被显式设置为零值的。</td></tr><tr><td>生成客户端库</td><td>Kubernetes 提供通用的客户端库，以及用来生成特定类别客户端库的工具</td></tr><tr><td>标签和注解</td><td>提供涵盖所有对象的公共元数据结构，且工具知晓如何编辑核心资源和定制资源的这些元数据</td></tr></tbody></table><h2 id=preparing-to-install-a-cr>准备安装定制资源</h2><p>在向你的集群添加定制资源之前，有些事情需要搞清楚。</p><h3 id=third-party-code-and-new-points-of-failure>第三方代码和新的失效点的问题</h3><p>尽管添加新的 CRD 不会自动带来新的失效点（Point of
Failure），例如导致第三方代码被在 API 服务器上运行，
类似 Helm Charts 这种软件包或者其他安装包通常在提供 CRD
的同时还包含带有第三方代码的 Deployment，负责实现新的定制资源的业务逻辑。</p><p>安装聚合 API 服务器时，也总会牵涉到运行一个新的 Deployment。</p><h3 id=storage>存储</h3><p>定制资源和 ConfigMap 一样也会消耗存储空间。创建过多的定制资源可能会导致
API 服务器上的存储空间超载。</p><p>聚合 API 服务器可以使用主 API 服务器相同的存储。如果是这样，你也要注意此警告。</p><h3 id=authentication-authorization-and-auditing>身份认证、鉴权授权以及审计</h3><p>CRD 通常与 API 服务器上的内置资源一样使用相同的身份认证、鉴权授权和审计日志机制。</p><p>如果你使用 RBAC 来执行鉴权授权，大多数 RBAC 角色都不会授权对新资源的访问
（除了 cluster-admin 角色以及使用通配符规则创建的其他角色）。
你要显式地为新资源的访问授权。CRD 和聚合 API 通常在交付时会包含针对所添加的类别的新的角色定义。</p><p>聚合 API 服务器可能会使用主 API 服务器相同的身份认证、鉴权授权和审计机制，也可能不会。</p><h2 id=accessing-a-custom-resources>访问定制资源</h2><p>Kubernetes <a href=/zh-cn/docs/reference/using-api/client-libraries/>客户端库</a>可用来访问定制资源。
并非所有客户端库都支持定制资源。<strong>Go</strong> 和 <strong>Python</strong> 客户端库是支持的。</p><p>当你添加了新的定制资源后，可以用如下方式之一访问它们：</p><ul><li><code>kubectl</code></li><li>Kubernetes 动态客户端</li><li>你所编写的 REST 客户端</li><li>使用 <a href=https://github.com/kubernetes/code-generator>Kubernetes 客户端生成工具</a>所生成的客户端。
生成客户端的工作有些难度，不过某些项目可能会随着 CRD 或聚合 API 一起提供一个客户端。</li></ul><h2 id=接下来>接下来</h2><ul><li>了解如何<a href=/zh-cn/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>使用聚合层扩展 Kubernetes API</a></li><li>了解如何<a href=/zh-cn/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/>使用 CustomResourceDefinition 来扩展 Kubernetes API</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-1ea4977c0ebf97569bf54a477faa7fa5>2 - Kubernetes API 聚合层</h1><p>使用聚合层（Aggregation Layer），用户可以通过附加的 API 扩展 Kubernetes，
而不局限于 Kubernetes 核心 API 提供的功能。
这里的附加 API 可以是现成的解决方案，比如
<a href=https://github.com/kubernetes-sigs/metrics-server>metrics server</a>，
或者你自己开发的 API。</p><p>聚合层不同于
<a href=/zh-cn/docs/concepts/extend-kubernetes/api-extension/custom-resources/>定制资源（Custom Resources）</a>。
后者的目的是让 <a class=glossary-tooltip title='提供 Kubernetes API 服务的控制面组件。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label=kube-apiserver>kube-apiserver</a>
能够识别新的对象类别（Kind）。</p><h2 id=aggregation-layer>聚合层</h2><p>聚合层在 kube-apiserver 进程内运行。在扩展资源注册之前，聚合层不做任何事情。
要注册 API，你可以添加一个 <strong>APIService</strong> 对象，用它来 “申领” Kubernetes API 中的 URL 路径。
自此以后，聚合层将把发给该 API 路径的所有内容（例如 <code>/apis/myextension.mycompany.io/v1/…</code>）
转发到已注册的 APIService。</p><p>APIService 的最常见实现方式是在集群中某 Pod 内运行 <strong>扩展 API 服务器</strong>。
如果你在使用扩展 API 服务器来管理集群中的资源，该扩展 API 服务器（也被写成“extension-apiserver”）
一般需要和一个或多个<a class=glossary-tooltip title='控制器通过 API 服务器监控集群的公共状态，并致力于将当前状态转变为期望的状态。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/architecture/controller/ target=_blank aria-label=控制器>控制器</a>一起使用。
apiserver-builder 库同时提供构造扩展 API 服务器和控制器框架代码。</p><h3 id=response-latency>响应延迟</h3><p>扩展 API 服务器与 kube-apiserver 之间需要存在低延迟的网络连接。
发现请求需要在五秒钟或更短的时间内完成到 kube-apiserver 的往返。</p><p>如果你的扩展 API 服务器无法满足这一延迟要求，应考虑如何更改配置以满足需要。</p><h2 id=接下来>接下来</h2><ul><li>阅读<a href=/zh-cn/docs/tasks/extend-kubernetes/configure-aggregation-layer/>配置聚合层</a> 文档，
了解如何在自己的环境中启用聚合器。</li><li>接下来，了解<a href=/zh-cn/docs/tasks/extend-kubernetes/setup-extension-api-server/>安装扩展 API 服务器</a>，
开始使用聚合层。</li><li>从 API 参考资料中研究关于 <a href=/zh-cn/docs/reference/kubernetes-api/cluster-resources/api-service-v1/>APIService</a> 的内容。</li></ul><p>或者，学习如何<a href=/zh-cn/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/>使用 CustomResourceDefinition 扩展 Kubernetes API</a>。</p></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/zh-cn/docs/home/>主页</a>
<a class=text-white href=/zh-cn/blog/>博客</a>
<a class=text-white href=/zh-cn/training/>培训</a>
<a class=text-white href=/zh-cn/partners/>合作伙伴</a>
<a class=text-white href=/zh-cn/community/>社区</a>
<a class=text-white href=/zh-cn/case-studies/>案例分析</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 The Kubernetes 作者 | 文档发布基于 <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a> 授权许可</small><br><small class=text-white>Copyright &copy; 2023 Linux 基金会&reg;。保留所有权利。Linux 基金会已注册并使用商标。如需了解 Linux 基金会的商标列表，请访问<a href=https://www.linuxfoundation.org/trademark-usage class=light-text>商标使用页面</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>