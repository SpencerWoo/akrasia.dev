<!doctype html><html lang=zh-cn class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=en href=https://kubernetes.io/docs/concepts/workloads/pods/><link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/concepts/workloads/pods/><link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/concepts/workloads/pods/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/concepts/workloads/pods/><link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/concepts/workloads/pods/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/concepts/workloads/pods/><link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/concepts/workloads/pods/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>Pod | Kubernetes</title><meta property="og:title" content="Pod"><meta property="og:description" content="生产级别的容器编排系统"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="Pod"><meta itemprop=description content="生产级别的容器编排系统"><meta name=twitter:card content="summary"><meta name=twitter:title content="Pod"><meta name=twitter:description content="生产级别的容器编排系统"><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content="Pod 是可以在 Kubernetes 中创建和管理的、最小的可部署的计算单元。
Pod（就像在鲸鱼荚或者豌豆荚中）是一组（一个或多个） 容器； 这些容器共享存储、网络、以及怎样运行这些容器的声明。 Pod 中的内容总是并置（colocated）的并且一同调度，在共享的上下文中运行。 Pod 所建模的是特定于应用的 “逻辑主机”，其中包含一个或多个应用容器， 这些容器相对紧密地耦合在一起。 在非云环境中，在相同的物理机或虚拟机上运行的应用类似于在同一逻辑主机上运行的云应用。
除了应用容器，Pod 还可以包含在 Pod 启动期间运行的 Init 容器。 你也可以在集群支持临时性容器的情况下， 为调试的目的注入临时性容器。
什么是 Pod？ 说明： 除了 Docker 之外，Kubernetes 支持很多其他容器运行时， Docker 是最有名的运行时， 使用 Docker 的术语来描述 Pod 会很有帮助。 Pod 的共享上下文包括一组 Linux 名字空间、控制组（cgroup）和可能一些其他的隔离方面， 即用来隔离容器的技术。 在 Pod 的上下文中，每个独立的应用可能会进一步实施隔离。
Pod 类似于共享名字空间并共享文件系统卷的一组容器。
使用 Pod 下面是一个 Pod 示例，它由一个运行镜像 nginx:1.14.2 的容器组成。
pods/simple-pod.yaml apiVersion: v1 kind: Pod metadata: name: nginx spec: containers: - name: nginx image: nginx:1.14.2 ports: - containerPort: 80 要创建上面显示的 Pod，请运行以下命令："><meta property="og:description" content="Pod 是可以在 Kubernetes 中创建和管理的、最小的可部署的计算单元。
Pod（就像在鲸鱼荚或者豌豆荚中）是一组（一个或多个） 容器； 这些容器共享存储、网络、以及怎样运行这些容器的声明。 Pod 中的内容总是并置（colocated）的并且一同调度，在共享的上下文中运行。 Pod 所建模的是特定于应用的 “逻辑主机”，其中包含一个或多个应用容器， 这些容器相对紧密地耦合在一起。 在非云环境中，在相同的物理机或虚拟机上运行的应用类似于在同一逻辑主机上运行的云应用。
除了应用容器，Pod 还可以包含在 Pod 启动期间运行的 Init 容器。 你也可以在集群支持临时性容器的情况下， 为调试的目的注入临时性容器。
什么是 Pod？ 说明： 除了 Docker 之外，Kubernetes 支持很多其他容器运行时， Docker 是最有名的运行时， 使用 Docker 的术语来描述 Pod 会很有帮助。 Pod 的共享上下文包括一组 Linux 名字空间、控制组（cgroup）和可能一些其他的隔离方面， 即用来隔离容器的技术。 在 Pod 的上下文中，每个独立的应用可能会进一步实施隔离。
Pod 类似于共享名字空间并共享文件系统卷的一组容器。
使用 Pod 下面是一个 Pod 示例，它由一个运行镜像 nginx:1.14.2 的容器组成。
pods/simple-pod.yaml apiVersion: v1 kind: Pod metadata: name: nginx spec: containers: - name: nginx image: nginx:1.14.2 ports: - containerPort: 80 要创建上面显示的 Pod，请运行以下命令："><meta name=twitter:description content="Pod 是可以在 Kubernetes 中创建和管理的、最小的可部署的计算单元。
Pod（就像在鲸鱼荚或者豌豆荚中）是一组（一个或多个） 容器； 这些容器共享存储、网络、以及怎样运行这些容器的声明。 Pod 中的内容总是并置（colocated）的并且一同调度，在共享的上下文中运行。 Pod 所建模的是特定于应用的 “逻辑主机”，其中包含一个或多个应用容器， 这些容器相对紧密地耦合在一起。 在非云环境中，在相同的物理机或虚拟机上运行的应用类似于在同一逻辑主机上运行的云应用。
除了应用容器，Pod 还可以包含在 Pod 启动期间运行的 Init 容器。 你也可以在集群支持临时性容器的情况下， 为调试的目的注入临时性容器。
什么是 Pod？ 说明： 除了 Docker 之外，Kubernetes 支持很多其他容器运行时， Docker 是最有名的运行时， 使用 Docker 的术语来描述 Pod 会很有帮助。 Pod 的共享上下文包括一组 Linux 名字空间、控制组（cgroup）和可能一些其他的隔离方面， 即用来隔离容器的技术。 在 Pod 的上下文中，每个独立的应用可能会进一步实施隔离。
Pod 类似于共享名字空间并共享文件系统卷的一组容器。
使用 Pod 下面是一个 Pod 示例，它由一个运行镜像 nginx:1.14.2 的容器组成。
pods/simple-pod.yaml apiVersion: v1 kind: Pod metadata: name: nginx spec: containers: - name: nginx image: nginx:1.14.2 ports: - containerPort: 80 要创建上面显示的 Pod，请运行以下命令："><meta property="og:url" content="https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/"><meta property="og:title" content="Pod"><meta name=twitter:title content="Pod"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/zh-cn/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/zh-cn/docs/>文档</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/zh-cn/blog/>Kubernetes 博客</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/zh-cn/training/>培训</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/zh-cn/partners/>合作伙伴</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/zh-cn/community/>社区</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/zh-cn/case-studies/>案例分析</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>版本列表</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/zh-cn/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/zh-cn/docs/concepts/workloads/pods/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/zh-cn/docs/concepts/workloads/pods/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/zh-cn/docs/concepts/workloads/pods/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/zh-cn/docs/concepts/workloads/pods/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/zh-cn/docs/concepts/workloads/pods/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>中文 (Chinese)</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/docs/concepts/workloads/pods/>English</a>
<a class=dropdown-item href=/ko/docs/concepts/workloads/pods/>한국어 (Korean)</a>
<a class=dropdown-item href=/ja/docs/concepts/workloads/pods/>日本語 (Japanese)</a>
<a class=dropdown-item href=/fr/docs/concepts/workloads/pods/>Français (French)</a>
<a class=dropdown-item href=/de/docs/concepts/workloads/pods/>Deutsch (German)</a>
<a class=dropdown-item href=/es/docs/concepts/workloads/pods/>Español (Spanish)</a>
<a class=dropdown-item href=/id/docs/concepts/workloads/pods/>Bahasa Indonesia</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>这是本节的多页打印视图。
<a href=# onclick="return print(),!1">点击此处打印</a>.</p><p><a href=/zh-cn/docs/concepts/workloads/pods/>返回本页常规视图</a>.</p></div><h1 class=title>Pod</h1><ul><li>1: <a href=#pg-c3c2b9cf30915ec9d46c147201da3332>Pod 的生命周期</a></li><li>2: <a href=#pg-1ccbd4eeded6ab138d98b59175bd557e>Init 容器</a></li><li>3: <a href=#pg-4aaf43c715cd764bc8ed4436f3537e68>干扰（Disruptions）</a></li><li>4: <a href=#pg-53a1005011e1bda2ce81819aad7c8b32>临时容器</a></li><li>5: <a href=#pg-420713565efe2f940e277f6b4824ad9a>Downward API</a></li></ul><div class=content><p><strong>Pod</strong> 是可以在 Kubernetes 中创建和管理的、最小的可部署的计算单元。</p><p><strong>Pod</strong>（就像在鲸鱼荚或者豌豆荚中）是一组（一个或多个）
<a class=glossary-tooltip title=容器是可移植、可执行的轻量级的镜像，镜像中包含软件及其相关依赖。 data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/overview/what-is-kubernetes/#why-containers target=_blank aria-label=容器>容器</a>；
这些容器共享存储、网络、以及怎样运行这些容器的声明。
Pod 中的内容总是并置（colocated）的并且一同调度，在共享的上下文中运行。
Pod 所建模的是特定于应用的 “逻辑主机”，其中包含一个或多个应用容器，
这些容器相对紧密地耦合在一起。
在非云环境中，在相同的物理机或虚拟机上运行的应用类似于在同一逻辑主机上运行的云应用。</p><p>除了应用容器，Pod 还可以包含在 Pod 启动期间运行的
<a href=/zh-cn/docs/concepts/workloads/pods/init-containers/>Init 容器</a>。
你也可以在集群支持<a href=/zh-cn/docs/concepts/workloads/pods/ephemeral-containers/>临时性容器</a>的情况下，
为调试的目的注入临时性容器。</p><h2 id=what-is-a-pod>什么是 Pod？</h2><div class="alert alert-info note callout" role=alert><strong>说明：</strong> 除了 Docker 之外，Kubernetes 支持很多其他<a class=glossary-tooltip title=容器运行时是负责运行容器的软件。 data-toggle=tooltip data-placement=top href=/zh-cn/docs/setup/production-environment/container-runtimes target=_blank aria-label=容器运行时>容器运行时</a>，
<a href=https://www.docker.com/>Docker</a> 是最有名的运行时，
使用 Docker 的术语来描述 Pod 会很有帮助。</div><p>Pod 的共享上下文包括一组 Linux 名字空间、控制组（cgroup）和可能一些其他的隔离方面，
即用来隔离<a class=glossary-tooltip title=容器是可移植、可执行的轻量级的镜像，镜像中包含软件及其相关依赖。 data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/overview/what-is-kubernetes/#why-containers target=_blank aria-label=容器>容器</a>的技术。
在 Pod 的上下文中，每个独立的应用可能会进一步实施隔离。</p><p>Pod 类似于共享名字空间并共享文件系统卷的一组容器。</p><h2 id=using-pods>使用 Pod</h2><p>下面是一个 Pod 示例，它由一个运行镜像 <code>nginx:1.14.2</code> 的容器组成。</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/pods/simple-pod.yaml download=pods/simple-pod.yaml><code>pods/simple-pod.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("pods-simple-pod-yaml")' title="Copy pods/simple-pod.yaml to clipboard"></img></div><div class=includecode id=pods-simple-pod-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>要创建上面显示的 Pod，请运行以下命令：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/pods/simple-pod.yaml
</span></span></code></pre></div><p>Pod 通常不是直接创建的，而是使用工作负载资源创建的。
有关如何将 Pod 用于工作负载资源的更多信息，请参阅<a href=#working-with-pods>使用 Pod</a>。</p><h3 id=workload-resources-for-managing-pods>用于管理 pod 的工作负载资源</h3><p>通常你不需要直接创建 Pod，甚至单实例 Pod。
相反，你会使用诸如
<a class=glossary-tooltip title=管理集群上的多副本应用。 data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Deployment>Deployment</a> 或
<a class=glossary-tooltip title='Job 是需要运行完成的确定性的或批量的任务。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/workloads/controllers/job/ target=_blank aria-label=Job>Job</a> 这类工作负载资源来创建 Pod。
如果 Pod 需要跟踪状态，可以考虑
<a class=glossary-tooltip title='StatefulSet 用来管理某 Pod 集合的部署和扩缩，并为这些 Pod 提供持久存储和持久标识符。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/workloads/controllers/statefulset/ target=_blank aria-label=StatefulSet>StatefulSet</a> 资源。</p><p>Kubernetes 集群中的 Pod 主要有两种用法：</p><ul><li><p><strong>运行单个容器的 Pod</strong>。"每个 Pod 一个容器" 模型是最常见的 Kubernetes 用例；
在这种情况下，可以将 Pod 看作单个容器的包装器，并且 Kubernetes 直接管理 Pod，而不是容器。</p></li><li><p><strong>运行多个协同工作的容器的 Pod</strong>。
Pod 可能封装由多个紧密耦合且需要共享资源的共处容器组成的应用程序。
这些位于同一位置的容器可能形成单个内聚的服务单元 —— 一个容器将文件从共享卷提供给公众，
而另一个单独的 “边车”（sidecar）容器则刷新或更新这些文件。
Pod 将这些容器和存储资源打包为一个可管理的实体。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>将多个并置、同管的容器组织到一个 Pod 中是一种相对高级的使用场景。
只有在一些场景中，容器之间紧密关联时你才应该使用这种模式。</div></li></ul><p>每个 Pod 都旨在运行给定应用程序的单个实例。如果希望横向扩展应用程序
（例如，运行多个实例以提供更多的资源），则应该使用多个 Pod，每个实例使用一个 Pod。
在 Kubernetes 中，这通常被称为<strong>副本（Replication）</strong>。
通常使用一种工作负载资源及其<a class=glossary-tooltip title='控制器通过 API 服务器监控集群的公共状态，并致力于将当前状态转变为期望的状态。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/architecture/controller/ target=_blank aria-label=控制器>控制器</a>来创建和管理一组 Pod 副本。</p><p>参见 <a href=#pods-and-controllers>Pod 和控制器</a>以了解 Kubernetes
如何使用工作负载资源及其控制器以实现应用的扩缩和自动修复。</p><h3 id=how-pods-manage-multiple-containers>Pod 怎样管理多个容器</h3><p>Pod 被设计成支持形成内聚服务单元的多个协作过程（形式为容器）。
Pod 中的容器被自动安排到集群中的同一物理机或虚拟机上，并可以一起进行调度。
容器之间可以共享资源和依赖、彼此通信、协调何时以及何种方式终止自身。</p><p>例如，你可能有一个容器，为共享卷中的文件提供 Web 服务器支持，以及一个单独的
"边车 (sidercar)" 容器负责从远端更新这些文件，如下图所示：</p><figure class=diagram-medium><img src=/images/docs/pod.svg alt="Pod 创建示意图"></figure><p>有些 Pod 具有 <a class=glossary-tooltip title='应用容器运行前必须先运行完成的一个或多个 Init 容器（Init Container）。' data-toggle=tooltip data-placement=top href='/zh-cn/docs/reference/glossary/?all=true#term-init-container' target=_blank aria-label='Init 容器'>Init 容器</a>和
<a class=glossary-tooltip title='用于运行部分工作负载的容器。与 Init 容器比较而言。' data-toggle=tooltip data-placement=top href='/zh-cn/docs/reference/glossary/?all=true#term-app-container' target=_blank aria-label=应用容器>应用容器</a>。
Init 容器会在启动应用容器之前运行并完成。</p><p>Pod 天生地为其成员容器提供了两种共享资源：<a href=#pod-networking>网络</a>和<a href=#pod-storage>存储</a>。</p><h2 id=working-with-pods>使用 Pod</h2><p>你很少在 Kubernetes 中直接创建一个个的 Pod，甚至是单实例（Singleton）的 Pod。
这是因为 Pod 被设计成了相对临时性的、用后即抛的一次性实体。
当 Pod 由你或者间接地由<a class=glossary-tooltip title='控制器通过 API 服务器监控集群的公共状态，并致力于将当前状态转变为期望的状态。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/architecture/controller/ target=_blank aria-label=控制器>控制器</a>
创建时，它被调度在集群中的<a class=glossary-tooltip title='Kubernetes 中的工作机器称作节点。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/architecture/nodes/ target=_blank aria-label=节点>节点</a>上运行。
Pod 会保持在该节点上运行，直到 Pod 结束执行、Pod 对象被删除、Pod 因资源不足而被<strong>驱逐</strong>或者节点失效为止。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong> 重启 Pod 中的容器不应与重启 Pod 混淆。
Pod 不是进程，而是容器运行的环境。
在被删除之前，Pod 会一直存在。</div><p>当你为 Pod 对象创建清单时，要确保所指定的 Pod 名称是合法的
<a href=/zh-cn/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNS 子域名</a>。</p><h3 id=pod-os>Pod 操作系统</h3><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.25 [stable]</code></div><p>你应该将 <code>.spec.os.name</code> 字段设置为 <code>windows</code> 或 <code>linux</code> 以表示你希望 Pod 运行在哪个操作系统之上。
这两个是 Kubernetes 目前支持的操作系统。将来，这个列表可能会被扩充。</p><p>在 Kubernetes v1.25 中，为此字段设置的值对 Pod
的<a class=glossary-tooltip title='控制平面组件，负责监视新创建的、未指定运行节点的 Pod，选择节点让 Pod 在上面运行。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/reference/command-line-tools-reference/kube-scheduler/ target=_blank aria-label=调度>调度</a>没有影响。
设置 <code>. spec.os.name</code> 有助于确定性地标识 Pod 的操作系统并用于验证。
如果你指定的 Pod 操作系统与运行 kubelet 所在节点的操作系统不同，
那么 kubelet 将会拒绝运行该 Pod。
<a href=/zh-cn/docs/concepts/security/pod-security-standards/>Pod 安全标准</a>也使用这个字段来避免强制执行与该操作系统无关的策略。</p><h3 id=pods-and-controllers>Pod 和控制器</h3><p>你可以使用工作负载资源来创建和管理多个 Pod。
资源的控制器能够处理副本的管理、上线，并在 Pod 失效时提供自愈能力。
例如，如果一个节点失败，控制器注意到该节点上的 Pod 已经停止工作，
就可以创建替换性的 Pod。调度器会将替身 Pod 调度到一个健康的节点执行。</p><p>下面是一些管理一个或者多个 Pod 的工作负载资源的示例：</p><ul><li><a class=glossary-tooltip title=管理集群上的多副本应用。 data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Deployment>Deployment</a></li><li><a class=glossary-tooltip title='StatefulSet 用来管理某 Pod 集合的部署和扩缩，并为这些 Pod 提供持久存储和持久标识符。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/workloads/controllers/statefulset/ target=_blank aria-label=StatefulSet>StatefulSet</a></li><li><a class=glossary-tooltip title='确保 Pod 的副本在集群中的一组节点上运行。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/workloads/controllers/daemonset/ target=_blank aria-label=DaemonSet>DaemonSet</a></li></ul><h3 id=pod-templates>Pod 模板</h3><p><a class=glossary-tooltip title='工作负载是在 Kubernetes 上运行的应用程序。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/workloads/ target=_blank aria-label=工作负载>工作负载</a>资源的控制器通常使用
<strong>Pod 模板（Pod Template）</strong> 来替你创建 Pod 并管理它们。</p><p>Pod 模板是包含在工作负载对象中的规范，用来创建 Pod。这类负载资源包括
<a href=/zh-cn/docs/concepts/workloads/controllers/deployment/>Deployment</a>、
<a href=/zh-cn/docs/concepts/workloads/controllers/job/>Job</a> 和
<a href=/zh-cn/docs/concepts/workloads/controllers/daemonset/>DaemonSet</a> 等。</p><p>工作负载的控制器会使用负载对象中的 <code>PodTemplate</code> 来生成实际的 Pod。
<code>PodTemplate</code> 是你用来运行应用时指定的负载资源的目标状态的一部分。</p><p>下面的示例是一个简单的 Job 的清单，其中的 <code>template</code> 指示启动一个容器。
该 Pod 中的容器会打印一条消息之后暂停。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>batch/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Job<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 这里是 Pod 模板</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>hello<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#39;sh&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;-c&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;echo &#34;Hello, Kubernetes!&#34; &amp;&amp; sleep 3600&#39;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>restartPolicy</span>:<span style=color:#bbb> </span>OnFailure<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 以上为 Pod 模板</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>修改 Pod 模板或者切换到新的 Pod 模板都不会对已经存在的 Pod 直接起作用。
如果改变工作负载资源的 Pod 模板，工作负载资源需要使用更新后的模板来创建 Pod，
并使用新创建的 Pod 替换旧的 Pod。</p><p>例如，StatefulSet 控制器针对每个 StatefulSet 对象确保运行中的 Pod 与当前的 Pod
模板匹配。如果编辑 StatefulSet 以更改其 Pod 模板，
StatefulSet 将开始基于更新后的模板创建新的 Pod。</p><p>每个工作负载资源都实现了自己的规则，用来处理对 Pod 模板的更新。
如果你想了解更多关于 StatefulSet 的具体信息，
请阅读 StatefulSet 基础教程中的<a href=/zh-cn/docs/tutorials/stateful-application/basic-stateful-set/#updating-statefulsets>更新策略</a>。</p><p>在节点上，<a class=glossary-tooltip title='一个在集群中每个节点上运行的代理。它保证容器都运行在 Pod 中。' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a> 并不直接监测或管理与
Pod 模板相关的细节或模板的更新，这些细节都被抽象出来。
这种抽象和关注点分离简化了整个系统的语义，
并且使得用户可以在不改变现有代码的前提下就能扩展集群的行为。</p><h2 id=pod-update-and-replacement>Pod 更新与替换</h2><p>正如前面章节所述，当某工作负载的 Pod 模板被改变时，
控制器会基于更新的模板创建新的 Pod 对象而不是对现有 Pod 执行更新或者修补操作。</p><p>Kubernetes 并不禁止你直接管理 Pod。对运行中的 Pod 的某些字段执行就地更新操作还是可能的。不过，类似
<a href=/docs/reference/generated/kubernetes-api/v1.25/#patch-pod-v1-core><code>patch</code></a> 和
<a href=/docs/reference/generated/kubernetes-api/v1.25/#replace-pod-v1-core><code>replace</code></a>
这类更新操作有一些限制：</p><ul><li><p>Pod 的绝大多数元数据都是不可变的。例如，你不可以改变其 <code>namespace</code>、<code>name</code>、
<code>uid</code> 或者 <code>creationTimestamp</code> 字段；<code>generation</code> 字段是比较特别的，
如果更新该字段，只能增加字段取值而不能减少。</p></li><li><p>如果 <code>metadata.deletionTimestamp</code> 已经被设置，则不可以向 <code>metadata.finalizers</code>
列表中添加新的条目。</p></li><li><p>Pod 更新不可以改变除 <code>spec.containers[*].image</code>、<code>spec.initContainers[*].image</code>、
<code>spec.activeDeadlineSeconds</code> 或 <code>spec.tolerations</code> 之外的字段。
对于 <code>spec.tolerations</code>，你只被允许添加新的条目到其中。</p></li><li><p>在更新 <code>spec.activeDeadlineSeconds</code> 字段时，以下两种更新操作是被允许的：</p><ol><li>如果该字段尚未设置，可以将其设置为一个正数；</li><li>如果该字段已经设置为一个正数，可以将其设置为一个更小的、非负的整数。</li></ol></li></ul><h3 id=resource-sharing-and-communication>资源共享和通信</h3><p>Pod 使它的成员容器间能够进行数据共享和通信。</p><h3 id=pod-storage>Pod 中的存储</h3><p>一个 Pod 可以设置一组共享的存储<a class=glossary-tooltip title='包含可被 Pod 中容器访问的数据的目录。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/storage/volumes/ target=_blank aria-label=卷>卷</a>。
Pod 中的所有容器都可以访问该共享卷，从而允许这些容器共享数据。
卷还允许 Pod 中的持久数据保留下来，即使其中的容器需要重新启动。
有关 Kubernetes 如何在 Pod 中实现共享存储并将其提供给 Pod 的更多信息，
请参考<a href=/zh-cn/docs/concepts/storage/>存储</a>。</p><h3 id=pod-networking>Pod 联网</h3><p>每个 Pod 都在每个地址族中获得一个唯一的 IP 地址。
Pod 中的每个容器共享网络名字空间，包括 IP 地址和网络端口。
<strong>Pod 内</strong>的容器可以使用 <code>localhost</code> 互相通信。
当 Pod 中的容器与 <strong>Pod 之外</strong>的实体通信时，它们必须协调如何使用共享的网络资源（例如端口）。</p><p>在同一个 Pod 内，所有容器共享一个 IP 地址和端口空间，并且可以通过 <code>localhost</code> 发现对方。
他们也能通过如 SystemV 信号量或 POSIX 共享内存这类标准的进程间通信方式互相通信。
不同 Pod 中的容器的 IP 地址互不相同，如果没有特殊配置，就无法通过 OS 级 IPC 进行通信。
如果某容器希望与运行于其他 Pod 中的容器通信，可以通过 IP 联网的方式实现。</p><p>Pod 中的容器所看到的系统主机名与为 Pod 配置的 <code>name</code> 属性值相同。
<a href=/zh-cn/docs/concepts/cluster-administration/networking/>网络</a>部分提供了更多有关此内容的信息。</p><h2 id=privileged-mode-for-containers>容器的特权模式</h2><p>在 Linux 中，Pod 中的任何容器都可以使用容器规约中的
<a href=/zh-cn/docs/tasks/configure-pod-container/security-context/>安全性上下文</a>中的
<code>privileged</code>（Linux）参数启用特权模式。
这对于想要使用操作系统管理权能（Capabilities，如操纵网络堆栈和访问设备）的容器很有用。</p><p>如果你的集群启用了 <code>WindowsHostProcessContainers</code> 特性，你可以使用 Pod 规约中安全上下文的
<code>windowsOptions.hostProcess</code> 参数来创建
<a href=/zh-cn/docs/tasks/configure-pod-container/create-hostprocess-pod/>Windows HostProcess Pod</a>。
这些 Pod 中的所有容器都必须以 Windows HostProcess 容器方式运行。
HostProcess Pod 可以直接运行在主机上，它也能像 Linux 特权容器一样，用于执行管理任务。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>你的<a class=glossary-tooltip title=容器运行时是负责运行容器的软件。 data-toggle=tooltip data-placement=top href=/zh-cn/docs/setup/production-environment/container-runtimes target=_blank aria-label=容器运行时>容器运行时</a>必须支持特权容器的概念才能使用这一配置。</div><h2 id=static-pods>静态 Pod</h2><p><strong>静态 Pod（Static Pod）</strong> 直接由特定节点上的 <code>kubelet</code> 守护进程管理，
不需要 <a class=glossary-tooltip title='提供 Kubernetes API 服务的控制面组件。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label='API 服务器'>API 服务器</a>看到它们。
尽管大多数 Pod 都是通过控制面（例如，<a class=glossary-tooltip title=管理集群上的多副本应用。 data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Deployment>Deployment</a>）
来管理的，对于静态 Pod 而言，<code>kubelet</code> 直接监控每个 Pod，并在其失效时重启之。</p><p>静态 Pod 通常绑定到某个节点上的 <a class=glossary-tooltip title='一个在集群中每个节点上运行的代理。它保证容器都运行在 Pod 中。' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a>。
其主要用途是运行自托管的控制面。
在自托管场景中，使用 <code>kubelet</code>
来管理各个独立的<a href=/zh-cn/docs/concepts/overview/components/#control-plane-components>控制面组件</a>。</p><p><code>kubelet</code> 自动尝试为每个静态 Pod 在 Kubernetes API
服务器上创建一个<a class=glossary-tooltip title='API 服务器中的一个对象，用于跟踪 kubelet 上的静态 pod。' data-toggle=tooltip data-placement=top href='/zh-cn/docs/reference/glossary/?all=true#term-mirror-pod' target=_blank aria-label='镜像 Pod'>镜像 Pod</a>。
这意味着在节点上运行的 Pod 在 API 服务器上是可见的，但不可以通过 API 服务器来控制。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>静态 Pod 的 <code>spec</code> 不能引用其他的 API 对象（例如：
<a class=glossary-tooltip title='为在 Pod 中运行的进程提供标识。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/tasks/configure-pod-container/configure-service-account/ target=_blank aria-label=ServiceAccount>ServiceAccount</a>、
<a class=glossary-tooltip title='ConfigMap 是一种 API 对象，用来将非机密性的数据保存到键值对中。使用时可以用作环境变量、命令行参数或者存储卷中的配置文件。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/tasks/configure-pod-container/configure-pod-configmap/ target=_blank aria-label=ConfigMap>ConfigMap</a>、
<a class=glossary-tooltip title='Secret 用于存储敏感信息，如密码、 OAuth 令牌和 SSH 密钥。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/configuration/secret/ target=_blank aria-label=Secret>Secret</a> 等）。</div><h2 id=container-probes>容器探针</h2><p><strong>Probe</strong> 是由 kubelet 对容器执行的定期诊断。要执行诊断，kubelet 可以执行三种动作：</p><ul><li><code>ExecAction</code>（借助容器运行时执行）</li><li><code>TCPSocketAction</code>（由 kubelet 直接检测）</li><li><code>HTTPGetAction</code>（由 kubelet 直接检测）</li></ul><p>你可以参阅 Pod 的生命周期文档中的<a href=/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#container-probes>探针</a>部分。</p><h2 id=接下来>接下来</h2><ul><li>了解 <a href=/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/>Pod 生命周期</a>。</li><li>了解 <a href=/zh-cn/docs/concepts/containers/runtime-class/>RuntimeClass</a>，
以及如何使用它来配置不同的 Pod 使用不同的容器运行时配置。</li><li>了解 <a href=/zh-cn/docs/concepts/workloads/pods/disruptions/>PodDisruptionBudget</a>，
以及你可以如何利用它在出现干扰因素时管理应用的可用性。</li><li>Pod 在 Kubernetes REST API 中是一个顶层资源。
<a href=/zh-cn/docs/reference/kubernetes-api/workload-resources/pod-v1/>Pod</a>
对象的定义中包含了更多的细节信息。</li><li>博客<a href=/blog/2015/06/the-distributed-system-toolkit-patterns/>分布式系统工具箱：复合容器模式</a>中解释了在同一
Pod 中包含多个容器时的几种常见布局。</li><li>了解 <a href=/zh-cn/docs/concepts/scheduling-eviction/topology-spread-constraints/>Pod 拓扑分布约束</a>。</li></ul><p>要了解为什么 Kubernetes 会在其他资源
（如 <a class=glossary-tooltip title='StatefulSet 用来管理某 Pod 集合的部署和扩缩，并为这些 Pod 提供持久存储和持久标识符。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/workloads/controllers/statefulset/ target=_blank aria-label=StatefulSet>StatefulSet</a>
或 <a class=glossary-tooltip title=管理集群上的多副本应用。 data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Deployment>Deployment</a>）
封装通用的 Pod API，相关的背景信息可以在前人的研究中找到。具体包括：</p><ul><li><a href=https://aurora.apache.org/documentation/latest/reference/configuration/#job-schema>Aurora</a></li><li><a href=https://research.google.com/pubs/pub43438.html>Borg</a></li><li><a href=https://mesosphere.github.io/marathon/docs/rest-api.html>Marathon</a></li><li><a href=https://research.google/pubs/pub41684/>Omega</a></li><li><a href=https://engineering.fb.com/data-center-engineering/tupperware/>Tupperware</a>.</li></ul></div></div><div class=td-content style=page-break-before:always><h1 id=pg-c3c2b9cf30915ec9d46c147201da3332>1 - Pod 的生命周期</h1><p>本页面讲述 Pod 的生命周期。
Pod 遵循预定义的生命周期，起始于 <code>Pending</code> <a href=#pod-phase>阶段</a>，
如果至少其中有一个主要容器正常启动，则进入 <code>Running</code>，之后取决于 Pod
中是否有容器以失败状态结束而进入 <code>Succeeded</code> 或者 <code>Failed</code> 阶段。</p><p>在 Pod 运行期间，<code>kubelet</code> 能够重启容器以处理一些失效场景。
在 Pod 内部，Kubernetes 跟踪不同容器的<a href=#container-states>状态</a>并确定使
Pod 重新变得健康所需要采取的动作。</p><p>在 Kubernetes API 中，Pod 包含规约部分和实际状态部分。
Pod 对象的状态包含了一组 <a href=#pod-conditions>Pod 状况（Conditions）</a>。
如果应用需要的话，你也可以向其中注入<a href=#pod-readiness-gate>自定义的就绪态信息</a>。</p><p>Pod 在其生命周期中只会被<a href=/zh-cn/docs/concepts/scheduling-eviction/>调度</a>一次。
一旦 Pod 被调度（分派）到某个节点，Pod 会一直在该节点运行，直到 Pod
停止或者被<a href=#pod-termination>终止</a>。</p><h2 id=pod-lifetime>Pod 生命期</h2><p>和一个个独立的应用容器一样，Pod 也被认为是相对临时性（而不是长期存在）的实体。
Pod 会被创建、赋予一个唯一的
ID（<a href=/zh-cn/docs/concepts/overview/working-with-objects/names/#uids>UID</a>），
并被调度到节点，并在终止（根据重启策略）或删除之前一直运行在该节点。</p><p>如果一个<a class=glossary-tooltip title='Kubernetes 中的工作机器称作节点。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/architecture/nodes/ target=_blank aria-label=节点>节点</a>死掉了，调度到该节点的
Pod 也被计划在给定超时期限结束后<a href=#pod-garbage-collection>删除</a>。</p><p>Pod 自身不具有自愈能力。如果 Pod
被调度到某<a class=glossary-tooltip title='Kubernetes 中的工作机器称作节点。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/architecture/nodes/ target=_blank aria-label=节点>节点</a>而该节点之后失效，
Pod 会被删除；类似地，Pod 无法在因节点资源耗尽或者节点维护而被驱逐期间继续存活。
Kubernetes 使用一种高级抽象来管理这些相对而言可随时丢弃的 Pod 实例，
称作<a class=glossary-tooltip title='控制器通过 API 服务器监控集群的公共状态，并致力于将当前状态转变为期望的状态。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/architecture/controller/ target=_blank aria-label=控制器>控制器</a>。</p><p>任何给定的 Pod （由 UID 定义）从不会被“重新调度（rescheduled）”到不同的节点；
相反，这一 Pod 可以被一个新的、几乎完全相同的 Pod 替换掉。
如果需要，新 Pod 的名字可以不变，但是其 UID 会不同。</p><p>如果某物声称其生命期与某 Pod 相同，例如存储<a class=glossary-tooltip title='包含可被 Pod 中容器访问的数据的目录。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/storage/volumes/ target=_blank aria-label=卷>卷</a>，
这就意味着该对象在此 Pod （UID 亦相同）存在期间也一直存在。
如果 Pod 因为任何原因被删除，甚至某完全相同的替代 Pod 被创建时，
这个相关的对象（例如这里的卷）也会被删除并重建。</p><figure class=diagram-medium><img src=/images/docs/pod.svg><figcaption><h4>Pod 结构图例</h4></figcaption></figure><p><em>一个包含多个容器的 Pod 中包含一个用来拉取文件的程序和一个 Web 服务器，
均使用持久卷作为容器间共享的存储。</em></p><h2 id=pod-phase>Pod 阶段</h2><p>Pod 的 <code>status</code> 字段是一个
<a href=/docs/reference/generated/kubernetes-api/v1.25/#podstatus-v1-core>PodStatus</a>
对象，其中包含一个 <code>phase</code> 字段。</p><p>Pod 的阶段（Phase）是 Pod 在其生命周期中所处位置的简单宏观概述。
该阶段并不是对容器或 Pod 状态的综合汇总，也不是为了成为完整的状态机。</p><p>Pod 阶段的数量和含义是严格定义的。
除了本文档中列举的内容外，不应该再假定 Pod 有其他的 <code>phase</code> 值。</p><p>下面是 <code>phase</code> 可能的值：</p><table><thead><tr><th style=text-align:left>取值</th><th style=text-align:left>描述</th></tr></thead><tbody><tr><td style=text-align:left><code>Pending</code>（悬决）</td><td style=text-align:left>Pod 已被 Kubernetes 系统接受，但有一个或者多个容器尚未创建亦未运行。此阶段包括等待 Pod 被调度的时间和通过网络下载镜像的时间。</td></tr><tr><td style=text-align:left><code>Running</code>（运行中）</td><td style=text-align:left>Pod 已经绑定到了某个节点，Pod 中所有的容器都已被创建。至少有一个容器仍在运行，或者正处于启动或重启状态。</td></tr><tr><td style=text-align:left><code>Succeeded</code>（成功）</td><td style=text-align:left>Pod 中的所有容器都已成功终止，并且不会再重启。</td></tr><tr><td style=text-align:left><code>Failed</code>（失败）</td><td style=text-align:left>Pod 中的所有容器都已终止，并且至少有一个容器是因为失败终止。也就是说，容器以非 0 状态退出或者被系统终止。</td></tr><tr><td style=text-align:left><code>Unknown</code>（未知）</td><td style=text-align:left>因为某些原因无法取得 Pod 的状态。这种情况通常是因为与 Pod 所在主机通信失败。</td></tr></tbody></table><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>当一个 Pod 被删除时，执行一些 kubectl 命令会展示这个 Pod 的状态为 <code>Terminating</code>（终止）。
这个 <code>Terminating</code> 状态并不是 Pod 阶段之一。
Pod 被赋予一个可以体面终止的期限，默认为 30 秒。
你可以使用 <code>--force</code> 参数来<a href=/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination-forced>强制终止 Pod</a>。</div><p>如果某节点死掉或者与集群中其他节点失联，Kubernetes
会实施一种策略，将失去的节点上运行的所有 Pod 的 <code>phase</code> 设置为 <code>Failed</code>。</p><h2 id=container-states>容器状态</h2><p>Kubernetes 会跟踪 Pod 中每个容器的状态，就像它跟踪 Pod 总体上的<a href=#pod-phase>阶段</a>一样。
你可以使用<a href=/zh-cn/docs/concepts/containers/container-lifecycle-hooks/>容器生命周期回调</a>
来在容器生命周期中的特定时间点触发事件。</p><p>一旦<a class=glossary-tooltip title='控制平面组件，负责监视新创建的、未指定运行节点的 Pod，选择节点让 Pod 在上面运行。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/reference/command-line-tools-reference/kube-scheduler/ target=_blank aria-label=调度器>调度器</a>将 Pod
分派给某个节点，<code>kubelet</code>
就通过<a class=glossary-tooltip title=容器运行时是负责运行容器的软件。 data-toggle=tooltip data-placement=top href=/zh-cn/docs/setup/production-environment/container-runtimes target=_blank aria-label=容器运行时>容器运行时</a>开始为
Pod 创建容器。容器的状态有三种：<code>Waiting</code>（等待）、<code>Running</code>（运行中）和
<code>Terminated</code>（已终止）。</p><p>要检查 Pod 中容器的状态，你可以使用 <code>kubectl describe pod &lt;pod 名称></code>。
其输出中包含 Pod 中每个容器的状态。</p><p>每种状态都有特定的含义：</p><h3 id=container-state-waiting><code>Waiting</code> （等待）</h3><p>如果容器并不处在 <code>Running</code> 或 <code>Terminated</code> 状态之一，它就处在 <code>Waiting</code> 状态。
处于 <code>Waiting</code> 状态的容器仍在运行它完成启动所需要的操作：例如，
从某个容器镜像仓库拉取容器镜像，或者向容器应用 <a class=glossary-tooltip title='Secret 用于存储敏感信息，如密码、 OAuth 令牌和 SSH 密钥。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/configuration/secret/ target=_blank aria-label=Secret>Secret</a>
数据等等。
当你使用 <code>kubectl</code> 来查询包含 <code>Waiting</code> 状态的容器的 Pod 时，你也会看到一个
Reason 字段，其中给出了容器处于等待状态的原因。</p><h3 id=container-state-running><code>Running</code>（运行中）</h3><p><code>Running</code> 状态表明容器正在执行状态并且没有问题发生。
如果配置了 <code>postStart</code> 回调，那么该回调已经执行且已完成。
如果你使用 <code>kubectl</code> 来查询包含 <code>Running</code> 状态的容器的 Pod 时，
你也会看到关于容器进入 <code>Running</code> 状态的信息。</p><h3 id=container-state-terminated><code>Terminated</code>（已终止）</h3><p>处于 <code>Terminated</code> 状态的容器已经开始执行并且或者正常结束或者因为某些原因失败。
如果你使用 <code>kubectl</code> 来查询包含 <code>Terminated</code> 状态的容器的 Pod 时，
你会看到容器进入此状态的原因、退出代码以及容器执行期间的起止时间。</p><p>如果容器配置了 <code>preStop</code> 回调，则该回调会在容器进入 <code>Terminated</code>
状态之前执行。</p><h2 id=restart-policy>容器重启策略</h2><p>Pod 的 <code>spec</code> 中包含一个 <code>restartPolicy</code> 字段，其可能取值包括
Always、OnFailure 和 Never。默认值是 Always。</p><p><code>restartPolicy</code> 适用于 Pod 中的所有容器。<code>restartPolicy</code> 仅针对同一节点上
<code>kubelet</code> 的容器重启动作。当 Pod 中的容器退出时，<code>kubelet</code>
会按指数回退方式计算重启的延迟（10s、20s、40s、...），其最长延迟为 5 分钟。
一旦某容器执行了 10 分钟并且没有出现问题，<code>kubelet</code> 对该容器的重启回退计时器执行重置操作。</p><h2 id=pod-conditions>Pod 状况</h2><p>Pod 有一个 PodStatus 对象，其中包含一个
<a href=/docs/reference/generated/kubernetes-api/v1.25/#podcondition-v1-core>PodConditions</a>
数组。Pod 可能通过也可能未通过其中的一些状况测试。
Kubelet 管理以下 PodCondition：</p><ul><li><code>PodScheduled</code>：Pod 已经被调度到某节点；</li><li><code>PodHasNetwork</code>：Pod 沙箱被成功创建并且配置了网络（Alpha 特性，必须被<a href=#pod-has-network>显式启用</a>）；</li><li><code>ContainersReady</code>：Pod 中所有容器都已就绪；</li><li><code>Initialized</code>：所有的 <a href=/zh-cn/docs/concepts/workloads/pods/init-containers/>Init 容器</a>都已成功完成；</li><li><code>Ready</code>：Pod 可以为请求提供服务，并且应该被添加到对应服务的负载均衡池中。</li></ul><table><thead><tr><th style=text-align:left>字段名称</th><th style=text-align:left>描述</th></tr></thead><tbody><tr><td style=text-align:left><code>type</code></td><td style=text-align:left>Pod 状况的名称</td></tr><tr><td style=text-align:left><code>status</code></td><td style=text-align:left>表明该状况是否适用，可能的取值有 "<code>True</code>"、"<code>False</code>" 或 "<code>Unknown</code>"</td></tr><tr><td style=text-align:left><code>lastProbeTime</code></td><td style=text-align:left>上次探测 Pod 状况时的时间戳</td></tr><tr><td style=text-align:left><code>lastTransitionTime</code></td><td style=text-align:left>Pod 上次从一种状态转换到另一种状态时的时间戳</td></tr><tr><td style=text-align:left><code>reason</code></td><td style=text-align:left>机器可读的、驼峰编码（UpperCamelCase）的文字，表述上次状况变化的原因</td></tr><tr><td style=text-align:left><code>message</code></td><td style=text-align:left>人类可读的消息，给出上次状态转换的详细信息</td></tr></tbody></table><h3 id=pod-readiness-gate>Pod 就绪态</h3><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.14 [stable]</code></div><p>你的应用可以向 PodStatus 中注入额外的反馈或者信号：<strong>Pod Readiness（Pod 就绪态）</strong>。
要使用这一特性，可以设置 Pod 规约中的 <code>readinessGates</code> 列表，为 kubelet
提供一组额外的状况供其评估 Pod 就绪态时使用。</p><p>就绪态门控基于 Pod 的 <code>status.conditions</code> 字段的当前值来做决定。
如果 Kubernetes 无法在 <code>status.conditions</code> 字段中找到某状况，
则该状况的状态值默认为 "<code>False</code>"。</p><p>这里是一个例子：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>readinessGates</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>conditionType</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;www.example.com/feature-1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>conditions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Ready                             <span style=color:#bbb> </span><span style=color:#080;font-style:italic># 内置的 Pod 状况</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;False&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>lastProbeTime</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>null</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>lastTransitionTime</span>:<span style=color:#bbb> </span>2018-01-01T00:00:00Z<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;www.example.com/feature-1&#34;</span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 额外的 Pod 状况</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;False&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>lastProbeTime</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>null</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>lastTransitionTime</span>:<span style=color:#bbb> </span>2018-01-01T00:00:00Z<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containerStatuses</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>containerID</span>:<span style=color:#bbb> </span>docker://abcd...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>ready</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>你所添加的 Pod 状况名称必须满足 Kubernetes
<a href=/zh-cn/docs/concepts/overview/working-with-objects/labels/#syntax-and-character-set>标签键名格式</a>。</p><h3 id=pod-readiness-status>Pod 就绪态的状态</h3><p>命令 <code>kubectl patch</code> 不支持修改对象的状态。
如果需要设置 Pod 的 <code>status.conditions</code>，应用或者
<a class=glossary-tooltip title=一种用于管理自定义资源的专用控制器 data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/extend-kubernetes/operator/ target=_blank aria-label=Operators>Operators</a>
需要使用 <code>PATCH</code> 操作。你可以使用
<a href=/zh-cn/docs/reference/using-api/client-libraries/>Kubernetes 客户端库</a>之一来编写代码，
针对 Pod 就绪态设置定制的 Pod 状况。</p><p>对于使用定制状况的 Pod 而言，只有当下面的陈述都适用时，该 Pod 才会被评估为就绪：</p><ul><li>Pod 中所有容器都已就绪；</li><li><code>readinessGates</code> 中的所有状况都为 <code>True</code> 值。</li></ul><p>当 Pod 的容器都已就绪，但至少一个定制状况没有取值或者取值为 <code>False</code>，
<code>kubelet</code> 将 Pod 的<a href=#pod-conditions>状况</a>设置为 <code>ContainersReady</code>。</p><h3 id=pod-has-network>Pod 网络就绪</h3><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.25 [alpha]</code></div><p>在 Pod 被调度到某节点后，它需要被 Kubelet 接受并且挂载所需的卷。
一旦这些阶段完成，Kubelet 将与容器运行时（使用<a class=glossary-tooltip title='一组与 kubelet 集成的容器运行时 API' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/overview/components/#container-runtime target=_blank aria-label='容器运行时接口（Container Runtime Interface；CRI）'>容器运行时接口（Container Runtime Interface；CRI）</a>）
一起为 Pod 生成运行时沙箱并配置网络。
如果启用了 <code>PodHasNetworkCondition</code> <a href=/zh-cn/docs/reference/command-line-tools-reference/feature-gates/>特性门控</a>，
kubelet 会通过 Pod 的 <code>status.conditions</code> 字段中的 <code>PodHasNetwork</code> 状况来报告
Pod 是否达到了初始化里程碑。</p><p>当 kubelet 检测到 Pod 不具备配置了网络的运行时沙箱时，<code>PodHasNetwork</code> 状况将被设置为 <code>False</code>。
以下场景中将会发生这种状况：</p><ul><li>在 Pod 生命周期的早期阶段，kubelet 还没有开始使用容器运行时为 Pod 设置沙箱时。</li><li>在 Pod 生命周期的末期阶段，Pod 的沙箱由于以下原因被销毁时：<ul><li>节点重启时 Pod 没有被驱逐</li><li>对于使用虚拟机进行隔离的容器运行时，Pod 沙箱虚拟机重启时，需要创建一个新的沙箱和全新的容器网络配置。</li></ul></li></ul><p>在运行时插件成功完成 Pod 的沙箱创建和网络配置后，
kubelet 会将 <code>PodHasNetwork</code> 状况设置为 <code>True</code>。
当 <code>PodHasNetwork</code> 状况设置为 <code>True</code> 后，
Kubelet 可以开始拉取容器镜像和创建容器。</p><p>对于带有 Init 容器的 Pod，kubelet 会在 Init 容器成功完成后将 <code>Initialized</code> 状况设置为 <code>True</code>
（这发生在运行时成功创建沙箱和配置网络之后），
对于没有 Init 容器的 Pod，kubelet 会在创建沙箱和网络配置开始之前将
<code>Initialized</code> 状况设置为 <code>True</code>。</p><h2 id=container-probes>容器探针</h2><p>probe 是由 <a href=/zh-cn/docs/reference/command-line-tools-reference/kubelet/>kubelet</a> 对容器执行的定期诊断。
要执行诊断，kubelet 既可以在容器内执行代码，也可以发出一个网络请求。</p><h3 id=probe-check-methods>检查机制</h3><p>使用探针来检查容器有四种不同的方法。
每个探针都必须准确定义为这四种机制中的一种：</p><dl><dt><code>exec</code></dt><dd>在容器内执行指定命令。如果命令退出时返回码为 0 则认为诊断成功。</dd><dt><code>grpc</code></dt><dd>使用 <a href=https://grpc.io/>gRPC</a> 执行一个远程过程调用。
目标应该实现
<a href=https://grpc.io/grpc/core/md_doc_health-checking.html>gRPC健康检查</a>。
如果响应的状态是 "SERVING"，则认为诊断成功。
gRPC 探针是一个 Alpha 特性，只有在你启用了
"GRPCContainerProbe" <a href=/zh-cn/docs/reference/command-line-tools-reference/feature-gates/>特性门控</a>时才能使用。</dd><dt><code>httpGet</code></dt><dd>对容器的 IP 地址上指定端口和路径执行 HTTP <code>GET</code> 请求。如果响应的状态码大于等于 200
且小于 400，则诊断被认为是成功的。</dd><dt><code>tcpSocket</code></dt><dd>对容器的 IP 地址上的指定端口执行 TCP 检查。如果端口打开，则诊断被认为是成功的。
如果远程系统（容器）在打开连接后立即将其关闭，这算作是健康的。</dd></dl><h3 id=probe-outcome>探测结果</h3><p>每次探测都将获得以下三种结果之一：</p><dl><dt><code>Success</code>（成功）</dt><dd>容器通过了诊断。</dd><dt><code>Failure</code>（失败）</dt><dd>容器未通过诊断。</dd><dt><code>Unknown</code>（未知）</dt><dd>诊断失败，因此不会采取任何行动。</dd></dl><h3 id=types-of-probe>探测类型</h3><p>针对运行中的容器，<code>kubelet</code> 可以选择是否执行以下三种探针，以及如何针对探测结果作出反应：</p><dl><dt><code>livenessProbe</code></dt><dd>指示容器是否正在运行。如果存活态探测失败，则 kubelet 会杀死容器，
并且容器将根据其<a href=#restart-policy>重启策略</a>决定未来。如果容器不提供存活探针，
则默认状态为 <code>Success</code>。</dd><dt><code>readinessProbe</code></dt><dd>指示容器是否准备好为请求提供服务。如果就绪态探测失败，
端点控制器将从与 Pod 匹配的所有服务的端点列表中删除该 Pod 的 IP 地址。
初始延迟之前的就绪态的状态值默认为 <code>Failure</code>。
如果容器不提供就绪态探针，则默认状态为 <code>Success</code>。</dd><dt><code>startupProbe</code></dt><dd>指示容器中的应用是否已经启动。如果提供了启动探针，则所有其他探针都会被
禁用，直到此探针成功为止。如果启动探测失败，<code>kubelet</code> 将杀死容器，
而容器依其<a href=#restart-policy>重启策略</a>进行重启。
如果容器没有提供启动探测，则默认状态为 <code>Success</code>。</dd></dl><p>如欲了解如何设置存活态、就绪态和启动探针的进一步细节，
可以参阅<a href=/zh-cn/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/>配置存活态、就绪态和启动探针</a>。</p><h4 id=when-should-you-use-a-liveness-probe>何时该使用存活态探针?</h4><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.0 [stable]</code></div><p>如果容器中的进程能够在遇到问题或不健康的情况下自行崩溃，则不一定需要存活态探针；
<code>kubelet</code> 将根据 Pod 的 <code>restartPolicy</code> 自动执行修复操作。</p><p>如果你希望容器在探测失败时被杀死并重新启动，那么请指定一个存活态探针，
并指定 <code>restartPolicy</code> 为 "<code>Always</code>" 或 "<code>OnFailure</code>"。</p><h4 id=when-should-you-use-a-readiness-probe>何时该使用就绪态探针?</h4><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.0 [stable]</code></div><p>如果要仅在探测成功时才开始向 Pod 发送请求流量，请指定就绪态探针。
在这种情况下，就绪态探针可能与存活态探针相同，但是规约中的就绪态探针的存在意味着
Pod 将在启动阶段不接收任何数据，并且只有在探针探测成功后才开始接收数据。</p><p>如果你希望容器能够自行进入维护状态，也可以指定一个就绪态探针，
检查某个特定于就绪态的因此不同于存活态探测的端点。</p><p>如果你的应用程序对后端服务有严格的依赖性，你可以同时实现存活态和就绪态探针。
当应用程序本身是健康的，存活态探针检测通过后，就绪态探针会额外检查每个所需的后端服务是否可用。
这可以帮助你避免将流量导向只能返回错误信息的 Pod。</p><p>如果你的容器需要在启动期间加载大型数据、配置文件或执行迁移，
你可以使用<a href=#when-should-you-use-a-startup-probe>启动探针</a>。
然而，如果你想区分已经失败的应用和仍在处理其启动数据的应用，你可能更倾向于使用就绪探针。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>请注意，如果你只是想在 Pod 被删除时能够排空请求，则不一定需要使用就绪态探针；
在删除 Pod 时，Pod 会自动将自身置于未就绪状态，无论就绪态探针是否存在。
等待 Pod 中的容器停止期间，Pod 会一直处于未就绪状态。</div><h4 id=when-should-you-use-a-startup-probe>何时该使用启动探针？</h4><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.20 [stable]</code></div><p>对于所包含的容器需要较长时间才能启动就绪的 Pod 而言，启动探针是有用的。
你不再需要配置一个较长的存活态探测时间间隔，只需要设置另一个独立的配置选定，
对启动期间的容器执行探测，从而允许使用远远超出存活态时间间隔所允许的时长。</p><p>如果你的容器启动时间通常超出 <code>initialDelaySeconds + failureThreshold × periodSeconds</code>
总值，你应该设置一个启动探测，对存活态探针所使用的同一端点执行检查。
<code>periodSeconds</code> 的默认值是 10 秒。你应该将其 <code>failureThreshold</code> 设置得足够高，
以便容器有充足的时间完成启动，并且避免更改存活态探针所使用的默认值。
这一设置有助于减少死锁状况的发生。</p><h2 id=pod-termination>Pod 的终止</h2><p>由于 Pod 所代表的是在集群中节点上运行的进程，当不再需要这些进程时允许其体面地终止是很重要的。
一般不应武断地使用 <code>KILL</code> 信号终止它们，导致这些进程没有机会完成清理操作。</p><p>设计的目标是令你能够请求删除进程，并且知道进程何时被终止，同时也能够确保删除操作终将完成。
当你请求删除某个 Pod 时，集群会记录并跟踪 Pod 的体面终止周期，
而不是直接强制地杀死 Pod。在存在强制关闭设施的前提下，
<a class=glossary-tooltip title='一个在集群中每个节点上运行的代理。它保证容器都运行在 Pod 中。' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a> 会尝试体面地终止
Pod。</p><p>通常情况下，容器运行时会发送一个 TERM 信号到每个容器中的主进程。
很多容器运行时都能够注意到容器镜像中 <code>STOPSIGNAL</code> 的值，并发送该信号而不是 TERM。
一旦超出了体面终止限期，容器运行时会向所有剩余进程发送 KILL 信号，之后
Pod 就会被从 <a class=glossary-tooltip title='提供 Kubernetes API 服务的控制面组件。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label='API 服务器'>API 服务器</a>上移除。
如果 <code>kubelet</code> 或者容器运行时的管理服务在等待进程终止期间被重启，
集群会从头开始重试，赋予 Pod 完整的体面终止限期。</p><p>下面是一个例子：</p><ol><li><p>你使用 <code>kubectl</code> 工具手动删除某个特定的 Pod，而该 Pod 的体面终止限期是默认值（30 秒）。</p></li><li><p>API 服务器中的 Pod 对象被更新，记录涵盖体面终止限期在内 Pod
的最终死期，超出所计算时间点则认为 Pod 已死（dead）。
如果你使用 <code>kubectl describe</code> 来查验你正在删除的 Pod，该 Pod 会显示为
"Terminating" （正在终止）。
在 Pod 运行所在的节点上：<code>kubelet</code> 一旦看到 Pod
被标记为正在终止（已经设置了体面终止限期），<code>kubelet</code> 即开始本地的 Pod 关闭过程。</p><ol><li><p>如果 Pod 中的容器之一定义了 <code>preStop</code>
<a href=/zh-cn/docs/concepts/containers/container-lifecycle-hooks>回调</a>，
<code>kubelet</code> 开始在容器内运行该回调逻辑。如果超出体面终止限期时，
<code>preStop</code> 回调逻辑仍在运行，<code>kubelet</code> 会请求给予该 Pod 的宽限期一次性增加 2 秒钟。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong><pre><code>  如果 `preStop` 回调所需要的时间长于默认的体面终止限期，你必须修改
  `terminationGracePeriodSeconds` 属性值来使其正常工作。</code></pre></div></li></ol><ol start=2><li><p><code>kubelet</code> 接下来触发容器运行时发送 TERM 信号给每个容器中的进程 1。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong><pre><code>  Pod 中的容器会在不同时刻收到 TERM 信号，接收顺序也是不确定的。
  如果关闭的顺序很重要，可以考虑使用 `preStop` 回调逻辑来协调。</code></pre></div></li></ol></li></ol><ol start=3><li>在 <code>kubelet</code> 启动体面关闭逻辑的同时，控制面会将关闭的 Pod 从对应的
EndpointSlice（和 Endpoints）对象中移除，过滤条件是 Pod
被对应的<a class=glossary-tooltip title='将运行在一组 Pods 上的应用程序公开为网络服务的抽象方法。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/services-networking/service/ target=_blank aria-label=服务>服务</a>以某
<a class=glossary-tooltip title=选择算符允许用户通过标签对一组资源对象进行筛选过滤。 data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/overview/working-with-objects/labels/ target=_blank aria-label=选择算符>选择算符</a>选定。
<a class=glossary-tooltip title='ReplicaSet 是下一代副本控制器。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/workloads/controllers/replicaset/ target=_blank aria-label=ReplicaSet>ReplicaSet</a>
和其他工作负载资源不再将关闭进程中的 Pod 视为合法的、能够提供服务的副本。
关闭动作很慢的 Pod 也无法继续处理请求数据，
因为负载均衡器（例如服务代理）已经在终止宽限期开始的时候将其从端点列表中移除。</li></ol><ol start=4><li><p>超出终止宽限期限时，<code>kubelet</code> 会触发强制关闭过程。容器运行时会向 Pod
中所有容器内仍在运行的进程发送 <code>SIGKILL</code> 信号。
<code>kubelet</code> 也会清理隐藏的 <code>pause</code> 容器，如果容器运行时使用了这种容器的话。</p></li><li><p><code>kubelet</code> 触发强制从 API 服务器上删除 Pod 对象的逻辑，并将体面终止限期设置为 0
（这意味着马上删除）。</p></li><li><p>API 服务器删除 Pod 的 API 对象，从任何客户端都无法再看到该对象。</p></li></ol><h3 id=pod-termination-forced>强制终止 Pod</h3><div class="alert alert-warning caution callout" role=alert><strong>注意：</strong><p>对于某些工作负载及其 Pod 而言，强制删除很可能会带来某种破坏。</div><p>默认情况下，所有的删除操作都会附有 30 秒钟的宽限期限。
<code>kubectl delete</code> 命令支持 <code>--grace-period=&lt;seconds></code> 选项，允许你重载默认值，
设定自己希望的期限值。</p><p>将宽限期限强制设置为 <code>0</code> 意味着立即从 API 服务器删除 Pod。
如果 Pod 仍然运行于某节点上，强制删除操作会触发 <code>kubelet</code> 立即执行清理操作。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>你必须在设置 <code>--grace-period=0</code> 的同时额外设置 <code>--force</code> 参数才能发起强制删除请求。</div><p>执行强制删除操作时，API 服务器不再等待来自 <code>kubelet</code> 的、关于 Pod
已经在原来运行的节点上终止执行的确认消息。
API 服务器直接删除 Pod 对象，这样新的与之同名的 Pod 即可以被创建。
在节点侧，被设置为立即终止的 Pod 仍然会在被强行杀死之前获得一点点的宽限时间。</p><div class="alert alert-warning caution callout" role=alert><strong>注意：</strong><p>马上删除时不等待确认正在运行的资源已被终止。这些资源可能会无限期地继续在集群上运行。</div><p>如果你需要强制删除 StatefulSet 的 Pod，
请参阅<a href=/zh-cn/docs/tasks/run-application/force-delete-stateful-set-pod/>从 StatefulSet 中删除 Pod</a> 的任务文档。</p><h3 id=pod-garbage-collection>已终止 Pod 的垃圾收集</h3><p>对于已失败的 Pod 而言，对应的 API 对象仍然会保留在集群的 API 服务器上，
直到用户或者<a class=glossary-tooltip title='控制器通过 API 服务器监控集群的公共状态，并致力于将当前状态转变为期望的状态。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/architecture/controller/ target=_blank aria-label=控制器>控制器</a>进程显式地将其删除。</p><p>控制面组件会在 Pod 个数超出所配置的阈值
（根据 <code>kube-controller-manager</code> 的 <code>terminated-pod-gc-threshold</code> 设置）时删除已终止的
Pod（阶段值为 <code>Succeeded</code> 或 <code>Failed</code>）。
这一行为会避免随着时间演进不断创建和终止 Pod 而引起的资源泄露问题。</p><h2 id=接下来>接下来</h2><ul><li>动手实践<a href=/zh-cn/docs/tasks/configure-pod-container/attach-handler-lifecycle-event/>为容器生命周期时间关联处理程序</a>。</li><li>动手实践<a href=/zh-cn/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/>配置存活态、就绪态和启动探针</a>。</li><li>进一步了解<a href=/zh-cn/docs/concepts/containers/container-lifecycle-hooks/>容器生命周期回调</a>。</li><li>关于 API 中定义的有关 Pod 和容器状态的详细规范信息，
可参阅 API 参考文档中 Pod 的 <a href=/docs/reference/kubernetes-api/workload-resources/pod-v1/#PodStatus><code>.status</code></a> 字段。</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-1ccbd4eeded6ab138d98b59175bd557e>2 - Init 容器</h1><p>本页提供了 Init 容器的概览。Init 容器是一种特殊容器，在 <a class=glossary-tooltip title='Pod 表示你的集群上一组正在运行的容器。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/workloads/pods/ target=_blank aria-label=Pod>Pod</a>
内的应用容器启动之前运行。Init 容器可以包括一些应用镜像中不存在的实用工具和安装脚本。</p><p>你可以在 Pod 的规约中与用来描述应用容器的 <code>containers</code> 数组平行的位置指定
Init 容器。</p><h2 id=understanding-init-containers>理解 Init 容器</h2><p>每个 <a class=glossary-tooltip title='Pod 表示你的集群上一组正在运行的容器。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/workloads/pods/ target=_blank aria-label=Pod>Pod</a> 中可以包含多个容器，
应用运行在这些容器里面，同时 Pod 也可以有一个或多个先于应用容器启动的 Init 容器。</p><p>Init 容器与普通的容器非常像，除了如下两点：</p><ul><li>它们总是运行到完成。</li><li>每个都必须在下一个启动之前成功完成。</li></ul><p>如果 Pod 的 Init 容器失败，kubelet 会不断地重启该 Init 容器直到该容器成功为止。
然而，如果 Pod 对应的 <code>restartPolicy</code> 值为 "Never"，并且 Pod 的 Init 容器失败，
则 Kubernetes 会将整个 Pod 状态设置为失败。</p><p>为 Pod 设置 Init 容器需要在
<a href=/zh-cn/docs/reference/kubernetes-api/workload-resources/pod-v1/#PodSpec>Pod 规约</a>中添加 <code>initContainers</code> 字段，
该字段以 <a href=/docs/reference/generated/kubernetes-api/v1.25/#container-v1-core>Container</a>
类型对象数组的形式组织，和应用的 <code>containers</code> 数组同级相邻。
参阅 API 参考的<a href=/zh-cn/docs/reference/kubernetes-api/workload-resources/pod-v1/#Container>容器</a>章节了解详情。</p><p>Init 容器的状态在 <code>status.initContainerStatuses</code> 字段中以容器状态数组的格式返回
（类似 <code>status.containerStatuses</code> 字段）。</p><h3 id=differences-from-regular-containers>与普通容器的不同之处</h3><p>Init 容器支持应用容器的全部字段和特性，包括资源限制、数据卷和安全设置。
然而，Init 容器对资源请求和限制的处理稍有不同，在下面<a href=#resources>资源</a>节有说明。</p><p>同时 Init 容器不支持 <code>lifecycle</code>、<code>livenessProbe</code>、<code>readinessProbe</code> 和 <code>startupProbe</code>，
因为它们必须在 Pod 就绪之前运行完成。</p><p>如果为一个 Pod 指定了多个 Init 容器，这些容器会按顺序逐个运行。
每个 Init 容器必须运行成功，下一个才能够运行。当所有的 Init 容器运行完成时，
Kubernetes 才会为 Pod 初始化应用容器并像平常一样运行。</p><h2 id=using-init-containers>使用 Init 容器</h2><p>因为 Init 容器具有与应用容器分离的单独镜像，其启动相关代码具有如下优势：</p><ul><li><p>Init 容器可以包含一些安装过程中应用容器中不存在的实用工具或个性化代码。
例如，没有必要仅为了在安装过程中使用类似 <code>sed</code>、<code>awk</code>、<code>python</code> 或 <code>dig</code>
这样的工具而去 <code>FROM</code> 一个镜像来生成一个新的镜像。</p></li><li><p>应用镜像的创建者和部署者可以各自独立工作，而没有必要联合构建一个单独的应用镜像。</p></li></ul><ul><li><p>与同一 Pod 中的多个应用容器相比，Init 容器能以不同的文件系统视图运行。因此，Init
容器可以被赋予访问应用容器不能访问的 <a class=glossary-tooltip title='Secret 用于存储敏感信息，如密码、 OAuth 令牌和 SSH 密钥。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/configuration/secret/ target=_blank aria-label=Secret>Secret</a> 的权限。</p></li><li><p>由于 Init 容器必须在应用容器启动之前运行完成，因此 Init
容器提供了一种机制来阻塞或延迟应用容器的启动，直到满足了一组先决条件。
一旦前置条件满足，Pod 内的所有的应用容器会并行启动。</p></li><li><p>Init 容器可以安全地运行实用程序或自定义代码，而在其他方式下运行这些实用程序或自定义代码可能会降低应用容器镜像的安全性。
通过将不必要的工具分开，你可以限制应用容器镜像的被攻击范围。</p></li></ul><h3 id=examples>示例</h3><p>下面是一些如何使用 Init 容器的想法：</p><ul><li><p>等待一个 Service 完成创建，通过类似如下 Shell 命令：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#a2f;font-weight:700>for</span> i in <span style=color:#666>{</span>1..100<span style=color:#666>}</span>; <span style=color:#a2f;font-weight:700>do</span> sleep 1; <span style=color:#a2f;font-weight:700>if</span> dig myservice; <span style=color:#a2f;font-weight:700>then</span> <span style=color:#a2f>exit</span> 0; <span style=color:#a2f;font-weight:700>fi</span>; <span style=color:#a2f;font-weight:700>done</span>; <span style=color:#a2f>exit</span> <span style=color:#666>1</span>
</span></span></code></pre></div></li></ul><ul><li><p>注册这个 Pod 到远程服务器，通过在命令中调用 API，类似如下：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -X POST http://<span style=color:#b8860b>$MANAGEMENT_SERVICE_HOST</span>:<span style=color:#b8860b>$MANAGEMENT_SERVICE_PORT</span>/register -d <span style=color:#b44>&#39;instance=$(&lt;POD_NAME&gt;)&amp;ip=$(&lt;POD_IP&gt;)&#39;</span>
</span></span></code></pre></div></li></ul><ul><li><p>在启动应用容器之前等一段时间，使用类似命令：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sleep <span style=color:#666>60</span>
</span></span></code></pre></div></li></ul><ul><li><p>克隆 Git 仓库到<a class=glossary-tooltip title='包含可被 Pod 中容器访问的数据的目录。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/storage/volumes/ target=_blank aria-label=卷>卷</a>中。</p></li><li><p>将配置值放到配置文件中，运行模板工具为主应用容器动态地生成配置文件。
例如，在配置文件中存放 <code>POD_IP</code> 值，并使用 Jinja 生成主应用配置文件。</p></li></ul><h3 id=init-containers-in-use>使用 Init 容器的情况</h3><p>下面的例子定义了一个具有 2 个 Init 容器的简单 Pod。 第一个等待 <code>myservice</code> 启动，
第二个等待 <code>mydb</code> 启动。 一旦这两个 Init 容器都启动完成，Pod 将启动 <code>spec</code> 节中的应用容器。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myapp-pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>MyApp<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myapp-container<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#39;sh&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;-c&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;echo The app is running! &amp;&amp; sleep 3600&#39;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>initContainers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>init-myservice<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#39;sh&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;-c&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;until nslookup myservice.$(cat /var/run/secrets/kubernetes.io/serviceaccount/namespace).svc.cluster.local; do echo waiting for myservice; sleep 2; done&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>init-mydb<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>busybox:1.28<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#39;sh&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#39;-c&#39;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;until nslookup mydb.$(cat /var/run/secrets/kubernetes.io/serviceaccount/namespace).svc.cluster.local; do echo waiting for mydb; sleep 2; done&#34;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div><p>你通过运行下面的命令启动 Pod：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f myapp.yaml
</span></span></code></pre></div><p>输出类似于：</p><pre tabindex=0><code>pod/myapp-pod created
</code></pre><p>使用下面的命令检查其状态：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get -f myapp.yaml
</span></span></code></pre></div><p>输出类似于：</p><pre tabindex=0><code>NAME        READY     STATUS     RESTARTS   AGE
myapp-pod   0/1       Init:0/2   0          6m
</code></pre><p>或者查看更多详细信息：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe -f myapp.yaml
</span></span></code></pre></div><p>输出类似于：</p><pre tabindex=0><code>Name:          myapp-pod
Namespace:     default
[...]
Labels:        app.kubernetes.io/name=MyApp
Status:        Pending
[...]
Init Containers:
  init-myservice:
[...]
    State:         Running
[...]
  init-mydb:
[...]
    State:         Waiting
      Reason:      PodInitializing
    Ready:         False
[...]
Containers:
  myapp-container:
[...]
    State:         Waiting
      Reason:      PodInitializing
    Ready:         False
[...]
Events:
  FirstSeen    LastSeen    Count    From                      SubObjectPath                           Type          Reason        Message
  ---------    --------    -----    ----                      -------------                           --------      ------        -------
  16s          16s         1        {default-scheduler }                                              Normal        Scheduled     Successfully assigned myapp-pod to 172.17.4.201
  16s          16s         1        {kubelet 172.17.4.201}    spec.initContainers{init-myservice}     Normal        Pulling       pulling image &#34;busybox&#34;
  13s          13s         1        {kubelet 172.17.4.201}    spec.initContainers{init-myservice}     Normal        Pulled        Successfully pulled image &#34;busybox&#34;
  13s          13s         1        {kubelet 172.17.4.201}    spec.initContainers{init-myservice}     Normal        Created       Created container init-myservice
  13s          13s         1        {kubelet 172.17.4.201}    spec.initContainers{init-myservice}     Normal        Started       Started container init-myservice
</code></pre><p>如需查看 Pod 内 Init 容器的日志，请执行：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl logs myapp-pod -c init-myservice <span style=color:#080;font-style:italic># 查看第一个 Init 容器</span>
</span></span><span style=display:flex><span>kubectl logs myapp-pod -c init-mydb      <span style=color:#080;font-style:italic># 查看第二个 Init 容器</span>
</span></span></code></pre></div><p>在这一刻，Init 容器将会等待至发现名称为 <code>mydb</code> 和 <code>myservice</code> 的 Service。</p><p>如下为创建这些 Service 的配置文件：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>myservice<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9376</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mydb<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>protocol</span>:<span style=color:#bbb> </span>TCP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>targetPort</span>:<span style=color:#bbb> </span><span style=color:#666>9377</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>创建 <code>mydb</code> 和 <code>myservice</code> 服务的命令：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f services.yaml
</span></span></code></pre></div><p>输出类似于：</p><pre tabindex=0><code>service/myservice created
service/mydb created
</code></pre><p>这样你将能看到这些 Init 容器执行完毕，随后 <code>my-app</code> 的 Pod 进入 <code>Running</code> 状态：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get -f myapp.yaml
</span></span></code></pre></div><p>输出类似于：</p><pre tabindex=0><code>NAME        READY     STATUS    RESTARTS   AGE
myapp-pod   1/1       Running   0          9m
</code></pre><p>这个简单例子应该能为你创建自己的 Init 容器提供一些启发。
<a href=#what-s-next>接下来</a>节提供了更详细例子的链接。</p><h2 id=detailed-behavior>具体行为</h2><p>在 Pod 启动过程中，每个 Init 容器会在网络和数据卷初始化之后按顺序启动。
kubelet 运行依据 Init 容器在 Pod 规约中的出现顺序依次运行之。</p><p>每个 Init 容器成功退出后才会启动下一个 Init 容器。
如果某容器因为容器运行时的原因无法启动，或以错误状态退出，kubelet 会根据
Pod 的 <code>restartPolicy</code> 策略进行重试。
然而，如果 Pod 的 <code>restartPolicy</code> 设置为 "Always"，Init 容器失败时会使用
<code>restartPolicy</code> 的 "OnFailure" 策略。</p><p>在所有的 Init 容器没有成功之前，Pod 将不会变成 <code>Ready</code> 状态。
Init 容器的端口将不会在 Service 中进行聚集。正在初始化中的 Pod 处于 <code>Pending</code> 状态，
但会将状况 <code>Initializing</code> 设置为 false。</p><p>如果 Pod <a href=#pod-restart-reasons>重启</a>，所有 Init 容器必须重新执行。</p><p>对 Init 容器规约的修改仅限于容器的 <code>image</code> 字段。
更改 Init 容器的 <code>image</code> 字段，等同于重启该 Pod。</p><p>因为 Init 容器可能会被重启、重试或者重新执行，所以 Init 容器的代码应该是幂等的。
特别地，基于 <code>emptyDirs</code> 写文件的代码，应该对输出文件可能已经存在做好准备。</p><p>Init 容器具有应用容器的所有字段。然而 Kubernetes 禁止使用 <code>readinessProbe</code>，
因为 Init 容器不能定义不同于完成态（Completion）的就绪态（Readiness）。
Kubernetes 会在校验时强制执行此检查。</p><p>在 Pod 上使用 <code>activeDeadlineSeconds</code> 和在容器上使用 <code>livenessProbe</code> 可以避免
Init 容器一直重复失败。
<code>activeDeadlineSeconds</code> 时间包含了 Init 容器启动的时间。
但建议仅在团队将其应用程序部署为 Job 时才使用 <code>activeDeadlineSeconds</code>，
因为 <code>activeDeadlineSeconds</code> 在 Init 容器结束后仍有效果。
如果你设置了 <code>activeDeadlineSeconds</code>，已经在正常运行的 Pod 会被杀死。</p><p>在 Pod 中的每个应用容器和 Init 容器的名称必须唯一；
与任何其它容器共享同一个名称，会在校验时抛出错误。</p><h3 id=resources>资源</h3><p>在给定的 Init 容器执行顺序下，资源使用适用于如下规则：</p><ul><li>所有 Init 容器上定义的任何特定资源的 limit 或 request 的最大值，作为
Pod <strong>有效初始 request/limit</strong>。
如果任何资源没有指定资源限制，这被视为最高限制。</li><li>Pod 对资源的 <strong>有效 limit/request</strong> 是如下两者中的较大者：<ul><li>所有应用容器对某个资源的 limit/request 之和</li><li>对某个资源的有效初始 limit/request</li></ul></li><li>基于有效 limit/request 完成调度，这意味着 Init 容器能够为初始化过程预留资源，
这些资源在 Pod 生命周期过程中并没有被使用。</li><li>Pod 的 <strong>有效 QoS 层</strong>，与 Init 容器和应用容器的一样。</li></ul><p>配额和限制适用于有效 Pod 的请求和限制值。
Pod 级别的 cgroups 是基于有效 Pod 的请求和限制值，和调度器相同。</p><h3 id=pod-restart-reasons>Pod 重启的原因</h3><p>Pod 重启会导致 Init 容器重新执行，主要有如下几个原因：</p><ul><li><p>Pod 的基础设施容器 (译者注：如 <code>pause</code> 容器) 被重启。这种情况不多见，
必须由具备 root 权限访问节点的人员来完成。</p></li><li><p>当 <code>restartPolicy</code> 设置为 <code>Always</code>，Pod 中所有容器会终止而强制重启。
由于垃圾收集机制的原因，Init 容器的完成记录将会丢失。</p></li></ul><p>当 Init 容器的镜像发生改变或者 Init 容器的完成记录因为垃圾收集等原因被丢失时，
Pod 不会被重启。这一行为适用于 Kubernetes v1.20 及更新版本。
如果你在使用较早版本的 Kubernetes，可查阅你所使用的版本对应的文档。</p><h2 id=接下来>接下来</h2><ul><li>阅读<a href=/zh-cn/docs/tasks/configure-pod-container/configure-pod-initialization/#create-a-pod-that-has-an-init-container>创建包含 Init 容器的 Pod</a></li><li>学习如何<a href=/zh-cn/docs/tasks/debug/debug-application/debug-init-containers/>调试 Init 容器</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-4aaf43c715cd764bc8ed4436f3537e68>3 - 干扰（Disruptions）</h1><p>本指南针对的是希望构建高可用性应用的应用所有者，他们有必要了解可能发生在 Pod 上的干扰类型。</p><p>文档同样适用于想要执行自动化集群操作（例如升级和自动扩展集群）的集群管理员。</p><h2 id=voluntary-and-involuntary-disruptions>自愿干扰和非自愿干扰</h2><p>Pod 不会消失，除非有人（用户或控制器）将其销毁，或者出现了不可避免的硬件或软件系统错误。</p><p>我们把这些不可避免的情况称为应用的<strong>非自愿干扰（Involuntary Disruptions）</strong>。例如：</p><ul><li>节点下层物理机的硬件故障</li><li>集群管理员错误地删除虚拟机（实例）</li><li>云提供商或虚拟机管理程序中的故障导致的虚拟机消失</li><li>内核错误</li><li>节点由于集群网络隔离从集群中消失</li><li>由于节点<a href=/zh-cn/docs/concepts/scheduling-eviction/node-pressure-eviction/>资源不足</a>导致 pod 被驱逐。</li></ul><p>除了资源不足的情况，大多数用户应该都熟悉这些情况；它们不是特定于 Kubernetes 的。</p><p>我们称其他情况为<strong>自愿干扰（Voluntary Disruptions）</strong>。
包括由应用所有者发起的操作和由集群管理员发起的操作。
典型的应用所有者的操作包括：</p><ul><li>删除 Deployment 或其他管理 Pod 的控制器</li><li>更新了 Deployment 的 Pod 模板导致 Pod 重启</li><li>直接删除 Pod（例如，因为误操作）</li></ul><p>集群管理员操作包括：</p><ul><li><a href=/zh-cn/docs/tasks/administer-cluster/safely-drain-node/>排空（drain）节点</a>进行修复或升级。</li><li>从集群中排空节点以缩小集群（了解<a href=https://github.com/kubernetes/autoscaler/#readme>集群自动扩缩</a>）。</li><li>从节点中移除一个 Pod，以允许其他 Pod 使用该节点。</li></ul><p>这些操作可能由集群管理员直接执行，也可能由集群管理员所使用的自动化工具执行，或者由集群托管提供商自动执行。</p><p>咨询集群管理员或联系云提供商，或者查询发布文档，以确定是否为集群启用了任何资源干扰源。
如果没有启用，可以不用创建 Pod Disruption Budgets（Pod 干扰预算）</p><div class="alert alert-warning caution callout" role=alert><strong>注意：</strong> 并非所有的自愿干扰都会受到 Pod 干扰预算的限制。
例如，删除 Deployment 或 Pod 的删除操作就会跳过 Pod 干扰预算检查。</div><h2 id=处理干扰>处理干扰</h2><p>以下是减轻非自愿干扰的一些方法：</p><ul><li>确保 Pod 在请求中给出<a href=/zh-cn/docs/tasks/configure-pod-container/assign-memory-resource/>所需资源</a>。</li><li>如果需要更高的可用性，请复制应用。
（了解有关运行多副本的<a href=/zh-cn/docs/tasks/run-application/run-stateless-application-deployment/>无状态</a>
和<a href=/zh-cn/docs/tasks/run-application/run-replicated-stateful-application/>有状态</a>应用的信息。）</li><li>为了在运行复制应用时获得更高的可用性，请跨机架（使用
<a href=/zh-cn/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity>反亲和性</a>
或跨区域（如果使用<a href=/zh-cn/docs/setup/best-practices/multiple-zones/>多区域集群</a>）扩展应用。</li></ul><p>自愿干扰的频率各不相同。在一个基本的 Kubernetes 集群中，没有自愿干扰（只有用户触发的干扰）。
然而，集群管理员或托管提供商可能运行一些可能导致自愿干扰的额外服务。例如，节点软
更新可能导致自愿干扰。另外，集群（节点）自动缩放的某些
实现可能导致碎片整理和紧缩节点的自愿干扰。集群
管理员或托管提供商应该已经记录了各级别的自愿干扰（如果有的话）。
有些配置选项，例如在 pod spec 中
<a href=/zh-cn/docs/concepts/scheduling-eviction/pod-priority-preemption/>使用 PriorityClasses</a>
也会产生自愿（和非自愿）的干扰。</p><h2 id=pod-disruption-budgets>干扰预算</h2><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.21 [stable]</code></div><p>即使你会经常引入自愿性干扰，Kubernetes 提供的功能也能够支持你运行高度可用的应用。</p><p>作为一个应用的所有者，你可以为每个应用创建一个 <code>PodDisruptionBudget</code>（PDB）。
PDB 将限制在同一时间因自愿干扰导致的多副本应用中发生宕机的 Pod 数量。
例如，基于票选机制的应用希望确保运行中的副本数永远不会低于票选所需的数量。
Web 前端可能希望确保提供负载的副本数量永远不会低于总数的某个百分比。</p><p>集群管理员和托管提供商应该使用遵循 PodDisruptionBudgets 的接口
（通过调用<a href=/zh-cn/docs/tasks/administer-cluster/safely-drain-node/#the-eviction-api>Eviction API</a>），
而不是直接删除 Pod 或 Deployment。</p><p>例如，<code>kubectl drain</code> 命令可以用来标记某个节点即将停止服务。
运行 <code>kubectl drain</code> 命令时，工具会尝试驱逐你所停服的节点上的所有 Pod。
<code>kubectl</code> 代表你所提交的驱逐请求可能会暂时被拒绝，
所以该工具会周期性地重试所有失败的请求，
直到目标节点上的所有的 Pod 都被终止，或者达到配置的超时时间。</p><p>PDB 指定应用可以容忍的副本数量（相当于应该有多少副本）。
例如，具有 <code>.spec.replicas: 5</code> 的 Deployment 在任何时间都应该有 5 个 Pod。
如果 PDB 允许其在某一时刻有 4 个副本，那么驱逐 API 将允许同一时刻仅有一个（而不是两个）Pod 自愿干扰。</p><p>使用标签选择器来指定构成应用的一组 Pod，这与应用的控制器（Deployment，StatefulSet 等）
选择 Pod 的逻辑一样。</p><p>Pod 的“预期”数量由管理这些 Pod 的工作负载资源的 <code>.spec.replicas</code> 参数计算出来的。
控制平面通过检查 Pod 的
<code>.metadata.ownerReferences</code> 来发现关联的工作负载资源。</p><p>PDB 无法防止<a href=#voluntary-and-involuntary-disruptions>非自愿干扰</a>；
但它们确实计入预算。</p><p>由于应用的滚动升级而被删除或不可用的 Pod 确实会计入干扰预算，
但是工作负载资源（如 Deployment 和 StatefulSet）
在进行滚动升级时不受 PDB 的限制。
应用更新期间的故障处理方式是在对应的工作负载资源的 <code>spec</code> 中配置的。</p><p>当使用驱逐 API 驱逐 Pod 时，Pod 会被体面地
<a href=/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination>终止</a>，期间会
参考 <a href=/docs/reference/generated/kubernetes-api/v1.25/#podspec-v1-core>PodSpec</a>
中的 <code>terminationGracePeriodSeconds</code> 配置值。</p><h2 id=pdb-example>PodDisruptionBudget 例子</h2><p>假设集群有 3 个节点，<code>node-1</code> 到 <code>node-3</code>。集群上运行了一些应用。
其中一个应用有 3 个副本，分别是 <code>pod-a</code>，<code>pod-b</code> 和 <code>pod-c</code>。
另外，还有一个不带 PDB 的无关 pod <code>pod-x</code> 也同样显示出来。
最初，所有的 Pod 分布如下：</p><table><thead><tr><th style=text-align:center>node-1</th><th style=text-align:center>node-2</th><th style=text-align:center>node-3</th></tr></thead><tbody><tr><td style=text-align:center>pod-a <em>available</em></td><td style=text-align:center>pod-b <em>available</em></td><td style=text-align:center>pod-c <em>available</em></td></tr><tr><td style=text-align:center>pod-x <em>available</em></td><td style=text-align:center></td><td style=text-align:center></td></tr></tbody></table><p>3 个 Pod 都是 deployment 的一部分，并且共同拥有同一个 PDB，要求 3 个 Pod 中至少有 2 个 Pod 始终处于可用状态。</p><p>例如，假设集群管理员想要重启系统，升级内核版本来修复内核中的缺陷。
集群管理员首先使用 <code>kubectl drain</code> 命令尝试腾空 <code>node-1</code> 节点。
命令尝试驱逐 <code>pod-a</code> 和 <code>pod-x</code>。操作立即就成功了。
两个 Pod 同时进入 <code>terminating</code> 状态。这时的集群处于下面的状态：</p><table><thead><tr><th style=text-align:center>node-1 <em>draining</em></th><th style=text-align:center>node-2</th><th style=text-align:center>node-3</th></tr></thead><tbody><tr><td style=text-align:center>pod-a <em>terminating</em></td><td style=text-align:center>pod-b <em>available</em></td><td style=text-align:center>pod-c <em>available</em></td></tr><tr><td style=text-align:center>pod-x <em>terminating</em></td><td style=text-align:center></td><td style=text-align:center></td></tr></tbody></table><p>Deployment 控制器观察到其中一个 Pod 正在终止，因此它创建了一个替代 Pod <code>pod-d</code>。
由于 <code>node-1</code> 被封锁（cordon），<code>pod-d</code> 落在另一个节点上。
同样其他控制器也创建了 <code>pod-y</code> 作为 <code>pod-x</code> 的替代品。</p><p>（注意：对于 StatefulSet 来说，<code>pod-a</code>（也称为 <code>pod-0</code>）需要在替换 Pod 创建之前完全终止，
替代它的也称为 <code>pod-0</code>，但是具有不同的 UID。除此之外，此示例也适用于 StatefulSet。）</p><p>当前集群的状态如下：</p><table><thead><tr><th style=text-align:center>node-1 <em>draining</em></th><th style=text-align:center>node-2</th><th style=text-align:center>node-3</th></tr></thead><tbody><tr><td style=text-align:center>pod-a <em>terminating</em></td><td style=text-align:center>pod-b <em>available</em></td><td style=text-align:center>pod-c <em>available</em></td></tr><tr><td style=text-align:center>pod-x <em>terminating</em></td><td style=text-align:center>pod-d <em>starting</em></td><td style=text-align:center>pod-y</td></tr></tbody></table><p>在某一时刻，Pod 被终止，集群如下所示：</p><table><thead><tr><th style=text-align:center>node-1 <em>drained</em></th><th style=text-align:center>node-2</th><th style=text-align:center>node-3</th></tr></thead><tbody><tr><td style=text-align:center></td><td style=text-align:center>pod-b <em>available</em></td><td style=text-align:center>pod-c <em>available</em></td></tr><tr><td style=text-align:center></td><td style=text-align:center>pod-d <em>starting</em></td><td style=text-align:center>pod-y</td></tr></tbody></table><p>此时，如果一个急躁的集群管理员试图排空（drain）<code>node-2</code> 或 <code>node-3</code>，drain 命令将被阻塞，
因为对于 Deployment 来说只有 2 个可用的 Pod，并且它的 PDB 至少需要 2 个。
经过一段时间，<code>pod-d</code> 变得可用。</p><p>集群状态如下所示：</p><table><thead><tr><th style=text-align:center>node-1 <em>drained</em></th><th style=text-align:center>node-2</th><th style=text-align:center>node-3</th></tr></thead><tbody><tr><td style=text-align:center></td><td style=text-align:center>pod-b <em>available</em></td><td style=text-align:center>pod-c <em>available</em></td></tr><tr><td style=text-align:center></td><td style=text-align:center>pod-d <em>available</em></td><td style=text-align:center>pod-y</td></tr></tbody></table><p>现在，集群管理员试图排空（drain）<code>node-2</code>。
drain 命令将尝试按照某种顺序驱逐两个 Pod，假设先是 <code>pod-b</code>，然后是 <code>pod-d</code>。
命令成功驱逐 <code>pod-b</code>，但是当它尝试驱逐 <code>pod-d</code>时将被拒绝，因为对于
Deployment 来说只剩一个可用的 Pod 了。</p><p>Deployment 创建 <code>pod-b</code> 的替代 Pod <code>pod-e</code>。
因为集群中没有足够的资源来调度 <code>pod-e</code>，drain 命令再次阻塞。集群最终将是下面这种状态：</p><table><thead><tr><th style=text-align:center>node-1 <em>drained</em></th><th style=text-align:center>node-2</th><th style=text-align:center>node-3</th><th style=text-align:center><em>no node</em></th></tr></thead><tbody><tr><td style=text-align:center></td><td style=text-align:center>pod-b <em>terminating</em></td><td style=text-align:center>pod-c <em>available</em></td><td style=text-align:center>pod-e <em>pending</em></td></tr><tr><td style=text-align:center></td><td style=text-align:center>pod-d <em>available</em></td><td style=text-align:center>pod-y</td><td style=text-align:center></td></tr></tbody></table><p>此时，集群管理员需要增加一个节点到集群中以继续升级操作。</p><p>可以看到 Kubernetes 如何改变干扰发生的速率，根据：</p><ul><li>应用需要多少个副本</li><li>优雅关闭应用实例需要多长时间</li><li>启动应用新实例需要多长时间</li><li>控制器的类型</li><li>集群的资源能力</li></ul><h2 id=pod-disruption-conditions>Pod 干扰状况</h2><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.25 [alpha]</code></div><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>要使用此行为，你必须在集群中启用 <code>PodDisruptionCondition</code>
<a href=/zh-cn/docs/reference/command-line-tools-reference/feature-gates/>特性门控</a>。</div><p>启用后，会给 Pod 添加一个 <code>DisruptionTarget</code>
<a href=/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#pod-conditions>状况</a>，
用来表明该 Pod 因为发生<a class=glossary-tooltip title='导致 Pod 服务停止的事件。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/workloads/pods/disruptions/ target=_blank aria-label=干扰>干扰</a>而被删除。
状况中的 <code>reason</code> 字段进一步给出 Pod 终止的原因，如下：</p><dl><dt><code>PreemptionByKubeScheduler</code></dt><dd>Pod 将被调度器<a class=glossary-tooltip title='Kubernetes 中的抢占逻辑通过驱逐节点上的低优先级 Pod 来帮助悬决的 Pod 找到合适的节点。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/scheduling-eviction/pod-priority-preemption/#preemption target=_blank aria-label=抢占>抢占</a>，
目的是接受优先级更高的新 Pod。
要了解更多的相关信息，请参阅 <a href=/zh-cn/docs/concepts/scheduling-eviction/pod-priority-preemption/>Pod 优先级和抢占</a>。</dd></dl><dl><dt><code>DeletionByTaintManager</code></dt><dd>由于 Pod 不能容忍 <code>NoExecute</code> 污点，Pod 将被
Taint Manager（<code>kube-controller-manager</code> 中节点生命周期控制器的一部分）删除；
请参阅基于<a class=glossary-tooltip title='污点是一种一个核心对象，包含三个必需的属性：key、value 和 effect。 污点会阻止在节点或节点组上调度 Pod。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/scheduling-eviction/taint-and-toleration/ target=_blank aria-label=污点>污点</a>的驱逐。</dd></dl><dl><dt><code>EvictionByEvictionAPI</code></dt><dd>Pod 已被标记为<a class=glossary-tooltip title='API 发起的驱逐是一个先调用 Eviction API 创建驱逐对象，再由该对象体面地中止 Pod 的过程。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/scheduling-eviction/api-eviction/ target=_blank aria-label='通过 Kubernetes API 驱逐'>通过 Kubernetes API 驱逐</a>。</dd></dl><dl><dt><code>DeletionByPodGC</code></dt><dd>绑定到一个不再存在的 Node 上的 Pod 将被
<a href=/zh-cn/docs/concepts/workloads/pods/pod-lifecycle/#pod-garbage-collection>Pod 垃圾收集</a>删除。</dd></dl><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>Pod 的干扰可能会被中断。控制平面可能会重新尝试继续干扰同一个 Pod，但这没办法保证。
因此，<code>DisruptionTarget</code> 条件可能会添被加到 Pod 上，
但该 Pod 实际上可能不会被删除。
在这种情况下，一段时间后，Pod 干扰状况将被清除。</div><p>使用 Job（或 CronJob）时，你可能希望将这些 Pod 干扰状况作为 Job
<a href=/zh-cn/docs/concepts/workloads/controllers/job#pod-failure-policy>Pod 失效策略</a>的一部分。</p><h2 id=分离集群所有者和应用所有者角色>分离集群所有者和应用所有者角色</h2><p>通常，将集群管理者和应用所有者视为彼此了解有限的独立角色是很有用的。这种责任分离在下面这些场景下是有意义的：</p><ul><li>当有许多应用团队共用一个 Kubernetes 集群，并且有自然的专业角色</li><li>当第三方工具或服务用于集群自动化管理</li></ul><p>Pod 干扰预算通过在角色之间提供接口来支持这种分离。</p><p>如果你的组织中没有这样的责任分离，则可能不需要使用 Pod 干扰预算。</p><h2 id=如何在集群上执行干扰性操作>如何在集群上执行干扰性操作</h2><p>如果你是集群管理员，并且需要对集群中的所有节点执行干扰操作，例如节点或系统软件升级，则可以使用以下选项</p><ul><li>接受升级期间的停机时间。</li><li>故障转移到另一个完整的副本集群。<ul><li>没有停机时间，但是对于重复的节点和人工协调成本可能是昂贵的。</li></ul></li><li>编写可容忍干扰的应用和使用 PDB。<ul><li>不停机。</li><li>最小的资源重复。</li><li>允许更多的集群管理自动化。</li><li>编写可容忍干扰的应用是棘手的，但对于支持容忍自愿干扰所做的工作，和支持自动扩缩和容忍非
自愿干扰所做工作相比，有大量的重叠</li></ul></li></ul><h2 id=接下来>接下来</h2><ul><li><p>参考<a href=/zh-cn/docs/tasks/run-application/configure-pdb/>配置 Pod 干扰预算</a>中的方法来保护你的应用。</p></li><li><p>进一步了解<a href=/zh-cn/docs/tasks/administer-cluster/safely-drain-node/>排空节点</a>的信息。</p></li><li><p>了解<a href=/zh-cn/docs/concepts/workloads/controllers/deployment/#updating-a-deployment>更新 Deployment</a>
的过程，包括如何在其进程中维持应用的可用性</p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-53a1005011e1bda2ce81819aad7c8b32>4 - 临时容器</h1><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.25 [stable]</code></div><p>本页面概述了临时容器：一种特殊的容器，该容器在现有
<a class=glossary-tooltip title='Pod 表示你的集群上一组正在运行的容器。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/workloads/pods/ target=_blank aria-label=Pod>Pod</a>
中临时运行，以便完成用户发起的操作，例如故障排查。
你会使用临时容器来检查服务，而不是用它来构建应用程序。</p><h2 id=understanding-ephemeral-containers>了解临时容器</h2><p><a class=glossary-tooltip title='Pod 表示你的集群上一组正在运行的容器。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/workloads/pods/ target=_blank aria-label=Pod>Pod</a> 是 Kubernetes 应用程序的基本构建块。
由于 Pod 是一次性且可替换的，因此一旦 Pod 创建，就无法将容器加入到 Pod 中。
取而代之的是，通常使用 <a class=glossary-tooltip title=管理集群上的多副本应用。 data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Deployment>Deployment</a>
以受控的方式来删除并替换 Pod。</p><p>有时有必要检查现有 Pod 的状态。例如，对于难以复现的故障进行排查。
在这些场景中，可以在现有 Pod 中运行临时容器来检查其状态并运行任意命令。</p><h3 id=what-is-an-ephemeral-container>什么是临时容器？</h3><p>临时容器与其他容器的不同之处在于，它们缺少对资源或执行的保证，并且永远不会自动重启，
因此不适用于构建应用程序。
临时容器使用与常规容器相同的 <code>ContainerSpec</code> 节来描述，但许多字段是不兼容和不允许的。</p><ul><li>临时容器没有端口配置，因此像 <code>ports</code>，<code>livenessProbe</code>，<code>readinessProbe</code>
这样的字段是不允许的。</li><li>Pod 资源分配是不可变的，因此 <code>resources</code> 配置是不允许的。</li><li>有关允许字段的完整列表，请参见
<a href=/docs/reference/generated/kubernetes-api/v1.25/#ephemeralcontainer-v1-core>EphemeralContainer 参考文档</a>。</li></ul><p>临时容器是使用 API 中的一种特殊的 <code>ephemeralcontainers</code> 处理器进行创建的，
而不是直接添加到 <code>pod.spec</code> 段，因此无法使用 <code>kubectl edit</code> 来添加一个临时容器。</p><p>与常规容器一样，将临时容器添加到 Pod 后，将不能更改或删除临时容器。</p><h2 id=uses-for-ephemeral-containers>临时容器的用途</h2><p>当由于容器崩溃或容器镜像不包含调试工具而导致 <code>kubectl exec</code> 无用时，
临时容器对于交互式故障排查很有用。</p><p>尤其是，<a href=https://github.com/GoogleContainerTools/distroless>Distroless 镜像</a>
允许用户部署最小的容器镜像，从而减少攻击面并减少故障和漏洞的暴露。
由于 distroless 镜像不包含 Shell 或任何的调试工具，因此很难单独使用
<code>kubectl exec</code> 命令进行故障排查。</p><p>使用临时容器时，启用
<a href=/zh-cn/docs/tasks/configure-pod-container/share-process-namespace/>进程名字空间共享</a>
很有帮助，可以查看其他容器中的进程。</p><p>接下来</p><ul><li>了解如何<a href=/zh-cn/docs/tasks/debug/debug-application/debug-running-pod/#ephemeral-container>使用临时调试容器来进行调试</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-420713565efe2f940e277f6b4824ad9a>5 - Downward API</h1><div class=lead>有两种方法可以将 Pod 和容器字段暴露给运行中的容器：环境变量和由特殊卷类型承载的文件。 这两种暴露 Pod 和容器字段的方法统称为 Downward API。</div><p>对于容器来说，在不与 Kubernetes 过度耦合的情况下，拥有关于自身的信息有时是很有用的。
<strong>Downward API</strong> 允许容器在不使用 Kubernetes 客户端或 API 服务器的情况下获得自己或集群的信息。</p><p>例如，现有应用程序假设某特定的周知的环境变量是存在的，其中包含唯一标识符。
一种方法是对应用程序进行封装，但这很繁琐且容易出错，并且违背了低耦合的目标。
更好的选择是使用 Pod 名称作为标识符，并将 Pod 名称注入到周知的环境变量中。</p><p>在 Kubernetes 中，有两种方法可以将 Pod 和容器字段暴露给运行中的容器：</p><ul><li>作为<a href=/zh-cn/docs/tasks/inject-data-application/environment-variable-expose-pod-information/>环境变量</a></li><li>作为 <a href=/zh-cn/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information/><code>downwardAPI</code> 卷中的文件</a></li></ul><p>这两种暴露 Pod 和容器字段的方式统称为 <strong>Downward API</strong>。</p><h2 id=available-fields>可用字段</h2><p>只有部分 Kubernetes API 字段可以通过 Downward API 使用。本节列出了你可以使用的字段。</p><p>你可以使用 <code>fieldRef</code> 传递来自可用的 Pod 级字段的信息。在 API 层面，一个 Pod 的
<code>spec</code> 总是定义了至少一个 <a href=/zh-cn/docs/reference/kubernetes-api/workload-resources/pod-v1/#Container>Container</a>。
你可以使用 <code>resourceFieldRef</code> 传递来自可用的 Container 级字段的信息。</p><h3 id=downwardapi-fieldRef>可通过 <code>fieldRef</code> 获得的信息</h3><p>对于大多数 Pod 级别的字段，你可以将它们作为环境变量或使用 <code>downwardAPI</code> 卷提供给容器。
通过这两种机制可用的字段有：</p><dl><dt><code>metadata.name</code></dt><dd>Pod 的名称</dd></dl><dl><dt><code>metadata.namespace</code></dt><dd>Pod 的<a class=glossary-tooltip title='名字空间是 Kubernetes 用来支持隔离单个集群中的资源组的一种抽象。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/overview/working-with-objects/namespaces/ target=_blank aria-label=命名空间>命名空间</a></dd></dl><dl><dt><code>metadata.uid</code></dt><dd>Pod 的唯一 ID</dd></dl><dl><dt><code>metadata.annotations['&lt;KEY>']</code></dt><dd>Pod 的<a class=glossary-tooltip title=注解是以键值对的形式给资源对象附加随机的无法标识的元数据。 data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/overview/working-with-objects/annotations/ target=_blank aria-label=注解>注解</a> <code>&lt;KEY></code> 的值（例如：<code>metadata.annotations['myannotation']</code>）</dd></dl><dl><dt><code>metadata.labels['&lt;KEY>']</code></dt><dd>Pod 的<a class=glossary-tooltip title=用来为对象设置可标识的属性标记；这些标记对用户而言是有意义且重要的。 data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/overview/working-with-objects/labels/ target=_blank aria-label=标签>标签</a> <code>&lt;KEY></code> 的值（例如：<code>metadata.labels['mylabel']</code>）</dd></dl><dl><dt><code>spec.serviceAccountName</code></dt><dd>Pod 的<a class=glossary-tooltip title='为在 Pod 中运行的进程提供标识。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/tasks/configure-pod-container/configure-service-account/ target=_blank aria-label=服务账号>服务账号</a>名称</dd></dl><dl><dt><code>spec.nodeName</code></dt><dd>Pod 运行时所处的<a class=glossary-tooltip title='Kubernetes 中的工作机器称作节点。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/architecture/nodes/ target=_blank aria-label=节点>节点</a>名称</dd></dl><dl><dt><code>status.hostIP</code></dt><dd>Pod 所在节点的主 IP 地址</dd></dl><dl><dt><code>status.podIP</code></dt><dd>Pod 的主 IP 地址（通常是其 IPv4 地址）</dd></dl><p>此外，以下信息可以通过 <code>downwardAPI</code> 卷 <code>fieldRef</code> 获得，但<strong>不能作为环境变量</strong>获得：</p><dl><dt><code>metadata.labels</code></dt><dd>Pod 的所有标签，格式为 <code>标签键名="转义后的标签值"</code>，每行一个标签</dd></dl><dl><dt><code>metadata.annotations</code></dt><dd>Pod 的全部注解，格式为 <code>注解键名="转义后的注解值"</code>，每行一个注解</dd></dl><h3 id=downwardapi-resourceFieldRef>可通过 <code>resourceFieldRef</code> 获得的信息</h3><dl><dt><code>resource: limits.cpu</code></dt><dd>容器的 CPU 限制值</dd></dl><dl><dt><code>resource: requests.cpu</code></dt><dd>容器的 CPU 请求值</dd></dl><dl><dt><code>resource: limits.memory</code></dt><dd>容器的内存限制值</dd></dl><dl><dt><code>resource: requests.memory</code></dt><dd>容器的内存请求值</dd></dl><dl><dt><code>resource: limits.hugepages-*</code></dt><dd>容器的巨页限制值（前提是启用了 <code>DownwardAPIHugePages</code>
<a href=/zh-cn/docs/reference/command-line-tools-reference/feature-gates/>特性门控</a>）</dd></dl><dl><dt><code>resource: requests.hugepages-*</code></dt><dd>容器的巨页请求值（前提是启用了 <code>DownwardAPIHugePages</code>
<a href=/zh-cn/docs/reference/command-line-tools-reference/feature-gates/>特性门控</a>）</dd></dl><dl><dt><code>resource: limits.ephemeral-storage</code></dt><dd>容器的临时存储的限制值</dd></dl><dl><dt><code>resource: requests.ephemeral-storage</code></dt><dd>容器的临时存储的请求值</dd></dl><h4 id=fallback-information-for-resource-limits>资源限制的后备信息</h4><p>如果没有为容器指定 CPU 和内存限制时尝试使用 Downward API 暴露该信息，那么 kubelet 默认会根据
<a href=/zh-cn/docs/tasks/administer-cluster/reserve-compute-resources/#node-allocatable>节点可分配资源</a>
计算并暴露 CPU 和内存的最大可分配值。</p><h2 id=接下来>接下来</h2><p>你可以阅读有关 <a href=/zh-cn/docs/concepts/storage/volumes/#downwardapi><code>downwardAPI</code> 卷</a>的内容。</p><p>你可以尝试使用 Downward API 暴露容器或 Pod 级别的信息：</p><ul><li>作为<a href=/zh-cn/docs/tasks/inject-data-application/environment-variable-expose-pod-information/>环境变量</a></li><li>作为 <a href=/zh-cn/docs/tasks/inject-data-application/downward-api-volume-expose-pod-information/><code>downwardAPI</code> 卷中的文件</a></li></ul></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/zh-cn/docs/home/>主页</a>
<a class=text-white href=/zh-cn/blog/>博客</a>
<a class=text-white href=/zh-cn/training/>培训</a>
<a class=text-white href=/zh-cn/partners/>合作伙伴</a>
<a class=text-white href=/zh-cn/community/>社区</a>
<a class=text-white href=/zh-cn/case-studies/>案例分析</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 The Kubernetes 作者 | 文档发布基于 <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a> 授权许可</small><br><small class=text-white>Copyright &copy; 2023 Linux 基金会&reg;。保留所有权利。Linux 基金会已注册并使用商标。如需了解 Linux 基金会的商标列表，请访问<a href=https://www.linuxfoundation.org/trademark-usage class=light-text>商标使用页面</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script>
<script async src=/js/sweetalert-2.1.2.min.js></script>
<script type=text/javascript>function copyCode(e){if(document.getElementById(e)){var t,n,s="_hiddenCopyText_";t=document.getElementById(s),t||(t=document.createElement("textarea"),t.style.position="absolute",t.style.left="-9999px",t.style.top="0",t.id=s,document.body.appendChild(t)),t.value=document.getElementById(e).innerText,t.select();try{n=document.execCommand("copy")}catch{swal("Oh, no…","Sorry, your browser doesn't support copying this example to your clipboard."),n=!1}return n?(swal("Copied to clipboard: ",e),n):(swal("Oops!",e+" not found when trying to copy code"),!1)}}</script></body></html>