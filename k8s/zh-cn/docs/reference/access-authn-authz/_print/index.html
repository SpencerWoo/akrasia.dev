<!doctype html><html lang=zh-cn class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=en href=https://kubernetes.io/docs/reference/access-authn-authz/><link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/reference/access-authn-authz/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/reference/access-authn-authz/><link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/reference/access-authn-authz/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/reference/access-authn-authz/><link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/reference/access-authn-authz/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>API 访问控制 | Kubernetes</title><meta property="og:title" content="API 访问控制"><meta property="og:description" content="生产级别的容器编排系统"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="API 访问控制"><meta itemprop=description content="生产级别的容器编排系统"><meta name=twitter:card content="summary"><meta name=twitter:title content="API 访问控制"><meta name=twitter:description content="生产级别的容器编排系统"><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content=" 关于 Kubernetes 如何实现和控制 API 访问的介绍性材料， 可阅读控制 Kubernetes API 的访问。
参考文档：
身份认证 使用启动引导令牌来执行身份认证 准入控制器 动态准入控制 鉴权与授权 基于角色的访问控制 基于属性的访问控制 节点鉴权 Webhook 鉴权 证书签名请求 包含 CSR 的批复 和证书签名 服务账号 开发者指南 管理文档 Kubelet 认证和鉴权 包括 kubelet TLS 启动引导 "><meta property="og:description" content=" 关于 Kubernetes 如何实现和控制 API 访问的介绍性材料， 可阅读控制 Kubernetes API 的访问。
参考文档：
身份认证 使用启动引导令牌来执行身份认证 准入控制器 动态准入控制 鉴权与授权 基于角色的访问控制 基于属性的访问控制 节点鉴权 Webhook 鉴权 证书签名请求 包含 CSR 的批复 和证书签名 服务账号 开发者指南 管理文档 Kubelet 认证和鉴权 包括 kubelet TLS 启动引导 "><meta name=twitter:description content=" 关于 Kubernetes 如何实现和控制 API 访问的介绍性材料， 可阅读控制 Kubernetes API 的访问。
参考文档：
身份认证 使用启动引导令牌来执行身份认证 准入控制器 动态准入控制 鉴权与授权 基于角色的访问控制 基于属性的访问控制 节点鉴权 Webhook 鉴权 证书签名请求 包含 CSR 的批复 和证书签名 服务账号 开发者指南 管理文档 Kubelet 认证和鉴权 包括 kubelet TLS 启动引导 "><meta property="og:url" content="https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/"><meta property="og:title" content="API 访问控制"><meta name=twitter:title content="API 访问控制"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/zh-cn/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/zh-cn/docs/>文档</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/zh-cn/blog/>Kubernetes 博客</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/zh-cn/training/>培训</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/zh-cn/partners/>合作伙伴</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/zh-cn/community/>社区</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/zh-cn/case-studies/>案例分析</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>版本列表</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/zh-cn/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/zh-cn/docs/reference/access-authn-authz/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/zh-cn/docs/reference/access-authn-authz/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/zh-cn/docs/reference/access-authn-authz/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/zh-cn/docs/reference/access-authn-authz/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/zh-cn/docs/reference/access-authn-authz/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>中文 (Chinese)</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/docs/reference/access-authn-authz/>English</a>
<a class=dropdown-item href=/ko/docs/reference/access-authn-authz/>한국어 (Korean)</a>
<a class=dropdown-item href=/fr/docs/reference/access-authn-authz/>Français (French)</a>
<a class=dropdown-item href=/de/docs/reference/access-authn-authz/>Deutsch (German)</a>
<a class=dropdown-item href=/es/docs/reference/access-authn-authz/>Español (Spanish)</a>
<a class=dropdown-item href=/id/docs/reference/access-authn-authz/>Bahasa Indonesia</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>这是本节的多页打印视图。
<a href=# onclick="return print(),!1">点击此处打印</a>.</p><p><a href=/zh-cn/docs/reference/access-authn-authz/>返回本页常规视图</a>.</p></div><h1 class=title>API 访问控制</h1><ul><li>1: <a href=#pg-a6264859a5ad6e2f4a6e4cff9ce4fa8b>用户认证</a></li><li>2: <a href=#pg-de45b6ca7419a0e308044425b2ac52bb>使用启动引导令牌（Bootstrap Tokens）认证</a></li><li>3: <a href=#pg-3d0c14d1e3cfade38febc343cd044c73>证书签名请求</a></li><li>4: <a href=#pg-518807b9b00bda46d7c7e6e0b17c18f8>准入控制器参考</a></li><li>5: <a href=#pg-d04751f776f1faa6a82bbb7f0a200950>动态准入控制</a></li><li>6: <a href=#pg-bea207258f3576b8ec7444a20d498e1d>管理服务账号</a></li><li>7: <a href=#pg-342be69d36f174f762c36f4fe11fcb20>鉴权概述</a></li><li>8: <a href=#pg-954776b47f2d90515f375623a0ce98e1>使用 RBAC 鉴权</a></li><li>9: <a href=#pg-a5bdc757c01991e5e6ab1a82b90639ea>使用 ABAC 鉴权</a></li><li>10: <a href=#pg-9cbb97d4d9f08d67931a1baae4e6519c>使用 Node 鉴权</a></li><li>11: <a href=#pg-643e4cec52a8577e9454649bdaac84d0>从 PodSecurityPolicy 映射到 Pod 安全性标准</a></li><li>12: <a href=#pg-215c25173044b8f97e9b0494b0c7e53f>Webhook 模式</a></li><li>13: <a href=#pg-36e1423f0b5caa8eafeb6f53c175d13c>Kubelet 认证/鉴权</a></li><li>14: <a href=#pg-d17c42b1760f6d5c333fc91ca9b453f4>TLS 启动引导</a></li></ul><div class=content><p>关于 Kubernetes 如何实现和控制 API 访问的介绍性材料，
可阅读<a href=/zh-cn/docs/concepts/security/controlling-access/>控制 Kubernetes API 的访问</a>。</p><p>参考文档：</p><ul><li><a href=/zh-cn/docs/reference/access-authn-authz/authentication/>身份认证</a><ul><li><a href=/zh-cn/docs/reference/access-authn-authz/bootstrap-tokens/>使用启动引导令牌来执行身份认证</a></li></ul></li><li><a href=/zh-cn/docs/reference/access-authn-authz/admission-controllers/>准入控制器</a><ul><li><a href=/zh-cn/docs/reference/access-authn-authz/extensible-admission-controllers/>动态准入控制</a></li></ul></li><li><a href=/zh-cn/docs/reference/access-authn-authz/authorization/>鉴权与授权</a><ul><li><a href=/zh-cn/docs/reference/access-authn-authz/rbac/>基于角色的访问控制</a></li><li><a href=/zh-cn/docs/reference/access-authn-authz/abac/>基于属性的访问控制</a></li><li><a href=/zh-cn/docs/reference/access-authn-authz/node/>节点鉴权</a></li><li><a href=/zh-cn/docs/reference/access-authn-authz/webhook/>Webhook 鉴权</a></li></ul></li><li><a href=/zh-cn/docs/reference/access-authn-authz/certificate-signing-requests/>证书签名请求</a><ul><li>包含 <a href=/zh-cn/docs/reference/access-authn-authz/certificate-signing-requests/#approval-rejection>CSR 的批复</a>
和<a href=/zh-cn/docs/reference/access-authn-authz/certificate-signing-requests/#signing>证书签名</a></li></ul></li><li>服务账号<ul><li><a href=/zh-cn/docs/tasks/configure-pod-container/configure-service-account/>开发者指南</a></li><li><a href=/zh-cn/docs/reference/access-authn-authz/service-accounts-admin/>管理文档</a></li></ul></li><li><a href=/zh-cn/docs/reference/access-authn-authz/kubelet-authn-authz/>Kubelet 认证和鉴权</a><ul><li>包括 kubelet <a href=/zh-cn/docs/reference/access-authn-authz/kubelet-tls-bootstrapping/>TLS 启动引导</a></li></ul></li></ul></div></div><div class=td-content style=page-break-before:always><h1 id=pg-a6264859a5ad6e2f4a6e4cff9ce4fa8b>1 - 用户认证</h1><p>本页提供身份认证有关的概述。</p><h2 id=users-in-kubernetes>Kubernetes 中的用户</h2><p>所有 Kubernetes 集群都有两类用户：由 Kubernetes 管理的服务账号和普通用户。</p><p>Kubernetes 假定普通用户是由一个与集群无关的服务通过以下方式之一进行管理的：</p><ul><li>负责分发私钥的管理员</li><li>类似 Keystone 或者 Google Accounts 这类用户数据库</li><li>包含用户名和密码列表的文件</li></ul><p>有鉴于此，<strong>Kubernetes 并不包含用来代表普通用户账号的对象</strong>。
普通用户的信息无法通过 API 调用添加到集群中。</p><p>尽管无法通过 API 调用来添加普通用户，
Kubernetes 仍然认为能够提供由集群的证书机构签名的合法证书的用户是通过身份认证的用户。
基于这样的配置，Kubernetes 使用证书中的 'subject' 的通用名称（Common Name）字段
（例如，"/CN=bob"）来确定用户名。
接下来，基于角色访问控制（RBAC）子系统会确定用户是否有权针对某资源执行特定的操作。
进一步的细节可参阅<a href=/zh-cn/docs/reference/access-authn-authz/certificate-signing-requests/#normal-user>证书请求</a>
下普通用户主题。</p><p>与此不同，服务账号是 Kubernetes API 所管理的用户。它们被绑定到特定的名字空间，
或者由 API 服务器自动创建，或者通过 API 调用创建。服务账号与一组以 Secret
保存的凭据相关，这些凭据会被挂载到 Pod 中，从而允许集群内的进程访问 Kubernetes API。</p><p>API 请求则或者与某普通用户相关联，或者与某服务账号相关联，
亦或者被视作<a href=#anonymous-requests>匿名请求</a>。这意味着集群内外的每个进程在向 API
服务器发起请求时都必须通过身份认证，否则会被视作匿名用户。这里的进程可以是在某工作站上输入
<code>kubectl</code> 命令的操作人员，也可以是节点上的 <code>kubelet</code> 组件，还可以是控制面的成员。</p><h2 id=authentication-strategies>身份认证策略</h2><p>Kubernetes 通过身份认证插件利用客户端证书、持有者令牌（Bearer Token）或身份认证代理（Proxy）
来认证 API 请求的身份。HTTP 请求发给 API 服务器时，插件会将以下属性关联到请求本身：</p><ul><li>用户名：用来辩识最终用户的字符串。常见的值可以是 <code>kube-admin</code> 或 <code>jane@example.com</code>。</li><li>用户 ID：用来辩识最终用户的字符串，旨在比用户名有更好的一致性和唯一性。</li><li>用户组：取值为一组字符串，其中各个字符串用来标明用户是某个命名的用户逻辑集合的成员。
常见的值可能是 <code>system:masters</code> 或者 <code>devops-team</code> 等。</li><li>附加字段：一组额外的键-值映射，键是字符串，值是一组字符串；
用来保存一些鉴权组件可能觉得有用的额外信息。</li></ul><p>所有（属性）值对于身份认证系统而言都是不透明的，
只有被<a href=/zh-cn/docs/reference/access-authn-authz/authorization/>鉴权组件</a>解释过之后才有意义。</p><p>你可以同时启用多种身份认证方法，并且你通常会至少使用两种方法：</p><ul><li>针对服务账号使用服务账号令牌</li><li>至少另外一种方法对用户的身份进行认证</li></ul><p>当集群中启用了多个身份认证模块时，第一个成功地对请求完成身份认证的模块会直接做出评估决定。
API 服务器并不保证身份认证模块的运行顺序。</p><p>对于所有通过身份认证的用户，<code>system:authenticated</code> 组都会被添加到其组列表中。</p><p>与其它身份认证协议（LDAP、SAML、Kerberos、X509 的替代模式等等）
都可以通过使用一个<a href=#authenticating-proxy>身份认证代理</a>或<a href=#webhook-token-authentication>身份认证 Webhoook</a>
来实现。</p><h3 id=x509-client-certs>X509 客户证书</h3><p>通过给 API 服务器传递 <code>--client-ca-file=SOMEFILE</code> 选项，就可以启动客户端证书身份认证。
所引用的文件必须包含一个或者多个证书机构，用来验证向 API 服务器提供的客户端证书。
如果提供了客户端证书并且证书被验证通过，则 subject 中的公共名称（Common Name）
就被作为请求的用户名。
自 Kubernetes 1.4 开始，客户端证书还可以通过证书的 organization 字段标明用户的组成员信息。
要包含用户的多个组成员信息，可以在证书中包含多个 organization 字段。</p><p>例如，使用 <code>openssl</code> 命令行工具生成一个证书签名请求：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>openssl req -new -key jbeda.pem -out jbeda-csr.pem -subj <span style=color:#b44>&#34;/CN=jbeda/O=app1/O=app2&#34;</span>
</span></span></code></pre></div><p>此命令将使用用户名 <code>jbeda</code> 生成一个证书签名请求（CSR），且该用户属于 "app1" 和
"app2" 两个用户组。</p><p>参阅<a href=/zh-cn/docs/tasks/administer-cluster/certificates/>管理证书</a>了解如何生成客户端证书。</p><h3 id=static-token-file>静态令牌文件</h3><p>当 API 服务器的命令行设置了 <code>--token-auth-file=SOMEFILE</code> 选项时，会从文件中读取持有者令牌。
目前，令牌会长期有效，并且在不重启 API 服务器的情况下无法更改令牌列表。</p><p>令牌文件是一个 CSV 文件，包含至少 3 个列：令牌、用户名和用户的 UID。
其余列被视为可选的组名。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>如果要设置的组名不止一个，则对应的列必须用双引号括起来，例如：</p><pre tabindex=0><code class=language-conf data-lang=conf>token,user,uid,&#34;group1,group2,group3&#34;
</code></pre></div><h4 id=putting-a-bearer-token-in-a-request>在请求中放入持有者令牌</h4><p>当使用持有者令牌来对某 HTTP 客户端执行身份认证时，API 服务器希望看到一个名为
<code>Authorization</code> 的 HTTP 头，其值格式为 <code>Bearer &lt;token></code>。
持有者令牌必须是一个可以放入 HTTP 头部值字段的字符序列，至多可使用 HTTP 的编码和引用机制。
例如：如果持有者令牌为 <code>31ada4fd-adec-460c-809a-9e56ceb75269</code>，则其出现在 HTTP 头部时如下所示：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=display:flex><span><span>Authorization: Bearer 31ada4fd-adec-460c-809a-9e56ceb75269
</span></span></span></code></pre></div><h3 id=bootstrap-tokens>启动引导令牌</h3><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.18 [stable]</code></div><p>为了支持平滑地启动引导新的集群，Kubernetes 包含了一种动态管理的持有者令牌类型，
称作 <strong>启动引导令牌（Bootstrap Token）</strong>。
这些令牌以 Secret 的形式保存在 <code>kube-system</code> 名字空间中，可以被动态管理和创建。
控制器管理器包含的 <code>TokenCleaner</code> 控制器能够在启动引导令牌过期时将其删除。</p><p>这些令牌的格式为 <code>[a-z0-9]{6}.[a-z0-9]{16}</code>。第一个部分是令牌的 ID；
第二个部分是令牌的 Secret。你可以用如下所示的方式来在 HTTP 头部设置令牌：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=display:flex><span><span>Authorization: Bearer 781292.db7bc3a58fc5f07e
</span></span></span></code></pre></div><p>你必须在 API 服务器上设置 <code>--enable-bootstrap-token-auth</code> 标志来启用基于启动引导令牌的身份认证组件。
你必须通过控制器管理器的 <code>--controllers</code> 标志来启用 TokenCleaner 控制器；
这可以通过类似 <code>--controllers=*,tokencleaner</code> 这种设置来做到。
如果你使用 <code>kubeadm</code> 来启动引导新的集群，该工具会帮你完成这些设置。</p><p>身份认证组件的认证结果为 <code>system:bootstrap:&lt;令牌 ID></code>，该用户属于
<code>system:bootstrappers</code> 用户组。
这里的用户名和组设置都是有意设计成这样，其目的是阻止用户在启动引导集群之后继续使用这些令牌。
这里的用户名和组名可以用来（并且已经被 <code>kubeadm</code> 用来）构造合适的鉴权策略，
以完成启动引导新集群的工作。</p><p>请参阅<a href=/zh-cn/docs/reference/access-authn-authz/bootstrap-tokens/>启动引导令牌</a>，
以了解关于启动引导令牌身份认证组件与控制器的更深入的信息，以及如何使用
<code>kubeadm</code> 来管理这些令牌。</p><h3 id=service-account-tokens>服务账号令牌</h3><p>服务账号（Service Account）是一种自动被启用的用户认证机制，使用经过签名的持有者令牌来验证请求。
该插件可接受两个可选参数：</p><ul><li><code>--service-account-key-file</code> 文件包含 PEM 编码的 x509 RSA 或 ECDSA 私钥或公钥，
用于验证 ServiceAccount 令牌。这样指定的文件可以包含多个密钥，
并且可以使用不同的文件多次指定此参数。若未指定，则使用 --tls-private-key-file 参数。</li><li><code>--service-account-lookup</code> 如果启用，则从 API 删除的令牌会被回收。</li></ul><p>服务账号通常由 API 服务器自动创建并通过 <code>ServiceAccount</code>
<a href=/zh-cn/docs/reference/access-authn-authz/admission-controllers/>准入控制器</a>关联到集群中运行的 Pod 上。
持有者令牌会挂载到 Pod 中可预知的位置，允许集群内进程与 API 服务器通信。
服务账号也可以使用 Pod 规约的 <code>serviceAccountName</code> 字段显式地关联到 Pod 上。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p><code>serviceAccountName</code> 通常会被忽略，因为关联关系是自动建立的。</div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb> </span><span style=color:#080;font-style:italic># 此 apiVersion 从 Kubernetes 1.9 开始可用</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>serviceAccountName</span>:<span style=color:#bbb> </span>bob-the-bot<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span></span></span></code></pre></div><p>在集群外部使用服务账号持有者令牌也是完全合法的，且可用来为长时间运行的、需要与 Kubernetes
API 服务器通信的任务创建标识。要手动创建服务账号，可以使用
<code>kubectl create serviceaccount &lt;名称></code> 命令。
此命令会在当前的名字空间中生成一个服务账号。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl create serviceaccount jenkins
</span></span></code></pre></div><pre tabindex=0><code class=language-none data-lang=none>serviceaccount/jenkins created
</code></pre><p>创建相关联的令牌：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl create token jenkins
</span></span></code></pre></div><pre tabindex=0><code class=language-none data-lang=none>eyJhbGciOiJSUzI1NiIsImtp...
</code></pre><p>所创建的令牌是一个已签名的 JWT 令牌。</p><p>已签名的 JWT 可以用作持有者令牌，并将被认证为所给的服务账号。
关于如何在请求中包含令牌，请参阅<a href=#putting-a-bearer-token-in-a-request>前文</a>。
通常，这些令牌数据会被挂载到 Pod 中以便集群内访问 API 服务器时使用，
不过也可以在集群外部使用。</p><p>服务账号被身份认证后，所确定的用户名为 <code>system:serviceaccount:&lt;名字空间>:&lt;服务账号></code>，
并被分配到用户组 <code>system:serviceaccounts</code> 和 <code>system:serviceaccounts:&lt;名字空间></code>。</p><div class="alert alert-danger warning callout" role=alert><strong>警告：</strong><p>由于服务账号令牌也可以保存在 Secret API 对象中，任何能够写入这些 Secret
的用户都可以请求一个令牌，且任何能够读取这些 Secret 的用户都可以被认证为对应的服务账号。
在为用户授予访问服务账号的权限以及对 Secret 的读取或写入权能时，要格外小心。</div><h3 id=openid-connect-tokens>OpenID Connect（OIDC）令牌</h3><p><a href=https://openid.net/connect/>OpenID Connect</a> 是一种 OAuth2 认证方式，
被某些 OAuth2 提供者支持，例如 Azure 活动目录、Salesforce 和 Google。
协议对 OAuth2 的主要扩充体现在有一个附加字段会和访问令牌一起返回，
这一字段称作 <a href=https://openid.net/specs/openid-connect-core-1_0.html#IDToken>ID Token（ID 令牌）</a>。
ID 令牌是一种由服务器签名的 JWT 令牌，其中包含一些可预知的字段，
例如用户的邮箱地址，</p><p>要识别用户，身份认证组件使用 OAuth2
<a href=https://openid.net/specs/openid-connect-core-1_0.html#TokenResponse>令牌响应</a>中的
<code>id_token</code>（而非 <code>access_token</code>）作为持有者令牌。
关于如何在请求中设置令牌，可参见<a href=#putting-a-bearer-token-in-a-request>前文</a>。</p><figure><div class=mermaid>sequenceDiagram
participant user as 用户
participant idp as 身份提供者
participant kube as Kubectl
participant api as API 服务器
user ->> idp: 1. 登录到 IdP
activate idp
idp -->> user: 2. 提供 access_token,<br>id_token, 和 refresh_token
deactivate idp
activate user
user ->> kube: 3. 调用 Kubectl 并<br>设置 --token 为 id_token<br>或者将令牌添加到 .kube/config
deactivate user
activate kube
kube ->> api: 4. Authorization: Bearer...
deactivate kube
activate api
api ->> api: 5. JWT 签名合法么？
api ->> api: 6. JWT 是否已过期？(iat+exp)
api ->> api: 7. 用户被授权了么？
api -->> kube: 8. 已授权：执行<br>操作并返回结果
deactivate api
activate kube
kube --x user: 9. 返回结果
deactivate kube</div></figure><noscript><div class="alert alert-secondary callout" role=alert><em class=javascript-required>必须<a href=https://www.enable-javascript.com/>启用</a> JavaScript 才能查看此页内容</em></div></noscript><ol><li>登录到你的身份服务（Identity Provider）</li><li>你的身份服务将为你提供 <code>access_token</code>、<code>id_token</code> 和 <code>refresh_token</code></li><li>在使用 <code>kubectl</code> 时，将 <code>id_token</code> 设置为 <code>--token</code> 标志值，或者将其直接添加到
<code>kubeconfig</code> 中</li><li><code>kubectl</code> 将你的 <code>id_token</code> 放到一个称作 <code>Authorization</code> 的头部，发送给 API 服务器</li><li>API 服务器将负责通过检查配置中引用的证书来确认 JWT 的签名是合法的</li><li>检查确认 <code>id_token</code> 尚未过期</li><li>确认用户有权限执行操作</li><li>鉴权成功之后，API 服务器向 <code>kubectl</code> 返回响应</li><li><code>kubectl</code> 向用户提供反馈信息</li></ol><p>由于用来验证你是谁的所有数据都在 <code>id_token</code> 中，Kubernetes 不需要再去联系身份服务。
在一个所有请求都是无状态请求的模型中，这一工作方式可以使得身份认证的解决方案更容易处理大规模请求。
不过，此访问也有一些挑战：</p><ol><li>Kubernetes 没有提供用来触发身份认证过程的 "Web 界面"。
因为不存在用来收集用户凭据的浏览器或用户接口，你必须自己先行完成对身份服务的认证过程。</li><li><code>id_token</code> 令牌不可收回。因其属性类似于证书，其生命期一般很短（只有几分钟），
所以，每隔几分钟就要获得一个新的令牌这件事可能很让人头疼。</li><li>如果需要向 Kubernetes 控制面板执行身份认证，你必须使用 <code>kubectl proxy</code>
命令或者一个能够注入 <code>id_token</code> 的反向代理。</li></ol><h4 id=configuring-the-api-server>配置 API 服务器</h4><p>要启用此插件，须在 API 服务器上配置以下标志：</p><table><thead><tr><th>参数</th><th>描述</th><th>示例</th><th>必需？</th></tr></thead><tbody><tr><td><code>--oidc-issuer-url</code></td><td>允许 API 服务器发现公开的签名密钥的服务的 URL。只接受模式为 <code>https://</code> 的 URL。此值通常设置为服务的发现 URL，不含路径。例如："https://accounts.google.com" 或 "https://login.salesforce.com"。此 URL 应指向 .well-known/openid-configuration 下一层的路径。</td><td>如果发现 URL 是 <code>https://accounts.google.com/.well-known/openid-configuration</code>，则此值应为 <code>https://accounts.google.com</code></td><td>是</td></tr><tr><td><code>--oidc-client-id</code></td><td>所有令牌都应发放给此客户 ID。</td><td>kubernetes</td><td>是</td></tr><tr><td><code>--oidc-username-claim</code></td><td>用作用户名的 JWT 申领（JWT Claim）。默认情况下使用 <code>sub</code> 值，即最终用户的一个唯一的标识符。管理员也可以选择其他申领，例如 <code>email</code> 或者 <code>name</code>，取决于所用的身份服务。不过，除了 <code>email</code> 之外的申领都会被添加令牌发放者的 URL 作为前缀，以免与其他插件产生命名冲突。</td><td>sub</td><td>否</td></tr><tr><td><code>--oidc-username-prefix</code></td><td>要添加到用户名申领之前的前缀，用来避免与现有用户名发生冲突（例如：<code>system:</code> 用户）。例如，此标志值为 <code>oidc:</code> 时将创建形如 <code>oidc:jane.doe</code> 的用户名。如果此标志未设置，且 <code>--oidc-username-claim</code> 标志值不是 <code>email</code>，则默认前缀为 <code>&lt;令牌发放者的 URL>#</code>，其中 <code>&lt;令牌发放者 URL ></code> 的值取自 <code>--oidc-issuer-url</code> 标志的设定。此标志值为 <code>-</code> 时，意味着禁止添加用户名前缀。</td><td><code>oidc:</code></td><td>否</td></tr><tr><td><code>--oidc-groups-claim</code></td><td>用作用户组名的 JWT 申领。如果所指定的申领确实存在，则其值必须是一个字符串数组。</td><td>groups</td><td>否</td></tr><tr><td><code>--oidc-groups-prefix</code></td><td>添加到组申领的前缀，用来避免与现有用户组名（如：<code>system:</code> 组）发生冲突。例如，此标志值为 <code>oidc:</code> 时，所得到的用户组名形如 <code>oidc:engineering</code> 和 <code>oidc:infra</code>。</td><td><code>oidc:</code></td><td>否</td></tr><tr><td><code>--oidc-required-claim</code></td><td>取值为一个 key=value 偶对，意为 ID 令牌中必须存在的申领。如果设置了此标志，则 ID 令牌会被检查以确定是否包含取值匹配的申领。此标志可多次重复，以指定多个申领。</td><td><code>claim=value</code></td><td>否</td></tr><tr><td><code>--oidc-ca-file</code></td><td>指向一个 CA 证书的路径，该 CA 负责对你的身份服务的 Web 证书提供签名。默认值为宿主系统的根 CA。</td><td><code>/etc/kubernetes/ssl/kc-ca.pem</code></td><td>否</td></tr><tr><td><code>--oidc-signing-algs</code></td><td>采纳的签名算法。默认为 "RS256"。</td><td><code>RS512</code></td><td>否</td></tr></tbody></table><p>很重要的一点是，API 服务器并非一个 OAuth2 客户端，相反，它只能被配置为信任某一个令牌发放者。
这使得使用公共服务（如 Google）的用户可以不信任发放给第三方的凭据。
如果管理员希望使用多个 OAuth 客户端，他们应该研究一下那些支持 <code>azp</code>
（Authorized Party，被授权方）申领的服务。
<code>azp</code> 是一种允许某客户端代替另一客户端发放令牌的机制。</p><p>Kubernetes 并未提供 OpenID Connect 的身份服务。
你可以使用现有的公共的 OpenID Connect 身份服务
（例如 Google 或者<a href=https://connect2id.com/products/nimbus-oauth-openid-connect-sdk/openid-connect-providers>其他服务</a>）。
或者，你也可以选择自己运行一个身份服务，例如
CoreOS <a href=https://github.com/coreos/dex>dex</a>、
<a href=https://github.com/keycloak/keycloak>Keycloak</a>、
CloudFoundry <a href=https://github.com/cloudfoundry/uaa>UAA</a> 或者
Tremolo Security 的 <a href=https://openunison.github.io/>OpenUnison</a>。</p><p>要在 Kubernetes 环境中使用某身份服务，该服务必须：</p><ol><li>支持 <a href=https://openid.net/specs/openid-connect-discovery-1_0.html>OpenID connect 发现</a>；
但事实上并非所有服务都具备此能力</li><li>运行 TLS 协议且所使用的加密组件都未过时</li><li>拥有由 CA 签名的证书（即使 CA 不是商业 CA 或者是自签名的 CA 也可以）</li></ol><p>关于上述第三条需求，即要求具备 CA 签名的证书，有一些额外的注意事项。
如果你部署了自己的身份服务，而不是使用云厂商（如 Google 或 Microsoft）所提供的服务，
你必须对身份服务的 Web 服务器证书进行签名，签名所用证书的 <code>CA</code> 标志要设置为
<code>TRUE</code>，即使用的是自签名证书。这是因为 GoLang 的 TLS 客户端实现对证书验证标准方面有非常严格的要求。如果你手头没有现成的 CA 证书，可以使用 CoreOS
团队所开发的<a href=https://github.com/dexidp/dex/blob/master/examples/k8s/gencert.sh>这个脚本</a>
来创建一个简单的 CA 和被签了名的证书与密钥对。
或者你也可以使用<a href=https://raw.githubusercontent.com/TremoloSecurity/openunison-qs-kubernetes/master/src/main/bash/makessl.sh>这个类似的脚本</a>，
生成一个合法期更长、密钥尺寸更大的 SHA256 证书。</p><p>特定系统的安装指令：</p><ul><li><a href=https://docs.cloudfoundry.org/concepts/architecture/uaa.html>UAA</a></li><li><a href=https://dexidp.io/docs/kubernetes/>Dex</a></li><li><a href=https://www.tremolosecurity.com/orchestra-k8s/>OpenUnison</a></li></ul><h4 id=using-kubectl>使用 kubectl</h4><h5 id=选项一-oidc-身份认证组件>选项一：OIDC 身份认证组件</h5><p>第一种方案是使用 kubectl 的 <code>oidc</code> 身份认证组件，该组件将 <code>id_token</code> 设置为所有请求的持有者令牌，
并且在令牌过期时自动刷新。在你登录到你的身份服务之后，
可以使用 kubectl 来添加你的 <code>id_token</code>、<code>refresh_token</code>、<code>client_id</code> 和
<code>client_secret</code>，以配置该插件。</p><p>如果服务在其刷新令牌响应中不包含 <code>id_token</code>，则此插件无法支持该服务。
这时你应该考虑下面的选项二。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl config set-credentials USER_NAME <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>   --auth-provider<span style=color:#666>=</span>oidc <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>   --auth-provider-arg<span style=color:#666>=</span>idp-issuer-url<span style=color:#666>=(</span> issuer url <span style=color:#666>)</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>   --auth-provider-arg<span style=color:#666>=</span>client-id<span style=color:#666>=(</span> your client id <span style=color:#666>)</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>   --auth-provider-arg<span style=color:#666>=</span>client-secret<span style=color:#666>=(</span> your client secret <span style=color:#666>)</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>   --auth-provider-arg<span style=color:#666>=</span>refresh-token<span style=color:#666>=(</span> your refresh token <span style=color:#666>)</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>   --auth-provider-arg<span style=color:#666>=</span>idp-certificate-authority<span style=color:#666>=(</span> path to your ca certificate <span style=color:#666>)</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>   --auth-provider-arg<span style=color:#666>=</span>id-token<span style=color:#666>=(</span> your id_token <span style=color:#666>)</span>
</span></span></code></pre></div><p>作为示例，在完成对你的身份服务的身份认证之后，运行下面的命令：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl config set-credentials mmosley  <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>        --auth-provider<span style=color:#666>=</span>oidc  <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>        --auth-provider-arg<span style=color:#666>=</span>idp-issuer-url<span style=color:#666>=</span>https://oidcidp.tremolo.lan:8443/auth/idp/OidcIdP  <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>        --auth-provider-arg<span style=color:#666>=</span>client-id<span style=color:#666>=</span>kubernetes  <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>        --auth-provider-arg<span style=color:#666>=</span>client-secret<span style=color:#666>=</span>1db158f6-177d-4d9c-8a8b-d36869918ec5  <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>        --auth-provider-arg<span style=color:#666>=</span>refresh-token<span style=color:#666>=</span>q1bKLFOyUiosTfawzA93TzZIDzH2TNa2SMm0zEiPKTUwME6BkEo6Sql5yUWVBSWpKUGphaWpxSVAfekBOZbBhaEW+VlFUeVRGcluyVF5JT4+haZmPsluFoFu5XkpXk5BXqHega4GAXlF+ma+vmYpFcHe5eZR+slBFpZKtQA<span style=color:#666>=</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>        --auth-provider-arg<span style=color:#666>=</span>idp-certificate-authority<span style=color:#666>=</span>/root/ca.pem <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>        --auth-provider-arg<span style=color:#666>=</span>id-token<span style=color:#666>=</span>eyJraWQiOiJDTj1vaWRjaWRwLnRyZW1vbG8ubGFuLCBPVT1EZW1vLCBPPVRybWVvbG8gU2VjdXJpdHksIEw9QXJsaW5ndG9uLCBTVD1WaXJnaW5pYSwgQz1VUy1DTj1rdWJlLWNhLTEyMDIxNDc5MjEwMzYwNzMyMTUyIiwiYWxnIjoiUlMyNTYifQ.eyJpc3MiOiJodHRwczovL29pZGNpZHAudHJlbW9sby5sYW46ODQ0My9hdXRoL2lkcC9PaWRjSWRQIiwiYXVkIjoia3ViZXJuZXRlcyIsImV4cCI6MTQ4MzU0OTUxMSwianRpIjoiMm96US15TXdFcHV4WDlHZUhQdy1hZyIsImlhdCI6MTQ4MzU0OTQ1MSwibmJmIjoxNDgzNTQ5MzMxLCJzdWIiOiI0YWViMzdiYS1iNjQ1LTQ4ZmQtYWIzMC0xYTAxZWU0MWUyMTgifQ.w6p4J_6qQ1HzTG9nrEOrubxIMb9K5hzcMPxc9IxPx2K4xO9l-oFiUw93daH3m5pluP6K7eOE6txBuRVfEcpJSwlelsOsW8gb8VJcnzMS9EnZpeA0tW_p-mnkFc3VcfyXuhe5R3G7aa5d8uHv70yJ9Y3-UhjiN9EhpMdfPAoEB9fYKKkJRzF7utTTIPGrSaSU6d2pcpfYKaxIwePzEkT4DfcQthoZdy9ucNvvLoi1DIC-UocFD8HLs8LYKEqSxQvOcvnThbObJ9af71EwmuE21fO5KzMW20KtAeget1gnldOosPtz1G5EwvaQ401-RPQzPGMVBld0_zMCAwZttJ4knw
</span></span></code></pre></div><p>此操作会生成以下配置：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>users</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mmosley<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>auth-provider</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>config</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>client-id</span>:<span style=color:#bbb> </span>kubernetes<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>client-secret</span>:<span style=color:#bbb> </span>1db158f6-177d-4d9c-8a8b-d36869918ec5<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>id-token</span>:<span style=color:#bbb> </span>eyJraWQiOiJDTj1vaWRjaWRwLnRyZW1vbG8ubGFuLCBPVT1EZW1vLCBPPVRybWVvbG8gU2VjdXJpdHksIEw9QXJsaW5ndG9uLCBTVD1WaXJnaW5pYSwgQz1VUy1DTj1rdWJlLWNhLTEyMDIxNDc5MjEwMzYwNzMyMTUyIiwiYWxnIjoiUlMyNTYifQ.eyJpc3MiOiJodHRwczovL29pZGNpZHAudHJlbW9sby5sYW46ODQ0My9hdXRoL2lkcC9PaWRjSWRQIiwiYXVkIjoia3ViZXJuZXRlcyIsImV4cCI6MTQ4MzU0OTUxMSwianRpIjoiMm96US15TXdFcHV4WDlHZUhQdy1hZyIsImlhdCI6MTQ4MzU0OTQ1MSwibmJmIjoxNDgzNTQ5MzMxLCJzdWIiOiI0YWViMzdiYS1iNjQ1LTQ4ZmQtYWIzMC0xYTAxZWU0MWUyMTgifQ.w6p4J_6qQ1HzTG9nrEOrubxIMb9K5hzcMPxc9IxPx2K4xO9l-oFiUw93daH3m5pluP6K7eOE6txBuRVfEcpJSwlelsOsW8gb8VJcnzMS9EnZpeA0tW_p-mnkFc3VcfyXuhe5R3G7aa5d8uHv70yJ9Y3-UhjiN9EhpMdfPAoEB9fYKKkJRzF7utTTIPGrSaSU6d2pcpfYKaxIwePzEkT4DfcQthoZdy9ucNvvLoi1DIC-UocFD8HLs8LYKEqSxQvOcvnThbObJ9af71EwmuE21fO5KzMW20KtAeget1gnldOosPtz1G5EwvaQ401-RPQzPGMVBld0_zMCAwZttJ4knw<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>idp-certificate-authority</span>:<span style=color:#bbb> </span>/root/ca.pem<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>idp-issuer-url</span>:<span style=color:#bbb> </span>https://oidcidp.tremolo.lan:8443/auth/idp/OidcIdP<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>refresh-token</span>:<span style=color:#bbb> </span>q1bKLFOyUiosTfawzA93TzZIDzH2TNa2SMm0zEiPKTUwME6BkEo6Sql5yUWVBSWpKUGphaWpxSVAfekBOZbBhaEW+VlFUeVRGcluyVF5JT4+haZmPsluFoFu5XkpXk5BXq<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>oidc<span style=color:#bbb>
</span></span></span></code></pre></div><p>当你的 <code>id_token</code> 过期时，<code>kubectl</code> 会尝试使用你的 <code>refresh_token</code> 来刷新你的
<code>id_token</code>，并且在 <code>.kube/config</code> 文件的 <code>client_secret</code> 中存放 <code>refresh_token</code>
和 <code>id_token</code> 的新值。</p><h5 id=选项二-使用-token-选项>选项二：使用 <code>--token</code> 选项</h5><p><code>kubectl</code> 命令允许你使用 <code>--token</code> 选项传递一个令牌。
你可以将 <code>id_token</code> 的内容复制粘贴过来，作为此标志的取值：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl --token<span style=color:#666>=</span>eyJhbGciOiJSUzI1NiJ9.eyJpc3MiOiJodHRwczovL21sYi50cmVtb2xvLmxhbjo4MDQzL2F1dGgvaWRwL29pZGMiLCJhdWQiOiJrdWJlcm5ldGVzIiwiZXhwIjoxNDc0NTk2NjY5LCJqdGkiOiI2RDUzNXoxUEpFNjJOR3QxaWVyYm9RIiwiaWF0IjoxNDc0NTk2MzY5LCJuYmYiOjE0NzQ1OTYyNDksInN1YiI6Im13aW5kdSIsInVzZXJfcm9sZSI6WyJ1c2VycyIsIm5ldy1uYW1lc3BhY2Utdmlld2VyIl0sImVtYWlsIjoibXdpbmR1QG5vbW9yZWplZGkuY29tIn0.f2As579n9VNoaKzoF-dOQGmXkFKf1FMyNV0-va_B63jn-_n9LGSCca_6IVMP8pO-Zb4KvRqGyTP0r3HkHxYy5c81AnIh8ijarruczl-TK_yF5akjSTHFZD-0gRzlevBDiH8Q79NAr-ky0P4iIXS8lY9Vnjch5MF74Zx0c3alKJHJUnnpjIACByfF2SCaYzbWFMUNat-K1PaUk5-ujMBG7yYnr95xD-63n8CO8teGUAAEMx6zRjzfhnhbzX-ajwZLGwGUBT4WqjMs70-6a7_8gZmLZb2az1cZynkFRj2BaCkVT3A2RrjeEwZEtGXlMqKJ1_I2ulrOVsYx01_yD35-rw get nodes
</span></span></code></pre></div><h3 id=webhook-token-authentication>Webhook 令牌身份认证</h3><p>Webhook 身份认证是一种用来验证持有者令牌的回调机制。</p><ul><li><code>--authentication-token-webhook-config-file</code> 指向一个配置文件，
其中描述如何访问远程的 Webhook 服务。</li><li><code>--authentication-token-webhook-cache-ttl</code> 用来设定身份认证决定的缓存时间。
默认时长为 2 分钟。</li></ul><p>配置文件使用 <a href=/zh-cn/docs/concepts/configuration/organize-cluster-access-kubeconfig/>kubeconfig</a>
文件的格式。文件中，<code>clusters</code> 指代远程服务，<code>users</code> 指代远程 API 服务
Webhook。下面是一个例子：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#080;font-style:italic># Kubernetes API 版本</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># API 对象类别</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># clusters 指代远程服务</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>clusters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>name-of-remote-authn-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>certificate-authority</span>:<span style=color:#bbb> </span>/path/to/ca.pem        <span style=color:#bbb> </span><span style=color:#080;font-style:italic># 用来验证远程服务的 CA</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>server</span>:<span style=color:#bbb> </span>https://authn.example.com/authenticate<span style=color:#bbb> </span><span style=color:#080;font-style:italic># 要查询的远程服务 URL。生产环境中建议使用 &#39;https&#39;。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># users 指代 API 服务的 Webhook 配置</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>users</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>name-of-api-server<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>client-certificate</span>:<span style=color:#bbb> </span>/path/to/cert.pem<span style=color:#bbb> </span><span style=color:#080;font-style:italic># Webhook 插件要使用的证书</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>client-key</span>:<span style=color:#bbb> </span>/path/to/key.pem         <span style=color:#bbb> </span><span style=color:#080;font-style:italic># 与证书匹配的密钥</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># kubeconfig 文件需要一个上下文（Context），此上下文用于本 API 服务器</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>current-context</span>:<span style=color:#bbb> </span>webhook<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>contexts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>context</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb> </span>name-of-remote-authn-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb> </span>name-of-api-server<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>webhook<span style=color:#bbb>
</span></span></span></code></pre></div><p>当客户端尝试在 API 服务器上使用持有者令牌完成身份认证
（如<a href=#putting-a-bearer-token-in-a-request>前</a>所述）时，
身份认证 Webhook 会用 POST 请求发送一个 JSON 序列化的对象到远程服务。
该对象是 <code>TokenReview</code> 对象，其中包含持有者令牌。
Kubernetes 不会强制请求提供此 HTTP 头部。</p><p>要注意的是，Webhook API 对象和其他 Kubernetes API 对象一样，
也要受到同一<a href=/zh-cn/docs/concepts/overview/kubernetes-api/>版本兼容规则</a>约束。
实现者应检查请求的 <code>apiVersion</code> 字段以确保正确的反序列化，
并且 <strong>必须</strong> 以与请求相同版本的 <code>TokenReview</code> 对象进行响应。</p><ul class="nav nav-tabs" id=tokenreview-request role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tokenreview-request-0 role=tab aria-controls=tokenreview-request-0 aria-selected=true>authentication.k8s.io/v1</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tokenreview-request-1 role=tab aria-controls=tokenreview-request-1>authentication.k8s.io/v1beta1</a></li></ul><div class=tab-content id=tokenreview-request><div id=tokenreview-request-0 class="tab-pane show active" role=tabpanel aria-labelledby=tokenreview-request-0><p><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>Kubernetes API 服务器默认发送 <code>authentication.k8s.io/v1beta1</code> 令牌以实现向后兼容性。
要选择接收 <code>authentication.k8s.io/v1</code> 令牌认证，API 服务器必须带着参数
<code>--authentication-token-webhook-version=v1</code> 启动。</div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>&#34;apiVersion&#34;: </span><span style=color:#b44>&#34;authentication.k8s.io/v1&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>&#34;kind&#34;: </span><span style=color:#b44>&#34;TokenReview&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>&#34;spec&#34;: </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   </span><span style=color:#080;font-style:italic># 发送到 API 服务器的不透明持有者令牌</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;token&#34;: </span><span style=color:#b44>&#34;014fbff9a07c...&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 提供令牌的服务器的受众标识符的可选列表。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 受众感知令牌验证器（例如，OIDC 令牌验证器）</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 应验证令牌是否针对此列表中的至少一个受众，</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 并返回此列表与响应状态中令牌的有效受众的交集。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 这确保了令牌对于向其提供给的服务器进行身份验证是有效的。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 如果未提供受众，则应验证令牌以向 Kubernetes API 服务器进行身份验证。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;audiences&#34;: </span>[<span style=color:#b44>&#34;https://myserver.example.com&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;https://myserver.internal.example.com&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></span></span></code></pre></div></div><div id=tokenreview-request-1 class=tab-pane role=tabpanel aria-labelledby=tokenreview-request-1><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>&#34;apiVersion&#34;: </span><span style=color:#b44>&#34;authentication.k8s.io/v1beta1&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>&#34;kind&#34;: </span><span style=color:#b44>&#34;TokenReview&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>&#34;spec&#34;: </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 发送到 API 服务器的不透明匿名令牌</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;token&#34;: </span><span style=color:#b44>&#34;014fbff9a07c...&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>   
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 提供令牌的服务器的受众标识符的可选列表。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 受众感知令牌验证器（例如，OIDC 令牌验证器）</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 应验证令牌是否针对此列表中的至少一个受众，</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 并返回此列表与响应状态中令牌的有效受众的交集。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 这确保了令牌对于向其提供给的服务器进行身份验证是有效的。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 如果未提供受众，则应验证令牌以向 Kubernetes API 服务器进行身份验证。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;audiences&#34;: </span>[<span style=color:#b44>&#34;https://myserver.example.com&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;https://myserver.internal.example.com&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>远程服务预计会填写请求的 <code>status</code> 字段以指示登录成功。
响应正文的 <code>spec</code> 字段被忽略并且可以省略。
远程服务必须使用它收到的相同 <code>TokenReview</code> API 版本返回响应。
持有者令牌的成功验证将返回：</p><ul class="nav nav-tabs" id=tokenreview-response-success role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tokenreview-response-success-0 role=tab aria-controls=tokenreview-response-success-0 aria-selected=true>authentication.k8s.io/v1</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tokenreview-response-success-1 role=tab aria-controls=tokenreview-response-success-1>authentication.k8s.io/v1beta1</a></li></ul><div class=tab-content id=tokenreview-response-success><div id=tokenreview-response-success-0 class="tab-pane show active" role=tabpanel aria-labelledby=tokenreview-response-success-0><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>&#34;apiVersion&#34;: </span><span style=color:#b44>&#34;authentication.k8s.io/v1&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>&#34;kind&#34;: </span><span style=color:#b44>&#34;TokenReview&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>&#34;status&#34;: </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;authenticated&#34;: </span><span style=color:#a2f;font-weight:700>true</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;user&#34;: </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 必要</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>&#34;username&#34;: </span><span style=color:#b44>&#34;janedoe@example.com&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 可选</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>&#34;uid&#34;: </span><span style=color:#b44>&#34;42&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 可选的组成员身份</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>&#34;groups&#34;: </span>[<span style=color:#b44>&#34;developers&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;qa&#34;</span>],<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 认证者提供的可选附加信息。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 此字段不可包含机密数据，因为这类数据可能被记录在日志或 API 对象中，</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 并且可能传递给 admission webhook。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>&#34;extra&#34;: </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>&#34;extrafield1&#34;: </span>[<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:#b44>&#34;extravalue1&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:#b44>&#34;extravalue2&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>},<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 验证器可以返回的、可选的用户感知令牌列表，</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 包含令牌对其有效的、包含于 `spec.audiences` 列表中的受众。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 如果省略，则认为该令牌可用于对 Kubernetes API 服务器进行身份验证。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;audiences&#34;: </span>[<span style=color:#b44>&#34;https://myserver.example.com&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></span></span></code></pre></div></div><div id=tokenreview-response-success-1 class=tab-pane role=tabpanel aria-labelledby=tokenreview-response-success-1><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>&#34;apiVersion&#34;: </span><span style=color:#b44>&#34;authentication.k8s.io/v1beta1&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>&#34;kind&#34;: </span><span style=color:#b44>&#34;TokenReview&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>&#34;status&#34;: </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;authenticated&#34;: </span><span style=color:#a2f;font-weight:700>true</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;user&#34;: </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 必要</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>&#34;username&#34;: </span><span style=color:#b44>&#34;janedoe@example.com&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 可选</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>&#34;uid&#34;: </span><span style=color:#b44>&#34;42&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 可选的组成员身份</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>&#34;groups&#34;: </span>[<span style=color:#b44>&#34;developers&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;qa&#34;</span>],<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 认证者提供的可选附加信息。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 此字段不可包含机密数据，因为这类数据可能被记录在日志或 API 对象中，</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 并且可能传递给 admission webhook。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>&#34;extra&#34;: </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>&#34;extrafield1&#34;: </span>[<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:#b44>&#34;extravalue1&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:#b44>&#34;extravalue2&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>},<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 验证器可以返回的、可选的用户感知令牌列表，</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 包含令牌对其有效的、包含于 `spec.audiences` 列表中的受众。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 如果省略，则认为该令牌可用于对 Kubernetes API 服务器进行身份验证。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;audiences&#34;: </span>[<span style=color:#b44>&#34;https://myserver.example.com&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>而不成功的请求会返回：</p><ul class="nav nav-tabs" id=tokenreview-response-error role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#tokenreview-response-error-0 role=tab aria-controls=tokenreview-response-error-0 aria-selected=true>authentication.k8s.io/v1</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#tokenreview-response-error-1 role=tab aria-controls=tokenreview-response-error-1>authentication.k8s.io/v1beta1</a></li></ul><div class=tab-content id=tokenreview-response-error><div id=tokenreview-response-error-0 class="tab-pane show active" role=tabpanel aria-labelledby=tokenreview-response-error-0><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>&#34;apiVersion&#34;: </span><span style=color:#b44>&#34;authentication.k8s.io/v1&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>&#34;kind&#34;: </span><span style=color:#b44>&#34;TokenReview&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>&#34;status&#34;: </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;authenticated&#34;: </span><span style=color:#a2f;font-weight:700>false</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 可选地包括有关身份验证失败原因的详细信息。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 如果没有提供错误信息，API 将返回一个通用的 Unauthorized 消息。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 当 authenticated=true 时，error 字段被忽略。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;error&#34;: </span><span style=color:#b44>&#34;Credentials are expired&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></span></span></code></pre></div></div><div id=tokenreview-response-error-1 class=tab-pane role=tabpanel aria-labelledby=tokenreview-response-error-1><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>&#34;apiVersion&#34;: </span><span style=color:#b44>&#34;authentication.k8s.io/v1beta1&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>&#34;kind&#34;: </span><span style=color:#b44>&#34;TokenReview&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>&#34;status&#34;: </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;authenticated&#34;: </span><span style=color:#a2f;font-weight:700>false</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 可选地包括有关身份验证失败原因的详细信息。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 如果没有提供错误信息，API 将返回一个通用的 Unauthorized 消息。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 当 authenticated=true 时，error 字段被忽略。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;error&#34;: </span><span style=color:#b44>&#34;Credentials are expired&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><h3 id=authenticating-proxy>身份认证代理</h3><p>API 服务器可以配置成从请求的头部字段值（如 <code>X-Remote-User</code>）中辩识用户。
这一设计是用来与某身份认证代理一起使用 API 服务器，代理负责设置请求的头部字段值。</p><ul><li><code>--requestheader-username-headers</code> 必需字段，大小写不敏感。
用来设置要获得用户身份所要检查的头部字段名称列表（有序）。
第一个包含数值的字段会被用来提取用户名。</li><li><code>--requestheader-group-headers</code> 可选字段，在 Kubernetes 1.6 版本以后支持，大小写不敏感。
建议设置为 "X-Remote-Group"。用来指定一组头部字段名称列表，以供检查用户所属的组名称。
所找到的全部头部字段的取值都会被用作用户组名。</li><li><code>--requestheader-extra-headers-prefix</code> 可选字段，在 Kubernetes 1.6 版本以后支持，大小写不敏感。
建议设置为 "X-Remote-Extra-"。用来设置一个头部字段的前缀字符串，
API 服务器会基于所给前缀来查找与用户有关的一些额外信息。这些额外信息通常用于所配置的鉴权插件。
API 服务器会将与所给前缀匹配的头部字段过滤出来，去掉其前缀部分，将剩余部分转换为小写字符串，
并在必要时执行<a href=https://tools.ietf.org/html/rfc3986#section-2.1>百分号解码</a>后，
构造新的附加信息字段键名。原来的头部字段值直接作为附加信息字段的值。</li></ul><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>在 1.13.3 版本之前（包括 1.10.7、1.9.11），附加字段的键名只能包含
<a href=https://tools.ietf.org/html/rfc7230#section-3.2.6>HTTP 头部标签的合法字符</a>。</div><p>例如，使用下面的配置：</p><pre tabindex=0><code>--requestheader-username-headers=X-Remote-User
--requestheader-group-headers=X-Remote-Group
--requestheader-extra-headers-prefix=X-Remote-Extra-
</code></pre><p>针对所收到的如下请求：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=display:flex><span><span style=color:#00a000>GET</span> <span style=color:#00f;font-weight:700>/</span> <span style=color:#a2f;font-weight:700>HTTP</span><span style=color:#666>/</span><span style=color:#666>1.1</span>
</span></span><span style=display:flex><span>X-Remote-User<span style=color:#666>:</span> fido
</span></span><span style=display:flex><span>X-Remote-Group<span style=color:#666>:</span> dogs
</span></span><span style=display:flex><span>X-Remote-Group<span style=color:#666>:</span> dachshunds
</span></span><span style=display:flex><span>X-Remote-Extra-Acme.com%2Fproject<span style=color:#666>:</span> some-project
</span></span><span style=display:flex><span>X-Remote-Extra-Scopes<span style=color:#666>:</span> openid
</span></span><span style=display:flex><span>X-Remote-Extra-Scopes<span style=color:#666>:</span> profile
</span></span></code></pre></div><p>会生成下面的用户信息：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>fido<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>groups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- dogs<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- dachshunds<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>extra</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>acme.com/project</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- some-project<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>scopes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- openid<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- profile<span style=color:#bbb>
</span></span></span></code></pre></div><p>为了防范头部信息侦听，在请求中的头部字段被检视之前，
身份认证代理需要向 API 服务器提供一份合法的客户端证书，供后者使用所给的 CA 来执行验证。
警告：<strong>不要</strong> 在不同的上下文中复用 CA 证书，除非你清楚这样做的风险是什么以及应如何保护
CA 用法的机制。</p><ul><li><code>--requestheader-client-ca-file</code> 必需字段，给出 PEM 编码的证书包。
在检查请求的头部字段以提取用户名信息之前，必须提供一个合法的客户端证书，
且该证书要能够被所给文件中的机构所验证。</li><li><code>--requestheader-allowed-names</code> 可选字段，用来给出一组公共名称（CN）。
如果此标志被设置，则在检视请求中的头部以提取用户信息之前，
必须提供包含此列表中所给的 CN 名的、合法的客户端证书。</li></ul><h2 id=anonymous-requests>匿名请求</h2><p>启用匿名请求支持之后，如果请求没有被已配置的其他身份认证方法拒绝，
则被视作匿名请求（Anonymous Requests）。这类请求获得用户名 <code>system:anonymous</code>
和对应的用户组 <code>system:unauthenticated</code>。</p><p>例如，在一个配置了令牌身份认证且启用了匿名访问的服务器上，如果请求提供了非法的持有者令牌，
则会返回 <code>401 Unauthorized</code> 错误。如果请求没有提供持有者令牌，则被视为匿名请求。</p><p>在 1.5.1-1.5.x 版本中，匿名访问默认情况下是被禁用的，可以通过为 API 服务器设定
<code>--anonymous-auth=true</code> 来启用。</p><p>在 1.6 及之后版本中，如果所使用的鉴权模式不是 <code>AlwaysAllow</code>，则匿名访问默认是被启用的。
从 1.6 版本开始，ABAC 和 RBAC 鉴权模块要求对 <code>system:anonymous</code> 用户或者
<code>system:unauthenticated</code> 用户组执行显式的权限判定，所以之前的为用户 <code>*</code> 或用户组
<code>*</code> 赋予访问权限的策略规则都不再包含匿名用户。</p><h2 id=user-impersonation>用户伪装</h2><p>一个用户可以通过伪装（Impersonation）头部字段来以另一个用户的身份执行操作。
使用这一能力，你可以手动重载请求被身份认证所识别出来的用户信息。
例如，管理员可以使用这一功能特性来临时伪装成另一个用户，查看请求是否被拒绝，
从而调试鉴权策略中的问题，</p><p>带伪装的请求首先会被身份认证识别为发出请求的用户，
之后会切换到使用被伪装的用户的用户信息。</p><ul><li>用户发起 API 调用时 <strong>同时</strong> 提供自身的凭据和伪装头部字段信息</li><li>API 服务器对用户执行身份认证</li><li>API 服务器确认通过认证的用户具有伪装特权</li><li>请求用户的信息被替换成伪装字段的值</li><li>评估请求，鉴权组件针对所伪装的用户信息执行操作</li></ul><p>以下 HTTP 头部字段可用来执行伪装请求：</p><ul><li><code>Impersonate-User</code>：要伪装成的用户名</li><li><code>Impersonate-Group</code>：要伪装成的用户组名。可以多次指定以设置多个用户组。
可选字段；要求 "Impersonate-User" 必须被设置。</li><li><code>Impersonate-Extra-&lt;附加名称></code>：一个动态的头部字段，用来设置与用户相关的附加字段。
此字段可选；要求 "Impersonate-User" 被设置。为了能够以一致的形式保留，
<code>&lt;附加名称></code>部分必须是小写字符，
如果有任何字符不是<a href=https://tools.ietf.org/html/rfc7230#section-3.2.6>合法的 HTTP 头部标签字符</a>，
则必须是 utf8 字符，且转换为<a href=https://tools.ietf.org/html/rfc3986#section-2.1>百分号编码</a>。</li><li><code>Impersonate-Uid</code>：一个唯一标识符，用来表示所伪装的用户。此头部可选。
如果设置，则要求 "Impersonate-User" 也存在。Kubernetes 对此字符串没有格式要求。</li></ul><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>在 1.11.3 版本之前（以及 1.10.7、1.9.11），<code>&lt;附加名称></code> 只能包含合法的 HTTP 标签字符。</div><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p><code>Impersonate-Uid</code> 仅在 1.22.0 及更高版本中可用。</div><p>伪装带有用户组的用户时，所使用的伪装头部字段示例：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=display:flex><span><span>Impersonate-User: jane.doe@example.com
</span></span></span><span style=display:flex><span><span>Impersonate-Group: developers
</span></span></span><span style=display:flex><span><span>Impersonate-Group: admins
</span></span></span></code></pre></div><p>伪装带有 UID 和附加字段的用户时，所使用的伪装头部字段示例：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=display:flex><span><span>Impersonate-User: jane.doe@example.com
</span></span></span><span style=display:flex><span><span>Impersonate-Extra-dn: cn=jane,ou=engineers,dc=example,dc=com
</span></span></span><span style=display:flex><span><span>Impersonate-Extra-acme.com%2Fproject: some-project
</span></span></span><span style=display:flex><span><span>Impersonate-Extra-scopes: view
</span></span></span><span style=display:flex><span><span>Impersonate-Extra-scopes: development
</span></span></span><span style=display:flex><span><span>Impersonate-Uid: 06f6ce97-e2c5-4ab8-7ba5-7654dd08d52b
</span></span></span></code></pre></div><p>在使用 <code>kubectl</code> 时，可以使用 <code>--as</code> 标志来配置 <code>Impersonate-User</code> 头部字段值，
使用 <code>--as-group</code> 标志配置 <code>Impersonate-Group</code> 头部字段值。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl drain mynode
</span></span></code></pre></div><pre tabindex=0><code class=language-none data-lang=none>Error from server (Forbidden): User &#34;clark&#34; cannot get nodes at the cluster scope. (get nodes mynode)
</code></pre><p>设置 <code>--as</code> 和 <code>--as-group</code> 标志：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl drain mynode --as<span style=color:#666>=</span>superman --as-group<span style=color:#666>=</span>system:masters
</span></span></code></pre></div><pre tabindex=0><code class=language-none data-lang=none>node/mynode cordoned
node/mynode drained
</code></pre><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p><code>kubectl</code> 不能对附加字段或 UID 执行伪装。</div><p>若要伪装成某个用户、某个组、用户标识符（UID））或者设置附加字段，
执行伪装操作的用户必须具有对所伪装的类别（“user”、“group”、“uid” 等）执行 “impersonate”
动词操作的能力。
对于启用了 RBAC 鉴权插件的集群，下面的 ClusterRole 封装了设置用户和组伪装字段所需的规则：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>impersonator<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;users&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;groups&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;serviceaccounts&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;impersonate&#34;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div><p>为了执行伪装，附加字段和所伪装的 UID 都位于 "authorization.k8s.io" <code>apiGroup</code> 中。
附加字段会被作为 <code>userextras</code> 资源的子资源来执行权限评估。
如果要允许用户为附加字段 “scopes” 和 UID 设置伪装头部，该用户需要被授予以下角色：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>scopes-and-uid-impersonator<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 可以设置 &#34;Impersonate-Extra-scopes&#34; 和 &#34;Impersonate-Uid&#34; 头部</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;authentication.k8s.io&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;userextras/scopes&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;uids&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;impersonate&#34;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div><p>你也可以通过约束资源可能对应的 <code>resourceNames</code> 限制伪装头部的取值：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>limited-impersonator<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 可以伪装成用户 &#34;jane.doe@example.com&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;users&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;impersonate&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resourceNames</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;jane.doe@example.com&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 可以伪装成用户组 &#34;developers&#34; 和 &#34;admins&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;groups&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;impersonate&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resourceNames</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;developers&#34;</span>,<span style=color:#b44>&#34;admins&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 可以将附加字段 &#34;scopes&#34; 伪装成 &#34;view&#34; 和 &#34;development&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;authentication.k8s.io&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;userextras/scopes&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;impersonate&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resourceNames</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;view&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;development&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 可以伪装 UID &#34;06f6ce97-e2c5-4ab8-7ba5-7654dd08d52b&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;authentication.k8s.io&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;uids&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;impersonate&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resourceNames</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;06f6ce97-e2c5-4ab8-7ba5-7654dd08d52b&#34;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>基于伪装成一个用户或用户组的能力，你可以执行任何操作，好像你就是那个用户或用户组一样。
出于这一原因，伪装操作是不受名字空间约束的。
如果你希望允许使用 Kubernetes RBAC 来执行身份伪装，就需要使用 <code>ClusterRole</code>
和 <code>ClusterRoleBinding</code>，而不是 <code>Role</code> 或 <code>RoleBinding</code>。</div><h2 id=client-go-credential-plugins>client-go 凭据插件</h2><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.22 [stable]</code></div><p><code>k8s.io/client-go</code> 及使用它的工具（如 <code>kubectl</code> 和 <code>kubelet</code>）
可以执行某个外部命令来获得用户的凭据信息。</p><p>这一特性的目的是便于客户端与 <code>k8s.io/client-go</code> 并不支持的身份认证协议
（LDAP、Kerberos、OAuth2、SAML 等）继承。
插件实现特定于协议的逻辑，之后返回不透明的凭据以供使用。
几乎所有的凭据插件使用场景中都需要在服务器端存在一个支持
<a href=#webhook-token-authentication>Webhook 令牌身份认证组件</a>的模块，
负责解析客户端插件所生成的凭据格式。</p><h3 id=example-use-case>示例应用场景</h3><p>在一个假想的应用场景中，某组织运行这一个外部的服务，能够将特定用户的已签名的令牌转换成
LDAP 凭据。此服务还能够对
<a href=#webhook-token-authentication>Webhook 令牌身份认证组件</a>的请求做出响应以验证所提供的令牌。
用户需要在自己的工作站上安装一个凭据插件。</p><p>要对 API 服务器认证身份时：</p><ul><li>用户发出 <code>kubectl</code> 命令。</li><li>凭据插件提示用户输入 LDAP 凭据，并与外部服务交互，获得令牌。</li><li>凭据插件将令牌返回该 client-go，后者将其用作持有者令牌提交给 API 服务器。</li><li>API 服务器使用 <a href=#webhook-token-authentication>Webhook 令牌身份认证组件</a>向外部服务发出
<code>TokenReview</code> 请求。</li><li>外部服务检查令牌上的签名，返回用户的用户名和用户组信息。</li></ul><h3 id=configuration>配置</h3><p>凭据插件通过 <a href=/zh-cn/docs/tasks/access-application-cluster/configure-access-multiple-clusters/>kubectl 配置文件</a>
来作为 user 字段的一部分设置。</p><ul class="nav nav-tabs" id=exec-plugin-kubeconfig-example-1 role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#exec-plugin-kubeconfig-example-1-0 role=tab aria-controls=exec-plugin-kubeconfig-example-1-0 aria-selected=true>client.authentication.k8s.io/v1</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#exec-plugin-kubeconfig-example-1-1 role=tab aria-controls=exec-plugin-kubeconfig-example-1-1>client.authentication.k8s.io/v1beta1</a></li></ul><div class=tab-content id=exec-plugin-kubeconfig-example-1><div id=exec-plugin-kubeconfig-example-1-0 class="tab-pane show active" role=tabpanel aria-labelledby=exec-plugin-kubeconfig-example-1-0><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>users</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-user<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>exec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 要执行的命令。必需。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;example-client-go-exec-plugin&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 解析 ExecCredentials 资源时使用的 API 版本。必需。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 插件返回的 API 版本必需与这里列出的版本匹配。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 要与支持多个版本的工具（如 client.authentication.k8s.io/v1beta1）集成，</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 可以设置一个环境变量或者向工具传递一个参数标明 exec 插件所期望的版本，</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 或者从 KUBERNETES_EXEC_INFO 环境变量的 ExecCredential 对象中读取版本信息。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;client.authentication.k8s.io/v1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 执行此插件时要设置的环境变量。可选字段。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;FOO&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;bar&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 执行插件时要传递的参数。可选字段。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;arg1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;arg2&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 当可执行文件不存在时显示给用户的文本。可选的。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>installHint</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        需要 example-client-go-exec-plugin 来在当前集群上执行身份认证。可以通过以下命令安装：
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        MacOS: brew install example-client-go-exec-plugin
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        Ubuntu: apt-get install example-client-go-exec-plugin
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        Fedora: dnf install example-client-go-exec-plugin
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        ...</span><span style=color:#bbb>        
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 是否使用 KUBERNETES_EXEC_INFO 环境变量的一部分向这个 exec 插件</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 提供集群信息（可能包含非常大的 CA 数据）</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>provideClusterInfo</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># Exec 插件与标准输入 I/O 数据流之间的协议。如果协议无法满足，</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 则插件无法运行并会返回错误信息。合法的值包括 &#34;Never&#34; （Exec 插件从不使用标准输入），</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># &#34;IfAvailable&#34; （Exec 插件希望在可以的情况下使用标准输入），</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 或者 &#34;Always&#34; （Exec 插件需要使用标准输入才能工作）。必需字段。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>interactiveMode</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>clusters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-cluster<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>server</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;https://172.17.4.100:6443&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>certificate-authority</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/kubernetes/ca.pem&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>extensions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>client.authentication.k8s.io/exec<span style=color:#bbb> </span><span style=color:#080;font-style:italic># 为每个集群 exec 配置保留的扩展名</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>extension</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>arbitrary</span>:<span style=color:#bbb> </span>config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>this</span>:<span style=color:#bbb> </span>在设置 provideClusterInfo 时可通过环境变量 KUBERNETES_EXEC_INFO 指定<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>you</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;can&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;put&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;anything&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;here&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>contexts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-cluster<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>context</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb> </span>my-cluster<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb> </span>my-user<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>current-context</span>:<span style=color:#bbb> </span>my-cluster<span style=color:#bbb>
</span></span></span></code></pre></div></div><div id=exec-plugin-kubeconfig-example-1-1 class=tab-pane role=tabpanel aria-labelledby=exec-plugin-kubeconfig-example-1-1><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>users</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-user<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>exec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 要执行的命令。必需。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;example-client-go-exec-plugin&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 解析 ExecCredentials 资源时使用的 API 版本。必需。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 插件返回的 API 版本必需与这里列出的版本匹配。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 要与支持多个版本的工具（如 client.authentication.k8s.io/v1）集成，</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 可以设置一个环境变量或者向工具传递一个参数标明 exec 插件所期望的版本，</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 或者从 KUBERNETES_EXEC_INFO 环境变量的 ExecCredential 对象中读取版本信息。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;client.authentication.k8s.io/v1beta1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 执行此插件时要设置的环境变量。可选字段。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>env</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;FOO&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>value</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;bar&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 执行插件时要传递的参数。可选字段。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>args</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;arg1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:#b44>&#34;arg2&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 当可执行文件不存在时显示给用户的文本。可选的。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>installHint</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        需要 example-client-go-exec-plugin 来在当前集群上执行身份认证。可以通过以下命令安装：
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        MacOS: brew install example-client-go-exec-plugin
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        Ubuntu: apt-get install example-client-go-exec-plugin
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        Fedora: dnf install example-client-go-exec-plugin
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        ...</span><span style=color:#bbb>        
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 是否使用 KUBERNETES_EXEC_INFO 环境变量的一部分向这个 exec 插件</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 提供集群信息（可能包含非常大的 CA 数据）</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>provideClusterInfo</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># Exec 插件与标准输入 I/O 数据流之间的协议。如果协议无法满足，</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 则插件无法运行并会返回错误信息。合法的值包括 &#34;Never&#34; （Exec 插件从不使用标准输入），</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># &#34;IfAvailable&#34; （Exec 插件希望在可以的情况下使用标准输入），</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 或者 &#34;Always&#34; （Exec 插件需要使用标准输入才能工作）。可选字段。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 默认值为 &#34;IfAvailable&#34;。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>interactiveMode</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>clusters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-cluster<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>server</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;https://172.17.4.100:6443&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>certificate-authority</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;/etc/kubernetes/ca.pem&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>extensions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>client.authentication.k8s.io/exec<span style=color:#bbb> </span><span style=color:#080;font-style:italic># 为每个集群 exec 配置保留的扩展名</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>extension</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>arbitrary</span>:<span style=color:#bbb> </span>config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>this</span>:<span style=color:#bbb> </span>在设置 provideClusterInfo 时可通过环境变量 KUBERNETES_EXEC_INFO 指定<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>you</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;can&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;put&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;anything&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;here&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>contexts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-cluster<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>context</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb> </span>my-cluster<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb> </span>my-user<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>current-context</span>:<span style=color:#bbb> </span>my-cluster<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>解析相对命令路径时，kubectl 将其视为与配置文件比较而言的相对路径。
如果 KUBECONFIG 被设置为 <code>/home/jane/kubeconfig</code>，而 exec 命令为
<code>./bin/example-client-go-exec-plugin</code>，则要执行的可执行文件为
<code>/home/jane/bin/example-client-go-exec-plugin</code>。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-user<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>exec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 对 kubeconfig 目录而言的相对路径</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>command</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;./bin/example-client-go-exec-plugin&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;client.authentication.k8s.io/v1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>interactiveMode</span>:<span style=color:#bbb> </span>Never<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=input-and-output-formats>输出和输出格式</h3><p>所执行的命令会在 <code>stdout</code> 打印 <code>ExecCredential</code> 对象。
<code>k8s.io/client-go</code> 使用 <code>status</code> 中返回的凭据信息向 Kubernetes API 服务器执行身份认证。
所执行的命令会通过环境变量 <code>KUBERNETES_EXEC_INFO</code> 收到一个 <code>ExecCredential</code> 对象作为其输入。
此输入中包含类似于所返回的 <code>ExecCredential</code> 对象的预期 API 版本，
以及是否插件可以使用 <code>stdin</code> 与用户交互这类信息。</p><p>在交互式会话（即，某终端）中运行时，<code>stdin</code> 是直接暴露给插件使用的。
插件应该使用来自 <code>KUBERNETES_EXEC_INFO</code> 环境变量的 <code>ExecCredential</code>
输入对象中的 <code>spec.interactive</code> 字段来确定是否提供了 <code>stdin</code>。
插件的 <code>stdin</code> 需求（即，为了能够让插件成功运行，是否 <code>stdin</code> 是可选的、
必须提供的或者从不会被使用的）是通过
<a href=/zh-cn/docs/concepts/configuration/organize-cluster-access-kubeconfig/>kubeconfig</a>
中的 <code>user.exec.interactiveMode</code> 来声明的（参见下面的表格了解合法值）。
字段 <code>user.exec.interactiveMode</code> 在 <code>client.authentication.k8s.io/v1beta1</code>
中是可选的，在 <code>client.authentication.k8s.io/v1</code> 中是必需的。</p><table><caption style=display:none>interactiveMode 取值</caption><thead><tr><th><code>interactiveMode</code> 取值</th><th>含义</th></tr></thead><tbody><tr><td><code>Never</code></td><td>此 exec 插件从不需要使用标准输入，因此如论是否有标准输入提供给用户输入，该 exec 插件都能运行。</td></tr><tr><td><code>IfAvailable</code></td><td>此 exec 插件希望在标准输入可用的情况下使用标准输入，但在标准输入不存在时也可运行。因此，无论是否存在给用户提供输入的标准输入，此 exec 插件都会运行。如果存在供用户输入的标准输入，则该标准输入会被提供给 exec 插件。</td></tr><tr><td><code>Always</code></td><td>此 exec 插件需要标准输入才能正常运行，因此只有存在供用户输入的标准输入时，此 exec 插件才会运行。如果不存在供用户输入的标准输入，则 exec 插件无法运行，并且 exec 插件的执行者会因此返回错误信息。</td></tr></tbody></table><p>与使用持有者令牌凭据，插件在 <a href=/zh-cn/docs/reference/config-api/client-authentication.v1beta1/#client-authentication-k8s-io-v1beta1-ExecCredential><code>ExecCredential</code></a>
的状态中返回一个令牌：</p><ul class="nav nav-tabs" id=exec-plugin-execcredential-example-1 role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#exec-plugin-execcredential-example-1-0 role=tab aria-controls=exec-plugin-execcredential-example-1-0 aria-selected=true>client.authentication.k8s.io/v1</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#exec-plugin-execcredential-example-1-1 role=tab aria-controls=exec-plugin-execcredential-example-1-1>client.authentication.k8s.io/v1beta1</a></li></ul><div class=tab-content id=exec-plugin-execcredential-example-1><div id=exec-plugin-execcredential-example-1-0 class="tab-pane show active" role=tabpanel aria-labelledby=exec-plugin-execcredential-example-1-0><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;client.authentication.k8s.io/v1&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;ExecCredential&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;status&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;token&#34;</span>: <span style=color:#b44>&#34;my-bearer-token&#34;</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div><div id=exec-plugin-execcredential-example-1-1 class=tab-pane role=tabpanel aria-labelledby=exec-plugin-execcredential-example-1-1><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;client.authentication.k8s.io/v1beta1&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;ExecCredential&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;status&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;token&#34;</span>: <span style=color:#b44>&#34;my-bearer-token&#34;</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div></div><p>另一种方案是，返回 PEM 编码的客户端证书和密钥，以便执行 TLS 客户端身份认证。
如果插件在后续调用中返回了不同的证书或密钥，<code>k8s.io/client-go</code>
会终止其与服务器的连接，从而强制执行新的 TLS 握手过程。</p><p>如果指定了这种方式，则 <code>clientKeyData</code> 和 <code>clientCertificateData</code> 字段都必需存在。</p><p><code>clientCertificateData</code> 字段可能包含一些要发送给服务器的中间证书（Intermediate
Certificates）。</p><ul class="nav nav-tabs" id=exec-plugin-execcredential-example-2 role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#exec-plugin-execcredential-example-2-0 role=tab aria-controls=exec-plugin-execcredential-example-2-0 aria-selected=true>client.authentication.k8s.io/v1</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#exec-plugin-execcredential-example-2-1 role=tab aria-controls=exec-plugin-execcredential-example-2-1>client.authentication.k8s.io/v1beta1</a></li></ul><div class=tab-content id=exec-plugin-execcredential-example-2><div id=exec-plugin-execcredential-example-2-0 class="tab-pane show active" role=tabpanel aria-labelledby=exec-plugin-execcredential-example-2-0><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;client.authentication.k8s.io/v1&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;ExecCredential&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;status&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;clientCertificateData&#34;</span>: <span style=color:#b44>&#34;-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;clientKeyData&#34;</span>: <span style=color:#b44>&#34;-----BEGIN RSA PRIVATE KEY-----\n...\n-----END RSA PRIVATE KEY-----&#34;</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div><div id=exec-plugin-execcredential-example-2-1 class=tab-pane role=tabpanel aria-labelledby=exec-plugin-execcredential-example-2-1><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;client.authentication.k8s.io/v1beta1&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;ExecCredential&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;status&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;clientCertificateData&#34;</span>: <span style=color:#b44>&#34;-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;clientKeyData&#34;</span>: <span style=color:#b44>&#34;-----BEGIN RSA PRIVATE KEY-----\n...\n-----END RSA PRIVATE KEY-----&#34;</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div></div><p>作为一种可选方案，响应中还可以包含以 <a href=https://datatracker.ietf.org/doc/html/rfc3339>RFC 3339</a>
时间戳格式给出的证书到期时间。
证书到期时间的有无会有如下影响：</p><ul><li>如果响应中包含了到期时间，持有者令牌和 TLS 凭据会被缓存，直到期限到来、
或者服务器返回 401 HTTP 状态码，或者进程退出。</li><li>如果未指定到期时间，则持有者令牌和 TLS 凭据会被缓存，直到服务器返回 401
HTTP 状态码或者进程退出。</li></ul><ul class="nav nav-tabs" id=exec-plugin-execcredential-example-3 role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#exec-plugin-execcredential-example-3-0 role=tab aria-controls=exec-plugin-execcredential-example-3-0 aria-selected=true>client.authentication.k8s.io/v1</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#exec-plugin-execcredential-example-3-1 role=tab aria-controls=exec-plugin-execcredential-example-3-1>client.authentication.k8s.io/v1beta1</a></li></ul><div class=tab-content id=exec-plugin-execcredential-example-3><div id=exec-plugin-execcredential-example-3-0 class="tab-pane show active" role=tabpanel aria-labelledby=exec-plugin-execcredential-example-3-0><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;client.authentication.k8s.io/v1&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;ExecCredential&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;status&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;token&#34;</span>: <span style=color:#b44>&#34;my-bearer-token&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;expirationTimestamp&#34;</span>: <span style=color:#b44>&#34;2018-03-05T17:30:20-08:00&#34;</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div><div id=exec-plugin-execcredential-example-3-1 class=tab-pane role=tabpanel aria-labelledby=exec-plugin-execcredential-example-3-1><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;client.authentication.k8s.io/v1beta1&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;ExecCredential&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;status&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;token&#34;</span>: <span style=color:#b44>&#34;my-bearer-token&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;expirationTimestamp&#34;</span>: <span style=color:#b44>&#34;2018-03-05T17:30:20-08:00&#34;</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div></div><p>为了让 exec 插件能够获得特定与集群的信息，可以在
<a href=/zh-cn/docs/concepts/configuration/organize-cluster-access-kubeconfig/>kubeconfig</a>
中的 <code>user.exec</code> 设置 <code>provideClusterInfo</code>。
这一特定于集群的信息就会通过 <code>KUBERNETES_EXEC_INFO</code> 环境变量传递给插件。
此环境变量中的信息可以用来执行特定于集群的凭据获取逻辑。
下面的 <code>ExecCredential</code> 清单描述的是一个示例集群信息。</p><ul class="nav nav-tabs" id=exec-plugin-execcredential-example-4 role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#exec-plugin-execcredential-example-4-0 role=tab aria-controls=exec-plugin-execcredential-example-4-0 aria-selected=true>client.authentication.k8s.io/v1</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#exec-plugin-execcredential-example-4-1 role=tab aria-controls=exec-plugin-execcredential-example-4-1>client.authentication.k8s.io/v1beta1</a></li></ul><div class=tab-content id=exec-plugin-execcredential-example-4><div id=exec-plugin-execcredential-example-4-0 class="tab-pane show active" role=tabpanel aria-labelledby=exec-plugin-execcredential-example-4-0><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;client.authentication.k8s.io/v1&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;ExecCredential&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;spec&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;cluster&#34;</span>: {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;server&#34;</span>: <span style=color:#b44>&#34;https://172.17.4.100:6443&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;certificate-authority-data&#34;</span>: <span style=color:#b44>&#34;LS0t...&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;config&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;arbitrary&#34;</span>: <span style=color:#b44>&#34;config&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;this&#34;</span>: <span style=color:#b44>&#34;可以在设置 provideClusterInfo 时通过 KUBERNETES_EXEC_INFO 环境变量提供&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;you&#34;</span>: [<span style=color:#b44>&#34;can&#34;</span>, <span style=color:#b44>&#34;put&#34;</span>, <span style=color:#b44>&#34;anything&#34;</span>, <span style=color:#b44>&#34;here&#34;</span>]
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;interactive&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div><div id=exec-plugin-execcredential-example-4-1 class=tab-pane role=tabpanel aria-labelledby=exec-plugin-execcredential-example-4-1><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;client.authentication.k8s.io/v1beta1&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;ExecCredential&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;spec&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;cluster&#34;</span>: {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;server&#34;</span>: <span style=color:#b44>&#34;https://172.17.4.100:6443&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;certificate-authority-data&#34;</span>: <span style=color:#b44>&#34;LS0t...&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;config&#34;</span>: {
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;arbitrary&#34;</span>: <span style=color:#b44>&#34;config&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;this&#34;</span>: <span style=color:#b44>&#34;可以在设置 provideClusterInfo 时通过 KUBERNETES_EXEC_INFO 环境变量提供&#34;</span>,
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;you&#34;</span>: [<span style=color:#b44>&#34;can&#34;</span>, <span style=color:#b44>&#34;put&#34;</span>, <span style=color:#b44>&#34;anything&#34;</span>, <span style=color:#b44>&#34;here&#34;</span>]
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;interactive&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div></div><h2 id=接下来>接下来</h2><ul><li>阅读<a href=/zh-cn/docs/reference/config-api/client-authentication.v1beta1/>客户端认证参考文档 (v1beta1)</a></li><li>阅读<a href=/zh-cn/docs/reference/config-api/client-authentication.v1/>客户端认证参考文档 (v1)</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-de45b6ca7419a0e308044425b2ac52bb>2 - 使用启动引导令牌（Bootstrap Tokens）认证</h1><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.18 [stable]</code></div><p>启动引导令牌是一种简单的持有者令牌（Bearer Token），这种令牌是在新建集群
或者在现有集群中添加新节点时使用的。
它被设计成能够支持 <a href=/zh-cn/docs/reference/setup-tools/kubeadm/><code>kubeadm</code></a>，
但是也可以被用在其他的案例中以便用户在不使用 <code>kubeadm</code> 的情况下启动集群。
它也被设计成可以通过 RBAC 策略，结合
<a href=/zh-cn/docs/reference/access-authn-authz/kubelet-tls-bootstrapping/>Kubelet TLS 启动引导</a>
系统进行工作。</p><p>启动引导令牌被定义成一个特定类型的 Secret（<code>bootstrap.kubernetes.io/token</code>），
并存在于 <code>kube-system</code> 名字空间中。
这些 Secret 会被 API 服务器上的启动引导认证组件（Bootstrap Authenticator）读取。
控制器管理器中的控制器 TokenCleaner 能够删除过期的令牌。
这些令牌也被用来在节点发现的过程中会使用的一个特殊的 ConfigMap 对象。
BootstrapSigner 控制器也会使用这一 ConfigMap。</p><h2 id=令牌格式>令牌格式</h2><p>启动引导令牌使用 <code>abcdef.0123456789abcdef</code> 的形式。
更加规范地说，它们必须符合正则表达式 <code>[a-z0-9]{6}\.[a-z0-9]{16}</code>。</p><p>令牌的第一部分是 “Token ID”，它是一种公开信息，用于引用令牌并确保不会
泄露认证所使用的秘密信息。
第二部分是“令牌秘密（Token Secret）”，它应该被共享给受信的第三方。</p><h2 id=启用启动引导令牌>启用启动引导令牌</h2><h2 id=enabling-bootstrap-token-authentication>启用启动引导令牌身份认证</h2><p>启动引导令牌认证组件可以通过 API 服务器上的如下标志启用：</p><pre tabindex=0><code>--enable-bootstrap-token-auth
</code></pre><p>启动引导令牌被启用后，可以作为持有者令牌的凭据，用于 API 服务器请求的身份认证。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=display:flex><span><span>Authorization: Bearer 07401b.f395accd246ae52d
</span></span></span></code></pre></div><p>令牌认证为用户名 <code>system:bootstrap:&lt;token id></code> 并且是组 <code>system:bootstrappers</code>
的成员。额外的组信息可以通过令牌的 Secret 来设置。</p><p>过期的令牌可以通过启用控制器管理器中的 <code>tokencleaner</code> 控制器来删除。</p><pre tabindex=0><code>--controllers=*,tokencleaner
</code></pre><h2 id=bootstrap-token-secret-format>启动引导令牌的 Secret 格式</h2><p>每个合法的令牌背后对应着 <code>kube-system</code> 名字空间中的某个 Secret 对象。
你可以从
<a href=https://github.com/kubernetes/design-proposals-archive/blob/main/cluster-lifecycle/bootstrap-discovery.md>这里</a>
找到完整设计文档。</p><p>这是 Secret 看起来的样子。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># name 必须是 &#34;bootstrap-token-&lt;token id&gt;&#34; 格式的</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>bootstrap-token-07401b<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># type 必须是 &#39;bootstrap.kubernetes.io/token&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>bootstrap.kubernetes.io/token<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>stringData</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 供人阅读的描述，可选。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>description</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;The default bootstrap token generated by &#39;kubeadm init&#39;.&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 令牌 ID 和秘密信息，必需。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>token-id</span>:<span style=color:#bbb> </span>07401b<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>token-secret</span>:<span style=color:#bbb> </span>f395accd246ae52d<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 可选的过期时间字段</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>expiration</span>:<span style=color:#bbb> </span>2017-03-10T03:22:11Z<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 允许的用法</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>usage-bootstrap-authentication</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>usage-bootstrap-signing</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 令牌要认证为的额外组，必须以 &#34;system:bootstrappers:&#34; 开头</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>auth-extra-groups</span>:<span style=color:#bbb> </span>system:bootstrappers:worker,system:bootstrappers:ingress<span style=color:#bbb>
</span></span></span></code></pre></div><p>Secret 的类型必须是 <code>bootstrap.kubernetes.io/token</code>，而且名字必须是 <code>bootstrap-token-&lt;token id></code>。
令牌必须存在于 <code>kube-system</code> 名字空间中。</p><p><code>usage-bootstrap-*</code> 成员表明这个 Secret 的用途。启用时，值必须设置为 <code>true</code>。</p><ul><li><code>usage-bootstrap-authentication</code> 表示令牌可以作为持有者令牌用于 API 服务器的身份认证。</li><li><code>usage-bootstrap-signing</code> 表示令牌可被用于 <code>cluster-info</code> ConfigMap 的签名，
就像下面描述的那样。</li></ul><p><code>expiration</code> 字段控制令牌的失效期。过期的令牌在用于身份认证时会被拒绝，在用于
ConfigMap 签名时会被忽略。
过期时间值是遵循 RFC3339 进行编码的 UTC 时间。
启用 TokenCleaner 控制器会自动删除过期的令牌。</p><h2 id=token-management-with-kubeadm>使用 <code>kubeadm</code> 管理令牌</h2><p>你可以使用 <code>kubeadm</code> 工具管理运行中集群上的令牌。
参见 <a href=/zh-cn/docs/reference/setup-tools/kubeadm/kubeadm-token/>kubeadm token 文档</a>
以了解详细信息。</p><h3 id=configmap-signing>ConfigMap 签名</h3><p>除了身份认证，令牌还可以用于签名 ConfigMap。
这一用法发生在集群启动过程的早期，在客户端信任 API 服务器之前。
被签名的 ConfigMap 可以被共享令牌完成身份认证。</p><p>通过在控制器管理器上启用 <code>bootstrapsigner</code> 控制器可以启用 ConfigMap 签名特性。</p><pre tabindex=0><code>--controllers=*,bootstrapsigner
</code></pre><p>被签名的 ConfigMap 是 <code>kube-public</code> 名字空间中的 <code>cluster-info</code>。
典型的工作流中，客户端在未经认证和忽略 TLS 报错的状态下读取这个 ConfigMap。
通过检查 ConfigMap 中嵌入的签名校验 ConfigMap 的载荷。</p><p>ConfigMap 会是这个样子的：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cluster-info<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-public<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>jws-kubeconfig-07401b</span>:<span style=color:#bbb> </span>eyJhbGciOiJIUzI1NiIsImtpZCI6IjA3NDAxYiJ9..tYEfbo6zDNo40MQE07aZcQX2m3EB2rO3NuXtxVMYm9U<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kubeconfig</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    clusters:
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    - cluster:
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        certificate-authority-data: &lt;非常长的证书数据&gt;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>        server: https://10.138.0.2:6443
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      name: &#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    contexts: []
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    current-context: &#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    kind: Config
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    preferences: {}
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>    users: []</span><span style=color:#bbb>    
</span></span></span></code></pre></div><p>ConfigMap 的 <code>kubeconfig</code> 成员是一个填好了集群信息的配置文件。
这里主要交换的信息是 <code>certificate-authority-data</code>。在将来可能会有扩展。</p><p>签名是一个使用 “detached” 模式生成的 JWS 签名。
为了检验签名，用户应该按照 JWS 规则（base64 编码且丢掉结尾的 <code>=</code>）对
<code>kubeconfig</code> 的载荷进行编码。完成编码的载荷会被插入到两个句点中间，形成完整的
JWS。你可以使用完整的令牌（比如 <code>07401b.f395accd246ae52d</code>）作为共享密钥，
通过 <code>HS256</code> 方式 (HMAC-SHA256) 对 JWS 进行校验。
用户<strong>必须</strong>确保使用了 HS256。</p><div class="alert alert-danger warning callout" role=alert><strong>警告：</strong><p>任何拥有了启动引导令牌的主体都可以为该令牌生成一个合法的签名。
当使用 ConfigMap 签名时，非常不建议针对很多客户使用相同的令牌，因为某个被攻击的
客户可能对另一个一来签名来开启 TLS 信任的客户发起中间人攻击。</div><p>参考 <a href=/zh-cn/docs/reference/setup-tools/kubeadm/implementation-details/>kubeadm 实现细节</a>
了解更多信息。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-3d0c14d1e3cfade38febc343cd044c73>3 - 证书签名请求</h1><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.19 [stable]</code></div><p>证书 API 支持
<a href=https://www.itu.int/rec/T-REC-X.509>X.509</a>
的自动化配置，
它为 Kubernetes API 的客户端提供一个编程接口，
用于从证书颁发机构（CA）请求并获取 X.509
<a class=glossary-tooltip title='证书是个安全加密文件，用来确认对 Kubernetes 集群访问的合法性。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/tasks/tls/managing-tls-in-a-cluster/ target=_blank aria-label=证书>证书</a>。</p><p>CertificateSigningRequest（CSR）资源用来向指定的签名者申请证书签名，
在最终签名之前，申请可能被批准，也可能被拒绝。</p><h2 id=request-signing-process>请求签名流程</h2><p>CertificateSigningRequest 资源类型允许客户使用它申请发放 X.509 证书。
CertificateSigningRequest 对象 在 <code>spec.request</code> 中包含一个 PEM 编码的 PKCS#10 签名请求。
CertificateSigningRequest 使用 <code>spec.signerName</code> 字段标示 <em>签名者</em>（请求的接收方）。
注意，<code>spec.signerName</code> 在 <code>certificates.k8s.io/v1</code> 之后的 API 版本是必填项。
在 Kubernetes v1.22 和以后的版本，客户可以可选地设置 <code>spec.expirationSeconds</code>
字段来为颁发的证书设定一个特定的有效期。该字段的最小有效值是 <code>600</code>，也就是 10 分钟。</p><p>创建完成的 CertificateSigningRequest，要先通过批准，然后才能签名。
根据所选的签名者，CertificateSigningRequest 可能会被
<a class=glossary-tooltip title='控制器通过 API 服务器监控集群的公共状态，并致力于将当前状态转变为期望的状态。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/architecture/controller/ target=_blank aria-label=控制器>控制器</a>自动批准。
否则，就必须人工批准，
人工批准可以使用 REST API（或 go 客户端），也可以执行 <code>kubectl certificate approve</code> 命令。
同样，CertificateSigningRequest 也可能被驳回，
这就相当于通知了指定的签名者，这个证书不能签名。</p><p>对于已批准的证书，下一步是签名。
对应的签名控制器首先验证签名条件是否满足，然后才创建证书。
签名控制器然后更新 CertificateSigningRequest，
将新证书保存到现有 CertificateSigningRequest 对象的 <code>status.certificate</code> 字段中。
此时，字段 <code>status.certificate</code> 要么为空，要么包含一个用 PEM 编码的 X.509 证书。
直到签名完成前，CertificateSigningRequest 的字段 <code>status.certificate</code> 都为空。</p><p>一旦 <code>status.certificate</code> 字段完成填充，请求既算完成，
客户端现在可以从 CertificateSigningRequest 资源中获取已签名的证书的 PEM 数据。
当然如果不满足签名条件，签名者可以拒签。</p><p>为了减少集群中遗留的过时的 CertificateSigningRequest 资源的数量，
一个垃圾收集控制器将会周期性地运行。
此垃圾收集器会清除在一段时间内没有改变过状态的 CertificateSigningRequests：</p><ul><li>已批准的请求：1小时后自动删除</li><li>已拒绝的请求：1小时后自动删除</li><li>已失败的请求：1小时后自动删除</li><li>挂起的请求：24小时后自动删除</li><li>所有请求：在颁发的证书过期后自动删除</li></ul><h2 id=signers>签名者</h2><p>也可以指定自定义 signerName。
所有签名者都应该提供自己工作方式的信息，
以便客户端可以预期到他们的 CSR 将发生什么。
此类信息包括：</p><ol><li><strong>信任分发</strong>：信任（CA 证书包）是如何分发的。</li><li><strong>许可的主体</strong>：当一个受限制的主体（subject）发送请求时，相应的限制和应对手段。</li><li><strong>许可的 x509 扩展</strong>：包括 IP subjectAltNames、DNS subjectAltNames、
Email subjectAltNames、URI subjectAltNames 等，请求一个受限制的扩展项时的应对手段。</li><li><strong>许可的密钥用途/扩展的密钥用途</strong>：当用途和签名者在 CSR 中指定的用途不同时，
相应的限制和应对手段。</li><li><strong>过期时间/证书有效期</strong>：过期时间由签名者确定、由管理员配置、还是由 CSR <code>spec.expirationSeconds</code> 字段指定等，
以及签名者决定的过期时间与 CSR <code>spec.expirationSeconds</code> 字段不同时的应对手段。</li><li><strong>允许/不允许 CA 位</strong>：当 CSR 包含一个签名者并不允许的 CA 证书的请求时，相应的应对手段。</li></ol><p>一般来说，当 CSR 被批准通过，且证书被签名后，<code>status.certificate</code> 字段
将包含一个 PEM 编码的 X.509 证书。
有些签名者在 <code>status.certificate</code> 字段中存储多个证书。
在这种情况下，签名者的说明文档应当指明附加证书的含义。
例如，这是要在 TLS 握手时提供的证书和中继证书。</p><p>PKCS#10 签名请求格式并没有一种标准的方法去设置证书的过期时间或者生命期。
因此，证书的过期时间或者生命期必须通过 CSR 对象的 <code>spec.expirationSeconds</code> 字段来设置。
当 <code>spec.expirationSeconds</code> 没有被指定时，内置的签名者默认使用 <code>ClusterSigningDuration</code> 配置选项
（kube-controller-manager 的命令行选项 <code>--cluster-signing-duration</code>），该选项的默认值设为 1 年。
当 <code>spec.expirationSeconds</code> 被指定时，<code>spec.expirationSeconds</code> 和 <code>ClusterSigningDuration</code>
中的最小值会被使用。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p><code>spec.expirationSeconds</code> 字段是在 Kubernetes v1.22 中加入的。早期的 Kubernetes 版本并不认识该字段。
v1.22 版本之前的 Kubernetes API 服务器会在创建对象的时候忽略该字段。</div><h3 id=kubernetes-signers>Kubernetes 签名者</h3><p>Kubernetes提供了内置的签名者，每个签名者都有一个众所周知的 <code>signerName</code>:</p><ol><li><code>kubernetes.io/kube-apiserver-client</code>：签名的证书将被 API 服务器视为客户证书。
<a class=glossary-tooltip title=主节点上运行控制器的组件。 data-toggle=tooltip data-placement=top href=/zh-cn/docs/reference/command-line-tools-reference/kube-controller-manager/ target=_blank aria-label=kube-controller-manager>kube-controller-manager</a> 不会自动批准它。<ol><li>信任分发：签名的证书将被 API 服务器视为客户端证书。CA 证书包不通过任何其他方式分发。</li><li>许可的主体：没有主体限制，但审核人和签名者可以选择不批准或不签署。
某些主体，比如集群管理员级别的用户或组因部署和安装方式不同而不同，
所以批准和签署之前需要进行额外仔细审查。
用来限制 <code>system:masters</code> 的 CertificateSubjectRestriction 准入插件默认处于启用状态，
但它通常不是集群中唯一的集群管理员主体。</li><li>许可的 x509 扩展：允许 subjectAltName 和 key usage 扩展，弃用其他扩展。</li><li>许可的密钥用途：必须包含 <code>["client auth"]</code>，但不能包含
<code>["digital signature", "key encipherment", "client auth"]</code> 之外的键。</li><li>过期时间/证书有效期：对于 kube-controller-manager 实现的签名者，
设置为 <code>--cluster-signing-duration</code> 选项和 CSR 对象的 <code>spec.expirationSeconds</code> 字段（如有设置该字段）中的最小值。</li><li>允许/不允许 CA 位：不允许。</li></ol></li></ol><ol start=2><li><p><code>kubernetes.io/kube-apiserver-client-kubelet</code>: 签名的证书将被 kube-apiserver 视为客户证书。
<a class=glossary-tooltip title=主节点上运行控制器的组件。 data-toggle=tooltip data-placement=top href=/zh-cn/docs/reference/command-line-tools-reference/kube-controller-manager/ target=_blank aria-label=kube-controller-manager>kube-controller-manager</a> 可以自动批准它。</p><ol><li>信任分发：签名的证书将被 API 服务器视为客户端证书。CA 证书包不通过任何其他方式分发。</li><li>许可的主体：组织名必须是 <code>["system:nodes"]</code>，用户名以 "<code>system:node:</code>" 开头</li><li>许可的 x509 扩展：允许 key usage 扩展，禁用 subjectAltName 扩展，并删除其他扩展。</li><li>许可的密钥用途：必须是 <code>["key encipherment", "digital signature", "client auth"]</code></li><li>过期时间/证书有效期：对于 kube-controller-manager 实现的签名者，
设置为 <code>--cluster-signing-duration</code> 选项和 CSR 对象的 <code>spec.expirationSeconds</code> 字段（如有设置该字段）中的最小值。</li><li>允许/不允许 CA 位：不允许。</li></ol></li></ol><ol start=3><li><code>kubernetes.io/kubelet-serving</code>: 签名服务证书，该服务证书被 API 服务器视为有效的 kubelet 服务证书，
但没有其他保证。<a class=glossary-tooltip title=主节点上运行控制器的组件。 data-toggle=tooltip data-placement=top href=/zh-cn/docs/reference/command-line-tools-reference/kube-controller-manager/ target=_blank aria-label=kube-controller-manager>kube-controller-manager</a> 不会自动批准它。<ol><li>信任分发：签名的证书必须被 kube-apiserver 认可，可有效的中止 kubelet 连接。CA 证书包不通过任何其他方式分发。</li><li>许可的主体：组织名必须是 <code>["system:nodes"]</code>，用户名以 "<code>system:node:</code>" 开头</li><li>许可的 x509 扩展：允许 key usage、DNSName/IPAddress subjectAltName 等扩展，
禁止 EmailAddress、URI subjectAltName 等扩展，并丢弃其他扩展。
至少有一个 DNS 或 IP 的 SubjectAltName 存在。</li><li>许可的密钥用途：必须是 <code>["key encipherment", "digital signature", "server auth"]</code></li><li>过期时间/证书有效期：对于 kube-controller-manager 实现的签名者，
设置为 <code>--cluster-signing-duration</code> 选项和 CSR 对象的 <code>spec.expirationSeconds</code> 字段（如有设置该字段）中的最小值。</li><li>允许/不允许 CA 位：不允许。</li></ol></li></ol><ol start=4><li><code>kubernetes.io/legacy-unknown</code>: 不保证信任。Kubernetes 的一些第三方发行版可能会使用它签署的客户端证书。
稳定版的 CertificateSigningRequest API（<code>certificates.k8s.io/v1</code> 以及之后的版本）不允许将
<code>signerName</code> 设置为 <code>kubernetes.io/legacy-unknown</code>。
<a class=glossary-tooltip title=主节点上运行控制器的组件。 data-toggle=tooltip data-placement=top href=/zh-cn/docs/reference/command-line-tools-reference/kube-controller-manager/ target=_blank aria-label=kube-controller-manager>kube-controller-manager</a> 不会自动批准这类请求。<ol><li>信任分发：没有。这个签名者在 Kubernetes 集群中没有标准的信任或分发。</li><li>许可的主体：全部。</li><li>许可的 x509 扩展：允许 subjectAltName 和 key usage 等扩展，并弃用其他扩展。</li><li>许可的密钥用途：全部。</li><li>过期时间/证书有效期：对于 kube-controller-manager 实现的签名者，
设置为 <code>--cluster-signing-duration</code> 选项和 CSR 对象的 <code>spec.expirationSeconds</code> 字段（如有设置该字段）中的最小值。</li><li>允许/不允许 CA 位 - 不允许。</li></ol></li></ol><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>注意：所有这些故障仅在 kube-controller-manager 日志中报告。</div><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p><code>spec.expirationSeconds</code> 字段是在 Kubernetes v1.22 中加入的。早期的 Kubernetes 版本并不认识该字段。
v1.22 版本之前的 Kubernetes API 服务器会在创建对象的时候忽略该字段。</div><p>对于这些签名者，信任的分发发生在带外（out of band）。上述信任之外的任何信任都是完全巧合的。
例如，一些发行版可能会将 <code>kubernetes.io/legacy-unknown</code> 作为 kube-apiserver 的客户端证书，
但这个做法并不标准。
这些用途都没有以任何方式涉及到 ServiceAccount 中的 Secrets <code>.data[ca.crt]</code>。
此 CA 证书包只保证使用默认的服务（<code>kubernetes.default.svc</code>）来验证到 API 服务器的连接。</p><h2 id=authorization>鉴权</h2><p>授权创建 CertificateSigningRequest 和检索 CertificateSigningRequest:</p><ul><li>verbs（动词）: <code>create</code>、<code>get</code>、<code>list</code>、<code>watch</code>,
group（组）：<code>certificates.k8s.io</code>，
resources：<code>certificatesigningrequests</code></li></ul><p>例如：</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/access/certificate-signing-request/clusterrole-create.yaml download=access/certificate-signing-request/clusterrole-create.yaml><code>access/certificate-signing-request/clusterrole-create.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("access-certificate-signing-request-clusterrole-create-yaml")' title="Copy access/certificate-signing-request/clusterrole-create.yaml to clipboard"></img></div><div class=includecode id=access-certificate-signing-request-clusterrole-create-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>csr-creator<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- certificates.k8s.io<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- certificatesigningrequests<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- create<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- get<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- list<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- watch<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>授权批准 CertificateSigningRequest：</p><ul><li>verbs（动词）: <code>get</code>、<code>list</code>、<code>watch</code>，
group（组）：<code>certificates.k8s.io</code>，
resources（资源）：<code>certificatesigningrequests</code></li><li>verbs（动词）: <code>update</code>，
group（组）：<code>certificates.k8s.io</code>，
resources（资源）：<code>certificatesigningrequests/approval</code></li><li>verbs（动词）：<code>approve</code>，
group（组）：<code>certificates.k8s.io</code>，
resources（资源）：<code>signers</code>，
resourceName：<code>&lt;signerNameDomain>/&lt;signerNamePath></code> 或 <code>&lt;signerNameDomain>/*</code></li></ul><p>例如：</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/access/certificate-signing-request/clusterrole-approve.yaml download=access/certificate-signing-request/clusterrole-approve.yaml><code>access/certificate-signing-request/clusterrole-approve.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("access-certificate-signing-request-clusterrole-approve-yaml")' title="Copy access/certificate-signing-request/clusterrole-approve.yaml to clipboard"></img></div><div class=includecode id=access-certificate-signing-request-clusterrole-approve-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>csr-approver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- certificates.k8s.io<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- certificatesigningrequests<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- get<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- list<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- watch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- certificates.k8s.io<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- certificatesigningrequests/approval<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- certificates.k8s.io<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- signers<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceNames</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- example.com/my-signer-name<span style=color:#bbb> </span><span style=color:#080;font-style:italic># example.com/* 可用于为 “example.com” 域中的所有签名者授权</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- approve<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>授权签名 CertificateSigningRequest：</p><ul><li>verbs（动词）：<code>get</code>、<code>list</code>、<code>watch</code>，
group（组）：<code>certificates.k8s.io</code>，
resources（资源）：<code>certificatesigningrequests</code></li><li>verbs（动词）：<code>update</code>，
group（组）：<code>certificates.k8s.io</code>，
resources（资源）：<code>certificatesigningrequests/status</code></li><li>verbs（动词）：<code>sign</code>，
group（组）：<code>certificates.k8s.io</code>，
resources（资源）：<code>signers</code>，
resourceName：<code>&lt;signerNameDomain>/&lt;signerNamePath></code> 或 <code>&lt;signerNameDomain>/*</code></li></ul><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/access/certificate-signing-request/clusterrole-sign.yaml download=access/certificate-signing-request/clusterrole-sign.yaml><code>access/certificate-signing-request/clusterrole-sign.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("access-certificate-signing-request-clusterrole-sign-yaml")' title="Copy access/certificate-signing-request/clusterrole-sign.yaml to clipboard"></img></div><div class=includecode id=access-certificate-signing-request-clusterrole-sign-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>csr-signer<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- certificates.k8s.io<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- certificatesigningrequests<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- get<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- list<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- watch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- certificates.k8s.io<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- certificatesigningrequests/status<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- certificates.k8s.io<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- signers<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceNames</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- example.com/my-signer-name<span style=color:#bbb> </span><span style=color:#080;font-style:italic># example.com/* 可用于为 “example.com” 域中的所有签名者授权</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- sign<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><h2 id=normal-user>普通用户</h2><p>为了让普通用户能够通过认证并调用 API，需要执行几个步骤。
首先，该用户必须拥有 Kubernetes 集群签发的证书，
然后将该证书提供给 Kubernetes API。</p><h3 id=create-private-key>创建私钥</h3><p>下面的脚本展示了如何生成 PKI 私钥和 CSR。
设置 CSR 的 CN 和 O 属性很重要。CN 是用户名，O 是该用户归属的组。
你可以参考 <a href=/zh-cn/docs/reference/access-authn-authz/rbac/>RBAC</a> 了解标准组的信息。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>openssl genrsa -out myuser.key <span style=color:#666>2048</span>
</span></span><span style=display:flex><span>openssl req -new -key myuser.key -out myuser.csr
</span></span></code></pre></div><h3 id=create-certificatesigningrequest>创建 CertificateSigningRequest</h3><p>创建一个 CertificateSigningRequest，并通过 kubectl 将其提交到 Kubernetes 集群。
下面是生成 CertificateSigningRequest 的脚本。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF | kubectl apply -f -
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: certificates.k8s.io/v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: CertificateSigningRequest
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: myuser
</span></span></span><span style=display:flex><span><span style=color:#b44>spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>  request: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURSBSRVFVRVNULS0tLS0KTUlJQ1ZqQ0NBVDRDQVFBd0VURVBNQTBHQTFVRUF3d0dZVzVuWld4aE1JSUJJakFOQmdrcWhraUc5dzBCQVFFRgpBQU9DQVE4QU1JSUJDZ0tDQVFFQTByczhJTHRHdTYxakx2dHhWTTJSVlRWMDNHWlJTWWw0dWluVWo4RElaWjBOCnR2MUZtRVFSd3VoaUZsOFEzcWl0Qm0wMUFSMkNJVXBGd2ZzSjZ4MXF3ckJzVkhZbGlBNVhwRVpZM3ExcGswSDQKM3Z3aGJlK1o2MVNrVHF5SVBYUUwrTWM5T1Nsbm0xb0R2N0NtSkZNMUlMRVI3QTVGZnZKOEdFRjJ6dHBoaUlFMwpub1dtdHNZb3JuT2wzc2lHQ2ZGZzR4Zmd4eW8ybmlneFNVekl1bXNnVm9PM2ttT0x1RVF6cXpkakJ3TFJXbWlECklmMXBMWnoyalVnald4UkhCM1gyWnVVV1d1T09PZnpXM01LaE8ybHEvZi9DdS8wYk83c0x0MCt3U2ZMSU91TFcKcW90blZtRmxMMytqTy82WDNDKzBERHk5aUtwbXJjVDBnWGZLemE1dHJRSURBUUFCb0FBd0RRWUpLb1pJaHZjTgpBUUVMQlFBRGdnRUJBR05WdmVIOGR4ZzNvK21VeVRkbmFjVmQ1N24zSkExdnZEU1JWREkyQTZ1eXN3ZFp1L1BVCkkwZXpZWFV0RVNnSk1IRmQycVVNMjNuNVJsSXJ3R0xuUXFISUh5VStWWHhsdnZsRnpNOVpEWllSTmU3QlJvYXgKQVlEdUI5STZXT3FYbkFvczFqRmxNUG5NbFpqdU5kSGxpT1BjTU1oNndLaTZzZFhpVStHYTJ2RUVLY01jSVUyRgpvU2djUWdMYTk0aEpacGk3ZnNMdm1OQUxoT045UHdNMGM1dVJVejV4T0dGMUtCbWRSeEgvbUNOS2JKYjFRQm1HCkkwYitEUEdaTktXTU0xMzhIQXdoV0tkNjVoVHdYOWl4V3ZHMkh4TG1WQzg0L1BHT0tWQW9FNkpsYWFHdTlQVmkKdjlOSjVaZlZrcXdCd0hKbzZXdk9xVlA3SVFjZmg3d0drWm89Ci0tLS0tRU5EIENFUlRJRklDQVRFIFJFUVVFU1QtLS0tLQo=
</span></span></span><span style=display:flex><span><span style=color:#b44>  signerName: kubernetes.io/kube-apiserver-client
</span></span></span><span style=display:flex><span><span style=color:#b44>  expirationSeconds: 86400  # one day
</span></span></span><span style=display:flex><span><span style=color:#b44>  usages:
</span></span></span><span style=display:flex><span><span style=color:#b44>  - client auth
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>需要注意的几点:</p><ul><li><code>usage</code> 字段必须是 '<code>client auth</code>'</li><li><code>expirationSeconds</code> 可以设置为更长（例如 <code>864000</code> 是十天）或者更短（例如 <code>3600</code> 是一个小时）</li><li><code>request</code> 字段是 CSR 文件内容的 base64 编码值。
要得到该值，可以执行命令 <code>cat myuser.csr | base64 | tr -d "\n"</code>。</li></ul><h3 id=approve-certificate-signing-request>批准证书签名请求</h3><p>使用 kubectl 创建 CSR 并批准。</p><p>获取 CSR 列表：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get csr
</span></span></code></pre></div><p>批准 CSR：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl certificate approve myuser
</span></span></code></pre></div><h3 id=get-the-certificate>取得证书</h3><p>从 CSR 取得证书：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get csr/myuser -o yaml
</span></span></code></pre></div><p>证书的内容使用 base64 编码，存放在字段 <code>status.certificate</code>。</p><p>从 CertificateSigningRequest 导出颁发的证书。</p><pre tabindex=0><code>kubectl get csr myuser -o jsonpath=&#39;{.status.certificate}&#39;| base64 -d &gt; myuser.crt
</code></pre><h3 id=create-role-and-role-binding>创建角色和角色绑定</h3><p>创建了证书之后，为了让这个用户能访问 Kubernetes 集群资源，现在就要创建
Role 和 RoleBinding 了。</p><p>下面是为这个新用户创建 Role 的示例命令：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create role developer --verb<span style=color:#666>=</span>create --verb<span style=color:#666>=</span>get --verb<span style=color:#666>=</span>list --verb<span style=color:#666>=</span>update --verb<span style=color:#666>=</span>delete --resource<span style=color:#666>=</span>pods
</span></span></code></pre></div><p>下面是为这个新用户创建 RoleBinding 的示例命令：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create rolebinding developer-binding-myuser --role<span style=color:#666>=</span>developer --user<span style=color:#666>=</span>myuser
</span></span></code></pre></div><h3 id=add-to-kubeconfig>添加到 kubeconfig</h3><p>最后一步是将这个用户添加到 kubeconfig 文件。
我们假设私钥和证书文件存放在 “/home/vagrant/work/” 目录中。</p><p>首先，我们需要添加新的凭据：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config set-credentials myuser --client-key<span style=color:#666>=</span>myuser.key --client-certificate<span style=color:#666>=</span>myuser.crt --embed-certs<span style=color:#666>=</span><span style=color:#a2f>true</span>
</span></span></code></pre></div><p>然后，你需要添加上下文：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config set-context myuser --cluster<span style=color:#666>=</span>kubernetes --user<span style=color:#666>=</span>myuser
</span></span></code></pre></div><p>来测试一下，把上下文切换为 <code>myuser</code>：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config use-context myuser
</span></span></code></pre></div><h2 id=approval-rejection>批准和驳回</h2><h3 id=approval-rejection-control-plane>控制平面的自动化批准</h3><p>kube-controller-manager 内建了一个证书批准者，其 signerName 为
<code>kubernetes.io/kube-apiserver-client-kubelet</code>，
该批准者将 CSR 上用于节点凭据的各种权限委托给权威认证机构。
kube-controller-manager 将 SubjectAccessReview 资源发送（POST）到 API 服务器，
以便检验批准证书的授权。</p><h3 id=approval-rejection-kubectl>使用 <code>kubectl</code> 批准或驳回</h3><p>Kubernetes 管理员（拥有足够的权限）可以手工批准（或驳回）CertificateSigningRequests，
此操作使用 <code>kubectl certificate approve</code> 和 <code>kubectl certificate deny</code> 命令实现。</p><p>使用 kubectl 批准一个 CSR：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl certificate approve &lt;certificate-signing-request-name&gt;
</span></span></code></pre></div><p>同样地，驳回一个 CSR：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl certificate deny &lt;certificate-signing-request-name&gt;
</span></span></code></pre></div><h3 id=approval-rejection-api-client>使用 Kubernetes API 批准或驳回</h3><p>REST API 的用户可以通过向待批准的 CSR 的 <code>approval</code> 子资源提交更新请求来批准 CSR。
例如，你可以编写一个
<a class=glossary-tooltip title=一种用于管理自定义资源的专用控制器 data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/extend-kubernetes/operator/ target=_blank aria-label=operator>operator</a>
来监视特定类型的 CSR，然后发送一个更新来批准它。</p><p>当你发出批准或驳回的指令时，根据你期望的状态来选择设置 <code>Approved</code> 或 <code>Denied</code>。</p><p>批准（<code>Approved</code>） 的 CSR：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>certificates.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>CertificateSigningRequest<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>conditions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>lastUpdateTime</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2020-02-08T11:37:35Z&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>lastTransitionTime</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2020-02-08T11:37:35Z&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>message</span>:<span style=color:#bbb> </span>Approved by my custom approver controller<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>reason</span>:<span style=color:#bbb> </span>ApprovedByMyPolicy<span style=color:#bbb> </span><span style=color:#080;font-style:italic># You can set this to any string</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Approved<span style=color:#bbb>
</span></span></span></code></pre></div><p>驳回（<code>Denied</code>）的 CSR：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>certificates.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>CertificateSigningRequest<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>conditions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>lastUpdateTime</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2020-02-08T11:37:35Z&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>lastTransitionTime</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2020-02-08T11:37:35Z&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>message</span>:<span style=color:#bbb> </span>Denied by my custom approver controller<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>reason</span>:<span style=color:#bbb> </span>DeniedByMyPolicy<span style=color:#bbb> </span><span style=color:#080;font-style:italic># You can set this to any string</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Denied<span style=color:#bbb>
</span></span></span></code></pre></div><p><code>status.conditions.reason</code> 字段通常设置为一个首字母大写的对机器友好的原因码;
这是一个命名约定，但你也可以随你的个人喜好设置。
如果你想添加一个供人类使用的注释，那就用 <code>status.conditions.message</code> 字段。</p><h2 id=signing>签名</h2><h3 id=signer-control-plane>控制平面签名者</h3><p>Kubernetes 控制平面实现了每一个
<a href=/zh-cn/docs/reference/access-authn-authz/certificate-signing-requests/#kubernetes-signers>Kubernetes 签名者</a>，
每个签名者的实现都是 kube-controller-manager 的一部分。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong> 在Kubernetes v1.18 之前，
kube-controller-manager 签名所有标记为 approved 的 CSR。</div><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p><code>spec.expirationSeconds</code> 字段是在 Kubernetes v1.22 中加入的。早期的 Kubernetes 版本并不认识该字段。
v1.22 版本之前的 Kubernetes API 服务器会在创建对象的时候忽略该字段。</div><h3 id=signer-api>基于 API 的签名者</h3><p>REST API 的用户可以通过向待签名的 CSR 的 <code>status</code> 子资源提交更新请求来对 CSR 进行签名。</p><p>作为这个请求的一部分，<code>status.certificate</code> 字段应设置为已签名的证书。
此字段可包含一个或多个 PEM 编码的证书。</p><p>所有的 PEM 块必须具备 "CERTIFICATE" 标签，且不包含文件头，且编码的数据必须是
<a href=https://tools.ietf.org/html/rfc5280#section-4.1>RFC5280 第 4 节</a>
中描述的 BER 编码的 ASN.1 证书结构。</p><pre tabindex=0><code>-----BEGIN CERTIFICATE-----
MIIDgjCCAmqgAwIBAgIUC1N1EJ4Qnsd322BhDPRwmg3b/oAwDQYJKoZIhvcNAQEL
BQAwXDELMAkGA1UEBhMCeHgxCjAIBgNVBAgMAXgxCjAIBgNVBAcMAXgxCjAIBgNV
BAoMAXgxCjAIBgNVBAsMAXgxCzAJBgNVBAMMAmNhMRAwDgYJKoZIhvcNAQkBFgF4
MB4XDTIwMDcwNjIyMDcwMFoXDTI1MDcwNTIyMDcwMFowNzEVMBMGA1UEChMMc3lz
dGVtOm5vZGVzMR4wHAYDVQQDExVzeXN0ZW06bm9kZToxMjcuMC4wLjEwggEiMA0G
CSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDne5X2eQ1JcLZkKvhzCR4Hxl9+ZmU3
+e1zfOywLdoQxrPi+o4hVsUH3q0y52BMa7u1yehHDRSaq9u62cmi5ekgXhXHzGmm
kmW5n0itRECv3SFsSm2DSghRKf0mm6iTYHWDHzUXKdm9lPPWoSOxoR5oqOsm3JEh
Q7Et13wrvTJqBMJo1GTwQuF+HYOku0NF/DLqbZIcpI08yQKyrBgYz2uO51/oNp8a
sTCsV4OUfyHhx2BBLUo4g4SptHFySTBwlpRWBnSjZPOhmN74JcpTLB4J5f4iEeA7
2QytZfADckG4wVkhH3C2EJUmRtFIBVirwDn39GXkSGlnvnMgF3uLZ6zNAgMBAAGj
YTBfMA4GA1UdDwEB/wQEAwIFoDATBgNVHSUEDDAKBggrBgEFBQcDAjAMBgNVHRMB
Af8EAjAAMB0GA1UdDgQWBBTREl2hW54lkQBDeVCcd2f2VSlB1DALBgNVHREEBDAC
ggAwDQYJKoZIhvcNAQELBQADggEBABpZjuIKTq8pCaX8dMEGPWtAykgLsTcD2jYr
L0/TCrqmuaaliUa42jQTt2OVsVP/L8ofFunj/KjpQU0bvKJPLMRKtmxbhXuQCQi1
qCRkp8o93mHvEz3mTUN+D1cfQ2fpsBENLnpS0F4G/JyY2Vrh19/X8+mImMEK5eOy
o0BMby7byUj98WmcUvNCiXbC6F45QTmkwEhMqWns0JZQY+/XeDhEcg+lJvz9Eyo2
aGgPsye1o3DpyXnyfJWAWMhOz7cikS5X2adesbgI86PhEHBXPIJ1v13ZdfCExmdd
M1fLPhLyR54fGaY+7/X8P9AZzPefAkwizeXwe9ii6/a08vWoiE4=
-----END CERTIFICATE-----
</code></pre><p>非 PEM 内容可能会出现在证书 PEM 块前后的位置，且未经验证，
以允许使用 <a href=https://www.rfc-editor.org/rfc/rfc7468#section-5.2>RFC7468 第 5.2 节</a>中描述的解释性文本。</p><p>当使用 JSON 或 YAML 格式时，此字段是 base-64 编码。
包含上述示例证书的 CertificateSigningRequest 如下所示：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>certificates.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>CertificateSigningRequest<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>certificate</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JS...&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=接下来>接下来</h2><ul><li>参阅 <a href=/zh-cn/docs/tasks/tls/managing-tls-in-a-cluster/>管理集群中的 TLS 认证</a></li><li>查看 kube-controller-manager 中<a href=https://github.com/kubernetes/kubernetes/blob/32ec6c212ec9415f604ffc1f4c1f29b782968ff1/pkg/controller/certificates/signer/cfssl_signer.go>签名者</a>部分的源代码</li><li>查看 kube-controller-manager 中<a href=https://github.com/kubernetes/kubernetes/blob/32ec6c212ec9415f604ffc1f4c1f29b782968ff1/pkg/controller/certificates/approver/sarapprove.go>批准者</a>部分的源代码</li><li>有关 X.509 本身的详细信息，请参阅 <a href=https://tools.ietf.org/html/rfc5280#section-3.1>RFC 5280</a> 第3.1节</li><li>有关 PKCS#10 证书签名请求语法的信息，请参阅 <a href=https://tools.ietf.org/html/rfc2986>RFC 2986</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-518807b9b00bda46d7c7e6e0b17c18f8>4 - 准入控制器参考</h1><p>此页面提供准入控制器（Admission Controllers）的概述。</p><h2 id=what-are-they>什么是准入控制插件？</h2><p><strong>准入控制器</strong> 是一段代码，它会在请求通过认证和鉴权之后、对象被持久化之前拦截到达 API
服务器的请求。</p><p>准入控制器可以执行<strong>验证（Validating）</strong> 和/或<strong>变更（Mutating）</strong> 操作。
变更（mutating）控制器可以根据被其接受的请求更改相关对象；验证（validating）控制器则不行。</p><p>准入控制器限制创建、删除、修改对象的请求。
准入控制器也可以阻止自定义动作，例如通过 API 服务器代理连接到 Pod 的请求。
准入控制器<strong>不会</strong> （也不能）阻止读取（<strong>get</strong>、<strong>watch</strong> 或 <strong>list</strong>）对象的请求。</p><p>Kubernetes 1.25
中的准入控制器由下面的<a href=#what-does-each-admission-controller-do>列表</a>组成，
并编译进 <code>kube-apiserver</code> 可执行文件，并且只能由集群管理员配置。
在该列表中，有两个特殊的控制器：MutatingAdmissionWebhook 和 ValidatingAdmissionWebhook。
它们根据 API 中的配置，
分别执行变更和验证<a href=/zh-cn/docs/reference/access-authn-authz/extensible-admission-controllers/#admission-webhooks>准入控制 webhook</a>。</p><h2 id=admission-control-phases>准入控制阶段</h2><p>准入控制过程分为两个阶段。第一阶段，运行变更准入控制器。第二阶段，运行验证准入控制器。
再次提醒，某些控制器既是变更准入控制器又是验证准入控制器。</p><p>如果两个阶段之一的任何一个控制器拒绝了某请求，则整个请求将立即被拒绝，并向最终用户返回错误。</p><p>最后，除了对对象进行变更外，准入控制器还可能有其它副作用：将相关资源作为请求处理的一部分进行变更。
增加配额用量就是一个典型的示例，说明了这样做的必要性。
此类用法都需要相应的回收或回调过程，因为任一准入控制器都无法确定某个请求能否通过所有其它准入控制器。</p><h2 id=why-do-i-need-them>为什么需要准入控制器？</h2><p>Kubernetes 的若干重要功能都要求启用一个准入控制器，以便正确地支持该特性。
因此，没有正确配置准入控制器的 Kubernetes API 服务器是不完整的，它无法支持你所期望的所有特性。</p><h2 id=how-do-i-turn-on-an-admission-controller>如何启用一个准入控制器？</h2><p>Kubernetes API 服务器的 <code>enable-admission-plugins</code> 标志接受一个（以逗号分隔的）准入控制插件列表，
这些插件会在集群修改对象之前被调用。</p><p>例如，下面的命令启用 <code>NamespaceLifecycle</code> 和 <code>LimitRanger</code> 准入控制插件：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kube-apiserver --enable-admission-plugins<span style=color:#666>=</span>NamespaceLifecycle,LimitRanger ...
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>根据你 Kubernetes 集群的部署方式以及 API 服务器的启动方式，你可能需要以不同的方式应用设置。
例如，如果将 API 服务器部署为 systemd 服务，你可能需要修改 systemd 单元文件；
如果以自托管方式部署 Kubernetes，你可能需要修改 API 服务器的清单文件。</div><h2 id=how-do-i-turn-off-an-admission-controller>怎么关闭准入控制器？</h2><p>Kubernetes API 服务器的 <code>disable-admission-plugins</code> 标志，会将传入的（以逗号分隔的）
准入控制插件列表禁用，即使是默认启用的插件也会被禁用。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kube-apiserver --disable-admission-plugins<span style=color:#666>=</span>PodNodeSelector,AlwaysDeny ...
</span></span></code></pre></div><h2 id=which-plugins-are-enabled-by-default>哪些插件是默认启用的？</h2><p>要查看哪些插件是被启用的：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kube-apiserver -h | grep enable-admission-plugins
</span></span></code></pre></div><p>在 Kubernetes 1.25 中，默认启用的插件有：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>CertificateApproval, CertificateSigning, CertificateSubjectRestriction, DefaultIngressClass, DefaultStorageClass, DefaultTolerationSeconds, LimitRanger, MutatingAdmissionWebhook, NamespaceLifecycle, PersistentVolumeClaimResize, PodSecurity, Priority, ResourceQuota, RuntimeClass, ServiceAccount, StorageObjectInUseProtection, TaintNodesByCondition, ValidatingAdmissionWebhook
</span></span></code></pre></div><h2 id=what-does-each-admission-controller-do>每个准入控制器的作用是什么？</h2><h3 id=alwaysadmit>AlwaysAdmit</h3><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.13 [deprecated]</code></div><p>该准入控制器允许所有的 Pod 进入集群。此插件<strong>已被弃用</strong>，因其行为与没有准入控制器一样。</p><h3 id=alwaysdeny>AlwaysDeny</h3><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.13 [deprecated]</code></div><p>拒绝所有的请求。由于它没有实际意义，<strong>已被弃用</strong>。</p><h3 id=alwayspullimages>AlwaysPullImages</h3><p>该准入控制器会修改每个新创建的 Pod，将其镜像拉取策略设置为 <code>Always</code>。
这在多租户集群中是有用的，这样用户就可以放心，他们的私有镜像只能被那些有凭证的人使用。
如果没有这个准入控制器，一旦镜像被拉取到节点上，任何用户的 Pod 都可以通过已了解到的镜像的名称
（假设 Pod 被调度到正确的节点上）来使用它，而不需要对镜像进行任何鉴权检查。
启用这个准入控制器之后，启动容器之前必须拉取镜像，这意味着需要有效的凭证。</p><h3 id=certificateapproval>CertificateApproval</h3><p>此准入控制器获取审批 CertificateSigningRequest 资源的请求并执行额外的鉴权检查，
以确保针对设置了 <code>spec.signerName</code> 的 CertificateSigningRequest 资源而言，
审批请求的用户有权限对证书请求执行 <strong>审批</strong> 操作。</p><p>有关对 CertificateSigningRequest 资源执行不同操作所需权限的详细信息，
请参阅<a href=/zh-cn/docs/reference/access-authn-authz/certificate-signing-requests/>证书签名请求</a>。</p><h3 id=certificatesigning>CertificateSigning</h3><p>此准入控制器监视对 CertificateSigningRequest 资源的 <code>status.certificate</code> 字段的更新请求，
并执行额外的鉴权检查，以确保针对设置了 <code>spec.signerName</code> 的 CertificateSigningRequest 资源而言，
签发证书的用户有权限对证书请求执行 <strong>签发</strong> 操作。</p><p>有关对 CertificateSigningRequest 资源执行不同操作所需权限的详细信息，
请参阅<a href=/zh-cn/docs/reference/access-authn-authz/certificate-signing-requests/>证书签名请求</a>。</p><h3 id=certificatesubjectrestriction>CertificateSubjectRestriction</h3><p>此准入控制器监视 <code>spec.signerName</code> 被设置为 <code>kubernetes.io/kube-apiserver-client</code> 的
CertificateSigningRequest 资源创建请求，并拒绝所有将 “group”（或 “organization attribute”）
设置为 <code>system:masters</code> 的请求。</p><h3 id=defaultingressclass>DefaultIngressClass</h3><p>该准入控制器监测没有请求任何特定 Ingress 类的 <code>Ingress</code> 对象创建请求，并自动向其添加默认 Ingress 类。
这样，没有任何特殊 Ingress 类需求的用户根本不需要关心它们，他们将被设置为默认 Ingress 类。</p><p>当未配置默认 Ingress 类时，此准入控制器不执行任何操作。如果有多个 Ingress 类被标记为默认 Ingress 类，
此控制器将拒绝所有创建 <code>Ingress</code> 的操作，并返回错误信息。
要修复此错误，管理员必须重新检查其 <code>IngressClass</code> 对象，并仅将其中一个标记为默认
（通过注解 "ingressclass.kubernetes.io/is-default-class"）。
此准入控制器会忽略所有 <code>Ingress</code> 更新操作，仅处理创建操作。</p><p>关于 Ingress 类以及如何将 Ingress 类标记为默认的更多信息，请参见
<a href=/zh-cn/docs/concepts/services-networking/ingress/>Ingress</a> 页面。</p><h3 id=defaultstorageclass>DefaultStorageClass</h3><p>此准入控制器监测没有请求任何特定存储类的 <code>PersistentVolumeClaim</code> 对象的创建请求，
并自动向其添加默认存储类。
这样，没有任何特殊存储类需求的用户根本不需要关心它们，它们将被设置为使用默认存储类。</p><p>当未配置默认存储类时，此准入控制器不执行任何操作。如果将多个存储类标记为默认存储类，
此控制器将拒绝所有创建 <code>PersistentVolumeClaim</code> 的请求，并返回错误信息。
要修复此错误，管理员必须重新检查其 <code>StorageClass</code> 对象，并仅将其中一个标记为默认。
此准入控制器会忽略所有 <code>PersistentVolumeClaim</code> 更新操作，仅处理创建操作。</p><p>关于持久卷申领和存储类，以及如何将存储类标记为默认，请参见<a href=/zh-cn/docs/concepts/storage/persistent-volumes/>持久卷</a>页面。</p><h3 id=defaulttolerationseconds>DefaultTolerationSeconds</h3><p>此准入控制器基于 k8s-apiserver 的输入参数 <code>default-not-ready-toleration-seconds</code> 和
<code>default-unreachable-toleration-seconds</code> 为 Pod 设置默认的容忍度，以容忍 <code>notready:NoExecute</code> 和
<code>unreachable:NoExecute</code> 污点
（如果 Pod 尚未容忍 <code>node.kubernetes.io/not-ready：NoExecute</code> 和
<code>node.kubernetes.io/unreachable：NoExecute</code> 污点的话）。
<code>default-not-ready-toleration-seconds</code> 和 <code>default-unreachable-toleration-seconds</code>
的默认值是 5 分钟。</p><h3 id=denyserviceexternalips>DenyServiceExternalIPs</h3><p>此准入控制器拒绝新的 <code>Service</code> 中使用字段 <code>externalIPs</code>。
此功能非常强大（允许网络流量拦截），并且无法很好地受策略控制。
启用后，集群用户将无法创建使用 <code>externalIPs</code> 的新 <code>Service</code>，也无法在现有
<code>Service</code> 对象上为 <code>externalIPs</code> 添加新值。
<code>externalIPs</code> 的现有使用不受影响，用户可以在现有 <code>Service</code> 对象上从
<code>externalIPs</code> 中删除值。</p><p>大多数用户根本不需要此特性，集群管理员应考虑将其禁用。
确实需要使用此特性的集群应考虑使用一些自定义策略来管理 <code>externalIPs</code> 的使用。
此准入控制器默认被禁用。</p><h3 id=eventratelimit>EventRateLimit</h3><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.13 [alpha]</code></div><p>此准入控制器缓解了请求存储新事件时淹没 API 服务器的问题。集群管理员可以通过以下方式指定事件速率限制：</p><ul><li>启用 <code>EventRateLimit</code> 准入控制器；</li><li>在通过 API 服务器的命令行标志 <code>--admission-control-config-file</code> 设置的文件中，
引用 <code>EventRateLimit</code> 配置文件：</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiserver.config.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>AdmissionConfiguration<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>plugins</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>EventRateLimit<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>eventconfig.yaml<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>可以在配置中指定的限制有四种类型：</p><ul><li><code>Server</code>：API 服务器收到的所有（创建或修改）Event 请求共享一个桶。</li><li><code>Namespace</code>：每个名字空间都对应一个专用的桶。</li><li><code>User</code>：为每个用户分配一个桶。</li><li><code>SourceAndObject</code>：根据事件的来源和涉及对象的各种组合分配桶。</li></ul><p>下面是一个针对此配置的 <code>eventconfig.yaml</code> 示例：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>eventratelimit.admission.k8s.io/v1alpha1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Configuration<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>Namespace<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>qps</span>:<span style=color:#bbb> </span><span style=color:#666>50</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>burst</span>:<span style=color:#bbb> </span><span style=color:#666>100</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cacheSize</span>:<span style=color:#bbb> </span><span style=color:#666>2000</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>User<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>qps</span>:<span style=color:#bbb> </span><span style=color:#666>10</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>burst</span>:<span style=color:#bbb> </span><span style=color:#666>50</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>详情请参见
<a href=/zh-cn/docs/reference/config-api/apiserver-eventratelimit.v1alpha1/>EventRateLimit 配置 API 文档（v1alpha1）</a>。</p><p>此准入控制器默认被禁用。</p><h3 id=extendedresourcetoleration>ExtendedResourceToleration</h3><p>此插件有助于创建带有扩展资源的专用节点。
如果运维人员想要创建带有扩展资源（如 GPU、FPGA 等）的专用节点，他们应该以扩展资源名称作为键名，
<a href=/zh-cn/docs/concepts/scheduling-eviction/taint-and-toleration/>为节点设置污点</a>。
如果启用了此准入控制器，会将此类污点的容忍度自动添加到请求扩展资源的 Pod 中，
用户不必再手动添加这些容忍度。</p><p>此准入控制器默认被禁用。</p><h3 id=imagepolicywebhook>ImagePolicyWebhook</h3><p>ImagePolicyWebhook 准入控制器允许使用后端 Webhook 做出准入决策。</p><p>此准入控制器默认被禁用。</p><h4 id=imagereview-config-file-format>配置文件格式</h4><p>ImagePolicyWebhook 使用配置文件来为后端行为设置选项。该文件可以是 JSON 或 YAML，
并具有以下格式:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>imagePolicy</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kubeConfigFile</span>:<span style=color:#bbb> </span>/path/to/kubeconfig/for/backend<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 以秒计的时长，控制批准请求的缓存时间</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>allowTTL</span>:<span style=color:#bbb> </span><span style=color:#666>50</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 以秒计的时长，控制拒绝请求的缓存时间</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>denyTTL</span>:<span style=color:#bbb> </span><span style=color:#666>50</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 以毫秒计的时长，控制重试间隔</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>retryBackoff</span>:<span style=color:#bbb> </span><span style=color:#666>500</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 确定 Webhook 后端失效时的行为</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>defaultAllow</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>在通过命令行标志 <code>--admission-control-config-file</code> 为 API 服务器提供的文件中，
引用 ImagePolicyWebhook 配置文件：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiserver.config.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>AdmissionConfiguration<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>plugins</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>ImagePolicyWebhook<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>imagepolicyconfig.yaml<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>或者，你也可以直接将配置嵌入到该文件中：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiserver.config.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>AdmissionConfiguration<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>plugins</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>ImagePolicyWebhook<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>configuration</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>imagePolicy</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>kubeConfigFile</span>:<span style=color:#bbb> </span>&lt;kubeconfig 文件路径&gt;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>allowTTL</span>:<span style=color:#bbb> </span><span style=color:#666>50</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>denyTTL</span>:<span style=color:#bbb> </span><span style=color:#666>50</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>retryBackoff</span>:<span style=color:#bbb> </span><span style=color:#666>500</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>defaultAllow</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>ImagePolicyWebhook 的配置文件必须引用
<a href=/zh-cn/docs/tasks/access-application-cluster/configure-access-multiple-clusters/>kubeconfig</a>
格式的文件；该文件用来设置与后端的连接。要求后端使用 TLS 进行通信。</p><p>kubeconfig 文件的 <code>clusters</code> 字段需要指向远端服务，<code>users</code> 字段需要包含已返回的授权者。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#080;font-style:italic># clusters 指的是远程服务。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>clusters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>name-of-remote-imagepolicy-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>certificate-authority</span>:<span style=color:#bbb> </span>/path/to/ca.pem   <span style=color:#bbb> </span><span style=color:#080;font-style:italic># CA 用于验证远程服务</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>server</span>:<span style=color:#bbb> </span>https://images.example.com/policy<span style=color:#bbb> </span><span style=color:#080;font-style:italic># 要查询的远程服务的 URL，必须是 &#39;https&#39;。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># users 指的是 API 服务器的 Webhook 配置。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>users</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>name-of-api-server<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>client-certificate</span>:<span style=color:#bbb> </span>/path/to/cert.pem<span style=color:#bbb> </span><span style=color:#080;font-style:italic># Webhook 准入控制器使用的证书</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>client-key</span>:<span style=color:#bbb> </span>/path/to/key.pem         <span style=color:#bbb> </span><span style=color:#080;font-style:italic># 证书匹配的密钥</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>关于 HTTP 配置的更多信息，请参阅
<a href=/zh-cn/docs/tasks/access-application-cluster/configure-access-multiple-clusters/>kubeconfig</a>
文档。</p><h4 id=request-payloads>请求载荷</h4><p>当面对一个准入决策时，API 服务器发送一个描述操作的 JSON 序列化的
<code>imagepolicy.k8s.io/v1alpha1</code> <code>ImageReview</code> 对象。
该对象包含描述被准入容器的字段，以及与 <code>*.image-policy.k8s.io/*</code> 匹配的所有 Pod 注解。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>注意，Webhook API 对象与其他 Kubernetes API 对象一样受制于相同的版本控制兼容性规则。
实现者应该知道对 alpha 对象兼容性是相对宽松的，并检查请求的 "apiVersion" 字段，
以确保正确的反序列化。
此外，API 服务器必须启用 <code>imagepolicy.k8s.io/v1alpha1</code> API 扩展组
（<code>--runtime-config=imagepolicy.k8s.io/v1alpha1=true</code>）。</div><p>请求载荷示例：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>:<span style=color:#b44>&#34;imagepolicy.k8s.io/v1alpha1&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;kind&#34;</span>:<span style=color:#b44>&#34;ImageReview&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;spec&#34;</span>:{
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;containers&#34;</span>:[
</span></span><span style=display:flex><span>      {
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;image&#34;</span>:<span style=color:#b44>&#34;myrepo/myimage:v1&#34;</span>
</span></span><span style=display:flex><span>      },
</span></span><span style=display:flex><span>      {
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;image&#34;</span>:<span style=color:#b44>&#34;myrepo/myimage@sha256:beb6bd6a68f114c1dc2ea4b28db81bdf91de202a9014972bec5e4d9171d90ed&#34;</span>
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    ],
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;annotations&#34;</span>:{
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;mycluster.image-policy.k8s.io/ticket-1234&#34;</span>: <span style=color:#b44>&#34;break-glass&#34;</span>
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;namespace&#34;</span>:<span style=color:#b44>&#34;mynamespace&#34;</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>远程服务将填充请求的 <code>status</code> 字段，并返回允许或不允许访问的响应。
响应体的 <code>spec</code> 字段会被忽略，并且可以被省略。一个允许访问应答会返回：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;imagepolicy.k8s.io/v1alpha1&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;ImageReview&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;status&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;allowed&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>若不允许访问，服务将返回：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;imagepolicy.k8s.io/v1alpha1&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;ImageReview&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;status&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;allowed&#34;</span>: <span style=color:#a2f;font-weight:700>false</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;reason&#34;</span>: <span style=color:#b44>&#34;image currently blacklisted&#34;</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>更多的文档，请参阅 <a href=/zh-cn/docs/reference/config-api/imagepolicy.v1alpha1/><code>imagepolicy.v1alpha1</code> API</a>。</p><h4 id=extending-with-annotations>使用注解进行扩展</h4><p>一个 Pod 中匹配 <code>*.image-policy.k8s.io/*</code> 的注解都会被发送给 Webhook。
这样做使得了解后端镜像策略的用户可以向它发送额外的信息，
并让不同的后端实现接收不同的信息。</p><p>你可以在这里输入的信息有：</p><ul><li>在紧急情况下，请求破例覆盖某个策略。</li><li>从一个记录了破例的请求的工单（Ticket）系统得到的一个工单号码。</li><li>向策略服务器提供提示信息，用于提供镜像的 imageID，以方便它进行查找。</li></ul><p>在任何情况下，注解都是由用户提供的，并不会被 Kubernetes 以任何方式进行验证。</p><h3 id=limitpodhardantiaffinitytopology>LimitPodHardAntiAffinityTopology</h3><p>此准入控制器拒绝定义了 <code>AntiAffinity</code> 拓扑键的任何 Pod
（<code>requiredDuringSchedulingRequiredDuringExecution</code> 中的 <code>kubernetes.io/hostname</code> 除外）。</p><p>此准入控制器默认被禁用。</p><h3 id=limitranger>LimitRanger</h3><p>此准入控制器会监测传入的请求，并确保请求不会违反 <code>Namespace</code> 中 <code>LimitRange</code> 对象所设置的任何约束。
如果你在 Kubernetes 部署中使用了 <code>LimitRange</code> 对象，则必须使用此准入控制器来执行这些约束。
LimitRanger 还可以用于将默认资源请求应用到没有设定资源约束的 Pod；
当前，默认的 LimitRanger 对 <code>default</code> 名字空间中的所有 Pod 都设置 0.1 CPU 的需求。</p><p>请查看
<a href=/zh-cn/docs/reference/kubernetes-api/policy-resources/limit-range-v1/>limitRange API 文档</a>和
<a href=/zh-cn/docs/tasks/administer-cluster/manage-resources/memory-default-namespace/>LimitRange 例子</a>以了解更多细节。</p><h3 id=mutatingadmissionwebhook>MutatingAdmissionWebhook</h3><p>此准入控制器调用任何与请求匹配的变更（Mutating） Webhook。匹配的 Webhook 将被顺序调用。
每一个 Webhook 都可以自由修改对象。</p><p><code>MutatingAdmissionWebhook</code>，顾名思义，仅在变更阶段运行。</p><p>如果由此准入控制器调用的 Webhook 有副作用（如：减少配额），
则它 <strong>必须</strong> 具有协调系统，因为不能保证后续的 Webhook 和验证准入控制器都会允许完成请求。</p><p>如果你禁用了 MutatingAdmissionWebhook，那么还必须使用 <code>--runtime-config</code> 标志禁止
<code>admissionregistration.k8s.io/v1</code> 组/版本中的 <code>MutatingWebhookConfiguration</code>，
二者都是默认启用的。</p><h4 id=use-caution-when-authoring-and-installing-mutating-webhooks>谨慎编写和安装变更 webhook</h4><ul><li>当用户尝试创建的对象与返回的对象不同时，用户可能会感到困惑。</li><li>当他们读回的对象与尝试创建的对象不同，内建的控制回路可能会出问题。<ul><li>与覆盖原始请求中设置的字段相比，使用原始请求未设置的字段会引起问题的可能性较小。
应尽量避免覆盖原始请求中的字段设置。</li></ul></li><li>内建资源和第三方资源的控制回路未来可能会出现破坏性的变更，使现在运行良好的 Webhook
无法再正常运行。即使完成了 Webhook API 安装，也不代表该 Webhook 会被提供无限期的支持。</li></ul><h3 id=namespaceautoprovision>NamespaceAutoProvision</h3><p>此准入控制器会检查针对名字空间域资源的所有传入请求，并检查所引用的名字空间是否确实存在。
如果找不到所引用的名字空间，控制器将创建一个名字空间。
此准入控制器对于不想要求名字空间必须先创建后使用的集群部署很有用。</p><h3 id=namespaceexists>NamespaceExists</h3><p>此准入控制器检查针对名字空间作用域的资源（除 <code>Namespace</code> 自身）的所有请求。
如果请求引用的名字空间不存在，则拒绝该请求。</p><h3 id=namespacelifecycle>NamespaceLifecycle</h3><p>该准入控制器禁止在一个正在被终止的 <code>Namespace</code> 中创建新对象，并确保针对不存在的
<code>Namespace</code> 的请求被拒绝。
该准入控制器还会禁止删除三个系统保留的名字空间，即 <code>default</code>、
<code>kube-system</code> 和 <code>kube-public</code>。</p><p><code>Namespace</code> 的删除操作会触发一系列删除该名字空间中所有对象（Pod、Service 等）的操作。
为了确保这个过程的完整性，我们强烈建议启用这个准入控制器。</p><h3 id=noderestriction>NodeRestriction</h3><p>该准入控制器限制了某 kubelet 可以修改的 <code>Node</code> 和 <code>Pod</code> 对象。
为了受到这个准入控制器的限制，kubelet 必须使用在 <code>system:nodes</code> 组中的凭证，
并使用 <code>system:node:&lt;nodeName></code> 形式的用户名。
这样，kubelet 只可修改自己的 <code>Node</code> API 对象，只能修改绑定到自身节点的 Pod 对象。</p><p>不允许 kubelet 更新或删除 <code>Node</code> API 对象的污点。</p><p><code>NodeRestriction</code> 准入插件可防止 kubelet 删除其 <code>Node</code> API 对象，
并对前缀为 <code>kubernetes.io/</code> 或 <code>k8s.io/</code> 的标签的修改对 kubelet 作如下限制：</p><ul><li><strong>禁止</strong> kubelet 添加、删除或更新前缀为 <code>node-restriction.kubernetes.io/</code> 的标签。
这类前缀的标签时保留给管理员的，用以为 <code>Node</code> 对象设置标签以隔离工作负载，而不允许 kubelet
修改带有该前缀的标签。</li><li><strong>允许</strong> kubelet 添加、删除、更新以下标签：<ul><li><code>kubernetes.io/hostname</code></li><li><code>kubernetes.io/arch</code></li><li><code>kubernetes.io/os</code></li><li><code>beta.kubernetes.io/instance-type</code></li><li><code>node.kubernetes.io/instance-type</code></li><li><code>failure-domain.beta.kubernetes.io/region</code> （已弃用）</li><li><code>failure-domain.beta.kubernetes.io/zone</code> （已弃用）</li><li><code>topology.kubernetes.io/region</code></li><li><code>topology.kubernetes.io/zone</code></li><li><code>kubelet.kubernetes.io/</code> 为前缀的标签</li><li><code>node.kubernetes.io/</code> 为前缀的标签</li></ul></li></ul><p>以 <code>kubernetes.io</code> 或 <code>k8s.io</code> 为前缀的所有其他标签都限制 kubelet 使用，并且将来可能会被
<code>NodeRestriction</code> 准入插件允许或禁止。</p><p>将来的版本可能会增加其他限制，以确保 kubelet 具有正常运行所需的最小权限集。</p><h3 id=ownerreferencespermissionenforcement>OwnerReferencesPermissionEnforcement</h3><p>此准入控制器保护对对象的 <code>metadata.ownerReferences</code> 的访问，以便只有对该对象具有
<strong>delete</strong> 权限的用户才能对其进行更改。
该准入控制器还保护对 <code>metadata.ownerReferences[x].blockOwnerDeletion</code> 对象的访问，
以便只有对所引用的 <strong>属主（owner）</strong> 的 <code>finalizers</code> 子资源具有 <strong>update</strong>
权限的用户才能对其进行更改。</p><h3 id=persistentvolumeclaimresize>PersistentVolumeClaimResize</h3><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.24 [stable]</code></div><p>此准入控制器检查传入的 <code>PersistentVolumeClaim</code> 调整大小请求，对其执行额外的验证检查操作。</p><p>建议启用 <code>PersistentVolumeClaimResize</code> 准入控制器。除非 PVC 的 <code>StorageClass</code> 明确地将
<code>allowVolumeExpansion</code> 设置为 <code>true</code> 来显式启用调整大小。
否则，默认情况下该准入控制器会阻止所有对 PVC 大小的调整。</p><p>例如：由以下 <code>StorageClass</code> 创建的所有 <code>PersistentVolumeClaim</code> 都支持卷容量扩充：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>storage.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StorageClass<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>gluster-vol-default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>provisioner</span>:<span style=color:#bbb> </span>kubernetes.io/glusterfs<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>parameters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resturl</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;http://192.168.10.100:8080&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>restuser</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>secretNamespace</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>secretName</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>allowVolumeExpansion</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>关于持久化卷申领的更多信息，请参见
<a href=/zh-cn/docs/concepts/storage/persistent-volumes/#persistentvolumeclaims>PersistentVolumeClaim</a>。</p><h3 id=persistentvolumelabel>PersistentVolumeLabel</h3><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.13 [deprecated]</code></div><p>此准入控制器会自动将由云提供商（如 Azure 或 GCP）定义的区（region）或区域（zone）
标签附加到 PersistentVolume 上。这有助于确保 Pod 和 PersistentVolume 位于相同的区或区域。
如果准入控制器不支持为 PersistentVolumes 自动添加标签，那你可能需要手动添加标签，
以防止 Pod 挂载其他区域的卷。
PersistentVolumeLabel <strong>已被弃用</strong>，
为持久卷添加标签的操作已由<a class=glossary-tooltip title='将 Kubernetes 与第三方云提供商进行集成的控制平面组件。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/architecture/cloud-controller/ target=_blank aria-label=云管理控制器>云管理控制器</a>接管。</p><p>此准入控制器默认被禁用。</p><h3 id=podnodeselector>PodNodeSelector</h3><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.5 [alpha]</code></div><p>此准入控制器通过读取名字空间注解和全局配置，来为名字空间中可以使用的节点选择器设置默认值并实施限制。</p><p>此准入控制器默认被禁用。</p><h4 id=configuration-file-format-podnodeselector>配置文件格式</h4><p><code>PodNodeSelector</code> 使用配置文件来设置后端行为的选项。
请注意，配置文件格式将在将来某个版本中改为版本化文件。
该文件可以是 JSON 或 YAML，格式如下：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>podNodeSelectorPluginConfig</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>clusterDefaultNodeSelector</span>:<span style=color:#bbb> </span>name-of-node-selector<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>namespace1</span>:<span style=color:#bbb> </span>name-of-node-selector<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb> </span><span style=color:green;font-weight:700>namespace2</span>:<span style=color:#bbb> </span>name-of-node-selector<span style=color:#bbb>
</span></span></span></code></pre></div><p>通过 API 服务器命令行标志 <code>--admission-control-config-file</code> 为 API 服务器提供的文件中，
需要引用 <code>PodNodeSelector</code> 配置文件：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiserver.config.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>AdmissionConfiguration<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>plugins</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>PodNodeSelector<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>podnodeselector.yaml<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><h4 id=configuration-annotation-format>配置注解格式</h4><p><code>PodNodeSelector</code> 使用键为 <code>scheduler.alpha.kubernetes.io/node-selector</code>
的注解为名字空间设置节点选择算符。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Namespace<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>scheduler.alpha.kubernetes.io/node-selector</span>:<span style=color:#bbb> </span>name-of-node-selector<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>namespace3<span style=color:#bbb>
</span></span></span></code></pre></div><h4 id=internal-behavior>内部行为</h4><p>此准入控制器行为如下：</p><ol><li>如果 <code>Namespace</code> 的注解带有键 <code>scheduler.alpha.kubernetes.io/node-selector</code>，
则将其值用作节点选择算符。</li><li>如果名字空间缺少此类注解，则使用 <code>PodNodeSelector</code> 插件配置文件中定义的
<code>clusterDefaultNodeSelector</code> 作为节点选择算符。</li><li>评估 Pod 节点选择算符和名字空间节点选择算符是否存在冲突。存在冲突将拒绝 Pod。</li><li>评估 Pod 节点选择算符和特定于名字空间的被允许的选择算符所定义的插件配置文件是否存在冲突。
存在冲突将导致拒绝 Pod。</li></ol><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>PodNodeSelector 允许 Pod 强制在特定标签的节点上运行。
另请参阅 PodTolerationRestriction 准入插件，该插件可防止 Pod 在特定污点的节点上运行。</div><h3 id=podsecurity>PodSecurity</h3><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.25 [stable]</code></div><p>这是下节所讨论的已被废弃的 <a href=#podsecuritypolicy>PodSecurityPolicy</a> 准入控制器的替代品。
此准入控制器负责在创建和修改 Pod 时，根据请求的安全上下文和
<a href=/zh-cn/docs/concepts/security/pod-security-standards/>Pod 安全标准</a>
来确定是否可以执行请求。</p><p>更多信息请参阅 <a href=/zh-cn/docs/concepts/security/pod-security-admission/>Pod 安全性准入控制器</a>。</p><h3 id=podsecuritypolicy>PodSecurityPolicy</h3><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.21 [deprecated]</code></div><p>此准入控制器负责在创建和修改 Pod 时根据请求的安全上下文和可用的 Pod
安全策略确定是否可以执行请求。</p><p>查看 <a href=/zh-cn/docs/concepts/security/pod-security-policy/>Pod 安全策略文档</a>进一步了解其间细节。</p><h3 id=podtolerationrestriction>PodTolerationRestriction</h3><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.7 [alpha]</code></div><p>准入控制器 PodTolerationRestriction 检查 Pod 的容忍度与其名字空间的容忍度之间是否存在冲突。
如果存在冲突，则拒绝 Pod 请求。
控制器接下来会将名字空间的容忍度合并到 Pod 的容忍度中，
根据名字空间的容忍度白名单检查所得到的容忍度结果。
如果检查成功，则将接受 Pod 请求，否则拒绝该请求。</p><p>如果 Pod 的名字空间没有任何关联的默认容忍度或容忍度白名单，
则使用集群级别的默认容忍度或容忍度白名单（如果有的话）。</p><p>名字空间的容忍度通过注解键 <code>scheduler.alpha.kubernetes.io/defaultTolerations</code>
来设置。可接受的容忍度可以通过 <code>scheduler.alpha.kubernetes.io/tolerationsWhitelist</code>
注解键来添加。</p><p>名字空间注解的示例：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Namespace<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>apps-that-need-nodes-exclusively<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>scheduler.alpha.kubernetes.io/defaultTolerations</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;[{&#34;operator&#34;: &#34;Exists&#34;, &#34;effect&#34;: &#34;NoSchedule&#34;, &#34;key&#34;: &#34;dedicated-node&#34;}]&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>scheduler.alpha.kubernetes.io/tolerationsWhitelist</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;[{&#34;operator&#34;: &#34;Exists&#34;, &#34;effect&#34;: &#34;NoSchedule&#34;, &#34;key&#34;: &#34;dedicated-node&#34;}]&#39;</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>此准入控制器默认被禁用。</p><h3 id=priority>优先级</h3><p>优先级准入控制器使用 <code>priorityClassName</code> 字段并用整型值填充优先级。
如果找不到优先级，则拒绝 Pod。</p><h3 id=resourcequota>ResourceQuota</h3><p>此准入控制器会监测传入的请求，并确保它不违反任何一个 <code>Namespace</code> 中的 <code>ResourceQuota</code>
对象中列举的约束。如果你在 Kubernetes 部署中使用了 <code>ResourceQuota</code>，
则必须使用这个准入控制器来强制执行配额限制。</p><p>请参阅
<a href=/zh-cn/docs/reference/kubernetes-api/policy-resources/resource-quota-v1/>resourceQuota API 参考</a>
和 <a href=/zh-cn/docs/concepts/policy/resource-quotas/>Resource Quota 例子</a>了解更多细节。</p><h3 id=runtimeclass>RuntimeClass</h3><p>如果你所定义的 RuntimeClass 包含 <a href=/zh-cn/docs/concepts/scheduling-eviction/pod-overhead/>Pod 开销</a>，
这个准入控制器会检查新的 Pod。
被启用后，此准入控制器会拒绝所有已经设置了 overhead 字段的 Pod 创建请求。
对于配置了 RuntimeClass 并在其 <code>.spec</code> 中选定 RuntimeClass 的 Pod，
此准入控制器会根据相应 RuntimeClass 中定义的值为 Pod 设置 <code>.spec.overhead</code>。</p><p>详情请参见 <a href=/zh-cn/docs/concepts/scheduling-eviction/pod-overhead/>Pod 开销</a>。</p><h3 id=securitycontextdeny>SecurityContextDeny</h3><p>此准入控制器将拒绝任何试图设置特定提升
<a href=/zh-cn/docs/tasks/configure-pod-container/security-context/>SecurityContext</a>
中某些字段的 Pod，正如任务<a href=/zh-cn/docs/tasks/configure-pod-container/security-context/>为 Pod 或 Container 配置安全上下文</a>
中所展示的那样。如果集群没有使用
<a href=/zh-cn/docs/concepts/security/pod-security-admission/>Pod 安全性准入</a>、
<a href=/zh-cn/docs/concepts/security/pod-security-policy/>PodSecurityPolicy</a>，
也没有任何外部强制机制，那么你可以使用此准入控制器来限制安全上下文所能获取的值集。</p><p>有关限制 Pod 权限的更多内容，请参阅
<a href=/zh-cn/docs/concepts/security/pod-security-standards/>Pod 安全标准</a>。</p><h3 id=serviceaccount>ServiceAccount</h3><p>此准入控制器实现了
<a href=/zh-cn/docs/tasks/configure-pod-container/configure-service-account/>ServiceAccount</a>
的自动化。强烈推荐为 Kubernetes 项目启用此准入控制器。
如果你打算使用 Kubernetes 的 <code>ServiceAccount</code> 对象，你应启用这个准入控制器。</p><h3 id=storageobjectinuseprotection>StorageObjectInUseProtection</h3><p><code>StorageObjectInUseProtection</code> 插件将 <code>kubernetes.io/pvc-protection</code> 或
<code>kubernetes.io/pv-protection</code> finalizers 添加到新创建的持久卷申领（PVC）
或持久卷（PV）中。如果用户尝试删除 PVC/PV，除非 PVC/PV 的保护控制器移除终结器（finalizers），
否则 PVC/PV 不会被删除。有关更多详细信息，
请参考<a href=/zh-cn/docs/concepts/storage/persistent-volumes/#storage-object-in-use-protection>保护使用中的存储对象</a>。</p><h3 id=taintnodesbycondition>TaintNodesByCondition</h3><p>该准入控制器为新创建的节点添加 <code>NotReady</code> 和 <code>NoSchedule</code>
<a class=glossary-tooltip title='污点是一种一个核心对象，包含三个必需的属性：key、value 和 effect。 污点会阻止在节点或节点组上调度 Pod。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/scheduling-eviction/taint-and-toleration/ target=_blank aria-label=污点>污点</a>。
这些污点能够避免一些竞态条件的发生，而这类竞态条件可能导致 Pod
在更新节点污点以准确反映其所报告状况之前，就被调度到新节点上。</p><h3 id=validatingadmissionwebhook>ValidatingAdmissionWebhook</h3><p>此准入控制器调用与请求匹配的所有验证性 Webhook。
匹配的 Webhook 将被并行调用。如果其中任何一个拒绝请求，则整个请求将失败。
该准入控制器仅在验证（Validating）阶段运行；与 <code>MutatingAdmissionWebhook</code>
准入控制器所调用的 Webhook 相反，它调用的 Webhook 不可以变更对象。</p><p>如果以此方式调用的 Webhook 有其它副作用（如：减少配额），则它 <strong>必须</strong> 具有协调机制。
这是因为无法保证后续的 Webhook 或其他验证性准入控制器都允许请求完成。</p><p>如果你禁用了 ValidatingAdmissionWebhook，还必须通过 <code>--runtime-config</code> 标志来禁用
<code>admissionregistration.k8s.io/v1</code> 组/版本中的 <code>ValidatingWebhookConfiguration</code> 对象。</p><h2 id=is-there-a-recommended-set-of-admission-controllers-to-use>有推荐的准入控制器吗？</h2><p>有。推荐使用的准入控制器默认情况下都处于启用状态
（请查看<a href=/zh-cn/docs/reference/command-line-tools-reference/kube-apiserver/#options>这里</a>）。
因此，你无需显式指定它们。
你可以使用 <code>--enable-admission-plugins</code> 标志（ <strong>顺序不重要</strong> ）来启用默认设置以外的其他准入控制器。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-d04751f776f1faa6a82bbb7f0a200950>5 - 动态准入控制</h1><p>除了<a href=/zh-cn/docs/reference/access-authn-authz/admission-controllers/>内置的 admission 插件</a>，
准入插件可以作为扩展独立开发，并以运行时所配置的 Webhook 的形式运行。
此页面描述了如何构建、配置、使用和监视准入 Webhook。</p><h2 id=what-are-admission-webhooks>什么是准入 Webhook？</h2><p>准入 Webhook 是一种用于接收准入请求并对其进行处理的 HTTP 回调机制。
可以定义两种类型的准入 webhook，即
<a href=/zh-cn/docs/reference/access-authn-authz/admission-controllers/#validatingadmissionwebhook>验证性质的准入 Webhook</a> 和
<a href=/zh-cn/docs/reference/access-authn-authz/admission-controllers/#mutatingadmissionwebhook>修改性质的准入 Webhook</a>。
修改性质的准入 Webhook 会先被调用。它们可以更改发送到 API
服务器的对象以执行自定义的设置默认值操作。</p><p>在完成了所有对象修改并且 API 服务器也验证了所传入的对象之后，
验证性质的 Webhook 会被调用，并通过拒绝请求的方式来强制实施自定义的策略。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong> 如果准入 Webhook 需要保证它们所看到的是对象的最终状态以实施某种策略。
则应使用验证性质的准入 Webhook，因为对象被修改性质 Webhook 看到之后仍然可能被修改。</div><h3 id=experimenting-with-admission-webhooks>尝试准入 Webhook</h3><p>准入 Webhook 本质上是集群控制平面的一部分。你应该非常谨慎地编写和部署它们。
如果你打算编写或者部署生产级准入 webhook，请阅读<a href=/zh-cn/docs/reference/access-authn-authz/extensible-admission-controllers/#write-an-admission-webhook-server>用户指南</a>以获取相关说明。
在下文中，我们将介绍如何快速试验准入 Webhook。</p><h3 id=prerequisites>先决条件</h3><ul><li><p>确保启用 MutatingAdmissionWebhook 和 ValidatingAdmissionWebhook 控制器。
<a href=/zh-cn/docs/reference/access-authn-authz/admission-controllers/#is-there-a-recommended-set-of-admission-controllers-to-use>这里</a>
是一组推荐的 admission 控制器，通常可以启用。</p></li><li><p>确保启用了 <code>admissionregistration.k8s.io/v1</code> API。</p></li></ul><h3 id=write-an-admission-webhook-server>编写一个准入 Webhook 服务器</h3><p>请参阅 Kubernetes e2e 测试中的
<a href=https://github.com/kubernetes/kubernetes/blob/release-1.21/test/images/agnhost/webhook/main.go>admission webhook 服务器</a>
的实现。webhook 处理由 API 服务器发送的 <code>AdmissionReview</code> 请求，并且将其决定
作为 <code>AdmissionReview</code> 对象以相同版本发送回去。</p><p>有关发送到 webhook 的数据的详细信息，请参阅 <a href=#request>webhook 请求</a>。</p><p>要获取来自 webhook 的预期数据，请参阅 <a href=#response>webhook 响应</a>。</p><p>示例准入 Webhook 服务器置 <code>ClientAuth</code> 字段为
<a href=https://github.com/kubernetes/kubernetes/blob/v1.22.0/test/images/agnhost/webhook/config.go#L38-L39>空</a>，
默认为 <code>NoClientCert</code> 。这意味着 webhook 服务器不会验证客户端的身份，认为其是 apiservers。
如果你需要双向 TLS 或其他方式来验证客户端，请参阅
如何<a href=#authenticate-apiservers>对 apiservers 进行身份认证</a>。</p><h3 id=deploy-the-admission-webhook-service>部署准入 Webhook 服务</h3><p>e2e 测试中的 webhook 服务器通过
<a href=/docs/reference/generated/kubernetes-api/v1.25/#deployment-v1-apps>deployment API</a>
部署在 Kubernetes 集群中。该测试还将创建一个
<a href=/docs/reference/generated/kubernetes-api/v1.25/#service-v1-core>service</a>
作为 webhook 服务器的前端。参见
<a href=https://github.com/kubernetes/kubernetes/blob/v1.22.0/test/e2e/apimachinery/webhook.go#L748>相关代码</a>。</p><p>你也可以在集群外部署 webhook。这样做需要相应地更新你的 webhook 配置。</p><h3 id=configure-admission-webhooks-on-the-fly>即时配置准入 Webhook</h3><p>你可以通过
<a href=/docs/reference/generated/kubernetes-api/v1.25/#validatingwebhookconfiguration-v1-admissionregistration-k8s-io>ValidatingWebhookConfiguration</a>
或者
<a href=/docs/reference/generated/kubernetes-api/v1.25/#mutatingwebhookconfiguration-v1-admissionregistration-k8s-io>MutatingWebhookConfiguration</a> 动态配置哪些资源要被哪些准入 Webhook 处理。</p><p>以下是一个 <code>ValidatingWebhookConfiguration</code> 示例，mutating webhook 配置与此类似。有关每个配置字段的详细信息，请参阅 <a href=#webhook-configuration>webhook 配置</a> 部分。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>admissionregistration.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ValidatingWebhookConfiguration<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;pod-policy.example.com&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>webhooks</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;pod-policy.example.com&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>   </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersions</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;v1&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>operations</span>:<span style=color:#bbb>  </span>[<span style=color:#b44>&#34;CREATE&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>   </span>[<span style=color:#b44>&#34;pods&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>scope</span>:<span style=color:#bbb>       </span><span style=color:#b44>&#34;Namespaced&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clientConfig</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;example-namespace&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;example-service&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>caBundle</span>:<span style=color:#bbb> </span>&lt;CA_BUNDLE&gt;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>admissionReviewVersions</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;v1&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>sideEffects</span>:<span style=color:#bbb> </span>None<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>timeoutSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>5</span><span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>你必须在以上示例中将 <code>&lt;CA_BUNDLE></code> 替换为一个有效的 CA 证书包，
这是一个用 PEM 编码的 CA 证书包，用于校验 Webhook 的服务器证书。</div><p>scope 字段指定是仅集群范围的资源（Cluster）还是名字空间范围的资源资源（Namespaced）将与此规则匹配。
<code>*</code> 表示没有范围限制。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong> 当使用 <code>clientConfig.service</code> 时，服务器证书必须对 <code>&lt;svc_name>.&lt;svc_namespace>.svc</code> 有效。</div><div class="alert alert-info note callout" role=alert><strong>说明：</strong> Webhook 调用的默认超时是 10 秒，你可以设置 <code>timeout</code> 并建议对 webhook 设置较短的超时时间。
如果 webhook 调用超时，则根据 webhook 的失败策略处理请求。</div><p>当一个 API 服务器收到与 <code>rules</code> 相匹配的请求时，
该 API 服务器将按照 <code>clientConfig</code> 中指定的方式向 webhook 发送一个 <code>admissionReview</code> 请求。</p><p>创建 Webhook 配置后，系统将花费几秒钟使新配置生效。</p><h3 id=authenticate-apiservers>对 API 服务器进行身份认证</h3><p>如果你的 Webhook 需要身份验证，则可以将 API 服务器配置为使用基本身份验证、持有者令牌或证书来向
Webhook 提供身份证明。完成此配置需要三个步骤。</p><ul><li><p>启动 API 服务器时，通过 <code>--admission-control-config-file</code> 参数指定准入控制配置文件的位置。</p></li><li><p>在准入控制配置文件中，指定 MutatingAdmissionWebhook 控制器和 ValidatingAdmissionWebhook 控制器应该读取凭据的位置。
凭证存储在 kubeConfig 文件中（是​​的，与 kubectl 使用的模式相同），因此字段名称为 <code>kubeConfigFile</code>。
以下是一个准入控制配置文件示例：</p></li></ul><ul class="nav nav-tabs" id=admissionconfiguration-example1 role=tablist><li class=nav-item><a data-toggle=tab class="nav-link active" href=#admissionconfiguration-example1-0 role=tab aria-controls=admissionconfiguration-example1-0 aria-selected=true>apiserver.config.k8s.io/v1</a></li><li class=nav-item><a data-toggle=tab class=nav-link href=#admissionconfiguration-example1-1 role=tab aria-controls=admissionconfiguration-example1-1>apiserver.k8s.io/v1alpha1</a></li></ul><div class=tab-content id=admissionconfiguration-example1><div id=admissionconfiguration-example1-0 class="tab-pane show active" role=tabpanel aria-labelledby=admissionconfiguration-example1-0><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiserver.config.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>AdmissionConfiguration<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>plugins</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>ValidatingAdmissionWebhook<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>configuration</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiserver.config.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>WebhookAdmissionConfiguration<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubeConfigFile</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&lt;path-to-kubeconfig-file&gt;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MutatingAdmissionWebhook<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>configuration</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiserver.config.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>WebhookAdmissionConfiguration<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubeConfigFile</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&lt;path-to-kubeconfig-file&gt;&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div></div><div id=admissionconfiguration-example1-1 class=tab-pane role=tabpanel aria-labelledby=admissionconfiguration-example1-1><p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#080;font-style:italic># 1.17 中被淘汰，推荐使用 apiserver.config.k8s.io/v1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiserver.k8s.io/v1alpha1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>AdmissionConfiguration<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>plugins</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>ValidatingAdmissionWebhook<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>configuration</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 1.17 中被淘汰，推荐使用 apiserver.config.k8s.io/v1，kind = WebhookAdmissionConfiguration</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiserver.config.k8s.io/v1alpha1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>WebhookAdmission<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubeConfigFile</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&lt;path-to-kubeconfig-file&gt;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>MutatingAdmissionWebhook<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>configuration</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 1.17 中被淘汰，推荐使用 apiserver.config.k8s.io/v1，kind = WebhookAdmissionConfiguration</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apiserver.config.k8s.io/v1alpha1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>WebhookAdmission<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubeConfigFile</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&lt;path-to-kubeconfig-file&gt;&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>有关 <code>AdmissionConfiguration</code> 的更多信息，请参见
<a href=/docs/reference/config-api/apiserver-webhookadmission.v1/>AdmissionConfiguration (v1) reference</a>。
有关每个配置字段的详细信息，请参见 <a href=#webhook-%E9%85%8D%E7%BD%AE>webhook 配置</a>部分。</p><ul><li><p>在 kubeConfig 文件中，提供证书凭据：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>users</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 名称应设置为服务的 DNS 名称或配置了 Webhook 的 URL 的主机名（包括端口）。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 如果将非 443 端口用于服务，则在配置 1.16+ API 服务器时，该端口必须包含在名称中。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 对于配置在默认端口（443）上与服务对话的 Webhook，请指定服务的 DNS 名称：</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># - name: webhook1.ns1.svc</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic>#   user: ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 对于配置在非默认端口（例如 8443）上与服务对话的 Webhook，请在 1.16+ 中指定服务的 DNS 名称和端口：</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># - name: webhook1.ns1.svc:8443</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic>#   user: ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 并可以选择仅使用服务的 DNS 名称来创建第二节，以与 1.15 API 服务器版本兼容：</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># - name: webhook1.ns1.svc</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic>#   user: ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 对于配置为使用 URL 的 webhook，请匹配在 webhook 的 URL 中指定的主机（和端口）。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 带有 `url: https://www.example.com` 的 webhook：</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># - name: www.example.com</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic>#   user: ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 带有 `url: https://www.example.com:443` 的 webhook：</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># - name: www.example.com:443</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic>#   user: ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 带有 `url: https://www.example.com:8443` 的 webhook：</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># - name: www.example.com:8443</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic>#   user: ...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;webhook1.ns1.svc&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>client-certificate-data</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&lt;pem encoded certificate&gt;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>client-key-data</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&lt;pem encoded key&gt;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># `name` 支持使用 * 通配符匹配前缀段。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;*.webhook-company.org&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>password</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&lt;password&gt;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>username</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&lt;name&gt;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># &#39;*&#39; 是默认匹配项。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;*&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>token</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&lt;token&gt;&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div></li></ul><p>当然，你需要设置 Webhook 服务器来处理这些身份验证请求。</p><h2 id=webhook-request-and-response>Webhook 请求与响应</h2><h3 id=request>请求</h3><p>Webhook 发送 POST 请求时，请设置 <code>Content-Type: application/json</code> 并对 <code>admission.k8s.io</code> API 组中的 <code>AdmissionReview</code> 对象进行序列化，将所得到的 JSON 作为请求的主体。</p><p>Webhook 可以在配置中的 <code>admissionReviewVersions</code> 字段指定可接受的 <code>AdmissionReview</code> 对象版本：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>admissionregistration.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ValidatingWebhookConfiguration<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>webhooks</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-webhook.example.com<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>admissionReviewVersions</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;v1&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;v1beta1&#34;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div><p>创建 webhook 配置时，<code>admissionReviewVersions</code> 是必填字段。
Webhook 必须支持至少一个当前和以前的 API 服务器都可以解析的 <code>AdmissionReview</code> 版本。</p><p>API 服务器将发送的是 <code>admissionReviewVersions</code> 列表中所支持的第一个 <code>AdmissionReview</code> 版本。如果 API 服务器不支持列表中的任何版本，则不允许创建配置。</p><p>如果 API 服务器遇到以前创建的 Webhook 配置，并且不支持该 API 服务器知道如何发送的任何 <code>AdmissionReview</code> 版本，则调用 Webhook 的尝试将失败，并依据<a href=#failure-policy>失败策略</a>进行处理。</p><p>此示例显示了 <code>AdmissionReview</code> 对象中包含的数据，该数据用于请求更新 <code>apps/v1</code> <code>Deployment</code> 的 <code>scale</code> 子资源：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>admission.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>AdmissionReview<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>request</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 唯一标识此准入回调的随机 uid</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>705ab4f5-6393-11e8-b7cc-42010a800002<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 传入完全正确的 group/version/kind 对象</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>group</span>:<span style=color:#bbb> </span>autoscaling<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>version</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Scale<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 修改 resource 的完全正确的的 group/version/kind</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resource</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>group</span>:<span style=color:#bbb> </span>apps<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>version</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resource</span>:<span style=color:#bbb> </span>deployments<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># subResource（如果请求是针对 subResource 的）</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>subResource</span>:<span style=color:#bbb> </span>scale<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 在对 API 服务器的原始请求中，传入对象的标准 group/version/kind</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 仅当 webhook 指定 `matchPolicy: Equivalent` 且将对 API 服务器的原始请求</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 转换为 webhook 注册的版本时，这才与 `kind` 不同。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>requestKind</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>group</span>:<span style=color:#bbb> </span>autoscaling<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>version</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Scale<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 在对 API 服务器的原始请求中正在修改的资源的标准 group/version/kind</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 仅当 webhook 指定了 `matchPolicy：Equivalent` 并且将对 API 服务器的原始请求转换为</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># webhook 注册的版本时，这才与 `resource` 不同。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>requestResource</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>group</span>:<span style=color:#bbb> </span>apps<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>version</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resource</span>:<span style=color:#bbb> </span>deployments<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># subResource（如果请求是针对 subResource 的）</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 仅当 webhook 指定了 `matchPolicy：Equivalent` 并且将对</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># API 服务器的原始请求转换为该 webhook 注册的版本时，这才与 `subResource` 不同。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>requestSubResource</span>:<span style=color:#bbb> </span>scale<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 被修改资源的名称</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 如果资源是属于名字空间（或者是名字空间对象），则这是被修改的资源的名字空间</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>my-namespace<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 操作可以是 CREATE、UPDATE、DELETE 或 CONNECT</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>operation</span>:<span style=color:#bbb> </span>UPDATE<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>userInfo</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 向 API 服务器发出请求的经过身份验证的用户的用户名</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>username</span>:<span style=color:#bbb> </span>admin<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 向 API 服务器发出请求的经过身份验证的用户的 UID</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>014fbff9a07c<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 向 API 服务器发出请求的经过身份验证的用户的组成员身份</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>groups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- system:authenticated<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- my-admin-group<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 向 API 服务器发出请求的用户相关的任意附加信息</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 该字段由 API 服务器身份验证层填充，并且如果 webhook 执行了任何</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># SubjectAccessReview 检查，则应将其包括在内。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>extra</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>some-key</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- some-value1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- some-value2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># object 是被接纳的新对象。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 对于 DELETE 操作，它为 null。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>object</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>autoscaling/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Scale<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># oldObject 是现有对象。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 对于 CREATE 和 CONNECT 操作，它为 null。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>oldObject</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>autoscaling/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Scale<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># options 包含要接受的操作的选项，例如 meta.k8s.io/v CreateOptions、UpdateOptions 或 DeleteOptions。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 对于 CONNECT 操作，它为 null。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>options</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>meta.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>UpdateOptions<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># dryRun 表示 API 请求正在以 `dryrun` 模式运行，并且将不会保留。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 带有副作用的 Webhook 应该避免在 dryRun 为 true 时激活这些副作用。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 有关更多详细信息，请参见 http://k8s.io/docs/reference/using-api/api-concepts/#make-a-dry-run-request</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>dryRun</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>False</span><span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=response>响应</h3><p>Webhook 使用 HTTP 200 状态码、<code>Content-Type: application/json</code> 和一个包含 <code>AdmissionReview</code> 对象的 JSON 序列化格式来发送响应。该 <code>AdmissionReview</code> 对象与发送的版本相同，且其中包含的 <code>response</code> 字段已被有效填充。</p><p><code>response</code> 至少必须包含以下字段：</p><ul><li><code>uid</code>，从发送到 Webhook 的 <code>request.uid</code> 中复制而来</li><li><code>allowed</code>，设置为 <code>true</code> 或 <code>false</code></li></ul><p>Webhook 允许请求的最简单响应示例：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;admission.k8s.io/v1&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;AdmissionReview&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;response&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;uid&#34;</span>: <span style=color:#b44>&#34;&lt;value from request.uid&gt;&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;allowed&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Webhook 禁止请求的最简单响应示例：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;admission.k8s.io/v1&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;AdmissionReview&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;response&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;uid&#34;</span>: <span style=color:#b44>&#34;&lt;value from request.uid&gt;&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;allowed&#34;</span>: <span style=color:#a2f;font-weight:700>false</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>当拒绝请求时，Webhook 可以使用 <code>status</code> 字段自定义 http 响应码和返回给用户的消息。
有关状态类型的详细信息，请参见
<a href=/docs/reference/generated/kubernetes-api/v1.25/#status-v1-meta>API 文档</a>。
禁止请求的响应示例，它定制了向用户显示的 HTTP 状态码和消息：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;admission.k8s.io/v1&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;AdmissionReview&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;response&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;uid&#34;</span>: <span style=color:#b44>&#34;&lt;value from request.uid&gt;&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;allowed&#34;</span>: <span style=color:#a2f;font-weight:700>false</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;status&#34;</span>: {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;code&#34;</span>: <span style=color:#666>403</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;message&#34;</span>: <span style=color:#b44>&#34;You cannot do this because it is Tuesday and your name starts with A&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>当允许请求时，mutating准入 Webhook 也可以选择修改传入的对象。
这是通过在响应中使用 <code>patch</code> 和 <code>patchType</code> 字段来完成的。
当前唯一支持的 <code>patchType</code> 是 <code>JSONPatch</code>。
有关更多详细信息，请参见 <a href=https://jsonpatch.com/>JSON patch</a>。
对于 <code>patchType: JSONPatch</code>，<code>patch</code> 字段包含一个以 base64 编码的 JSON patch 操作数组。</p><p>例如，设置 <code>spec.replicas</code> 的单个补丁操作将是
<code>[{"op": "add", "path": "/spec/replicas", "value": 3}]</code>。</p><p>如果以 Base64 形式编码，结果将是
<code>W3sib3AiOiAiYWRkIiwgInBhdGgiOiAiL3NwZWMvcmVwbGljYXMiLCAidmFsdWUiOiAzfV0=</code></p><p>因此，添加该标签的 Webhook 响应为：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;admission.k8s.io/v1&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;AdmissionReview&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;response&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;uid&#34;</span>: <span style=color:#b44>&#34;&lt;value from request.uid&gt;&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;allowed&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;patchType&#34;</span>: <span style=color:#b44>&#34;JSONPatch&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;patch&#34;</span>: <span style=color:#b44>&#34;W3sib3AiOiAiYWRkIiwgInBhdGgiOiAiL3NwZWMvcmVwbGljYXMiLCAidmFsdWUiOiAzfV0=&#34;</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>准入 Webhook 可以选择性地返回在 HTTP <code>Warning</code> 头中返回给请求客户端的警告消息，警告代码为 299。
警告可以与允许或拒绝的准入响应一起发送。</p><p>如果你正在实现返回一条警告的 webhook，则：</p><ul><li>不要在消息中包括 "Warning:" 前缀</li><li>使用警告消息描述该客户端进行 API 请求时会遇到或应意识到的问题</li><li>如果可能，将警告限制为 120 个字符</li></ul><div class="alert alert-warning caution callout" role=alert><strong>注意：</strong><p>超过 256 个字符的单条警告消息在返回给客户之前可能会被 API 服务器截断。
如果超过 4096 个字符的警告消息（来自所有来源），则额外的警告消息会被忽略。</div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;admission.k8s.io/v1&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;AdmissionReview&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;response&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;uid&#34;</span>: <span style=color:#b44>&#34;&lt;value from request.uid&gt;&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;allowed&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;warnings&#34;</span>: [
</span></span><span style=display:flex><span>      <span style=color:#b44>&#34;duplicate envvar entries specified with name MY_ENV&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:#b44>&#34;memory request less than 4MB specified for container mycontainer, which will not start successfully&#34;</span>
</span></span><span style=display:flex><span>    ]
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=webhook-configuration>Webhook 配置</h2><p>要注册准入 Webhook，请创建 <code>MutatingWebhookConfiguration</code> 或 <code>ValidatingWebhookConfiguration</code> API 对象。
<code>MutatingWebhookConfiguration</code> 或<code>ValidatingWebhookConfiguration</code> 对象的名称必须是有效的
<a href=/zh-cn/docs/concepts/overview/working-with-objects/names#dns-subdomain-names>DNS 子域名</a>。</p><p>每种配置可以包含一个或多个 Webhook。如果在单个配置中指定了多个
Webhook，则应为每个 Webhook 赋予一个唯一的名称。
这是必需的，以使生成的审计日志和指标更易于与激活的配置相匹配。</p><p>每个 Webhook 定义以下内容。</p><h3 id=matching-requests-rules>匹配请求-规则</h3><p>每个 webhook 必须指定用于确定是否应将对 apiserver 的请求发送到 webhook 的规则列表。
每个规则都指定一个或多个 operations、apiGroups、apiVersions 和 resources 以及资源的 scope：</p><ul><li><code>operations</code> 列出一个或多个要匹配的操作。
可以是 <code>CREATE</code>、<code>UPDATE</code>、<code>DELETE</code>、<code>CONNECT</code> 或 <code>*</code> 以匹配所有内容。</li><li><code>apiGroups</code> 列出了一个或多个要匹配的 API 组。<code>""</code> 是核心 API 组。<code>"*"</code> 匹配所有 API 组。</li><li><code>apiVersions</code> 列出了一个或多个要匹配的 API 版本。<code>"*"</code> 匹配所有 API 版本。</li><li><code>resources</code> 列出了一个或多个要匹配的资源。<ul><li><code>"*"</code> 匹配所有资源，但不包括子资源。</li><li><code>"*/*"</code> 匹配所有资源，包括子资源。</li><li><code>"pods/*"</code> 匹配 pod 的所有子资源。</li><li><code>"*/status"</code> 匹配所有 status 子资源。</li></ul></li><li><code>scope</code> 指定要匹配的范围。有效值为 <code>"Cluster"</code>、<code>"Namespaced"</code> 和 <code>"*"</code>。
子资源匹配其父资源的范围。默认值为 <code>"*"</code>。<ul><li><code>"Cluster"</code> 表示只有集群作用域的资源才能匹配此规则（API 对象 Namespace 是集群作用域的）。</li><li><code>"Namespaced"</code> 意味着仅具有名字空间的资源才符合此规则。</li><li><code>"*"</code> 表示没有作用域限制。</li></ul></li></ul><p>如果传入请求与任何 Webhook <code>rules</code> 的指定 <code>operations</code>、<code>groups</code>、<code>versions</code>、
<code>resources</code> 和 <code>scope</code> 匹配，则该请求将发送到 Webhook。</p><p>以下是可用于指定应拦截哪些资源的规则的其他示例。</p><p>匹配针对 <code>apps/v1</code> 和 <code>apps/v1beta1</code> 组中 <code>deployments</code> 和 <code>replicasets</code>
资源的 <code>CREATE</code> 或 <code>UPDATE</code> 请求：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>admissionregistration.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ValidatingWebhookConfiguration<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>webhooks</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-webhook.example.com<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>operations</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;CREATE&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;UPDATE&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;apps&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersions</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;v1&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;v1beta1&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;deployments&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;replicasets&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>scope</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Namespaced&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>...<span style=color:#bbb>
</span></span></span></code></pre></div><p>匹配所有 API 组和版本中的所有资源（但不包括子资源）的创建请求：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>admissionregistration.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ValidatingWebhookConfiguration<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>webhooks</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-webhook.example.com<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>operations</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;CREATE&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;*&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>apiVersions</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;*&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;*&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>scope</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;*&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>匹配所有 API 组和版本中所有 <code>status</code> 子资源的更新请求：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>admissionregistration.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ValidatingWebhookConfiguration<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>webhooks</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-webhook.example.com<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>operations</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;UPDATE&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;*&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>apiVersions</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;*&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;*/status&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>scope</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;*&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=matching-requests-objectselector>匹配请求：objectSelector</h3><p>通过指定 <code>objectSelector</code>，Webhook 能够根据可能发送的对象的标签来限制哪些请求被拦截。
如果指定，则将对 <code>objectSelector</code> 和可能发送到 Webhook 的 object 和 oldObject
进行评估。如果两个对象之一与选择器匹配，则认为该请求已匹配。</p><p>空对象（对于创建操作而言为 <code>oldObject</code>，对于删除操作而言为 <code>newObject</code>），
或不能带标签的对象（例如 <code>DeploymentRollback</code> 或 <code>PodProxyOptions</code> 对象）
被认为不匹配。</p><p>仅当选择使用 webhook 时才使用对象选择器，因为最终用户可以通过设置标签来
跳过准入 Webhook。</p><p>这个例子展示了一个 mutating webhook，它将匹配带有标签 <code>foo:bar</code> 的任何资源的
<code>CREATE</code> 的操作：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>admissionregistration.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>MutatingWebhookConfiguration<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>webhooks</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-webhook.example.com<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>objectSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>foo</span>:<span style=color:#bbb> </span>bar<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>operations</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;CREATE&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;*&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersions</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;*&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;*&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>scope</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;*&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>有关标签选择器的更多示例，请参见<a href=/zh-cn/docs/concepts/overview/working-with-objects/labels>标签</a>。</p><h3 id=matching-requests-namespaceselector>匹配请求：namespaceSelector</h3><p>通过指定 <code>namespaceSelector</code>，
Webhook 可以根据具有名字空间的资源所处的名字空间的标签来选择拦截哪些资源的操作。</p><p><code>namespaceSelector</code> 根据名字空间的标签是否匹配选择器，决定是否针对具名字空间的资源
（或 Namespace 对象）的请求运行 webhook。
如果对象是除 Namespace 以外的集群范围的资源，则 <code>namespaceSelector</code> 标签无效。</p><p>本例给出的修改性质的 Webhook 将匹配到对名字空间中具名字空间的资源的 <code>CREATE</code> 请求，
前提是这些资源不含值为 "0" 或 "1" 的 "runlevel" 标签：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>admissionregistration.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>MutatingWebhookConfiguration<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>webhooks</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-webhook.example.com<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>namespaceSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>runlevel<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>NotIn<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;0&#34;</span>,<span style=color:#b44>&#34;1&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>operations</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;CREATE&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;*&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>apiVersions</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;*&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;*&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>scope</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Namespaced&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>此示例显示了一个验证性质的 Webhook，它将匹配到对某名字空间中的任何具名字空间的资源的
<code>CREATE</code> 请求，前提是该名字空间具有值为 "prod" 或 "staging" 的 "environment" 标签：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>admissionregistration.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ValidatingWebhookConfiguration<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>webhooks</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-webhook.example.com<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>namespaceSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>environment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>operator</span>:<span style=color:#bbb> </span>In<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>values</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;prod&#34;</span>,<span style=color:#b44>&#34;staging&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>operations</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;CREATE&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;*&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>apiVersions</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;*&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;*&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>scope</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Namespaced&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>有关标签选择器的更多示例，请参见
<a href=/zh-cn/docs/concepts/overview/working-with-objects/labels>标签</a>。</p><h3 id=matching-requests-matchpolicy>匹配请求：matchPolicy</h3><p>API 服务器可以通过多个 API 组或版本来提供对象。</p><p>例如，如果一个 webhook 仅为某些 API 组/版本指定了规则（例如
<code>apiGroups:["apps"], apiVersions:["v1","v1beta1"]</code>），而修改资源的请求是通过另一个
API 组/版本（例如 <code>extensions/v1beta1</code>）发出的，该请求将不会被发送到 Webhook。</p><p><code>matchPolicy</code> 允许 webhook 定义如何使用其 <code>rules</code> 匹配传入的请求。
允许的值为 <code>Exact</code> 或 <code>Equivalent</code>。</p><ul><li><code>Exact</code> 表示仅当请求与指定规则完全匹配时才应拦截该请求。</li><li><code>Equivalent</code> 表示如果某个请求意在修改 <code>rules</code> 中列出的资源，
即使该请求是通过其他 API 组或版本发起，也应拦截该请求。</li></ul><p>在上面给出的示例中，仅为 <code>apps/v1</code> 注册的 webhook 可以使用 <code>matchPolicy</code>：</p><ul><li><code>matchPolicy: Exact</code> 表示不会将 <code>extensions/v1beta1</code> 请求发送到 Webhook</li><li><code>matchPolicy:Equivalent</code> 表示将 <code>extensions/v1beta1</code> 请求发送到 webhook
（将对象转换为 webhook 指定的版本：<code>apps/v1</code>）</li></ul><p>建议指定 <code>Equivalent</code>，确保升级后启用 API 服务器中资源的新版本时，
Webhook 继续拦截他们期望的资源。</p><p>当 API 服务器停止提供某资源时，该资源不再被视为等同于该资源的其他仍在提供服务的版本。
例如，<code>extensions/v1beta1</code> 中的 Deployment 已被废弃，计划在 v1.16 中移除。</p><p>移除后，带有 <code>apiGroups:["extensions"], apiVersions:["v1beta1"], resources: ["deployments"]</code>
规则的 Webhook 将不再拦截通过 <code>apps/v1</code> API 来创建的 Deployment。
因此，Webhook 应该优先注册稳定版本的资源。</p><p>此示例显示了一个验证性质的 Webhook，该 Webhook 拦截对 Deployment 的修改（无论 API 组或版本是什么），
始终会发送一个 <code>apps/v1</code> 版本的 Deployment 对象：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>admissionregistration.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ValidatingWebhookConfiguration<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>webhooks</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-webhook.example.com<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>matchPolicy</span>:<span style=color:#bbb> </span>Equivalent<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>operations</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;CREATE&#34;</span>,<span style=color:#b44>&#34;UPDATE&#34;</span>,<span style=color:#b44>&#34;DELETE&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;apps&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersions</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;v1&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;deployments&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>scope</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;Namespaced&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>准入 Webhook 所用的 <code>matchPolicy</code> 默认为 <code>Equivalent</code>。</p><h3 id=contacting-the-webhook>调用 Webhook</h3><p>API 服务器确定请求应发送到 webhook 后，它需要知道如何调用 webhook。
此信息在 webhook 配置的 <code>clientConfig</code> 节中指定。</p><p>Webhook 可以通过 URL 或服务引用来调用，并且可以选择包含自定义 CA 包，以用于验证 TLS 连接。</p><h4 id=url>URL</h4><p><code>url</code> 以标准 URL 形式给出 webhook 的位置（<code>scheme://host:port/path</code>）。</p><p><code>host</code> 不应引用集群中运行的服务；通过指定 <code>service</code> 字段来使用服务引用。
主机可以通过某些 API 服务器中的外部 DNS 进行解析。
（例如，<code>kube-apiserver</code> 无法解析集群内 DNS，因为这将违反分层规则）。<code>host</code> 也可以是 IP 地址。</p><p>请注意，将 <code>localhost</code> 或 <code>127.0.0.1</code> 用作 <code>host</code> 是有风险的，
除非你非常小心地在所有运行 apiserver 的、可能需要对此 webhook
进行调用的主机上运行。这样的安装方式可能不具有可移植性，即很难在新集群中启用。</p><p>scheme 必须为 "https"；URL 必须以 "https://" 开头。</p><p>使用用户或基本身份验证（例如："user:password@"）是不允许的。
使用片段（"#..."）和查询参数（"?..."）也是不允许的。</p><p>这是配置为调用 URL 的修改性质的 Webhook 的示例
（并且期望使用系统信任根证书来验证 TLS 证书，因此不指定 caBundle）：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>admissionregistration.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>MutatingWebhookConfiguration<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>webhooks</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-webhook.example.com<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clientConfig</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>url</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;https://my-webhook.example.com:9443/my-webhook-path&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><h4 id=service-reference>服务引用</h4><p><code>clientConfig</code> 内部的 Service 是对该 Webhook 服务的引用。
如果 Webhook 在集群中运行，则应使用 <code>service</code> 而不是 <code>url</code>。
服务的 <code>namespace</code> 和 <code>name</code> 是必需的。
<code>port</code> 是可选的，默认值为 443。<code>path</code> 是可选的，默认为 "/"。</p><p>这是一个 mutating Webhook 的示例，该 mutating Webhook 配置为在子路径 "/my-path" 端口
"1234" 上调用服务，并使用自定义 CA 包针对 ServerName
<code>my-service-name.my-service-namespace.svc</code> 验证 TLS 连接：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>admissionregistration.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>MutatingWebhookConfiguration<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>webhooks</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-webhook.example.com<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clientConfig</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>caBundle</span>:<span style=color:#bbb> </span>&lt;CA_BUNDLE&gt;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>service</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>my-service-namespace<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-service-name<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>/my-path<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>port</span>:<span style=color:#bbb> </span><span style=color:#666>1234</span><span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>你必须在以上示例中将 <code>&lt;CA_BUNDLE></code> 替换为一个有效的 VA 证书包，
这是一个用 PEM 编码的 CA 证书包，用于校验 Webhook 的服务器证书。</div><h3 id=side-effects>副作用</h3><p>Webhook 通常仅对发送给他们的 <code>AdmissionReview</code> 内容进行操作。
但是，某些 Webhook 在处理 admission 请求时会进行带外更改。</p><p>进行带外更改的（产生“副作用”的） Webhook 必须具有协调机制（如控制器），
该机制定期确定事物的实际状态，并调整由准入 Webhook 修改的带外数据以反映现实情况。
这是因为对准入 Webhook 的调用不能保证所准入的对象将原样保留，或根本不保留。
以后，webhook 可以修改对象的内容，在写入存储时可能会发生冲突，或者
服务器可以在持久保存对象之前关闭电源。</p><p>此外，处理 <code>dryRun: true</code> admission 请求时，具有副作用的 Webhook 必须避免产生副作用。
一个 Webhook 必须明确指出在使用 <code>dryRun</code> 运行时不会有副作用，
否则 <code>dry-run</code> 请求将不会发送到该 Webhook，而 API 请求将会失败。</p><p>Webhook 使用 webhook 配置中的 <code>sideEffects</code> 字段显示它们是否有副作用：</p><ul><li><code>None</code>：调用 webhook 没有副作用。</li><li><code>NoneOnDryRun</code>：调用 webhook 可能会有副作用，但是如果将带有 <code>dryRun: true</code>
属性的请求发送到 webhook，则 webhook 将抑制副作用（该 webhook 可识别 <code>dryRun</code>）。</li></ul><p>这是一个 validating webhook 的示例，表明它对 <code>dryRun: true</code> 请求没有副作用：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>admissionregistration.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ValidatingWebhookConfiguration<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>webhooks</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-webhook.example.com<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>sideEffects</span>:<span style=color:#bbb> </span>NoneOnDryRun<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=timeouts>超时</h3><p>由于 Webhook 会增加 API 请求的延迟，因此应尽快完成自身的操作。
<code>timeoutSeconds</code> 用来配置在将调用视为失败之前，允许 API 服务器等待 Webhook 响应的时间长度。</p><p>如果超时在 Webhook 响应之前被触发，则基于<a href=#failure-policy>失败策略</a>，将忽略
Webhook 调用或拒绝 API 调用。</p><p>超时值必须设置在 1 到 30 秒之间。</p><p>这是一个自定义超时设置为 2 秒的 validating Webhook 的示例：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>admissionregistration.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ValidatingWebhookConfiguration<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>webhooks</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-webhook.example.com<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>timeoutSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>准入 Webhook 所用的超时时间默认为 10 秒。</p><h3 id=reinvocation-policy>再调用策略</h3><p>修改性质的准入插件（包括 Webhook）的任何一种排序方式都不会适用于所有情况。
(参见 <a href=https://issue.k8s.io/64333>https://issue.k8s.io/64333</a> 示例)。
修改性质的 Webhook 可以向对象中添加新的子结构（例如向 <code>pod</code> 中添加 <code>container</code>），
已经运行的其他修改插件可能会对这些新结构有影响
（就像在所有容器上设置 <code>imagePullPolicy</code> 一样）。</p><p>要允许修改性质的准入插件感应到其他插件所做的更改，
如果修改性质的 Webhook 修改了一个对象，则会重新运行内置的修改性质的准入插件，
并且修改性质的 Webhook 可以指定 <code>reinvocationPolicy</code> 来控制是否也重新调用它们。</p><p>可以将 <code>reinvocationPolicy</code> 设置为 <code>Never</code> 或 <code>IfNeeded</code>。 默认为 <code>Never</code>。</p><ul><li><code>Never</code>: 在一次准入测试中，不得多次调用 Webhook。</li><li><code>IfNeeded</code>: 如果在最初的 Webhook 调用之后被其他对象的插件修改了被接纳的对象，
则可以作为准入测试的一部分再次调用该 webhook。</li></ul><p>要注意的重要因素有：</p><ul><li>不能保证附加调用的次数恰好是一。</li><li>如果其他调用导致对该对象的进一步修改，则不能保证再次调用 Webhook。</li><li>使用此选项的 Webhook 可能会重新排序，以最大程度地减少额外调用的次数。</li><li>要在确保所有修改都完成后验证对象，请改用验证性质的 Webhook
（推荐用于有副作用的 Webhook）。</li></ul><p>这是一个修改性质的 Webhook 的示例，该 Webhook 在以后的准入插件修改对象时被重新调用：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>admissionregistration.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>MutatingWebhookConfiguration<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>webhooks</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-webhook.example.com<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>reinvocationPolicy</span>:<span style=color:#bbb> </span>IfNeeded<span style=color:#bbb>
</span></span></span></code></pre></div><p>修改性质的 Webhook 必须具有<a href=#idempotence>幂等</a>性，并且能够成功处理
已被接纳并可能被修改的对象的修改性质的 Webhook。
对于所有修改性质的准入 Webhook 都是如此，因为它们可以在对象中进行的
任何更改可能已经存在于用户提供的对象中，但是对于选择重新调用的 webhook
来说是必不可少的。</p><h3 id=failure-policy>失败策略</h3><p><code>failurePolicy</code> 定义了如何处理准入 webhook 中无法识别的错误和超时错误。允许的值为 <code>Ignore</code> 或 <code>Fail</code>。</p><ul><li><code>Ignore</code> 表示调用 webhook 的错误将被忽略并且允许 API 请求继续。</li><li><code>Fail</code> 表示调用 webhook 的错误导致准入失败并且 API 请求被拒绝。</li></ul><p>这是一个修改性质的 webhook，配置为在调用准入 Webhook 遇到错误时拒绝 API 请求：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>admissionregistration.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>MutatingWebhookConfiguration<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>webhooks</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>my-webhook.example.com<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>failurePolicy</span>:<span style=color:#bbb> </span>Fail<span style=color:#bbb>
</span></span></span></code></pre></div><p>准入 Webhook 所用的默认 <code>failurePolicy</code> 是 <code>Fail</code>。</p><h2 id=monitoring-admission-webhooks>监控 Admission Webhook</h2><p>API 服务器提供了监视准入 Webhook 行为的方法。这些监视机制可帮助集群管理员回答以下问题：</p><ol><li>哪个修改性质的 webhook 改变了 API 请求中的对象？</li><li>修改性质的 Webhook 对对象做了哪些更改？</li><li>哪些 webhook 经常拒绝 API 请求？是什么原因拒绝？</li></ol><h3 id=mutating-webhook-auditing-annotations>Mutating Webhook 审计注解</h3><p>有时，了解 API 请求中的哪个修改性质的 Webhook 使对象改变以及该 Webhook 应用了哪些更改很有用。</p><p>Kubernetes API 服务器针对每个修改性质的 Webhook 调用执行<a href=/zh-cn/docs/tasks/debug/debug-cluster/audit/>审计</a>操作。
每个调用都会生成一个审计注解，记述请求对象是否发生改变，
可选地还可以根据 Webhook 的准入响应生成一个注解，记述所应用的修补。
针对给定请求的给定执行阶段，注解被添加到审计事件中，
然后根据特定策略进行预处理并写入后端。</p><p>事件的审计级别决定了要记录哪些注解：</p><ul><li><p>在 <code>Metadata</code> 或更高审计级别上，将使用 JSON 负载记录带有键名
<code>mutation.webhook.admission.k8s.io/round_{round idx}_index_{order idx}</code> 的注解，
该注解表示针对给定请求调用了 Webhook，以及该 Webhook 是否更改了对象。</p><p>例如，对于正在被重新调用的某 Webhook，所记录的注解如下。
Webhook 在 mutating Webhook 链中排在第三个位置，并且在调用期间未改变请求对象。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#080;font-style:italic># 审计事件相关记录</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;kind&#34;: </span><span style=color:#b44>&#34;Event&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;apiVersion&#34;: </span><span style=color:#b44>&#34;audit.k8s.io/v1&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;annotations&#34;: </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>&#34;mutation.webhook.admission.k8s.io/round_1_index_2&#34;: &#34;{\&#34;configuration\&#34;:\&#34;my-mutating-webhook-configuration.example.com\&#34;,\&#34;webhook\&#34;:\&#34;my-webhook.example.com\&#34;,\&#34;mutated\&#34;: </span><span style=color:#a2f;font-weight:700>false</span>}&#34;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 其他注解</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 其他字段</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#080;font-style:italic># 反序列化的注解值</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;configuration&#34;: </span><span style=color:#b44>&#34;my-mutating-webhook-configuration.example.com&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;webhook&#34;: </span><span style=color:#b44>&#34;my-webhook.example.com&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;mutated&#34;: </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></span></span></code></pre></div><p>对于在第一轮中调用的 Webhook，所记录的注解如下。
Webhook 在 mutating Webhook 链中排在第一位，并在调用期间改变了请求对象。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#080;font-style:italic># 审计事件相关记录</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;kind&#34;: </span><span style=color:#b44>&#34;Event&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;apiVersion&#34;: </span><span style=color:#b44>&#34;audit.k8s.io/v1&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;annotations&#34;: </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>&#34;mutation.webhook.admission.k8s.io/round_0_index_0&#34;: &#34;{\&#34;configuration\&#34;:\&#34;my-mutating-webhook-configuration.example.com\&#34;,\&#34;webhook\&#34;:\&#34;my-webhook-always-mutate.example.com\&#34;,\&#34;mutated\&#34;: </span><span style=color:#a2f;font-weight:700>true</span>}&#34;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 其他注解</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 其他字段</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#080;font-style:italic># 反序列化的注解值</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;configuration&#34;: </span><span style=color:#b44>&#34;my-mutating-webhook-configuration.example.com&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;webhook&#34;: </span><span style=color:#b44>&#34;my-webhook-always-mutate.example.com&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;mutated&#34;: </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></span></span></code></pre></div></li></ul><ul><li><p>在 <code>Request</code> 或更高审计级别上，将使用 JSON 负载记录带有键名为
<code>patch.webhook.admission.k8s.io/round_{round idx}_index_{order idx}</code> 的注解，
该注解表明针对给定请求调用了 Webhook 以及应用于请求对象之上的修改。</p><p>例如，以下是针对正在被重新调用的某 Webhook 所记录的注解。
Webhook 在修改性质的 Webhook 链中排在第四，并在其响应中包含一个 JSON 补丁，
该补丁已被应用于请求对象。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#080;font-style:italic># 审计事件相关记录</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;kind&#34;: </span><span style=color:#b44>&#34;Event&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;apiVersion&#34;: </span><span style=color:#b44>&#34;audit.k8s.io/v1&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;annotations&#34;: </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>&#34;patch.webhook.admission.k8s.io/round_1_index_3&#34;: </span><span style=color:#b44>&#34;{\&#34;configuration\&#34;:\&#34;my-other-mutating-webhook-configuration.example.com\&#34;,\&#34;webhook\&#34;:\&#34;my-webhook-always-mutate.example.com\&#34;,\&#34;patch\&#34;:[{\&#34;op\&#34;:\&#34;add\&#34;,\&#34;path\&#34;:\&#34;/data/mutation-stage\&#34;,\&#34;value\&#34;:\&#34;yes\&#34;}],\&#34;patchType\&#34;:\&#34;JSONPatch\&#34;}&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#080;font-style:italic># 其他注解</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 其他字段</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#080;font-style:italic># 反序列化的注解值</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;configuration&#34;: </span><span style=color:#b44>&#34;my-other-mutating-webhook-configuration.example.com&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;webhook&#34;: </span><span style=color:#b44>&#34;my-webhook-always-mutate.example.com&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;patchType&#34;: </span><span style=color:#b44>&#34;JSONPatch&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;patch&#34;: </span>[<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>&#34;op&#34;: </span><span style=color:#b44>&#34;add&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>&#34;path&#34;: </span><span style=color:#b44>&#34;/data/mutation-stage&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>&#34;value&#34;: </span><span style=color:#b44>&#34;yes&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></span></span></code></pre></div></li></ul><h3 id=admission-webhook-metrics>准入 Webhook 度量值</h3><p>API 服务器从 <code>/metrics</code> 端点公开 Prometheus 指标，这些指标可用于监控和诊断 API 服务器状态。
以下指标记录了与准入 Webhook 相关的状态。</p><h4 id=api-server-admission-webhook-rejection-count>apiserver 准入 Webhook 拒绝次数</h4><p>有时，了解哪些准入 Webhook 经常拒绝 API 请求以及拒绝的原因是很有用的。</p><p>在 v1.16+ 中，kube-apiserver 提供了 Prometheus 计数器度量值，记录
准入 Webhook 的拒绝次数。
度量值的标签给出了 Webhook 拒绝该请求的原因：</p><ul><li><code>name</code>：拒绝请求 Webhook 的名称。</li><li><code>operation</code>：请求的操作类型可以是 <code>CREATE</code>、<code>UPDATE</code>、<code>DELETE</code> 和 <code>CONNECT</code> 其中之一。</li><li><code>type</code>：Admission webhook 类型，可以是 <code>admit</code> 和 <code>validating</code> 其中之一。</li><li><code>error_type</code>：标识在 webhook 调用期间是否发生了错误并且导致了拒绝。其值可以是以下之一：<ul><li><code>calling_webhook_error</code>：发生了来自准入 Webhook 的无法识别的错误或超时错误，
并且 webhook 的 <a href=#failure-policy>失败策略</a> 设置为 <code>Fail</code>。</li><li><code>no_error</code>：未发生错误。Webhook 在准入响应中以 <code>allowed: false</code> 值拒绝了请求。
度量标签 <code>rejection_code</code> 记录了在准入响应中设置的 <code>.status.code</code>。</li><li><code>apiserver_internal_error</code>：apiserver 发生内部错误。</li></ul></li><li><code>rejection_code</code>：当 Webhook 拒绝请求时，在准入响应中设置的 HTTP 状态码。</li></ul><p>拒绝计数指标示例：</p><pre tabindex=0><code># HELP apiserver_admission_webhook_rejection_count [ALPHA] Admission webhook rejection count, identified by name and broken out for each admission type (validating or admit) and operation. Additional labels specify an error type (calling_webhook_error or apiserver_internal_error if an error occurred; no_error otherwise) and optionally a non-zero rejection code if the webhook rejects the request with an HTTP status code (honored by the apiserver when the code is greater or equal to 400). Codes greater than 600 are truncated to 600, to keep the metrics cardinality bounded.
# TYPE apiserver_admission_webhook_rejection_count counter
apiserver_admission_webhook_rejection_count{error_type=&#34;calling_webhook_error&#34;,name=&#34;always-timeout-webhook.example.com&#34;,operation=&#34;CREATE&#34;,rejection_code=&#34;0&#34;,type=&#34;validating&#34;} 1
apiserver_admission_webhook_rejection_count{error_type=&#34;calling_webhook_error&#34;,name=&#34;invalid-admission-response-webhook.example.com&#34;,operation=&#34;CREATE&#34;,rejection_code=&#34;0&#34;,type=&#34;validating&#34;} 1
apiserver_admission_webhook_rejection_count{error_type=&#34;no_error&#34;,name=&#34;deny-unwanted-configmap-data.example.com&#34;,operation=&#34;CREATE&#34;,rejection_code=&#34;400&#34;,type=&#34;validating&#34;} 13
</code></pre><h2 id=best-practices-and-warnings>最佳实践和警告</h2><h3 id=idempotence>幂等性</h3><p>幂等的修改性质的准入 Webhook 能够成功处理已经被它接纳甚或修改的对象。
即使多次执行该准入测试，也不会产生与初次执行结果相异的结果。</p><h4 id=example-of-idempotent-mutating-admission-webhooks>幂等 mutating admission Webhook 的示例：</h4><ol><li>对于 <code>CREATE</code> Pod 请求，将 Pod 的字段 <code>.spec.securityContext.runAsNonRoot</code>
设置为 true，以实施安全最佳实践。</li><li>对于 <code>CREATE</code> Pod 请求，如果未设置容器的字段
<code>.spec.containers[].resources.limits</code>，设置默认资源限制值。</li><li>对于 <code>CREATE</code> pod 请求，如果 Pod 中不存在名为 <code>foo-sidecar</code> 的边车容器，
向 Pod 注入一个 <code>foo-sidecar</code> 容器。</li></ol><p>在上述情况下，可以安全地重新调用 Webhook，或接受已经设置了字段的对象。</p><h4 id=example-of-non-idempotent-mutating-admission-webhooks>非幂等 mutating admission Webhook 的示例：</h4><ol><li>对于 <code>CREATE</code> pod 请求，注入名称为 <code>foo-sidecar</code> 并带有当前时间戳的
边车容器（例如 <code>foo-sidecar-19700101-000000</code>）。</li><li>对于 <code>CREATE/UPDATE</code> pod 请求，如果容器已设置标签 <code>"env"</code> 则拒绝，
否则将 <code>"env": "prod"</code> 标签添加到容器。</li><li>对于 <code>CREATE</code> pod 请求，盲目地添加一个名为 <code>foo-sidecar</code> 的边车容器，
而未查看 Pod 中是否已经有 <code>foo-sidecar</code> 容器。</li></ol><p>在上述第一种情况下，重新调用该 Webhook 可能导致同一个 Sidecar 容器
多次注入到 Pod 中，而且每次使用不同的容器名称。
类似地，如果 Sidecar 已存在于用户提供的 Pod 中，则 Webhook 可能注入重复的容器。</p><p>在上述第二种情况下，重新调用 Webhook 将导致 Webhook 自身输出失败。</p><p>在上述第三种情况下，重新调用 Webhook 将导致 Pod 规范中的容器重复，
从而使请求无效并被 API 服务器拒绝。</p><h3 id=intercepting-all-versions-of-an-object>拦截对象的所有版本</h3><p>建议通过将 <code>.webhooks[].matchPolicy</code> 设置为 <code>Equivalent</code>，
以确保准入 Webhooks 始终拦截对象的所有版本。
建议准入 Webhooks 应该更偏向注册资源的稳定版本。
如果无法拦截对象的所有版本，可能会导致准入策略未再某些版本的请求上执行。
有关示例，请参见<a href=#matching-requests-matchpolicy>匹配请求：matchPolicy</a>。</p><h3 id=availability>可用性</h3><p>建议准入 webhook 尽快完成执行（时长通常是毫秒级），因为它们会增加 API 请求的延迟。
建议对 Webhook 使用较小的超时值。有关更多详细信息，请参见<a href=#timeouts>超时</a>。</p><p>建议 Admission Webhook 应该采用某种形式的负载均衡机制，以提供高可用性和高性能。
如果集群中正在运行 Webhook，则可以在服务后面运行多个 Webhook 后端，以利用该服务支持的负载均衡。</p><h3 id=guaranteeing-the-final-state-of-the-object-is-seen>确保看到对象的最终状态</h3><p>如果某准入 Webhook 需要保证自己能够看到对象的最终状态以实施策略，
则应该使用一个验证性质的 webhook，
因为可以通过 mutating Webhook 看到对象后对其进行修改。</p><p>例如，一个修改性质的准入Webhook 被配置为在每个 <code>CREATE</code> Pod 请求中
注入一个名称为 "foo-sidecar" 的 sidecar 容器。</p><p>如果<em>必须</em>存在边车容器，则还应配置一个验证性质的准入 Webhook 以拦截
<code>CREATE</code> Pod 请求，并验证要创建的对象中是否存在具有预期配置的名称为
"foo-sidecar" 的容器。</p><h3 id=avoiding-deadlocks-in-self-hosted-webhooks>避免自托管的 Webhooks 中出现死锁</h3><p>如果集群内的 Webhook 配置能够拦截启动其自己的 Pod 所需的资源，
则该 Webhook 可能导致其自身部署时发生死锁。</p><p>例如，某修改性质的准入 Webhook 配置为仅当 Pod 中设置了某个标签
（例如 <code>"env": "prod"</code>）时，才接受 <code>CREATE</code> Pod 请求。
Webhook 服务器在未设置 <code>"env"</code> 标签的 Deployment 中运行。当运行 Webhook 服务器的
容器的节点运行不正常时，Webhook 部署尝试将容器重新调度到另一个节点。
但是，由于未设置 <code>"env"</code> 标签，因此请求将被现有的 Webhook 服务器拒绝，并且调度迁移不会发生。</p><p>建议使用 <a href=#matching-requests-namespaceselector>namespaceSelector</a> 排除
Webhook 所在的名字空间。</p><h3 id=side-effects>副作用</h3><p>建议准入 Webhook 应尽可能避免副作用，这意味着该准入 webhook 仅对发送给他们的
<code>AdmissionReview</code> 的内容起作用，并且不要进行额外更改。
如果 Webhook 没有任何副作用，则 <code>.webhooks[].sideEffects</code> 字段应设置为
<code>None</code>。</p><p>如果在准入执行期间存在副作用，则应在处理 <code>dryRun</code> 为 <code>true</code> 的 <code>AdmissionReview</code>
对象时避免产生副作用，并且其 <code>.webhooks[].sideEffects</code> 字段应设置为
<code>NoneOnDryRun</code>。更多详细信息，请参见<a href=#side-effects>副作用</a>。</p><h3 id=avoiding-operating-on-the-kube-system-namespace>避免对 kube-system 名字空间进行操作</h3><p><code>kube-system</code> 名字空间包含由 Kubernetes 系统创建的对象，
例如用于控制平面组件的服务账号，诸如 <code>kube-dns</code> 之类的 Pod 等。
意外更改或拒绝 <code>kube-system</code>
名字空间中的请求可能会导致控制平面组件停止运行或者导致未知行为发生。
如果你的准入 Webhook 不想修改 Kubernetes 控制平面的行为，请使用
<a href=#matching-requests-namespaceselector><code>namespaceSelector</code></a>
避免拦截 <code>kube-system</code> 名字空间。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-bea207258f3576b8ec7444a20d498e1d>6 - 管理服务账号</h1><p><strong>ServiceAccount</strong> 为 Pod 中运行的进程提供了一个身份。</p><p>Pod 内的进程可以使用其关联服务账号的身份，向集群的 API 服务器进行身份认证。</p><p>有关服务账号的介绍，
请参阅<a href=/zh-cn/docs/tasks/configure-pod-container/configure-service-account/>配置服务账号</a>。</p><p>本任务指南阐述有关 ServiceAccount 的几个概念。
本指南还讲解如何获取或撤销代表 ServiceAccount 的令牌。</p><h2 id=准备开始>准备开始</h2><p>你必须拥有一个 Kubernetes 的集群，同时你的 Kubernetes 集群必须带有 kubectl 命令行工具。
建议在至少有两个节点的集群上运行本教程，且这些节点不作为控制平面主机。
如果你还没有集群，你可以通过 <a href=https://minikube.sigs.k8s.io/docs/tutorials/multi_node/>Minikube</a>
构建一个你自己的集群，或者你可以使用下面任意一个 Kubernetes 工具构建：</p><ul><li><a href=https://killercoda.com/playgrounds/scenario/kubernetes>Killercoda</a></li><li><a href=http://labs.play-with-k8s.com/>玩转 Kubernetes</a></li></ul><p>为了能够准确地跟随这些步骤，确保你有一个名为 <code>examplens</code> 的名字空间。
如果你没有，运行以下命令创建一个名字空间：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create namespace examplens
</span></span></code></pre></div><h2 id=user-accounts-versus-service-accounts>用户账号与服务账号</h2><p>Kubernetes 区分用户账号和服务账号的概念，主要基于以下原因：</p><ul><li>用户账号是针对人而言的。而服务账号是针对运行在 Pod 中的应用进程而言的，
在 Kubernetes 中这些进程运行在容器中，而容器是 Pod 的一部分。</li><li>用户账号是全局性的。其名称在某集群中的所有名字空间中必须是唯一的。
无论你查看哪个名字空间，代表用户的特定用户名都代表着同一个用户。
在 Kubernetes 中，服务账号是名字空间作用域的。
两个不同的名字空间可以包含具有相同名称的 ServiceAccount。</li></ul><ul><li>通常情况下，集群的用户账号可能会从企业数据库进行同步，创建新用户需要特殊权限，并且涉及到复杂的业务流程。
服务账号创建有意做得更轻量，允许集群用户为了具体的任务按需创建服务账号。
将 ServiceAccount 的创建与新用户注册的步骤分离开来，使工作负载更易于遵从权限最小化原则。</li></ul><ul><li>对人员和服务账号审计所考虑的因素可能不同；这种分离更容易区分不同之处。</li><li>针对复杂系统的配置包可能包含系统组件相关的各种服务账号的定义。
因为服务账号的创建约束不多并且有名字空间域的名称，所以这种配置通常是轻量的。</li></ul><h2 id=bound-service-account-token-volume>绑定的服务账号令牌卷机制</h2><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.22 [stable]</code></div><p>默认情况下，Kubernetes 控制平面（特别是 <a href=#service-account-admission-controller>ServiceAccount 准入控制器</a>）
添加一个<a href=/zh-cn/docs/concepts/storage/projected-volumes/>投射卷</a>到 Pod，
此卷包括了访问 Kubernetes API 的令牌。</p><p>以下示例演示如何查找已启动的 Pod：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>kube-api-access-&lt;随机后缀&gt;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>projected</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>sources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>serviceAccountToken</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>token<span style=color:#bbb> </span><span style=color:#080;font-style:italic># 必须与应用所预期的路径匹配</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>configMap</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>ca.crt<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>ca.crt<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>kube-root-ca.crt<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>downwardAPI</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span>- <span style=color:green;font-weight:700>fieldRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                  </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                  </span><span style=color:green;font-weight:700>fieldPath</span>:<span style=color:#bbb> </span>metadata.namespace<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>namespace<span style=color:#bbb>
</span></span></span></code></pre></div><p>该清单片段定义了由三个数据源组成的投射卷。在当前场景中，每个数据源也代表该卷内的一条独立路径。这三个数据源是：</p><ol><li><code>serviceAccountToken</code> 数据源，包含 kubelet 从 kube-apiserver 获取的令牌。
kubelet 使用 TokenRequest API 获取有时间限制的令牌。为 TokenRequest 服务的这个令牌会在
Pod 被删除或定义的生命周期（默认为 1 小时）结束之后过期。该令牌绑定到特定的 Pod，
并将其 audience（受众）设置为与 <code>kube-apiserver</code> 的 audience 相匹配。
这种机制取代了之前基于 Secret 添加卷的机制，之前 Secret 代表了针对 Pod 的 ServiceAccount 但不会过期。</li><li><code>configMap</code> 数据源。ConfigMap 包含一组证书颁发机构数据。
Pod 可以使用这些证书来确保自己连接到集群的 kube-apiserver（而不是连接到中间件或意外配置错误的对等点上）。</li><li><code>downwardAPI</code> 数据源，用于查找包含 Pod 的名字空间的名称，
并使该名称信息可用于在 Pod 内运行的应用程序代码。</li></ol><p>Pod 内挂载这个特定卷的所有容器都可以访问上述信息。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>没有特定的机制可以使通过 TokenRequest 签发的令牌无效。如果你不再信任为某个 Pod 绑定的服务账号令牌，
你可以删除该 Pod。删除 Pod 将使其绑定的服务账号令牌过期。</div><h2 id=manual-secret-management-for-serviceaccounts>手动管理 ServiceAccount 的 Secret</h2><p>v1.22 之前的 Kubernetes 版本会自动创建凭据访问 Kubernetes API。
这种更老的机制基于先创建令牌 Secret，然后将其挂载到正运行的 Pod 中。</p><p>在包括 Kubernetes v1.25 在内最近的几个版本中，使用
<a href=/zh-cn/docs/reference/kubernetes-api/authentication-resources/token-request-v1/>TokenRequest</a> API
<a href=#bound-service-account-token-volume>直接获得</a> API 凭据，并使用投射卷挂载到 Pod 中。
使用这种方法获得的令牌具有绑定的生命周期，当挂载的 Pod 被删除时这些令牌将自动失效。</p><p>你仍然可以<a href=/zh-cn/docs/tasks/configure-pod-container/configure-service-account/#manually-create-an-api-token-for-a-serviceaccount>手动创建</a>
Secret 来保存服务账号令牌；例如在你需要一个永不过期的令牌的时候。</p><p>一旦你手动创建一个 Secret 并将其关联到 ServiceAccount，Kubernetes 控制平面就会自动将令牌填充到该 Secret 中。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>尽管存在手动创建长久 ServiceAccount 令牌的机制，但还是推荐使用
<a href=/zh-cn/docs/reference/kubernetes-api/authentication-resources/token-request-v1/>TokenRequest</a>
获得短期的 API 访问令牌。</div><h2 id=control-plane-details>控制平面细节</h2><h3 id=token-controller>令牌控制器</h3><p>服务账号令牌控制器作为 <code>kube-controller-manager</code> 的一部分运行，以异步的形式工作。
其职责包括：</p><ul><li>监测 ServiceAccount 的删除并删除所有相应的服务账号令牌 Secret。</li><li>监测服务账号令牌 Secret 的添加，保证相应的 ServiceAccount 存在，如有需要，
向 Secret 中添加令牌。</li><li>监测服务账号令牌 Secret 的删除，如有需要，从相应的 ServiceAccount 中移除引用。</li></ul><p>你必须通过 <code>--service-account-private-key-file</code> 标志为 <code>kube-controller-manager</code>
的令牌控制器传入一个服务账号私钥文件。该私钥用于为所生成的服务账号令牌签名。
同样地，你需要通过 <code>--service-account-key-file</code> 标志将对应的公钥通知给
kube-apiserver。公钥用于在身份认证过程中校验令牌。</p><h3 id=serviceaccount-admission-controller>ServiceAccount 准入控制器</h3><p>对 Pod 的改动通过一个被称为<a href=/zh-cn/docs/reference/access-authn-authz/admission-controllers/>准入控制器</a>的插件来实现。
它是 API 服务器的一部分。当 Pod 被创建时，该准入控制器会同步地修改 Pod。
如果该插件处于激活状态（在大多数发行版中都是默认激活的），当 Pod 被创建时它会进行以下操作：</p><ol><li>如果该 Pod 没有设置 <code>.spec.serviceAccountName</code>，
准入控制器为新来的 Pod 将 ServiceAccount 的名称设为 <code>default</code>。</li><li>准入控制器保证新来的 Pod 所引用的 ServiceAccount 确实存在。
如果没有 ServiceAccount 具有匹配的名称，则准入控制器拒绝新来的 Pod。
这个检查甚至适用于 <code>default</code> ServiceAccount。</li></ol><ol start=3><li>如果服务账号的 <code>automountServiceAccountToken</code> 字段或 Pod 的
<code>automountServiceAccountToken</code> 字段都未显式设置为 <code>false</code>：<ul><li>准入控制器变更新来的 Pod，添加一个包含 API
访问令牌的额外<a class=glossary-tooltip title='包含可被 Pod 中容器访问的数据的目录。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/storage/volumes/ target=_blank aria-label=卷>卷</a>。</li><li>准入控制器将 <code>volumeMount</code> 添加到 Pod 中的每个容器，
忽略已为 <code>/var/run/secrets/kubernetes.io/serviceaccount</code> 路径定义的卷挂载的所有容器。
对于 Linux 容器，此卷挂载在 <code>/var/run/secrets/kubernetes.io/serviceaccount</code>；
在 Windows 节点上，此卷挂载在等价的路径上。</li></ul></li><li>如果新来 Pod 的规约已包含任何 <code>imagePullSecrets</code>，则准入控制器添加 <code>imagePullSecrets</code>，
并从 <code>ServiceAccount</code> 进行复制。</li></ol><h3 id=tokenrequest-api>TokenRequest API</h3><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.22 [stable]</code></div><p>你使用 ServiceAccount 的
<a href=/zh-cn/docs/reference/kubernetes-api/authentication-resources/token-request-v1/>TokenRequest</a>
子资源为该 ServiceAccount 获取有时间限制的令牌。
你不需要调用它来获取在容器中使用的 API 令牌，因为 kubelet 使用 <strong>投射卷</strong> 对此进行了设置。</p><p>如果你想要从 <code>kubectl</code> 使用 TokenRequest API，
请参阅<a href=/zh-cn/docs/tasks/configure-pod-container/configure-service-account/#manually-create-an-api-token-for-a-serviceaccount>为 ServiceAccount 手动创建 API 令牌</a>。</p><p>Kubernetes 控制平面（特别是 ServiceAccount 准入控制器）向 Pod 添加了一个投射卷，
kubelet 确保该卷包含允许容器作为正确 ServiceAccount 进行身份认证的令牌。</p><p>（这种机制取代了之前基于 Secret 添加卷的机制，之前 Secret 代表了 Pod 所用的 ServiceAccount 但不会过期。）</p><p>以下示例演示如何查找已启动的 Pod：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>kube-api-access-&lt;random-suffix&gt;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>projected</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>defaultMode</span>:<span style=color:#bbb> </span><span style=color:#666>420</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># 这个十进制数等同于八进制 0644</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>sources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>serviceAccountToken</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>expirationSeconds</span>:<span style=color:#bbb> </span><span style=color:#666>3607</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>token<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>configMap</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span>- <span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>ca.crt<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>ca.crt<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>kube-root-ca.crt<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>downwardAPI</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>              </span>- <span style=color:green;font-weight:700>fieldRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                  </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                  </span><span style=color:green;font-weight:700>fieldPath</span>:<span style=color:#bbb> </span>metadata.namespace<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                </span><span style=color:green;font-weight:700>path</span>:<span style=color:#bbb> </span>namespace<span style=color:#bbb>
</span></span></span></code></pre></div><p>该清单片段定义了由三个数据源信息组成的投射卷。</p><ol><li><code>serviceAccountToken</code> 数据源，包含 kubelet 从 kube-apiserver 获取的令牌。
kubelet 使用 TokenRequest API 获取有时间限制的令牌。为 TokenRequest 服务的这个令牌会在
Pod 被删除或定义的生命周期（默认为 1 小时）结束之后过期。该令牌绑定到特定的 Pod，
并将其 audience（受众）设置为与 <code>kube-apiserver</code> 的 audience 相匹配。</li><li><code>configMap</code> 数据源。ConfigMap 包含一组证书颁发机构数据。
Pod 可以使用这些证书来确保自己连接到集群的 kube-apiserver（而不是连接到中间件或意外配置错误的对等点上）。</li><li><code>downwardAPI</code> 数据源。这个 <code>downwardAPI</code> 卷获得包含 Pod 的名字空间的名称，
并使该名称信息可用于在 Pod 内运行的应用程序代码。</li></ol><p>挂载此卷的 Pod 内的所有容器均可以访问上述信息。</p><h2 id=create-token>创建额外的 API 令牌</h2><div class="alert alert-warning caution callout" role=alert><strong>注意：</strong><p>只有<a href=#tokenrequest-api>令牌请求</a>机制不合适，才需要创建长久的 API 令牌。
令牌请求机制提供有时间限制的令牌；因为随着这些令牌过期，它们对信息安全方面的风险也会降低。</div><p>要为 ServiceAccount 创建一个不过期、持久化的 API 令牌，
请创建一个类型为 <code>kubernetes.io/service-account-token</code> 的 Secret，附带引用 ServiceAccount 的注解。
控制平面随后生成一个长久的令牌，并使用生成的令牌数据更新该 Secret。</p><p>以下是此类 Secret 的示例清单：</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/secret/serviceaccount/mysecretname.yaml download=secret/serviceaccount/mysecretname.yaml><code>secret/serviceaccount/mysecretname.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("secret-serviceaccount-mysecretname-yaml")' title="Copy secret/serviceaccount/mysecretname.yaml to clipboard"></img></div><div class=includecode id=secret-serviceaccount-mysecretname-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Secret<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>:<span style=color:#bbb> </span>kubernetes.io/service-account-token<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>mysecretname<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>kubernetes.io/service-account.name</span>:<span style=color:#bbb> </span>myserviceaccount<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>若要基于此示例创建 Secret，运行以下命令：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl -n examplens create -f https://k8s.io/examples/secret/serviceaccount/mysecretname.yaml
</span></span></code></pre></div><p>若要查看该 Secret 的详细信息，运行以下命令：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl -n examplens describe secret mysecretname
</span></span></code></pre></div><p>输出类似于：</p><pre tabindex=0><code>Name:           mysecretname
Namespace:      examplens
Labels:         &lt;none&gt;
Annotations:    kubernetes.io/service-account.name=myserviceaccount
                kubernetes.io/service-account.uid=8a85c4c4-8483-11e9-bc42-526af7764f64

Type:   kubernetes.io/service-account-token

Data
====
ca.crt:         1362 bytes
namespace:      9 bytes
token:          ...
</code></pre><p>如果你在 <code>examplens</code> 名字空间中启动新的 Pod，可以使用你刚刚创建的
<code>myserviceaccount</code> service-account-token Secret。</p><h2 id=delete-token>删除/废止 ServiceAccount 令牌</h2><p>如果你知道 Secret 的名称且该 Secret 包含要移除的令牌：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete secret name-of-secret
</span></span></code></pre></div><p>否则，先找到 ServiceAccount 所用的 Secret。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 此处假设你已有一个名为 &#39;examplens&#39; 的名字空间</span>
</span></span><span style=display:flex><span>kubectl -n examplens get serviceaccount/example-automated-thing -o yaml
</span></span></code></pre></div><p>输出类似于：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ServiceAccount<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubectl.kubernetes.io/last-applied-configuration</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      </span><span style=color:#bbb>      </span>{<span style=color:#b44>&#34;apiVersion&#34;</span>:<span style=color:#b44>&#34;v1&#34;</span>,<span style=color:#b44>&#34;kind&#34;</span>:<span style=color:#b44>&#34;ServiceAccount&#34;</span>,<span style=color:#b44>&#34;metadata&#34;</span>:{<span style=color:#b44>&#34;annotations&#34;</span>:{},<span style=color:#b44>&#34;name&#34;</span>:<span style=color:#b44>&#34;example-automated-thing&#34;</span>,<span style=color:#b44>&#34;namespace&#34;</span>:<span style=color:#b44>&#34;examplens&#34;</span>}}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2019-07-21T07:07:07Z&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example-automated-thing<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>examplens<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;777&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selfLink</span>:<span style=color:#bbb> </span>/api/v1/namespaces/examplens/serviceaccounts/example-automated-thing<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>f23fd170-66f2-4697-b049-e1e266b7f835<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>secrets</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example-automated-thing-token-zyxwv<span style=color:#bbb>
</span></span></span></code></pre></div><p>随后删除你现在知道名称的 Secret：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl -n examplens delete secret/example-automated-thing-token-zyxwv
</span></span></code></pre></div><p>控制平面发现 ServiceAccount 缺少其 Secret，并创建一个替代项：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl -n examplens get serviceaccount/example-automated-thing -o yaml
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ServiceAccount<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubectl.kubernetes.io/last-applied-configuration</span>:<span style=color:#bbb> </span>|<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      </span><span style=color:#bbb>      </span>{<span style=color:#b44>&#34;apiVersion&#34;</span>:<span style=color:#b44>&#34;v1&#34;</span>,<span style=color:#b44>&#34;kind&#34;</span>:<span style=color:#b44>&#34;ServiceAccount&#34;</span>,<span style=color:#b44>&#34;metadata&#34;</span>:{<span style=color:#b44>&#34;annotations&#34;</span>:{},<span style=color:#b44>&#34;name&#34;</span>:<span style=color:#b44>&#34;example-automated-thing&#34;</span>,<span style=color:#b44>&#34;namespace&#34;</span>:<span style=color:#b44>&#34;examplens&#34;</span>}}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2019-07-21T07:07:07Z&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example-automated-thing<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>examplens<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;1026&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selfLink</span>:<span style=color:#bbb> </span>/api/v1/namespaces/examplens/serviceaccounts/example-automated-thing<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>uid</span>:<span style=color:#bbb> </span>f23fd170-66f2-4697-b049-e1e266b7f835<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>secrets</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example-automated-thing-token-4rdrh<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=clean-up>清理</h2><p>如果创建了一个 <code>examplens</code> 名字空间进行试验，你可以移除它：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete namespace examplens
</span></span></code></pre></div><h2 id=control-plane-details>控制平面细节</h2><h3 id=serviceaccount-controller>ServiceAccount 控制器</h3><p>ServiceAccount 控制器管理名字空间内的 ServiceAccount，并确保每个活跃的名字空间中都存在名为
“default” 的 ServiceAccount。</p><h3 id=令牌控制器>令牌控制器</h3><p>服务账号令牌控制器作为 <code>kube-controller-manager</code> 的一部分运行，以异步的形式工作。
其职责包括：</p><ul><li>监测 ServiceAccount 的创建并创建相应的服务账号令牌 Secret 以允许 API 访问。</li><li>监测 ServiceAccount 的删除并删除所有相应的服务账号令牌 Secret。</li><li>监测服务账号令牌 Secret 的添加，保证相应的 ServiceAccount 存在，如有需要，
向 Secret 中添加令牌。</li><li>监测 Secret 的删除，如有需要，从相应的 ServiceAccount 中移除引用。</li></ul><p>你必须通过 <code>--service-account-private-key-file</code> 标志为 <code>kube-controller-manager</code>
的令牌控制器传入一个服务账号私钥文件。该私钥用于为所生成的服务账号令牌签名。
同样地，你需要通过 <code>--service-account-key-file</code> 标志将对应的公钥通知给
kube-apiserver。公钥用于在身份认证过程中校验令牌。</p><h2 id=接下来>接下来</h2><ul><li>查阅有关<a href=/zh-cn/docs/concepts/storage/projected-volumes/>投射卷</a>的更多细节。</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-342be69d36f174f762c36f4fe11fcb20>7 - 鉴权概述</h1><p>了解有关 Kubernetes 鉴权的更多信息，包括使用支持的鉴权模块创建策略的详细信息。</p><p>在 Kubernetes 中，你必须在鉴权（授予访问权限）之前进行身份验证（登录），有关身份验证的信息，
请参阅<a href=/zh-cn/docs/concepts/security/controlling-access/>访问控制概述</a>.</p><p>Kubernetes 期望请求中存在 REST API 常见的属性。
这意味着 Kubernetes 鉴权适用于现有的组织范围或云提供商范围的访问控制系统，
除了 Kubernetes API 之外，它还可以处理其他 API。</p><h2 id=determine-whether-a-request-is-allowed-or-denied>确定是允许还是拒绝请求</h2><p>Kubernetes 使用 API 服务器对 API 请求进行鉴权。
它根据所有策略评估所有请求属性来决定允许或拒绝请求。
一个 API 请求的所有部分都必须被某些策略允许才能继续。
这意味着默认情况下拒绝权限。</p><p>（尽管 Kubernetes 使用 API 服务器，但是依赖于特定对象种类的特定字段的访问控制
和策略由准入控制器处理。）</p><p>当系统配置了多个鉴权模块时，Kubernetes 将按顺序使用每个模块。
如果任何鉴权模块批准或拒绝请求，则立即返回该决定，并且不会与其他鉴权模块协商。
如果所有模块对请求没有意见，则拒绝该请求。
被拒绝响应返回 HTTP 状态代码 403。</p><h2 id=审查你的请求属性>审查你的请求属性</h2><p>Kubernetes 仅审查以下 API 请求属性：</p><ul><li><strong>用户</strong> —— 身份验证期间提供的 <code>user</code> 字符串。</li><li><strong>组</strong> —— 经过身份验证的用户所属的组名列表。</li><li><strong>额外信息</strong> —— 由身份验证层提供的任意字符串键到字符串值的映射。</li><li><strong>API</strong> —— 指示请求是否针对 API 资源。</li><li><strong>请求路径</strong> —— 各种非资源端点的路径，如 <code>/api</code> 或 <code>/healthz</code>。</li><li><strong>API 请求动词</strong> —— API 动词 <code>get</code>、<code>list</code>、<code>create</code>、<code>update</code>、<code>patch</code>、<code>watch</code>、
<code>proxy</code>、<code>redirect</code>、<code>delete</code> 和 <code>deletecollection</code> 用于资源请求。
要确定资源 API 端点的请求动词，请参阅<a href=#determine-the-request-verb>确定请求动词</a>。</li><li><strong>HTTP 请求动词</strong> —— HTTP 动词 <code>get</code>、<code>post</code>、<code>put</code> 和 <code>delete</code> 用于非资源请求。</li><li><strong>资源</strong> —— 正在访问的资源的 ID 或名称（仅限资源请求）-
对于使用 <code>get</code>、<code>update</code>、<code>patch</code> 和 <code>delete</code> 动词的资源请求，你必须提供资源名称。</li><li><strong>子资源</strong> —— 正在访问的子资源（仅限资源请求）。</li><li><strong>名字空间</strong> —— 正在访问的对象的名称空间（仅适用于名字空间资源请求）。</li><li><strong>API 组</strong> —— 正在访问的 <a class=glossary-tooltip title='Kubernetes API 中的一组相关路径。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/overview/kubernetes-api/#api-groups-and-versioning target=_blank aria-label='API 组'>API 组</a>
（仅限资源请求）。空字符串表示<a href=/zh-cn/docs/reference/using-api/#api-groups>核心 API 组</a>。</li></ul><h2 id=determine-the-request-verb>确定请求动词</h2><p><strong>非资源请求</strong></p><p>对于 <code>/api/v1/...</code> 或 <code>/apis/&lt;group>/&lt;version>/...</code>
之外的端点的请求被视为 “非资源请求（Non-Resource Requests）”，
并使用该请求的 HTTP 方法的小写形式作为其请求动词。</p><p>例如，对 <code>/api</code> 或 <code>/healthz</code> 这类端点的 <code>GET</code> 请求将使用 <code>get</code> 作为其动词。</p><p><strong>资源请求</strong></p><p>要确定对资源 API 端点的请求动词，需要查看所使用的 HTTP 动词以及该请求是针对单个资源还是一组资源：</p><table><thead><tr><th>HTTP 动词</th><th>请求动词</th></tr></thead><tbody><tr><td>POST</td><td>create</td></tr><tr><td>GET, HEAD</td><td>get （针对单个资源）、list（针对集合）</td></tr><tr><td>PUT</td><td>update</td></tr><tr><td>PATCH</td><td>patch</td></tr><tr><td>DELETE</td><td>delete（针对单个资源）、deletecollection（针对集合）</td></tr></tbody></table><div class="alert alert-warning caution callout" role=alert><strong>注意：</strong><p><code>get</code>、<code>list</code> 和 <code>watch</code> 动作都可以返回一个资源的完整详细信息。就返回的数据而言，它们是等价的。
例如，对 <code>secrets</code> 使用 <code>list</code> 仍然会显示所有已返回资源的 <code>data</code> 属性。</div><p>Kubernetes 有时使用专门的动词以对额外的权限进行鉴权。例如：</p><ul><li><a href=/zh-cn/docs/reference/access-authn-authz/rbac/#privilege-escalation-prevention-and-bootstrapping>RBAC</a><ul><li>对 <code>rbac.authorization.k8s.io</code> API 组中 <code>roles</code> 和 <code>clusterroles</code> 资源的 <code>bind</code>
和 <code>escalate</code> 动词</li></ul></li><li><a href=/zh-cn/docs/reference/access-authn-authz/authentication/>身份认证</a><ul><li>对核心 API 组中 <code>users</code>、<code>groups</code> 和 <code>serviceaccounts</code> 以及 <code>authentication.k8s.io</code>
API 组中的 <code>userextras</code> 所使用的 <code>impersonate</code> 动词。</li></ul></li></ul><h2 id=authorization-modules>鉴权模块</h2><ul><li><strong>Node</strong> —— 一个专用鉴权模式，根据调度到 kubelet 上运行的 Pod 为 kubelet 授予权限。
要了解有关使用节点鉴权模式的更多信息，请参阅<a href=/zh-cn/docs/reference/access-authn-authz/node/>节点鉴权</a>。</li><li><strong>ABAC</strong> —— 基于属性的访问控制（ABAC）定义了一种访问控制范型，通过使用将属性组合在一起的策略，
将访问权限授予用户。策略可以使用任何类型的属性（用户属性、资源属性、对象，环境属性等）。
要了解有关使用 ABAC 模式的更多信息，请参阅
<a href=/zh-cn/docs/reference/access-authn-authz/abac/>ABAC 模式</a>。</li><li><strong>RBAC</strong> —— 基于角色的访问控制（RBAC）
是一种基于企业内个人用户的角色来管理对计算机或网络资源的访问的方法。
在此上下文中，权限是单个用户执行特定任务的能力，
例如查看、创建或修改文件。要了解有关使用 RBAC 模式的更多信息，请参阅
<a href=/zh-cn/docs/reference/access-authn-authz/rbac/>RBAC 模式</a>。<ul><li>被启用之后，RBAC（基于角色的访问控制）使用 <code>rbac.authorization.k8s.io</code> API
组来驱动鉴权决策，从而允许管理员通过 Kubernetes API 动态配置权限策略。</li><li>要启用 RBAC，请使用 <code>--authorization-mode = RBAC</code> 启动 API 服务器。</li></ul></li><li><strong>Webhook</strong> —— WebHook 是一个 HTTP 回调：发生某些事情时调用的 HTTP POST；
通过 HTTP POST 进行简单的事件通知。
实现 WebHook 的 Web 应用程序会在发生某些事情时将消息发布到 URL。
要了解有关使用 Webhook 模式的更多信息，请参阅
<a href=/zh-cn/docs/reference/access-authn-authz/webhook/>Webhook 模式</a>。</li></ul><h4 id=checking-api-access>检查 API 访问</h4><p><code>kubectl</code> 提供 <code>auth can-i</code> 子命令，用于快速查询 API 鉴权。
该命令使用 <code>SelfSubjectAccessReview</code> API 来确定当前用户是否可以执行给定操作，
无论使用何种鉴权模式该命令都可以工作。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl auth can-i create deployments --namespace dev
</span></span></code></pre></div><p>输出类似于：</p><pre tabindex=0><code>yes
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl auth can-i create deployments --namespace prod
</span></span></code></pre></div><p>输出类似于：</p><pre tabindex=0><code>no
</code></pre><p>管理员可以将此与<a href=/zh-cn/docs/reference/access-authn-authz/authentication/#user-impersonation>用户扮演（User Impersonation）</a>
结合使用，以确定其他用户可以执行的操作。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl auth can-i list secrets --namespace dev --as dave
</span></span></code></pre></div><p>输出类似于：</p><pre tabindex=0><code>no
</code></pre><p>类似地，检查名字空间 <code>dev</code> 里的 <code>dev-sa</code> 服务账户是否可以列举名字空间 <code>target</code> 里的 Pod：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl auth can-i list pods <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>	--namespace target <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>	--as system:serviceaccount:dev:dev-sa
</span></span></code></pre></div><p>输出类似于：</p><pre tabindex=0><code>yes
</code></pre><p><code>SelfSubjectAccessReview</code> 是 <code>authorization.k8s.io</code> API 组的一部分，它将 API
服务器鉴权公开给外部服务。该组中的其他资源包括：</p><ul><li><code>SubjectAccessReview</code> - 对任意用户的访问进行评估，而不仅仅是当前用户。
当鉴权决策被委派给 API 服务器时很有用。例如，kubelet 和扩展 API
服务器使用它来确定用户对自己的 API 的访问权限。</li><li><code>LocalSubjectAccessReview</code> - 与 <code>SubjectAccessReview</code> 类似，但仅限于特定的名字空间。</li><li><code>SelfSubjectRulesReview</code> - 返回用户可在名字空间内执行的操作集的审阅。
用户可以快速汇总自己的访问权限，或者用于 UI 中的隐藏/显示动作。</li></ul><p>可以通过创建普通的 Kubernetes 资源来查询这些 API，其中返回对象的响应 "status"
字段是查询的结果。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl create -f - -o yaml <span style=color:#b44>&lt;&lt; EOF
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: authorization.k8s.io/v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: SelfSubjectAccessReview
</span></span></span><span style=display:flex><span><span style=color:#b44>spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>  resourceAttributes:
</span></span></span><span style=display:flex><span><span style=color:#b44>    group: apps
</span></span></span><span style=display:flex><span><span style=color:#b44>    name: deployments
</span></span></span><span style=display:flex><span><span style=color:#b44>    verb: create
</span></span></span><span style=display:flex><span><span style=color:#b44>    namespace: dev
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><p>生成的 <code>SelfSubjectAccessReview</code> 为：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>authorization.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>SelfSubjectAccessReview<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>null</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceAttributes</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>group</span>:<span style=color:#bbb> </span>apps<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>deployments<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>dev<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>verb</span>:<span style=color:#bbb> </span>create<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>status</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>allowed</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>denied</span>:<span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>false</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=using-flags-for-your-authorization-module>为你的鉴权模块设置参数</h2><p>你必须在策略中包含一个参数标志，以指明你的策略包含哪个鉴权模块：</p><p>可以使用的参数有：</p><ul><li><code>--authorization-mode=ABAC</code> 基于属性的访问控制（ABAC）模式允许你使用本地文件配置策略。</li><li><code>--authorization-mode=RBAC</code> 基于角色的访问控制（RBAC）模式允许你使用
Kubernetes API 创建和存储策略。</li><li><code>--authorization-mode=Webhook</code> WebHook 是一种 HTTP 回调模式，允许你使用远程
REST 端点管理鉴权。</li><li><code>--authorization-mode=Node</code> 节点鉴权是一种特殊用途的鉴权模式，专门对
kubelet 发出的 API 请求执行鉴权。</li><li><code>--authorization-mode=AlwaysDeny</code> 该标志阻止所有请求。仅将此标志用于测试。</li><li><code>--authorization-mode=AlwaysAllow</code> 此标志允许所有请求。仅在你不需要 API 请求的鉴权时才使用此标志。</li></ul><p>你可以选择多个鉴权模块。模块按顺序检查，以便较靠前的模块具有更高的优先级来允许或拒绝请求。</p><h2 id=privilege-escalation-via-pod-creation>通过创建或编辑工作负载提升权限</h2><p>能够在名字空间中创建或者编辑 Pod 的用户，
无论是直接操作还是通过<a href=/zh-cn/docs/concepts/architecture/controller/>控制器</a>
（例如，一个 Operator）来操作，都可以提升他们在该名字空间内的权限。</p><div class="alert alert-warning caution callout" role=alert><strong>注意：</strong><p>系统管理员在授予对工作负载的创建或编辑的权限时要小心。
关于这些权限如何被误用的详细信息请参阅
<a href=#escalation-paths>提升途径</a></div><h3 id=escalation-paths>特权提升途径</h3><ul><li>挂载该名字空间内的任意 Secret<ul><li>可以用来访问其他工作负载专用的 Secret</li><li>可以用来获取权限更高的服务账号的令牌</li></ul></li><li>使用该名字空间内的任意服务账号<ul><li>可以用另一个工作负载的身份来访问 Kubernetes API（伪装）</li><li>可以执行该服务账号的任意特权操作</li></ul></li><li>挂载该名字空间里其他工作负载专用的 ConfigMap<ul><li>可以用来获取其他工作负载专用的信息，例如数据库主机名。</li></ul></li><li>挂载该名字空间里其他工作负载的卷<ul><li>可以用来获取其他工作负载专用的信息，并且更改它。</li></ul></li></ul><div class="alert alert-warning caution callout" role=alert><strong>注意：</strong><p>系统管理员在部署改变以上部分的 CRD 的时候要小心。
它们可能会打开权限提升的途径。
在决定你的 RBAC 控制时应该考虑这方面的问题。</div><h2 id=接下来>接下来</h2><ul><li>要了解有关身份验证的更多信息，
请参阅<a href=/zh-cn/docs/concepts/security/controlling-access/>控制对 Kubernetes API 的访问</a>中的
<strong>身份验证</strong> 部分。</li><li>要了解有关准入控制的更多信息，请参阅<a href=/zh-cn/docs/reference/access-authn-authz/admission-controllers/>使用准入控制器</a>。</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-954776b47f2d90515f375623a0ce98e1>8 - 使用 RBAC 鉴权</h1><p>基于角色（Role）的访问控制（RBAC）是一种基于组织中用户的角色来调节控制对计算机或网络资源的访问的方法。</p><p>RBAC 鉴权机制使用 <code>rbac.authorization.k8s.io</code>
<a class=glossary-tooltip title='Kubernetes API 中的一组相关路径。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/overview/kubernetes-api/#api-groups-and-versioning target=_blank aria-label='API 组'>API 组</a>来驱动鉴权决定，
允许你通过 Kubernetes API 动态配置策略。</p><p>要启用 RBAC，在启动 <a class=glossary-tooltip title='提供 Kubernetes API 服务的控制面组件。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label='API 服务器'>API 服务器</a>时将
<code>--authorization-mode</code> 参数设置为一个逗号分隔的列表并确保其中包含 <code>RBAC</code>。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kube-apiserver --authorization-mode<span style=color:#666>=</span>Example,RBAC --&lt;其他选项&gt; --&lt;其他选项&gt;
</span></span></code></pre></div><h2 id=api-overview>API 对象</h2><p>RBAC API 声明了四种 Kubernetes 对象：<strong>Role</strong>、<strong>ClusterRole</strong>、<strong>RoleBinding</strong> 和
<strong>ClusterRoleBinding</strong>。你可以像使用其他 Kubernetes 对象一样，通过类似 <code>kubectl</code>
这类工具<a href=/zh-cn/docs/concepts/overview/working-with-objects/kubernetes-objects/#understanding-kubernetes-objects>描述对象</a>,
或修补对象。</p><div class="alert alert-warning caution callout" role=alert><strong>注意：</strong><p>这些对象在设计时即实施了一些访问限制。如果你在学习过程中对集群做了更改，
请参考<a href=#privilege-escalation-prevention-and-bootstrapping>避免特权提升和引导</a>一节，
以了解这些限制会以怎样的方式阻止你做出修改。</div><h3 id=role-and-clusterole>Role 和 ClusterRole</h3><p>RBAC 的 <strong>Role</strong> 或 <strong>ClusterRole</strong> 中包含一组代表相关权限的规则。
这些权限是纯粹累加的（不存在拒绝某操作的规则）。</p><p>Role 总是用来在某个<a class=glossary-tooltip title='名字空间是 Kubernetes 用来支持隔离单个集群中的资源组的一种抽象。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/overview/working-with-objects/namespaces/ target=_blank aria-label=名字空间>名字空间</a>内设置访问权限；
在你创建 Role 时，你必须指定该 Role 所属的名字空间。</p><p>与之相对，ClusterRole 则是一个集群作用域的资源。这两种资源的名字不同（Role 和 ClusterRole）
是因为 Kubernetes 对象要么是名字空间作用域的，要么是集群作用域的，不可两者兼具。</p><p>ClusterRole 有若干用法。你可以用它来：</p><ol><li>定义对某名字空间域对象的访问权限，并将在个别名字空间内被授予访问权限；</li><li>为名字空间作用域的对象设置访问权限，并被授予跨所有名字空间的访问权限；</li><li>为集群作用域的资源定义访问权限。</li></ol><p>如果你希望在名字空间内定义角色，应该使用 Role；
如果你希望定义集群范围的角色，应该使用 ClusterRole。</p><h4 id=role-example>Role 示例</h4><p>下面是一个位于 "default" 名字空间的 Role 的示例，可用来授予对
<a class=glossary-tooltip title='Pod 表示你的集群上一组正在运行的容器。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/workloads/pods/ target=_blank aria-label=Pod>Pod</a> 的读访问权限：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Role<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pod-reader<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb> </span><span style=color:#080;font-style:italic># &#34;&#34; 标明 core API 组</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;pods&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;get&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;watch&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;list&#34;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=clusterrole-example>ClusterRole 示例</h3><p>ClusterRole 同样可以用于授予 Role 能够授予的权限。
因为 ClusterRole 属于集群范围，所以它也可以为以下资源授予访问权限：</p><ul><li><p>集群范围资源（比如<a class=glossary-tooltip title='Kubernetes 中的工作机器称作节点。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/architecture/nodes/ target=_blank aria-label=节点（Node）>节点（Node）</a>）</p></li><li><p>非资源端点（比如 <code>/healthz</code>）</p></li><li><p>跨名字空间访问的名字空间作用域的资源（如 Pod）</p><p>比如，你可以使用 ClusterRole 来允许某特定用户执行 <code>kubectl get pods --all-namespaces</code></p></li></ul><p>下面是一个 ClusterRole 的示例，可用来为任一特定名字空间中的
<a class=glossary-tooltip title='Secret 用于存储敏感信息，如密码、 OAuth 令牌和 SSH 密钥。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/configuration/secret/ target=_blank aria-label=Secret>Secret</a> 授予读访问权限，
或者跨名字空间的访问权限（取决于该角色是如何<a href=#rolebinding-and-clusterrolebinding>绑定</a>的）：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># &#34;namespace&#34; 被忽略，因为 ClusterRoles 不受名字空间限制</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-reader<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 在 HTTP 层面，用来访问 Secret 资源的名称为 &#34;secrets&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;secrets&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;get&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;watch&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;list&#34;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div><p>Role 或 ClusterRole 对象的名称必须是合法的<a href=/zh-cn/docs/concepts/overview/working-with-objects/names#path-segment-names>路径分段名称</a>。</p><h3 id=rolebinding-and-clusterrolebinding>RoleBinding 和 ClusterRoleBinding</h3><p>角色绑定（Role Binding）是将角色中定义的权限赋予一个或者一组用户。
它包含若干 <strong>主体</strong>（用户、组或服务账户）的列表和对这些主体所获得的角色的引用。
RoleBinding 在指定的名字空间中执行授权，而 ClusterRoleBinding 在集群范围执行授权。</p><p>一个 RoleBinding 可以引用同一的名字空间中的任何 Role。
或者，一个 RoleBinding 可以引用某 ClusterRole 并将该 ClusterRole 绑定到
RoleBinding 所在的名字空间。
如果你希望将某 ClusterRole 绑定到集群中所有名字空间，你要使用 ClusterRoleBinding。</p><p>RoleBinding 或 ClusterRoleBinding 对象的名称必须是合法的
<a href=/zh-cn/docs/concepts/overview/working-with-objects/names#path-segment-names>路径分段名称</a>。</p><h4 id=rolebinding-example>RoleBinding 示例</h4><p>下面的例子中的 RoleBinding 将 "pod-reader" Role 授予在 "default" 名字空间中的用户 "jane"。
这样，用户 "jane" 就具有了读取 "default" 名字空间中所有 Pod 的权限。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 此角色绑定允许 &#34;jane&#34; 读取 &#34;default&#34; 名字空间中的 Pod</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 你需要在该命名空间中有一个名为 “pod-reader” 的 Role</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>RoleBinding<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>read-pods<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 你可以指定不止一个“subject（主体）”</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>User<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>jane<span style=color:#bbb> </span><span style=color:#080;font-style:italic># &#34;name&#34; 是区分大小写的</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>roleRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># &#34;roleRef&#34; 指定与某 Role 或 ClusterRole 的绑定关系</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Role       <span style=color:#bbb> </span><span style=color:#080;font-style:italic># 此字段必须是 Role 或 ClusterRole</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pod-reader <span style=color:#bbb> </span><span style=color:#080;font-style:italic># 此字段必须与你要绑定的 Role 或 ClusterRole 的名称匹配</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></span></span></code></pre></div><p>RoleBinding 也可以引用 ClusterRole，以将对应 ClusterRole 中定义的访问权限授予
RoleBinding 所在名字空间的资源。这种引用使得你可以跨整个集群定义一组通用的角色，
之后在多个名字空间中复用。</p><p>例如，尽管下面的 RoleBinding 引用的是一个 ClusterRole，"dave"（这里的主体，
区分大小写）只能访问 "development" 名字空间中的 Secrets 对象，因为 RoleBinding
所在的名字空间（由其 metadata 决定）是 "development"。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 此角色绑定使得用户 &#34;dave&#34; 能够读取 &#34;development&#34; 名字空间中的 Secrets</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 你需要一个名为 &#34;secret-reader&#34; 的 ClusterRole</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>RoleBinding<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>read-secrets<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># RoleBinding 的名字空间决定了访问权限的授予范围。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 这里隐含授权仅在 &#34;development&#34; 名字空间内的访问权限。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>development<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>User<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>dave<span style=color:#bbb> </span><span style=color:#080;font-style:italic># &#39;name&#39; 是区分大小写的</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>roleRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-reader<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></span></span></code></pre></div><h4 id=clusterrolebinding-example>ClusterRoleBinding 示例</h4><p>要跨整个集群完成访问权限的授予，你可以使用一个 ClusterRoleBinding。
下面的 ClusterRoleBinding 允许 "manager" 组内的所有用户访问任何名字空间中的 Secret。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 此集群角色绑定允许 “manager” 组中的任何人访问任何名字空间中的 Secret 资源</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRoleBinding<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>read-secrets-global<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Group<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>manager     <span style=color:#bbb> </span><span style=color:#080;font-style:italic># &#39;name&#39; 是区分大小写的</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>roleRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>secret-reader<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></span></span></code></pre></div><p>创建了绑定之后，你不能再修改绑定对象所引用的 Role 或 ClusterRole。
试图改变绑定对象的 <code>roleRef</code> 将导致合法性检查错误。
如果你想要改变现有绑定对象中 <code>roleRef</code> 字段的内容，必须删除重新创建绑定对象。</p><p>这种限制有两个主要原因：</p><ol><li>将 <code>roleRef</code> 设置为不可以改变，这使得可以为用户授予对现有绑定对象的 <code>update</code> 权限，
这样可以让他们管理主体列表，同时不能更改被授予这些主体的角色。</li></ol><ol start=2><li>针对不同角色的绑定是完全不一样的绑定。要求通过删除/重建绑定来更改 <code>roleRef</code>，
这样可以确保要赋予绑定的所有主体会被授予新的角色（而不是在允许或者不小心修改了
<code>roleRef</code> 的情况下导致所有现有主体未经验证即被授予新角色对应的权限）。</li></ol><p>命令 <code>kubectl auth reconcile</code> 可以创建或者更新包含 RBAC 对象的清单文件，
并且在必要的情况下删除和重新创建绑定对象，以改变所引用的角色。
更多相关信息请参照<a href=#kubectl-auth-reconcile>命令用法和示例</a>。</p><h3 id=referring-to-resources>对资源的引用</h3><p>在 Kubernetes API 中，大多数资源都是使用对象名称的字符串表示来呈现与访问的。
例如，对于 Pod 应使用 "pods"。
RBAC 使用对应 API 端点的 URL 中呈现的名字来引用资源。
有一些 Kubernetes API 涉及 <strong>子资源（subresource）</strong>，例如 Pod 的日志。
对 Pod 日志的请求看起来像这样：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-http data-lang=http><span style=display:flex><span><span>GET /api/v1/namespaces/{namespace}/pods/{name}/log
</span></span></span></code></pre></div><p>在这里，<code>pods</code> 对应名字空间作用域的 Pod 资源，而 <code>log</code> 是 <code>pods</code> 的子资源。
在 RBAC 角色表达子资源时，使用斜线（<code>/</code>）来分隔资源和子资源。
要允许某主体读取 <code>pods</code> 同时访问这些 Pod 的 <code>log</code> 子资源，你可以这样写：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Role<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>pod-and-pod-logs-reader<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;pods&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;pods/log&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;get&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;list&#34;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div><p>对于某些请求，也可以通过 <code>resourceNames</code> 列表按名称引用资源。
在指定时，可以将请求限定为资源的单个实例。
下面的例子中限制可以 <code>get</code> 和 <code>update</code> 一个名为 <code>my-configmap</code> 的
<a class=glossary-tooltip title='ConfigMap 是一种 API 对象，用来将非机密性的数据保存到键值对中。使用时可以用作环境变量、命令行参数或者存储卷中的配置文件。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/tasks/configure-pod-container/configure-pod-configmap/ target=_blank aria-label=ConfigMap>ConfigMap</a>：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Role<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>configmap-updater<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 在 HTTP 层面，用来访问 ConfigMap 资源的名称为 &#34;configmaps&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;configmaps&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceNames</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;my-configmap&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;update&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;get&#34;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>你不能使用资源名字来限制 <code>create</code> 或者 <code>deletecollection</code> 请求。
对于 <code>create</code> 请求而言，这是因为在鉴权时可能还不知道新对象的名字。
如果你使用 <code>resourceName</code> 来限制 <code>list</code> 或者 <code>watch</code> 请求，
客户端必须在它们的 <code>list</code> 或者 <code>watch</code> 请求里包含一个与指定的 <code>resourceName</code>
匹配的 <code>metadata.name</code> 字段选择器。
例如，<code>kubectl get configmaps --field-selector=metadata.name=my-configmap</code></div><p>使用通配符 <code>*</code> 可以批量引用所有的 <code>resources</code> 和 <code>verbs</code> 对象，无需逐一引用。
对于 <code>nonResourceURLs</code>，可以将通配符 <code>*</code> 作为后缀实现全局通配，
对于 <code>apiGroups</code> 和 <code>resourceNames</code>，空集表示没有任何限制。
下面的示例允许对所有当前和未来资源执行所有动作（注意，这类似于内置的 <code>cluster-admin</code>）。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Role<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>example.com-superuser <span style=color:#bbb> </span><span style=color:#080;font-style:italic># 此角色仅作示范，请勿使用</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;example.com&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;*&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;*&#34;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-warning caution callout" role=alert><strong>注意：</strong><p>在 resources 和 verbs 条目中使用通配符会为敏感资源授予过多的访问权限。
例如，如果添加了新的资源类型、新的子资源或新的自定义动词，
通配符条目会自动授予访问权限，用户可能不希望出现这种情况。
应该执行<a href=zh-cn/docs/concepts/security/rbac-good-practices/#least-privilege>最小特权原则</a>，
使用具体的 resources 和 verbs 确保仅赋予工作负载正常运行所需的权限。</div><h3 id=aggregated-clusterroles>聚合的 ClusterRole</h3><p>你可以将若干 ClusterRole <strong>聚合（Aggregate）</strong> 起来，形成一个复合的 ClusterRole。
作为集群控制面的一部分，控制器会监视带有 <code>aggregationRule</code> 的 ClusterRole 对象集合。<code>aggregationRule</code>
为控制器定义一个标签<a class=glossary-tooltip title=选择算符允许用户通过标签对一组资源对象进行筛选过滤。 data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/overview/working-with-objects/labels/ target=_blank aria-label=选择算符>选择算符</a>供后者匹配应该组合到当前
ClusterRole 的 <code>roles</code> 字段中的 ClusterRole 对象。</p><p>下面是一个聚合 ClusterRole 的示例：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>monitoring<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>aggregationRule</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>clusterRoleSelectors</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>rbac.example.com/aggregate-to-monitoring</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb> </span>[]<span style=color:#bbb> </span><span style=color:#080;font-style:italic># 控制面自动填充这里的规则</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>如果你创建一个与某个已存在的聚合 ClusterRole 的标签选择算符匹配的 ClusterRole，
这一变化会触发新的规则被添加到聚合 ClusterRole 的操作。
下面的例子中，通过创建一个标签同样为 <code>rbac.example.com/aggregate-to-monitoring: true</code>
的 ClusterRole，新的规则可被添加到 "monitoring" ClusterRole 中。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>monitoring-endpoints<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rbac.example.com/aggregate-to-monitoring</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 当你创建 &#34;monitoring-endpoints&#34; ClusterRole 时，</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># 下面的规则会被添加到 &#34;monitoring&#34; ClusterRole 中</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;services&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;endpointslices&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;pods&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;get&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;list&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;watch&#34;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div><p>默认的<a href=#default-roles-and-role-bindings>面向用户的角色</a>使用 ClusterRole 聚合。
这使得作为集群管理员的你可以为扩展默认规则，包括为定制资源设置规则，
比如通过 CustomResourceDefinitions 或聚合 API 服务器提供的定制资源。</p><p>例如，下面的 ClusterRoles 让默认角色 "admin" 和 "edit" 拥有管理自定义资源 "CronTabs" 的权限，
"view" 角色对 CronTab 资源拥有读操作权限。
你可以假定 CronTab 对象在 API 服务器所看到的 URL 中被命名为 <code>"crontabs"</code>。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>aggregate-cron-tabs-edit<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 添加以下权限到默认角色 &#34;admin&#34; 和 &#34;edit&#34; 中</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rbac.authorization.k8s.io/aggregate-to-admin</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rbac.authorization.k8s.io/aggregate-to-edit</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;stable.example.com&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;crontabs&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;get&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;list&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;watch&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;create&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;update&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;patch&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;delete&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>aggregate-cron-tabs-view<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#080;font-style:italic># 添加以下权限到 &#34;view&#34; 默认角色中</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rbac.authorization.k8s.io/aggregate-to-view</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;stable.example.com&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;crontabs&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;get&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;list&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;watch&#34;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div><h4 id=role-examples>Role 示例</h4><p>以下示例均为从 Role 或 ClusterRole 对象中截取出来，我们仅展示其 <code>rules</code> 部分。</p><p>允许读取在核心 <a class=glossary-tooltip title='Kubernetes API 中的一组相关路径。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/overview/kubernetes-api/#api-groups-and-versioning target=_blank aria-label='API 组'>API 组</a>下的 <code>"pods"</code>：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 在 HTTP 层面，用来访问 Pod 资源的名称为 &#34;pods&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;pods&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;get&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;list&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;watch&#34;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div><p>允许在 <code>"apps"</code> API 组中读/写 Deployment（在 HTTP 层面，对应 URL
中资源部分为 <code>"deployments"</code>）：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;apps&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic>#</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 在 HTTP 层面，用来访问 Deployment 资源的名称为 &#34;deployments&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;deployments&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;get&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;list&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;watch&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;create&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;update&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;patch&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;delete&#34;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div><p>允许读取核心 API 组中的 Pod 和读/写 <code>"batch"</code> API 组中的 Job 资源：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 在 HTTP 层面，用来访问 Pod 资源的名称为 &#34;pods&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;pods&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;get&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;list&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;watch&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;batch&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 在 HTTP 层面，用来访问 Job 资源的名称为 &#34;jobs&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;jobs&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;get&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;list&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;watch&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;create&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;update&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;patch&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;delete&#34;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div><p>允许读取名称为 "my-config" 的 ConfigMap（需要通过 RoleBinding
绑定以限制为某名字空间中特定的 ConfigMap）：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 在 HTTP 层面，用来访问 ConfigMap 资源的名称为 &#34;configmaps&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;configmaps&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceNames</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;my-config&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;get&#34;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div><p>允许读取在核心组中的 <code>"nodes"</code> 资源（因为 <code>Node</code> 是集群作用域的，所以需要
ClusterRole 绑定到 ClusterRoleBinding 才生效）：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 在 HTTP 层面，用来访问 Node 资源的名称为 &#34;nodes&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;nodes&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;get&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;list&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;watch&#34;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div><p>允许针对非资源端点 <code>/healthz</code> 和其子路径上发起 GET 和 POST 请求
（必须在 ClusterRole 绑定 ClusterRoleBinding 才生效）：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>nonResourceURLs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;/healthz&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;/healthz/*&#34;</span>]<span style=color:#bbb> </span><span style=color:#080;font-style:italic># nonResourceURL 中的 &#39;*&#39; 是一个全局通配符</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;get&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;post&#34;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=referring-to-subjects>对主体的引用</h3><p>RoleBinding 或者 ClusterRoleBinding 可绑定角色到某 <strong>主体（Subject）</strong> 上。
主体可以是组，用户或者<a class=glossary-tooltip title='为在 Pod 中运行的进程提供标识。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/tasks/configure-pod-container/configure-service-account/ target=_blank aria-label=服务账户>服务账户</a>。</p><p>Kubernetes 用字符串来表示用户名。
用户名可以是普通的用户名，像 "alice"；或者是邮件风格的名称，如 "bob@example.com"，
或者是以字符串形式表达的数字 ID。你作为 Kubernetes
管理员负责配置<a href=/zh-cn/docs/reference/access-authn-authz/authentication/>身份认证模块</a>，
以便后者能够生成你所期望的格式的用户名。</p><div class="alert alert-warning caution callout" role=alert><strong>注意：</strong><p>前缀 <code>system:</code> 是 Kubernetes 系统保留的，所以你要确保所配置的用户名或者组名不能出现上述
<code>system:</code> 前缀。除了对前缀的限制之外，RBAC 鉴权系统不对用户名格式作任何要求。</div><p>在 Kubernetes 中，身份认证（Authenticator）模块提供用户组信息。
与用户名一样，用户组名也用字符串来表示，而且对该字符串没有格式要求，
只是不能使用保留的前缀 <code>system:</code>。</p><p><a href=/zh-cn/docs/tasks/configure-pod-container/configure-service-account/>服务账户（ServiceAccount）</a>
的用户名前缀为 <code>system:serviceaccount:</code>，属于前缀为 <code>system:serviceaccounts:</code> 的用户组。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong><ul><li><code>system:serviceaccount:</code> （单数）是用于服务账户用户名的前缀；</li><li><code>system:serviceaccounts:</code> （复数）是用于服务账户组名的前缀。</li></ul></div><h4 id=role-binding-examples>RoleBinding 示例</h4><p>下面示例是 <code>RoleBinding</code> 中的片段，仅展示其 <code>subjects</code> 的部分。</p><p>对于名称为 <code>alice@example.com</code> 的用户：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>User<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;alice@example.com&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></span></span></code></pre></div><p>对于名称为 <code>frontend-admins</code> 的用户组：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Group<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;frontend-admins&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></span></span></code></pre></div><p>对于 <code>kube-system</code> 名字空间中的默认服务账户：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ServiceAccount<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span></span></span></code></pre></div><p>对于 "qa" 名称空间中的所有服务账户：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Group<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:serviceaccounts:qa<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></span></span></code></pre></div><p>对于在任何名字空间中的服务账户：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Group<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:serviceaccounts<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></span></span></code></pre></div><p>对于所有已经过身份认证的用户：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Group<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:authenticated<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></span></span></code></pre></div><p>对于所有未通过身份认证的用户：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Group<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:unauthenticated<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></span></span></code></pre></div><p>对于所有用户：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Group<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:authenticated<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Group<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:unauthenticated<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=default-roles-and-role-bindings>默认 Roles 和 Role Bindings</h2><p>API 服务器创建一组默认的 ClusterRole 和 ClusterRoleBinding 对象。
这其中许多是以 <code>system:</code> 为前缀的，用以标识对应资源是直接由集群控制面管理的。
所有的默认 ClusterRole 和 ClusterRoleBinding 都有
<code>kubernetes.io/bootstrapping=rbac-defaults</code> 标签。</p><div class="alert alert-warning caution callout" role=alert><strong>注意：</strong><p>在修改名称包含 <code>system:</code> 前缀的 ClusterRole 和 ClusterRoleBinding
时要格外小心。
对这些资源的更改可能导致集群无法正常运作。</div><h3 id=auto-reconciliation>自动协商</h3><p>在每次启动时，API 服务器都会更新默认 ClusterRole 以添加缺失的各种权限，
并更新默认的 ClusterRoleBinding 以增加缺失的各类主体。
这种自动协商机制允许集群去修复一些不小心发生的修改，
并且有助于保证角色和角色绑定在新的发行版本中有权限或主体变更时仍然保持最新。</p><p>如果要禁止此功能，请将默认 ClusterRole 以及 ClusterRoleBinding 的
<code>rbac.authorization.kubernetes.io/autoupdate</code> 注解设置成 <code>false</code>。
注意，缺少默认权限和角色绑定主体可能会导致集群无法正常工作。</p><p>如果基于 RBAC 的鉴权机制被启用，则自动协商功能默认是被启用的。</p><h3 id=discovery-roles>API 发现角色</h3><p>无论是经过身份验证的还是未经过身份验证的用户，
默认的角色绑定都授权他们读取被认为是可安全地公开访问的 API（包括 CustomResourceDefinitions）。
如果要禁用匿名的未经过身份验证的用户访问，请在 API 服务器配置中中添加
<code>--anonymous-auth=false</code> 的配置选项。</p><p>通过运行命令 <code>kubectl</code> 可以查看这些角色的配置信息:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get clusterroles system:discovery -o yaml
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>如果你编辑该 ClusterRole，你所作的变更会被 API 服务器在重启时自动覆盖，
这是通过<a href=#auto-reconciliation>自动协商</a>机制完成的。要避免这类覆盖操作，
要么不要手动编辑这些角色，要么禁止自动协商机制。</div><table><caption>Kubernetes RBAC API 发现角色</caption><col style=width:25%><col style=width:25%><col><thead><tr><th>默认 ClusterRole</th><th>默认 ClusterRoleBinding</th><th>描述</th></tr></thead><tbody><tr><td><b>system:basic-user</b></td><td><b>system:authenticated</b> 组</td><td>允许用户以只读的方式去访问他们自己的基本信息。在 v1.14 版本之前，这个角色在默认情况下也绑定在 <tt>system:unauthenticated</tt> 上。</td></tr><tr><td><b>system:discovery</b></td><td><b>system:authenticated</b> 组</td><td>允许以只读方式访问 API 发现端点，这些端点用来发现和协商 API 级别。
在 v1.14 版本之前，这个角色在默认情况下绑定在 <tt>system:unauthenticated</tt> 上。</td></tr><tr><td><b>system:public-info-viewer</b></td><td><b>system:authenticated</b> 和 <b>system:unauthenticated</b> 组</td><td>允许对集群的非敏感信息进行只读访问，此角色是在 v1.14 版本中引入的。</td></tr></tbody></table><h3 id=user-facing-roles>面向用户的角色</h3><p>一些默认的 ClusterRole 不是以前缀 <code>system:</code> 开头的。这些是面向用户的角色。
它们包括超级用户（Super-User）角色（<code>cluster-admin</code>）、
使用 ClusterRoleBinding 在集群范围内完成授权的角色（<code>cluster-status</code>）、
以及使用 RoleBinding 在特定名字空间中授予的角色（<code>admin</code>、<code>edit</code>、<code>view</code>）。</p><p>面向用户的 ClusterRole 使用 <a href=#aggregated-clusterroles>ClusterRole 聚合</a>以允许管理员在这些
ClusterRole 上添加用于定制资源的规则。如果想要添加规则到 <code>admin</code>、<code>edit</code> 或者 <code>view</code>，
可以创建带有以下一个或多个标签的 ClusterRole：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rbac.authorization.k8s.io/aggregate-to-admin</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rbac.authorization.k8s.io/aggregate-to-edit</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rbac.authorization.k8s.io/aggregate-to-view</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span></code></pre></div><table><col style=width:25%><col style=width:25%><col><thead><tr><th>默认 ClusterRole</th><th>默认 ClusterRoleBinding</th><th>描述</th></tr></thead><tbody><tr><td><b>cluster-admin</b></td><td><b>system:masters</b> 组</td><td>允许超级用户在平台上的任何资源上执行所有操作。
当在 <b>ClusterRoleBinding</b> 中使用时，可以授权对集群中以及所有名字空间中的全部资源进行完全控制。
当在 <b>RoleBinding</b> 中使用时，可以授权控制角色绑定所在名字空间中的所有资源，包括名字空间本身。</td></tr><tr><td><b>admin</b></td><td>无</td><td>允许管理员访问权限，旨在使用 <b>RoleBinding</b> 在名字空间内执行授权。<p>如果在 <b>RoleBinding</b> 中使用，则可授予对名字空间中的大多数资源的读/写权限，
包括创建角色和角色绑定的能力。
此角色不允许对资源配额或者名字空间本身进行写操作。
此角色也不允许对 Kubernetes v1.22+ 创建的 EndpointSlices（或 Endpoints）进行写操作。
更多信息参阅 <a href=#write-access-for-endpoints>“EndpointSlices 和 Endpoints 写权限”小节</a>。</p></td></tr><tr><td><b>edit</b></td><td>无</td><td>允许对名字空间的大多数对象进行读/写操作。<p>此角色不允许查看或者修改角色或者角色绑定。
不过，此角色可以访问 Secret，以名字空间中任何 ServiceAccount 的身份运行 Pod，
所以可以用来了解名字空间内所有服务账户的 API 访问级别。
此角色也不允许对 Kubernetes v1.22+ 创建的 EndpointSlices（或 Endpoints）进行写操作。
更多信息参阅 <a href=#write-access-for-endpoints>“EndpointSlices 和 Endpoints 写操作”小节</a>。</p></td></tr><tr><td><b>view</b></td><td>无</td><td>允许对名字空间的大多数对象有只读权限。
它不允许查看角色或角色绑定。<p>此角色不允许查看 Secrets，因为读取 Secret 的内容意味着可以访问名字空间中
ServiceAccount 的凭据信息，进而允许利用名字空间中任何 ServiceAccount
的身份访问 API（这是一种特权提升）。</p></td></tr></tbody></table><h3 id=core-component-roles>核心组件角色</h3><table><col style=width:25%><col style=width:25%><col><thead><tr><th>默认 ClusterRole</th><th>默认 ClusterRoleBinding</th><th>描述</th></tr></thead><tbody><tr><td><b>system:kube-scheduler</b></td><td><b>system:kube-scheduler</b> 用户</td><td>允许访问 <a class=glossary-tooltip title='控制平面组件，负责监视新创建的、未指定运行节点的 Pod，选择节点让 Pod 在上面运行。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/reference/command-line-tools-reference/kube-scheduler/ target=_blank aria-label=scheduler>scheduler</a>
组件所需要的资源。</td></tr><tr><td><b>system:volume-scheduler</b></td><td><b>system:kube-scheduler</b> 用户</td><td>允许访问 kube-scheduler 组件所需要的卷资源。</td></tr><tr><td><b>system:kube-controller-manager</b></td><td><b>system:kube-controller-manager</b> 用户</td><td>允许访问<a class=glossary-tooltip title=主节点上运行控制器的组件。 data-toggle=tooltip data-placement=top href=/zh-cn/docs/reference/command-line-tools-reference/kube-controller-manager/ target=_blank aria-label=控制器管理器>控制器管理器</a>组件所需要的资源。
各个控制回路所需要的权限在<a href=#controller-roles>控制器角色</a>详述。</td></tr><tr><td><b>system:node</b></td><td>无</td><td>允许访问 kubelet 所需要的资源，<b>包括对所有 Secret 的读操作和对所有 Pod 状态对象的写操作。</b><p>你应该使用 <a href=/zh-cn/docs/reference/access-authn-authz/node/>Node 鉴权组件</a>和
<a href=/zh-cn/docs/reference/access-authn-authz/admission-controllers/#noderestriction>NodeRestriction 准入插件</a>而不是
<tt>system:node</tt> 角色。同时基于 kubelet 上调度执行的 Pod 来授权
kubelet 对 API 的访问。</p><p><tt>system:node</tt> 角色的意义仅是为了与从 v1.8 之前版本升级而来的集群兼容。</p></td></tr><tr><td><b>system:node-proxier</b></td><td><b>system:kube-proxy</b> 用户</td><td>允许访问 <a class=glossary-tooltip title='kube-proxy 是集群中每个节点上运行的网络代理。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/reference/command-line-tools-reference/kube-proxy/ target=_blank aria-label=kube-proxy>kube-proxy</a>
组件所需要的资源。</td></tr></tbody></table><h3 id=other-component-roles>其他组件角色</h3><table><col style=width:25%><col style=width:25%><col><thead><tr><th>默认 ClusterRole</th><th>默认 ClusterRoleBinding</th><th>描述</th></tr></thead><tbody><tr><td><b>system:auth-delegator</b></td><td>无</td><td>允许将身份认证和鉴权检查操作外包出去。
这种角色通常用在插件式 API 服务器上，以实现统一的身份认证和鉴权。</td></tr><tr><td><b>system:heapster</b></td><td>无</td><td>为 <a href=https://github.com/kubernetes/heapster>Heapster</a> 组件（已弃用）定义的角色。</td></tr><tr><td><b>system:kube-aggregator</b></td><td>无</td><td>为 <a href=https://github.com/kubernetes/kube-aggregator>kube-aggregator</a> 组件定义的角色。</td></tr><tr><td><b>system:kube-dns</b></td><td>在 <b>kube-system</b> 名字空间中的 <b>kube-dns</b> 服务账户</td><td>为 <a href=/zh-cn/docs/concepts/services-networking/dns-pod-service/>kube-dns</a> 组件定义的角色。</td></tr><tr><td><b>system:kubelet-api-admin</b></td><td>无</td><td>允许 kubelet API 的完全访问权限。</td></tr><tr><td><b>system:node-bootstrapper</b></td><td>无</td><td>允许访问执行
<a href=/zh-cn/docs/reference/access-authn-authz/kubelet-tls-bootstrapping/>kubelet TLS 启动引导</a>
所需要的资源。</td></tr><tr><td><b>system:node-problem-detector</b></td><td>无</td><td>为 <a href=https://github.com/kubernetes/node-problem-detector>node-problem-detector</a> 组件定义的角色。</td></tr><tr><td><b>system:persistent-volume-provisioner</b></td><td>无</td><td>允许访问大部分<a href=/zh-cn/docs/concepts/storage/persistent-volumes/#dynamic>动态卷驱动</a>所需要的资源。</td></tr><tr><td><b>system:monitoring</b></td><td><b>system:monitoring</b> 组</td><td>允许对控制平面监控端点的读取访问（例如：<a class=glossary-tooltip title='提供 Kubernetes API 服务的控制面组件。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label=kube-apiserver>kube-apiserver</a>
存活和就绪端点（<tt>/healthz</tt>、<tt>/livez</tt>、<tt>/readyz</tt>），
各个健康检查端点（<tt>/healthz/*</tt>、<tt>/livez/*</tt>、<tt>/readyz/*</tt>）和 <tt>/metrics</tt>）。
请注意，各个运行状况检查端点和度量标准端点可能会公开敏感信息。</td></tr></tbody></table><h3 id=controller-roles>内置控制器的角色</h3><p>Kubernetes <a class=glossary-tooltip title=主节点上运行控制器的组件。 data-toggle=tooltip data-placement=top href=/zh-cn/docs/reference/command-line-tools-reference/kube-controller-manager/ target=_blank aria-label=控制器管理器>控制器管理器</a>运行内建于
Kubernetes 控制面的<a class=glossary-tooltip title='控制器通过 API 服务器监控集群的公共状态，并致力于将当前状态转变为期望的状态。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/architecture/controller/ target=_blank aria-label=控制器>控制器</a>。
当使用 <code>--use-service-account-credentials</code> 参数启动时，kube-controller-manager
使用单独的服务账户来启动每个控制器。
每个内置控制器都有相应的、前缀为 <code>system:controller:</code> 的角色。
如果控制管理器启动时未设置 <code>--use-service-account-credentials</code>，
它使用自己的身份凭据来运行所有的控制器，该身份必须被授予所有相关的角色。
这些角色包括：</p><ul><li><code>system:controller:attachdetach-controller</code></li><li><code>system:controller:certificate-controller</code></li><li><code>system:controller:clusterrole-aggregation-controller</code></li><li><code>system:controller:cronjob-controller</code></li><li><code>system:controller:daemon-set-controller</code></li><li><code>system:controller:deployment-controller</code></li><li><code>system:controller:disruption-controller</code></li><li><code>system:controller:endpoint-controller</code></li><li><code>system:controller:expand-controller</code></li><li><code>system:controller:generic-garbage-collector</code></li><li><code>system:controller:horizontal-pod-autoscaler</code></li><li><code>system:controller:job-controller</code></li><li><code>system:controller:namespace-controller</code></li><li><code>system:controller:node-controller</code></li><li><code>system:controller:persistent-volume-binder</code></li><li><code>system:controller:pod-garbage-collector</code></li><li><code>system:controller:pv-protection-controller</code></li><li><code>system:controller:pvc-protection-controller</code></li><li><code>system:controller:replicaset-controller</code></li><li><code>system:controller:replication-controller</code></li><li><code>system:controller:resourcequota-controller</code></li><li><code>system:controller:root-ca-cert-publisher</code></li><li><code>system:controller:route-controller</code></li><li><code>system:controller:service-account-controller</code></li><li><code>system:controller:service-controller</code></li><li><code>system:controller:statefulset-controller</code></li><li><code>system:controller:ttl-controller</code></li></ul><h2 id=privilege-escalation-prevention-and-bootstrapping>初始化与预防权限提升</h2><p>RBAC API 会阻止用户通过编辑角色或者角色绑定来提升权限。
由于这一点是在 API 级别实现的，所以在 RBAC 鉴权组件未启用的状态下依然可以正常工作。</p><h3 id=restrictions-on-role-creation-or-update>对角色创建或更新的限制</h3><p>只有在符合下列条件之一的情况下，你才能创建/更新角色:</p><ol><li>你已经拥有角色中包含的所有权限，且其作用域与正被修改的对象作用域相同。
（对 ClusterRole 而言意味着集群范围，对 Role 而言意味着相同名字空间或者集群范围）。</li><li>你被显式授权在 <code>rbac.authorization.k8s.io</code> API 组中的 <code>roles</code> 或 <code>clusterroles</code>
资源使用 <code>escalate</code> 动词。</li></ol><p>例如，如果 <code>user-1</code> 没有列举集群范围所有 Secret 的权限，他将不能创建包含该权限的 ClusterRole。
若要允许用户创建/更新角色：</p><ol><li>根据需要赋予他们一个角色，允许他们根据需要创建/更新 Role 或者 ClusterRole 对象。</li><li>授予他们在所创建/更新角色中包含特殊权限的权限:<ul><li>隐式地为他们授权（如果它们试图创建或者更改 Role 或 ClusterRole 的权限，
但自身没有被授予相应权限，API 请求将被禁止）。</li><li>通过允许他们在 Role 或 ClusterRole 资源上执行 <code>escalate</code> 动作显式完成授权。
这里的 <code>roles</code> 和 <code>clusterroles</code> 资源包含在 <code>rbac.authorization.k8s.io</code> API 组中。</li></ul></li></ol><h3 id=restrictions-on-role-binding-creation-or-update>对角色绑定创建或更新的限制</h3><p>只有你已经具有了所引用的角色中包含的全部权限时，<strong>或者</strong> 你被授权在所引用的角色上执行 <code>bind</code>
动词时，你才可以创建或更新角色绑定。这里的权限与角色绑定的作用域相同。
例如，如果用户 <code>user-1</code> 没有列举集群范围所有 Secret 的能力，则他不可以创建
ClusterRoleBinding 引用授予该许可权限的角色。
如要允许用户创建或更新角色绑定：</p><ol><li>赋予他们一个角色，使得他们能够根据需要创建或更新 RoleBinding 或 ClusterRoleBinding 对象。</li><li>授予他们绑定某特定角色所需要的许可权限：<ul><li>隐式授权下，可以将角色中包含的许可权限授予他们；</li><li>显式授权下，可以授权他们在特定 Role （或 ClusterRole）上执行 <code>bind</code> 动词的权限。</li></ul></li></ol><p>例如，下面的 ClusterRole 和 RoleBinding 将允许用户 <code>user-1</code> 把名字空间 <code>user-1-namespace</code>
中的 <code>admin</code>、<code>edit</code> 和 <code>view</code> 角色赋予其他用户：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>role-grantor<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;rbac.authorization.k8s.io&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;rolebindings&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;create&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;rbac.authorization.k8s.io&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;clusterroles&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;bind&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#080;font-style:italic># 忽略 resourceNames 意味着允许绑定任何 ClusterRole</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceNames</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;admin&#34;</span>,<span style=color:#b44>&#34;edit&#34;</span>,<span style=color:#b44>&#34;view&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>---</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>RoleBinding<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>role-grantor-binding<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>user-1-namespace<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>roleRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>role-grantor<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>User<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>user-1<span style=color:#bbb>
</span></span></span></code></pre></div><p>当启动引导第一个角色和角色绑定时，需要为初始用户授予他们尚未拥有的权限。
对初始角色和角色绑定进行初始化时需要：</p><ul><li>使用用户组为 <code>system:masters</code> 的凭据，该用户组由默认绑定关联到 <code>cluster-admin</code>
这个超级用户角色。</li></ul><h2 id=command-line-utilities>一些命令行工具</h2><h3 id=kubectl-create-role><code>kubectl create role</code></h3><p>创建 Role 对象，定义在某一名字空间中的权限。例如:</p><ul><li><p>创建名称为 “pod-reader” 的 Role 对象，允许用户对 Pods 执行 <code>get</code>、<code>watch</code> 和 <code>list</code> 操作：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create role pod-reader --verb<span style=color:#666>=</span>get --verb<span style=color:#666>=</span>list --verb<span style=color:#666>=</span>watch --resource<span style=color:#666>=</span>pods
</span></span></code></pre></div></li></ul><ul><li><p>创建名称为 “pod-reader” 的 Role 对象并指定 <code>resourceNames</code>：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create role pod-reader --verb<span style=color:#666>=</span>get --resource<span style=color:#666>=</span>pods --resource-name<span style=color:#666>=</span>readablepod --resource-name<span style=color:#666>=</span>anotherpod
</span></span></code></pre></div></li></ul><ul><li><p>创建名为 “foo” 的 Role 对象并指定 <code>apiGroups</code>：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create role foo --verb<span style=color:#666>=</span>get,list,watch --resource<span style=color:#666>=</span>replicasets.apps
</span></span></code></pre></div></li></ul><ul><li><p>创建名为 “foo” 的 Role 对象并指定子资源权限:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create role foo --verb<span style=color:#666>=</span>get,list,watch --resource<span style=color:#666>=</span>pods,pods/status
</span></span></code></pre></div></li></ul><ul><li><p>创建名为 “my-component-lease-holder” 的 Role 对象，使其具有对特定名称的资源执行
get/update 的权限：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create role my-component-lease-holder --verb<span style=color:#666>=</span>get,list,watch,update --resource<span style=color:#666>=</span>lease --resource-name<span style=color:#666>=</span>my-component
</span></span></code></pre></div></li></ul><h3 id=kubectl-create-clusterrole><code>kubectl create clusterrole</code></h3><p>创建 ClusterRole 对象。例如：</p><ul><li><p>创建名称为 “pod-reader” 的 ClusterRole 对象，允许用户对 Pods 对象执行 <code>get</code>、
<code>watch</code> 和 <code>list</code> 操作：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create clusterrole pod-reader --verb<span style=color:#666>=</span>get,list,watch --resource<span style=color:#666>=</span>pods
</span></span></code></pre></div></li></ul><ul><li><p>创建名为 “pod-reader” 的 ClusterRole 对象并指定 <code>resourceNames</code>：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create clusterrole pod-reader --verb<span style=color:#666>=</span>get --resource<span style=color:#666>=</span>pods --resource-name<span style=color:#666>=</span>readablepod --resource-name<span style=color:#666>=</span>anotherpod
</span></span></code></pre></div></li></ul><ul><li><p>创建名为 “foo” 的 ClusterRole 对象并指定 <code>apiGroups</code>：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create clusterrole foo --verb<span style=color:#666>=</span>get,list,watch --resource<span style=color:#666>=</span>replicasets.apps
</span></span></code></pre></div></li></ul><ul><li><p>创建名为 “foo” 的 ClusterRole 对象并指定子资源:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create clusterrole foo --verb<span style=color:#666>=</span>get,list,watch --resource<span style=color:#666>=</span>pods,pods/status
</span></span></code></pre></div></li></ul><ul><li><p>创建名为 “foo” 的 ClusterRole 对象并指定 <code>nonResourceURL</code>：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create clusterrole <span style=color:#b44>&#34;foo&#34;</span> --verb<span style=color:#666>=</span>get --non-resource-url<span style=color:#666>=</span>/logs/*
</span></span></code></pre></div></li></ul><ul><li><p>创建名为 “monitoring” 的 ClusterRole 对象并指定 <code>aggregationRule</code>：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create clusterrole monitoring --aggregation-rule<span style=color:#666>=</span><span style=color:#b44>&#34;rbac.example.com/aggregate-to-monitoring=true&#34;</span>
</span></span></code></pre></div></li></ul><h3 id=kubectl-create-rolebinding><code>kubectl create rolebinding</code></h3><p>在特定的名字空间中对 <code>Role</code> 或 <code>ClusterRole</code> 授权。例如：</p><ul><li><p>在名字空间 “acme” 中，将名为 <code>admin</code> 的 ClusterRole 中的权限授予名称 “bob” 的用户:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create rolebinding bob-admin-binding --clusterrole<span style=color:#666>=</span>admin --user<span style=color:#666>=</span>bob --namespace<span style=color:#666>=</span>acme
</span></span></code></pre></div></li></ul><ul><li><p>在名字空间 “acme” 中，将名为 <code>view</code> 的 ClusterRole 中的权限授予名字空间 “acme”
中名为 <code>myapp</code> 的服务账户：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create rolebinding myapp-view-binding --clusterrole<span style=color:#666>=</span>view --serviceaccount<span style=color:#666>=</span>acme:myapp --namespace<span style=color:#666>=</span>acme
</span></span></code></pre></div></li></ul><ul><li><p>在名字空间 “acme” 中，将名为 <code>view</code> 的 ClusterRole 对象中的权限授予名字空间
“myappnamespace” 中名称为 <code>myapp</code> 的服务账户：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create rolebinding myappnamespace-myapp-view-binding --clusterrole<span style=color:#666>=</span>view --serviceaccount<span style=color:#666>=</span>myappnamespace:myapp --namespace<span style=color:#666>=</span>acme
</span></span></code></pre></div></li></ul><h3 id=kubectl-create-clusterrolebinding><code>kubectl create clusterrolebinding</code></h3><p>在整个集群（所有名字空间）中用 ClusterRole 授权。例如：</p><ul><li><p>在整个集群范围，将名为 <code>cluster-admin</code> 的 ClusterRole 中定义的权限授予名为 “root” 用户：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create clusterrolebinding root-cluster-admin-binding --clusterrole<span style=color:#666>=</span>cluster-admin --user<span style=color:#666>=</span>root
</span></span></code></pre></div></li></ul><ul><li><p>在整个集群范围内，将名为 <code>system:node-proxier</code> 的 ClusterRole 的权限授予名为
“system:kube-proxy” 的用户：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create clusterrolebinding kube-proxy-binding --clusterrole<span style=color:#666>=</span>system:node-proxier --user<span style=color:#666>=</span>system:kube-proxy
</span></span></code></pre></div></li></ul><ul><li><p>在整个集群范围内，将名为 <code>view</code> 的 ClusterRole 中定义的权限授予 “acme” 名字空间中名为
“myapp” 的服务账户：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create clusterrolebinding myapp-view-binding --clusterrole<span style=color:#666>=</span>view --serviceaccount<span style=color:#666>=</span>acme:myapp
</span></span></code></pre></div></li></ul><h3 id=kubectl-auth-reconcile><code>kubectl auth reconcile</code></h3><p>使用清单文件来创建或者更新 <code>rbac.authorization.k8s.io/v1</code> API 对象。</p><p>尚不存在的对象会被创建，如果对应的名字空间也不存在，必要的话也会被创建。
已经存在的角色会被更新，使之包含输入对象中所给的权限。如果指定了
<code>--remove-extra-permissions</code>，可以删除额外的权限。</p><p>已经存在的绑定也会被更新，使之包含输入对象中所给的主体。如果指定了
<code>--remove-extra-permissions</code>，则可以删除多余的主体。</p><p>例如:</p><ul><li><p>测试应用 RBAC 对象的清单文件，显示将要进行的更改：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl auth reconcile -f my-rbac-rules.yaml --dry-run<span style=color:#666>=</span>client
</span></span></code></pre></div></li></ul><ul><li><p>应用 RBAC 对象的清单文件，保留角色（<code>roles</code>）中的额外权限和绑定（<code>bindings</code>）中的其他主体：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl auth reconcile -f my-rbac-rules.yaml
</span></span></code></pre></div></li></ul><ul><li><p>应用 RBAC 对象的清单文件，删除角色（<code>roles</code>）中的额外权限和绑定中的其他主体：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl auth reconcile -f my-rbac-rules.yaml --remove-extra-subjects --remove-extra-permissions
</span></span></code></pre></div></li></ul><h2 id=service-account-permissions>服务账户权限</h2><p>默认的 RBAC 策略为控制面组件、节点和控制器授予权限。
但是不会对 <code>kube-system</code> 名字空间之外的服务账户授予权限。
（除了授予所有已认证用户的发现权限）</p><p>这使得你可以根据需要向特定 ServiceAccount 授予特定权限。
细粒度的角色绑定可带来更好的安全性，但需要更多精力管理。
粗粒度的授权可能导致 ServiceAccount 被授予不必要的 API 访问权限（甚至导致潜在的权限提升），
但更易于管理。</p><p>按从最安全到最不安全的顺序，存在以下方法：</p><ol><li><p>为特定应用的服务账户授予角色（最佳实践）</p><p>这要求应用在其 Pod 规约中指定 <code>serviceAccountName</code>，
并额外创建服务账户（包括通过 API、应用程序清单、<code>kubectl create serviceaccount</code> 等）。</p><p>例如，在名字空间 “my-namespace” 中授予服务账户 “my-sa” 只读权限：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create rolebinding my-sa-view <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --clusterrole<span style=color:#666>=</span>view <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --serviceaccount<span style=color:#666>=</span>my-namespace:my-sa <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --namespace<span style=color:#666>=</span>my-namespace
</span></span></code></pre></div></li></ol><ol start=2><li><p>将角色授予某名字空间中的 “default” 服务账户</p><p>如果某应用没有指定 <code>serviceAccountName</code>，那么它将使用 “default” 服务账户。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>"default" 服务账户所具有的权限会被授予给名字空间中所有未指定 <code>serviceAccountName</code> 的 Pod。</div><p>例如，在名字空间 "my-namespace" 中授予服务账户 "default" 只读权限：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create rolebinding default-view <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --clusterrole<span style=color:#666>=</span>view <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --serviceaccount<span style=color:#666>=</span>my-namespace:default <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --namespace<span style=color:#666>=</span>my-namespace
</span></span></code></pre></div><p>许多<a href=/zh-cn/docs/concepts/cluster-administration/addons/>插件组件</a>在 <code>kube-system</code>
名字空间以 “default” 服务账户运行。
要允许这些插件组件以超级用户权限运行，需要将集群的 <code>cluster-admin</code> 权限授予
<code>kube-system</code> 名字空间中的 “default” 服务账户。</p><div class="alert alert-warning caution callout" role=alert><strong>注意：</strong><p>启用这一配置意味着在 <code>kube-system</code> 名字空间中包含以超级用户账号来访问集群 API 的 Secret。</div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create clusterrolebinding add-on-cluster-admin <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --clusterrole<span style=color:#666>=</span>cluster-admin <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --serviceaccount<span style=color:#666>=</span>kube-system:default
</span></span></code></pre></div></li></ol><ol start=3><li><p>将角色授予名字空间中所有服务账户</p><p>如果你想要名字空间中所有应用都具有某角色，无论它们使用的什么服务账户，
可以将角色授予该名字空间的服务账户组。</p><p>例如，在名字空间 “my-namespace” 中的只读权限授予该名字空间中的所有服务账户：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create rolebinding serviceaccounts-view <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --clusterrole<span style=color:#666>=</span>view <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --group<span style=color:#666>=</span>system:serviceaccounts:my-namespace <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --namespace<span style=color:#666>=</span>my-namespace
</span></span></code></pre></div></li></ol><ol start=4><li><p>在集群范围内为所有服务账户授予一个受限角色（不鼓励）</p><p>如果你不想管理每一个名字空间的权限，你可以向所有的服务账户授予集群范围的角色。</p><p>例如，为集群范围的所有服务账户授予跨所有名字空间的只读权限：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create clusterrolebinding serviceaccounts-view <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --clusterrole<span style=color:#666>=</span>view <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --group<span style=color:#666>=</span>system:serviceaccounts
</span></span></code></pre></div></li></ol><ol start=5><li><p>授予超级用户访问权限给集群范围内的所有服务帐户（强烈不鼓励）</p><p>如果你不在乎如何区分权限，你可以将超级用户访问权限授予所有服务账户。</p><div class="alert alert-danger warning callout" role=alert><strong>警告：</strong><p>这样做会允许所有应用都对你的集群拥有完全的访问权限，并将允许所有能够读取
Secret（或创建 Pod）的用户对你的集群有完全的访问权限。</div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create clusterrolebinding serviceaccounts-cluster-admin <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --clusterrole<span style=color:#666>=</span>cluster-admin <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --group<span style=color:#666>=</span>system:serviceaccounts
</span></span></code></pre></div></li></ol><h2 id=write-access-for-endpoints>EndpointSlices 和 Endpoints 写权限</h2><p>在 Kubernetes v1.22 之前版本创建的集群里，
“edit” 和 “admin” 聚合角色包含对 EndpointSlices（和 Endpoints）的写权限。
作为 <a href=https://github.com/kubernetes/kubernetes/issues/103675>CVE-2021-25740</a> 的缓解措施，
此访问权限不包含在 Kubernetes 1.22 以及更高版本集群的聚合角色里。</p><p>升级到 Kubernetes v1.22 版本的现有集群不会包括此变化。
<a href=https://github.com/kubernetes/kubernetes/issues/103675>CVE 公告</a>包含了在现有集群里限制此访问权限的指引。</p><p>如果你希望在新集群的聚合角色里保留此访问权限，你可以创建下面的 ClusterRole：</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/access/endpoints-aggregated.yaml download=access/endpoints-aggregated.yaml><code>access/endpoints-aggregated.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("access-endpoints-aggregated-yaml")' title="Copy access/endpoints-aggregated.yaml to clipboard"></img></div><div class=includecode id=access-endpoints-aggregated-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>kubernetes.io/description</span>:<span style=color:#bbb> </span>|-<span style=color:#b44;font-style:italic>
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      将端点写入权限添加到 edit 和 admin 角色。此特性因 CVE-2021-25740 在 1.22
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      中默认被移除。请参阅 https://issue.k8s.io/103675
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      这一设置将允许写者要求 LoadBalancer 或 Ingress 的实现向外暴露后端 IP 地址，
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      所暴露的 IP 地址无法通过其他方式访问，
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      并且可以规避对这些后端访问进行预防/隔离的网络策略或安全控制机制。
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      EndpointSlice 从未包含在 edit 和 admin 角色中，
</span></span></span><span style=display:flex><span><span style=color:#b44;font-style:italic>      因此 EndpointSlice API 没有什么可恢复的。</span><span style=color:#bbb>      
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>rbac.authorization.k8s.io/aggregate-to-edit</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>custom:aggregate-to-edit:endpoints<span style=color:#bbb> </span><span style=color:#080;font-style:italic># 你可以随意愿更改这个 name</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;endpoints&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;create&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;delete&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;deletecollection&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;patch&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;update&#34;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><h2 id=upgrading-from-abac>从 ABAC 升级</h2><p>原来运行较老版本 Kubernetes 的集群通常会使用限制宽松的 ABAC 策略，
包括授予所有服务帐户全权访问 API 的能力。</p><p>默认的 RBAC 策略为控制面组件、节点和控制器等授予有限的权限，但不会为
<code>kube-system</code> 名字空间外的服务账户授权（除了授予所有认证用户的发现权限之外）。</p><p>这样做虽然安全得多，但可能会干扰期望自动获得 API 权限的现有工作负载。
这里有两种方法来完成这种转换:</p><h3 id=parallel-authorizers>并行鉴权</h3><p>同时运行 RBAC 和 ABAC 鉴权模式，
并指定包含<a href=/zh-cn/docs/reference/access-authn-authz/abac/#policy-file-format>现有的 ABAC 策略</a>的策略文件：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>--authorization-mode<span style=color:#666>=</span>...,RBAC,ABAC --authorization-policy-file<span style=color:#666>=</span>mypolicy.json
</span></span></code></pre></div><p>关于命令行中的第一个选项：如果早期的鉴权组件，例如 Node，拒绝了某个请求，则
RBAC 鉴权组件尝试对该 API 请求鉴权。如果 RBAC 也拒绝了该 API 请求，则运行 ABAC
鉴权组件。这意味着被 RBAC 或 ABAC 策略所允许的任何请求都是被允许的请求。</p><p>如果 kube-apiserver 启动时，RBAC 组件的日志级别为 5 或更高（<code>--vmodule=rbac*=5</code> 或 <code>--v=5</code>），
你可以在 API 服务器的日志中看到 RBAC 拒绝的细节（前缀 <code>RBAC</code>）
你可以使用这些信息来确定需要将哪些角色授予哪些用户、组或服务帐户。</p><p>一旦你<a href=#service-account-permissions>将角色授予服务账户</a>且工作负载运行时，
服务器日志中没有出现 RBAC 拒绝消息，就可以删除 ABAC 鉴权器。</p><h3 id=permissive-rbac-permissions>宽松的 RBAC 权限</h3><p>你可以使用 RBAC 角色绑定复制宽松的 ABAC 策略。</p><div class="alert alert-danger warning callout" role=alert><strong>警告：</strong><p>下面的策略允许 <strong>所有</strong> 服务帐户充当集群管理员。
容器中运行的所有应用程序都会自动收到服务帐户的凭据，可以对 API 执行任何操作，
包括查看 Secret 和修改权限。这一策略是不被推荐的。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create clusterrolebinding permissive-binding <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --clusterrole<span style=color:#666>=</span>cluster-admin <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --user<span style=color:#666>=</span>admin <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --user<span style=color:#666>=</span>kubelet <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --group<span style=color:#666>=</span>system:serviceaccounts
</span></span></code></pre></div></div><p>在你完成到 RBAC 的迁移后，应该调整集群的访问控制，确保相关的策略满足你的信息安全需求。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-a5bdc757c01991e5e6ab1a82b90639ea>9 - 使用 ABAC 鉴权</h1><p>基于属性的访问控制（Attribute-based access control - ABAC）定义了访问控制范例，
其中通过使用将属性组合在一起的策略来向用户授予访问权限。</p><h2 id=policy-file-format>策略文件格式</h2><p>基于 <code>ABAC</code> 模式，可以这样指定策略文件 <code>--authorization-policy-file=SOME_FILENAME</code>。</p><p>此文件格式是 <a href=https://jsonlines.org/>JSON Lines</a>，不应存在外层的列表或映射，每行应只有一个映射。</p><p>每一行都是一个策略对象，策略对象是具有以下属性的映射：</p><ul><li>版本控制属性：<ul><li><code>apiVersion</code>，字符串类型：有效值为 <code>abac.authorization.kubernetes.io/v1beta1</code>，允许对策略格式进行版本控制和转换。</li><li><code>kind</code>，字符串类型：有效值为 <code>Policy</code>，允许对策略格式进行版本控制和转换。</li></ul></li><li><code>spec</code> 配置为具有以下映射的属性：<ul><li>主体匹配属性：<ul><li><code>user</code>，字符串类型；来自 <code>--token-auth-file</code> 的用户字符串，如果你指定 <code>user</code>，它必须与验证用户的用户名匹配。</li><li><code>group</code>，字符串类型；如果指定 <code>group</code>，它必须与经过身份验证的用户的一个组匹配，<code>system:authenticated</code> 匹配所有经过身份验证的请求。
<code>system:unauthenticated</code> 匹配所有未经过身份验证的请求。</li></ul></li></ul></li><li>资源匹配属性：<ul><li><code>apiGroup</code>，字符串类型；一个 API 组。<ul><li>例如：<code>apps</code>，<code>networking.k8s.io</code></li><li>通配符：<code>*</code>匹配所有 API 组。</li></ul></li><li><code>namespace</code>，字符串类型；一个命名空间。<ul><li>例如：<code>kube-system</code></li><li>通配符：<code>*</code>匹配所有资源请求。</li></ul></li><li><code>resource</code>，字符串类型；资源类型。<ul><li>例如：<code>pods</code>，<code>deployments</code></li><li>通配符：<code>*</code>匹配所有资源请求。</li></ul></li></ul></li><li>非资源匹配属性：<ul><li><code>nonResourcePath</code>，字符串类型；非资源请求路径。<ul><li>例如：<code>/version</code> 或 <code>/apis</code></li><li>通配符：<ul><li><code>*</code> 匹配所有非资源请求。</li><li><code>/foo/*</code> 匹配 <code>/foo/</code> 的所有子路径。</li></ul></li></ul></li></ul></li><li><code>readonly</code>，键入布尔值，如果为 true，则表示该策略仅适用于 get、list 和 watch 操作。</li></ul><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>属性未设置等效于属性被设置为对应类型的零值( 例如空字符串、0、false)，然而，出于可读性考虑，应尽量选择不设置这类属性。</p><p>在将来，策略可能以 JSON 格式表示，并通过 REST 界面进行管理。</p></div><h2 id=authorization-algorithm>鉴权算法</h2><p>请求具有与策略对象的属性对应的属性。</p><p>当接收到请求时，确定属性。未知属性设置为其类型的零值（例如：空字符串，0，false）。</p><p>设置为 <code>"*"</code> 的属性将匹配相应属性的任何值。</p><p>检查属性的元组，以匹配策略文件中的每个策略。如果至少有一行匹配请求属性，则请求被鉴权（但仍可能无法通过稍后的合法性检查）。</p><p>要允许任何经过身份验证的用户执行某些操作，请将策略组属性设置为 <code>"system:authenticated"</code>。</p><p>要允许任何未经身份验证的用户执行某些操作，请将策略组属性设置为 <code>"system:unauthenticated"</code>。</p><p>要允许用户执行任何操作，请使用设置为 <code>"*"</code> 的 apiGroup，namespace，resource 和 nonResourcePath 属性编写策略。</p><h2 id=kubectl>kubectl</h2><p>kubectl 使用 apiserver 的 <code>/api</code> 和 <code>/apis</code> 端点来发现服务资源类型，
并使用位于 <code>/openapi/v2</code> 的模式信息来验证通过创建/更新操作发送到 API 的对象。</p><p>当使用 ABAC 鉴权时，这些特殊资源必须显式地通过策略中的 <code>nonResourcePath</code> 属性暴露出来（参见下面的 <a href=#examples>示例</a>）：</p><ul><li><code>/api</code>，<code>/api/*</code>，<code>/apis</code> 和 <code>/apis/*</code> 用于 API 版本协商。</li><li><code>/version</code> 通过 <code>kubectl version</code> 检索服务器版本。</li><li><code>/swaggerapi/*</code> 用于创建 / 更新操作。</li></ul><p>要检查涉及到特定 kubectl 操作的 HTTP 调用，你可以调整详细程度：
kubectl --v=8 version</p><h2 id=examples>例子</h2><ol><li><p>Alice 可以对所有资源做任何事情：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{<span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;abac.authorization.kubernetes.io/v1beta1&#34;</span>, <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;Policy&#34;</span>, <span style=color:green;font-weight:700>&#34;spec&#34;</span>: {<span style=color:green;font-weight:700>&#34;user&#34;</span>: <span style=color:#b44>&#34;alice&#34;</span>, <span style=color:green;font-weight:700>&#34;namespace&#34;</span>: <span style=color:#b44>&#34;*&#34;</span>, <span style=color:green;font-weight:700>&#34;resource&#34;</span>: <span style=color:#b44>&#34;*&#34;</span>, <span style=color:green;font-weight:700>&#34;apiGroup&#34;</span>: <span style=color:#b44>&#34;*&#34;</span>}}
</span></span></code></pre></div></li><li><p>kubelet 可以读取任何 pod：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{<span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;abac.authorization.kubernetes.io/v1beta1&#34;</span>, <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;Policy&#34;</span>, <span style=color:green;font-weight:700>&#34;spec&#34;</span>: {<span style=color:green;font-weight:700>&#34;user&#34;</span>: <span style=color:#b44>&#34;kubelet&#34;</span>, <span style=color:green;font-weight:700>&#34;namespace&#34;</span>: <span style=color:#b44>&#34;*&#34;</span>, <span style=color:green;font-weight:700>&#34;resource&#34;</span>: <span style=color:#b44>&#34;pods&#34;</span>, <span style=color:green;font-weight:700>&#34;readonly&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>}}
</span></span></code></pre></div></li><li><p>kubelet 可以读写事件：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{<span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;abac.authorization.kubernetes.io/v1beta1&#34;</span>, <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;Policy&#34;</span>, <span style=color:green;font-weight:700>&#34;spec&#34;</span>: {<span style=color:green;font-weight:700>&#34;user&#34;</span>: <span style=color:#b44>&#34;kubelet&#34;</span>, <span style=color:green;font-weight:700>&#34;namespace&#34;</span>: <span style=color:#b44>&#34;*&#34;</span>, <span style=color:green;font-weight:700>&#34;resource&#34;</span>: <span style=color:#b44>&#34;events&#34;</span>}}
</span></span></code></pre></div></li></ol><ol start=4><li><p>Bob 可以在命名空间 <code>projectCaribou</code> 中读取 pod：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{<span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;abac.authorization.kubernetes.io/v1beta1&#34;</span>, <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;Policy&#34;</span>, <span style=color:green;font-weight:700>&#34;spec&#34;</span>: {<span style=color:green;font-weight:700>&#34;user&#34;</span>: <span style=color:#b44>&#34;bob&#34;</span>, <span style=color:green;font-weight:700>&#34;namespace&#34;</span>: <span style=color:#b44>&#34;projectCaribou&#34;</span>, <span style=color:green;font-weight:700>&#34;resource&#34;</span>: <span style=color:#b44>&#34;pods&#34;</span>, <span style=color:green;font-weight:700>&#34;readonly&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>}}
</span></span></code></pre></div></li><li><p>任何人都可以对所有非资源路径进行只读请求：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{<span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;abac.authorization.kubernetes.io/v1beta1&#34;</span>, <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;Policy&#34;</span>, <span style=color:green;font-weight:700>&#34;spec&#34;</span>: {<span style=color:green;font-weight:700>&#34;group&#34;</span>: <span style=color:#b44>&#34;system:authenticated&#34;</span>, <span style=color:green;font-weight:700>&#34;readonly&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>, <span style=color:green;font-weight:700>&#34;nonResourcePath&#34;</span>: <span style=color:#b44>&#34;*&#34;</span>}}
</span></span><span style=display:flex><span>{<span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;abac.authorization.kubernetes.io/v1beta1&#34;</span>, <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;Policy&#34;</span>, <span style=color:green;font-weight:700>&#34;spec&#34;</span>: {<span style=color:green;font-weight:700>&#34;group&#34;</span>: <span style=color:#b44>&#34;system:unauthenticated&#34;</span>, <span style=color:green;font-weight:700>&#34;readonly&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>, <span style=color:green;font-weight:700>&#34;nonResourcePath&#34;</span>: <span style=color:#b44>&#34;*&#34;</span>}}
</span></span></code></pre></div></li></ol><p><a href=https://releases.k8s.io/v1.25.0/pkg/auth/authorizer/abac/example_policy_file.jsonl>完整文件示例</a></p><h2 id=a-quick-note-on-service-accounts>服务帐户的快速说明</h2><p>服务帐户自动生成用户。用户名是根据命名约定生成的：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>system:serviceaccount:&lt;namespace&gt;:&lt;serviceaccountname&gt;
</span></span></code></pre></div><p>创建新的命名空间也会导致创建一个新的服务帐户：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>system:serviceaccount:&lt;namespace&gt;:default
</span></span></code></pre></div><p>例如，如果要将 API 的 kube-system 完整权限中的默认服务帐户授予，则可以将此行添加到策略文件中：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{<span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>:<span style=color:#b44>&#34;abac.authorization.kubernetes.io/v1beta1&#34;</span>,<span style=color:green;font-weight:700>&#34;kind&#34;</span>:<span style=color:#b44>&#34;Policy&#34;</span>,<span style=color:green;font-weight:700>&#34;spec&#34;</span>:{<span style=color:green;font-weight:700>&#34;user&#34;</span>:<span style=color:#b44>&#34;system:serviceaccount:kube-system:default&#34;</span>,<span style=color:green;font-weight:700>&#34;namespace&#34;</span>:<span style=color:#b44>&#34;*&#34;</span>,<span style=color:green;font-weight:700>&#34;resource&#34;</span>:<span style=color:#b44>&#34;*&#34;</span>,<span style=color:green;font-weight:700>&#34;apiGroup&#34;</span>:<span style=color:#b44>&#34;*&#34;</span>}}
</span></span></code></pre></div><p>需要重新启动 apiserver 以获取新的策略行。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-9cbb97d4d9f08d67931a1baae4e6519c>10 - 使用 Node 鉴权</h1><p>节点鉴权是一种特殊用途的鉴权模式，专门对 kubelet 发出的 API 请求进行授权。</p><h2 id=overview>概述</h2><p>节点鉴权器允许 kubelet 执行 API 操作。包括：</p><p>读取操作：</p><ul><li>services</li><li>endpoints</li><li>nodes</li><li>pods</li><li>与绑定到 kubelet 节点的 Pod 相关的 Secret、ConfigMap、PersistentVolumeClaim 和持久卷</li></ul><p>写入操作：</p><ul><li>节点和节点状态（启用 <code>NodeRestriction</code> 准入插件以限制 kubelet 只能修改自己的节点）</li><li>Pod 和 Pod 状态 (启用 <code>NodeRestriction</code> 准入插件以限制 kubelet 只能修改绑定到自身的 Pod)</li><li>事件</li></ul><p>身份认证与鉴权相关的操作：</p><ul><li>对于基于 TLS 的启动引导过程时使用的
<a href=/zh-cn/docs/reference/access-authn-authz/certificate-signing-requests/>certificationsigningrequests API</a>
的读/写权限</li><li>为委派的身份验证/鉴权检查创建 TokenReview 和 SubjectAccessReview 的能力</li></ul><p>在将来的版本中，节点鉴权器可能会添加或删除权限，以确保 kubelet 具有正确操作所需的最小权限集。</p><p>为了获得节点鉴权器的授权，kubelet 必须使用一个凭证以表示它在 <code>system:nodes</code>
组中，用户名为 <code>system:node:&lt;nodeName></code>。上述的组名和用户名格式要与
<a href=/zh-cn/docs/reference/access-authn-authz/kubelet-tls-bootstrapping/>kubelet TLS 启动引导</a>
过程中为每个 kubelet 创建的标识相匹配。</p><p><code>&lt;nodeName></code> 的值<strong>必须</strong>与 kubelet 注册的节点名称精确匹配。默认情况下，节点名称是由
<code>hostname</code> 提供的主机名，或者通过 kubelet <code>--hostname-override</code>
<a href=/zh-cn/docs/reference/command-line-tools-reference/kubelet/>选项</a> 覆盖。
但是，当使用 <code>--cloud-provider</code> kubelet 选项时，具体的主机名可能由云提供商确定，
忽略本地的 <code>hostname</code> 和 <code>--hostname-override</code> 选项。有关
kubelet 如何确定主机名的详细信息，请参阅
<a href=/zh-cn/docs/reference/command-line-tools-reference/kubelet/>kubelet 选项参考</a>。</p><p>要启用节点鉴权器，请使用 <code>--authorization-mode=Node</code> 启动 API 服务器。</p><p>要限制 kubelet 可以写入的 API 对象，请使用
<code>--enable-admission-plugins=...,NodeRestriction,...</code> 启动 API 服务器，从而启用
<a href=/zh-cn/docs/reference/access-authn-authz/admission-controllers#NodeRestriction>NodeRestriction</a>
准入插件。</p><h2 id=migration-considerations>迁移考虑因素</h2><h3 id=kubelets-outside-the-system-nodes-group>在 <code>system:nodes</code> 组之外的 kubelet</h3><p><code>system:nodes</code> 组之外的 kubelet 不会被 <code>Node</code> 鉴权模式授权，并且需要继续通过当前授权它们的机制来授权。
节点准入插件不会限制来自这些 kubelet 的请求。</p><h3 id=kubelets-with-undifferentiated-usernames>具有无差别用户名的 kubelet</h3><p>在一些部署中，kubelet 具有 <code>system:nodes</code> 组的凭证，
但是无法给出它们所关联的节点的标识，因为它们没有 <code>system:node:...</code> 格式的用户名。
这些 kubelet 不会被 <code>Node</code> 鉴权模式授权，并且需要继续通过当前授权它们的任何机制来授权。</p><p>因为默认的节点标识符实现不会把它当作节点身份标识，<code>NodeRestriction</code>
准入插件会忽略来自这些 kubelet 的请求。</p><h3 id=upgrades-from-previous-versions-using-rbac>相对于以前使用 RBAC 的版本的更新</h3><p>升级的 1.7 之前的使用 <a href=/zh-cn/docs/reference/access-authn-authz/rbac/>RBAC</a>
的集群将继续按原样运行，因为 <code>system:nodes</code> 组绑定已经存在。</p><p>如果集群管理员希望开始使用 <code>Node</code> 鉴权器和 <code>NodeRestriction</code> 准入插件来限制节点对
API 的访问，这一需求可以通过下列操作来完成且不会影响已部署的应用：</p><ol><li>启用 <code>Node</code> 鉴权模式 (<code>--authorization-mode=Node,RBAC</code>) 和 <code>NodeRestriction</code> 准入插件</li><li>确保所有 kubelet 的凭据符合组/用户名要求</li><li>审核 API 服务器日志以确保 <code>Node</code> 鉴权器不会拒绝来自 kubelet 的请求（日志中没有持续的 <code>NODE DENY</code> 消息）</li><li>删除 <code>system:node</code> 集群角色绑定</li></ol><h3 id=rbac-node-permissions>RBAC 节点权限</h3><p>在 1.6 版本中，当使用 <a href=/zh-cn/docs/reference/access-authn-authz/rbac/>RBAC 鉴权模式</a>
时，<code>system:nodes</code> 集群角色会被自动绑定到 <code>system:node</code> 组。</p><p>在 1.7 版本中，不再推荐将 <code>system:nodes</code> 组自动绑定到 <code>system:node</code>
角色，因为节点鉴权器通过对 Secret 和 ConfigMap 访问的额外限制完成了相同的任务。
如果同时启用了 <code>Node</code> 和 <code>RBAC</code> 鉴权模式，1.7 版本则不会创建 <code>system:nodes</code>
组到 <code>system:node</code> 角色的自动绑定。</p><p>在 1.8 版本中，绑定将根本不会被创建。</p><p>使用 RBAC 时，将继续创建 <code>system:node</code> 集群角色，以便与将其他用户或组绑定到该角色的部署方法兼容。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-643e4cec52a8577e9454649bdaac84d0>11 - 从 PodSecurityPolicy 映射到 Pod 安全性标准</h1><p>下面的表格列举了 <code>PodSecurityPolicy</code>
对象上的配置参数，这些字段是否会变更或检查 Pod 配置，以及这些配置值如何映射到
<a href=/zh-cn/docs/concepts/security/pod-security-standards/>Pod 安全性标准（Pod Security Standards）</a>
之上。</p><p>对于每个可应用的参数，表格中给出了
<a href=/zh-cn/docs/concepts/security/pod-security-standards/#baseline>Baseline</a> 和
<a href=/zh-cn/docs/concepts/security/pod-security-standards/#restricted>Restricted</a>
配置下可接受的取值。
对这两种配置而言不可接受的取值均归入
<a href=/zh-cn/docs/concepts/security/pod-security-standards/#privileged>Privileged</a>
配置下。“无意见”意味着对所有 Pod 安全性标准而言所有取值都可接受。</p><p>如果想要了解如何一步步完成迁移，可参阅<a href=/zh-cn/docs/tasks/configure-pod-container/migrate-from-psp/>从 PodSecurityPolicy 迁移到内置的 PodSecurity 准入控制器</a>。</p><h2 id=podsecuritypolicy-spec>PodSecurityPolicy 规约</h2><p>下面表格中所列举的字段是 <code>PodSecurityPolicySpec</code> 的一部分，是通过 <code>.spec</code>
字段路径来设置的。</p><table class=no-word-break><caption style=display:none>从 PodSecurityPolicySpec 字段映射到 Pod Security 标准</caption><tbody><tr><th><code>PodSecurityPolicySpec</code></th><th>类型</th><th>Pod 安全性标准中对应设置</th></tr><tr><td><code>privileged</code></td><td>检查性质</td><td><b>Baseline & Restricted</b>: <code>false</code> / 未定义 / nil</td></tr><tr><td><code>defaultAddCapabilities</code></td><td>更改性质 & 检查性质</td><td>需求满足下面的 <code>allallowedCapabilities</code></td></tr><tr><td><code>allowedCapabilities</code></td><td>检查性质</td><td><p><b>Baseline</b>：下面各项的子集</p><ul><li><code>AUDIT_WRITE</code></li><li><code>CHOWN</code></li><li><code>DAC_OVERRIDE</code></li><li><code>FOWNER</code></li><li><code>FSETID</code></li><li><code>KILL</code></li><li><code>MKNOD</code></li><li><code>NET_BIND_SERVICE</code></li><li><code>SETFCAP</code></li><li><code>SETGID</code></li><li><code>SETPCAP</code></li><li><code>SETUID</code></li><li><code>SYS_CHROOT</code></li></ul><p><b>Restricted</b>：空 / 未定义 / nil 或<i>仅</i>包含 <code>NET_BIND_SERVICE</code> 的列表</p></td></tr><tr><td><code>requiredDropCapabilities</code></td><td>更改性质 & 检查性质</td><td><p><b>Baseline</b>：无意见</p><p><b>Restricted</b>：必须包含 <code>ALL</code></p></td></tr><tr><td><code>volumes</code></td><td>检查性质</td><td><p><b>Baseline</b>除下列取值之外的任何值</p><ul><li><code>hostPath</code></li><li><code>*</code></li></ul><p><b>Restricted</b>：下列取值的子集</p><ul><li><code>configMap</code></li><li><code>csi</code></li><li><code>downwardAPI</code></li><li><code>emptyDir</code></li><li><code>ephemeral</code></li><li><code>persistentVolumeClaim</code></li><li><code>projected</code></li><li><code>secret</code></li></ul></td></tr><tr><td><code>hostNetwork</code></td><td>检查性质</td><td><b>Baseline & Restricted</b>：<code>false</code> / 未定义 / nil</td></tr><tr><td><code>hostPorts</code></td><td>检查性质</td><td><b>Baseline & Restricted</b>：未定义 / nil / 空</td></tr><tr><td><code>hostPID</code></td><td>检查性质</td><td><b>Baseline & Restricted</b>：<code>false</code> / 未定义 / nil</td></tr><tr><td><code>hostIPC</code></td><td>检查性质</td><td><b>Baseline & Restricted</b>：<code>false</code> / 未定义 / nil</td></tr><tr><td><code>seLinux</code></td><td>更改性质 & 检查性质</td><td><p><b>Baseline & Restricted</b>：
<code>seLinux.rule</code> 为 <code>MustRunAs</code>，且 <code>options</code> 如下：</p><ul><li><code>user</code> 未设置（<code>""</code> / 未定义 / nil）</li><li><code>role</code> 未设置（<code>""</code> / 未定义 / nil）</li><li><code>type</code> 未设置或者取值为 <code>container_t</code>、<code>container_init_t</code> 或 <code>container_kvm_t</code> 之一</li><li><code>level</code> 是任何取值</li></ul></td></tr><tr><td><code>runAsUser</code></td><td>变更性质 & 检查性质</td><td><p><b>Baseline</b>：任何取值</p><p><b>Restricted</b>：<code>rule</code> 是 <code>MustRunAsNonRoot</code></p></td></tr><tr><td><code>runAsGroup</code></td><td>变更性质（MustRunAs）& 检查性质</td><td><i>无意见</i></td></tr><tr><td><code>supplementalGroups</code></td><td>变更性质 & 检查性质</td><td><i>无意见</i></td></tr><tr><td><code>fsGroup</code></td><td>变更性质 & 验证性质</td><td><i>无意见</i></td></tr><tr><td><code>readOnlyRootFilesystem</code></td><td>变更性质 & 检查性质</td><td><i>无意见</i></td></tr><tr><td><code>defaultAllowPrivilegeEscalation</code></td><td>变更性质</td><td><i>无意见（非变更性质）</i></td></tr><tr><td><code>allowPrivilegeEscalation</code></td><td>变更性质 & 检查性质</td><td><p><i>只有设置为 <code>false</code> 时才执行变更动作</i></p><p><b>Baseline</b>：无意见</p><p><b>Restricted</b>：<code>false</code></p></td></tr><tr><td><code>allowedHostPaths</code></td><td>检查性质</td><td><i>无意见（volumes 优先）</i></td></tr><tr><td><code>allowedFlexVolumes</code></td><td>检查性质</td><td><i>无意见（volumes 优先）</i></td></tr><tr><td><code>allowedCSIDrivers</code></td><td>检查性质</td><td><i>无意见（volumes 优先）</i></td></tr><tr><td><code>allowedUnsafeSysctls</code></td><td>检查性质</td><td><b>Baseline & Restricted</b>：未定义 / nil / 空</td></tr><tr><td><code>forbiddenSysctls</code></td><td>检查性质</td><td><i>无意见</i></td></tr><tr><td><code>allowedProcMountTypes</code><br><i>(alpha feature)</i></td><td>检查性质</td><td><b>Baseline & Restricted</b>：<code>["Default"]</code> 或者未定义 / nil / 空</td></tr><tr><td><code>runtimeClass</code><br><code>&nbsp;.defaultRuntimeClassName</code></td><td>变更性质</td><td><i>无意见</i></td></tr><tr><td><code>runtimeClass</code><br><code>&nbsp;.allowedRuntimeClassNames</code></td><td>检查性质</td><td><i>无意见</i></td></tr></tbody></table><h2 id=podsecuritypolicy-annotations>PodSecurityPolicy 注解</h2><p>下面表格中所列举的<a href=/zh-cn/docs/concepts/overview/working-with-objects/annotations/>注解</a>可以通过
<code>.metadata.annotations</code> 设置到 PodSecurityPolicy 对象之上。</p><table class=no-word-break><caption style=display:none>将 PodSecurityPolicy 注解映射到 Pod 安全性标准</caption><tbody><tr><th><code>PSP 注解</code></th><th>类型</th><th>Pod 安全性标准中对应设置</th></tr><tr><td><code>seccomp.security.alpha.kubernetes.io</code><br><code>/defaultProfileName</code></td><td>变更性质</td><td><i>无意见</i></td></tr><tr><td><code>seccomp.security.alpha.kubernetes.io</code><br><code>/allowedProfileNames</code></td><td>检查性质</td><td><p><b>Baseline</b>：<code>"runtime/default,"</code> <i>（其中尾部的逗号允许取消设置）</i></p><p><b>Restricted</b>：<code>"runtime/default"</code> <i>（没有尾部逗号）</i></p><p><i><code>localhost/*</code> 取值对于 Baseline 和 Restricted 都是可接受的</i></p></td></tr><tr><td><code>apparmor.security.beta.kubernetes.io</code><br><code>/defaultProfileName</code></td><td>变更性质</td><td><i>无意见</i></td></tr><tr><td><code>apparmor.security.beta.kubernetes.io</code><br><code>/allowedProfileNames</code></td><td>检查性质</td><td><p><b>Baseline</b>：<code>"runtime/default,"</code> <i>（其中尾部的逗号允许取消设置）</i></p><p><b>Restricted</b>：<code>"runtime/default"</code> <i>（没有尾部逗号）</i></p><p><i><code>localhost/*</code> 取值对于 Baseline 和 Restricted 都是可接受的</i></p></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-215c25173044b8f97e9b0494b0c7e53f>12 - Webhook 模式</h1><p>WebHook 是一种 HTTP 回调：某些条件下触发的 HTTP POST 请求；通过 HTTP POST
发送的简单事件通知。一个基于 web 应用实现的 WebHook 会在特定事件发生时把消息发送给特定的 URL。</p><p>具体来说，当在判断用户权限时，<code>Webhook</code> 模式会使 Kubernetes 查询外部的 REST 服务。</p><h2 id=configuration-file-format>配置文件格式</h2><p><code>Webhook</code> 模式需要一个 HTTP 配置文件，通过
<code>--authorization-webhook-config-file=SOME_FILENAME</code> 的参数声明。</p><p>配置文件的格式使用
<a href=/zh-cn/docs/tasks/access-application-cluster/configure-access-multiple-clusters/>kubeconfig</a>。
在该文件中，“users” 代表着 API 服务器的 webhook，而 “cluster” 代表着远程服务。</p><p>使用 HTTPS 客户端认证的配置例子：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#080;font-style:italic># Kubernetes API 版本</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># API 对象种类</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># clusters 代表远程服务。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>clusters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>name-of-remote-authz-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 对远程服务进行身份认证的 CA。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>certificate-authority</span>:<span style=color:#bbb> </span>/path/to/ca.pem<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:#080;font-style:italic># 远程服务的查询 URL。必须使用 &#39;https&#39;。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>server</span>:<span style=color:#bbb> </span>https://authz.example.com/authorize<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># users 代表 API 服务器的 webhook 配置</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>users</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>name-of-api-server<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>client-certificate</span>:<span style=color:#bbb> </span>/path/to/cert.pem<span style=color:#bbb> </span><span style=color:#080;font-style:italic># webhook plugin 使用 cert</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>client-key</span>:<span style=color:#bbb> </span>/path/to/key.pem         <span style=color:#bbb> </span><span style=color:#080;font-style:italic># cert 所对应的 key</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#080;font-style:italic># kubeconfig 文件必须有 context。需要提供一个给 API 服务器。</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>current-context</span>:<span style=color:#bbb> </span>webhook<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>contexts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>context</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb> </span>name-of-remote-authz-service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb> </span>name-of-api-server<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>webhook<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=request-payloads>请求载荷</h2><p>在做认证决策时，API 服务器会 POST 一个 JSON 序列化的 <code>authorization.k8s.io/v1beta1</code> <code>SubjectAccessReview</code>
对象来描述这个动作。这个对象包含了描述用户请求的字段，同时也包含了需要被访问资源或请求特征的具体信息。</p><p>需要注意的是 webhook API 对象与其他 Kubernetes API
对象一样都同样都遵从<a href=/zh-cn/docs/concepts/overview/kubernetes-api/>版本兼容规则</a>。
实施人员应该了解 beta 对象的更宽松的兼容性承诺，同时确认请求的 "apiVersion" 字段能被正确地反序列化。
此外，API 服务器还必须启用 <code>authorization.k8s.io/v1beta1</code> API 扩展组 (<code>--runtime-config=authorization.k8s.io/v1beta1=true</code>)。</p><p>一个请求内容的例子：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;authorization.k8s.io/v1beta1&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;SubjectAccessReview&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;spec&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;resourceAttributes&#34;</span>: {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;namespace&#34;</span>: <span style=color:#b44>&#34;kittensandponies&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;verb&#34;</span>: <span style=color:#b44>&#34;get&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;group&#34;</span>: <span style=color:#b44>&#34;unicorn.example.org&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;resource&#34;</span>: <span style=color:#b44>&#34;pods&#34;</span>
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;user&#34;</span>: <span style=color:#b44>&#34;jane&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;group&#34;</span>: [
</span></span><span style=display:flex><span>      <span style=color:#b44>&#34;group1&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:#b44>&#34;group2&#34;</span>
</span></span><span style=display:flex><span>    ]
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>期待远程服务填充请求的 <code>status</code> 字段并响应允许或禁止访问。响应主体的 <code>spec</code> 字段被忽略，可以省略。允许的响应将返回:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;authorization.k8s.io/v1beta1&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;SubjectAccessReview&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;status&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;allowed&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>为了禁止访问，有两种方法。</p><p>在大多数情况下，第一种方法是首选方法，它指示授权 webhook 不允许或对请求 “无意见”。
但是，如果配置了其他授权者，则可以给他们机会允许请求。如果没有其他授权者，或者没有一个授权者，则该请求被禁止。webhook 将返回：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;authorization.k8s.io/v1beta1&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;SubjectAccessReview&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;status&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;allowed&#34;</span>: <span style=color:#a2f;font-weight:700>false</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;reason&#34;</span>: <span style=color:#b44>&#34;user does not have read access to the namespace&#34;</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>第二种方法立即拒绝其他配置的授权者进行短路评估。仅应由对集群的完整授权者配置有详细了解的 webhook 使用。webhook 将返回：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;authorization.k8s.io/v1beta1&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;SubjectAccessReview&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;status&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;allowed&#34;</span>: <span style=color:#a2f;font-weight:700>false</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;denied&#34;</span>: <span style=color:#a2f;font-weight:700>true</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;reason&#34;</span>: <span style=color:#b44>&#34;user does not have read access to the namespace&#34;</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>对于非资源的路径访问是这么发送的:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;authorization.k8s.io/v1beta1&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;SubjectAccessReview&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;spec&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;nonResourceAttributes&#34;</span>: {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;path&#34;</span>: <span style=color:#b44>&#34;/debug&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;verb&#34;</span>: <span style=color:#b44>&#34;get&#34;</span>
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;user&#34;</span>: <span style=color:#b44>&#34;jane&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;group&#34;</span>: [
</span></span><span style=display:flex><span>      <span style=color:#b44>&#34;group1&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:#b44>&#34;group2&#34;</span>
</span></span><span style=display:flex><span>    ]
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>非资源类的路径包括：<code>/api</code>、<code>/apis</code>、<code>/metrics</code>、<code>/logs</code>、<code>/debug</code>、
<code>/healthz</code>、<code>/livez</code>、<code>/openapi/v2</code>、<code>/readyz</code>、和 <code>/version</code>。
客户端需要访问 <code>/api</code>、<code>/api/*</code>、<code>/apis</code>、<code>/apis/*</code> 和 <code>/version</code> 以便
能发现服务器上有什么资源和版本。对于其他非资源类的路径访问在没有 REST API 访问限制的情况下拒绝。</p><p>更多信息可以参考 authorization.v1beta1 API 对象和
<a href=https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apiserver/plugin/pkg/authorizer/webhook/webhook.go>webhook.go</a>。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-36e1423f0b5caa8eafeb6f53c175d13c>13 - Kubelet 认证/鉴权</h1><h2 id=overview>概述</h2><p>kubelet 的 HTTPS 端点公开了 API，
这些 API 可以访问敏感度不同的数据，
并允许你在节点上和容器内以不同级别的权限执行操作。</p><p>本文档介绍了如何对 kubelet 的 HTTPS 端点的访问进行认证和鉴权。</p><h2 id=kubelet-authentication>Kubelet 身份认证</h2><p>默认情况下，未被已配置的其他身份认证方法拒绝的对 kubelet 的 HTTPS 端点的请求会被视为匿名请求，
并被赋予 <code>system:anonymous</code> 用户名和 <code>system:unauthenticated</code> 组。</p><p>要禁用匿名访问并向未经身份认证的请求发送 <code>401 Unauthorized</code> 响应，请执行以下操作：</p><ul><li>带 <code>--anonymous-auth=false</code> 标志启动 kubelet</li></ul><p>要对 kubelet 的 HTTPS 端点启用 X509 客户端证书认证：</p><ul><li>带 <code>--client-ca-file</code> 标志启动 kubelet，提供一个 CA 证书包以供验证客户端证书</li><li>带 <code>--kubelet-client-certificate</code> 和 <code>--kubelet-client-key</code> 标志启动 API 服务器</li><li>有关更多详细信息，请参见
<a href=/zh-cn/docs/reference/access-authn-authz/authentication/#x509-client-certs>API 服务器身份验证文档</a></li></ul><p>要启用 API 持有者令牌（包括服务帐户令牌）以对 kubelet 的 HTTPS 端点进行身份验证，请执行以下操作：</p><ul><li>确保在 API 服务器中启用了 <code>authentication.k8s.io/v1beta1</code> API 组</li><li>带 <code>--authentication-token-webhook</code> 和 <code>--kubeconfig</code> 标志启动 kubelet</li><li>kubelet 调用已配置的 API 服务器上的 <code>TokenReview</code> API，以根据持有者令牌确定用户信息</li></ul><h2 id=kubelet-authorization>Kubelet 鉴权</h2><p>任何成功通过身份验证的请求（包括匿名请求）之后都会被鉴权。
默认的鉴权模式为 <code>AlwaysAllow</code>，它允许所有请求。</p><p>细分对 kubelet API 的访问权限可能有多种原因：</p><ul><li>启用了匿名身份验证，但是应限制匿名用户调用 kubelet API 的能力</li><li>启用了持有者令牌认证，但应限制任意 API 用户（如服务帐户）调用 kubelet API 的能力</li><li>启用了客户端证书身份验证，但仅应允许已配置的 CA 签名的某些客户端证书使用 kubelet API</li></ul><p>要细分对 kubelet API 的访问权限，请将鉴权委派给 API 服务器：</p><ul><li>确保在 API 服务器中启用了 <code>authorization.k8s.io/v1beta1</code> API 组</li><li>带 <code>--authorization-mode=Webhook</code> 和 <code>--kubeconfig</code> 标志启动 kubelet</li><li>kubelet 调用已配置的 API 服务器上的 <code>SubjectAccessReview</code> API，
以确定每个请求是否得到鉴权</li></ul><p>kubelet 使用与 API 服务器相同的
<a href=/zh-cn/docs/reference/access-authn-authz/authorization/#review-your-request-attributes>请求属性</a>
方法对 API 请求执行鉴权。</p><p>请求的动词根据传入请求的 HTTP 动词确定：</p><table><thead><tr><th>HTTP 动词</th><th>请求动词</th></tr></thead><tbody><tr><td>POST</td><td>create</td></tr><tr><td>GET, HEAD</td><td>get</td></tr><tr><td>PUT</td><td>update</td></tr><tr><td>PATCH</td><td>patch</td></tr><tr><td>DELETE</td><td>delete</td></tr></tbody></table><p>资源和子资源是根据传入请求的路径确定的：</p><table><thead><tr><th>Kubelet API</th><th>资源</th><th>子资源</th></tr></thead><tbody><tr><td>/stats/*</td><td>nodes</td><td>stats</td></tr><tr><td>/metrics/*</td><td>nodes</td><td>metrics</td></tr><tr><td>/logs/*</td><td>nodes</td><td>log</td></tr><tr><td>/spec/*</td><td>nodes</td><td>spec</td></tr><tr><td><strong>其它所有</strong></td><td>nodes</td><td>proxy</td></tr></tbody></table><p>名字空间和 API 组属性始终是空字符串，
资源名称始终是 kubelet 的 <code>Node</code> API 对象的名称。</p><p>在此模式下运行时，请确保传递给 API 服务器的由 <code>--kubelet-client-certificate</code> 和
<code>--kubelet-client-key</code> 标志标识的用户具有以下属性的鉴权：</p><ul><li>verb=*, resource=nodes, subresource=proxy</li><li>verb=*, resource=nodes, subresource=stats</li><li>verb=*, resource=nodes, subresource=log</li><li>verb=*, resource=nodes, subresource=spec</li><li>verb=*, resource=nodes, subresource=metrics</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-d17c42b1760f6d5c333fc91ca9b453f4>14 - TLS 启动引导</h1><p>在一个 Kubernetes 集群中，工作节点上的组件（kubelet 和 kube-proxy）需要与
Kubernetes 控制平面组件通信，尤其是 kube-apiserver。
为了确保通信本身是私密的、不被干扰，并且确保集群的每个组件都在与另一个可信的组件通信，
我们强烈建议使用节点上的客户端 TLS 证书。</p><p>启动引导这些组件的正常过程，尤其是需要证书来与 kube-apiserver 安全通信的工作节点，
可能会是一个具有挑战性的过程，因为这一过程通常不受 Kubernetes 控制，需要不少额外工作。
这也使得初始化或者扩缩一个集群的操作变得具有挑战性。</p><p>为了简化这一过程，从 1.4 版本开始，Kubernetes 引入了一个证书请求和签名 API。
该提案可在<a href=https://github.com/kubernetes/kubernetes/pull/20439>这里</a>看到。</p><p>本文档描述节点初始化的过程，如何为 kubelet 配置 TLS 客户端证书启动引导，
以及其背后的工作原理。</p><h2 id=initialization-process>初始化过程</h2><p>当工作节点启动时，kubelet 执行以下操作：</p><ol><li>寻找自己的 <code>kubeconfig</code> 文件</li><li>检索 API 服务器的 URL 和凭据，通常是来自 <code>kubeconfig</code> 文件中的
TLS 密钥和已签名证书</li><li>尝试使用这些凭据来与 API 服务器通信</li></ol><p>假定 kube-apiserver 成功地认证了 kubelet 的凭据数据，它会将 kubelet
视为一个合法的节点并开始将 Pod 分派给该节点。</p><p>注意，签名的过程依赖于：</p><ul><li><code>kubeconfig</code> 中包含密钥和本地主机的证书</li><li>证书被 kube-apiserver 所信任的一个证书机构（CA）所签名</li></ul><p>负责部署和管理集群的人有以下责任：</p><ol><li>创建 CA 密钥和证书</li><li>将 CA 证书发布到 kube-apiserver 运行所在的控制平面节点上</li><li>为每个 kubelet 创建密钥和证书；强烈建议为每个 kubelet 使用独一无二的、
CN 取值与众不同的密钥和证书</li><li>使用 CA 密钥对 kubelet 证书签名</li><li>将 kubelet 密钥和签名的证书发布到 kubelet 运行所在的特定节点上</li></ol><p>本文中描述的 TLS 启动引导过程有意简化甚至完全自动化上述过程，
尤其是第三步之后的操作，因为这些步骤是初始化或者扩缩集群时最常见的操作。</p><h3 id=bootstrap-initialization>启动引导初始化</h3><p>在启动引导初始化过程中，会发生以下事情：</p><ol><li>kubelet 启动</li><li>kubelet 看到自己<strong>没有</strong>对应的 <code>kubeconfig</code> 文件</li><li>kubelet 搜索并发现 <code>bootstrap-kubeconfig</code> 文件</li><li>kubelet 读取该启动引导文件，从中获得 API 服务器的 URL 和用途有限的一个“令牌（Token）”</li><li>kubelet 建立与 API 服务器的连接，使用上述令牌执行身份认证</li><li>kubelet 现在拥有受限制的凭据来创建和取回证书签名请求（CSR）</li><li>kubelet 为自己创建一个 CSR，并将其 signerName 设置为 <code>kubernetes.io/kube-apiserver-client-kubelet</code></li><li>CSR 被以如下两种方式之一批复：</li></ol><ul><li>如果配置了，kube-controller-manager 会自动批复该 CSR</li><li>如果配置了，一个外部进程，或者是人，使用 Kubernetes API 或者使用 <code>kubectl</code>
来批复该 CSR</li></ul><ol start=9><li>kubelet 所需要的证书被创建</li></ol><ol start=10><li>证书被发放给 kubelet</li><li>kubelet 取回该证书</li><li>kubelet 创建一个合适的 <code>kubeconfig</code>，其中包含密钥和已签名的证书</li><li>kubelet 开始正常操作</li><li>可选地，如果配置了，kubelet 在证书接近于过期时自动请求更新证书</li><li>更新的证书被批复并发放；取决于配置，这一过程可能是自动的或者手动完成</li></ol><p>本文的其余部分描述配置 TLS 启动引导的必要步骤及其局限性。</p><h2 id=configuration>配置</h2><p>要配置 TLS 启动引导及可选的自动批复，你必须配置以下组件的选项：</p><ul><li>kube-apiserver</li><li>kube-controller-manager</li><li>kubelet</li><li>集群内的资源：<code>ClusterRoleBinding</code> 以及可能需要的 <code>ClusterRole</code></li></ul><p>此外，你需要有 Kubernetes 证书机构（Certificate Authority，CA）。</p><h2 id=certificate-authority>证书机构</h2><p>就像在没有 TLS 启动引导支持的情况下，你会需要证书机构（CA）密钥和证书。
这些数据会被用来对 kubelet 证书进行签名。
如前所述，将证书机构密钥和证书发布到控制平面节点是你的责任。</p><p>就本文而言，我们假定这些数据被发布到控制平面节点上的 <code>/var/lib/kubernetes/ca.pem</code>（证书）和
<code>/var/lib/kubernetes/ca-key.pem</code>（密钥）文件中。
我们将这两个文件称作“Kubernetes CA 证书和密钥”。
所有 Kubernetes 组件（kubelet、kube-apiserver、kube-controller-manager）
都使用这些凭据，并假定这里的密钥和证书都是 PEM 编码的。</p><h2 id=kube-apiserver-configuration>kube-apiserver 配置</h2><p>启用 TLS 启动引导对 kube-apiserver 有若干要求：</p><ul><li>能够识别对客户端证书进行签名的 CA</li><li>能够对启动引导的 kubelet 执行身份认证，并将其置入 <code>system:bootstrappers</code> 组</li><li>能够对启动引导的 kubelet 执行鉴权操作，允许其创建证书签名请求（CSR）</li></ul><h3 id=recognizing-client-certificates>识别客户证书</h3><p>对于所有客户端证书的认证操作而言，这是很常见的。
如果还没有设置，要为 kube-apiserver 命令添加 <code>--client-ca-file=FILENAME</code>
标志来启用客户端证书认证，在标志中引用一个包含用来签名的证书的证书机构包，
例如：<code>--client-ca-file=/var/lib/kubernetes/ca.pem</code>。</p><h3 id=initial-bootstrap-authentication>初始启动引导认证</h3><p>为了让启动引导的 kubelet 能够连接到 kube-apiserver 并请求证书，
它必须首先在服务器上认证自身身份。你可以使用任何一种能够对 kubelet
执行身份认证的<a href=/zh-cn/docs/reference/access-authn-authz/authentication/>身份认证组件</a>。</p><p>尽管所有身份认证策略都可以用来对 kubelet 的初始启动凭据来执行认证，
出于容易准备的因素，建议使用如下两个身份认证组件：</p><ol><li><a href=#bootstrap-tokens>启动引导令牌（Bootstrap Token）</a></li><li><a href=#token-authentication-file>令牌认证文件</a></li></ol><p>启动引导令牌是一种对 kubelet 进行身份认证的方法，相对简单且容易管理，
且不需要在启动 kube-apiserver 时设置额外的标志。</p><p>无论选择哪种方法，这里的需求是 kubelet 能够被身份认证为某个具有如下权限的用户：</p><ol><li>创建和读取 CSR</li><li>在启用了自动批复时，能够在请求节点客户端证书时得到自动批复</li></ol><p>使用启动引导令牌执行身份认证的 kubelet 会被认证为 <code>system:bootstrappers</code>
组中的用户。这是使用启动引导令牌的一种标准方法。</p><p>随着这个功能特性的逐渐成熟，你需要确保令牌绑定到某基于角色的访问控制（RBAC）
策略上，从而严格限制请求（使用<a href=/zh-cn/docs/reference/access-authn-authz/bootstrap-tokens/>启动引导令牌</a>）
仅限于客户端申请提供证书。当 RBAC 被配置启用时，可以将令牌限制到某个组，
从而提高灵活性。例如，你可以在准备节点期间禁止某特定启动引导组的访问。</p><h4 id=bootstrap-tokens>启动引导令牌</h4><p>启动引导令牌的细节在<a href=/zh-cn/docs/reference/access-authn-authz/bootstrap-tokens/>这里</a>
详述。启动引导令牌在 Kubernetes 集群中存储为 Secret 对象，被发放给各个 kubelet。
你可以在整个集群中使用同一个令牌，也可以为每个节点发放单独的令牌。</p><p>这一过程有两个方面：</p><ol><li>基于令牌 ID、机密数据和范畴信息创建 Kubernetes Secret</li><li>将令牌发放给 kubelet</li></ol><p>从 kubelet 的角度，所有令牌看起来都很像，没有特别的含义。
从 kube-apiserver 服务器的角度，启动引导令牌是很特殊的。
根据其 <code>type</code>、<code>namespace</code> 和 <code>name</code>，kube-apiserver 能够将其认作特殊的令牌，
并授予携带该令牌的任何人特殊的启动引导权限，换言之，将其视为
<code>system:bootstrappers</code> 组的成员。这就满足了 TLS 启动引导的基本需求。</p><p>关于创建 Secret 的进一步细节可访问<a href=/zh-cn/docs/reference/access-authn-authz/bootstrap-tokens/>这里</a>。</p><p>如果你希望使用启动引导令牌，你必须在 kube-apiserver 上使用下面的标志启用之：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#888>--enable-bootstrap-token-auth=true
</span></span></span></code></pre></div><h4 id=token-authentication-file>令牌认证文件</h4><p>kube-apiserver 能够将令牌视作身份认证依据。
这些令牌可以是任意数据，但必须表示为基于某安全的随机数生成器而得到的至少
128 位混沌数据。这里的随机数生成器可以是现代 Linux 系统上的
<code>/dev/urandom</code>。生成令牌的方式有很多种。例如：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>head -c <span style=color:#666>16</span> /dev/urandom | od -An -t x | tr -d <span style=color:#b44>&#39; &#39;</span>
</span></span></code></pre></div><p>上面的命令会生成类似于 <code>02b50b05283e98dd0fd71db496ef01e8</code> 这样的令牌。</p><p>令牌文件看起来是下面的例子这样，其中前面三个值可以是任何值，
用引号括起来的组名称则只能用例子中给的值。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#888>02b50b05283e98dd0fd71db496ef01e8,kubelet-bootstrap,10001,&#34;system:bootstrappers&#34;
</span></span></span></code></pre></div><p>向 kube-apiserver 添加 <code>--token-auth-file=FILENAME</code> 标志（或许这要对 systemd
的单元文件作修改）以启用令牌文件。有关进一步细节的文档，
可参见<a href=/zh-cn/docs/reference/access-authn-authz/authentication/#static-token-file>这里</a>。</p><h3 id=authorize-kubelet-to-create-csr>授权 kubelet 创建 CSR</h3><p>现在启动引导节点被 <strong>身份认证</strong> 为 <code>system:bootstrapping</code> 组的成员，
它需要被 <strong>授权</strong> 创建证书签名请求（CSR）并在证书被签名之后将其取回。
幸运的是，Kubernetes 提供了一个 <code>ClusterRole</code>，其中精确地封装了这些许可，
<code>system:node-bootstrapper</code>。</p><p>为了实现这一点，你只需要创建 <code>ClusterRoleBinding</code>，将 <code>system:bootstrappers</code>
组绑定到集群角色 <code>system:node-bootstrapper</code>。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#080;font-style:italic># 允许启动引导节点创建 CSR</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRoleBinding<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>create-csrs-for-bootstrapping<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Group<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:bootstrappers<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>roleRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:node-bootstrapper<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=kube-controller-manager-configuration>kube-controller-manager 配置</h2><p>API 服务器从 kubelet 收到证书请求并对这些请求执行身份认证，
但真正负责发放签名证书的是控制器管理器（controller-manager）。</p><p>控制器管理器通过一个证书发放的控制回路来执行此操作。该操作的执行方式是使用磁盘上的文件用
<a href=https://blog.cloudflare.com/introducing-cfssl/>cfssl</a> 本地签名组件来完成。
目前，所发放的所有证书都有一年的有效期，并设定了默认的一组密钥用法。</p><p>为了让控制器管理器对证书签名，它需要：</p><ul><li>能够访问你之前所创建并分发的 “Kubernetes CA 密钥和证书”</li><li>启用 CSR 签名</li></ul><h3 id=access-to-key-and-certificate>访问密钥和证书</h3><p>如前所述，你需要创建一个 Kubernetes CA 密钥和证书，并将其发布到控制平面节点。
这些数据会被控制器管理器来对 kubelet 证书进行签名。</p><p>由于这些被签名的证书反过来会被 kubelet 用来在 kube-apiserver 执行普通的
kubelet 身份认证，很重要的一点是为控制器管理器所提供的 CA 也被 kube-apiserver
信任用来执行身份认证。CA 密钥和证书是通过 kube-apiserver 的标志
<code>--client-ca-file=FILENAME</code>（例如，<code>--client-ca-file=/var/lib/kubernetes/ca.pem</code>），
来设定的，正如 kube-apiserver 配置节所述。</p><p>要将 Kubernetes CA 密钥和证书提供给 kube-controller-manager，可使用以下标志：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>--cluster-signing-cert-file<span style=color:#666>=</span><span style=color:#b44>&#34;/etc/path/to/kubernetes/ca/ca.crt&#34;</span> --cluster-signing-key-file<span style=color:#666>=</span><span style=color:#b44>&#34;/etc/path/to/kubernetes/ca/ca.key&#34;</span>
</span></span></code></pre></div><p>例如：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>--cluster-signing-cert-file<span style=color:#666>=</span><span style=color:#b44>&#34;/var/lib/kubernetes/ca.pem&#34;</span> --cluster-signing-key-file<span style=color:#666>=</span><span style=color:#b44>&#34;/var/lib/kubernetes/ca-key.pem&#34;</span>
</span></span></code></pre></div><p>所签名的证书的合法期限可以通过下面的标志来配置：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>--cluster-signing-duration
</span></span></code></pre></div><h3 id=approval>批复</h3><p>为了对 CSR 进行批复，你需要告诉控制器管理器批复这些 CSR 是可接受的。
这是通过将 RBAC 访问权限授予正确的组来实现的。</p><p>许可权限有两组：</p><ul><li><code>nodeclient</code>：如果节点在为节点创建新的证书，则该节点还没有证书。
该节点使用前文所列的令牌之一来执行身份认证，因此是组 <code>system:bootstrappers</code> 组的成员。</li><li><code>selfnodeclient</code>：如果节点在对证书执行续期操作，则该节点已经拥有一个证书。
节点持续使用现有的证书将自己认证为 <code>system:nodes</code> 组的成员。</li></ul><p>要允许 kubelet 请求并接收新的证书，可以创建一个 <code>ClusterRoleBinding</code>
将启动引导节点所处的组 <code>system:bootstrappers</code> 绑定到为其赋予访问权限的 <code>ClusterRole</code>
<code>system:certificates.k8s.io:certificatesigningrequests:nodeclient</code>：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#080;font-style:italic># 批复 &#34;system:bootstrappers&#34; 组的所有 CSR</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRoleBinding<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>auto-approve-csrs-for-group<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Group<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:bootstrappers<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>roleRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:certificates.k8s.io:certificatesigningrequests:nodeclient<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></span></span></code></pre></div><p>要允许 kubelet 对其客户端证书执行续期操作，可以创建一个 <code>ClusterRoleBinding</code>
将正常工作的节点所处的组 <code>system:nodes</code> 绑定到为其授予访问许可的 <code>ClusterRole</code>
<code>system:certificates.k8s.io:certificatesigningrequests:selfnodeclient</code>：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#080;font-style:italic># 批复 &#34;system:nodes&#34; 组的 CSR 续约请求</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRoleBinding<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>auto-approve-renewals-for-nodes<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>subjects</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Group<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:nodes<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>roleRef</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>system:certificates.k8s.io:certificatesigningrequests:selfnodeclient<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>apiGroup</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io<span style=color:#bbb>
</span></span></span></code></pre></div><p>作为 <a href=/zh-cn/docs/reference/command-line-tools-reference/kube-controller-manager/>kube-controller-manager</a>
的一部分的 <code>csrapproving</code> 控制器是自动被启用的。
该控制器使用 <a href=/zh-cn/docs/reference/access-authn-authz/authorization/#checking-api-access><code>SubjectAccessReview</code> API</a>
来确定给定用户是否被授权请求 CSR，之后基于鉴权结果执行批复操作。
为了避免与其它批复组件发生冲突，内置的批复组件不会显式地拒绝任何 CSRs。
该组件仅是忽略未被授权的请求。
控制器也会作为垃圾收集的一部分清除已过期的证书。</p><h2 id=kubelet-configuration>kubelet 配置</h2><p>最后，当控制平面节点被正确配置并且所有必要的身份认证和鉴权机制都就绪时，
我们可以配置 kubelet。</p><p>kubelet 需要以下配置来执行启动引导：</p><ul><li>一个用来存储所生成的密钥和证书的路径（可选，可以使用默认配置）</li><li>一个用来指向尚不存在的 <code>kubeconfig</code> 文件的路径；kubelet 会将启动引导配置文件放到这个位置</li><li>一个指向启动引导 <code>kubeconfig</code> 文件的路径，用来提供 API 服务器的 URL 和启动引导凭据，
例如，启动引导令牌</li><li>可选的：轮换证书的指令</li></ul><p>启动引导 <code>kubeconfig</code> 文件应该放在一个 kubelet 可访问的路径下，例如
<code>/var/lib/kubelet/bootstrap-kubeconfig</code>。</p><p>其格式与普通的 <code>kubeconfig</code> 文件完全相同。实例文件可能看起来像这样：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Config<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>clusters</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>certificate-authority</span>:<span style=color:#bbb> </span>/var/lib/kubernetes/ca.pem<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>server</span>:<span style=color:#bbb> </span>https://my.server.example.com:6443<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>bootstrap<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>contexts</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>context</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>cluster</span>:<span style=color:#bbb> </span>bootstrap<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb> </span>kubelet-bootstrap<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>bootstrap<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>current-context</span>:<span style=color:#bbb> </span>bootstrap<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>preferences</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>users</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>kubelet-bootstrap<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>user</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>token</span>:<span style=color:#bbb> </span>07401b.f395accd246ae52d<span style=color:#bbb>
</span></span></span></code></pre></div><p>需要额外注意的一些因素有：</p><ul><li><code>certificate-authority</code>：指向 CA 文件的路径，用来对 kube-apiserver 所出示的服务器证书进行验证</li><li><code>server</code>：用来访问 kube-apiserver 的 URL</li><li><code>token</code>：要使用的令牌</li></ul><p>令牌的格式并不重要，只要它与 kube-apiserver 的期望匹配即可。
在上面的例子中，我们使用的是启动引导令牌。
如前所述，任何合法的身份认证方法都可以使用，不限于令牌。</p><p>因为启动引导 <code>kubeconfig</code> 文件是一个标准的 <code>kubeconfig</code> 文件，你可以使用
<code>kubectl</code> 来生成该文件。要生成上面的示例文件：</p><pre tabindex=0><code>kubectl config --kubeconfig=/var/lib/kubelet/bootstrap-kubeconfig set-cluster bootstrap --server=&#39;https://my.server.example.com:6443&#39; --certificate-authority=/var/lib/kubernetes/ca.pem
kubectl config --kubeconfig=/var/lib/kubelet/bootstrap-kubeconfig set-credentials kubelet-bootstrap --token=07401b.f395accd246ae52d
kubectl config --kubeconfig=/var/lib/kubelet/bootstrap-kubeconfig set-context bootstrap --user=kubelet-bootstrap --cluster=bootstrap
kubectl config --kubeconfig=/var/lib/kubelet/bootstrap-kubeconfig use-context bootstrap
</code></pre><p>要指示 kubelet 使用启动引导 <code>kubeconfig</code> 文件，可以使用下面的 kubelet 标志：</p><pre tabindex=0><code>--bootstrap-kubeconfig=&#34;/var/lib/kubelet/bootstrap-kubeconfig&#34; --kubeconfig=&#34;/var/lib/kubelet/kubeconfig&#34;
</code></pre><p>在启动 kubelet 时，如果 <code>--kubeconfig</code> 标志所指定的文件并不存在，会使用通过标志
<code>--bootstrap-kubeconfig</code> 所指定的启动引导 kubeconfig 配置来向 API 服务器请求客户端证书。
在证书请求被批复并被 kubelet 收回时，一个引用所生成的密钥和所获得证书的 kubeconfig
文件会被写入到通过 <code>--kubeconfig</code> 所指定的文件路径下。
证书和密钥文件会被放到 <code>--cert-dir</code> 所指定的目录中。</p><h3 id=client-and-serving-certificates>客户和服务证书</h3><p>前文所述的内容都与 kubelet <strong>客户端</strong>证书相关，尤其是 kubelet 用来向
kube-apiserver 认证自身身份的证书。</p><p>kubelet 也可以使用 <strong>服务（Serving）</strong> 证书。kubelet 自身向外提供一个 HTTPS 末端，
包含若干功能特性。要保证这些末端的安全性，kubelet 可以执行以下操作之一：</p><ul><li>使用通过 <code>--tls-private-key-file</code> 和 <code>--tls-cert-file</code> 所设置的密钥和证书</li><li>如果没有提供密钥和证书，则创建自签名的密钥和证书</li><li>通过 CSR API 从集群服务器请求服务证书</li></ul><p>TLS 启动引导所提供的客户端证书默认被签名为仅用于 <code>client auth</code>（客户端认证），
因此不能作为提供服务的证书，或者 <code>server auth</code>。</p><p>不过，你可以启用服务器证书，至少可以部分地通过证书轮换来实现这点。</p><h3 id=certificate-rotation>证书轮换</h3><p>Kubernetes v1.8 和更高版本的 kubelet 实现了对客户端证书与/或服务证书进行轮换
这一 Beta 特性。这一特性通过 kubelet 对应的 <code>RotateKubeletClientCertificate</code> 和
<code>RotateKubeletServerCertificate</code> 特性门控标志来控制，并且是默认启用的。</p><p><code>RotateKubeletClientCertificate</code> 会导致 kubelet 在其现有凭据即将过期时通过创建新的
CSR 来轮换其客户端证书。要启用此功能特性，可将下面的标志传递给 kubelet：</p><pre tabindex=0><code>--rotate-certificates
</code></pre><p><code>RotateKubeletServerCertificate</code> 会让 kubelet 在启动引导其客户端凭据之后请求一个服务证书
<strong>且</strong> 对该服务证书执行轮换操作。要启用此功能特性，将下面的标志传递给 kubelet：</p><pre tabindex=0><code>--rotate-server-certificates
</code></pre><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>出于<a href=https://github.com/kubernetes/community/pull/1982>安全原因</a>，Kubernetes 核心中所实现的
CSR 批复控制器并不会自动批复节点的<strong>服务</strong>证书。
要使用 <code>RotateKubeletServerCertificate</code> 功能特性，
集群运维人员需要运行一个定制的控制器或者手动批复服务证书的请求。</p><p>对 kubelet 服务证书的批复过程因集群部署而异，通常应该仅批复如下 CSR：</p><ol><li>由节点发出的请求（确保 <code>spec.username</code> 字段形式为 <code>system:node:&lt;nodeName></code>
且 <code>spec.groups</code> 包含 <code>system:nodes</code>）</li><li>请求中包含服务证书用法（确保 <code>spec.usages</code> 中包含 <code>server auth</code>，可选地也可包含
<code>digital signature</code> 和 <code>key encipherment</code>，且不包含其它用法）</li><li>仅包含隶属于请求节点的 IP 和 DNS 的 <code>subjectAltNames</code>，没有 URI 和 Email
形式的 <code>subjectAltNames</code>（解析 <code>spec.request</code> 中的 x509 证书签名请求可以检查
<code>subjectAltNames</code>）</li></ol></div><h2 id=other-authenticating-components>其它身份认证组件</h2><p>本文所描述的所有 TLS 启动引导内容都与 kubelet 相关。不过，其它组件也可能需要直接与
kube-apiserver 直接通信。容易想到的是 kube-proxy，同样隶属于
Kubernetes 的节点组件并且运行在所有节点之上，不过也可能包含一些其它负责监控或者联网的组件。</p><p>与 kubelet 类似，这些其它组件也需要一种向 kube-apiserver 认证身份的方法。
你可以用几种方法来生成这类凭据：</p><ul><li>较老的方式：和 kubelet 在 TLS 启动引导之前所做的一样，用类似的方式创建和分发证书。</li><li>DaemonSet：由于 kubelet 自身被加载到所有节点之上，并且有足够能力来启动基本服务，
你可以运行将 kube-proxy 和其它特定节点的服务作为 <code>kube-system</code> 名字空间中的
DaemonSet 来执行，而不是独立的进程。由于 DaemonSet 位于集群内部，
你可以为其指派一个合适的服务账户，使之具有适当的访问权限来完成其使命。
这也许是配置此类服务的最简单的方法。</li></ul><h2 id=kubectl-approval>kubectl 批复</h2><p>CSRs 可以在控制器管理其内置的批复工作流之外被批复。</p><p>签名控制器并不会立即对所有证书请求执行签名操作。相反，
它会等待这些请求被某具有适当特权的用户标记为 “Approved（已批准）”状态。
这一流程有意允许由外部批复控制器来自动执行的批复，
或者由控制器管理器内置的批复控制器来自动批复。
不过，集群管理员也可以使用 <code>kubectl</code> 来手动批准证书请求。
管理员可以通过 <code>kubectl get csr</code> 来列举所有的 CSR，使用
<code>kubectl descsribe csr &lt;name></code> 来描述某个 CSR 的细节。
管理员可以使用 <code>kubectl certificate approve &lt;name</code> 来批准某 CSR，或者
<code>kubectl certificate deny &lt;name></code> 来拒绝某 CSR。</p></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/zh-cn/docs/home/>主页</a>
<a class=text-white href=/zh-cn/blog/>博客</a>
<a class=text-white href=/zh-cn/training/>培训</a>
<a class=text-white href=/zh-cn/partners/>合作伙伴</a>
<a class=text-white href=/zh-cn/community/>社区</a>
<a class=text-white href=/zh-cn/case-studies/>案例分析</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 The Kubernetes 作者 | 文档发布基于 <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a> 授权许可</small><br><small class=text-white>Copyright &copy; 2023 Linux 基金会&reg;。保留所有权利。Linux 基金会已注册并使用商标。如需了解 Linux 基金会的商标列表，请访问<a href=https://www.linuxfoundation.org/trademark-usage class=light-text>商标使用页面</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>