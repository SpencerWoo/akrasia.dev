<!doctype html><html lang=zh-cn class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=en href=https://kubernetes.io/docs/reference/kubectl/><link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/reference/kubectl/><link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/reference/kubectl/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/reference/kubectl/><link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/reference/kubectl/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/reference/kubectl/><link rel=alternate hreflang=pt-br href=https://kubernetes.io/pt-br/docs/reference/kubectl/><link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/reference/kubectl/><link rel=alternate hreflang=ru href=https://kubernetes.io/ru/docs/reference/kubectl/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/zh-cn/docs/reference/kubectl/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>命令行工具 (kubectl) | Kubernetes</title><meta property="og:title" content="命令行工具 (kubectl)"><meta property="og:description" content="生产级别的容器编排系统"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/zh-cn/docs/reference/kubectl/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="命令行工具 (kubectl)"><meta itemprop=description content="生产级别的容器编排系统"><meta name=twitter:card content="summary"><meta name=twitter:title content="命令行工具 (kubectl)"><meta name=twitter:description content="生产级别的容器编排系统"><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content="Kubernetes 提供 kubectl 是使用 Kubernetes API 与 Kubernetes 集群的控制面进行通信的命令行工具。
这个工具叫做 kubectl。
针对配置信息，kubectl 在 $HOME/.kube 目录中查找一个名为 config 的配置文件。 你可以通过设置 KUBECONFIG 环境变量或设置 --kubeconfig
参数来指定其它 kubeconfig 文件。
本文概述了 kubectl 语法和命令操作描述，并提供了常见的示例。 有关每个命令的详细信息，包括所有受支持的参数和子命令， 请参阅 kubectl 参考文档。
有关安装说明，请参见安装 kubectl； 如需快速指南，请参见备忘单。 如果你更习惯使用 docker 命令行工具， Docker 用户的 kubectl 介绍了一些 Kubernetes 的等价命令。
语法 使用以下语法从终端窗口运行 kubectl 命令：
kubectl [command] [TYPE] [NAME] [flags] 其中 command、TYPE、NAME 和 flags 分别是：
command：指定要对一个或多个资源执行的操作，例如 create、get、describe、delete。
TYPE：指定资源类型。资源类型不区分大小写， 可以指定单数、复数或缩写形式。例如，以下命令输出相同的结果：
kubectl get pod pod1 kubectl get pods pod1 kubectl get po pod1 NAME：指定资源的名称。名称区分大小写。 如果省略名称，则显示所有资源的详细信息。例如：kubectl get pods。"><meta property="og:description" content="Kubernetes 提供 kubectl 是使用 Kubernetes API 与 Kubernetes 集群的控制面进行通信的命令行工具。
这个工具叫做 kubectl。
针对配置信息，kubectl 在 $HOME/.kube 目录中查找一个名为 config 的配置文件。 你可以通过设置 KUBECONFIG 环境变量或设置 --kubeconfig
参数来指定其它 kubeconfig 文件。
本文概述了 kubectl 语法和命令操作描述，并提供了常见的示例。 有关每个命令的详细信息，包括所有受支持的参数和子命令， 请参阅 kubectl 参考文档。
有关安装说明，请参见安装 kubectl； 如需快速指南，请参见备忘单。 如果你更习惯使用 docker 命令行工具， Docker 用户的 kubectl 介绍了一些 Kubernetes 的等价命令。
语法 使用以下语法从终端窗口运行 kubectl 命令：
kubectl [command] [TYPE] [NAME] [flags] 其中 command、TYPE、NAME 和 flags 分别是：
command：指定要对一个或多个资源执行的操作，例如 create、get、describe、delete。
TYPE：指定资源类型。资源类型不区分大小写， 可以指定单数、复数或缩写形式。例如，以下命令输出相同的结果：
kubectl get pod pod1 kubectl get pods pod1 kubectl get po pod1 NAME：指定资源的名称。名称区分大小写。 如果省略名称，则显示所有资源的详细信息。例如：kubectl get pods。"><meta name=twitter:description content="Kubernetes 提供 kubectl 是使用 Kubernetes API 与 Kubernetes 集群的控制面进行通信的命令行工具。
这个工具叫做 kubectl。
针对配置信息，kubectl 在 $HOME/.kube 目录中查找一个名为 config 的配置文件。 你可以通过设置 KUBECONFIG 环境变量或设置 --kubeconfig
参数来指定其它 kubeconfig 文件。
本文概述了 kubectl 语法和命令操作描述，并提供了常见的示例。 有关每个命令的详细信息，包括所有受支持的参数和子命令， 请参阅 kubectl 参考文档。
有关安装说明，请参见安装 kubectl； 如需快速指南，请参见备忘单。 如果你更习惯使用 docker 命令行工具， Docker 用户的 kubectl 介绍了一些 Kubernetes 的等价命令。
语法 使用以下语法从终端窗口运行 kubectl 命令：
kubectl [command] [TYPE] [NAME] [flags] 其中 command、TYPE、NAME 和 flags 分别是：
command：指定要对一个或多个资源执行的操作，例如 create、get、describe、delete。
TYPE：指定资源类型。资源类型不区分大小写， 可以指定单数、复数或缩写形式。例如，以下命令输出相同的结果：
kubectl get pod pod1 kubectl get pods pod1 kubectl get po pod1 NAME：指定资源的名称。名称区分大小写。 如果省略名称，则显示所有资源的详细信息。例如：kubectl get pods。"><meta property="og:url" content="https://kubernetes.io/zh-cn/docs/reference/kubectl/"><meta property="og:title" content="命令行工具 (kubectl)"><meta name=twitter:title content="命令行工具 (kubectl)"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/zh-cn/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/zh-cn/docs/>文档</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/zh-cn/blog/>Kubernetes 博客</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/zh-cn/training/>培训</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/zh-cn/partners/>合作伙伴</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/zh-cn/community/>社区</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/zh-cn/case-studies/>案例分析</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>版本列表</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/zh-cn/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/zh-cn/docs/reference/kubectl/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/zh-cn/docs/reference/kubectl/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/zh-cn/docs/reference/kubectl/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/zh-cn/docs/reference/kubectl/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/zh-cn/docs/reference/kubectl/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>中文 (Chinese)</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/docs/reference/kubectl/>English</a>
<a class=dropdown-item href=/ko/docs/reference/kubectl/>한국어 (Korean)</a>
<a class=dropdown-item href=/ja/docs/reference/kubectl/>日本語 (Japanese)</a>
<a class=dropdown-item href=/fr/docs/reference/kubectl/>Français (French)</a>
<a class=dropdown-item href=/de/docs/reference/kubectl/>Deutsch (German)</a>
<a class=dropdown-item href=/es/docs/reference/kubectl/>Español (Spanish)</a>
<a class=dropdown-item href=/pt-br/docs/reference/kubectl/>Português (Portuguese)</a>
<a class=dropdown-item href=/id/docs/reference/kubectl/>Bahasa Indonesia</a>
<a class=dropdown-item href=/ru/docs/reference/kubectl/>Русский (Russian)</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>这是本节的多页打印视图。
<a href=# onclick="return print(),!1">点击此处打印</a>.</p><p><a href=/zh-cn/docs/reference/kubectl/>返回本页常规视图</a>.</p></div><h1 class=title>命令行工具 (kubectl)</h1><ul><li>1: <a href=#pg-8aba901ac13f124e5782b90ddb166ee2>kubectl 备忘单</a></li><li>2: <a href=#pg-d7ffbf04ffbefb241fd0722423b80f5a>kubectl 命令</a></li><li>3: <a href=#pg-4d3e62632c189fcc3c1357cd8fb8799c>kubectl</a></li><li>4: <a href=#pg-a938176c695852fe70362c29cf615f1c>JSONPath 支持</a></li><li>5: <a href=#pg-8de6aceb8bf692c06cced446bac5bc92>kubectl 的用法约定</a></li><li>6: <a href=#pg-a7abc09192597e614b58f8b552b682f5>适用于 Docker 用户的 kubectl</a></li></ul><div class=content><p>Kubernetes 提供 kubectl 是使用 Kubernetes API 与 Kubernetes
集群的<a class=glossary-tooltip title='控制平面是指容器编排层，它暴露 API 和接口来定义、部署容器和管理容器的生命周期。' data-toggle=tooltip data-placement=top href='/zh-cn/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label=控制面>控制面</a>进行通信的命令行工具。</p><p>这个工具叫做 <code>kubectl</code>。</p><p>针对配置信息，<code>kubectl</code> 在 <code>$HOME/.kube</code> 目录中查找一个名为 <code>config</code> 的配置文件。
你可以通过设置 <code>KUBECONFIG</code> 环境变量或设置
<a href=/zh-cn/docs/concepts/configuration/organize-cluster-access-kubeconfig/><code>--kubeconfig</code></a></p><p>参数来指定其它 <a href=/zh-cn/docs/concepts/configuration/organize-cluster-access-kubeconfig/>kubeconfig</a> 文件。</p><p>本文概述了 <code>kubectl</code> 语法和命令操作描述，并提供了常见的示例。
有关每个命令的详细信息，包括所有受支持的参数和子命令，
请参阅 <a href=/docs/reference/generated/kubectl/kubectl-commands/>kubectl</a> 参考文档。</p><p>有关安装说明，请参见<a href=/zh-cn/docs/tasks/tools/#kubectl>安装 kubectl</a>；
如需快速指南，请参见<a href=/zh-cn/docs/reference/kubectl/cheatsheet/>备忘单</a>。
如果你更习惯使用 <code>docker</code> 命令行工具，
<a href=/zh-cn/docs/reference/kubectl/docker-cli-to-kubectl/>Docker 用户的 <code>kubectl</code></a>
介绍了一些 Kubernetes 的等价命令。</p><h2 id=syntax>语法</h2><p>使用以下语法从终端窗口运行 <code>kubectl</code> 命令：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#666>[</span>command<span style=color:#666>]</span> <span style=color:#666>[</span>TYPE<span style=color:#666>]</span> <span style=color:#666>[</span>NAME<span style=color:#666>]</span> <span style=color:#666>[</span>flags<span style=color:#666>]</span>
</span></span></code></pre></div><p>其中 <code>command</code>、<code>TYPE</code>、<code>NAME</code> 和 <code>flags</code> 分别是：</p><ul><li><p><code>command</code>：指定要对一个或多个资源执行的操作，例如 <code>create</code>、<code>get</code>、<code>describe</code>、<code>delete</code>。</p></li><li><p><code>TYPE</code>：指定<a href=#resource-types>资源类型</a>。资源类型不区分大小写，
可以指定单数、复数或缩写形式。例如，以下命令输出相同的结果：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod pod1
</span></span><span style=display:flex><span>kubectl get pods pod1
</span></span><span style=display:flex><span>kubectl get po pod1
</span></span></code></pre></div></li></ul><ul><li><p><code>NAME</code>：指定资源的名称。名称区分大小写。
如果省略名称，则显示所有资源的详细信息。例如：<code>kubectl get pods</code>。</p><p>在对多个资源执行操作时，你可以按类型和名称指定每个资源，或指定一个或多个文件：</p></li></ul><ul><li><p>要按类型和名称指定资源：</p></li><li><p>要对所有类型相同的资源进行分组，请执行以下操作：<code>TYPE1 name1 name2 name&lt;#></code>。<br>例子：<code>kubectl get pod example-pod1 example-pod2</code></p></li><li><p>分别指定多个资源类型：<code>TYPE1/name1 TYPE1/name2 TYPE2/name3 TYPE&lt;#>/name&lt;#></code>。<br>例子：<code>kubectl get pod/example-pod1 replicationcontroller/example-rc1</code></p></li><li><p>用一个或多个文件指定资源：<code>-f file1 -f file2 -f file&lt;#></code></p></li><li><p><a href=/zh-cn/docs/concepts/configuration/overview/#general-configuration-tips>使用 YAML 而不是 JSON</a>，
因为 YAML 对用户更友好, 特别是对于配置文件。<br>例子：<code>kubectl get -f ./pod.yaml</code></p></li></ul><ul><li><code>flags</code>： 指定可选的参数。例如，可以使用 <code>-s</code> 或 <code>--server</code> 参数指定
Kubernetes API 服务器的地址和端口。</li></ul><div class="alert alert-warning caution callout" role=alert><strong>注意：</strong> 从命令行指定的参数会覆盖默认值和任何相应的环境变量。</div><p>如果你需要帮助，在终端窗口中运行 <code>kubectl help</code>。</p><h2 id=in-cluster-authentication-and-namespace-overrides>集群内身份验证和命名空间覆盖</h2><p>默认情况下，<code>kubectl</code> 命令首先确定它是否在 Pod 中运行，从而被视为在集群中运行。
它首先检查 <code>KUBERNETES_SERVICE_HOST</code> 和 <code>KUBERNETES_SERVICE_PORT</code> 环境变量以及
<code>/var/run/secrets/kubernetes.io/serviceaccount/token</code> 中是否存在服务帐户令牌文件。
如果三个条件都被满足，则假定在集群内进行身份验证。</p><p>为保持向后兼容性，如果在集群内身份验证期间设置了 <code>POD_NAMESPACE</code>
环境变量，它将覆盖服务帐户令牌中的默认命名空间。
任何依赖默认命名空间的清单或工具都会受到影响。</p><p><strong><code>POD_NAMESPACE</code> 环境变量</strong></p><p>如果设置了 <code>POD_NAMESPACE</code> 环境变量，对命名空间资源的 CLI 操作对象将使用该变量值作为默认值。
例如，如果该变量设置为 <code>seattle</code>，<code>kubectl get pods</code> 将返回 <code>seattle</code> 命名空间中的 Pod。
这是因为 Pod 是一个命名空间资源，且命令中没有提供命名空间。</p><p>直接使用 <code>--namespace &lt;value></code> 会覆盖此行为。</p><p><strong>kubectl 如何处理 ServiceAccount 令牌</strong></p><p>假设：</p><ul><li>有 Kubernetes 服务帐户令牌文件挂载在
<code>/var/run/secrets/kubernetes.io/serviceaccount/token</code> 上，并且</li><li>设置了 <code>KUBERNETES_SERVICE_HOST</code> 环境变量，并且</li><li>设置了 <code>KUBERNETES_SERVICE_PORT</code> 环境变量，并且</li><li>你没有在 kubectl 命令行上明确指定命名空间。</li></ul><p>然后 kubectl 假定它正在你的集群中运行。
kubectl 工具查找该 ServiceAccount 的命名空间
（该命名空间与 Pod 的命名空间相同）并针对该命名空间进行操作。
这与集群外运行的情况不同；
当 kubectl 在集群外运行并且你没有指定命名空间时，
kubectl 命令会针对你在客户端配置中为当前上下文设置的命名空间进行操作。
要为你的 kubectl 更改默认的命名空间，你可以使用以下命令：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config set-context --current --namespace<span style=color:#666>=</span>&lt;namespace-name&gt;
</span></span></code></pre></div><h2 id=operations>操作</h2><p>下表包含所有 kubectl 操作的简短描述和普通语法：</p><table><thead><tr><th>操作</th><th>语法</th><th>描述</th></tr></thead><tbody><tr><td><code>alpha</code></td><td><code>kubectl alpha SUBCOMMAND [flags]</code></td><td>列出与 alpha 特性对应的可用命令，这些特性在 Kubernetes 集群中默认情况下是不启用的。</td></tr><tr><td><code>annotate</code></td><td><code>kubectl annotate (-f FILENAME | TYPE NAME | TYPE/NAME) KEY_1=VAL_1 ... KEY_N=VAL_N [--overwrite] [--all] [--resource-version=version] [flags]</code></td><td>添加或更新一个或多个资源的注解。</td></tr><tr><td><code>api-resources</code></td><td><code>kubectl api-resources [flags]</code></td><td>列出可用的 API 资源。</td></tr><tr><td><code>api-versions</code></td><td><code>kubectl api-versions [flags]</code></td><td>列出可用的 API 版本。</td></tr><tr><td><code>apply</code></td><td><code>kubectl apply -f FILENAME [flags]</code></td><td>从文件或 stdin 对资源应用配置更改。</td></tr><tr><td><code>attach</code></td><td><code>kubectl attach POD -c CONTAINER [-i] [-t] [flags]</code></td><td>挂接到正在运行的容器，查看输出流或与容器（stdin）交互。</td></tr><tr><td><code>auth</code></td><td><code>kubectl auth [flags] [options]</code></td><td>检查授权。</td></tr><tr><td><code>autoscale</code></td><td><code>kubectl autoscale (-f FILENAME | TYPE NAME | TYPE/NAME) [--min=MINPODS] --max=MAXPODS [--cpu-percent=CPU] [flags]</code></td><td>自动扩缩由副本控制器管理的一组 pod。</td></tr><tr><td><code>certificate</code></td><td><code>kubectl certificate SUBCOMMAND [options]</code></td><td>修改证书资源。</td></tr><tr><td><code>cluster-info</code></td><td><code>kubectl cluster-info [flags]</code></td><td>显示有关集群中主服务器和服务的端口信息。</td></tr><tr><td><code>completion</code></td><td><code>kubectl completion SHELL [options]</code></td><td>为指定的 Shell（Bash 或 Zsh）输出 Shell 补齐代码。</td></tr><tr><td><code>config</code></td><td><code>kubectl config SUBCOMMAND [flags]</code></td><td>修改 kubeconfig 文件。有关详细信息，请参阅各个子命令。</td></tr><tr><td><code>convert</code></td><td><code>kubectl convert -f FILENAME [options]</code></td><td>在不同的 API 版本之间转换配置文件。配置文件可以是 YAML 或 JSON 格式。注意 - 需要安装 <code>kubectl-convert</code> 插件。</td></tr><tr><td><code>cordon</code></td><td><code>kubectl cordon NODE [options]</code></td><td>将节点标记为不可调度。</td></tr><tr><td><code>cp</code></td><td><code>kubectl cp &lt;file-spec-src> &lt;file-spec-dest> [options]</code></td><td>从容器复制文件、目录或将文件、目录复制到容器。</td></tr><tr><td><code>create</code></td><td><code>kubectl create -f FILENAME [flags]</code></td><td>从文件或 stdin 创建一个或多个资源。</td></tr><tr><td><code>delete</code></td><td><code>kubectl delete (-f FILENAME | TYPE [NAME | /NAME | -l label | --all]) [flags]</code></td><td>基于文件、标准输入或通过指定标签选择器、名称、资源选择器或资源本身，删除资源。</td></tr><tr><td><code>describe</code></td><td><code>kubectl describe (-f FILENAME | TYPE [NAME_PREFIX | /NAME | -l label]) [flags]</code></td><td>显示一个或多个资源的详细状态。</td></tr><tr><td><code>diff</code></td><td><code>kubectl diff -f FILENAME [flags]</code></td><td>在当前起作用的配置和文件或标准输之间作对比 (<strong>BETA</strong>)</td></tr><tr><td><code>drain</code></td><td><code>kubectl drain NODE [options]</code></td><td>腾空节点以准备维护。</td></tr><tr><td><code>edit</code></td><td><code>kubectl edit (-f FILENAME | TYPE NAME | TYPE/NAME) [flags]</code></td><td>使用默认编辑器编辑和更新服务器上一个或多个资源的定义。</td></tr><tr><td><code>exec</code></td><td><code>kubectl exec POD [-c CONTAINER] [-i] [-t] [flags] [-- COMMAND [args...]]</code></td><td>对 Pod 中的容器执行命令。</td></tr><tr><td><code>explain</code></td><td><code>kubectl explain [--recursive=false] [flags]</code></td><td>获取多种资源的文档。例如 Pod、Node、Service 等。</td></tr><tr><td><code>expose</code></td><td><code>kubectl expose (-f FILENAME | TYPE NAME | TYPE/NAME) [--port=port] [--protocol=TCP|UDP] [--target-port=number-or-name] [--name=name] [--external-ip=external-ip-of-service] [--type=type] [flags]</code></td><td>将副本控制器、服务或 Pod 作为新的 Kubernetes 服务暴露。</td></tr><tr><td><code>get</code></td><td><code>kubectl get (-f FILENAME | TYPE [NAME | /NAME | -l label]) [--watch] [--sort-by=FIELD] [[-o | --output]=OUTPUT_FORMAT] [flags]</code></td><td>列出一个或多个资源。</td></tr><tr><td><code>kustomize</code></td><td><code>kubectl kustomize <dir>[flags] [options]`</code></td><td>列出从 kustomization.yaml 文件中的指令生成的一组 API 资源。参数必须是包含文件的目录的路径，或者是 git 存储库 URL，其路径后缀相对于存储库根目录指定了相同的路径。</td></tr><tr><td><code>label</code></td><td><code>kubectl label (-f FILENAME | TYPE NAME | TYPE/NAME) KEY_1=VAL_1 ... KEY_N=VAL_N [--overwrite] [--all] [--resource-version=version] [flags]</code></td><td>添加或更新一个或多个资源的标签。</td></tr><tr><td><code>logs</code></td><td><code>kubectl logs POD [-c CONTAINER] [--follow] [flags]</code></td><td>打印 Pod 中容器的日志。</td></tr><tr><td><code>options</code></td><td><code>kubectl options</code></td><td>全局命令行选项列表，这些选项适用于所有命令。</td></tr><tr><td><code>patch</code></td><td><code>kubectl patch (-f FILENAME | TYPE NAME | TYPE/NAME) --patch PATCH [flags]</code></td><td>使用策略合并流程更新资源的一个或多个字段。</td></tr><tr><td><code>plugin</code></td><td><code>kubectl plugin [flags] [options]</code></td><td>提供用于与插件交互的实用程序。</td></tr><tr><td><code>port-forward</code></td><td><code>kubectl port-forward POD [LOCAL_PORT:]REMOTE_PORT [...[LOCAL_PORT_N:]REMOTE_PORT_N] [flags]</code></td><td>将一个或多个本地端口转发到一个 Pod。</td></tr><tr><td><code>proxy</code></td><td><code>kubectl proxy [--port=PORT] [--www=static-dir] [--www-prefix=prefix] [--api-prefix=prefix] [flags]</code></td><td>运行访问 Kubernetes API 服务器的代理。</td></tr><tr><td><code>replace</code></td><td><code>kubectl replace -f FILENAME</code></td><td>基于文件或标准输入替换资源。</td></tr><tr><td><code>rollout</code></td><td><code>kubectl rollout SUBCOMMAND [options]</code></td><td>管理资源的上线。有效的资源类型包括：Deployment、 DaemonSet 和 StatefulSet。</td></tr><tr><td><code>run</code></td><td><code>kubectl run NAME --image=image [--env="key=value"] [--port=port] [--dry-run=server | client | none] [--overrides=inline-json] [flags]</code></td><td>在集群上运行指定的镜像。</td></tr><tr><td><code>scale</code></td><td><code>kubectl scale (-f FILENAME | TYPE NAME | TYPE/NAME) --replicas=COUNT [--resource-version=version] [--current-replicas=count] [flags]</code></td><td>更新指定副本控制器的大小。</td></tr><tr><td><code>set</code></td><td><code>kubectl set SUBCOMMAND [options]</code></td><td>配置应用资源。</td></tr><tr><td><code>taint</code></td><td><code>kubectl taint NODE NAME KEY_1=VAL_1:TAINT_EFFECT_1 ... KEY_N=VAL_N:TAINT_EFFECT_N [options]</code></td><td>更新一个或多个节点上的污点。</td></tr><tr><td><code>top</code></td><td><code>kubectl top [flags] [options]</code></td><td>显示资源（CPU、内存、存储）的使用情况。</td></tr><tr><td><code>uncordon</code></td><td><code>kubectl uncordon NODE [options]</code></td><td>将节点标记为可调度。</td></tr><tr><td><code>version</code></td><td><code>kubectl version [--client] [flags]</code></td><td>显示运行在客户端和服务器上的 Kubernetes 版本。</td></tr><tr><td><code>wait</code></td><td><code>kubectl wait ([-f FILENAME] | resource.group/resource.name | resource.group [(-l label | --all)]) [--for=delete|--for condition=available] [options]</code></td><td>实验特性：等待一种或多种资源的特定状况。</td></tr></tbody></table><p>了解更多有关命令操作的信息，
请参阅 <a href=/zh-cn/docs/reference/kubectl/kubectl/>kubectl</a> 参考文档。</p><h2 id=resource-types>资源类型</h2><p>下表列出所有受支持的资源类型及其缩写别名。</p><p>(以下输出可以通过 <code>kubectl api-resources</code> 获取，内容以 Kubernetes 1.25.0 版本为准。)</p><table><thead><tr><th>资源名</th><th>缩写名</th><th>API 版本</th><th>按命名空间</th><th>资源类型</th></tr></thead><tbody><tr><td><code>bindings</code></td><td></td><td>v1</td><td>true</td><td>Binding</td></tr><tr><td><code>componentstatuses</code></td><td><code>cs</code></td><td>v1</td><td>false</td><td>ComponentStatus</td></tr><tr><td><code>configmaps</code></td><td><code>cm</code></td><td>v1</td><td>true</td><td>ConfigMap</td></tr><tr><td><code>endpoints</code></td><td><code>ep</code></td><td>v1</td><td>true</td><td>Endpoints</td></tr><tr><td><code>events</code></td><td><code>ev</code></td><td>v1</td><td>true</td><td>Event</td></tr><tr><td><code>limitranges</code></td><td><code>limits</code></td><td>v1</td><td>true</td><td>LimitRange</td></tr><tr><td><code>namespaces</code></td><td><code>ns</code></td><td>v1</td><td>false</td><td>Namespace</td></tr><tr><td><code>nodes</code></td><td><code>no</code></td><td>v1</td><td>false</td><td>Node</td></tr><tr><td><code>persistentvolumeclaims</code></td><td><code>pvc</code></td><td>v1</td><td>true</td><td>PersistentVolumeClaim</td></tr><tr><td><code>persistentvolumes</code></td><td><code>pv</code></td><td>v1</td><td>false</td><td>PersistentVolume</td></tr><tr><td><code>pods</code></td><td><code>po</code></td><td>v1</td><td>true</td><td>Pod</td></tr><tr><td><code>podtemplates</code></td><td></td><td>v1</td><td>true</td><td>PodTemplate</td></tr><tr><td><code>replicationcontrollers</code></td><td><code>rc</code></td><td>v1</td><td>true</td><td>ReplicationController</td></tr><tr><td><code>resourcequotas</code></td><td><code>quota</code></td><td>v1</td><td>true</td><td>ResourceQuota</td></tr><tr><td><code>secrets</code></td><td></td><td>v1</td><td>true</td><td>Secret</td></tr><tr><td><code>serviceaccounts</code></td><td><code>sa</code></td><td>v1</td><td>true</td><td>ServiceAccount</td></tr><tr><td><code>services</code></td><td><code>svc</code></td><td>v1</td><td>true</td><td>Service</td></tr><tr><td><code>mutatingwebhookconfigurations</code></td><td></td><td>admissionregistration.k8s.io/v1</td><td>false</td><td>MutatingWebhookConfiguration</td></tr><tr><td><code>validatingwebhookconfigurations</code></td><td></td><td>admissionregistration.k8s.io/v1</td><td>false</td><td>ValidatingWebhookConfiguration</td></tr><tr><td><code>customresourcedefinitions</code></td><td><code>crd,crds</code></td><td>apiextensions.k8s.io/v1</td><td>false</td><td>CustomResourceDefinition</td></tr><tr><td><code>apiservices</code></td><td></td><td>apiregistration.k8s.io/v1</td><td>false</td><td>APIService</td></tr><tr><td><code>controllerrevisions</code></td><td></td><td>apps/v1</td><td>true</td><td>ControllerRevision</td></tr><tr><td><code>daemonsets</code></td><td><code>ds</code></td><td>apps/v1</td><td>true</td><td>DaemonSet</td></tr><tr><td><code>deployments</code></td><td><code>deploy</code></td><td>apps/v1</td><td>true</td><td>Deployment</td></tr><tr><td><code>replicasets</code></td><td><code>rs</code></td><td>apps/v1</td><td>true</td><td>ReplicaSet</td></tr><tr><td><code>statefulsets</code></td><td><code>sts</code></td><td>apps/v1</td><td>true</td><td>StatefulSet</td></tr><tr><td><code>tokenreviews</code></td><td></td><td>authentication.k8s.io/v1</td><td>false</td><td>TokenReview</td></tr><tr><td><code>localsubjectaccessreviews</code></td><td></td><td>authorization.k8s.io/v1</td><td>true</td><td>LocalSubjectAccessReview</td></tr><tr><td><code>selfsubjectaccessreviews</code></td><td></td><td>authorization.k8s.io/v1</td><td>false</td><td>SelfSubjectAccessReview</td></tr><tr><td><code>selfsubjectrulesreviews</code></td><td></td><td>authorization.k8s.io/v1</td><td>false</td><td>SelfSubjectRulesReview</td></tr><tr><td><code>subjectaccessreviews</code></td><td></td><td>authorization.k8s.io/v1</td><td>false</td><td>SubjectAccessReview</td></tr><tr><td><code>horizontalpodautoscalers</code></td><td><code>hpa</code></td><td>autoscaling/v2</td><td>true</td><td>HorizontalPodAutoscaler</td></tr><tr><td><code>cronjobs</code></td><td><code>cj</code></td><td>batch/v1</td><td>true</td><td>CronJob</td></tr><tr><td><code>jobs</code></td><td></td><td>batch/v1</td><td>true</td><td>Job</td></tr><tr><td><code>certificatesigningrequests</code></td><td><code>csr</code></td><td>certificates.k8s.io/v1</td><td>false</td><td>CertificateSigningRequest</td></tr><tr><td><code>leases</code></td><td></td><td>coordination.k8s.io/v1</td><td>true</td><td>Lease</td></tr><tr><td><code>endpointslices</code></td><td></td><td>discovery.k8s.io/v1</td><td>true</td><td>EndpointSlice</td></tr><tr><td><code>events</code></td><td><code>ev</code></td><td>events.k8s.io/v1</td><td>true</td><td>Event</td></tr><tr><td><code>flowschemas</code></td><td></td><td>flowcontrol.apiserver.k8s.io/v1beta2</td><td>false</td><td>FlowSchema</td></tr><tr><td><code>prioritylevelconfigurations</code></td><td></td><td>flowcontrol.apiserver.k8s.io/v1beta2</td><td>false</td><td>PriorityLevelConfiguration</td></tr><tr><td><code>ingressclasses</code></td><td></td><td>networking.k8s.io/v1</td><td>false</td><td>IngressClass</td></tr><tr><td><code>ingresses</code></td><td><code>ing</code></td><td>networking.k8s.io/v1</td><td>true</td><td>Ingress</td></tr><tr><td><code>networkpolicies</code></td><td><code>netpol</code></td><td>networking.k8s.io/v1</td><td>true</td><td>NetworkPolicy</td></tr><tr><td><code>runtimeclasses</code></td><td></td><td>node.k8s.io/v1</td><td>false</td><td>RuntimeClass</td></tr><tr><td><code>poddisruptionbudgets</code></td><td><code>pdb</code></td><td>policy/v1</td><td>true</td><td>PodDisruptionBudget</td></tr><tr><td><code>podsecuritypolicies</code></td><td><code>psp</code></td><td>policy/v1beta1</td><td>false</td><td>PodSecurityPolicy</td></tr><tr><td><code>clusterrolebindings</code></td><td></td><td>rbac.authorization.k8s.io/v1</td><td>false</td><td>ClusterRoleBinding</td></tr><tr><td><code>clusterroles</code></td><td></td><td>rbac.authorization.k8s.io/v1</td><td>false</td><td>ClusterRole</td></tr><tr><td><code>rolebindings</code></td><td></td><td>rbac.authorization.k8s.io/v1</td><td>true</td><td>RoleBinding</td></tr><tr><td><code>roles</code></td><td></td><td>rbac.authorization.k8s.io/v1</td><td>true</td><td>Role</td></tr><tr><td><code>priorityclasses</code></td><td><code>pc</code></td><td>scheduling.k8s.io/v1</td><td>false</td><td>PriorityClass</td></tr><tr><td><code>csidrivers</code></td><td></td><td>storage.k8s.io/v1</td><td>false</td><td>CSIDriver</td></tr><tr><td><code>csinodes</code></td><td></td><td>storage.k8s.io/v1</td><td>false</td><td>CSINode</td></tr><tr><td><code>csistoragecapacities</code></td><td></td><td>storage.k8s.io/v1</td><td>true</td><td>CSIStorageCapacity</td></tr><tr><td><code>storageclasses</code></td><td><code>sc</code></td><td>storage.k8s.io/v1</td><td>false</td><td>StorageClass</td></tr><tr><td><code>volumeattachments</code></td><td></td><td>storage.k8s.io/v1</td><td>false</td><td>VolumeAttachment</td></tr></tbody></table><h2 id=output-options>输出选项</h2><p>有关如何格式化或排序某些命令的输出的信息，请参阅以下章节。有关哪些命令支持不同输出选项的详细信息，
请参阅 <a href=/zh-cn/docs/reference/kubectl/kubectl/>kubectl</a> 参考文档。</p><h3 id=formatting-output>格式化输出</h3><p>所有 <code>kubectl</code> 命令的默认输出格式都是人类可读的纯文本格式。要以特定格式在终端窗口输出详细信息，
可以将 <code>-o</code> 或 <code>--output</code> 参数添加到受支持的 <code>kubectl</code> 命令中。</p><h4 id=语法>语法</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#666>[</span>command<span style=color:#666>]</span> <span style=color:#666>[</span>TYPE<span style=color:#666>]</span> <span style=color:#666>[</span>NAME<span style=color:#666>]</span> -o &lt;output_format&gt;
</span></span></code></pre></div><p>取决于具体的 <code>kubectl</code> 操作，支持的输出格式如下：</p><table><thead><tr><th>输出格式</th><th>描述</th></tr></thead><tbody><tr><td><code>-o custom-columns=&lt;spec></code></td><td>使用逗号分隔的<a href=#custom-columns>自定义列</a>列表打印表。</td></tr><tr><td><code>-o custom-columns-file=&lt;filename></code></td><td>使用 <code>&lt;filename></code> 文件中的<a href=#custom-columns>自定义列</a>模板打印表。</td></tr><tr><td><code>-o json</code></td><td>输出 JSON 格式的 API 对象</td></tr><tr><td><code>-o jsonpath=&lt;template></code></td><td>打印 <a href=/zh-cn/docs/reference/kubectl/jsonpath/>jsonpath</a> 表达式定义的字段</td></tr><tr><td><code>-o jsonpath-file=&lt;filename></code></td><td>打印 <code>&lt;filename></code> 文件中 <a href=/zh-cn/docs/reference/kubectl/jsonpath/>jsonpath</a> 表达式定义的字段。</td></tr><tr><td><code>-o name</code></td><td>仅打印资源名称而不打印任何其他内容。</td></tr><tr><td><code>-o wide</code></td><td>以纯文本格式输出，包含所有附加信息。对于 Pod 包含节点名。</td></tr><tr><td><code>-o yaml</code></td><td>输出 YAML 格式的 API 对象。</td></tr></tbody></table><h5 id=示例>示例</h5><p>在此示例中，以下命令将单个 Pod 的详细信息输出为 YAML 格式的对象：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pod web-pod-13je7 -o yaml
</span></span></code></pre></div><p>请记住：有关每个命令支持哪种输出格式的详细信息，
请参阅 <a href=/zh-cn/docs/reference/kubectl/kubectl/>kubectl</a> 参考文档。</p><h4 id=custom-columns>自定义列</h4><p>要定义自定义列并仅将所需的详细信息输出到表中，可以使用 <code>custom-columns</code> 选项。
你可以选择内联定义自定义列或使用模板文件：<code>-o custom-columns=&lt;spec></code> 或 <code>-o custom-columns-file=&lt;filename></code>。</p><h5 id=示例-1>示例</h5><p>内联：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods &lt;pod-name&gt; -o custom-columns<span style=color:#666>=</span>NAME:.metadata.name,RSRC:.metadata.resourceVersion
</span></span></code></pre></div><p>模板文件：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods &lt;pod-name&gt; -o custom-columns-file<span style=color:#666>=</span>template.txt
</span></span></code></pre></div><p>其中，<code>template.txt</code> 文件包含：</p><pre tabindex=0><code>NAME          RSRC
metadata.name metadata.resourceVersion
</code></pre><p>运行这两个命令之一的结果类似于：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME           RSRC
</span></span><span style=display:flex><span>submit-queue   <span style=color:#666>610995</span>
</span></span></code></pre></div><h4 id=server-side-列>Server-side 列</h4><p><code>kubectl</code> 支持从服务器接收关于对象的特定列信息。
这意味着对于任何给定的资源，服务器将返回与该资源相关的列和行，以便客户端打印。
通过让服务器封装打印的细节，这允许在针对同一集群使用的客户端之间提供一致的人类可读输出。</p><p>此功能默认启用。要禁用它，请将该 <code>--server-print=false</code> 参数添加到 <code>kubectl get</code> 命令中。</p><h5 id=例子>例子</h5><p>要打印有关 Pod 状态的信息，请使用如下命令：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods &lt;pod-name&gt; --server-print<span style=color:#666>=</span><span style=color:#a2f>false</span>
</span></span></code></pre></div><p>输出类似于：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>NAME       AGE
</span></span><span style=display:flex><span>pod-name   1m
</span></span></code></pre></div><h3 id=排序列表对象>排序列表对象</h3><p>要将对象排序后输出到终端窗口，可以将 <code>--sort-by</code> 参数添加到支持的 <code>kubectl</code> 命令。
通过使用 <code>--sort-by</code> 参数指定任何数字或字符串字段来对对象进行排序。
要指定字段，请使用 <a href=/zh-cn/docs/reference/kubectl/jsonpath/>jsonpath</a> 表达式。</p><h4 id=语法-1>语法</h4><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#666>[</span>command<span style=color:#666>]</span> <span style=color:#666>[</span>TYPE<span style=color:#666>]</span> <span style=color:#666>[</span>NAME<span style=color:#666>]</span> --sort-by<span style=color:#666>=</span>&lt;jsonpath_exp&gt;
</span></span></code></pre></div><h5 id=示例-2>示例</h5><p>要打印按名称排序的 Pod 列表，请运行：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods --sort-by<span style=color:#666>=</span>.metadata.name
</span></span></code></pre></div><h2 id=示例-常用操作>示例：常用操作</h2><p>使用以下示例集来帮助你熟悉运行常用 kubectl 操作：</p><p><code>kubectl apply</code> - 以文件或标准输入为准应用或更新资源。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 使用 example-service.yaml 中的定义创建服务。</span>
</span></span><span style=display:flex><span>kubectl apply -f example-service.yaml
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 使用 example-controller.yaml 中的定义创建 replication controller。</span>
</span></span><span style=display:flex><span>kubectl apply -f example-controller.yaml
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 使用 &lt;directory&gt; 路径下的任意 .yaml、.yml 或 .json 文件 创建对象。</span>
</span></span><span style=display:flex><span>kubectl apply -f &lt;directory&gt;
</span></span></code></pre></div><p><code>kubectl get</code> - 列出一个或多个资源。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 以纯文本输出格式列出所有 Pod。</span>
</span></span><span style=display:flex><span>kubectl get pods
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 以纯文本输出格式列出所有 Pod，并包含附加信息(如节点名)。</span>
</span></span><span style=display:flex><span>kubectl get pods -o wide
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 以纯文本输出格式列出具有指定名称的副本控制器。提示：你可以使用别名 &#39;rc&#39; 缩短和替换 &#39;replicationcontroller&#39; 资源类型。</span>
</span></span><span style=display:flex><span>kubectl get replicationcontroller &lt;rc-name&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 以纯文本输出格式列出所有副本控制器和服务。</span>
</span></span><span style=display:flex><span>kubectl get rc,services
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 以纯文本输出格式列出所有守护程序集，包括未初始化的守护程序集。</span>
</span></span><span style=display:flex><span>kubectl get ds --include-uninitialized
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 列出在节点 server01 上运行的所有 Pod</span>
</span></span><span style=display:flex><span>kubectl get pods --field-selector<span style=color:#666>=</span>spec.nodeName<span style=color:#666>=</span>server01
</span></span></code></pre></div><p><code>kubectl describe</code> - 显示一个或多个资源的详细状态，默认情况下包括未初始化的资源。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 显示名为 &lt;pod-name&gt; 的 Pod 的详细信息。</span>
</span></span><span style=display:flex><span>kubectl describe nodes &lt;node-name&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 显示名为 &lt;pod-name&gt; 的 Pod 的详细信息。</span>
</span></span><span style=display:flex><span>kubectl describe pods/&lt;pod-name&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 显示由名为 &lt;rc-name&gt; 的副本控制器管理的所有 Pod 的详细信息。</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 记住：副本控制器创建的任何 Pod 都以副本控制器的名称为前缀。</span>
</span></span><span style=display:flex><span>kubectl describe pods &lt;rc-name&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 描述所有的 Pod</span>
</span></span><span style=display:flex><span>kubectl describe pods
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p><code>kubectl get</code> 命令通常用于检索同一资源类别的一个或多个资源。
它具有丰富的参数，允许你使用 <code>-o</code> 或 <code>--output</code> 参数自定义输出格式。
你可以指定 <code>-w</code> 或 <code>--watch</code> 参数以开始监测特定对象的更新。
<code>kubectl describe</code> 命令更侧重于描述指定资源的许多相关方面。它可以调用对 <code>API 服务器</code> 的多个 API 调用来为用户构建视图。
例如，该 <code>kubectl describe node</code> 命令不仅检索有关节点的信息，还检索在其上运行的 Pod 的摘要，为节点生成的事件等。</div><p><code>kubectl delete</code> - 基于文件、标准输入或通过指定标签选择器、名称、资源选择器或资源来删除资源。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 使用 pod.yaml 文件中指定的类型和名称删除 Pod。</span>
</span></span><span style=display:flex><span>kubectl delete -f pod.yaml
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 删除所有带有 &#39;&lt;label-key&gt;=&lt;label-value&gt;&#39; 标签的 Pod 和服务。</span>
</span></span><span style=display:flex><span>kubectl delete pods,services -l &lt;label-key&gt;<span style=color:#666>=</span>&lt;label-value&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 删除所有 Pod，包括未初始化的 Pod。</span>
</span></span><span style=display:flex><span>kubectl delete pods --all
</span></span></code></pre></div><p><code>kubectl exec</code> - 对 Pod 中的容器执行命令。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 从 Pod &lt;pod-name&gt; 中获取运行 &#39;date&#39; 的输出。默认情况下，输出来自第一个容器。</span>
</span></span><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> &lt;pod-name&gt; -- date
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 运行输出 &#39;date&#39; 获取在 Pod &lt;pod-name&gt; 中容器 &lt;container-name&gt; 的输出。</span>
</span></span><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> &lt;pod-name&gt; -c &lt;container-name&gt; -- date
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 获取一个交互 TTY 并在 Pod  &lt;pod-name&gt; 中运行 /bin/bash。默认情况下，输出来自第一个容器。</span>
</span></span><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> -ti &lt;pod-name&gt; -- /bin/bash
</span></span></code></pre></div><p><code>kubectl logs</code> - 打印 Pod 中容器的日志。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 返回 Pod &lt;pod-name&gt; 的日志快照。</span>
</span></span><span style=display:flex><span>kubectl logs &lt;pod-name&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 从 Pod &lt;pod-name&gt; 开始流式传输日志。这类似于 &#39;tail -f&#39; Linux 命令。</span>
</span></span><span style=display:flex><span>kubectl logs -f &lt;pod-name&gt;
</span></span></code></pre></div><p><code>kubectl diff</code> - 查看集群建议更新的差异。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># “pod.json”中包含的差异资源。</span>
</span></span><span style=display:flex><span>kubectl diff -f pod.json
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 从标准输入读取的差异文件。</span>
</span></span><span style=display:flex><span>cat service.yaml | kubectl diff -f -
</span></span></code></pre></div><h2 id=示例-创建和使用插件>示例：创建和使用插件</h2><p>使用以下示例来帮助你熟悉编写和使用 <code>kubectl</code> 插件：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 用任何语言创建一个简单的插件，并为生成的可执行文件命名</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 以前缀 &#34;kubectl-&#34; 开始</span>
</span></span><span style=display:flex><span>cat ./kubectl-hello
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080>#!/bin/sh
</span></span></span><span style=display:flex><span><span style=color:#080></span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 这个插件打印单词 &#34;hello world&#34;</span>
</span></span><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b44>&#34;hello world&#34;</span>
</span></span></code></pre></div><p>这个插件写好了，把它变成可执行的：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>
</span></span><span style=display:flex><span>sudo chmod a+x ./kubectl-hello
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 并将其移动到路径中的某个位置</span>
</span></span><span style=display:flex><span>sudo mv ./kubectl-hello /usr/local/bin
</span></span><span style=display:flex><span>sudo chown root:root /usr/local/bin
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 你现在已经创建并&#34;安装了&#34;一个 kubectl 插件。</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 你可以开始使用这个插件，从 kubectl 调用它，就像它是一个常规命令一样</span>
</span></span><span style=display:flex><span>kubectl hello
</span></span></code></pre></div><pre tabindex=0><code>hello world
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 你可以&#34;卸载&#34;一个插件，只需从你的 $PATH 中删除它</span>
</span></span><span style=display:flex><span>sudo rm /usr/local/bin/kubectl-hello
</span></span></code></pre></div><p>为了查看可用的所有 <code>kubectl</code> 插件，你可以使用 <code>kubectl plugin list</code> 子命令：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl plugin list
</span></span></code></pre></div><p>输出类似于：</p><pre tabindex=0><code>The following kubectl-compatible plugins are available:

/usr/local/bin/kubectl-hello
/usr/local/bin/kubectl-foo
/usr/local/bin/kubectl-bar
</code></pre><p><code>kubectl plugin list</code> 指令也可以向你告警哪些插件被运行，或是被其它插件覆盖了，例如：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>sudo chmod -x /usr/local/bin/kubectl-foo <span style=color:#080;font-style:italic># 删除执行权限</span>
</span></span><span style=display:flex><span>kubectl plugin list
</span></span></code></pre></div><pre tabindex=0><code>The following kubectl-compatible plugins are available:

/usr/local/bin/kubectl-hello
/usr/local/bin/kubectl-foo
  - warning: /usr/local/bin/kubectl-foo identified as a plugin, but it is not executable
/usr/local/bin/kubectl-bar

error: one plugin warning was found
</code></pre><p>你可以将插件视为在现有 kubectl 命令之上构建更复杂功能的一种方法：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat ./kubectl-whoami
</span></span></code></pre></div><p>接下来的几个示例假设你已经将 <code>kubectl-whoami</code> 设置为以下内容：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080>#!/bin/bash
</span></span></span><span style=display:flex><span><span style=color:#080></span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic>#这个插件利用 `kubectl config` 命令基于当前所选上下文输出当前用户的信息</span>
</span></span><span style=display:flex><span>kubectl config view --template<span style=color:#666>=</span><span style=color:#b44>&#39;{{ range .contexts }}{{ if eq .name &#34;&#39;</span><span style=color:#a2f;font-weight:700>$(</span>kubectl config current-context<span style=color:#a2f;font-weight:700>)</span><span style=color:#b44>&#39;&#34; }}Current user: {{ printf &#34;%s\n&#34; .context.user }}{{ end }}{{ end }}&#39;</span>
</span></span></code></pre></div><p>运行以上命令将为你提供一个输出，其中包含 KUBECONFIG 文件中当前上下文的用户：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080>#!/bin/bash
</span></span></span><span style=display:flex><span><span style=color:#080></span><span style=color:#080;font-style:italic># 使文件成为可执行的</span>
</span></span><span style=display:flex><span>sudo chmod +x ./kubectl-whoami
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 然后移动到你的路径中</span>
</span></span><span style=display:flex><span>sudo mv ./kubectl-whoami /usr/local/bin
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl whoami
</span></span><span style=display:flex><span>Current user: plugins-user
</span></span></code></pre></div><h2 id=接下来>接下来</h2><ul><li>阅读 <code>kubectl</code> 参考文档：<ul><li>kubectl <a href=/zh-cn/docs/reference/kubectl/kubectl/>命令参考</a></li><li>参考<a href=/docs/reference/generated/kubectl/kubectl-commands/>命令行参数</a></li></ul></li><li>学习关于 <a href=/zh-cn/docs/reference/kubectl/conventions/><code>kubectl</code> 使用约定</a></li><li>阅读 kubectl 中的 <a href=/zh-cn/docs/reference/kubectl/jsonpath/>JSONPath 支持</a></li><li>了解如何<a href=/zh-cn/docs/tasks/extend-kubectl/kubectl-plugins>使用插件扩展 kubectl</a><ul><li>查看更多<a href=https://github.com/kubernetes/sample-cli-plugin>示例 CLI 插件</a>。</li></ul></li></ul></div></div><div class=td-content style=page-break-before:always><h1 id=pg-8aba901ac13f124e5782b90ddb166ee2>1 - kubectl 备忘单</h1><p>本页列举了常用的 <code>kubectl</code> 命令和标志。</p><h2 id=kubectl-autocomplete>Kubectl 自动补全</h2><h3 id=bash>BASH</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#a2f>source</span> &lt;<span style=color:#666>(</span>kubectl completion bash<span style=color:#666>)</span> <span style=color:#080;font-style:italic># 在 bash 中设置当前 shell 的自动补全，要先安装 bash-completion 包。</span>
</span></span><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b44>&#34;source &lt;(kubectl completion bash)&#34;</span> &gt;&gt; ~/.bashrc <span style=color:#080;font-style:italic># 在你的 bash shell 中永久地添加自动补全</span>
</span></span></code></pre></div><p>你还可以在补全时为 <code>kubectl</code> 使用一个速记别名：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#a2f>alias</span> <span style=color:#b8860b>k</span><span style=color:#666>=</span>kubectl
</span></span><span style=display:flex><span><span style=color:#a2f>complete</span> -o default -F __start_kubectl k
</span></span></code></pre></div><h3 id=zsh>ZSH</h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#a2f>source</span> &lt;<span style=color:#666>(</span>kubectl completion zsh<span style=color:#666>)</span>  <span style=color:#080;font-style:italic># 在 zsh 中设置当前 shell 的自动补全</span>
</span></span><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#b44>&#39;[[ $commands[kubectl] ]] &amp;&amp; source &lt;(kubectl completion zsh)&#39;</span> &gt;&gt; ~/.zshrc <span style=color:#080;font-style:italic># 在你的 zsh shell 中永久地添加自动补全</span>
</span></span></code></pre></div><h3 id=a-note-on-all-namespaces>关于 --all-namespaces 的一点说明</h3><p>我们经常用到 <code>--all-namespaces</code> 参数，你应该要知道它的简写：</p><p><code>kubectl -A</code></p><h2 id=kubectl-context-and-configuration>Kubectl 上下文和配置</h2><p>设置 <code>kubectl</code> 与哪个 Kubernetes 集群进行通信并修改配置信息。
查看<a href=/zh-cn/docs/tasks/access-application-cluster/configure-access-multiple-clusters/>使用 kubeconfig 跨集群授权访问</a>
文档获取配置文件详细信息。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl config view <span style=color:#080;font-style:italic># 显示合并的 kubeconfig 配置。</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 同时使用多个 kubeconfig 文件并查看合并的配置</span>
</span></span><span style=display:flex><span><span style=color:#b8860b>KUBECONFIG</span><span style=color:#666>=</span>~/.kube/config:~/.kube/kubconfig2
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl config view
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 获取 e2e 用户的密码</span>
</span></span><span style=display:flex><span>kubectl config view -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.users[?(@.name == &#34;e2e&#34;)].user.password}&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl config view -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.users[].name}&#39;</span>    <span style=color:#080;font-style:italic># 显示第一个用户</span>
</span></span><span style=display:flex><span>kubectl config view -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.users[*].name}&#39;</span>   <span style=color:#080;font-style:italic># 获取用户列表</span>
</span></span><span style=display:flex><span>kubectl config get-contexts                          <span style=color:#080;font-style:italic># 显示上下文列表</span>
</span></span><span style=display:flex><span>kubectl config current-context                       <span style=color:#080;font-style:italic># 展示当前所处的上下文</span>
</span></span><span style=display:flex><span>kubectl config use-context my-cluster-name           <span style=color:#080;font-style:italic># 设置默认的上下文为 my-cluster-name</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl config set-cluster my-cluster-name           <span style=color:#080;font-style:italic># 在 kubeconfig 中设置集群条目</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 在 kubeconfig 中配置代理服务器的 URL，以用于该客户端的请求</span>
</span></span><span style=display:flex><span>kubectl config set-cluster my-cluster-name --proxy-url<span style=color:#666>=</span>my-proxy-url
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 添加新的用户配置到 kubeconf 中，使用 basic auth 进行身份认证</span>
</span></span><span style=display:flex><span>kubectl config set-credentials kubeuser/foo.kubernetes.com --username<span style=color:#666>=</span>kubeuser --password<span style=color:#666>=</span>kubepassword
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 在指定上下文中持久性地保存名字空间，供所有后续 kubectl 命令使用</span>
</span></span><span style=display:flex><span>kubectl config set-context --current --namespace<span style=color:#666>=</span>ggckad-s2
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 使用特定的用户名和名字空间设置上下文</span>
</span></span><span style=display:flex><span>kubectl config set-context gce --user<span style=color:#666>=</span>cluster-admin --namespace<span style=color:#666>=</span>foo <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  <span style=color:#666>&amp;&amp;</span> kubectl config use-context gce
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl config <span style=color:#a2f>unset</span> users.foo                       <span style=color:#080;font-style:italic># 删除用户 foo</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 设置或显示 context / namespace 的短别名</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># （仅适用于 bash 和 bash 兼容的 shell，在使用 kn 设置命名空间之前要先设置 current-context）</span>
</span></span><span style=display:flex><span><span style=color:#a2f>alias</span> <span style=color:#b8860b>kx</span><span style=color:#666>=</span><span style=color:#b44>&#39;f() { [ &#34;$1&#34; ] &amp;&amp; kubectl config use-context $1 || kubectl config current-context ; } ; f&#39;</span>
</span></span><span style=display:flex><span><span style=color:#a2f>alias</span> <span style=color:#b8860b>kn</span><span style=color:#666>=</span><span style=color:#b44>&#39;f() { [ &#34;$1&#34; ] &amp;&amp; kubectl config set-context --current --namespace $1 || kubectl config view --minify | grep namespace | cut -d&#34; &#34; -f6 ; } ; f&#39;</span>
</span></span></code></pre></div><h2 id=kubectl-apply>Kubectl apply</h2><p><code>apply</code> 通过定义 Kubernetes 资源的文件来管理应用。
它通过运行 <code>kubectl apply</code> 在集群中创建和更新资源。
这是在生产中管理 Kubernetes 应用的推荐方法。
参见 <a href=https://kubectl.docs.kubernetes.io/zh/>Kubectl 文档</a>。</p><h2 id=creating-objects>创建对象</h2><p>Kubernetes 配置可以用 YAML 或 JSON 定义。可以使用的文件扩展名有
<code>.yaml</code>、<code>.yml</code> 和 <code>.json</code>。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl apply -f ./my-manifest.yaml           <span style=color:#080;font-style:italic># 创建资源</span>
</span></span><span style=display:flex><span>kubectl apply -f ./my1.yaml -f ./my2.yaml     <span style=color:#080;font-style:italic># 使用多个文件创建</span>
</span></span><span style=display:flex><span>kubectl apply -f ./dir                        <span style=color:#080;font-style:italic># 基于目录下的所有清单文件创建资源</span>
</span></span><span style=display:flex><span>kubectl apply -f https://git.io/vPieo         <span style=color:#080;font-style:italic># 从 URL 中创建资源</span>
</span></span><span style=display:flex><span>kubectl create deployment nginx --image<span style=color:#666>=</span>nginx <span style=color:#080;font-style:italic># 启动单实例 nginx</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 创建一个打印 “Hello World” 的 Job</span>
</span></span><span style=display:flex><span>kubectl create job hello --image<span style=color:#666>=</span>busybox:1.28 -- <span style=color:#a2f>echo</span> <span style=color:#b44>&#34;Hello World&#34;</span> 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 创建一个打印 “Hello World” 间隔1分钟的 CronJob</span>
</span></span><span style=display:flex><span>kubectl create cronjob hello --image<span style=color:#666>=</span>busybox:1.28   --schedule<span style=color:#666>=</span><span style=color:#b44>&#34;*/1 * * * *&#34;</span> -- <span style=color:#a2f>echo</span> <span style=color:#b44>&#34;Hello World&#34;</span>    
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl explain pods                          <span style=color:#080;font-style:italic># 获取 pod 清单的文档说明</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 从标准输入创建多个 YAML 对象</span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF | kubectl apply -f -
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: Pod
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: busybox-sleep
</span></span></span><span style=display:flex><span><span style=color:#b44>spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>  containers:
</span></span></span><span style=display:flex><span><span style=color:#b44>  - name: busybox
</span></span></span><span style=display:flex><span><span style=color:#b44>    image: busybox:1.28
</span></span></span><span style=display:flex><span><span style=color:#b44>    args:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - sleep
</span></span></span><span style=display:flex><span><span style=color:#b44>    - &#34;1000000&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44>---
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: Pod
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: busybox-sleep-less
</span></span></span><span style=display:flex><span><span style=color:#b44>spec:
</span></span></span><span style=display:flex><span><span style=color:#b44>  containers:
</span></span></span><span style=display:flex><span><span style=color:#b44>  - name: busybox
</span></span></span><span style=display:flex><span><span style=color:#b44>    image: busybox:1.28
</span></span></span><span style=display:flex><span><span style=color:#b44>    args:
</span></span></span><span style=display:flex><span><span style=color:#b44>    - sleep
</span></span></span><span style=display:flex><span><span style=color:#b44>    - &#34;1000&#34;
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 创建有多个 key 的 Secret</span>
</span></span><span style=display:flex><span>cat <span style=color:#b44>&lt;&lt;EOF | kubectl apply -f -
</span></span></span><span style=display:flex><span><span style=color:#b44>apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#b44>kind: Secret
</span></span></span><span style=display:flex><span><span style=color:#b44>metadata:
</span></span></span><span style=display:flex><span><span style=color:#b44>  name: mysecret
</span></span></span><span style=display:flex><span><span style=color:#b44>type: Opaque
</span></span></span><span style=display:flex><span><span style=color:#b44>data:
</span></span></span><span style=display:flex><span><span style=color:#b44>  password: $(echo -n &#34;s33msi4&#34; | base64 -w0)
</span></span></span><span style=display:flex><span><span style=color:#b44>  username: $(echo -n &#34;jane&#34; | base64 -w0)
</span></span></span><span style=display:flex><span><span style=color:#b44>EOF</span>
</span></span></code></pre></div><h2 id=viewing-finding-resources>查看和查找资源</h2><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#080;font-style:italic># get 命令的基本输出</span>
</span></span><span style=display:flex><span>kubectl get services                          <span style=color:#080;font-style:italic># 列出当前命名空间下的所有 services</span>
</span></span><span style=display:flex><span>kubectl get pods --all-namespaces             <span style=color:#080;font-style:italic># 列出所有命名空间下的全部的 Pods</span>
</span></span><span style=display:flex><span>kubectl get pods -o wide                      <span style=color:#080;font-style:italic># 列出当前命名空间下的全部 Pods，并显示更详细的信息</span>
</span></span><span style=display:flex><span>kubectl get deployment my-dep                 <span style=color:#080;font-style:italic># 列出某个特定的 Deployment</span>
</span></span><span style=display:flex><span>kubectl get pods                              <span style=color:#080;font-style:italic># 列出当前命名空间下的全部 Pods</span>
</span></span><span style=display:flex><span>kubectl get pod my-pod -o yaml                <span style=color:#080;font-style:italic># 获取一个 pod 的 YAML</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># describe 命令的详细输出</span>
</span></span><span style=display:flex><span>kubectl describe nodes my-node
</span></span><span style=display:flex><span>kubectl describe pods my-pod
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 列出当前名字空间下所有 Services，按名称排序</span>
</span></span><span style=display:flex><span>kubectl get services --sort-by<span style=color:#666>=</span>.metadata.name
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 列出 Pods，按重启次数排序</span>
</span></span><span style=display:flex><span>kubectl get pods --sort-by<span style=color:#666>=</span><span style=color:#b44>&#39;.status.containerStatuses[0].restartCount&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 列举所有 PV 持久卷，按容量排序</span>
</span></span><span style=display:flex><span>kubectl get pv --sort-by<span style=color:#666>=</span>.spec.capacity.storage
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 获取包含 app=cassandra 标签的所有 Pods 的 version 标签</span>
</span></span><span style=display:flex><span>kubectl get pods --selector<span style=color:#666>=</span><span style=color:#b8860b>app</span><span style=color:#666>=</span>cassandra -o <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.items[*].metadata.labels.version}&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 检索带有 “.” 键值，例： &#39;ca.crt&#39;</span>
</span></span><span style=display:flex><span>kubectl get configmap myconfig <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.data.ca\.crt}&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 检索一个 base64 编码的值，其中的键名应该包含减号而不是下划线。</span>
</span></span><span style=display:flex><span>kubectl get secret my-secret --template<span style=color:#666>=</span><span style=color:#b44>&#39;{{index .data &#34;key-name-with-dashes&#34;}}&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 获取所有工作节点（使用选择器以排除标签名称为 &#39;node-role.kubernetes.io/control-plane&#39; 的结果）</span>
</span></span><span style=display:flex><span>kubectl get node --selector<span style=color:#666>=</span><span style=color:#b44>&#39;!node-role.kubernetes.io/control-plane&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 获取当前命名空间中正在运行的 Pods</span>
</span></span><span style=display:flex><span>kubectl get pods --field-selector<span style=color:#666>=</span>status.phase<span style=color:#666>=</span>Running
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 获取全部节点的 ExternalIP 地址</span>
</span></span><span style=display:flex><span>kubectl get nodes -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.items[*].status.addresses[?(@.type==&#34;ExternalIP&#34;)].address}&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 列出属于某个特定 RC 的 Pods 的名称</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 在转换对于 jsonpath 过于复杂的场合，&#34;jq&#34; 命令很有用；可以在 https://stedolan.github.io/jq/ 找到它。</span>
</span></span><span style=display:flex><span><span style=color:#b8860b>sel</span><span style=color:#666>=</span><span style=color:#b68;font-weight:700>${</span><span style=color:#a2f;font-weight:700>$(</span>kubectl get rc my-rc --output<span style=color:#666>=</span>json | jq -j <span style=color:#b44>&#39;.spec.selector | to_entries | .[] | &#34;\(.key)=\(.value),&#34;&#39;</span><span style=color:#a2f;font-weight:700>)</span>%?<span style=color:#b68;font-weight:700>}</span>
</span></span><span style=display:flex><span><span style=color:#a2f>echo</span> <span style=color:#a2f;font-weight:700>$(</span>kubectl get pods --selector<span style=color:#666>=</span><span style=color:#b8860b>$sel</span> --output<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>={</span>.items..metadata.name<span style=color:#666>}</span><span style=color:#a2f;font-weight:700>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 显示所有 Pods 的标签（或任何其他支持标签的 Kubernetes 对象）</span>
</span></span><span style=display:flex><span>kubectl get pods --show-labels
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 检查哪些节点处于就绪状态</span>
</span></span><span style=display:flex><span><span style=color:#b8860b>JSONPATH</span><span style=color:#666>=</span><span style=color:#b44>&#39;{range .items[*]}{@.metadata.name}:{range @.status.conditions[*]}{@.type}={@.status};{end}{end}&#39;</span> <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span> <span style=color:#666>&amp;&amp;</span> kubectl get nodes -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#34;</span><span style=color:#b8860b>$JSONPATH</span><span style=color:#b44>&#34;</span> | grep <span style=color:#b44>&#34;Ready=True&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 不使用外部工具来输出解码后的 Secret</span>
</span></span><span style=display:flex><span>kubectl get secret my-secret -o go-template<span style=color:#666>=</span><span style=color:#b44>&#39;{{range $k,$v := .data}}{{&#34;### &#34;}}{{$k}}{{&#34;\n&#34;}}{{$v|base64decode}}{{&#34;\n\n&#34;}}{{end}}&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 列出被一个 Pod 使用的全部 Secret</span>
</span></span><span style=display:flex><span>kubectl get pods -o json | jq <span style=color:#b44>&#39;.items[].spec.containers[].env[]?.valueFrom.secretKeyRef.name&#39;</span> | grep -v null | sort | uniq
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 列举所有 Pods 中初始化容器的容器 ID（containerID）</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 可用于在清理已停止的容器时避免删除初始化容器</span>
</span></span><span style=display:flex><span>kubectl get pods --all-namespaces -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{range .items[*].status.initContainerStatuses[*]}{.containerID}{&#34;\n&#34;}{end}&#39;</span> | cut -d/ -f3
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 列出事件（Events），按时间戳排序</span>
</span></span><span style=display:flex><span>kubectl get events --sort-by<span style=color:#666>=</span>.metadata.creationTimestamp
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 比较当前的集群状态和假定某清单被应用之后的集群状态</span>
</span></span><span style=display:flex><span>kubectl diff -f ./my-manifest.yaml
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 生成一个句点分隔的树，其中包含为节点返回的所有键</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 在复杂的嵌套JSON结构中定位键时非常有用</span>
</span></span><span style=display:flex><span>kubectl get nodes -o json | jq -c <span style=color:#b44>&#39;paths|join(&#34;.&#34;)&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 生成一个句点分隔的树，其中包含为pod等返回的所有键</span>
</span></span><span style=display:flex><span>kubectl get pods -o json | jq -c <span style=color:#b44>&#39;paths|join(&#34;.&#34;)&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 假设你的 Pods 有默认的容器和默认的名字空间，并且支持 &#39;env&#39; 命令，可以使用以下脚本为所有 Pods 生成 ENV 变量。</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 该脚本也可用于在所有的 Pods 里运行任何受支持的命令，而不仅仅是 &#39;env&#39;。 </span>
</span></span><span style=display:flex><span><span style=color:#a2f;font-weight:700>for</span> pod in <span style=color:#a2f;font-weight:700>$(</span>kubectl get po --output<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>={</span>.items..metadata.name<span style=color:#666>}</span><span style=color:#a2f;font-weight:700>)</span>; <span style=color:#a2f;font-weight:700>do</span> <span style=color:#a2f>echo</span> <span style=color:#b8860b>$pod</span> <span style=color:#666>&amp;&amp;</span> kubectl <span style=color:#a2f>exec</span> -it <span style=color:#b8860b>$pod</span> -- env; <span style=color:#a2f;font-weight:700>done</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 获取一个 Deployment 的 status 子资源</span>
</span></span><span style=display:flex><span>kubectl get deployment nginx-deployment --subresource<span style=color:#666>=</span>status
</span></span></code></pre></div><h2 id=updating-resources>更新资源</h2><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl <span style=color:#a2f>set</span> image deployment/frontend <span style=color:#b8860b>www</span><span style=color:#666>=</span>image:v2               <span style=color:#080;font-style:italic># 滚动更新 &#34;frontend&#34; Deployment 的 &#34;www&#34; 容器镜像</span>
</span></span><span style=display:flex><span>kubectl rollout <span style=color:#a2f>history</span> deployment/frontend                      <span style=color:#080;font-style:italic># 检查 Deployment 的历史记录，包括版本</span>
</span></span><span style=display:flex><span>kubectl rollout undo deployment/frontend                         <span style=color:#080;font-style:italic># 回滚到上次部署版本</span>
</span></span><span style=display:flex><span>kubectl rollout undo deployment/frontend --to-revision<span style=color:#666>=</span><span style=color:#666>2</span>         <span style=color:#080;font-style:italic># 回滚到特定部署版本</span>
</span></span><span style=display:flex><span>kubectl rollout status -w deployment/frontend                    <span style=color:#080;font-style:italic># 监视 &#34;frontend&#34; Deployment 的滚动升级状态直到完成</span>
</span></span><span style=display:flex><span>kubectl rollout restart deployment/frontend                      <span style=color:#080;font-style:italic># 轮替重启 &#34;frontend&#34; Deployment</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>cat pod.json | kubectl replace -f -                              <span style=color:#080;font-style:italic># 通过传入到标准输入的 JSON 来替换 Pod</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 强制替换，删除后重建资源。会导致服务不可用。</span>
</span></span><span style=display:flex><span>kubectl replace --force -f ./pod.json
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 为多副本的 nginx 创建服务，使用 80 端口提供服务，连接到容器的 8000 端口。</span>
</span></span><span style=display:flex><span>kubectl expose rc nginx --port<span style=color:#666>=</span><span style=color:#666>80</span> --target-port<span style=color:#666>=</span><span style=color:#666>8000</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 将某单容器 Pod 的镜像版本（标签）更新到 v4</span>
</span></span><span style=display:flex><span>kubectl get pod mypod -o yaml | sed <span style=color:#b44>&#39;s/\(image: myimage\):.*$/\1:v4/&#39;</span> | kubectl replace -f -
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl label pods my-pod new-label<span style=color:#666>=</span>awesome                      <span style=color:#080;font-style:italic># 添加标签</span>
</span></span><span style=display:flex><span>kubectl annotate pods my-pod icon-url<span style=color:#666>=</span>http://goo.gl/XXBTWq       <span style=color:#080;font-style:italic># 添加注解</span>
</span></span><span style=display:flex><span>kubectl autoscale deployment foo --min<span style=color:#666>=</span><span style=color:#666>2</span> --max<span style=color:#666>=</span><span style=color:#666>10</span>                <span style=color:#080;font-style:italic># 对 &#34;foo&#34; Deployment 自动伸缩容</span>
</span></span></code></pre></div><h2 id=patching-resources>部分更新资源</h2><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#080;font-style:italic># 部分更新某节点</span>
</span></span><span style=display:flex><span>kubectl patch node k8s-node-1 -p <span style=color:#b44>&#39;{&#34;spec&#34;:{&#34;unschedulable&#34;:true}}&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 更新容器的镜像；spec.containers[*].name 是必须的。因为它是一个合并性质的主键。</span>
</span></span><span style=display:flex><span>kubectl patch pod valid-pod -p <span style=color:#b44>&#39;{&#34;spec&#34;:{&#34;containers&#34;:[{&#34;name&#34;:&#34;kubernetes-serve-hostname&#34;,&#34;image&#34;:&#34;new image&#34;}]}}&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 使用带位置数组的 JSON patch 更新容器的镜像</span>
</span></span><span style=display:flex><span>kubectl patch pod valid-pod --type<span style=color:#666>=</span><span style=color:#b44>&#39;json&#39;</span> -p<span style=color:#666>=</span><span style=color:#b44>&#39;[{&#34;op&#34;: &#34;replace&#34;, &#34;path&#34;: &#34;/spec/containers/0/image&#34;, &#34;value&#34;:&#34;new image&#34;}]&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 使用带位置数组的 JSON patch 禁用某 Deployment 的 livenessProbe</span>
</span></span><span style=display:flex><span>kubectl patch deployment valid-deployment  --type json   -p<span style=color:#666>=</span><span style=color:#b44>&#39;[{&#34;op&#34;: &#34;remove&#34;, &#34;path&#34;: &#34;/spec/template/spec/containers/0/livenessProbe&#34;}]&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 在带位置数组中添加元素</span>
</span></span><span style=display:flex><span>kubectl patch sa default --type<span style=color:#666>=</span><span style=color:#b44>&#39;json&#39;</span> -p<span style=color:#666>=</span><span style=color:#b44>&#39;[{&#34;op&#34;: &#34;add&#34;, &#34;path&#34;: &#34;/secrets/1&#34;, &#34;value&#34;: {&#34;name&#34;: &#34;whatever&#34; } }]&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 通过修正 scale 子资源来更新 Deployment 的副本数</span>
</span></span><span style=display:flex><span>kubectl patch deployment nginx-deployment --subresource<span style=color:#666>=</span><span style=color:#b44>&#39;scale&#39;</span> --type<span style=color:#666>=</span><span style=color:#b44>&#39;merge&#39;</span> -p <span style=color:#b44>&#39;{&#34;spec&#34;:{&#34;replicas&#34;:2}}&#39;</span>
</span></span></code></pre></div><h2 id=editing-resources>编辑资源</h2><p>使用你偏爱的编辑器编辑 API 资源。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl edit svc/docker-registry                      <span style=color:#080;font-style:italic># 编辑名为 docker-registry 的服务</span>
</span></span><span style=display:flex><span><span style=color:#b8860b>KUBE_EDITOR</span><span style=color:#666>=</span><span style=color:#b44>&#34;nano&#34;</span> kubectl edit svc/docker-registry   <span style=color:#080;font-style:italic># 使用其他编辑器</span>
</span></span></code></pre></div><h2 id=scaling-resources>对资源进行伸缩</h2><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl scale --replicas<span style=color:#666>=</span><span style=color:#666>3</span> rs/foo                                 <span style=color:#080;font-style:italic># 将名为 &#39;foo&#39; 的副本集伸缩到 3 副本</span>
</span></span><span style=display:flex><span>kubectl scale --replicas<span style=color:#666>=</span><span style=color:#666>3</span> -f foo.yaml                            <span style=color:#080;font-style:italic># 将在 &#34;foo.yaml&#34; 中的特定资源伸缩到 3 个副本</span>
</span></span><span style=display:flex><span>kubectl scale --current-replicas<span style=color:#666>=</span><span style=color:#666>2</span> --replicas<span style=color:#666>=</span><span style=color:#666>3</span> deployment/mysql  <span style=color:#080;font-style:italic># 如果名为 mysql 的 Deployment 的副本当前是 2，那么将它伸缩到 3</span>
</span></span><span style=display:flex><span>kubectl scale --replicas<span style=color:#666>=</span><span style=color:#666>5</span> rc/foo rc/bar rc/baz                   <span style=color:#080;font-style:italic># 伸缩多个副本控制器</span>
</span></span></code></pre></div><h2 id=deleting-resources>删除资源</h2><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl delete -f ./pod.json                                              <span style=color:#080;font-style:italic># 删除在 pod.json 中指定的类型和名称的 Pod</span>
</span></span><span style=display:flex><span>kubectl delete pod,service baz foo                                        <span style=color:#080;font-style:italic># 删除名称为 &#34;baz&#34; 和 &#34;foo&#34; 的 Pod 和服务</span>
</span></span><span style=display:flex><span>kubectl delete pods,services -l <span style=color:#b8860b>name</span><span style=color:#666>=</span>myLabel                              <span style=color:#080;font-style:italic># 删除包含 name=myLabel 标签的 pods 和服务</span>
</span></span><span style=display:flex><span>kubectl -n my-ns delete pod,svc --all                                     <span style=color:#080;font-style:italic># 删除在 my-ns 名字空间中全部的 Pods 和服务</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 删除所有与 pattern1 或 pattern2 awk 模式匹配的 Pods</span>
</span></span><span style=display:flex><span>kubectl get pods  -n mynamespace --no-headers<span style=color:#666>=</span><span style=color:#a2f>true</span> | awk <span style=color:#b44>&#39;/pattern1|pattern2/{print $1}&#39;</span> | xargs  kubectl delete -n mynamespace pod
</span></span></code></pre></div><h2 id=interacting-with-running-pods>与运行中的 Pod 进行交互</h2><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl logs my-pod                                 <span style=color:#080;font-style:italic># 获取 pod 日志（标准输出）</span>
</span></span><span style=display:flex><span>kubectl logs -l <span style=color:#b8860b>name</span><span style=color:#666>=</span>myLabel                        <span style=color:#080;font-style:italic># 获取含 name=myLabel 标签的 Pods 的日志（标准输出）</span>
</span></span><span style=display:flex><span>kubectl logs my-pod --previous                      <span style=color:#080;font-style:italic># 获取上个容器实例的 pod 日志（标准输出）</span>
</span></span><span style=display:flex><span>kubectl logs my-pod -c my-container                 <span style=color:#080;font-style:italic># 获取 Pod 容器的日志（标准输出, 多容器场景）</span>
</span></span><span style=display:flex><span>kubectl logs -l <span style=color:#b8860b>name</span><span style=color:#666>=</span>myLabel -c my-container        <span style=color:#080;font-style:italic># 获取含 name=myLabel 标签的 Pod 容器日志（标准输出, 多容器场景）</span>
</span></span><span style=display:flex><span>kubectl logs my-pod -c my-container --previous      <span style=color:#080;font-style:italic># 获取 Pod 中某容器的上个实例的日志（标准输出, 多容器场景）</span>
</span></span><span style=display:flex><span>kubectl logs -f my-pod                              <span style=color:#080;font-style:italic># 流式输出 Pod 的日志（标准输出）</span>
</span></span><span style=display:flex><span>kubectl logs -f my-pod -c my-container              <span style=color:#080;font-style:italic># 流式输出 Pod 容器的日志（标准输出, 多容器场景）</span>
</span></span><span style=display:flex><span>kubectl logs -f -l <span style=color:#b8860b>name</span><span style=color:#666>=</span>myLabel --all-containers    <span style=color:#080;font-style:italic># 流式输出含 name=myLabel 标签的 Pod 的所有日志（标准输出）</span>
</span></span><span style=display:flex><span>kubectl run -i --tty busybox --image<span style=color:#666>=</span>busybox:1.28 -- sh  <span style=color:#080;font-style:italic># 以交互式 Shell 运行 Pod</span>
</span></span><span style=display:flex><span>kubectl run nginx --image<span style=color:#666>=</span>nginx -n mynamespace      <span style=color:#080;font-style:italic># 在 “mynamespace” 命名空间中运行单个 nginx Pod</span>
</span></span><span style=display:flex><span>kubectl run nginx --image<span style=color:#666>=</span>nginx --dry-run<span style=color:#666>=</span>client -o yaml &gt; pod.yaml
</span></span><span style=display:flex><span>                                                    <span style=color:#080;font-style:italic># 为运行 nginx Pod 生成规约并将其写入到名为 pod.yaml 的文件</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl attach my-pod -i                            <span style=color:#080;font-style:italic># 挂接到一个运行的容器中</span>
</span></span><span style=display:flex><span>kubectl port-forward my-pod 5000:6000               <span style=color:#080;font-style:italic># 在本地计算机上侦听端口 5000 并转发到 my-pod 上的端口 6000</span>
</span></span><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> my-pod -- ls /                         <span style=color:#080;font-style:italic># 在已有的 Pod 中运行命令（单容器场景）</span>
</span></span><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> --stdin --tty my-pod -- /bin/sh        <span style=color:#080;font-style:italic># 使用交互 shell 访问正在运行的 Pod (一个容器场景)</span>
</span></span><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> my-pod -c my-container -- ls /         <span style=color:#080;font-style:italic># 在已有的 Pod 中运行命令（多容器场景）</span>
</span></span><span style=display:flex><span>kubectl top pod POD_NAME --containers               <span style=color:#080;font-style:italic># 显示给定 Pod 和其中容器的监控数据</span>
</span></span><span style=display:flex><span>kubectl top pod POD_NAME --sort-by<span style=color:#666>=</span>cpu              <span style=color:#080;font-style:italic># 显示给定 Pod 的指标并且按照 &#39;cpu&#39; 或者 &#39;memory&#39; 排序</span>
</span></span></code></pre></div><h2 id=copy-files-and-directories-to-and-from-containers>从容器中复制文件和目录</h2><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl cp /tmp/foo_dir my-pod:/tmp/bar_dir            <span style=color:#080;font-style:italic># 将 /tmp/foo_dir 本地目录复制到远程当前命名空间中 Pod 中的 /tmp/bar_dir</span>
</span></span><span style=display:flex><span>kubectl cp /tmp/foo my-pod:/tmp/bar -c my-container    <span style=color:#080;font-style:italic># 将 /tmp/foo 本地文件复制到远程 Pod 中特定容器的 /tmp/bar 下</span>
</span></span><span style=display:flex><span>kubectl cp /tmp/foo my-namespace/my-pod:/tmp/bar       <span style=color:#080;font-style:italic># 将 /tmp/foo 本地文件复制到远程 “my-namespace” 命名空间内指定 Pod 中的 /tmp/bar</span>
</span></span><span style=display:flex><span>kubectl cp my-namespace/my-pod:/tmp/foo /tmp/bar       <span style=color:#080;font-style:italic># 将 /tmp/foo 从远程 Pod 复制到本地 /tmp/bar</span>
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p><code>kubectl cp</code> 要求容器镜像中存在 “tar” 二进制文件。如果 “tar” 不存在，<code>kubectl cp</code> 将失败。
对于进阶用例，例如符号链接、通配符扩展或保留文件权限，请考虑使用 <code>kubectl exec</code>。</div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>tar cf - /tmp/foo | kubectl <span style=color:#a2f>exec</span> -i -n my-namespace my-pod -- tar xf - -C /tmp/bar  <span style=color:#080;font-style:italic># 将 /tmp/foo 本地文件复制到远程 “my-namespace” 命名空间中 pod 中的 /tmp/bar</span>
</span></span><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> -n my-namespace my-pod -- tar cf - /tmp/foo | tar xf - -C /tmp/bar    <span style=color:#080;font-style:italic># 将 /tmp/foo 从远程 pod 复制到本地 /tmp/bar</span>
</span></span></code></pre></div><h2 id=interacting-with-deployments-and-services>与 Deployments 和 Services 进行交互</h2><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl logs deploy/my-deployment                         <span style=color:#080;font-style:italic># 获取一个 Deployment 的 Pod 的日志（单容器例子）</span>
</span></span><span style=display:flex><span>kubectl logs deploy/my-deployment -c my-container         <span style=color:#080;font-style:italic># 获取一个 Deployment 的 Pod 的日志（多容器例子）</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl port-forward svc/my-service <span style=color:#666>5000</span>                  <span style=color:#080;font-style:italic># 侦听本地端口 5000 并转发到 Service 后端端口 5000</span>
</span></span><span style=display:flex><span>kubectl port-forward svc/my-service 5000:my-service-port  <span style=color:#080;font-style:italic># 侦听本地端口 5000 并转发到名字为 &lt;my-service-port&gt; 的 Service 目标端口</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl port-forward deploy/my-deployment 5000:6000       <span style=color:#080;font-style:italic># 侦听本地端口 5000 并转发到 &lt;my-deployment&gt; 创建的 Pod 里的端口 6000</span>
</span></span><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> deploy/my-deployment -- ls                   <span style=color:#080;font-style:italic># 在 Deployment 里的第一个 Pod 的第一个容器里运行命令（单容器和多容器例子）</span>
</span></span></code></pre></div><h2 id=interacting-with-nodes-and-cluster>与节点和集群进行交互</h2><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl cordon my-node                                                <span style=color:#080;font-style:italic># 标记 my-node 节点为不可调度</span>
</span></span><span style=display:flex><span>kubectl drain my-node                                                 <span style=color:#080;font-style:italic># 对 my-node 节点进行清空操作，为节点维护做准备</span>
</span></span><span style=display:flex><span>kubectl uncordon my-node                                              <span style=color:#080;font-style:italic># 标记 my-node 节点为可以调度</span>
</span></span><span style=display:flex><span>kubectl top node my-node                                              <span style=color:#080;font-style:italic># 显示给定节点的度量值</span>
</span></span><span style=display:flex><span>kubectl cluster-info                                                  <span style=color:#080;font-style:italic># 显示主控节点和服务的地址</span>
</span></span><span style=display:flex><span>kubectl cluster-info dump                                             <span style=color:#080;font-style:italic># 将当前集群状态转储到标准输出</span>
</span></span><span style=display:flex><span>kubectl cluster-info dump --output-directory<span style=color:#666>=</span>/path/to/cluster-state   <span style=color:#080;font-style:italic># 将当前集群状态输出到 /path/to/cluster-state</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 查看当前节点上存在的现有污点。</span>
</span></span><span style=display:flex><span>kubectl get nodes -o<span style=color:#666>=</span><span style=color:#b44>&#39;custom-columns=NodeName:.metadata.name,TaintKey:.spec.taints[*].key,TaintValue:.spec.taints[*].value,TaintEffect:.spec.taints[*].effect&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 如果已存在具有指定键和效果的污点，则替换其值为指定值。</span>
</span></span><span style=display:flex><span>kubectl taint nodes foo <span style=color:#b8860b>dedicated</span><span style=color:#666>=</span>special-user:NoSchedule
</span></span></code></pre></div><h3 id=resource-types>资源类型</h3><p>列出所支持的全部资源类型和它们的简称、<a href=/zh-cn/docs/concepts/overview/kubernetes-api/#api-groups-and-versioning>API 组</a>, 是否是<a href=/zh-cn/docs/concepts/overview/working-with-objects/namespaces>名字空间作用域</a> 和 <a href=/zh-cn/docs/concepts/overview/working-with-objects/kubernetes-objects>Kind</a>。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl api-resources
</span></span></code></pre></div><p>用于探索 API 资源的其他操作：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>kubectl api-resources --namespaced<span style=color:#666>=</span><span style=color:#a2f>true</span>      <span style=color:#080;font-style:italic># 所有命名空间作用域的资源</span>
</span></span><span style=display:flex><span>kubectl api-resources --namespaced<span style=color:#666>=</span><span style=color:#a2f>false</span>     <span style=color:#080;font-style:italic># 所有非命名空间作用域的资源</span>
</span></span><span style=display:flex><span>kubectl api-resources -o name                <span style=color:#080;font-style:italic># 用简单格式列举所有资源（仅显示资源名称）</span>
</span></span><span style=display:flex><span>kubectl api-resources -o wide                <span style=color:#080;font-style:italic># 用扩展格式列举所有资源（又称 &#34;wide&#34; 格式）</span>
</span></span><span style=display:flex><span>kubectl api-resources --verbs<span style=color:#666>=</span>list,get       <span style=color:#080;font-style:italic># 支持 &#34;list&#34; 和 &#34;get&#34; 请求动词的所有资源</span>
</span></span><span style=display:flex><span>kubectl api-resources --api-group<span style=color:#666>=</span>extensions <span style=color:#080;font-style:italic># &#34;extensions&#34; API 组中的所有资源</span>
</span></span></code></pre></div><h3 id=formatting-output>格式化输出</h3><p>要以特定格式将详细信息输出到终端窗口，将 <code>-o</code>（或者 <code>--output</code>）参数添加到支持的 <code>kubectl</code> 命令中。</p><table><thead><tr><th>输出格式</th><th>描述</th></tr></thead><tbody><tr><td><code>-o=custom-columns=&lt;spec></code></td><td>使用逗号分隔的自定义列来打印表格</td></tr><tr><td><code>-o=custom-columns-file=&lt;filename></code></td><td>使用 <code>&lt;filename></code> 文件中的自定义列模板打印表格</td></tr><tr><td><code>-o=json</code></td><td>输出 JSON 格式的 API 对象</td></tr><tr><td><code>-o=jsonpath=&lt;template></code></td><td>打印 <a href=/zh-cn/docs/reference/kubectl/jsonpath>jsonpath</a> 表达式中定义的字段</td></tr><tr><td><code>-o=jsonpath-file=&lt;filename></code></td><td>打印在 <code>&lt;filename></code> 文件中定义的 <a href=/zh-cn/docs/reference/kubectl/jsonpath>jsonpath</a> 表达式所指定的字段。</td></tr><tr><td><code>-o=name</code></td><td>仅打印资源名称而不打印其他内容</td></tr><tr><td><code>-o=wide</code></td><td>以纯文本格式输出额外信息，对于 Pod 来说，输出中包含了节点名称</td></tr><tr><td><code>-o=yaml</code></td><td>输出 YAML 格式的 API 对象</td></tr></tbody></table><p>使用 <code>-o=custom-columns</code> 的示例：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#080;font-style:italic># 集群中运行着的所有镜像</span>
</span></span><span style=display:flex><span>kubectl get pods -A -o<span style=color:#666>=</span>custom-columns<span style=color:#666>=</span><span style=color:#b44>&#39;DATA:spec.containers[*].image&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 列举 default 名字空间中运行的所有镜像，按 Pod 分组</span>
</span></span><span style=display:flex><span>kubectl get pods --namespace default --output<span style=color:#666>=</span>custom-columns<span style=color:#666>=</span><span style=color:#b44>&#34;NAME:.metadata.name,IMAGE:.spec.containers[*].image&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 除 &#34;registry.k8s.io/coredns:1.6.2&#34; 之外的所有镜像</span>
</span></span><span style=display:flex><span>kubectl get pods -A -o<span style=color:#666>=</span>custom-columns<span style=color:#666>=</span><span style=color:#b44>&#39;DATA:spec.containers[?(@.image!=&#34;registry.k8s.io/coredns:1.6.2&#34;)].image&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 输出 metadata 下面的所有字段，无论 Pod 名字为何</span>
</span></span><span style=display:flex><span>kubectl get pods -A -o<span style=color:#666>=</span>custom-columns<span style=color:#666>=</span><span style=color:#b44>&#39;DATA:metadata.*&#39;</span>
</span></span></code></pre></div><p>有关更多示例，请参看 kubectl <a href=/zh-cn/docs/reference/kubectl/#custom-columns>参考文档</a>。</p><h3 id=kubectl-output-verbosity-and-debugging>Kubectl 日志输出详细程度和调试</h3><p>Kubectl 日志输出详细程度是通过 <code>-v</code> 或者 <code>--v</code> 来控制的，参数后跟一个数字表示日志的级别。
Kubernetes 通用的日志习惯和相关的日志级别在
<a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-instrumentation/logging.md>这里</a>有相应的描述。</p><table><thead><tr><th>详细程度</th><th>描述</th></tr></thead><tbody><tr><td><code>--v=0</code></td><td>用于那些应该 <em>始终</em> 对运维人员可见的信息，因为这些信息一般很有用。</td></tr><tr><td><code>--v=1</code></td><td>如果你不想要看到冗余信息，此值是一个合理的默认日志级别。</td></tr><tr><td><code>--v=2</code></td><td>输出有关服务的稳定状态的信息以及重要的日志消息，这些信息可能与系统中的重大变化有关。这是建议大多数系统设置的默认日志级别。</td></tr><tr><td><code>--v=3</code></td><td>包含有关系统状态变化的扩展信息。</td></tr><tr><td><code>--v=4</code></td><td>包含调试级别的冗余信息。</td></tr><tr><td><code>--v=5</code></td><td>跟踪级别的详细程度。</td></tr><tr><td><code>--v=6</code></td><td>显示所请求的资源。</td></tr><tr><td><code>--v=7</code></td><td>显示 HTTP 请求头。</td></tr><tr><td><code>--v=8</code></td><td>显示 HTTP 请求内容。</td></tr><tr><td><code>--v=9</code></td><td>显示 HTTP 请求内容而且不截断内容。</td></tr></tbody></table><h2 id=接下来>接下来</h2><ul><li>参阅 <a href=/zh-cn/docs/reference/kubectl/>kubectl 概述</a>，进一步了解 <a href=/zh-cn/docs/reference/kubectl/jsonpath>JsonPath</a>。</li><li>参阅 <a href=/zh-cn/docs/reference/kubectl/kubectl/>kubectl</a> 选项。</li><li>参阅 <a href=/zh-cn/docs/reference/kubectl/conventions/>kubectl 使用约定</a>来理解如何在可复用的脚本中使用它。</li><li>查看社区中其他的 <a href=https://github.com/dennyzhang/cheatsheet-kubernetes-A4>kubectl 备忘单</a>。</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-d7ffbf04ffbefb241fd0722423b80f5a>2 - kubectl 命令</h1><p><a href=/docs/reference/generated/kubectl/kubectl-commands/>kubectl 命令参考</a></p></div><div class=td-content style=page-break-before:always><h1 id=pg-4d3e62632c189fcc3c1357cd8fb8799c>3 - kubectl</h1><h2 id=简介>简介</h2><p>kubectl 管理控制 Kubernetes 集群。</p><p>获取更多信息，请访问 <a href=/zh-cn/docs/reference/kubectl/>kubectl 概述</a>。</p><pre tabindex=0><code>kubectl [flags]
</code></pre><h2 id=选项>选项</h2><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>--add-dir-header</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>设置为 true 表示添加文件目录到日志信息头中</td></tr><tr><td colspan=2>--alsologtostderr</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>表示将日志输出到文件的同时输出到 stderr</td></tr><tr><td colspan=2>--as string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>以指定用户的身份执行操作</td></tr><tr><td colspan=2>--as-group stringArray</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>模拟指定的组来执行操作，可以使用这个标志来指定多个组。</td></tr><tr><td colspan=2>--azure-container-registry-config string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>包含 Azure 容器仓库配置信息的文件的路径。</td></tr><tr><td colspan=2>--cache-dir string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: "$HOME/.kube/cache"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>默认缓存目录</td></tr><tr><td colspan=2>--certificate-authority string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>指向证书机构的 cert 文件路径</td></tr><tr><td colspan=2>--client-certificate string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>TLS 使用的客户端证书路径</td></tr><tr><td colspan=2>--client-key string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>TLS 使用的客户端密钥文件路径</td></tr><tr><td colspan=2>--cloud-provider-gce-l7lb-src-cidrs cidrs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: 130.211.0.0/22,35.191.0.0/16</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>在 GCE 防火墙中开放的 CIDR，用来进行 L7 LB 流量代理和健康检查。</td></tr><tr><td colspan=2>--cloud-provider-gce-lb-src-cidrs cidrs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: 130.211.0.0/22,209.85.152.0/22,209.85.204.0/22,35.191.0.0/16</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>在 GCE 防火墙中开放的 CIDR，用来进行 L4 LB 流量代理和健康检查。</td></tr><tr><td colspan=2>--cluster string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>要使用的 kubeconfig 集群的名称</td></tr><tr><td colspan=2>--context string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>要使用的 kubeconfig 上下文的名称</td></tr><tr><td colspan=2>--default-not-ready-toleration-seconds int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: 300</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>表示 `notReady` 状态的容忍度秒数：默认情况下，`NoExecute` 被添加到尚未具有此容忍度的每个 Pod 中。</td></tr><tr><td colspan=2>--default-unreachable-toleration-seconds int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: 300</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>表示 `unreachable` 状态的容忍度秒数：默认情况下，`NoExecute` 被添加到尚未具有此容忍度的每个 Pod 中。</td></tr><tr><td colspan=2>-h, --help</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>kubectl 操作的帮助命令</td></tr><tr><td colspan=2>--insecure-skip-tls-verify</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>设置为 true，则表示不会检查服务器证书的有效性。这样会导致你的 HTTPS 连接不安全。</td></tr><tr><td colspan=2>--kubeconfig string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>CLI 请求使用的 kubeconfig 配置文件的路径。</td></tr><tr><td colspan=2>--log-backtrace-at traceLocation&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: 0</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>当日志机制运行到指定文件的指定行（file:N）时，打印调用堆栈信息</td></tr><tr><td colspan=2>--log-dir string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>如果不为空，则将日志文件写入此目录</td></tr><tr><td colspan=2>--log-file string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>如果不为空，则将使用此日志文件</td></tr><tr><td colspan=2>--log-file-max-size uint&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: 1800</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>定义日志文件的最大尺寸。单位为兆字节。如果值设置为 0，则表示日志文件大小不受限制。</td></tr><tr><td colspan=2>--log-flush-frequency duration&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: 5s</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>两次日志刷新操作之间的最长时间（秒）</td></tr><tr><td colspan=2>--logtostderr&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: true</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>日志输出到 stderr 而不是文件中</td></tr><tr><td colspan=2>--match-server-version</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>要求客户端版本和服务端版本相匹配</td></tr><tr><td colspan=2>-n, --namespace string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>如果存在，CLI 请求将使用此命名空间</td><tr><td colspan=2>--one-output</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>如果为 true，则只将日志写入初始严重级别（而不是同时写入所有较低的严重级别）。</td></tr></tr><tr><td colspan=2>--password string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>API 服务器进行基本身份验证的密码</td></tr><tr><td colspan=2>--profile string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: "none"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>要记录的性能指标的名称。可取 (none|cpu|heap|goroutine|threadcreate|block|mutex) 其中之一。</td></tr><tr><td colspan=2>--profile-output string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: "profile.pprof"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>用于转储所记录的性能信息的文件名</td></tr><tr><td colspan=2>--request-timeout string&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: "0"</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>放弃单个服务器请求之前的等待时间，非零值需要包含相应时间单位（例如：1s、2m、3h）。零值则表示不做超时要求。</td></tr><tr><td colspan=2>-s, --server string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>Kubernetes API 服务器的地址和端口</td></tr><tr><td colspan=2>--skip-headers</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>设置为 true 则表示跳过在日志消息中出现 header 前缀信息</td></tr><tr><td colspan=2>--skip-log-headers</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>设置为 true 则表示在打开日志文件时跳过 header 信息</td></tr><tr><td colspan=2>--stderrthreshold severity&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;默认值: 2</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>等于或高于此阈值的日志将输出到标准错误输出（stderr）</td></tr><tr><td colspan=2>--token string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>用于对 API 服务器进行身份认证的持有者令牌</td></tr><tr><td colspan=2>--user string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>指定使用 kubeconfig 配置文件中的用户名</td></tr><tr><td colspan=2>--username string</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>用于 API 服务器的基本身份验证的用户名</td></tr><tr><td colspan=2>-v, --v Level</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>指定输出日志的日志详细级别</td></tr><tr><td colspan=2>--version version[=true]</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>打印 kubectl 版本信息并退出</td></tr><tr><td colspan=2>--vmodule moduleSpec</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>以逗号分隔的 pattern=N 设置列表，用于过滤文件的日志记录</td></tr></tbody></table><h2 id=环境变量>环境变量</h2><table style=width:100%;table-layout:fixed><col span=1 style=width:10px><col span=1><tbody><tr><td colspan=2>KUBECONFIG</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>kubectl 的配置 ("kubeconfig") 文件的路径。默认值: "$HOME/.kube/config"</td></tr><tr><td colspan=2>KUBECTL_COMMAND_HEADERS</td></tr><tr><td></td><td style=line-height:130%;word-wrap:break-word>设置为 false 时，将关闭额外的 HTTP 标头，不再详细说明被调用的 kubectl 命令 (此变量适用于 Kubernetes v1.22 或更高版本)</td></tr></tbody></table><h2 id=另请参见>另请参见</h2><ul><li><a href=/docs/reference/generated/kubectl/kubectl-commands#annotate>kubectl annotate</a> - 更新资源所关联的注解</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#api-resources>kubectl api-resources</a> - 打印服务器上所支持的 API 资源</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#api-versions>kubectl api-versions</a> - 以“组/版本”的格式输出服务端所支持的 API 版本</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#apply>kubectl apply</a> - 基于文件名或标准输入，将新的配置应用到资源上</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#attach>kubectl attach</a> - 连接到一个正在运行的容器</li></ul><ul><li><a href=/docs/reference/generated/kubectl/kubectl-commands#auth>kubectl auth</a> - 检查授权信息</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#autoscale>kubectl autoscale</a> - 对一个资源对象（Deployment、ReplicaSet 或 ReplicationController ）进行扩缩</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#certificate>kubectl certificate</a> - 修改证书资源</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#cluster-info>kubectl cluster-info</a> - 显示集群信息</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#completion>kubectl completion</a> - 根据已经给出的 Shell（bash 或 zsh），输出 Shell 补全后的代码</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#config>kubectl config</a> - 修改 kubeconfig 配置文件</li></ul><ul><li><a href=/docs/reference/generated/kubectl/kubectl-commands#convert>kubectl convert</a> - 在不同的 API 版本之间转换配置文件</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#cordon>kubectl cordon</a> - 标记节点为不可调度的</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#cp>kubectl cp</a> - 将文件和目录拷入/拷出容器</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#create>kubectl create</a> - 通过文件或标准输入来创建资源</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#debug>kubectl debug</a> - 创建用于排查工作负载和节点故障的调试会话</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#delete>kubectl delete</a> - 通过文件名、标准输入、资源和名字删除资源，或者通过资源和标签选择算符来删除资源</li></ul><ul><li><a href=/docs/reference/generated/kubectl/kubectl-commands#describe>kubectl describe</a> - 显示某个资源或某组资源的详细信息</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#diff>kubectl diff</a> - 显示目前版本与将要应用的版本之间的差异</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#drain>kubectl drain</a> - 腾空节点，准备维护</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#edit>kubectl edit</a> - 修改服务器上的某资源</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#exec>kubectl exec</a> - 在容器中执行相关命令</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#explain>kubectl explain</a> - 显示资源文档说明</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#expose>kubectl expose</a> - 给定副本控制器、服务、Deployment 或 Pod，将其暴露为新的 kubernetes Service</li></ul><ul><li><a href=/docs/reference/generated/kubectl/kubectl-commands#get>kubectl get</a> - 显示一个或者多个资源信息</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#kustomize>kubectl kustomize</a> - 从目录或远程 URL 中构建 kustomization</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#label>kubectl label</a> - 更新资源的标签</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#logs>kubectl logs</a> - 输出 Pod 中某容器的日志</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#options>kubectl options</a> - 打印所有命令都支持的共有参数列表</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#patch>kubectl patch</a> - 基于策略性合并修补（Stategic Merge Patch）规则更新某资源中的字段</li></ul><ul><li><a href=/docs/reference/generated/kubectl/kubectl-commands#plugin>kubectl plugin</a> - 运行命令行插件</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#port-forward>kubectl port-forward</a> - 将一个或者多个本地端口转发到 Pod</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#proxy>kubectl proxy</a> - 运行一个 kubernetes API 服务器代理</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#replace>kubectl replace</a> - 基于文件名或标准输入替换资源</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#rollout>kubectl rollout</a> - 管理资源的上线</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#run>kubectl run</a> - 在集群中使用指定镜像启动容器</li></ul><ul><li><a href=/docs/reference/generated/kubectl/kubectl-commands#scale>kubectl scale</a> - 为一个 Deployment、ReplicaSet 或 ReplicationController 设置一个新的规模值</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#set>kubectl set</a> - 为对象设置功能特性</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#taint>kubectl taint</a> - 在一个或者多个节点上更新污点配置</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#top>kubectl top</a> - 显示资源（CPU /内存/存储）使用率</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#uncordon>kubectl uncordon</a> - 标记节点为可调度的</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#version>kubectl version</a> - 打印客户端和服务器的版本信息</li><li><a href=/docs/reference/generated/kubectl/kubectl-commands#wait>kubectl wait</a> - 实验性：等待一个或多个资源达到某种状态</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-a938176c695852fe70362c29cf615f1c>4 - JSONPath 支持</h1><p>kubectl 支持 JSONPath 模板。</p><p>JSONPath 模板由 {} 包起来的 JSONPath 表达式组成。Kubectl 使用 JSONPath 表达式来过滤 JSON 对象中的特定字段并格式化输出。
除了原始的 JSONPath 模板语法，以下函数和语法也是有效的:</p><ol><li>使用双引号将 JSONPath 表达式内的文本引起来。</li><li>使用 <code>range</code>，<code>end</code> 运算符来迭代列表。</li><li>使用负片索引后退列表。负索引不会“环绕”列表，并且只要 <code>-index + listLength> = 0</code> 就有效。</li></ol><div class="alert alert-info note callout" role=alert><strong>说明：</strong><ul><li><p><code>$</code> 运算符是可选的，因为默认情况下表达式总是从根对象开始。</p></li><li><p>结果对象将作为其 String() 函数输出。</p></li></ul></div><p>给定 JSON 输入:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;List&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;items&#34;</span>:[
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;kind&#34;</span>:<span style=color:#b44>&#34;None&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;metadata&#34;</span>:{<span style=color:green;font-weight:700>&#34;name&#34;</span>:<span style=color:#b44>&#34;127.0.0.1&#34;</span>},
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;status&#34;</span>:{
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;capacity&#34;</span>:{<span style=color:green;font-weight:700>&#34;cpu&#34;</span>:<span style=color:#b44>&#34;4&#34;</span>},
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;addresses&#34;</span>:[{<span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;LegacyHostIP&#34;</span>, <span style=color:green;font-weight:700>&#34;address&#34;</span>:<span style=color:#b44>&#34;127.0.0.1&#34;</span>}]
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;kind&#34;</span>:<span style=color:#b44>&#34;None&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;metadata&#34;</span>:{<span style=color:green;font-weight:700>&#34;name&#34;</span>:<span style=color:#b44>&#34;127.0.0.2&#34;</span>},
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;status&#34;</span>:{
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;capacity&#34;</span>:{<span style=color:green;font-weight:700>&#34;cpu&#34;</span>:<span style=color:#b44>&#34;8&#34;</span>},
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>&#34;addresses&#34;</span>:[
</span></span><span style=display:flex><span>          {<span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;LegacyHostIP&#34;</span>, <span style=color:green;font-weight:700>&#34;address&#34;</span>:<span style=color:#b44>&#34;127.0.0.2&#34;</span>},
</span></span><span style=display:flex><span>          {<span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;another&#34;</span>, <span style=color:green;font-weight:700>&#34;address&#34;</span>:<span style=color:#b44>&#34;127.0.0.3&#34;</span>}
</span></span><span style=display:flex><span>        ]
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  ],
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;users&#34;</span>:[
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;myself&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;user&#34;</span>: {}
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;e2e&#34;</span>,
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;user&#34;</span>: {<span style=color:green;font-weight:700>&#34;username&#34;</span>: <span style=color:#b44>&#34;admin&#34;</span>, <span style=color:green;font-weight:700>&#34;password&#34;</span>: <span style=color:#b44>&#34;secret&#34;</span>}
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  ]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><table><thead><tr><th>函数</th><th>描述</th><th>示例</th><th>结果</th></tr></thead><tbody><tr><td><code>text</code></td><td>纯文本</td><td><code>kind is {.kind}</code></td><td><code>kind is List</code></td></tr><tr><td><code>@</code></td><td>当前对象</td><td><code>{@}</code></td><td>与输入相同</td></tr><tr><td><code>.</code> or <code>[]</code></td><td>子运算符</td><td><code>{.kind}</code>, <code>{['kind']}</code> or <code>{['name\.type']}</code></td><td><code>List</code></td></tr><tr><td><code>..</code></td><td>递归下降</td><td><code>{..name}</code></td><td><code>127.0.0.1 127.0.0.2 myself e2e</code></td></tr><tr><td><code>*</code></td><td>通配符。获取所有对象</td><td><code>{.items[*].metadata.name}</code></td><td><code>[127.0.0.1 127.0.0.2]</code></td></tr><tr><td><code>[start:end :step]</code></td><td>下标运算符</td><td><code>{.users[0].name}</code></td><td><code>myself</code></td></tr><tr><td><code>[,]</code></td><td>并集运算符</td><td><code>{.items[*]['metadata.name', 'status.capacity']}</code></td><td><code>127.0.0.1 127.0.0.2 map[cpu:4] map[cpu:8]</code></td></tr><tr><td><code>?()</code></td><td>过滤</td><td><code>{.users[?(@.name=="e2e")].user.password}</code></td><td><code>secret</code></td></tr><tr><td><code>range</code>, <code>end</code></td><td>迭代列表</td><td><code>{range .items[*]}[{.metadata.name}, {.status.capacity}] {end}</code></td><td><code>[127.0.0.1, map[cpu:4]] [127.0.0.2, map[cpu:8]]</code></td></tr><tr><td><code>''</code></td><td>引用解释执行字符串</td><td><code>{range .items[*]}{.metadata.name}{'\t'}{end}</code></td><td><code>127.0.0.1 127.0.0.2</code></td></tr></tbody></table><p>使用 <code>kubectl</code> 和 JSONPath 表达式的示例:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -o json
</span></span><span style=display:flex><span>kubectl get pods -o<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{@}&#39;</span>
</span></span><span style=display:flex><span>kubectl get pods -o<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.items[0]}&#39;</span>
</span></span><span style=display:flex><span>kubectl get pods -o<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.items[0].metadata.name}&#39;</span>
</span></span><span style=display:flex><span>kubectl get pods -o<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#34;{.items[*][&#39;metadata.name&#39;, &#39;status.capacity&#39;]}&#34;</span>
</span></span><span style=display:flex><span>kubectl get pods -o<span style=color:#666>=</span><span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{range .items[*]}{.metadata.name}{&#34;\t&#34;}{.status.startTime}{&#34;\n&#34;}{end}&#39;</span>
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>在 Windows 上，对于任何包含空格的 JSONPath 模板，你必须使用双引号（不是上面 bash 所示的单引号）。
反过来，这意味着你必须在模板中的所有文字周围使用单引号或转义的双引号。
例如:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cmd data-lang=cmd><span style=display:flex><span>C:<span style=color:#a0a000>\</span><span style=color:#080;font-style:italic>&gt; kubectl get pods -o=jsonpath=&#34;{range .items[*]}{.metadata.name}{&#39;\t&#39;}{.status.startTime}{&#39;\n&#39;}{end}&#34;</span>
</span></span><span style=display:flex><span>C:<span style=color:#a0a000>\</span><span style=color:#080;font-style:italic>&gt; kubectl get pods -o=jsonpath=&#34;{range .items[*]}{.metadata.name}{\&#34;\t\&#34;}{.status.startTime}{\&#34;\n\&#34;}{end}&#34;</span>
</span></span></code></pre></div></div><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>不支持 JSONPath 正则表达式。如需使用正则表达式进行匹配操作，你可以使用如 <code>jq</code> 之类的工具。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># kubectl 的 JSONpath 输出不支持正则表达式</span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 下面的命令不会生效</span>
</span></span><span style=display:flex><span>kubectl get pods -o <span style=color:#b8860b>jsonpath</span><span style=color:#666>=</span><span style=color:#b44>&#39;{.items[?(@.metadata.name=~/^test$/)].metadata.name}&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 下面的命令可以获得所需的结果</span>
</span></span><span style=display:flex><span>kubectl get pods -o json | jq -r <span style=color:#b44>&#39;.items[] | select(.metadata.name | test(&#34;test-&#34;)).spec.containers[].image&#39;</span>
</span></span></code></pre></div></div></div><div class=td-content style=page-break-before:always><h1 id=pg-8de6aceb8bf692c06cced446bac5bc92>5 - kubectl 的用法约定</h1><p><code>kubectl</code> 的推荐用法约定。</p><h2 id=using-kubectl-in-reusable-scripts>在可重用脚本中使用 <code>kubectl</code></h2><p>对于脚本中的稳定输出：</p><ul><li>请求一个面向机器的输出格式，例如 <code>-o name</code>、<code>-o json</code>、<code>-o yaml</code>、<code>-o go template</code> 或 <code>-o jsonpath</code>。</li><li>完全限定版本。例如 <code>jobs.v1.batch/myjob</code>。这将确保 kubectl 不会使用其默认版本，该版本会随着时间的推移而更改。</li><li>不要依赖上下文、首选项或其他隐式状态。</li></ul><h2 id=subresources>子资源</h2><ul><li>你可以将 <code>--subresource</code> alpha 标志用于 kubectl 命令，例如 <code>get</code>、<code>patch</code>、<code>edit</code> 和 <code>replace</code>
来获取和更新所有支持子资源的资源的子资源。目前，仅支持 <code>status</code> 和 <code>scale</code> 子资源。</li><li>针对子资源的 API 协定与完整资源相同。在更新 <code>status</code> 子资源为一个新值时，请记住，
子资源可能是潜在的由控制器调和为不同的值。</li></ul><h2 id=best-practices>最佳实践</h2><h3 id=kubectl-run><code>kubectl run</code></h3><p>若希望 <code>kubectl run</code> 满足基础设施即代码的要求：</p><ul><li>使用特定版本的标签标记镜像，不要将该标签改为新版本。例如使用 <code>:v1234</code>、<code>v1.2.3</code>、<code>r03062016-1-4</code>，
而不是 <code>:latest</code>（有关详细信息，请参阅<a href=/zh-cn/docs/concepts/configuration/overview/#container-images>配置的最佳实践</a>)。</li><li>使用基于版本控制的脚本来运行包含大量参数的镜像。</li><li>对于无法通过 <code>kubectl run</code> 参数来表示的功能特性，使用基于源码控制的配置文件，以记录要使用的功能特性。</li></ul><p>你可以使用 <code>--dry-run=client</code> 参数来预览而不真正提交即将下发到集群的对象实例：</p><h3 id=kubectl-apply><code>kubectl apply</code></h3><ul><li>你可以使用 <code>kubectl apply</code> 命令创建或更新资源。有关使用 kubectl apply 更新资源的详细信息，请参阅 <a href=https://kubectl.docs.kubernetes.io>Kubectl 文档</a>。</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-a7abc09192597e614b58f8b552b682f5>6 - 适用于 Docker 用户的 kubectl</h1><p>你可以使用 Kubernetes 命令行工具 <code>kubectl</code> 与 API 服务器进行交互。如果你熟悉 Docker 命令行工具，
则使用 kubectl 非常简单。但是，Docker 命令和 kubectl 命令之间有一些区别。以下显示了 Docker 子命令，
并描述了等效的 <code>kubectl</code> 命令。</p><h2 id=docker-run>docker run</h2><p>要运行 nginx 部署并将其暴露，请参见 <a href=/docs/reference/generated/kubectl/kubectl-commands#-em-deployment-em->kubectl create deployment</a></p><p>使用 Docker 命令：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker run -d --restart<span style=color:#666>=</span>always -e <span style=color:#b8860b>DOMAIN</span><span style=color:#666>=</span>cluster --name nginx-app -p 80:80 nginx
</span></span></code></pre></div><pre tabindex=0><code>55c103fa129692154a7652490236fee9be47d70a8dd562281ae7d2f9a339a6db
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker ps
</span></span></code></pre></div><pre tabindex=0><code>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                NAMES
55c103fa1296        nginx               &#34;nginx -g &#39;daemon of…&#34;   9 seconds ago       Up 9 seconds        0.0.0.0:80-&gt;80/tcp   nginx-app
</code></pre><p>使用 kubectl 命令：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 启动运行 nginx 的 Pod</span>
</span></span><span style=display:flex><span>kubectl create deployment --image<span style=color:#666>=</span>nginx nginx-app
</span></span></code></pre></div><pre tabindex=0><code>deployment.apps/nginx-app created
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 添加 env 到 nginx-app</span>
</span></span><span style=display:flex><span>kubectl <span style=color:#a2f>set</span> env deployment/nginx-app  <span style=color:#b8860b>DOMAIN</span><span style=color:#666>=</span>cluster
</span></span></code></pre></div><pre tabindex=0><code>deployment.apps/nginx-app env updated
</code></pre><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p><code>kubectl</code> 命令打印创建或突变资源的类型和名称，然后可以在后续命令中使用。部署后，你可以公开新服务。</div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># 通过服务公开端口</span>
</span></span><span style=display:flex><span>kubectl expose deployment nginx-app --port<span style=color:#666>=</span><span style=color:#666>80</span> --name<span style=color:#666>=</span>nginx-http
</span></span></code></pre></div><pre tabindex=0><code>service &#34;nginx-http&#34; exposed
</code></pre><p>在 kubectl 命令中，我们创建了一个 <a href=/zh-cn/docs/concepts/workloads/controllers/deployment/>Deployment</a>，
这将保证有 N 个运行 nginx 的 Pod（N 代表 spec 中声明的副本数，默认为 1）。
我们还创建了一个 <a href=/zh-cn/docs/concepts/services-networking/service/>service</a>，其选择算符与容器标签匹配。
查看<a href=/zh-cn/docs/tasks/access-application-cluster/service-access-application-cluster>使用服务访问集群中的应用程序</a>获取更多信息。</p><p>默认情况下镜像会在后台运行，与 <code>docker run -d ...</code> 类似，如果你想在前台运行，
使用 <a href=/docs/reference/generated/kubectl/kubectl-commands/#run><code>kubectl run</code></a> 在前台运行 Pod:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl run <span style=color:#666>[</span>-i<span style=color:#666>]</span> <span style=color:#666>[</span>--tty<span style=color:#666>]</span> --attach &lt;name&gt; --image<span style=color:#666>=</span>&lt;image&gt;
</span></span></code></pre></div><p>与 <code>docker run ...</code> 不同的是，如果指定了 <code>--attach</code>，我们将连接到 <code>stdin</code>、<code>stdout</code> 和 <code>stderr</code>，
而不能控制具体连接到哪个输出流（<code>docker -a ...</code>）。要从容器中退出，可以输入 Ctrl + P，然后按 Ctrl + Q。</p><p>因为我们使用 Deployment 启动了容器，如果你终止连接到的进程（例如 <code>ctrl-c</code>），容器将会重启，
这跟 <code>docker run -it</code> 不同。如果想销毁该 Deployment（和它的 Pod），
你需要运行 <code>kubectl delete deployment &lt;name></code>。</p><h2 id=docker-ps>docker ps</h2><p>如何列出哪些正在运行？查看 <a href=/docs/reference/generated/kubectl/kubectl-commands/#get>kubectl get</a>。</p><p>使用 Docker 命令：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker ps -a
</span></span></code></pre></div><pre tabindex=0><code>CONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS                     PORTS                NAMES
14636241935f        ubuntu:16.04        &#34;echo test&#34;              5 seconds ago        Exited (0) 5 seconds ago                        cocky_fermi
55c103fa1296        nginx               &#34;nginx -g &#39;daemon of…&#34;   About a minute ago   Up About a minute          0.0.0.0:80-&gt;80/tcp   nginx-app
</code></pre><p>使用 kubectl 命令：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get po
</span></span></code></pre></div><pre tabindex=0><code>NAME                        READY     STATUS      RESTARTS   AGE
nginx-app-8df569cb7-4gd89   1/1       Running     0          3m
ubuntu                      0/1       Completed   0          20s
</code></pre><h2 id=docker-attach>docker attach</h2><p>如何连接到已经运行在容器中的进程？
查看 <a href=/docs/reference/generated/kubectl/kubectl-commands/#attach>kubectl attach</a>。</p><p>使用 Docker 命令：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker ps
</span></span></code></pre></div><pre tabindex=0><code>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                NAMES
55c103fa1296        nginx               &#34;nginx -g &#39;daemon of…&#34;   5 minutes ago       Up 5 minutes        0.0.0.0:80-&gt;80/tcp   nginx-app
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker attach 55c103fa1296
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>kubectl:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods
</span></span></code></pre></div><pre tabindex=0><code>NAME              READY     STATUS    RESTARTS   AGE
nginx-app-5jyvm   1/1       Running   0          10m
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl attach -it nginx-app-5jyvm
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>要从容器中分离，可以输入 Ctrl + P，然后按 Ctrl + Q。</p><h2 id=docker-exec>docker exec</h2><p>如何在容器中执行命令？查看 <a href=/docs/reference/generated/kubectl/kubectl-commands/#exec>kubectl exec</a>。</p><p>使用 Docker 命令：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker ps
</span></span></code></pre></div><pre tabindex=0><code>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                NAMES
55c103fa1296        nginx               &#34;nginx -g &#39;daemon of…&#34;   6 minutes ago       Up 6 minutes        0.0.0.0:80-&gt;80/tcp   nginx-app
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker <span style=color:#a2f>exec</span> 55c103fa1296 cat /etc/hostname
</span></span></code></pre></div><pre tabindex=0><code>55c103fa1296
</code></pre><p>使用 kubectl 命令：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get po
</span></span></code></pre></div><pre tabindex=0><code>NAME              READY     STATUS    RESTARTS   AGE
nginx-app-5jyvm   1/1       Running   0          10m
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> nginx-app-5jyvm -- cat /etc/hostname
</span></span></code></pre></div><pre tabindex=0><code>nginx-app-5jyvm
</code></pre><p>执行交互式命令怎么办？</p><p>使用 Docker 命令：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker <span style=color:#a2f>exec</span> -ti 55c103fa1296 /bin/sh
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># exit</span>
</span></span></code></pre></div><p>kubectl:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl <span style=color:#a2f>exec</span> -ti nginx-app-5jyvm -- /bin/sh
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># exit</span>
</span></span></code></pre></div><p>更多信息请查看<a href=/zh-cn/docs/tasks/debug/debug-application/get-shell-running-container/>获取运行中容器的 Shell 环境</a>。</p><h2 id=docker-logs>docker logs</h2><p>如何查看运行中进程的 stdout/stderr？查看 <a href=/docs/reference/generated/kubectl/kubectl-commands/#logs>kubectl logs</a>。</p><p>使用 Docker 命令：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker logs -f a9e
</span></span></code></pre></div><pre tabindex=0><code>192.168.9.1 - - [14/Jul/2015:01:04:02 +0000] &#34;GET / HTTP/1.1&#34; 200 612 &#34;-&#34; &#34;curl/7.35.0&#34; &#34;-&#34;
192.168.9.1 - - [14/Jul/2015:01:04:03 +0000] &#34;GET / HTTP/1.1&#34; 200 612 &#34;-&#34; &#34;curl/7.35.0&#34; &#34;-&#34;
</code></pre><p>使用 kubectl 命令：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl logs -f nginx-app-zibvs
</span></span></code></pre></div><pre tabindex=0><code>10.240.63.110 - - [14/Jul/2015:01:09:01 +0000] &#34;GET / HTTP/1.1&#34; 200 612 &#34;-&#34; &#34;curl/7.26.0&#34; &#34;-&#34;
10.240.63.110 - - [14/Jul/2015:01:09:02 +0000] &#34;GET / HTTP/1.1&#34; 200 612 &#34;-&#34; &#34;curl/7.26.0&#34; &#34;-&#34;
</code></pre><p>现在是时候提一下 Pod 和容器之间的细微差别了；默认情况下如果 Pod 中的进程退出 Pod 也不会终止，
相反它将会重启该进程。这类似于 docker run 时的 <code>--restart=always</code> 选项，这是主要差别。
在 Docker 中，进程的每个调用的输出都是被连接起来的，但是对于 Kubernetes，每个调用都是分开的。
要查看以前在 Kubernetes 中执行的输出，请执行以下操作：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl logs --previous nginx-app-zibvs
</span></span></code></pre></div><pre tabindex=0><code>10.240.63.110 - - [14/Jul/2015:01:09:01 +0000] &#34;GET / HTTP/1.1&#34; 200 612 &#34;-&#34; &#34;curl/7.26.0&#34; &#34;-&#34;
10.240.63.110 - - [14/Jul/2015:01:09:02 +0000] &#34;GET / HTTP/1.1&#34; 200 612 &#34;-&#34; &#34;curl/7.26.0&#34; &#34;-&#34;
</code></pre><p>查看<a href=/zh-cn/docs/concepts/cluster-administration/logging/>日志架构</a>获取更多信息。</p><h2 id=docker-stop-and-docker-rm>docker stop 和 docker rm</h2><p>如何停止和删除运行中的进程？查看 <a href=/docs/reference/generated/kubectl/kubectl-commands/#delete>kubectl delete</a>。</p><p>使用 Docker 命令：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker ps
</span></span></code></pre></div><pre tabindex=0><code>CONTAINER ID        IMAGE               COMMAND                CREATED             STATUS              PORTS                         NAMES
a9ec34d98787        nginx               &#34;nginx -g &#39;daemon of&#34;  22 hours ago        Up 22 hours         0.0.0.0:80-&gt;80/tcp, 443/tcp   nginx-app
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker stop a9ec34d98787
</span></span></code></pre></div><pre tabindex=0><code>a9ec34d98787
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker rm a9ec34d98787
</span></span></code></pre></div><pre tabindex=0><code>a9ec34d98787
</code></pre><p>使用 kubectl 命令：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get deployment nginx-app
</span></span></code></pre></div><pre tabindex=0><code>NAME         READY   UP-TO-DATE   AVAILABLE   AGE
nginx-app    1/1     1            1           2m
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get po -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx-app
</span></span></code></pre></div><pre tabindex=0><code>NAME                         READY     STATUS    RESTARTS   AGE
nginx-app-2883164633-aklf7   1/1       Running   0          2m
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete deployment nginx-app
</span></span></code></pre></div><pre tabindex=0><code>deployment &#34;nginx-app&#34; deleted
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get po -l <span style=color:#b8860b>app</span><span style=color:#666>=</span>nginx-app
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># 什么都没有返回</span>
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>请注意，我们不直接删除 Pod。使用 kubectl 命令，我们要删除拥有该 Pod 的 Deployment。
如果我们直接删除 Pod，Deployment 将会重新创建该 Pod。</div><h2 id=docker-login>docker login</h2><p>在 kubectl 中没有对 <code>docker login</code> 的直接模拟。如果你有兴趣在私有镜像仓库中使用 Kubernetes，
请参阅<a href=/zh-cn/docs/concepts/containers/images/#using-a-private-registry>使用私有镜像仓库</a>。</p><h2 id=docker-version>docker version</h2><p>如何查看客户端和服务端的版本？查看 <a href=/docs/reference/generated/kubectl/kubectl-commands/#version>kubectl version</a>。</p><p>使用 Docker 命令：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker version
</span></span></code></pre></div><pre tabindex=0><code>Client version: 1.7.0
Client API version: 1.19
Go version (client): go1.4.2
Git commit (client): 0baf609
OS/Arch (client): linux/amd64
Server version: 1.7.0
Server API version: 1.19
Go version (server): go1.4.2
Git commit (server): 0baf609
OS/Arch (server): linux/amd64
</code></pre><p>使用 kubectl 命令：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl version
</span></span></code></pre></div><pre tabindex=0><code>Client Version: version.Info{Major:&#34;1&#34;, Minor:&#34;6&#34;, GitVersion:&#34;v1.6.9+a3d1dfa6f4335&#34;, GitCommit:&#34;9b77fed11a9843ce3780f70dd251e92901c43072&#34;, GitTreeState:&#34;dirty&#34;, BuildDate:&#34;2017-08-29T20:32:58Z&#34;, OpenPaasKubernetesVersion:&#34;v1.03.02&#34;, GoVersion:&#34;go1.7.5&#34;, Compiler:&#34;gc&#34;, Platform:&#34;linux/amd64&#34;}
Server Version: version.Info{Major:&#34;1&#34;, Minor:&#34;6&#34;, GitVersion:&#34;v1.6.9+a3d1dfa6f4335&#34;, GitCommit:&#34;9b77fed11a9843ce3780f70dd251e92901c43072&#34;, GitTreeState:&#34;dirty&#34;, BuildDate:&#34;2017-08-29T20:32:58Z&#34;, OpenPaasKubernetesVersion:&#34;v1.03.02&#34;, GoVersion:&#34;go1.7.5&#34;, Compiler:&#34;gc&#34;, Platform:&#34;linux/amd64&#34;}
</code></pre><h2 id=docker-info>docker info</h2><p>如何获取有关环境和配置的各种信息？查看 <a href=/docs/reference/generated/kubectl/kubectl-commands/#cluster-info>kubectl cluster-info</a>。</p><p>使用 Docker 命令：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>docker info
</span></span></code></pre></div><pre tabindex=0><code>Containers: 40
Images: 168
Storage Driver: aufs
 Root Dir: /usr/local/google/docker/aufs
 Backing Filesystem: extfs
 Dirs: 248
 Dirperm1 Supported: false
Execution Driver: native-0.2
Logging Driver: json-file
Kernel Version: 3.13.0-53-generic
Operating System: Ubuntu 14.04.2 LTS
CPUs: 12
Total Memory: 31.32 GiB
Name: k8s-is-fun.mtv.corp.google.com
ID: ADUV:GCYR:B3VJ:HMPO:LNPQ:KD5S:YKFQ:76VN:IANZ:7TFV:ZBF4:BYJO
WARNING: No swap limit support
</code></pre><p>使用 kubectl 命令：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl cluster-info
</span></span></code></pre></div><pre tabindex=0><code>Kubernetes master is running at https://203.0.113.141
KubeDNS is running at https://203.0.113.141/api/v1/namespaces/kube-system/services/kube-dns/proxy
kubernetes-dashboard is running at https://203.0.113.141/api/v1/namespaces/kube-system/services/kubernetes-dashboard/proxy
Grafana is running at https://203.0.113.141/api/v1/namespaces/kube-system/services/monitoring-grafana/proxy
Heapster is running at https://203.0.113.141/api/v1/namespaces/kube-system/services/monitoring-heapster/proxy
InfluxDB is running at https://203.0.113.141/api/v1/namespaces/kube-system/services/monitoring-influxdb/proxy
</code></pre></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/zh-cn/docs/home/>主页</a>
<a class=text-white href=/zh-cn/blog/>博客</a>
<a class=text-white href=/zh-cn/training/>培训</a>
<a class=text-white href=/zh-cn/partners/>合作伙伴</a>
<a class=text-white href=/zh-cn/community/>社区</a>
<a class=text-white href=/zh-cn/case-studies/>案例分析</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 The Kubernetes 作者 | 文档发布基于 <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a> 授权许可</small><br><small class=text-white>Copyright &copy; 2023 Linux 基金会&reg;。保留所有权利。Linux 基金会已注册并使用商标。如需了解 Linux 基金会的商标列表，请访问<a href=https://www.linuxfoundation.org/trademark-usage class=light-text>商标使用页面</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>