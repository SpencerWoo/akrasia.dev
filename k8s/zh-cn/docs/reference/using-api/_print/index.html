<!doctype html><html lang=zh-cn class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=en href=https://kubernetes.io/docs/reference/using-api/><link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/reference/using-api/><link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/reference/using-api/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/reference/using-api/><link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/reference/using-api/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/reference/using-api/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/zh-cn/docs/reference/using-api/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>API 概述 | Kubernetes</title><meta property="og:title" content="API 概述"><meta property="og:description" content="生产级别的容器编排系统"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/zh-cn/docs/reference/using-api/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="API 概述"><meta itemprop=description content="生产级别的容器编排系统"><meta name=twitter:card content="summary"><meta name=twitter:title content="API 概述"><meta name=twitter:description content="生产级别的容器编排系统"><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content="本文提供了 Kubernetes API 的参考信息。
REST API 是 Kubernetes 的基本结构。 所有操作和组件之间的通信及外部用户命令都是调用 API 服务器处理的 REST API。 因此，Kubernetes 平台视一切皆为 API 对象， 且它们在 API 中有相应的定义。
Kubernetes API 参考 列出了 Kubernetes v1.25 版本的 API。
如需了解一般背景信息，请查阅 Kubernetes API。 Kubernetes API 控制访问描述了客户端如何向 Kubernetes API 服务器进行身份认证以及他们的请求如何被鉴权。
API 版本控制 JSON 和 Protobuf 序列化模式遵循相同的模式更改原则。 以下描述涵盖了这两种格式。
API 版本控制和软件版本控制是间接相关的。 API 和发布版本控制提案描述了 API 版本控制和软件版本控制间的关系。
不同的 API 版本代表着不同的稳定性和支持级别。 你可以在 API 变更文档 中查看到更多的不同级别的判定标准。
下面是每个级别的摘要：
Alpha： 版本名称包含 alpha（例如：v1alpha1）。 内置的 Alpha API 版本默认被禁用且必须在 kube-apiserver 配置中显式启用才能使用。 软件可能会有 Bug。启用某个特性可能会暴露出 Bug。 对某个 Alpha API 特性的支持可能会随时被删除，恕不另行通知。 API 可能在以后的软件版本中以不兼容的方式更改，恕不另行通知。 由于缺陷风险增加和缺乏长期支持，建议该软件仅用于短期测试集群。 Beta："><meta property="og:description" content="本文提供了 Kubernetes API 的参考信息。
REST API 是 Kubernetes 的基本结构。 所有操作和组件之间的通信及外部用户命令都是调用 API 服务器处理的 REST API。 因此，Kubernetes 平台视一切皆为 API 对象， 且它们在 API 中有相应的定义。
Kubernetes API 参考 列出了 Kubernetes v1.25 版本的 API。
如需了解一般背景信息，请查阅 Kubernetes API。 Kubernetes API 控制访问描述了客户端如何向 Kubernetes API 服务器进行身份认证以及他们的请求如何被鉴权。
API 版本控制 JSON 和 Protobuf 序列化模式遵循相同的模式更改原则。 以下描述涵盖了这两种格式。
API 版本控制和软件版本控制是间接相关的。 API 和发布版本控制提案描述了 API 版本控制和软件版本控制间的关系。
不同的 API 版本代表着不同的稳定性和支持级别。 你可以在 API 变更文档 中查看到更多的不同级别的判定标准。
下面是每个级别的摘要：
Alpha： 版本名称包含 alpha（例如：v1alpha1）。 内置的 Alpha API 版本默认被禁用且必须在 kube-apiserver 配置中显式启用才能使用。 软件可能会有 Bug。启用某个特性可能会暴露出 Bug。 对某个 Alpha API 特性的支持可能会随时被删除，恕不另行通知。 API 可能在以后的软件版本中以不兼容的方式更改，恕不另行通知。 由于缺陷风险增加和缺乏长期支持，建议该软件仅用于短期测试集群。 Beta："><meta name=twitter:description content="本文提供了 Kubernetes API 的参考信息。
REST API 是 Kubernetes 的基本结构。 所有操作和组件之间的通信及外部用户命令都是调用 API 服务器处理的 REST API。 因此，Kubernetes 平台视一切皆为 API 对象， 且它们在 API 中有相应的定义。
Kubernetes API 参考 列出了 Kubernetes v1.25 版本的 API。
如需了解一般背景信息，请查阅 Kubernetes API。 Kubernetes API 控制访问描述了客户端如何向 Kubernetes API 服务器进行身份认证以及他们的请求如何被鉴权。
API 版本控制 JSON 和 Protobuf 序列化模式遵循相同的模式更改原则。 以下描述涵盖了这两种格式。
API 版本控制和软件版本控制是间接相关的。 API 和发布版本控制提案描述了 API 版本控制和软件版本控制间的关系。
不同的 API 版本代表着不同的稳定性和支持级别。 你可以在 API 变更文档 中查看到更多的不同级别的判定标准。
下面是每个级别的摘要：
Alpha： 版本名称包含 alpha（例如：v1alpha1）。 内置的 Alpha API 版本默认被禁用且必须在 kube-apiserver 配置中显式启用才能使用。 软件可能会有 Bug。启用某个特性可能会暴露出 Bug。 对某个 Alpha API 特性的支持可能会随时被删除，恕不另行通知。 API 可能在以后的软件版本中以不兼容的方式更改，恕不另行通知。 由于缺陷风险增加和缺乏长期支持，建议该软件仅用于短期测试集群。 Beta："><meta property="og:url" content="https://kubernetes.io/zh-cn/docs/reference/using-api/"><meta property="og:title" content="API 概述"><meta name=twitter:title content="API 概述"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/zh-cn/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/zh-cn/docs/>文档</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/zh-cn/blog/>Kubernetes 博客</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/zh-cn/training/>培训</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/zh-cn/partners/>合作伙伴</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/zh-cn/community/>社区</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/zh-cn/case-studies/>案例分析</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>版本列表</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/zh-cn/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/zh-cn/docs/reference/using-api/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/zh-cn/docs/reference/using-api/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/zh-cn/docs/reference/using-api/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/zh-cn/docs/reference/using-api/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/zh-cn/docs/reference/using-api/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>中文 (Chinese)</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/docs/reference/using-api/>English</a>
<a class=dropdown-item href=/ko/docs/reference/using-api/>한국어 (Korean)</a>
<a class=dropdown-item href=/ja/docs/reference/using-api/>日本語 (Japanese)</a>
<a class=dropdown-item href=/fr/docs/reference/using-api/>Français (French)</a>
<a class=dropdown-item href=/de/docs/reference/using-api/>Deutsch (German)</a>
<a class=dropdown-item href=/es/docs/reference/using-api/>Español (Spanish)</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>这是本节的多页打印视图。
<a href=# onclick="return print(),!1">点击此处打印</a>.</p><p><a href=/zh-cn/docs/reference/using-api/>返回本页常规视图</a>.</p></div><h1 class=title>API 概述</h1><ul><li>1: <a href=#pg-2b5428a2ff6f4831fd972ef50e12b3eb>Kubernetes API 概念</a></li><li>2: <a href=#pg-040d9484db673074f1b8ba3465be9d91>服务器端应用（Server-Side Apply）</a></li><li>3: <a href=#pg-79880efc25dc8cb3b6962ad78a964319>客户端库</a></li><li>4: <a href=#pg-8d2ce3e7b2223cda0ccd428f4d5ea24b>Kubernetes 弃用策略</a></li><li>5: <a href=#pg-2479c39af50fd55b898a3bcfb5988077>已弃用 API 的迁移指南</a></li><li>6: <a href=#pg-e4dbb59f8f23854d7b7d574e169923c4>Kubernetes API 健康端点</a></li></ul><div class=content><p>本文提供了 Kubernetes API 的参考信息。</p><p>REST API 是 Kubernetes 的基本结构。
所有操作和组件之间的通信及外部用户命令都是调用 API 服务器处理的 REST API。
因此，Kubernetes 平台视一切皆为 API 对象，
且它们在 <a href=/docs/reference/generated/kubernetes-api/v1.25/>API</a> 中有相应的定义。</p><p><a href=/docs/reference/generated/kubernetes-api/v1.25/>Kubernetes API 参考</a>
列出了 Kubernetes v1.25 版本的 API。</p><p>如需了解一般背景信息，请查阅 <a href=/zh-cn/docs/concepts/overview/kubernetes-api/>Kubernetes API</a>。
<a href=/zh-cn/docs/concepts/security/controlling-access/>Kubernetes API 控制访问</a>描述了客户端如何向
Kubernetes API 服务器进行身份认证以及他们的请求如何被鉴权。</p><h2 id=api-reference>API 版本控制</h2><p>JSON 和 Protobuf 序列化模式遵循相同的模式更改原则。
以下描述涵盖了这两种格式。</p><p>API 版本控制和软件版本控制是间接相关的。
<a href=https://git.k8s.io/sig-release/release-engineering/versioning.md>API 和发布版本控制提案</a>描述了
API 版本控制和软件版本控制间的关系。</p><p>不同的 API 版本代表着不同的稳定性和支持级别。
你可以在 <a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api_changes.md#alpha-beta-and-stable-versions>API 变更文档</a>
中查看到更多的不同级别的判定标准。</p><p>下面是每个级别的摘要：</p><ul><li>Alpha：<ul><li>版本名称包含 <code>alpha</code>（例如：<code>v1alpha1</code>）。</li><li>内置的 Alpha API 版本默认被禁用且必须在 <code>kube-apiserver</code> 配置中显式启用才能使用。</li><li>软件可能会有 Bug。启用某个特性可能会暴露出 Bug。</li><li>对某个 Alpha API 特性的支持可能会随时被删除，恕不另行通知。</li><li>API 可能在以后的软件版本中以不兼容的方式更改，恕不另行通知。</li><li>由于缺陷风险增加和缺乏长期支持，建议该软件仅用于短期测试集群。</li></ul></li></ul><ul><li><p>Beta：</p><ul><li>版本名称包含 <code>beta</code>（例如：<code>v2beta3</code>）。</li><li>内置的 Beta API 版本默认被禁用且必须在 <code>kube-apiserver</code> 配置中显式启用才能使用
（例外情况是 Kubernetes 1.22 之前引入的 Beta 版本的 API，这些 API 默认被启用）。</li><li>内置 Beta API 版本从引入到弃用的最长生命周期为 9 个月或 3 个次要版本（以较长者为准），
从弃用到移除的最长生命周期为 9 个月或 3 个次要版本（以较长者为准）。</li><li>软件被很好的测试过。启用某个特性被认为是安全的。</li><li>尽管一些特性会发生细节上的变化，但它们将会被长期支持。</li></ul><ul><li>在随后的 Beta 版或 Stable 版中，对象的模式和（或）语义可能以不兼容的方式改变。
当这种情况发生时，将提供迁移说明。
适配后续的 Beta 或 Stable API 版本可能需要编辑或重新创建 API 对象，这可能并不简单。
对于依赖此功能的应用程序，可能需要停机迁移。</li><li>该版本的软件不建议生产使用。
后续发布版本可能会有不兼容的变动。
一旦 Beta API 版本被弃用且不再提供服务，
则使用 Beta API 版本的用户需要转为使用后续的 Beta 或 Stable API 版本。</li></ul><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>请尝试 Beta 版时特性时并提供反馈。
特性完成 Beta 阶段测试后，就可能不会有太多的变更了。</div></li></ul><ul><li>Stable：<ul><li>版本名称如 <code>vX</code>，其中 <code>X</code> 为整数。</li><li>特性的 Stable 版本会出现在后续很多版本的发布软件中。
Stable API 版本仍然适用于 Kubernetes 主要版本范围内的所有后续发布，
并且 Kubernetes 的主要版本当前没有移除 Stable API 的修订计划。</li></ul></li></ul><h2 id=api-groups>API 组</h2><p><a href=https://git.k8s.io/design-proposals-archive/api-machinery/api-group.md>API 组</a>能够简化对
Kubernetes API 的扩展。API 组信息出现在 REST 路径中，也出现在序列化对象的 <code>apiVersion</code> 字段中。</p><p>以下是 Kubernetes 中的几个组：</p><ul><li><strong>核心（core）</strong>（也被称为 <strong>legacy</strong>）组的 REST 路径为 <code>/api/v1</code>。
核心组并不作为 <code>apiVersion</code> 字段的一部分，例如， <code>apiVersion: v1</code>。</li><li>指定的组位于 REST 路径 <code>/apis/$GROUP_NAME/$VERSION</code>，
并且使用 <code>apiVersion: $GROUP_NAME/$VERSION</code> （例如，<code>apiVersion: batch/v1</code>）。
你可以在 <a href=/docs/reference/generated/kubernetes-api/v1.25/#-strong-api-groups-strong->Kubernetes API 参考文档</a>
中查看全部的 API 组。</li></ul><h2 id=enabling-or-disabling>启用或禁用 API 组</h2><p>资源和 API 组是在默认情况下被启用的。
你可以通过在 API 服务器上设置 <code>--runtime-config</code> 参数来启用或禁用它们。
<code>--runtime-config</code> 参数接受逗号分隔的 <code>&lt;key>[=&lt;value>]</code> 对，
来描述 API 服务器的运行时配置。如果省略了 <code>=&lt;value></code> 部分，那么视其指定为 <code>=true</code>。
例如：</p><ul><li>禁用 <code>batch/v1</code>，对应参数设置 <code>--runtime-config=batch/v1=false</code></li><li>启用 <code>batch/v2alpha1</code>，对应参数设置 <code>--runtime-config=batch/v2alpha1</code></li><li>要启用特定版本的 API，如 <code>storage.k8s.io/v1beta1/csistoragecapacities</code>，可以设置
<code>--runtime-config=storage.k8s.io/v1beta1/csistoragecapacities</code></li></ul><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>启用或禁用组或资源时，
你需要重启 API 服务器和控制器管理器来使 <code>--runtime-config</code> 生效。</div><h2 id=persistence>持久化</h2><p>Kubernetes 通过 API 资源来将序列化的状态写到 <a class=glossary-tooltip title='一致且高度可用的键值存储，用作 Kubernetes 的所有集群数据的后台数据库。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/tasks/administer-cluster/configure-upgrade-etcd/ target=_blank aria-label=etcd>etcd</a> 中存储。</p><h2 id=接下来>接下来</h2><ul><li>进一步了解 <a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#api-conventions>API 惯例</a></li><li>阅读<a href=https://git.k8s.io/design-proposals-archive/api-machinery/aggregated-api-servers.md>聚合器</a></li></ul></div></div><div class=td-content style=page-break-before:always><h1 id=pg-2b5428a2ff6f4831fd972ef50e12b3eb>1 - Kubernetes API 概念</h1><p>Kubernetes API 是通过 HTTP 提供的基于资源 (RESTful) 的编程接口。
它支持通过标准 HTTP 动词（POST、PUT、PATCH、DELETE、GET）检索、创建、更新和删除主要资源。</p><p>对于某些资源，API 包括额外的子资源，允许细粒度授权（例如：将 Pod 的详细信息与检索日志分开），
为了方便或者提高效率，可以以不同的表示形式接受和服务这些资源。</p><p>Kubernetes 支持通过 <strong>watch</strong> 实现高效的资源变更通知。
Kubernetes 还提供了一致的列表操作，以便 API 客户端可以有效地缓存、跟踪和同步资源的状态。</p><p>你可以在线查看 <a href=/zh-cn/docs/reference/kubernetes-api/>API 参考</a>，
或继续阅读以了解 API 的一般信息。</p><h2 id=standard-api-terminology>Kubernetes API 术语</h2><p>Kubernetes 通常使用常见的 RESTful 术语来描述 API 概念：</p><ul><li><strong>资源类型（Resource Type）</strong> 是 URL 中使用的名称（<code>pods</code>、<code>namespaces</code>、<code>services</code>）</li><li>所有资源类型都有一个具体的表示（它们的对象模式），称为 <strong>类别（Kind）</strong></li><li>资源实例的列表称为 <strong>集合（Collection）</strong></li><li>资源类型的单个实例称为 <strong>资源（Resource）</strong>，通常也表示一个 <strong>对象（Object）</strong></li><li>对于某些资源类型，API 包含一个或多个 <strong>子资源（sub-resources）</strong>，这些子资源表示为资源下的 URI 路径</li></ul><p>大多数 Kubernetes API
资源类型都是<a href=/zh-cn/docs/concepts/overview/working-with-objects/kubernetes-objects/#kubernetes-objects>对象</a>：
它们代表集群上某个概念的具体实例，例如 Pod 或命名空间。
少数 API 资源类型是 “虚拟的”，它们通常代表的是操作而非对象本身，
例如权限检查（使用带有 JSON 编码的 <code>SubjectAccessReview</code> 主体的 POST 到 <code>subjectaccessreviews</code> 资源），
或 Pod 的子资源 <code>eviction</code>（用于触发 <a href=/zh-cn/docs/concepts/scheduling-eviction/api-eviction/>API-发起的驱逐</a>）。</p><h3 id=object-names>对象名字</h3><p>你可以通过 API 创建的所有对象都有一个唯一的<a class=glossary-tooltip title='客户端提供的字符串，用来指代资源 URL 中的对象，如 /api/v1/pods/some-name。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/overview/working-with-objects/names/ target=_blank aria-label=名字>名字</a>，
以允许幂等创建和检索，
但如果虚拟资源类型不可检索或不依赖幂等性，则它们可能没有唯一名称。
在<a class=glossary-tooltip title='名字空间是 Kubernetes 用来支持隔离单个集群中的资源组的一种抽象。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/overview/working-with-objects/namespaces/ target=_blank aria-label=命名空间>命名空间</a>内，
同一时刻只能有一个给定类别的对象具有给定名称。
但是，如果你删除该对象，你可以创建一个具有相同名称的新对象。
有些对象没有命名空间（例如：节点），因此它们的名称在整个集群中必须是唯一的。</p><h3 id=api-verbs>API 动词</h3><p>几乎所有对象资源类型都支持标准 HTTP 动词 - GET、POST、PUT、PATCH 和 DELETE。
Kubernetes 也使用自己的动词，这些动词通常写成小写，以区别于 HTTP 动词。</p><p>Kubernetes 使用术语 <strong>list</strong> 来描述返回资源<a href=#collections>集合</a>，
以区别于通常称为 <strong>get</strong> 的单个资源检索。
如果你发送带有 <code>?watch</code> 查询参数的 HTTP GET 请求，
Kubernetes 将其称为 <strong>watch</strong> 而不是 <strong>get</strong>（有关详细信息，请参阅<a href=#efficient-detection-of-changes>快速检测更改</a>）。</p><p>对于 PUT 请求，Kubernetes 在内部根据现有对象的状态将它们分类为 <strong>create</strong> 或 <strong>update</strong>。
<strong>update</strong> 不同于 <strong>patch</strong>；<strong>patch</strong> 的 HTTP 动词是 PATCH。</p><h2 id=resource-uris>资源 URI</h2><p>所有资源类型要么是集群作用域的（<code>/apis/GROUP/VERSION/*</code>），
要么是名字空间作用域的（<code>/apis/GROUP/VERSION/namespaces/NAMESPACE/*</code>）。
名字空间作用域的资源类型会在其名字空间被删除时也被删除，
并且对该资源类型的访问是由定义在名字空间域中的授权检查来控制的。</p><p>你还可以访问资源集合（例如：列出所有 Node）。以下路径用于检索集合和资源：</p><ul><li>集群作用域的资源：<ul><li><code>GET /apis/GROUP/VERSION/RESOURCETYPE</code> - 返回指定资源类型的资源的集合</li><li><code>GET /apis/GROUP/VERSION/RESOURCETYPE/NAME</code> - 返回指定资源类型下名称为 NAME 的资源</li></ul></li><li>名字空间作用域的资源：<ul><li><code>GET /apis/GROUP/VERSION/RESOURCETYPE</code> - 返回所有名字空间中指定资源类型的全部实例的集合</li><li><code>GET /apis/GROUP/VERSION/namespaces/NAMESPACE/RESOURCETYPE</code> - 返回名字空间 NAMESPACE 内给定资源类型的全部实例的集合</li><li><code>GET /apis/GROUP/VERSION/namespaces/NAMESPACE/RESOURCETYPE/NAME</code> - 返回名字空间 NAMESPACE 中给定资源类型的名称为 NAME 的实例</li></ul></li></ul><p>由于名字空间本身是一个集群作用域的资源类型，你可以通过 <code>GET /api/v1/namespaces/</code>
检视所有名字空间的列表（“集合”），使用 <code>GET /api/v1/namespaces/NAME</code> 查看特定名字空间的详细信息。</p><ul><li>集群作用域的子资源：<code>GET /apis/GROUP/VERSION/RESOURCETYPE/NAME/SUBRESOURCE</code></li><li>名字空间作用域的子资源：<code>GET /apis/GROUP/VERSION/namespaces/NAMESPACE/RESOURCETYPE/NAME/SUBRESOURCE</code></li></ul><p>取决于对象是什么，每个子资源所支持的动词有所不同 - 参见 <a href=/zh-cn/docs/reference/kubernetes-api/>API 文档</a>以了解更多信息。
跨多个资源来访问其子资源是不可能的 - 如果需要这一能力，则通常意味着需要一种新的虚拟资源类型了。</p><h2 id=efficient-detection-of-changes>高效检测变更</h2><p>Kubernetes API 允许客户端对对象或集合发出初始请求，然后跟踪自该初始请求以来的更改：<strong>watch</strong>。
客户端可以发送 <strong>list</strong> 或者 <strong>get</strong> 请求，然后发出后续 <strong>watch</strong> 请求。</p><p>为了使这种更改跟踪成为可能，每个 Kubernetes 对象都有一个 <code>resourceVersion</code> 字段，
表示存储在底层持久层中的该资源的版本。在检索资源集合（命名空间或集群范围）时，
来自 API 服务器的响应包含一个 <code>resourceVersion</code> 值。
客户端可以使用该 <code>resourceVersion</code> 来启动对 API 服务器的 <strong>watch</strong>。</p><p>当你发送 <strong>watch</strong> 请求时，API 服务器会响应更改流。
这些更改逐项列出了在你指定为 <strong>watch</strong> 请求参数的 <code>resourceVersion</code> 之后发生的操作（例如 <strong>create</strong>、<strong>delete</strong> 和 <strong>update</strong>）的结果。
整个 <strong>watch</strong> 机制允许客户端获取当前状态，然后订阅后续更改，而不会丢失任何事件。</p><p>如果客户端 <strong>watch</strong> 连接断开，则该客户端可以从最后返回的 <code>resourceVersion</code> 开始新的 <strong>watch</strong> 请求；
客户端还可以执行新的 <strong>get</strong>/<strong>list</strong> 请求并重新开始。有关更多详细信息，请参阅<a href=#resource-versions>资源版本语义</a>。</p><p>例如：</p><ol><li><p>列举给定名字空间中的所有 Pod：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#888>GET /api/v1/namespaces/test/pods
</span></span></span><span style=display:flex><span><span style=color:#888>---
</span></span></span><span style=display:flex><span><span style=color:#888>200 OK
</span></span></span><span style=display:flex><span><span style=color:#888>Content-Type: application/json
</span></span></span><span style=display:flex><span><span style=color:#888></span><span>
</span></span></span><span style=display:flex><span><span></span><span style=color:#888>{
</span></span></span><span style=display:flex><span><span style=color:#888>  &#34;kind&#34;: &#34;PodList&#34;,
</span></span></span><span style=display:flex><span><span style=color:#888>  &#34;apiVersion&#34;: &#34;v1&#34;,
</span></span></span><span style=display:flex><span><span style=color:#888>  &#34;metadata&#34;: {&#34;resourceVersion&#34;:&#34;10245&#34;},
</span></span></span><span style=display:flex><span><span style=color:#888>  &#34;items&#34;: [...]
</span></span></span><span style=display:flex><span><span style=color:#888>}
</span></span></span></code></pre></div></li></ol><ol start=2><li><p>从资源版本 10245 开始，接收影响 <em>test</em> 命名空间中 Pod 的所有 API 操作
（例如 <strong>create</strong>、<strong>delete</strong>、<strong>apply</strong> 或 <strong>update</strong>）的通知。
每个更改通知都是一个 JSON 文档。
HTTP 响应正文（用作 <code>application/json</code>）由一系列 JSON 文档组成。</p><pre tabindex=0><code>GET /api/v1/namespaces/test/pods?watch=1&amp;resourceVersion=10245
---
200 OK
Transfer-Encoding: chunked
Content-Type: application/json

{
  &#34;type&#34;: &#34;ADDED&#34;,
  &#34;object&#34;: {&#34;kind&#34;: &#34;Pod&#34;, &#34;apiVersion&#34;: &#34;v1&#34;, &#34;metadata&#34;: {&#34;resourceVersion&#34;: &#34;10596&#34;, ...}, ...}
}
{
  &#34;type&#34;: &#34;MODIFIED&#34;,
  &#34;object&#34;: {&#34;kind&#34;: &#34;Pod&#34;, &#34;apiVersion&#34;: &#34;v1&#34;, &#34;metadata&#34;: {&#34;resourceVersion&#34;: &#34;11020&#34;, ...}, ...}
}
...
</code></pre></li></ol><p>给定的 Kubernetes 服务器只会保留一定的时间内发生的历史变更列表。
使用 etcd3 的集群默认保存过去 5 分钟内发生的变更。
当所请求的 <strong>watch</strong> 操作因为资源的历史版本不存在而失败，
客户端必须能够处理因此而返回的状态代码 <code>410 Gone</code>，清空其本地的缓存，
重新执行 <strong>get</strong> 或者 <strong>list</strong> 操作，
并基于新返回的 <code>resourceVersion</code> 来开始新的 <strong>watch</strong> 操作。</p><p>对于订阅集合，Kubernetes 客户端库通常会为 <strong>list</strong> -然后- <strong>watch</strong> 的逻辑提供某种形式的标准工具。
（在 Go 客户端库中，这称为 <code>反射器（Reflector）</code>，位于 <code>k8s.io/client-go/tools/cache</code> 包中。）</p><h3 id=Watch-bookmark>监视书签</h3><p>为了减轻短历史窗口的影响，Kubernetes API 提供了一个名为 <code>BOOKMARK</code> 的监视事件。
这是一种特殊的事件，用于标记客户端请求的给定 <code>resourceVersion</code> 的所有更改都已发送。
代表 <code>BOOKMARK</code> 事件的文档属于请求所请求的类型，但仅包含一个 <code>.metadata.resourceVersion</code> 字段。例如：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#888>GET /api/v1/namespaces/test/pods?watch=1&amp;resourceVersion=10245&amp;allowWatchBookmarks=true
</span></span></span><span style=display:flex><span><span style=color:#888>---
</span></span></span><span style=display:flex><span><span style=color:#888>200 OK
</span></span></span><span style=display:flex><span><span style=color:#888>Transfer-Encoding: chunked
</span></span></span><span style=display:flex><span><span style=color:#888>Content-Type: application/json
</span></span></span><span style=display:flex><span><span style=color:#888></span><span>
</span></span></span><span style=display:flex><span><span></span><span style=color:#888>{
</span></span></span><span style=display:flex><span><span style=color:#888>  &#34;type&#34;: &#34;ADDED&#34;,
</span></span></span><span style=display:flex><span><span style=color:#888>  &#34;object&#34;: {&#34;kind&#34;: &#34;Pod&#34;, &#34;apiVersion&#34;: &#34;v1&#34;, &#34;metadata&#34;: {&#34;resourceVersion&#34;: &#34;10596&#34;, ...}, ...}
</span></span></span><span style=display:flex><span><span style=color:#888>}
</span></span></span><span style=display:flex><span><span style=color:#888>...
</span></span></span><span style=display:flex><span><span style=color:#888>{
</span></span></span><span style=display:flex><span><span style=color:#888>  &#34;type&#34;: &#34;BOOKMARK&#34;,
</span></span></span><span style=display:flex><span><span style=color:#888>  &#34;object&#34;: {&#34;kind&#34;: &#34;Pod&#34;, &#34;apiVersion&#34;: &#34;v1&#34;, &#34;metadata&#34;: {&#34;resourceVersion&#34;: &#34;12746&#34;} }
</span></span></span><span style=display:flex><span><span style=color:#888>}
</span></span></span></code></pre></div><p>作为客户端，你可以在 <strong>watch</strong> 请求中设置 <code>allowWatchBookmarks=true</code> 查询参数来请求 <code>BOOKMARK</code> 事件，
但你不应假设书签会在任何特定时间间隔返回，即使要求时，客户端也不能假设 API 服务器会发送任何 <code>BOOKMARK</code> 事件。</p><h2 id=retrieving-large-results-sets-in-chunks>分块检视大体量结果</h2><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.9 [beta]</code></div><p>在较大规模集群中，检索某些资源类型的集合可能会导致非常大的响应，从而影响服务器和客户端。
例如，一个集群可能有数万个 Pod，每个 Pod 大约相当于 2 KiB 的编码 JSON。
跨所有命名空间检索所有 Pod 可能会导致非常大的响应 (10-20MB) 并消耗大量服务器资源。</p><p>如果你没有明确禁用 <code>APIListChunking</code> <a href=/zh-cn/docs/reference/command-line-tools-reference/feature-gates/>特性门控</a>，
Kubernetes API 服务器支持将单个大型集合请求分解为许多较小块的能力，同时保持总请求的一致性。</p><p>你可以请求 API 服务器通过使用页（Kubernetes 将其称为“块（Chunk）”）的方式来处理 <strong>list</strong>，
完成单个集合的响应。
要以块的形式检索单个集合，针对集合的请求支持两个查询参数 <code>limit</code> 和 <code>continue</code>，
并且从集合元 <code>metadata</code> 字段中的所有 <strong>list</strong> 操作返回响应字段 <code>continue</code>。
客户端应该指定他们希望在每个带有 <code>limit</code> 的块中接收的条目数上限，如果集合中有更多资源，
服务器将在结果中返回 <code>limit</code> 资源并包含一个 <code>continue</code> 值。</p><p>作为 API 客户端，你可以在下一次请求时将 <code>continue</code> 值传递给 API 服务器，
以指示服务器返回下一页（<em>块</em>）结果。继续下去直到服务器返回一个空的 <code>continue</code> 值，
你可以检索整个集合。</p><p>与 <strong>watch</strong> 操作类似，<code>continue</code> 令牌也会在很短的时间（默认为 5 分钟）内过期，
并在无法返回更多结果时返回 <code>410 Gone</code> 代码。
这时，客户端需要从头开始执行上述检视操作或者忽略 <code>limit</code> 参数。</p><p>例如，如果集群上有 1253 个 Pod，客户端希望每次收到包含至多 500 个 Pod
的数据块，它应按下面的步骤来请求数据块：</p><ol><li><p>列举集群中所有 Pod，每次接收至多 500 个 Pod：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#888>GET /api/v1/pods?limit=500
</span></span></span><span style=display:flex><span><span style=color:#888>---
</span></span></span><span style=display:flex><span><span style=color:#888>200 OK
</span></span></span><span style=display:flex><span><span style=color:#888>Content-Type: application/json
</span></span></span><span style=display:flex><span><span style=color:#888></span><span>
</span></span></span><span style=display:flex><span><span></span><span style=color:#888>{
</span></span></span><span style=display:flex><span><span style=color:#888>  &#34;kind&#34;: &#34;PodList&#34;,
</span></span></span><span style=display:flex><span><span style=color:#888>  &#34;apiVersion&#34;: &#34;v1&#34;,
</span></span></span><span style=display:flex><span><span style=color:#888>  &#34;metadata&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#888>    &#34;resourceVersion&#34;:&#34;10245&#34;,
</span></span></span><span style=display:flex><span><span style=color:#888>    &#34;continue&#34;: &#34;ENCODED_CONTINUE_TOKEN&#34;,
</span></span></span><span style=display:flex><span><span style=color:#888>    &#34;remainingItemCount&#34;: 753,
</span></span></span><span style=display:flex><span><span style=color:#888>    ...
</span></span></span><span style=display:flex><span><span style=color:#888>  },
</span></span></span><span style=display:flex><span><span style=color:#888>  &#34;items&#34;: [...] // returns pods 1-500
</span></span></span><span style=display:flex><span><span style=color:#888>}
</span></span></span></code></pre></div></li></ol><ol start=2><li><p>继续前面的调用，返回下一组 500 个 Pod：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#888>GET /api/v1/pods?limit=500&amp;continue=ENCODED_CONTINUE_TOKEN
</span></span></span><span style=display:flex><span><span style=color:#888>---
</span></span></span><span style=display:flex><span><span style=color:#888>200 OK
</span></span></span><span style=display:flex><span><span style=color:#888>Content-Type: application/json
</span></span></span><span style=display:flex><span><span style=color:#888></span><span>
</span></span></span><span style=display:flex><span><span></span><span style=color:#888>{
</span></span></span><span style=display:flex><span><span style=color:#888>  &#34;kind&#34;: &#34;PodList&#34;,
</span></span></span><span style=display:flex><span><span style=color:#888>  &#34;apiVersion&#34;: &#34;v1&#34;,
</span></span></span><span style=display:flex><span><span style=color:#888>  &#34;metadata&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#888>    &#34;resourceVersion&#34;:&#34;10245&#34;,
</span></span></span><span style=display:flex><span><span style=color:#888>    &#34;continue&#34;: &#34;ENCODED_CONTINUE_TOKEN_2&#34;,
</span></span></span><span style=display:flex><span><span style=color:#888>    &#34;remainingItemCount&#34;: 253,
</span></span></span><span style=display:flex><span><span style=color:#888>    ...
</span></span></span><span style=display:flex><span><span style=color:#888>  },
</span></span></span><span style=display:flex><span><span style=color:#888>  &#34;items&#34;: [...] // returns pods 501-1000
</span></span></span><span style=display:flex><span><span style=color:#888>}
</span></span></span></code></pre></div></li></ol><ol start=3><li><p>继续前面的调用，返回最后 253 个 Pod：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#888>GET /api/v1/pods?limit=500&amp;continue=ENCODED_CONTINUE_TOKEN_2
</span></span></span><span style=display:flex><span><span style=color:#888>---
</span></span></span><span style=display:flex><span><span style=color:#888>200 OK
</span></span></span><span style=display:flex><span><span style=color:#888>Content-Type: application/json
</span></span></span><span style=display:flex><span><span style=color:#888></span><span>
</span></span></span><span style=display:flex><span><span></span><span style=color:#888>{
</span></span></span><span style=display:flex><span><span style=color:#888>  &#34;kind&#34;: &#34;PodList&#34;,
</span></span></span><span style=display:flex><span><span style=color:#888>  &#34;apiVersion&#34;: &#34;v1&#34;,
</span></span></span><span style=display:flex><span><span style=color:#888>  &#34;metadata&#34;: {
</span></span></span><span style=display:flex><span><span style=color:#888>    &#34;resourceVersion&#34;:&#34;10245&#34;,
</span></span></span><span style=display:flex><span><span style=color:#888>    &#34;continue&#34;: &#34;&#34;, // continue token is empty because we have reached the end of the list
</span></span></span><span style=display:flex><span><span style=color:#888>    ...
</span></span></span><span style=display:flex><span><span style=color:#888>  },
</span></span></span><span style=display:flex><span><span style=color:#888>  &#34;items&#34;: [...] // returns pods 1001-1253
</span></span></span><span style=display:flex><span><span style=color:#888>}
</span></span></span></code></pre></div></li></ol><p>请注意，集合的 <code>resourceVersion</code> 在每个请求中保持不变，
这表明服务器正在向你显示 Pod 的一致快照。
在版本 <code>10245</code> 之后创建、更新或删除的 Pod 将不会显示，
除非你在没有继续令牌的情况下发出单独的 <strong>list</strong> 请求。
这使你可以将大请求分成更小的块，然后对整个集合执行 <strong>watch</strong> 操作，而不会丢失任何更新。</p><p><code>remainingItemCount</code> 是集合中未包含在此响应中的后续项目的数量。
如果 <strong>list</strong> 请求包含标签或字段<a class=glossary-tooltip title=选择算符允许用户通过标签对一组资源对象进行筛选过滤。 data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/overview/working-with-objects/labels/ target=_blank aria-label=选择器>选择器</a>，
则剩余项目的数量是未知的，并且 API 服务器在其响应中不包含 <code>remainingItemCount</code> 字段。
如果 <strong>list</strong> 是完整的（因为它没有分块，或者因为这是最后一个块），没有更多的剩余项目，
API 服务器在其响应中不包含 <code>remainingItemCount</code> 字段。
<code>remainingItemCount</code> 的用途是估计集合的大小。</p><h2 id=collections>集合</h2><p>在 Kubernetes 术语中，你从 <strong>list</strong> 中获得的响应是一个“集合（Collections）”。
然而，Kubernetes 为不同类型资源的集合定义了具体类型。
集合的类别名是针对资源类别的，并附加了 <code>List</code>。</p><p>当你查询特定类型的 API 时，该查询返回的所有项目都属于该类型。
例如，当你 <strong>list</strong> Service 对象时，集合响应的 <code>kind</code> 设置为
<a href=/zh-cn/docs/reference/kubernetes-api/service-resources/service-v1/#ServiceList><code>ServiceList</code></a>；
该集合中的每个项目都代表一个 Service。例如：</p><pre tabindex=0><code>GET /api/v1/services
</code></pre><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>&#34;kind&#34;: </span><span style=color:#b44>&#34;ServiceList&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>&#34;apiVersion&#34;: </span><span style=color:#b44>&#34;v1&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>&#34;metadata&#34;: </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;resourceVersion&#34;: </span><span style=color:#b44>&#34;2947301&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>},<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>&#34;items&#34;: </span>[<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>&#34;metadata&#34;: </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>&#34;name&#34;: </span><span style=color:#b44>&#34;kubernetes&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>&#34;namespace&#34;: </span><span style=color:#b44>&#34;default&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>&#34;metadata&#34;: </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>&#34;name&#34;: </span><span style=color:#b44>&#34;kube-dns&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>&#34;namespace&#34;: </span><span style=color:#b44>&#34;kube-system&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Kubernetes API 中定义了数十种集合类型（如 <code>PodList</code>、<code>ServiceList</code> 和 <code>NodeList</code>）。
你可以从 <a href=/zh-cn/docs/reference/kubernetes-api/>Kubernetes API</a> 文档中获取有关每种集合类型的更多信息。</p><p>一些工具，例如 <code>kubectl</code>，对于 Kubernetes 集合的表现机制与 Kubernetes API 本身略有不同。
因为 <code>kubectl</code> 的输出可能包含来自 API 级别的多个 <strong>list</strong> 操作的响应，
所以 <code>kubectl</code> 使用 <code>kind: List</code> 表示项目列表。例如：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get services -A -o yaml
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>List<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resourceVersion</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selfLink</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>items</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2021-06-03T14:54:12Z&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>component</span>:<span style=color:#bbb> </span>apiserver<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>provider</span>:<span style=color:#bbb> </span>kubernetes<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>kubernetes<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>prometheus.io/port</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;9153&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>prometheus.io/scrape</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>creationTimestamp</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2021-06-03T14:54:14Z&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>k8s-app</span>:<span style=color:#bbb> </span>kube-dns<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>kubernetes.io/cluster-service</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;true&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>kubernetes.io/name</span>:<span style=color:#bbb> </span>CoreDNS<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>kube-dns<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>kube-system<span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>请记住，Kubernetes API 没有名为 <code>List</code> 的 <code>kind</code>。</p><p><code>kind: List</code> 是一个客户端内部实现细节，用于处理可能属于不同类别的对象的集合。
在自动化或其他代码中避免依赖 <code>kind: List</code>。</p></div><h2 id=receiving-resources-as-tables>以表格形式接收资源</h2><p>当你执行 <code>kubectl get</code> 时，默认的输出格式是特定资源类型的一个或多个实例的简单表格形式。
过去，客户端需要重复 <code>kubectl</code> 中所实现的表格输出和描述输出逻辑，以执行简单的对象列表操作。
该方法的一些限制包括处理某些对象时的不可忽视逻辑。
此外，API 聚合或第三方资源提供的类型在编译时是未知的。
这意味着必须为客户端无法识别的类型提供通用实现。</p><p>为了避免上述各种潜在的局限性，客户端可以请求服务器端返回对象的表格（Table）
表现形式，从而将打印输出的特定细节委托给服务器。
Kubernetes API 实现标准的 HTTP 内容类型（Content Type）协商：为 <code>GET</code>
调用传入一个值为 <code>application/json;as=Table;g=meta.k8s.io;v=v1</code> 的 <code>Accept</code>
头部即可请求服务器以 Table 的内容类型返回对象。</p><p>例如，以 Table 格式列举集群中所有 Pod：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#888>GET /api/v1/pods
</span></span></span><span style=display:flex><span><span style=color:#888>Accept: application/json;as=Table;g=meta.k8s.io;v=v1
</span></span></span><span style=display:flex><span><span style=color:#888>---
</span></span></span><span style=display:flex><span><span style=color:#888>200 OK
</span></span></span><span style=display:flex><span><span style=color:#888>Content-Type: application/json
</span></span></span><span style=display:flex><span><span style=color:#888></span><span>
</span></span></span><span style=display:flex><span><span></span><span style=color:#888>{
</span></span></span><span style=display:flex><span><span style=color:#888>    &#34;kind&#34;: &#34;Table&#34;,
</span></span></span><span style=display:flex><span><span style=color:#888>    &#34;apiVersion&#34;: &#34;meta.k8s.io/v1&#34;,
</span></span></span><span style=display:flex><span><span style=color:#888>    ...
</span></span></span><span style=display:flex><span><span style=color:#888>    &#34;columnDefinitions&#34;: [
</span></span></span><span style=display:flex><span><span style=color:#888>        ...
</span></span></span><span style=display:flex><span><span style=color:#888>    ]
</span></span></span><span style=display:flex><span><span style=color:#888>}
</span></span></span></code></pre></div><p>对于在控制平面上不存在定制的 Table 定义的 API 资源类型而言，服务器会返回一个默认的
Table 响应，其中包含资源的 <code>name</code> 和 <code>creationTimestamp</code> 字段。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#888>GET /apis/crd.example.com/v1alpha1/namespaces/default/resources
</span></span></span><span style=display:flex><span><span style=color:#888>---
</span></span></span><span style=display:flex><span><span style=color:#888>200 OK
</span></span></span><span style=display:flex><span><span style=color:#888>Content-Type: application/json
</span></span></span><span style=display:flex><span><span style=color:#888>...
</span></span></span><span style=display:flex><span><span style=color:#888></span><span>
</span></span></span><span style=display:flex><span><span></span><span style=color:#888>{
</span></span></span><span style=display:flex><span><span style=color:#888>    &#34;kind&#34;: &#34;Table&#34;,
</span></span></span><span style=display:flex><span><span style=color:#888>    &#34;apiVersion&#34;: &#34;meta.k8s.io/v1&#34;,
</span></span></span><span style=display:flex><span><span style=color:#888>    ...
</span></span></span><span style=display:flex><span><span style=color:#888>    &#34;columnDefinitions&#34;: [
</span></span></span><span style=display:flex><span><span style=color:#888>        {
</span></span></span><span style=display:flex><span><span style=color:#888>            &#34;name&#34;: &#34;Name&#34;,
</span></span></span><span style=display:flex><span><span style=color:#888>            &#34;type&#34;: &#34;string&#34;,
</span></span></span><span style=display:flex><span><span style=color:#888>            ...
</span></span></span><span style=display:flex><span><span style=color:#888>        },
</span></span></span><span style=display:flex><span><span style=color:#888>        {
</span></span></span><span style=display:flex><span><span style=color:#888>            &#34;name&#34;: &#34;Created At&#34;,
</span></span></span><span style=display:flex><span><span style=color:#888>            &#34;type&#34;: &#34;date&#34;,
</span></span></span><span style=display:flex><span><span style=color:#888>            ...
</span></span></span><span style=display:flex><span><span style=color:#888>        }
</span></span></span><span style=display:flex><span><span style=color:#888>    ]
</span></span></span><span style=display:flex><span><span style=color:#888>}
</span></span></span></code></pre></div><p>并非所有 API 资源类型都支持 Table 响应；
例如，<a class=glossary-tooltip title='通过定制化的代码给你的 Kubernetes API 服务器增加资源对象，而无需编译完整的定制 API 服务器。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/ target=_blank aria-label=CustomResourceDefinitions>CustomResourceDefinitions</a> 可能没有定义字段到表的映射，
<a href=/zh-cn/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/>扩展核心 Kubernetes API</a>
的 APIService 可能根本不提供 Table 响应。
如果你正在实现使用 Table 信息并且必须针对所有资源类型（包括扩展）工作的客户端，
你应该在 <code>Accept</code> 请求头中指定多种内容类型的请求。例如：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#888>Accept: application/json;as=Table;g=meta.k8s.io;v=v1, application/json
</span></span></span></code></pre></div><h2 id=alternate-representations-of-resources>资源的其他表示形式</h2><p>默认情况下，Kubernetes 返回序列化为 JSON 的对象，内容类型为 <code>application/json</code>。
这是 API 的默认序列化格式。
但是，客户端可能会使用更有效的 <a href=#protobuf-encoding>Protobuf 表示</a> 请求这些对象，
以获得更好的大规模性能。Kubernetes API 实现标准的 HTTP 内容类型协商：
带有 <code>Accept</code> 请求头部的 <code>GET</code> 调用会请求服务器尝试以你的首选媒体类型返回响应，
而将 Protobuf 中的对象发送到服务器以进行 <code>PUT</code> 或 <code>POST</code> 调用意味着你必须适当地设置
<code>Content-Type</code> 请求头。</p><p>如果支持请求的格式，服务器将返回带有 <code>Content-Type</code> 标头的响应，
如果不支持你请求的媒体类型，则返回 <code>406 Not Acceptable</code> 错误。
所有内置资源类型都支持 <code>application/json</code> 媒体类型。</p><p>有关每个 API 支持的内容类型列表，请参阅 Kubernetes <a href=/zh-cn/docs/reference/kubernetes-api/>API 参考</a>。</p><p>例如：</p><ol><li><p>以 Protobuf 格式列举集群上的所有 Pod：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#888>GET /api/v1/pods
</span></span></span><span style=display:flex><span><span style=color:#888>Accept: application/vnd.kubernetes.protobuf
</span></span></span><span style=display:flex><span><span style=color:#888>---
</span></span></span><span style=display:flex><span><span style=color:#888>200 OK
</span></span></span><span style=display:flex><span><span style=color:#888>Content-Type: application/vnd.kubernetes.protobuf
</span></span></span><span style=display:flex><span><span style=color:#888></span><span>
</span></span></span><span style=display:flex><span><span></span><span style=color:#888>... binary encoded PodList object
</span></span></span></code></pre></div></li></ol><ol start=2><li><p>通过向服务器发送 Protobuf 编码的数据创建 Pod，但请求以 JSON 形式接收响应：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#888>POST /api/v1/namespaces/test/pods
</span></span></span><span style=display:flex><span><span style=color:#888>Content-Type: application/vnd.kubernetes.protobuf
</span></span></span><span style=display:flex><span><span style=color:#888>Accept: application/json
</span></span></span><span style=display:flex><span><span style=color:#888>... binary encoded Pod object
</span></span></span><span style=display:flex><span><span style=color:#888>---
</span></span></span><span style=display:flex><span><span style=color:#888>200 OK
</span></span></span><span style=display:flex><span><span style=color:#888>Content-Type: application/json
</span></span></span><span style=display:flex><span><span style=color:#888></span><span>
</span></span></span><span style=display:flex><span><span></span><span style=color:#888>{
</span></span></span><span style=display:flex><span><span style=color:#888>  &#34;kind&#34;: &#34;Pod&#34;,
</span></span></span><span style=display:flex><span><span style=color:#888>  &#34;apiVersion&#34;: &#34;v1&#34;,
</span></span></span><span style=display:flex><span><span style=color:#888>  ...
</span></span></span><span style=display:flex><span><span style=color:#888>}
</span></span></span></code></pre></div></li></ol><p>并非所有 API 资源类型都支持 Protobuf；具体来说，
Protobuf 不适用于定义为 <a class=glossary-tooltip title='通过定制化的代码给你的 Kubernetes API 服务器增加资源对象，而无需编译完整的定制 API 服务器。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/ target=_blank aria-label=CustomResourceDefinitions>CustomResourceDefinitions</a>
或通过<a class=glossary-tooltip title='聚合层允许你在自己的集群上安装额外的 Kubernetes 风格的 API。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/ target=_blank aria-label=聚合层>聚合层</a>提供服务的资源。
作为客户端，如果你可能需要使用扩展类型，则应在请求 <code>Accept</code> 请求头中指定多种内容类型以支持回退到 JSON。
例如：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#888>Accept: application/vnd.kubernetes.protobuf, application/json
</span></span></span></code></pre></div><h3 id=protobuf-encoding>Kubernetes Protobuf 编码</h3><p>Kubernetes 使用封套形式来对 Protobuf 响应进行编码。
封套外层由 4 个字节的特殊数字开头，便于从磁盘文件或 etcd 中辩识 Protobuf
格式的（而不是 JSON）数据。
接下来存放的是 Protobuf 编码的封套消息，其中描述下层对象的编码和类型，最后
才是对象本身。</p><p>封套格式如下：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#888>四个字节的特殊数字前缀：
</span></span></span><span style=display:flex><span><span style=color:#888>  字节 0-3: &#34;k8s\x00&#34; [0x6b, 0x38, 0x73, 0x00]
</span></span></span><span style=display:flex><span><span style=color:#888></span><span>
</span></span></span><span style=display:flex><span><span></span><span style=color:#888>使用下面 IDL 来编码的 Protobuf 消息：
</span></span></span><span style=display:flex><span><span style=color:#888>  message Unknown {
</span></span></span><span style=display:flex><span><span style=color:#888>    // typeMeta 应该包含 &#34;kind&#34; 和 &#34;apiVersion&#34; 的字符串值，就像
</span></span></span><span style=display:flex><span><span style=color:#888>    // 对应的 JSON 对象中所设置的那样
</span></span></span><span style=display:flex><span><span style=color:#888>    optional TypeMeta typeMeta = 1;
</span></span></span><span style=display:flex><span><span style=color:#888></span><span>
</span></span></span><span style=display:flex><span><span></span><span style=color:#888>    // raw 中将保存用 protobuf 序列化的完整对象。
</span></span></span><span style=display:flex><span><span style=color:#888>    // 参阅客户端库中为指定 kind 所作的 protobuf 定义
</span></span></span><span style=display:flex><span><span style=color:#888>    optional bytes raw = 2;
</span></span></span><span style=display:flex><span><span style=color:#888></span><span>
</span></span></span><span style=display:flex><span><span></span><span style=color:#888>    // contentEncoding 用于 raw 数据的编码格式。未设置此值意味着没有特殊编码。
</span></span></span><span style=display:flex><span><span style=color:#888>    optional string contentEncoding = 3;
</span></span></span><span style=display:flex><span><span style=color:#888></span><span>
</span></span></span><span style=display:flex><span><span></span><span style=color:#888>    // contentType 包含 raw 数据所采用的序列化方法。
</span></span></span><span style=display:flex><span><span style=color:#888>    // 未设置此值意味着 application/vnd.kubernetes.protobuf，且通常被忽略
</span></span></span><span style=display:flex><span><span style=color:#888>    optional string contentType = 4;
</span></span></span><span style=display:flex><span><span style=color:#888>  }
</span></span></span><span style=display:flex><span><span style=color:#888></span><span>
</span></span></span><span style=display:flex><span><span></span><span style=color:#888>  message TypeMeta {
</span></span></span><span style=display:flex><span><span style=color:#888>    // apiVersion 是 type 对应的组名/版本
</span></span></span><span style=display:flex><span><span style=color:#888>    optional string apiVersion = 1;
</span></span></span><span style=display:flex><span><span style=color:#888>    // kind 是对象模式定义的名称。此对象应该存在一个 protobuf 定义。
</span></span></span><span style=display:flex><span><span style=color:#888>    optional string kind = 2;
</span></span></span><span style=display:flex><span><span style=color:#888>  }
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>收到 <code>application/vnd.kubernetes.protobuf</code> 格式响应的客户端在响应与预期的前缀不匹配时应该拒绝响应，
因为将来的版本可能需要以某种不兼容的方式更改序列化格式，
并且这种更改是通过变更前缀完成的。</div><h2 id=resource-deletion>资源删除</h2><p>当你 <strong>delete</strong> 资源时，操作将分两个阶段进行。</p><ol><li>终结（finalization）</li><li>移除</li></ol><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>&#34;kind&#34;: </span><span style=color:#b44>&#34;ConfigMap&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>&#34;apiVersion&#34;: </span><span style=color:#b44>&#34;v1&#34;</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>&#34;metadata&#34;: </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;finalizers&#34;: </span>{<span style=color:#b44>&#34;url.io/neat-finalization&#34;</span>,<span style=color:#bbb> </span><span style=color:#b44>&#34;other-url.io/my-finalizer&#34;</span>},<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>&#34;deletionTimestamp&#34;: </span>nil,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></span></span></code></pre></div><p>当客户端第一次发送 <strong>delete</strong> 请求删除资源时，<code>.metadata.deletionTimestamp</code> 设置为当前时间。
一旦设置了 <code>.metadata.deletionTimestamp</code>，
作用于终结器的外部控制器可以在任何时间以任何顺序开始执行它们的清理工作。</p><p>终结器之间 <strong>不存在</strong> 强制的执行顺序，因为这会带来卡住 <code>.metadata.finalizers</code> 的重大风险。</p><p><code>.metadata.finalizers</code> 字段是共享的：任何有权限的参与者都可以重新排序。
如果终结器列表是按顺序处理的，那么这可能会导致这样一种情况：
在列表中负责第一个终结器的组件正在等待列表中稍后负责终结器的组件产生的某些信号
（字段值、外部系统或其他），从而导致死锁。</p><p>如果没有强制排序，终结者可以在它们之间自由排序，并且不易受到列表中排序变化的影响。</p><p>当最后一个终结器也被移除时，资源才真正从 etcd 中移除。</p><h2 id=single-resource-api>单个资源 API</h2><p>Kubernetes API 动词 <strong>get</strong>、<strong>create</strong>、<strong>apply</strong>、<strong>update</strong>、<strong>patch</strong>、<strong>delete</strong> 和 <strong>proxy</strong> 仅支持单一资源。
这些具有单一资源支持的动词不支持在有序或无序列表或事务中一起提交多个资源。</p><p>当客户端（包括 kubectl）对一组资源进行操作时，客户端会发出一系列单资源 API 请求，
然后在需要时聚合响应。</p><p>相比之下，Kubernetes API 动词 <strong>list</strong> 和 <strong>watch</strong> 允许获取多个资源，
而 <strong>deletecollection</strong> 允许删除多个资源。</p><h2 id=field-validation>字段校验</h2><p>Kubernetes 总是校验字段的类型。例如，如果 API 中的某个字段被定义为数值，
你就不能将该字段设置为文本类型的值。如果某个字段被定义为字符串数组，你只能提供数组。
有些字段可以忽略，有些字段必须填写。忽略 API 请求中的必填字段会报错。</p><p>如果请求中带有集群控制面无法识别的额外字段，API 服务器的行为会更加复杂。</p><p>默认情况下，如果接收到的输入信息中含有 API 服务器无法识别的字段，API 服务器会丢弃该字段
（例如： <code>PUT</code> 请求中的 JSON 主体）。</p><p>API 服务器会在两种情况下丢弃 HTTP 请求中提供的字段。</p><p>这些情况是：</p><ol><li>相关资源的 OpenAPI 模式定义中没有该字段，因此无法识别该字段（有种例外情形是，
<a class=glossary-tooltip title='通过定制化的代码给你的 Kubernetes API 服务器增加资源对象，而无需编译完整的定制 API 服务器。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/ target=_blank aria-label=CRD>CRD</a>
通过 <code>x-kubernetes-preserve-unknown-fields</code> 显式选择不删除未知字段）。</li></ol><ol start=2><li>字段在对象中重复出现。</li></ol><h3 id=setting-the-field-validation-level>设置字段校验层级</h3><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.25 [beta]</code></div><p>如果启用了 <code>ServerSideFieldValidation</code> <a href=/zh-cn/docs/reference/command-line-tools-reference/feature-gates/>特性门控</a>
（在 1.23 和 1.24 中默认处于禁用状态，从 1.25 开始默认启用），
你可以用服务端的字段校验来抓取这些未能识别的字段。</p><p>使用可以提交数据的 HTTP 动词（<code>POST</code>、<code>PUT</code>、<code>PATCH</code>）时，可以在字段校验中设置
API 服务器丢弃字段时的通知设置。通知层级可能包括 <code>Ignore</code>、<code>Warn</code> 和 <code>Strict</code>。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>如果你所提交的请求中指定了无法识别的字段，并且该请求由于其他某种原因无法生效
（例如：请求提供的是字符值，而 API 需要整数），那么 API 服务器会返回 400 Bad Request（400 请求无效）错误响应码。</p><p>在这种情况下，无论请求哪个层级的字段校验，都总会收到错误响应。</p></div><p>字段校验需要通过 <code>fieldValidation</code> 查询参数进行设置。此参数接受三种值：</p><dl><dt><code>Ignore</code></dt><dd>使 API 服务器像没有遇到错误字段一样成功处理请求，丢弃所有的未知字段和重复字段，并且不发送丢弃字段的通知。</dd></dl><p><code>Warn</code>
:（默认值）使 API 服务器成功处理请求，并向客户端发送告警信息。告警信息通过 <code>Warning:</code> 响应头发送，
并为每个未知字段或重复字段添加一条告警信息。有关告警和相关的 Kubernetes API 的信息，
可参阅博文<a href=/blog/2020/09/03/warnings/>告警：增加实用告警功能</a>。</p><dl><dt><code>Strict</code></dt><dd>API 服务器检测到任何未知字段或重复字段时，拒绝处理请求并返回 400 Bad Request 错误。
来自 API 服务器的响应消息列出了 API 检测到的所有未知字段或重复字段。</dd></dl><p>向服务器提交请求的工具（例如 <code>kubectl</code>）可能会设置自己的默认值，与 API 服务器默认使用的 <code>Warn</code>
校验层级不同。</p><p><code>kubectl</code> 工具使用 <code>--validate</code> 标志设置字段校验层级。
之前 <code>--validate</code> 被作为布尔值开启或关闭客户段的校验功能。
从 Kubernetes 1.25 开始，kubectl 向启用字段校验的服务器发送请求时使用服务端字段校验。
只有无法连接启用了字段校验的 API 服务器时，才会恢复使用客户端的字段校验。</p><p><code>kubectl</code> 接受 <code>ignore</code>、<code>warn</code>、<code>strict</code> 值，同时也接受 <code>true</code>（等效于 <code>strict</code>）
和 <code>false</code>（等效于 <code>ignore</code>）。kubectl 的字段校验默认配置为 <code>--validate=true</code>，
即服务端的 <code>strict</code> 级字段校验。</p><h2 id=dry-run>试运行</h2><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.18 [stable]</code></div><p>当你使用可以修改资源的 HTTP 动词（<code>POST</code>、<code>PUT</code>、<code>PATCH</code> 和 <code>DELETE</code>）时，
你可以在 <strong>试运行（dry run）</strong> 模式下提交你的请求。
试运行模式有助于通过典型的请求阶段（准入链、验证、合并冲突）评估请求，直到将对象持久化到存储中。
请求的响应正文尽可能接近非试运行响应。Kubernetes 保证试运行请求不会被持久化存储或产生任何其他副作用。</p><h3 id=make-a-dry-run-request>发起试运行请求</h3><p>通过设置 <code>dryRun</code> 查询参数触发试运行。此参数是一个字符串，用作枚举，唯一可接受的值是：</p><dl><dt>[未设置值]</dt><dd>允许副作用。你可以使用 <code>?dryRun</code> 或 <code>?dryRun&pretty=true</code> 之类的查询字符串请求此操作。
响应是最终会被持久化的对象，或者如果请求不能被满足则会出现一个错误。</dd><dt><code>All</code></dt><dd>每个阶段都正常运行，除了防止副作用的最终存储阶段。</dd></dl><p>当你设置 <code>?dryRun=All</code> 时，将运行任何相关的<a class=glossary-tooltip title='在对象持久化之前拦截 Kubernetes API 服务器请求的一段代码。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/reference/access-authn-authz/admission-controllers/ target=_blank aria-label=准入控制器>准入控制器</a>，
验证准入控制器检查经过变更的请求，针对 <code>PATCH</code> 请求执行合并、设置字段默认值等操作，并进行模式验证。
更改不会持久化到底层存储，但本应持久化的最终对象仍会与正常状态代码一起返回给用户。</p><p>如果请求的非试运行版本会触发具有副作用的准入控制器，则该请求将失败，而不是冒不希望的副作用的风险。
所有内置准入控制插件都支持试运行。
此外，准入 Webhook 还可以设置<a href=/docs/reference/generated/kubernetes-api/v1.25/#validatingwebhook-v1-admissionregistration-k8s-io>配置对象</a>
的 <code>sideEffects</code> 字段为 <code>None</code>，借此声明它们没有副作用。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong> 如果 webhook 确实有副作用，则应该将 <code>sideEffects</code> 字段设置为 “NoneOnDryRun”。
如果还修改了 webhook 以理解 AdmissionReview 中的 DryRun 字段，
并防止对标记为试运行的任何请求产生副作用，则该更改是适当的。</div><p>这是一个使用 <code>?dryRun=All</code> 的试运行请求的示例：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#888>POST /api/v1/namespaces/test/pods?dryRun=All
</span></span></span><span style=display:flex><span><span style=color:#888>Content-Type: application/json
</span></span></span><span style=display:flex><span><span style=color:#888>Accept: application/json
</span></span></span></code></pre></div><p>响应会与非试运行模式请求的响应看起来相同，只是某些生成字段的值可能会不同。</p><h3 id=generated-values>生成值</h3><p>对象的某些值通常是在对象被写入数据库之前生成的。很重要的一点是不要依赖试运行请求为这些字段所设置的值，
因为试运行模式下所得到的这些值与真实请求所获得的值很可能不同。这类字段有：</p><ul><li><code>name</code>：如果设置了 <code>generateName</code> 字段，则 <code>name</code> 会获得一个唯一的随机名称</li><li><code>creationTimestamp</code> / <code>deletionTimestamp</code>：记录对象的创建/删除时间</li><li><code>UID</code>：<a href=/zh-cn/docs/concepts/overview/working-with-objects/names/#uids>唯一标识</a>对象，
取值随机生成（非确定性）</li><li><code>resourceVersion</code>：跟踪对象的持久化（存储）版本</li><li>变更性准入控制器所设置的字段</li><li>对于 <code>Service</code> 资源：<code>kube-apiserver</code> 为 <code>Service</code> 对象分配的端口和 IP 地址</li></ul><h3 id=dry-run-authorization>试运行的授权</h3><p>试运行和非试运行请求的鉴权是完全相同的。因此，要发起一个试运行请求，
你必须被授权执行非试运行请求。</p><p>例如，要在 Deployment 对象上试运行 <strong>patch</strong> 操作，你必须具有对 Deployment 执行 <strong>patch</strong> 操作的访问权限，
如下面的 <a class=glossary-tooltip title='管理授权决策，允许管理员通过 Kubernetes API 动态配置访问策略。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/reference/access-authn-authz/rbac/ target=_blank aria-label=RBAC>RBAC</a> 规则所示：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;apps&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;deployments&#34;</span>]<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb> </span>[<span style=color:#b44>&#34;patch&#34;</span>]<span style=color:#bbb>
</span></span></span></code></pre></div><p>参阅<a href=/zh-cn/docs/reference/access-authn-authz/authorization/>鉴权概述</a>以了解鉴权细节。</p><h2 id=server-side-apply>服务器端应用</h2><p>Kubernetes 的<a href=/zh-cn/docs/reference/using-api/server-side-apply/>服务器端应用</a>功能允许控制平面跟踪新创建对象的托管字段。
服务端应用为管理字段冲突提供了清晰的模式，提供了服务器端 <code>Apply</code> 和 <code>Update</code> 操作，
并替换了 <code>kubectl apply</code> 的客户端功能。</p><p>服务端应用的 API 动词是 <strong>apply</strong>。有关详细信息，
请参阅<a href=/zh-cn/docs/reference/using-api/server-side-apply/>服务器端应用</a>。</p><h2 id=resource-versions>资源版本</h2><p>资源版本是标识服务器内部对象版本的字符串。
客户端可以使用资源版本来确定对象何时更改，
或者在获取、列出和监视资源时表达数据一致性要求。
资源版本必须被客户端视为不透明的，并且未经修改地传回服务器。</p><p>你不能假设资源版本是数字的或可排序的。
API 客户端只能比较两个资源版本的相等性（这意味着你不能比较资源版本的大于或小于关系）。</p><h3 id=resourceVersion-in-metadata>metadata 中的 <code>resourceVersion</code></h3><p>客户端在资源中查找资源版本，这些资源包括来自用于 <strong>watch</strong> 的响应流资源，或者使用 <strong>list</strong> 枚举的资源。</p><p><a href=/docs/reference/generated/kubernetes-api/v1.25/#objectmeta-v1-meta>v1.meta/ObjectMeta</a> -
资源的 <code>metadata.resourceVersion</code> 值标明该实例上次被更改时的资源版本。</p><p><a href=/docs/reference/generated/kubernetes-api/v1.25/#listmeta-v1-meta>v1.meta/ListMeta</a> - 资源集合即
<strong>list</strong> 操作的响应）的 <code>metadata.resourceVersion</code> 所标明的是 list 响应被构造时的资源版本。</p><h3 id=the-resourceversion-parameter>查询字符串中的 <code>resourceVersion</code> 参数</h3><p><strong>get</strong>、<strong>list</strong> 和 <strong>watch</strong> 操作支持 <code>resourceVersion</code> 参数。
从 v1.19 版本开始，Kubernetes API 服务器支持 <strong>list</strong> 请求的 <code>resourceVersionMatch</code> 参数。</p><p>API 服务器根据你请求的操作和 <code>resourceVersion</code> 的值对 <code>resourceVersion</code> 参数进行不同的解释。
如果你设置 <code>resourceVersionMatch</code> 那么这也会影响匹配发生的方式。</p><h3 id=semantics-for-get-and-list><strong>get</strong> 和 <strong>list</strong> 语义</h3><p>对于 <strong>get</strong> 和 <strong>list</strong> 而言，<code>resourceVersion</code> 的语义为：</p><p><strong>get:</strong></p><table><thead><tr><th>resourceVersion 未设置</th><th>resourceVersion="0"</th><th>resourceVersion="&lt;非零值>"</th></tr></thead><tbody><tr><td>最新版本</td><td>任何版本</td><td>不老于给定版本</td></tr></tbody></table><p><strong>list:</strong></p><p>从 v1.19 版本开始，Kubernetes API 服务器支持 <strong>list</strong> 请求的 <code>resourceVersionMatch</code> 参数。
如果同时设置 <code>resourceVersion</code> 和 <code>resourceVersionMatch</code>，
则 <code>resourceVersionMatch</code> 参数确定 API 服务器如何解释 <code>resourceVersion</code>。</p><p>在 <strong>list</strong> 请求上设置 <code>resourceVersion</code> 时，你应该始终设置 <code>resourceVersionMatch</code> 参数。
但是，请准备好处理响应的 API 服务器不知道 <code>resourceVersionMatch</code> 并忽略它的情况。</p><p>除非你对一致性有着非常强烈的需求，使用 <code>resourceVersionMatch=NotOlderThan</code>
同时为 <code>resourceVersion</code> 设定一个已知值是优选的交互方式，因为与不设置
<code>resourceVersion</code> 和 <code>resourceVersionMatch</code> 相比，这种配置可以取得更好的集群性能和可扩缩性。
后者需要提供带票选能力的读操作。</p><p>设置 <code>resourceVersionMatch</code> 参数而不设置 <code>resourceVersion</code> 参数是不合法的。</p><p>下表解释了具有各种 <code>resourceVersion</code> 和 <code>resourceVersionMatch</code> 组合的 <strong>list</strong> 请求的行为：</p><table><caption style=display:none>list 操作的 resourceVersionMatch 与分页参数</caption><thead><tr><th>resourceVersionMatch 参数</th><th>分页参数</th><th>resourceVersion 未设置</th><th>resourceVersion="0"</th><th>resourceVersion="&lt;非零值>"</th></tr></thead><tbody><tr><td><strong>未设置</strong></td><td><strong>limit 未设置</strong></td><td>最新版本</td><td>任意版本</td><td>不老于指定版本</td></tr><tr><td><strong>未设置</strong></td><td>limit=&lt;n>, <strong>continue 未设置</strong></td><td>最新版本</td><td>任意版本</td><td>精确匹配</td></tr><tr><td><strong>未设置</strong></td><td>limit=&lt;n>, continue=&lt;token></td><td>从 token 开始、精确匹配</td><td>非法请求，视为从 token 开始、精确匹配</td><td>非法请求，返回 HTTP <code>400 Bad Request</code></td></tr><tr><td><code>resourceVersionMatch=Exact</code> [1]</td><td><strong>limit 未设置</strong></td><td>非法请求</td><td>非法请求</td><td>精确匹配</td></tr><tr><td><code>resourceVersionMatch=Exact</code> [1]</td><td>limit=&lt;n>, <strong>continue 未设置</strong></td><td>非法请求</td><td>非法请求</td><td>精确匹配</td></tr><tr><td><code>resourceVersionMatch=NotOlderThan</code> [1]</td><td><strong>limit 未设置</strong></td><td>非法请求</td><td>任意版本</td><td>不老于指定版本</td></tr><tr><td><code>resourceVersionMatch=NotOlderThan</code> [1]</td><td>limit=&lt;n>, <strong>continue 未设置</strong></td><td>非法请求</td><td>任意版本</td><td>不老于指定版本</td></tr></tbody></table><div class="alert alert-info note callout" role=alert><strong>说明：</strong> 如果你的集群的 API 服务器不支持 <code>resourceVersionMatch</code> 参数，
则行为与你未设置它时相同。</div><p><strong>get</strong> 和 <strong>list</strong> 的语义是：</p><dl><dt>任意版本</dt><dd>返回任何资源版本的数据。最新可用资源版本优先，但不需要强一致性；
可以提供任何资源版本的数据。由于分区或过时的缓存，
请求可能返回客户端先前观察到的更旧资源版本的数据，特别是在高可用性配置中。
不能容忍这种情况的客户不应该使用这种语义。</dd><dt>最新版本</dt><dd>返回最新资源版本的数据。
返回的数据必须一致（详细说明：通过仲裁读取从 etcd 提供）。</dd></dl><dl><dt>不老于指定版本</dt><dd>返回数据至少与提供的 <code>resourceVersion</code> 一样新。
最新的可用数据是首选，但可以提供不早于提供的 <code>resourceVersion</code> 的任何数据。
对于对遵守 <code>resourceVersionMatch</code> 参数的服务器的 <strong>list</strong> 请求，
这保证了集合的 <code>.metadata.resourceVersion</code> 不早于请求的 <code>resourceVersion</code>，
但不保证该集合中任何项目的 <code>.metadata.resourceVersion</code>。</dd></dl><dl><dt>精确匹配</dt><dd>以提供的确切资源版本返回数据。如果提供的 <code>resourceVersion</code> 不可用，
则服务器以 HTTP 410 “Gone”响应。对于对支持 <code>resourceVersionMatch</code> 参数的服务器的 <strong>list</strong> 请求，
这可以保证集合的 <code>.metadata.resourceVersion</code> 与你在查询字符串中请求的 <code>resourceVersion</code> 相同。
该保证不适用于该集合中任何项目的 <code>.metadata.resourceVersion</code>。</dd><dt>从 token 开始、精确匹配</dt><dd>返回初始分页 <strong>list</strong> 调用的资源版本的数据。
返回的 <em>Continue 令牌</em> 负责跟踪最初提供的资源版本，最初提供的资源版本用于在初始分页 <strong>list</strong> 之后的所有分页 <strong>list</strong> 中。</dd></dl><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>当你 <strong>list</strong> 资源并收到集合响应时，
响应包括集合的<a href=/docs/reference/generated/kubernetes-api/v1.21/#listmeta-v1-meta>元数据</a>
以及该集合中每个项目的<a href=/docs/reference/generated/kubernetes-api/v1.21/#listmeta-v1-meta>对象元数据</a>。
对于在集合响应中找到的单个对象，<code>.metadata.resourceVersion</code> 跟踪该对象的最后更新时间，
而不是对象在服务时的最新程度。</div><p>当使用 <code>resourceVersionMatch=NotOlderThan</code> 并设置了限制时，
客户端必须处理 HTTP 410 “Gone” 响应。
例如，客户端可能会使用更新的 <code>resourceVersion</code> 重试或回退到 <code>resourceVersion=""</code>。</p><p>当使用 <code>resourceVersionMatch=Exact</code> 并且未设置限制时，
客户端必须验证集合的 <code>.metadata.resourceVersion</code> 是否与请求的 <code>resourceVersion</code> 匹配，
并处理不匹配的情况。例如，客户端可能会退回到设置了限制的请求。</p><h3 id=semantics-for-watch><strong>watch</strong> 语义</h3><p>对于 <strong>watch</strong> 操作而言，资源版本的语义如下：</p><p><strong>watch：</strong></p><table><caption style=display:none>watch 操作的 resourceVersion 设置</caption><thead><tr><th>resourceVersion 未设置</th><th>resourceVersion="0"</th><th>resourceVersion="&lt;非零值>"</th></tr></thead><tbody><tr><td>读取状态并从最新版本开始</td><td>读取状态并从任意版本开始</td><td>从指定版本开始</td></tr></tbody></table><p><strong>watch</strong> 操作语义的含义如下：</p><dl><dt>读取状态并从任意版本开始</dt><dd><div class="alert alert-warning caution callout" role=alert><strong>注意：</strong> 以这种方式初始化的监视可能会返回任意陈旧的数据。
请在使用之前查看此语义，并尽可能支持其他语义。</div>在任何资源版本开始 <strong>watch</strong>；首选可用的最新资源版本，但不是必需的。允许任何起始资源版本。
由于分区或过时的缓存，<strong>watch</strong> 可能从客户端之前观察到的更旧的资源版本开始，
特别是在高可用性配置中。不能容忍这种明显倒带的客户不应该用这种语义启动 <strong>watch</strong>。
为了建立初始状态，<strong>watch</strong> 从起始资源版本中存在的所有资源实例的合成 “添加” 事件开始。
以下所有监视事件都针对在 <strong>watch</strong> 开始的资源版本之后发生的所有更改。</dd></dl><dl><dt>读取状态并从最新版本开始</dt><dd>从最近的资源版本开始 <strong>watch</strong>，
它必须是一致的（详细说明：通过仲裁读取从 etcd 提供服务）。
为了建立初始状态，<strong>watch</strong> 从起始资源版本中存在的所有资源实例的合成 “添加” 事件开始。
以下所有监视事件都针对在 <strong>watch</strong> 开始的资源版本之后发生的所有更改。</dd></dl><dl><dt>从指定版本开始</dt><dd>以确切的资源版本开始 <strong>watch</strong>。监视事件适用于提供的资源版本之后的所有更改。
与 “Get State and Start at Most Recent” 和 “Get State and Start at Any” 不同，
<strong>watch</strong> 不会以所提供资源版本的合成 “添加” 事件启动。
由于客户端提供了资源版本，因此假定客户端已经具有起始资源版本的初始状态。</dd></dl><h3 id=410-gone-responses>"410 Gone" 响应</h3><p>服务器不需要提供所有老的资源版本，在客户端请求的是早于服务器端所保留版本的
<code>resourceVersion</code> 时，可以返回 HTTP <code>410 (Gone)</code> 状态码。
客户端必须能够容忍 <code>410 (Gone)</code> 响应。
参阅<a href=#efficient-detection-of-changes>高效检测变更</a>以了解如何在监测资源时处理
<code>410 (Gone)</code> 响应。</p><p>如果所请求的 <code>resourceVersion</code> 超出了可应用的 <code>limit</code>，
那么取决于请求是否是通过高速缓存来满足的，API 服务器可能会返回一个 <code>410 Gone</code> HTTP 响应。</p><h3 id=unavailable-resource-versions>不可用的资源版本</h3><p>服务器不需要提供无法识别的资源版本。
如果你请求了 <strong>list</strong> 或 <strong>get</strong> API 服务器无法识别的资源版本，则 API 服务器可能会：</p><ul><li>短暂等待资源版本可用，如果提供的资源版本在合理的时间内仍不可用，
则应超时并返回 <code>504 (Gateway Timeout)</code>；</li><li>使用 <code>Retry-After</code> 响应标头进行响应，指示客户端在重试请求之前应等待多少秒。</li></ul><p>如果你请求 API 服务器无法识别的资源版本，
kube-apiserver 还会使用 “Too large resource version” 消息额外标识其错误响应。</p><p>如果你对无法识别的资源版本发出 <strong>watch</strong> 请求，
API 服务器可能会无限期地等待（直到请求超时）资源版本变为可用。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-040d9484db673074f1b8ba3465be9d91>2 - 服务器端应用（Server-Side Apply）</h1><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.22 [stable]</code></div><h2 id=introduction>简介</h2><p>服务器端应用协助用户、控制器通过声明式配置的方式管理他们的资源。
客户端可以发送完整描述的目标（A fully specified intent），
声明式地创建和修改<a href=/zh-cn/docs/concepts/overview/working-with-objects/kubernetes-objects/>对象</a>。</p><p>一个完整描述的目标并不是一个完整的对象，仅包括能体现用户意图的字段和值。
该目标（intent）可以用来创建一个新对象，
也可以通过服务器来实现与现有对象的<a href=#merge-strategy>合并</a>。</p><p>系统支持多个应用者（appliers）在同一个对象上开展协作。</p><p>“<a href=#field-management>字段管理（field management）</a>”机制追踪对象字段的变化。
当一个字段值改变时，其所有权从当前管理器（manager）转移到施加变更的管理器。
当尝试将新配置应用到一个对象时，如果字段有不同的值，且由其他管理器管理，
将会引发<a href=#conflicts>冲突</a>。
冲突引发警告信号：此操作可能抹掉其他协作者的修改。
冲突可以被刻意忽略，这种情况下，值将会被改写，所有权也会发生转移。</p><p>当你从配置文件中删除一个字段，然后应用这个配置文件，
将触发服务器端应用检查此字段是否还被其他字段管理器拥有。
如果没有，那就从活动对象中删除该字段；如果有，那就重置为默认值。
该规则同样适用于 list 或 map 项目。</p><p>服务器端应用既是原有 <code>kubectl apply</code> 的替代品，
也是控制器发布自身变化的一个简化机制。</p><p>如果你启用了服务器端应用，控制平面就会跟踪被所有新创建对象管理的字段。</p><h2 id=field-management>字段管理</h2><p>相对于通过 <code>kubectl</code> 管理的注解 <code>last-applied</code>，
服务器端应用使用了一种更具声明式特点的方法：
它持续的跟踪用户的字段管理，而不仅仅是最后一次的执行状态。
这就意味着，作为服务器端应用的一个副作用，
关于用哪一个字段管理器负责管理对象中的哪个字段的这类信息，都要对外界开放了。</p><p>用户管理字段这件事，在服务器端应用的场景中，意味着用户依赖并期望字段的值不要改变。
最后一次对字段值做出断言的用户将被记录到当前字段管理器。
这可以通过发送 <code>POST</code>、 <code>PUT</code>、
或非应用（non-apply）方式的 <code>PATCH</code> 等命令来修改字段值的方式实现，
或通过把字段放在配置文件中，然后发送到服务器端应用的服务端点的方式实现。
当使用服务器端应用，尝试着去改变一个被其他人管理的字段，
会导致请求被拒绝（在没有设置强制执行时，参见<a href=#conflicts>冲突</a>）。</p><p>如果两个或以上的应用者均把同一个字段设置为相同值，他们将共享此字段的所有权。
后续任何改变共享字段值的尝试，不管由那个应用者发起，都会导致冲突。
共享字段的所有者可以放弃字段的所有权，这只需从配置文件中删除该字段即可。</p><p>字段管理的信息存储在 <code>managedFields</code> 字段中，该字段是对象的
<a href=/docs/reference/generated/kubernetes-api/v1.25/#objectmeta-v1-meta><code>metadata</code></a>
中的一部分。</p><p>服务器端应用创建对象的简单示例如下：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-cm<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>test-label</span>:<span style=color:#bbb> </span>test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>managedFields</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>manager</span>:<span style=color:#bbb> </span>kubectl<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>operation</span>:<span style=color:#bbb> </span>Apply<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>time</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;2010-10-10T0:00:00Z&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>fieldsType</span>:<span style=color:#bbb> </span>FieldsV1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>fieldsV1</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>f:metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>f:labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>f:test-label</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>f:data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>f:key</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>some value<span style=color:#bbb>
</span></span></span></code></pre></div><p>上述对象在 <code>metadata.managedFields</code> 中包含了唯一的管理器。
管理器由管理实体自身的基本信息组成，比如操作类型、API 版本、以及它管理的字段。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>该字段由 API 服务器管理，用户不应该改动它。</div><p>不过，执行 <code>Update</code> 操作修改 <code>metadata.managedFields</code> 也是可实现的。
强烈不鼓励这么做，但当发生如下情况时，
比如 <code>managedFields</code> 进入不一致的状态（显然不应该发生这种情况），
这么做也是一个合理的尝试。</p><p><code>managedFields</code> 的格式在
<a href=/docs/reference/generated/kubernetes-api/v1.25/#fieldsv1-v1-meta>API</a>
文档中描述。</p><h2 id=conflicts>冲突</h2><p>冲突是一种特定的错误状态，
发生在执行 <code>Apply</code> 改变一个字段，而恰巧该字段被其他用户声明过主权时。
这可以防止一个应用者不小心覆盖掉其他用户设置的值。
冲突发生时，应用者有三种办法来解决它：</p><ul><li><p><strong>覆盖前值，成为唯一的管理器：</strong> 如果打算覆盖该值（或应用者是一个自动化部件，比如控制器），
应用者应该设置查询参数 <code>force</code> 为 true（在 kubectl 中，可以通过在
apply 命令中使用 <code>--force-conflicts</code> 标志来完成），然后再发送一次请求。
这将强制操作成功，改变字段的值，从所有其他管理器的 managedFields 条目中删除指定字段。</p></li><li><p><strong>不覆盖前值，放弃管理权：</strong> 如果应用者不再关注该字段的值，
可以从配置文件中删掉它，再重新发送请求。
这就保持了原值不变，并从 managedFields 的应用者条目中删除该字段。</p></li><li><p><strong>不覆盖前值，成为共享的管理器：</strong> 如果应用者仍然关注字段值，并不想覆盖它，
他们可以在配置文件中把字段的值改为和服务器对象一样，再重新发送请求。
这样在不改变字段值的前提下，
就实现了字段管理被应用者和所有声明了管理权的其他的字段管理器共享。</p></li></ul><h2 id=managers>管理器</h2><p>管理器识别出正在修改对象的工作流程（在冲突时尤其有用）,
管理器可以通过修改请求的参数 <code>fieldManager</code> 指定。
虽然 kubectl 默认发往 <code>kubectl</code> 服务端点，但它则请求到应用的服务端点（apply endpoint）。
对于其他的更新，它默认的是从用户代理计算得来。</p><h2 id=apply-and-update>应用和更新</h2><p>此特性涉及两类操作，分别是 <code>Apply</code>
（内容类型为 <code>application/apply-patch+yaml</code> 的 <code>PATCH</code> 请求）
和 <code>Update</code> （所有修改对象的其他操作）。
这两类操作都会更新字段 <code>managedFields</code>，但行为表现有一点不同。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>不管你提交的是 JSON 数据还是 YAML 数据，
都要使用 <code>application/apply-patch+yaml</code> 作为 <code>Content-Type</code> 的值。</p><p>所有的 JSON 文档 都是合法的 YAML。</p></div><p>例如，在冲突发生的时候，只有 <code>apply</code> 操作失败，而 <code>update</code> 则不会。
此外，<code>apply</code> 操作必须通过提供一个 <code>fieldManager</code> 查询参数来标识自身，
而此查询参数对于 <code>update</code> 操作则是可选的。
最后，当使用 <code>apply</code> 命令时，你不能在应用中的对象中持有 <code>managedFields</code>。</p><p>一个包含多个管理器的对象，示例如下：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ConfigMap<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>test-cm<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>namespace</span>:<span style=color:#bbb> </span>default<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>test-label</span>:<span style=color:#bbb> </span>test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>managedFields</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>manager</span>:<span style=color:#bbb> </span>kubectl<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>operation</span>:<span style=color:#bbb> </span>Apply<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>fields</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>f:metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>f:labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>f:test-label</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>manager</span>:<span style=color:#bbb> </span>kube-controller-manager<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>operation</span>:<span style=color:#bbb> </span>Update<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>time</span>:<span style=color:#bbb> </span><span style=color:#b44>&#39;2019-03-30T16:00:00.000Z&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>fields</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>f:data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>f:key</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>key</span>:<span style=color:#bbb> </span>new value<span style=color:#bbb>
</span></span></span></code></pre></div><p>在这个例子中，
第二个操作被管理器 <code>kube-controller-manager</code> 以 <code>Update</code> 的方式运行。
此 <code>update</code> 更改 data 字段的值，
并使得字段管理器被改为 <code>kube-controller-manager</code>。</p><p>如果把 <code>update</code> 操作改为 <code>Apply</code>，那就会因为所有权冲突的原因，导致操作失败。</p><h2 id=merge-strategy>合并策略</h2><p>由服务器端应用实现的合并策略，提供了一个总体更稳定的对象生命周期。
服务器端应用试图依据负责管理它们的主体来合并字段，而不是根据值来否决。
这么做是为了多个主体可以更新同一个对象，且不会引起意外的相互干扰。</p><p>当用户发送一个“完整描述的目标”对象到服务器端应用的服务端点，
服务器会将它和活动对象做一次合并，如果两者中有重复定义的值，那就以配置文件的为准。
如果配置文件中的项目集合不是此用户上一次操作项目的超集，
所有缺少的、没有其他应用者管理的项目会被删除。
关于合并时用来做决策的对象规格的更多信息，参见
<a href=https://sigs.k8s.io/structured-merge-diff>sigs.k8s.io/structured-merge-diff</a>.</p><p>Kubernetes 1.16 和 1.17 中添加了一些标记，
允许 API 开发人员描述由 list、map、和 structs 支持的合并策略。
这些标记可应用到相应类型的对象，在 Go 文件或在
<a href=/docs/reference/generated/kubernetes-api/v1.25#jsonschemaprops-v1-apiextensions-k8s-io>CRD</a>
的 OpenAPI 的模式中定义：</p><table><thead><tr><th>Golang 标记</th><th>OpenAPI extension</th><th>可接受的值</th><th>描述</th><th>引入版本</th></tr></thead><tbody><tr><td><code>//+listType</code></td><td><code>x-kubernetes-list-type</code></td><td><code>atomic</code>/<code>set</code>/<code>map</code></td><td>适用于 list。<code>set</code> 适用于仅包含标量元素的列表。这些元素必须是不重复的。<code>map</code> 仅适用于包含嵌套类型的列表。列表中的键（参见 <code>listMapKey</code>）不可以重复。<code>atomic</code> 适用于任何类型的列表。如果配置为 <code>atomic</code>，则合并时整个列表会被替换掉。任何时候，只有一个管理器负责管理指定列表。如果配置为 <code>set</code> 或 <code>map</code>，不同的管理器也可以分开管理条目。</td><td>1.16</td></tr><tr><td><code>//+listMapKey</code></td><td><code>x-kubernetes-list-map-keys</code></td><td>字段名称的列表，例如，<code>["port", "protocol"]</code></td><td>仅当 <code>+listType=map</code> 时适用。取值为字段名称的列表，这些字段值的组合能够唯一标识列表中的条目。尽管可以存在多个键，<code>listMapKey</code> 是单数的，这是因为键名需要在 Go 类型中各自独立指定。键字段必须是标量。</td><td>1.16</td></tr><tr><td><code>//+mapType</code></td><td><code>x-kubernetes-map-type</code></td><td><code>atomic</code>/<code>granular</code></td><td>适用于 map。 <code>atomic</code> 指 map 只能被单个的管理器整个的替换。 <code>granular</code> 指 map 支持多个管理器各自更新自己的字段。</td><td>1.17</td></tr><tr><td><code>//+structType</code></td><td><code>x-kubernetes-map-type</code></td><td><code>atomic</code>/<code>granular</code></td><td>适用于 structs；否则就像 <code>//+mapType</code> 有相同的用法和 openapi 注释.</td><td>1.17</td></tr></tbody></table><p>若未指定 <code>listType</code>，API 服务器将 <code>patchMergeStrategy=merge</code> 标记解释为
<code>listType=map</code> 并且视对应的 <code>patchMergeKey</code> 标记为 <code>listMapKey</code> 取值。</p><p><code>atomic</code> 列表类型是递归的。</p><p>这些标记都是用源代码注释的方式给出的，不必作为字段标签（tag）再重复。</p><h3 id=compatibility-across-toplogy-changes>拓扑变化时的兼容性</h3><p>在极少的情况下，CRD 或者内置类型的作者可能希望更改其资源中的某个字段的
拓扑配置，同时又不提升版本号。
通过升级集群或者更新 CRD 来更改类型的拓扑信息与更新现有对象的结果不同。
变更的类型有两种：一种是将字段从 <code>map</code>/<code>set</code>/<code>granular</code> 更改为 <code>atomic</code>，
另一种是做逆向改变。</p><p>当 <code>listType</code>、<code>mapType</code> 或 <code>structType</code> 从 <code>map</code>/<code>set</code>/<code>granular</code> 改为
<code>atomic</code> 时，现有对象的整个列表、映射或结构的属主都会变为这些类型的
元素之一的属主。这意味着，对这些对象的进一步变更会引发冲突。</p><p>当一个列表、映射或结构从 <code>atomic</code> 改为 <code>map</code>/<code>set</code>/<code>granular</code> 之一
时，API 服务器无法推导这些字段的新的属主。因此，当对象的这些字段
再次被更新时不会引发冲突。出于这一原因，不建议将某类型从 <code>atomic</code> 改为
<code>map</code>/<code>set</code>/<code>granular</code>。</p><p>以下面的自定义资源为例：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>example.com/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Foo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>foo-sample<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>managedFields</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>manager</span>:<span style=color:#bbb> </span>manager-one<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>operation</span>:<span style=color:#bbb> </span>Apply<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>example.com/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>fields</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>f:spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>f:data</span>:<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>data</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>key1</span>:<span style=color:#bbb> </span>val1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>key2</span>:<span style=color:#bbb> </span>val2<span style=color:#bbb>
</span></span></span></code></pre></div><p>在 <code>spec.data</code> 从 <code>atomic</code> 改为 <code>granular</code> 之前，<code>manager-one</code> 是
<code>spec.data</code> 字段及其所包含字段（<code>key1</code> 和 <code>key2</code>）的属主。
当对应的 CRD 被更改，使得 <code>spec.data</code> 变为 <code>granular</code> 拓扑时，
<code>manager-one</code> 继续拥有顶层字段 <code>spec.data</code>（这意味着其他管理者想删除名为
<code>data</code> 的映射而不引起冲突是不可能的），但不再拥有
<code>key1</code> 和 <code>key2</code>。因此，其他管理者可以在不引起冲突的情况下更改
或删除这些字段。</p><h2 id=custom-resources>自定义资源</h2><p>默认情况下，服务器端应用把自定义资源看做非结构化数据。
所有的键值（keys）就像 struct 的字段一样被处理，
所有的 list 被认为是原子性的。</p><p>如果自定义资源定义（Custom Resource Definition，CRD）定义了一个
<a href=/docs/reference/generated/kubernetes-api/v1.25#jsonschemaprops-v1-apiextensions-k8s-io>模式</a>，
它包含类似以前“合并策略”章节中定义过的注解，
这些注解将在合并此类型的对象时使用。</p><h2 id=using-server-side-apply-in-controller>在控制器中使用服务器端应用</h2><p>控制器的开发人员可以把服务器端应用作为简化控制器的更新逻辑的方式。
读-改-写 和/或 patch 的主要区别如下所示：</p><ul><li>应用的对象必须包含控制器关注的所有字段。</li><li>对于在控制器没有执行过应用操作之前就已经存在的字段，不能删除。
（控制器在这种用例环境下，依然可以发送一个 PATCH/UPDATE）</li><li>对象不必事先读取，<code>resourceVersion</code> 不必指定。</li></ul><p>强烈推荐：设置控制器在冲突时强制执行，这是因为冲突发生时，它们没有其他解决方案或措施。</p><h2 id=transferring-ownership>转移所有权</h2><p>除了通过<a href=#conflicts>冲突解决方案</a>提供的并发控制，
服务器端应用提供了一些协作方式来将字段所有权从用户转移到控制器。</p><p>最好通过例子来说明这一点。
让我们来看看，在使用 Horizo​​ntalPodAutoscaler 资源和与之配套的控制器，
且开启了 Deployment 的自动水平扩展功能之后，
怎么安全的将 <code>replicas</code> 字段的所有权从用户转移到控制器。</p><p>假设用户定义了 Deployment，且 <code>replicas</code> 字段已经设置为期望的值：</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/application/ssa/nginx-deployment.yaml download=application/ssa/nginx-deployment.yaml><code>application/ssa/nginx-deployment.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("application-ssa-nginx-deployment-yaml")' title="Copy application/ssa/nginx-deployment.yaml to clipboard"></img></div><div class=includecode id=application-ssa-nginx-deployment-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>并且，用户使用服务器端应用，像这样创建 Deployment：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/application/ssa/nginx-deployment.yaml --server-side
</span></span></code></pre></div><p>然后，为 Deployment 启用 HPA，例如：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl autoscale deployment nginx-deployment --cpu-percent<span style=color:#666>=</span><span style=color:#666>50</span> --min<span style=color:#666>=</span><span style=color:#666>1</span> --max<span style=color:#666>=</span><span style=color:#666>10</span>
</span></span></code></pre></div><p>现在，用户希望从他们的配置中删除 <code>replicas</code>，所以他们总是和 HPA 控制器冲突。
然而，这里存在一个竟态：
在 HPA 需要调整 <code>replicas</code> 之前会有一个时间窗口，
如果在 HPA 写入字段成为所有者之前，用户删除了<code>replicas</code>，
那 API 服务器就会把 <code>replicas</code> 的值设为 1， 也就是默认值。
这不是用户希望发生的事情，即使是暂时的。</p><p>这里有两个解决方案：</p><ul><li>（基本操作）把 <code>replicas</code> 留在配置文件中；当 HPA 最终写入那个字段，
系统基于此事件告诉用户：冲突发生了。在这个时间点，可以安全的删除配置文件。</li><li>（高级操作）然而，如果用户不想等待，比如他们想为合作伙伴保持集群清晰，
那他们就可以执行以下步骤，安全的从配置文件中删除 <code>replicas</code>。</li></ul><p>首先，用户新定义一个只包含 <code>replicas</code> 字段的配置文件：</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/application/ssa/nginx-deployment-replicas-only.yaml download=application/ssa/nginx-deployment-replicas-only.yaml><code>application/ssa/nginx-deployment-replicas-only.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("application-ssa-nginx-deployment-replicas-only-yaml")' title="Copy application/ssa/nginx-deployment-replicas-only.yaml to clipboard"></img></div><div class=includecode id=application-ssa-nginx-deployment-replicas-only-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>3</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>用户使用名为 <code>handover-to-hpa</code> 的字段管理器，应用此配置文件。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/application/ssa/nginx-deployment-replicas-only.yaml <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --server-side --field-manager<span style=color:#666>=</span>handover-to-hpa <span style=color:#b62;font-weight:700>\
</span></span></span><span style=display:flex><span><span style=color:#b62;font-weight:700></span>  --validate<span style=color:#666>=</span><span style=color:#a2f>false</span>
</span></span></code></pre></div><p>如果应用操作和 HPA 控制器产生冲突，那什么都不做。
冲突表明控制器在更早的流程中已经对字段声明过所有权。</p><p>在此时间点，用户可以从配置文件中删除 <code>replicas</code> 。</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/zh-cn/examples/application/ssa/nginx-deployment-no-replicas.yaml download=application/ssa/nginx-deployment-no-replicas.yaml><code>application/ssa/nginx-deployment-no-replicas.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("application-ssa-nginx-deployment-no-replicas-yaml")' title="Copy application/ssa/nginx-deployment-no-replicas.yaml to clipboard"></img></div><div class=includecode id=application-ssa-nginx-deployment-no-replicas-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>注意，只要 HPA 控制器为 <code>replicas</code> 设置了一个新值，
该临时字段管理器将不再拥有任何字段，会被自动删除。
这里不需要执行清理工作。</p><h3 id=transferring-ownership-between-users>在用户之间转移所有权</h3><p>通过在配置文件中把一个字段设置为相同的值，用户可以在他们之间转移字段的所有权，
从而共享了字段的所有权。
当用户共享了字段的所有权，任何一个用户可以从他的配置文件中删除该字段，
并应用该变更，从而放弃所有权，并实现了所有权向其他用户的转移。</p><h2 id=comparison-with-client-side-apply>与客户端应用的对比</h2><p>由服务器端应用实现的冲突检测和解决方案的一个结果就是，
应用者总是可以在本地状态中得到最新的字段值。
如果得不到最新值，下次执行应用操作时就会发生冲突。
解决冲突三个选项的任意一个都会保证：此应用过的配置文件是服务器上对象字段的最新子集。</p><p>这和客户端应用（Client Side Apply） 不同，如果有其他用户覆盖了此值，
过期的值被留在了应用者本地的配置文件中。
除非用户更新了特定字段，此字段才会准确，
应用者没有途径去了解下一次应用操作是否会覆盖其他用户的修改。</p><p>另一个区别是使用客户端应用的应用者不能改变他们正在使用的 API 版本，但服务器端应用支持这个场景。</p><h2 id=upgrading-from-client-side-apply-to-server-side-apply>从客户端应用升级到服务器端应用</h2><p>客户端应用方式时，用户使用 <code>kubectl apply</code> 管理资源，
可以通过使用下面标记切换为使用服务器端应用。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply --server-side <span style=color:#666>[</span>--dry-run<span style=color:#666>=</span>server<span style=color:#666>]</span>
</span></span></code></pre></div><p>默认情况下，对象的字段管理从客户端应用方式迁移到 kubectl 触发的服务器端应用时，不会发生冲突。</p><div class="alert alert-warning caution callout" role=alert><strong>注意：</strong><p>保持注解 <code>last-applied-configuration</code> 是最新的。
从注解能推断出字段是由客户端应用管理的。
任何没有被客户端应用管理的字段将引发冲突。</p><p>举例说明，比如你在客户端应用之后，
使用 <code>kubectl scale</code> 去更新 <code>replicas</code> 字段，
可是该字段并没有被客户端应用所拥有，
在执行 <code>kubectl apply --server-side</code> 时就会产生冲突。</p></div><p>此操作以 <code>kubectl</code> 作为字段管理器来应用到服务器端应用。
作为例外，可以指定一个不同的、非默认字段管理器停止的这种行为，如下面的例子所示。
对于 kubectl 触发的服务器端应用，默认的字段管理器是 <code>kubectl</code>。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply --server-side --field-manager<span style=color:#666>=</span>my-manager <span style=color:#666>[</span>--dry-run<span style=color:#666>=</span>server<span style=color:#666>]</span>
</span></span></code></pre></div><h2 id=downgrading-from-server-side-apply-to-client-side-apply>从服务器端应用降级到客户端应用</h2><p>如果你用 <code>kubectl apply --server-side</code> 管理一个资源，
可以直接用 <code>kubectl apply</code> 命令将其降级为客户端应用。</p><p>降级之所以可行，这是因为 <code>kubectl server-side apply</code>
会保存最新的 <code>last-applied-configuration</code> 注解。</p><p>此操作以 <code>kubectl</code> 作为字段管理器应用到服务器端应用。
作为例外，可以指定一个不同的、非默认字段管理器停止这种行为，如下面的例子所示。
对于 kubectl 触发的服务器端应用，默认的字段管理器是 <code>kubectl</code>。</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply --server-side --field-manager<span style=color:#666>=</span>my-manager <span style=color:#666>[</span>--dry-run<span style=color:#666>=</span>server<span style=color:#666>]</span>
</span></span></code></pre></div><h2 id=api-endpoint>API 端点</h2><p>启用了服务器端应用特性之后，
<code>PATCH</code> 服务端点接受额外的内容类型 <code>application/apply-patch+yaml</code>。
服务器端应用的用户就可以把 YAMl
格式的部分定义对象（partially specified objects）发送到此端点。
当一个配置文件被应用时，它应该包含所有体现你意图的字段。</p><h3 id=rbac-and-permissions>RBAC 和权限</h3><p>因为服务器端应用是一种 <code>PATCH</code> 操作，所以一个角色编辑资源需要 <code>PATCH</code> 权限，
但要用服务器端应用创建资源还需要 <code>CREATE</code> 动作权限。</p><h2 id=clearing-managedfields>清除 ManagedFields</h2><p>可以从对象中剥离所有 managedField，
实现方法是通过使用 <code>MergePatch</code>、 <code>StrategicMergePatch</code>、
<code>JSONPatch</code>、 <code>Update</code>、以及所有的非应用方式的操作来覆盖它。
这可以通过用空条目覆盖 managedFields 字段的方式实现。以下是两个示例：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#888>PATCH /api/v1/namespaces/default/configmaps/example-cm
</span></span></span><span style=display:flex><span><span style=color:#888>Content-Type: application/merge-patch+json
</span></span></span><span style=display:flex><span><span style=color:#888>Accept: application/json
</span></span></span><span style=display:flex><span><span style=color:#888>Data: {&#34;metadata&#34;:{&#34;managedFields&#34;: [{}]}}
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#888>PATCH /api/v1/namespaces/default/configmaps/example-cm
</span></span></span><span style=display:flex><span><span style=color:#888>Content-Type: application/json-patch+json
</span></span></span><span style=display:flex><span><span style=color:#888>Accept: application/json
</span></span></span><span style=display:flex><span><span style=color:#888>Data: [{&#34;op&#34;: &#34;replace&#34;, &#34;path&#34;: &#34;/metadata/managedFields&#34;, &#34;value&#34;: [{}]}]
</span></span></span></code></pre></div><p>这一操作将用只包含一个空条目的列表覆写 managedFields，
来实现从对象中整个的去除 managedFields。
注意，只把 managedFields 设置为空列表并不会重置字段。
这么做是有目的的，所以 managedFields 将永远不会被与该字段无关的客户删除。</p><p>在重置操作结合 managedFields 以外其他字段更改的场景中，
将导致 managedFields 首先被重置，其他改变被押后处理。
其结果是，应用者取得了同一个请求中所有字段的所有权。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-79880efc25dc8cb3b6962ad78a964319>3 - 客户端库</h1><p>本页面包含基于各种编程语言使用 Kubernetes API 的客户端库概述。</p><p>在使用 <a href=/zh-cn/docs/reference/using-api/>Kubernetes REST API</a> 编写应用程序时，
你并不需要自己实现 API 调用和 “请求/响应” 类型。
你可以根据自己的编程语言需要选择使用合适的客户端库。</p><p>客户端库通常为你处理诸如身份验证之类的常见任务。
如果 API 客户端在 Kubernetes 集群中运行，大多数客户端库可以发现并使用 Kubernetes 服务帐户进行身份验证，
或者能够理解 <a href=/zh-cn/docs/tasks/access-application-cluster/configure-access-multiple-clusters/>kubeconfig 文件</a>
格式来读取凭据和 API 服务器地址。</p><h2 id=officially-supported-kubernetes-client-libraries>官方支持的 Kubernetes 客户端库</h2><p>以下客户端库由 <a href=https://github.com/kubernetes/community/tree/master/sig-api-machinery>Kubernetes SIG API Machinery</a> 正式维护。</p><table><thead><tr><th>语言</th><th>客户端库</th><th>样例程序</th></tr></thead><tbody><tr><td>C</td><td><a href=https://github.com/kubernetes-client/c/>github.com/kubernetes-client/c</a></td><td><a href=https://github.com/kubernetes-client/c/tree/master/examples>浏览</a></td></tr><tr><td>dotnet</td><td><a href=https://github.com/kubernetes-client/csharp>github.com/kubernetes-client/csharp</a></td><td><a href=https://github.com/kubernetes-client/csharp/tree/master/examples/simple>浏览</a></td></tr><tr><td>Go</td><td><a href=https://github.com/kubernetes/client-go/>github.com/kubernetes/client-go/</a></td><td><a href=https://github.com/kubernetes/client-go/tree/master/examples>浏览</a></td></tr><tr><td>Haskell</td><td><a href=https://github.com/kubernetes-client/haskell>github.com/kubernetes-client/haskell</a></td><td><a href=https://github.com/kubernetes-client/haskell/tree/master/kubernetes-client/example>浏览</a></td></tr><tr><td>Java</td><td><a href=https://github.com/kubernetes-client/java/>github.com/kubernetes-client/java</a></td><td><a href=https://github.com/kubernetes-client/java/tree/master/examples>浏览</a></td></tr><tr><td>JavaScript</td><td><a href=https://github.com/kubernetes-client/javascript>github.com/kubernetes-client/javascript</a></td><td><a href=https://github.com/kubernetes-client/javascript/tree/master/examples>浏览</a></td></tr><tr><td>Perl</td><td><a href=https://github.com/kubernetes-client/perl/>github.com/kubernetes-client/perl/</a></td><td><a href=https://github.com/kubernetes-client/perl/tree/master/examples>浏览</a></td></tr><tr><td>Python</td><td><a href=https://github.com/kubernetes-client/python/>github.com/kubernetes-client/python/</a></td><td><a href=https://github.com/kubernetes-client/python/tree/master/examples>浏览</a></td></tr><tr><td>Ruby</td><td><a href=https://github.com/kubernetes-client/ruby/>github.com/kubernetes-client/ruby/</a></td><td><a href=https://github.com/kubernetes-client/ruby/tree/master/examples>浏览</a></td></tr></tbody></table><h2 id=community-maintained-client-libraries>社区维护的客户端库</h2><div class="alert alert-secondary callout third-party-content" role=alert><strong>说明：</strong>
本部分链接到提供 Kubernetes 所需功能的第三方项目。Kubernetes 项目作者不负责这些项目。此页面遵循<a href=https://github.com/cncf/foundation/blob/master/website-guidelines.md target=_blank>CNCF 网站指南</a>，按字母顺序列出项目。要将项目添加到此列表中，请在提交更改之前阅读<a href=/docs/contribute/style/content-guide/#third-party-content>内容指南</a>。</div><p>以下 Kubernetes API 客户端库是由社区，而非 Kubernetes 团队支持、维护的。</p><table><thead><tr><th>语言</th><th>客户端库</th></tr></thead><tbody><tr><td>Clojure</td><td><a href=https://github.com/yanatan16/clj-kubernetes-api>github.com/yanatan16/clj-kubernetes-api</a></td></tr><tr><td>DotNet</td><td><a href=https://github.com/tonnyeremin/kubernetes_gen>github.com/tonnyeremin/kubernetes_gen</a></td></tr><tr><td>DotNet (RestSharp)</td><td><a href=https://github.com/masroorhasan/Kubernetes.DotNet>github.com/masroorhasan/Kubernetes.DotNet</a></td></tr><tr><td>Elixir</td><td><a href=https://github.com/obmarg/kazan/>github.com/obmarg/kazan</a></td></tr><tr><td>Elixir</td><td><a href=https://github.com/coryodaniel/k8s>github.com/coryodaniel/k8s</a></td></tr><tr><td>Go</td><td><a href=https://github.com/ericchiang/k8s>github.com/ericchiang/k8s</a></td></tr><tr><td>Java (OSGi)</td><td><a href=https://bitbucket.org/amdatulabs/amdatu-kubernetes>bitbucket.org/amdatulabs/amdatu-kubernetes</a></td></tr><tr><td>Java (Fabric8, OSGi)</td><td><a href=https://github.com/fabric8io/kubernetes-client>github.com/fabric8io/kubernetes-client</a></td></tr><tr><td>Java</td><td><a href=https://github.com/manusa/yakc>github.com/manusa/yakc</a></td></tr><tr><td>Lisp</td><td><a href=https://github.com/brendandburns/cl-k8s>github.com/brendandburns/cl-k8s</a></td></tr><tr><td>Lisp</td><td><a href=https://github.com/xh4/cube>github.com/xh4/cube</a></td></tr><tr><td>Node.js (TypeScript)</td><td><a href=https://github.com/Goyoo/node-k8s-client>github.com/Goyoo/node-k8s-client</a></td></tr><tr><td>Node.js</td><td><a href=https://github.com/ajpauwels/easy-k8s>github.com/ajpauwels/easy-k8s</a></td></tr><tr><td>Node.js</td><td><a href=https://github.com/godaddy/kubernetes-client>github.com/godaddy/kubernetes-client</a></td></tr><tr><td>Node.js</td><td><a href=https://github.com/tenxcloud/node-kubernetes-client>github.com/tenxcloud/node-kubernetes-client</a></td></tr><tr><td>Perl</td><td><a href=https://metacpan.org/pod/Net::Kubernetes>metacpan.org/pod/Net::Kubernetes</a></td></tr><tr><td>PHP</td><td><a href=https://github.com/allansun/kubernetes-php-client>github.com/allansun/kubernetes-php-client</a></td></tr><tr><td>PHP</td><td><a href=https://github.com/maclof/kubernetes-client>github.com/maclof/kubernetes-client</a></td></tr><tr><td>PHP</td><td><a href=https://github.com/travisghansen/kubernetes-client-php>github.com/travisghansen/kubernetes-client-php</a></td></tr><tr><td>PHP</td><td><a href=https://github.com/renoki-co/php-k8s>github.com/renoki-co/php-k8s</a></td></tr><tr><td>Python</td><td><a href=https://github.com/fiaas/k8s>github.com/fiaas/k8s</a></td></tr><tr><td>Python</td><td><a href=https://github.com/gtsystem/lightkube>github.com/gtsystem/lightkube</a></td></tr><tr><td>Python</td><td><a href=https://github.com/mnubo/kubernetes-py>github.com/mnubo/kubernetes-py</a></td></tr><tr><td>Python</td><td><a href=https://github.com/tomplus/kubernetes_asyncio>github.com/tomplus/kubernetes_asyncio</a></td></tr><tr><td>Python</td><td><a href=https://github.com/Frankkkkk/pykorm>github.com/Frankkkkk/pykorm</a></td></tr><tr><td>Ruby</td><td><a href=https://github.com/abonas/kubeclient>github.com/abonas/kubeclient</a></td></tr><tr><td>Ruby</td><td><a href=https://github.com/k8s-ruby/k8s-ruby>github.com/k8s-ruby/k8s-ruby</a></td></tr><tr><td>Ruby</td><td><a href=https://github.com/kontena/k8s-client>github.com/kontena/k8s-client</a></td></tr><tr><td>Rust</td><td><a href=https://github.com/clux/kube-rs>github.com/clux/kube-rs</a></td></tr><tr><td>Rust</td><td><a href=https://github.com/ynqa/kubernetes-rust>github.com/ynqa/kubernetes-rust</a></td></tr><tr><td>Scala</td><td><a href=https://github.com/hagay3/skuber>github.com/hagay3/skuber</a></td></tr><tr><td>Scala</td><td><a href=https://github.com/hnaderi/scala-k8s>github.com/hnaderi/scala-k8s</a></td></tr><tr><td>Scala</td><td><a href=https://github.com/joan38/kubernetes-client>github.com/joan38/kubernetes-client</a></td></tr><tr><td>Swift</td><td><a href=https://github.com/swiftkube/client>github.com/swiftkube/client</a></td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-8d2ce3e7b2223cda0ccd428f4d5ea24b>4 - Kubernetes 弃用策略</h1><p>本文档详细解释系统中各个层面的弃用策略（Deprecation Policy）。</p><p>Kubernetes 是一个组件众多、贡献者人数众多的大系统。
就像很多类似的软件，所提供的功能特性集合会随着时间推移而自然发生变化，
而且有时候某个功能特性可能需要被去除。被去除的可能是一个 API、
一个参数标志或者甚至某整个功能特性。为了避免影响到现有用户，
Kubernetes 对于其中渐次移除的各个方面规定了一种弃用策略并遵从此策略。</p><h2 id=deprecating-parts-of-the-api>弃用 API 的一部分</h2><p>由于 Kubernetes 是一个 API 驱动的系统，API 会随着时间推移而演化，
以反映人们对问题空间的认识的变化。Kubernetes API 实际上是一个 API 集合，
其中每个成员称作“API 组（API Group）”，并且每个 API 组都是独立管理版本的。
<a href=/zh-cn/docs/reference/using-api/#api-versioning>API 版本</a>会有三类，
每类有不同的废弃策略：</p><table><thead><tr><th>示例</th><th>分类</th></tr></thead><tbody><tr><td>v1</td><td>正式发布（Generally available，GA，稳定版本）</td></tr><tr><td>v1beta1</td><td>Beta （预发布）</td></tr><tr><td>v1alpha1</td><td>Alpha （试验性）</td></tr></tbody></table><p>给定的 Kubernetes 发布版本中可以支持任意数量的 API 组，且每组可以包含任意个数的版本。</p><p>下面的规则负责指导 API 元素的弃用，具体元素包括：</p><ul><li>REST 资源（也即 API 对象）</li><li>REST 资源的字段</li><li>REST 资源的注解，包含“beta”类注解但不包含“alpha”类注解</li><li>枚举值或者常数值</li><li>组件配置结构</li></ul><p>以下是跨正式发布版本时要实施的规则，不适用于对 master 或发布分支上不同提交之间的变化。</p><p><strong>规则 #1：只能在增加 API 组版本号时删除 API 元素。</strong></p><p>一旦在某个特定 API 组版本中添加了 API 元素，则该元素不可从该版本中删除，
且其行为也不能大幅度地变化，无论属于哪一类（GA、Alpha 或 Beta）。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong> 由于历史原因，Kubernetes 中存在两个“单体式（Monolithic）”API 组 -
“core”（无组名）和“extensions”。这两个遗留 API 组中的资源会被逐渐迁移到更为特定领域的 API 组中。</div><p><strong>规则 #2：在给定的发布版本中，API 对象必须能够在不同的 API
版本之间来回转换且不造成信息丢失，除非整个 REST 资源在某些版本中完全不存在。</strong></p><p>例如，一个对象可被用 v1 来写入之后用 v2 来读出并转换为 v1，所得到的 v1 必须与原来的
v1 对象完全相同。v2 中的表现形式可能与 v1 不同，但系统知道如何在两个版本之间执行双向转换。
此外，v2 中添加的所有新字段都必须能够转换为 v1 再转换回来。这意味着 v1
必须添加一个新的等效字段或者将其表现为一个注解。</p><p><strong>规则 #3：给定类别的 API 版本不可被弃用以支持稳定性更差的 API 版本。</strong></p><ul><li>一个正式发布的（GA）API 版本可替换 Beta 或 Alpha API 版本。</li><li>Beta API 版本可以替换早期的 Beta 和 Alpha API 版本，但 <strong>不可以</strong> 替换正式的 API 版本。</li><li>Alpha API 版本可以替换早期的 Alpha API 版本，但 <strong>不可以</strong> 替换 Beta 或正式的 API 版本。</li></ul><p><strong>规则 #4a：API 生命周期由 API 稳定性级别决定</strong></p><ul><li>GA API 版本可以被标记为已弃用，但不得在 Kubernetes 的主要版本中删除</li><li>Beta API 版本在引入后不超过 9 个月或 3 个次要版本（以较长者为准）将被弃用，
并且在弃用后 9 个月或 3 个次要版本（以较长者为准）不再提供服务</li><li>Alpha API 版本可能会在任何版本中被删除，不另行通知</li></ul><p>这确保了 Beta API 支持涵盖了<a href=/zh-cn/releases/version-skew-policy/>最多 2 个版本的支持版本偏差</a>，
并且这些 API 不会在不稳定的 Beta 版本上停滞不前，积累的生产使用数据将在对 Beta API 的支持结束时中断。</p><div class="alert alert-info note callout" role=alert><strong>说明：</strong><p>目前没有删除正式版本 API 的 Kubernetes 主要版本修订计划。</div><div class="alert alert-info note callout" role=alert><strong>说明：</strong> 在 <a href=https://github.com/kubernetes/kubernetes/issues/52185>#52185</a> 被解决之前，
已经被保存到持久性存储中的 API 版本都不可以被去除。
你可以禁止这些版本所对应的 REST 末端（在符合本文中弃用时间线的前提下），
但是 API 服务器必须仍能解析和转换存储中以前写入的数据。</div><p><strong>规则 #4b：标记为“preferred（优选的）” API 版本和给定 API 组的
“storage version（存储版本）”在既支持老版本也支持新版本的 Kubernetes
发布版本出来以前不可以提升其版本号。</strong></p><p>用户必须能够升级到 Kubernetes 新的发行版本，之后再回滚到前一个发行版本，
且整个过程中无需针对新的 API 版本做任何转换，也不允许出现功能损坏的情况，
除非用户显式地使用了仅在较新版本中才存在的功能特性。
就对象的存储表示而言，这一点尤其是不言自明的。</p><p>以上所有规则最好通过例子来说明。假定现有 Kubernetes 发行版本为 X，其中引入了新的 API 组。
大约每隔 4 个月会有一个新的 Kubernetes 版本被发布（每年 3 个版本）。
下面的表格描述了在一系列后续的发布版本中哪些 API 版本是受支持的。</p><table><thead><tr><th>发布版本</th><th>API 版本</th><th>优选/存储版本</th><th>注释</th></tr></thead><tbody><tr><td>X</td><td>v1alpha1</td><td>v1alpha1</td><td></td></tr><tr><td>X+1</td><td>v1alpha2</td><td>v1alpha2</td><td><ul><li>v1alpha1 被去除，发布说明中会包含 "action required（采取行动）" 说明</li></ul></td></tr><tr><td>X+2</td><td>v1beta1</td><td>v1beta1</td><td><ul><li>v1alpha2 被去除，发布说明中包含对应的 "action required（采取行动）" 说明</li></ul></td></tr><tr><td>X+3</td><td>v1beta2、v1beta1（已弃用）</td><td>v1beta1</td><td><ul><li>v1beta1 被弃用，发布说明中包含对应的 "action required（采取行动）" 说明</li></ul></td></tr><tr><td>X+4</td><td>v1beta2、v1beta1（已弃用）</td><td>v1beta2</td><td></td></tr><tr><td>X+5</td><td>v1、v1beta1（已弃用）、v1beta2（已弃用）</td><td>v1beta2</td><td><ul><li>v1beta2 被弃用，发布说明中包含对应的 "action required（采取行动）" 说明</li></ul></td></tr><tr><td>X+6</td><td>v1、v1beta2（已弃用）</td><td>v1</td><td><ul><li>v1beta1 被去除，发布说明中包含对应的 "action required（采取行动）" 说明</li></ul></td></tr><tr><td>X+7</td><td>v1、v1beta2（已弃用）</td><td>v1</td><td></td></tr><tr><td>X+8</td><td>v2alpha1、v1</td><td>v1</td><td><ul><li>v1beta2 被去除，发布说明中包含对应的 "action required（采取行动）" 说明</li></ul></td></tr><tr><td>X+9</td><td>v2alpha2、v1</td><td>v1</td><td><ul><li>v2alpha1 被删除，发布说明中包含对应的 "action required（采取行动）" 说明</li></ul></td></tr><tr><td>X+10</td><td>v2beta1、v1</td><td>v1</td><td><ul><li>v2alpha2 被删除，发布说明中包含对应的 "action required（采取行动）" 说明</li></ul></td></tr><tr><td>X+11</td><td>v2beta2、v2beta1（已弃用）、v1</td><td>v1</td><td><ul><li>v2beta1 被弃用，发布说明中包含对应的 "action required（采取行动）" 说明</li></ul></td></tr><tr><td>X+12</td><td>v2、v2beta2（已弃用）、v2beta1（已弃用）、v1（已弃用）</td><td>v1</td><td><ul><li>v2beta2 已被弃用，发布说明中包含对应的 "action required（采取行动）" 说明</li><li>v1 已被弃用，取而代之的是 v2，但不会被删除</li></ul></td></tr><tr><td>X+13</td><td>v2、v2beta1（已弃用）、v2beta2（已弃用）、v1（已弃用）</td><td>v2</td><td></td></tr><tr><td>X+14</td><td>v2、v2beta2（已弃用）、v1（已弃用）</td><td>v2</td><td><ul><li>v2beta1 被删除，发布说明中包含对应的 "action required（采取行动）" 说明</li></ul></td></tr><tr><td>X+15</td><td>v2、v1（已弃用）</td><td>v2</td><td><ul><li>v2beta2 被删除，发布说明中包含对应的 "action required（采取行动）" 说明</li></ul></td></tr></tbody></table><h3 id=rest-resources-aka-api-objects>REST 资源（也即 API 对象）</h3><p>考虑一个假想的名为 Widget 的 REST 资源，在上述时间线中位于 API v1，而现在打算将其弃用。
我们会在文档和<a href=https://groups.google.com/forum/#!forum/kubernetes-announce>公告</a>中与
X+1 版本的发布同步记述此弃用决定。
Wdiget 资源仍会在 API 版本 v1（已弃用）中存在，但不会出现在 v2alpha1 中。
Widget 资源会 X+8 发布版本之前（含 X+8）一直存在并可用。
只有在发布版本 X+9 中，API v1 寿终正寝时，Widget
才彻底消失，相应的资源行为也被移除。</p><p>从 Kubernetes v1.19 开始，当 API 请求被发送到一个已弃用的 REST API 末端时：</p><ol><li><p>API 响应中会包含一个 <code>Warning</code> 头部字段（如 <a href=https://tools.ietf.org/html/rfc7234#section-5.5>RFC7234 5.5 节</a>所定义）；</p></li><li><p>该请求会导致对应的<a href=/zh-cn/docs/tasks/debug/debug-cluster/audit/>审计事件</a>中会增加一个注解
<code>"k8s.io/deprecated":"true"</code>。</p></li><li><p><code>kube-apiserver</code> 进程的 <code>apiserver_requested_deprecated_apis</code> 度量值会被设置为 <code>1</code>。
该度量值还附带 <code>group</code>、<code>version</code>、<code>resource</code> 和 <code>subresource</code> 标签
（可供添加到度量值 <code>apiserver_request_total</code> 上），
和一个 <code>removed_release</code> 标签，标明该 API 将消失的 Kubernetes 发布版本。
下面的 Prometheus 查询会返回对 v1.22 中将移除的、已弃用的 API 的请求的信息：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-promql data-lang=promql><span style=display:flex><span><span style=color:#b8860b>apiserver_requested_deprecated_apis</span>{<span style=color:#a0a000>removed_release</span><span style=color:#666>=</span>&#34;<span style=color:#b44>1.22</span>&#34;}<span style=color:#bbb> </span><span style=color:#666>*</span><span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>on</span><span style=color:#666>(</span><span style=color:#a2f;font-weight:700>group</span>,<span style=color:#b8860b>version</span>,<span style=color:#b8860b>resource</span>,<span style=color:#b8860b>subresource</span><span style=color:#666>)</span><span style=color:#bbb> </span><span style=color:#a2f;font-weight:700>group_right</span><span style=color:#666>()</span><span style=color:#bbb> </span><span style=color:#b8860b>apiserver_request_total</span><span style=color:#bbb>
</span></span></span></code></pre></div></li></ol><h3 id=fields-of-rest-resources>REST 资源的字段</h3><p>就像整个 REST 资源一样，在 API v1 中曾经存在的各个字段在 API v1 被移除之前必须一直存在且起作用。
与整个资源上的规定不同，v2 API 可以选择为字段提供不同的表示方式，
只要对应的资源对象可在不同版本之间来回转换即可。
例如，v1 版本中一个名为 "magnitude" 的已弃用字段可能在 API v2 中被命名为 "deprecatedMagnitude"。
当 v1 最终被移除时，废弃的字段也可以从 v2 中移除。</p><h3 id=enumerated-or-constant-values>枚举值或常数值</h3><p>就像前文讲述的 REST 资源及其中的单个字段一样，API v1 中所支持的常数值必须在
API v1 被移除之前一直存在且起作用。</p><h3 id=component-config-structures>组件配置结构</h3><p>组件的配置也是有版本的，并且按 REST 资源的方式来管理。</p><h3 id=future-work>将来的工作</h3><p>随着时间推移，Kubernetes 会引入粒度更细的 API 版本。
到那时，这里的规则会根据需要进行调整。</p><h2 id=弃用一个标志或-cli-命令>弃用一个标志或 CLI 命令</h2><p>Kubernetes 系统中包含若干不同的、相互协作的程序。
有时，Kubernetes 可能会删除这些程序的某些标志或 CLI 命令（统称“命令行元素”）。
这些程序可以天然地划分到两个大组中：面向用户的和面向管理员的程序。
二者之间的弃用策略略有不同。
除非某个标志显示地通过前缀或文档来标明其为“alpha”或“beta”，
该标志要被视作正式发布的（GA）。</p><p>命令行元素相当于系统的 API 的一部分，不过因为它们并没有采用 REST API
一样的方式来管理版本，其弃用规则规定如下：</p><p><strong>规则 #5a：面向用户的命令行元素（例如，kubectl）必须在其宣布被弃用其在以下时长内仍能使用：</strong></p><ul><li><strong>GA：12 个月或者 2 个发布版本（取其较长者）</strong></li><li><strong>Beta：3 个月或者 1 个发布版本（取其较长者）</strong></li><li><strong>Alpha：0 发布版本</strong></li></ul><p><strong>规则 #5b：面向管理员的命令行元素（例如，kubelet）必须在其被宣布弃用之后以下时长内保持可用：</strong></p><ul><li><strong>GA：6 个月或 1 个发行版本（取其较长者）</strong></li><li><strong>Beta: 3 个月或 1 个发行版本（取其较长者）</strong></li><li><strong>Alpha: 0 个发布版本</strong></li></ul><p><strong>规则 #6：被弃用的 CLI 元素在被用到时必须能够产生警告，而警告的产生是可以被禁止的。</strong></p><h2 id=deprecating-a-feature-or-behavior>弃用某功能特性或行为</h2><p>在一些较偶然的情形下，某 Kubernetes 发行版本需要弃用系统的某项功能特性或者行为，
而对应的功能特性或行为并不受 API 或 CLI 控制。在这种情况下，其弃用规则如下：</p><p><strong>规则 #7：被弃用的行为必须在被宣布弃用之后至少 1 年时间内必须保持能用。</strong></p><p>这并不意味着对系统的所有更改都受此策略约束。
此规则仅适用于重大的、用户可见的行为；这些行为会影响到在 Kubernetes
中运行的应用的正确性，或者影响到 Kubernetes 集群的管理。
此规则也适用于那些被整个移除的功能特性或行为。</p><p>上述规则的一个例外是 <strong>特性门控（Feature Gate）</strong>。特性门控是一些键值偶对，
允许用户启用或禁用一些试验性的功能特性。</p><p>特性门控意在覆盖功能特性的整个开发周期，它们无意成为长期的 API。
因此，它们会在某功能特性正式发布或被抛弃之后被弃用和删除。</p><p>随着一个功能特性经过不同的成熟阶段，相关的特性门控也会演化。
与功能特性生命周期对应的特性门控状态为：</p><ul><li>Alpha：特性门控默认被禁用，只能由用户显式启用。</li><li>Beta：特性门控默认被弃用，可被用户显式禁用。</li><li>GA: 特性门控被弃用（参见<a href=#deprecation>弃用</a>），并且不再起作用。</li><li>GA，弃用窗口期结束：特性门控被删除，不再接受调用。</li></ul><h3 id=deprecation>弃用</h3><p>功能特性在正式发布之前的生命周期内任何时间点都可被移除。
当未正式发布的功能特性被移除时，它们对应的特性门控也被弃用。</p><p>当尝试禁用一个不再起作用的特性门控时，该调用会失败，这样可以避免毫无迹象地执行一些不受支持的场景。</p><p>在某些场合，移除一个即将正式发布的功能特性需要很长时间。
特性门控可以保持其功能，直到对应的功能特性被彻底去除，直到那时特性门控自身才可被弃用。</p><p>由于移除一个已经正式发布的功能特性对应的特性门控也需要一定时间，对特性门控的调用可能一直被允许，
前提是特性门控对功能本身无影响且特性门控不会引发任何错误。</p><p>意在允许用户禁用的功能特性应该包含一个在相关联的特性门控中禁用该功能的机制。</p><p>特性门控的版本管理与之前讨论的组件版本管理不同，因此其对应的弃用策略如下：</p><p><strong>规则 #8：特性门控所对应的功能特性经历下面所列的成熟性阶段转换时，特性门控必须被弃用。
特性门控弃用时必须在以下时长内保持其功能可用：</strong></p><ul><li><strong>Beta 特性转为 GA：6 个月或者 2 个发布版本（取其较长者）</strong></li><li><strong>Beta 特性转为丢弃：3 个月或者 1 个发布版本（取其较长者）</strong></li><li><strong>Alpha 特性转为丢弃：0 个发布版本</strong></li></ul><p><strong>规则 #9：已弃用的特色门控再被使用时必须给出警告回应。当特性门控被弃用时，
必须在发布说明和对应的 CLI 帮助信息中通过文档宣布。
警告信息和文档都要标明是否某特性门控不再起作用。</strong></p><h3 id=deprecating-a-metric>弃用度量值</h3><p>Kubernetes 控制平面的每个组件都公开度量值（通常是 <code>/metrics</code> 端点），它们通常由集群管理员使用。
并不是所有的度量值都是同样重要的：一些度量值通常用作 SLIs 或被使用来确定 SLOs，这些往往比较重要。
其他度量值在本质上带有实验性，或者主要用于 Kubernetes 开发过程。</p><p>因此，度量值分为两个稳定性类别（<code>ALPHA</code> 和 <code>STABLE</code>）;
此分类会影响在 Kubernetes 发布版本中移除某度量值。
所对应的分类取决于对该度量值重要性的预期。
弃用和移除度量值的规则如下：</p><p><strong>规则 #9a: 对于相应的稳定性类别，度量值起作用的周期必须不小于：</strong></p><ul><li><strong>STABLE: 4 个发布版本或者 12 个月 (取其较长者)</strong></li><li><strong>ALPHA: 0 个发布版本</strong></li></ul><p><strong>规则 #9b: 在度量值被宣布启用之后，它起作用的周期必须不小于：</strong></p><ul><li><strong>STABLE: 3 个发布版本或者 9 个月 (取其较长者)</strong></li><li><strong>ALPHA: 0 个发布版本</strong></li></ul><p>已弃用的度量值将在其描述文本前加上一个已弃用通知字符串 '(Deprecated from x.y)'，
并将在度量值被记录期间发出警告日志。就像稳定的、未被弃用的度量指标一样，
被弃用的度量值将自动注册到 metrics 端点，因此被弃用的度量值也是可见的。</p><p>在随后的版本中（当度量值 <code>deprecatedVersion</code> 等于 <strong>当前 Kubernetes 版本 - 3</strong>），
被弃用的度量值将变成 <strong>隐藏（Hidden）</strong> metric 度量值。
与被弃用的度量值不同，隐藏的度量值将不再被自动注册到 metrics 端点（因此被隐藏）。
但是，它们可以通过可执行文件的命令行标志显式启用
（<code>--show-hidden-metrics-for-version=</code>）。
如果集群管理员不能对早期的弃用警告作出反应，这一设计就为他们提供了抓紧迁移弃用度量值的途径。
隐藏的度量值应该在再过一个发行版本后被删除。</p><h2 id=exceptions>例外</h2><p>没有策略可以覆盖所有情况。此策略文档是一个随时被更新的文档，会随着时间推移演化。
在实践中，会有一些情况无法很好地匹配到这里的弃用策略，
或者这里的策略变成了很严重的羁绊。这类情形要与 SIG 和项目领导讨论，
寻求对应场景的最佳解决方案。请一直铭记，Kubernetes 承诺要成为一个稳定的系统，
至少会尽力做到不会影响到其用户。此弃用策略的任何例外情况都会在所有相关的发布说明中公布。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-2479c39af50fd55b898a3bcfb5988077>5 - 已弃用 API 的迁移指南</h1><p>随着 Kubernetes API 的演化，APIs 会周期性地被重组或升级。
当 APIs 演化时，老的 API 会被弃用并被最终删除。
本页面包含你在将已弃用 API 版本迁移到新的更稳定的 API 版本时需要了解的知识。</p><h2 id=removed-apis-by-release>各发行版本中移除的 API</h2><h3 id=v1-27>v1.27</h3><p><strong>v1.27</strong> 发行版本中将去除以下已弃用的 API 版本：</p><h4 id=csistoragecapacity-v127>CSIStorageCapacity</h4><p><strong>storage.k8s.io/v1beta1</strong> API版本的 CSIStorageCapacity 将不再在 v1.27 提供。</p><ul><li>自 v1.24 版本起，迁移清单和 API 客户端使用 <strong>storage.k8s.io/v1</strong> API 版本</li><li>所有现有的持久化对象都可以通过新的 API 访问</li><li>没有需要额外注意的变更</li></ul><h3 id=v1-26>v1.26</h3><p><strong>v1.26</strong> 发行版本中将去除以下已弃用的 API 版本：</p><h4 id=flowcontrol-resources-v126>流控制资源</h4><p><strong>flowcontrol.apiserver.k8s.io/v1beta1</strong> API 版本的 FlowSchema
和 PriorityLevelConfiguration 将不会在 v1.26 中提供。</p><ul><li>迁移清单和 API 客户端使用 <strong>flowcontrol.apiserver.k8s.io/v1beta2</strong> API 版本，
此 API 从 v1.23 版本开始可用；</li><li>所有的已保存的对象都可以通过新的 API 来访问；</li><li>没有需要额外注意的变更</li></ul><h4 id=horizontalpodautoscaler-v126>HorizontalPodAutoscaler</h4><p><strong>autoscaling/v2beta2</strong> API 版本的 HorizontalPodAutoscaler 将不会在
v1.26 版本中提供。</p><ul><li>迁移清单和 API 客户端使用 <strong>autoscaling/v2</strong> API 版本，
此 API 从 v1.23 版本开始可用；</li><li>所有的已保存的对象都可以通过新的 API 来访问；</li></ul><h3 id=v1-25>v1.25</h3><p><strong>v1.25</strong> 发行版本将停止提供以下已废弃 API 版本：</p><h4 id=cronjob-v125>CronJob</h4><p><strong>batch/v1beta1</strong> API 版本的 CronJob 将不会在 v1.25 版本中继续提供。</p><ul><li>迁移清单和 API 客户端使用 <strong>batch/v1</strong> API 版本，此 API 从 v1.21 版本开始可用；</li><li>所有的已保存的对象都可以通过新的 API 来访问；</li><li>没有需要额外注意的变更</li></ul><h4 id=endpointslice-v125>EndpointSlice</h4><p><strong>discovery.k8s.io/v1beta1</strong> API 版本的 EndpointSlice 将不会在 v1.25 版本中继续提供。</p><ul><li>迁移清单和 API 客户端使用 <strong>discovery.k8s.io/v1</strong> API 版本，此 API 从 v1.21 版本开始可用；</li><li>所有的已保存的对象都可以通过新的 API 来访问；</li><li><strong>discovery.k8s.io/v1</strong> 中值得注意的变更有：<ul><li>使用每个 Endpoint 的 <code>nodeName</code> 字段而不是已被弃用的
<code>topology["kubernetes.io/hostname"]</code> 字段；</li><li>使用每个 Endpoint 的 <code>zone</code> 字段而不是已被弃用的
<code>topology["kubernetes.io/zone"]</code> 字段；</li><li><code>topology</code> 字段被替换为 <code>deprecatedTopology</code>，并且在 v1 版本中不可写入。</li></ul></li></ul><h4 id=event-v125>Event</h4><p><strong>events.k8s.io/v1beta1</strong> API 版本的 Event 将不会在 v1.25 版本中继续提供。</p><ul><li>迁移清单和 API 客户端使用 <strong>events.k8s.io/v1</strong> API 版本，此 API 从 v1.19 版本开始可用；</li><li>所有的已保存的对象都可以通过新的 API 来访问；</li></ul><ul><li><strong>events.k8s.io/v1</strong> 中值得注意的变更有：<ul><li><code>type</code> 字段只能设置为 <code>Normal</code> 和 <code>Warning</code> 之一；</li><li><code>involvedObject</code> 字段被更名为 <code>regarding</code>；</li><li><code>action</code>、<code>reason</code>、<code>reportingController</code> 和 <code>reportingInstance</code> 字段
在创建新的 <strong>events.k8s.io/v1</strong> 版本 Event 时都是必需的字段；</li><li>使用 <code>eventTime</code> 而不是已被弃用的 <code>firstTimestamp</code> 字段
（该字段已被更名为 <code>deprecatedFirstTimestamp</code>，且不允许出现在新的 <strong>events.k8s.io/v1</strong> Event 对象中）；</li><li>使用 <code>series.lastObservedTime</code> 而不是已被弃用的 <code>lastTimestamp</code> 字段
（该字段已被更名为 <code>deprecatedLastTimestamp</code>，且不允许出现在新的 <strong>events.k8s.io/v1</strong> Event 对象中）；</li><li>使用 <code>series.count</code> 而不是已被弃用的 <code>count</code> 字段
（该字段已被更名为 <code>deprecatedCount</code>，且不允许出现在新的 <strong>events.k8s.io/v1</strong> Event 对象中）；</li><li>使用 <code>reportingController</code> 而不是已被弃用的 <code>source.component</code> 字段
（该字段已被更名为 <code>deprecatedSource.component</code>，且不允许出现在新的 <strong>events.k8s.io/v1</strong> Event 对象中）；</li><li>使用 <code>reportingInstance</code> 而不是已被弃用的 <code>source.host</code> 字段
（该字段已被更名为 <code>deprecatedSource.host</code>，且不允许出现在新的 <strong>events.k8s.io/v1</strong> Event 对象中）。</li></ul></li></ul><h4 id=horizontalpodautoscaler-v125>HorizontalPodAutoscaler</h4><p><strong>autoscaling/v2beta1</strong> API 版本的 HorizontalPodAutoscaler 将不会在 v1.25 版本中继续提供。</p><ul><li>迁移清单和 API 客户端使用 <strong>autoscaling/v2</strong> API 版本，此 API 从 v1.23 版本开始可用；</li><li>所有的已保存的对象都可以通过新的 API 来访问；</li></ul><h4 id=poddisruptionbudget-v125>PodDisruptionBudget</h4><p><strong>policy/v1beta1</strong> API 版本的 PodDisruptionBudget 将不会在 v1.25 版本中继续提供。</p><ul><li>迁移清单和 API 客户端使用 <strong>policy/v1</strong> API 版本，此 API 从 v1.21 版本开始可用；</li><li>所有的已保存的对象都可以通过新的 API 来访问；</li><li><strong>policy/v1</strong> 中需要额外注意的变更有：<ul><li>在 <code>policy/v1</code> 版本的 PodDisruptionBudget 中将 <code>spec.selector</code>
设置为空（<code>{}</code>）时会选择名字空间中的所有 Pods（在 <code>policy/v1beta1</code>
版本中，空的 <code>spec.selector</code> 不会选择任何 Pods）。如果 <code>spec.selector</code>
未设置，则在两个 API 版本下都不会选择任何 Pods。</li></ul></li></ul><h4 id=psp-v125>PodSecurityPolicy</h4><p><strong>policy/v1beta1</strong> API 版本中的 PodSecurityPolicy 将不会在 v1.25 中提供，
并且 PodSecurityPolicy 准入控制器也会被删除。</p><p>迁移到 <a href=/zh-cn/docs/concepts/security/pod-security-admission/>Pod 安全准入</a>或<a href=/zh-cn/docs/reference/access-authn-authz/extensible-admission-controllers/>第三方准入 webhook</a>。
有关迁移指南，请参阅<a href=/zh-cn/docs/tasks/configure-pod-container/migrate-from-psp/>从 PodSecurityPolicy 迁移到内置 PodSecurity 准入控制器</a>。
有关弃用的更多信息，请参阅 <a href=/zh-cn/blog/2021/04/06/podsecuritypolicy-deprecation-past-present-and-future/>PodSecurityPolicy 弃用：过去、现在和未来</a>。</p><h4 id=runtimeclass-v125>RuntimeClass</h4><p><strong>node.k8s.io/v1beta1</strong> API 版本中的 RuntimeClass 将不会在 v1.25 中提供。</p><ul><li>迁移清单和 API 客户端使用 <strong>node.k8s.io/v1</strong> API 版本，此 API 从 v1.20 版本开始可用；</li><li>所有的已保存的对象都可以通过新的 API 来访问；</li><li>没有需要额外注意的变更</li></ul><h3 id=v1-22>v1.22</h3><p><strong>v1.22</strong> 发行版本停止提供以下已废弃 API 版本：</p><h4 id=webhook-resources-v122>Webhook 资源</h4><p><strong>admissionregistration.k8s.io/v1beta1</strong> API 版本的 MutatingWebhookConfiguration
和 ValidatingWebhookConfiguration 不在 v1.22 版本中继续提供。</p><ul><li>迁移清单和 API 客户端使用 <strong>admissionregistration.k8s.io/v1</strong> API 版本，
此 API 从 v1.16 版本开始可用；</li><li>所有的已保存的对象都可以通过新的 API 来访问；</li></ul><ul><li>值得注意的变更：<ul><li><code>webhooks[*].failurePolicy</code> 在 v1 版本中默认值从 <code>Ignore</code> 改为 <code>Fail</code></li><li><code>webhooks[*].matchPolicy</code> 在 v1 版本中默认值从 <code>Exact</code> 改为 <code>Equivalent</code></li><li><code>webhooks[*].timeoutSeconds</code> 在 v1 版本中默认值从 <code>30s</code> 改为 <code>10s</code></li><li><code>webhooks[*].sideEffects</code> 的默认值被删除，并且该字段变为必须指定；
在 v1 版本中可选的值只能是 <code>None</code> 和 <code>NoneOnDryRun</code> 之一</li><li><code>webhooks[*].admissionReviewVersions</code> 的默认值被删除，在 v1
版本中此字段变为必须指定（AdmissionReview 的被支持版本包括 <code>v1</code> 和 <code>v1beta1</code>）</li><li><code>webhooks[*].name</code> 必须在通过 <code>admissionregistration.k8s.io/v1</code>
创建的对象列表中唯一</li></ul></li></ul><h4 id=customresourcedefinition-v122>CustomResourceDefinition</h4><p><strong>apiextensions.k8s.io/v1beta1</strong> API 版本的 CustomResourceDefinition
不在 v1.22 版本中继续提供。</p><ul><li>迁移清单和 API 客户端使用 <strong>apiextensions/v1</strong> API 版本，此 API 从 v1.16 版本开始可用；</li><li>所有的已保存的对象都可以通过新的 API 来访问；</li></ul><ul><li>值得注意的变更：<ul><li><code>spec.scope</code> 的默认值不再是 <code>Namespaced</code>，该字段必须显式指定</li><li><code>spec.version</code> 在 v1 版本中被删除；应改用 <code>spec.versions</code></li><li><code>spec.validation</code> 在 v1 版本中被删除；应改用 <code>spec.versions[*].schema</code></li><li><code>spec.subresources</code> 在 v1 版本中被删除；应改用 <code>spec.versions[*].subresources</code></li><li><code>spec.additionalPrinterColumns</code> 在 v1 版本中被删除；应改用
<code>spec.versions[*].additionalPrinterColumns</code></li><li><code>spec.conversion.webhookClientConfig</code> 在 v1 版本中被移动到
<code>spec.conversion.webhook.clientConfig</code> 中</li></ul><pre><code>* `spec.conversion.conversionReviewVersions` 在 v1 版本中被移动到
`spec.conversion.webhook.conversionReviewVersions`
</code></pre><ul><li><code>spec.versions[*].schema.openAPIV3Schema</code> 在创建 v1 版本的
CustomResourceDefinition 对象时变成必需字段，并且其取值必须是一个
<a href=/zh-cn/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#specifying-a-structural-schema>结构化的 Schema</a></li><li><code>spec.preserveUnknownFields: true</code> 在创建 v1 版本的 CustomResourceDefinition
对象时不允许指定；该配置必须在 Schema 定义中使用
<code>x-kubernetes-preserve-unknown-fields: true</code> 来设置</li><li>在 v1 版本中，<code>additionalPrinterColumns</code> 的条目中的 <code>JSONPath</code> 字段被更名为
<code>jsonPath</code>（补丁 <a href=https://github.com/kubernetes/kubernetes/issues/66531>#66531</a>）</li></ul></li></ul><h4 id=apiservice-v122>APIService</h4><p><strong>apiregistration/v1beta1</strong> API 版本的 APIService 不在 v1.22 版本中继续提供。</p><ul><li>迁移清单和 API 客户端使用 <strong>apiregistration.k8s.io/v1</strong> API 版本，此 API 从
v1.10 版本开始可用；</li><li>所有的已保存的对象都可以通过新的 API 来访问；</li><li>没有需要额外注意的变更</li></ul><h4 id=tokenreview-v122>TokenReview</h4><p><strong>authentication.k8s.io/v1beta1</strong> API 版本的 TokenReview 不在 v1.22 版本中继续提供。</p><ul><li>迁移清单和 API 客户端使用 <strong>authentication.k8s.io/v1</strong> API 版本，此 API 从
v1.6 版本开始可用；</li><li>所有的已保存的对象都可以通过新的 API 来访问；</li><li>没有需要额外注意的变更</li></ul><h4 id=subjectaccessreview-resources-v122>SubjectAccessReview resources</h4><p><strong>authorization.k8s.io/v1beta1</strong> API 版本的 LocalSubjectAccessReview、
SelfSubjectAccessReview、SubjectAccessReview、SelfSubjectRulesReview 不在 v1.22 版本中继续提供。</p><ul><li>迁移清单和 API 客户端使用 <strong>authorization.k8s.io/v1</strong> API 版本，此 API 从
v1.6 版本开始可用；</li><li>所有的已保存的对象都可以通过新的 API 来访问；</li><li>需要额外注意的变更：<ul><li><code>spec.group</code> 在 v1 版本中被更名为 <code>spec.groups</code>
（补丁 <a href=https://github.com/kubernetes/kubernetes/issues/32709>#32709</a>）</li></ul></li></ul><h4 id=certificatesigningrequest-v122>CertificateSigningRequest</h4><p><strong>certificates.k8s.io/v1beta1</strong> API 版本的 CertificateSigningRequest 不在
v1.22 版本中继续提供。</p><ul><li>迁移清单和 API 客户端使用 <strong>certificates.k8s.io/v1</strong> API 版本，此 API 从
v1.19 版本开始可用；</li><li>所有的已保存的对象都可以通过新的 API 来访问；</li></ul><ul><li><code>certificates.k8s.io/v1</code> 中需要额外注意的变更：<ul><li>对于请求证书的 API 客户端而言：<ul><li><code>spec.signerName</code> 现在变成必需字段（参阅
<a href=/zh-cn/docs/reference/access-authn-authz/certificate-signing-requests/#kubernetes-signers>已知的 Kubernetes 签署者</a>），
并且通过 <code>certificates.k8s.io/v1</code> API 不可以创建签署者为
<code>kubernetes.io/legacy-unknown</code> 的请求</li><li><code>spec.usages</code> 现在变成必需字段，其中不可以包含重复的字符串值，
并且只能包含已知的用法字符串</li></ul></li><li>对于要批准或者签署证书的 API 客户端而言：<ul><li><code>status.conditions</code> 中不可以包含重复的类型</li><li><code>status.conditions[*].status</code> 字段现在变为必需字段</li><li><code>status.certificate</code> 必须是 PEM 编码的，而且其中只能包含 <code>CERTIFICATE</code>
数据块</li></ul></li></ul></li></ul><h4 id=lease-v122>Lease</h4><p><strong>coordination.k8s.io/v1beta1</strong> API 版本的 Lease 不在 v1.22 版本中继续提供。</p><ul><li>迁移清单和 API 客户端使用 <strong>coordination.k8s.io/v1</strong> API 版本，此 API 从
v1.14 版本开始可用；</li><li>所有的已保存的对象都可以通过新的 API 来访问；</li><li>没有需要额外注意的变更</li></ul><h4 id=ingress-v122>Ingress</h4><p><strong>extensions/v1beta1</strong> 和 <strong>networking.k8s.io/v1beta1</strong> API 版本的 Ingress
不在 v1.22 版本中继续提供。</p><ul><li>迁移清单和 API 客户端使用 <strong>networking.k8s.io/v1</strong> API 版本，此 API 从
v1.19 版本开始可用；</li><li>所有的已保存的对象都可以通过新的 API 来访问；</li></ul><ul><li>值得注意的变更：<ul><li><code>spec.backend</code> 字段被更名为 <code>spec.defaultBackend</code></li><li>后端的 <code>serviceName</code> 字段被更名为 <code>service.name</code></li><li>数值表示的后端 <code>servicePort</code> 字段被更名为 <code>service.port.number</code></li><li>字符串表示的后端 <code>servicePort</code> 字段被更名为 <code>service.port.name</code></li><li>对所有要指定的路径，<code>pathType</code> 都成为必需字段。
可选项为 <code>Prefix</code>、<code>Exact</code> 和 <code>ImplementationSpecific</code>。
要匹配 <code>v1beta1</code> 版本中未定义路径类型时的行为，可使用 <code>ImplementationSpecific</code></li></ul></li></ul><h4 id=ingressclass-v122>IngressClass</h4><p><strong>networking.k8s.io/v1beta1</strong> API 版本的 IngressClass 不在 v1.22 版本中继续提供。</p><ul><li>迁移清单和 API 客户端使用 <strong>networking.k8s.io/v1</strong> API 版本，此 API 从
v1.19 版本开始可用；</li><li>所有的已保存的对象都可以通过新的 API 来访问；</li><li>没有需要额外注意的变更</li></ul><h4 id=rbac-resources-v122>RBAC 资源</h4><p><strong>rbac.authorization.k8s.io/v1beta1</strong> API 版本的 ClusterRole、ClusterRoleBinding、
Role 和 RoleBinding 不在 v1.22 版本中继续提供。</p><ul><li>迁移清单和 API 客户端使用 <strong>rbac.authorization.k8s.io/v1</strong> API 版本，此 API 从
v1.8 版本开始可用；</li><li>所有的已保存的对象都可以通过新的 API 来访问；</li><li>没有需要额外注意的变更</li></ul><h4 id=priorityclass-v122>PriorityClass</h4><p><strong>scheduling.k8s.io/v1beta1</strong> API 版本的 PriorityClass 不在 v1.22 版本中继续提供。</p><ul><li>迁移清单和 API 客户端使用 <strong>scheduling.k8s.io/v1</strong> API 版本，此 API 从
v1.14 版本开始可用；</li><li>所有的已保存的对象都可以通过新的 API 来访问；</li><li>没有需要额外注意的变更</li></ul><h4 id=storage-resources-v122>存储资源</h4><p><strong>storage.k8s.io/v1beta1</strong> API 版本的 CSIDriver、CSINode、StorageClass
和 VolumeAttachment 不在 v1.22 版本中继续提供。</p><ul><li>迁移清单和 API 客户端使用 <strong>storage.k8s.io/v1</strong> API 版本<ul><li>CSIDriver 从 v1.19 版本开始在 <strong>storage.k8s.io/v1</strong> 中提供；</li><li>CSINode 从 v1.17 版本开始在 <strong>storage.k8s.io/v1</strong> 中提供；</li><li>StorageClass 从 v1.6 版本开始在 <strong>storage.k8s.io/v1</strong> 中提供；</li><li>VolumeAttachment 从 v1.13 版本开始在 <strong>storage.k8s.io/v1</strong> 中提供；</li></ul></li><li>所有的已保存的对象都可以通过新的 API 来访问；</li><li>没有需要额外注意的变更</li></ul><h3 id=v1-16>v1.16</h3><p><strong>v1.16</strong> 发行版本停止提供以下已废弃 API 版本：</p><h4 id=networkpolicy-v116>NetworkPolicy</h4><p><strong>extensions/v1beta1</strong> API 版本的 NetworkPolicy 不在 v1.16 版本中继续提供。</p><ul><li>迁移清单和 API 客户端使用 <strong>networking.k8s.io/v1</strong> API 版本，此 API 从
v1.8 版本开始可用；</li><li>所有的已保存的对象都可以通过新的 API 来访问；</li></ul><h4 id=daemonset-v116>DaemonSet</h4><p><strong>extensions/v1beta1</strong> 和 <strong>apps/v1beta2</strong> API 版本的 DaemonSet 在
v1.16 版本中不再继续提供。</p><ul><li>迁移清单和 API 客户端使用 <strong>apps/v1</strong> API 版本，此 API 从 v1.9 版本开始可用；</li><li>所有的已保存的对象都可以通过新的 API 来访问；</li></ul><ul><li>值得注意的变更：<ul><li><code>spec.templateGeneration</code> 字段被删除</li><li><code>spec.selector</code> 现在变成必需字段，并且在对象创建之后不可变更；
可以将现有模板的标签作为选择算符以实现无缝迁移。</li><li><code>spec.updateStrategy.type</code> 的默认值变为 <code>RollingUpdate</code>
（<code>extensions/v1beta1</code> API 版本中的默认值是 <code>OnDelete</code>）。</li></ul></li></ul><h4 id=deployment-v116>Deployment</h4><p><strong>extensions/v1beta1</strong>、<strong>apps/v1beta1</strong> 和 <strong>apps/v1beta2</strong> API 版本的
Deployment 在 v1.16 版本中不再继续提供。</p><ul><li>迁移清单和 API 客户端使用 <strong>apps/v1</strong> API 版本，此 API 从 v1.9 版本开始可用；</li><li>所有的已保存的对象都可以通过新的 API 来访问；</li></ul><ul><li>值得注意的变更：<ul><li><code>spec.rollbackTo</code> 字段被删除</li><li><code>spec.selector</code> 字段现在变为必需字段，并且在 Deployment 创建之后不可变更；
可以使用现有的模板的标签作为选择算符以实现无缝迁移。</li><li><code>spec.progressDeadlineSeconds</code> 的默认值变为 <code>600</code> 秒
（<code>extensions/v1beta1</code> 中的默认值是没有期限）</li><li><code>spec.revisionHistoryLimit</code> 的默认值变为 <code>10</code>
（<code>apps/v1beta1</code> API 版本中此字段默认值为 <code>2</code>，在<code>extensions/v1beta1</code> API
版本中的默认行为是保留所有历史记录）。</li><li><code>maxSurge</code> 和 <code>maxUnavailable</code> 的默认值变为 <code>25%</code>
（在 <code>extensions/v1beta1</code> API 版本中，这些字段的默认值是 <code>1</code>）。</li></ul></li></ul><h4 id=statefulset-v116>StatefulSet</h4><p><strong>apps/v1beta1</strong> 和 <strong>apps/v1beta2</strong> API 版本的 StatefulSet 在 v1.16 版本中不再继续提供。</p><ul><li>迁移清单和 API 客户端使用 <strong>apps/v1</strong> API 版本，此 API 从 v1.9 版本开始可用；</li><li>所有的已保存的对象都可以通过新的 API 来访问；</li></ul><ul><li>值得注意的变更：<ul><li><code>spec.selector</code> 字段现在变为必需字段，并且在 StatefulSet 创建之后不可变更；
可以使用现有的模板的标签作为选择算符以实现无缝迁移。</li><li><code>spec.updateStrategy.type</code> 的默认值变为 <code>RollingUpdate</code>
（<code>apps/v1beta1</code> API 版本中的默认值是 <code>OnDelete</code>）。</li></ul></li></ul><h4 id=replicaset-v116>ReplicaSet</h4><p><strong>extensions/v1beta1</strong>、<strong>apps/v1beta1</strong> 和 <strong>apps/v1beta2</strong> API 版本的
ReplicaSet 在 v1.16 版本中不再继续提供。</p><ul><li>迁移清单和 API 客户端使用 <strong>apps/v1</strong> API 版本，此 API 从 v1.9 版本开始可用；</li><li>所有的已保存的对象都可以通过新的 API 来访问；</li></ul><ul><li>值得注意的变更：<ul><li><code>spec.selector</code> 现在变成必需字段，并且在对象创建之后不可变更；
可以将现有模板的标签作为选择算符以实现无缝迁移。</li></ul></li></ul><h4 id=psp-v116>PodSecurityPolicy</h4><p><strong>extensions/v1beta1</strong> API 版本的 PodSecurityPolicy 在 v1.16 版本中不再继续提供。</p><ul><li>迁移清单和 API 客户端使用 <strong>policy/v1beta1</strong> API 版本，此 API 从 v1.10 版本开始可用；</li><li>注意 <strong>policy/v1beta1</strong> API 版本的 PodSecurityPolicy 会在 v1.25 版本中移除。</li></ul><h2 id=what-to-do>需要做什么</h2><h3 id=在禁用已启用-api-的情况下执行测试>在禁用已启用 API 的情况下执行测试</h3><p>你可以通过在启动 API 服务器时禁用特定的 API 版本来模拟即将发生的
API 移除，从而完成测试。在 API 服务器启动参数中添加如下标志：</p><p><code>--runtime-config=&lt;group>/&lt;version>=false</code></p><p>例如：</p><p><code>--runtime-config=admissionregistration.k8s.io/v1beta1=false,apiextensions.k8s.io/v1beta1,...</code></p><h3 id=定位何处使用了已弃用的-api>定位何处使用了已弃用的 API</h3><p>使用 <a href=/blog/2020/09/03/warnings/#deprecation-warnings>client warnings, metrics, and audit information available in 1.19+</a>
来定位在何处使用了已弃用的 API。</p><h3 id=迁移到未被弃用的-api>迁移到未被弃用的 API</h3><ul><li>更新自定义的集成组件和控制器，调用未被弃用的 API</li><li>更改 YAML 文件引用未被弃用的 API</li></ul><p>你可以用 <code>kubectl-convert</code> 命令（在 v1.20 之前是 <code>kubectl convert</code>）
来自动转换现有对象：</p><p><code>kubectl-convert -f &lt;file> --output-version &lt;group>/&lt;version></code>.</p><p>例如，要将较老的 Deployment 版本转换为 <code>apps/v1</code> 版本，你可以运行</p><p><code>kubectl-convert -f ./my-deployment.yaml --output-version apps/v1</code></p><p>需要注意的是这种操作使用的默认值可能并不理想。
要进一步了解某个特定资源，可查阅 Kubernetes <a href=/zh-cn/docs/reference/kubernetes-api/>API 参考</a>。</p></div><div class=td-content style=page-break-before:always><h1 id=pg-e4dbb59f8f23854d7b7d574e169923c4>6 - Kubernetes API 健康端点</h1><p>Kubernetes <a class=glossary-tooltip title='提供 Kubernetes API 服务的控制面组件。' data-toggle=tooltip data-placement=top href=/zh-cn/docs/concepts/overview/components/#kube-apiserver target=_blank aria-label='API 服务器'>API 服务器</a> 提供 API 端点以指示 API 服务器的当前状态。
本文描述了这些 API 端点，并说明如何使用。</p><h2 id=api-endpoints-for-health>API 健康端点</h2><p>Kubernetes API 服务器提供 3 个 API 端点（<code>healthz</code>、<code>livez</code> 和 <code>readyz</code>）来表明 API 服务器的当前状态。
<code>healthz</code> 端点已被弃用（自 Kubernetes v1.16 起），你应该使用更为明确的 <code>livez</code> 和 <code>readyz</code> 端点。
<code>livez</code> 端点可与 <code>--livez-grace-period</code> <a href=/zh-cn/docs/reference/command-line-tools-reference/kube-apiserver>标志</a>一起使用，来指定启动持续时间。
为了正常关机，你可以使用 <code>/readyz</code> 端点并指定 <code>--shutdown-delay-duration</code> <a href=/zh-cn/docs/reference/command-line-tools-reference/kube-apiserver>标志</a>。
检查 API 服务器的 <code>healthz</code>/<code>livez</code>/<code>readyz</code> 端点的机器应依赖于 HTTP 状态代码。
状态码 <code>200</code> 表示 API 服务器是 <code>healthy</code>、<code>live</code> 还是 <code>ready</code>，具体取决于所调用的端点。
以下更详细的选项供操作人员使用，用来调试其集群或了解 API 服务器的状态。</p><p>以下示例将显示如何与运行状况 API 端点进行交互。</p><p>对于所有端点，都可以使用 <code>verbose</code> 参数来打印检查项以及检查状态。
这对于操作人员调试 API 服务器的当前状态很有用，这些不打算给机器使用：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -k https://localhost:6443/livez?verbose
</span></span></code></pre></div><p>或从具有身份验证的远程主机：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get --raw<span style=color:#666>=</span><span style=color:#b44>&#39;/readyz?verbose&#39;</span>
</span></span></code></pre></div><p>输出将如下所示：</p><pre tabindex=0><code>[+]ping ok
[+]log ok
[+]etcd ok
[+]poststarthook/start-kube-apiserver-admission-initializer ok
[+]poststarthook/generic-apiserver-start-informers ok
[+]poststarthook/start-apiextensions-informers ok
[+]poststarthook/start-apiextensions-controllers ok
[+]poststarthook/crd-informer-synced ok
[+]poststarthook/bootstrap-controller ok
[+]poststarthook/rbac/bootstrap-roles ok
[+]poststarthook/scheduling/bootstrap-system-priority-classes ok
[+]poststarthook/start-cluster-authentication-info-controller ok
[+]poststarthook/start-kube-aggregator-informers ok
[+]poststarthook/apiservice-registration-controller ok
[+]poststarthook/apiservice-status-available-controller ok
[+]poststarthook/kube-apiserver-autoregistration ok
[+]autoregister-completion ok
[+]poststarthook/apiservice-openapi-controller ok
healthz check passed
</code></pre><p>Kubernetes API 服务器也支持排除特定的检查项。
查询参数也可以像以下示例一样进行组合：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -k <span style=color:#b44>&#39;https://localhost:6443/readyz?verbose&amp;exclude=etcd&#39;</span>
</span></span></code></pre></div><p>输出显示排除了 <code>etcd</code> 检查：</p><pre tabindex=0><code>[+]ping ok
[+]log ok
[+]etcd excluded: ok
[+]poststarthook/start-kube-apiserver-admission-initializer ok
[+]poststarthook/generic-apiserver-start-informers ok
[+]poststarthook/start-apiextensions-informers ok
[+]poststarthook/start-apiextensions-controllers ok
[+]poststarthook/crd-informer-synced ok
[+]poststarthook/bootstrap-controller ok
[+]poststarthook/rbac/bootstrap-roles ok
[+]poststarthook/scheduling/bootstrap-system-priority-classes ok
[+]poststarthook/start-cluster-authentication-info-controller ok
[+]poststarthook/start-kube-aggregator-informers ok
[+]poststarthook/apiservice-registration-controller ok
[+]poststarthook/apiservice-status-available-controller ok
[+]poststarthook/kube-apiserver-autoregistration ok
[+]autoregister-completion ok
[+]poststarthook/apiservice-openapi-controller ok
[+]shutdown ok
healthz check passed
</code></pre><h2 id=individual-health-check>独立健康检查</h2><div style=margin-top:10px;margin-bottom:10px><b>特性状态：</b> <code>Kubernetes v1.25 [alpha]</code></div><p>每个单独的健康检查都会公开一个 HTTP 端点，并且可以单独检查。
单个运行状况检查的模式为 <code>/livez/&lt;healthcheck-name></code>，其中 <code>livez</code> 和 <code>readyz</code> 表明你要检查的是 API 服务器是否存活或就绪。
<code>&lt;healthcheck-name></code> 的路径可以通过上面的 <code>verbose</code> 参数发现 ，并采用 <code>[+]</code> 和 <code>ok</code> 之间的路径。
这些单独的健康检查不应由机器使用，但对于操作人员调试系统而言，是有帮助的：</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -k https://localhost:6443/livez/etcd
</span></span></code></pre></div></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/zh-cn/docs/home/>主页</a>
<a class=text-white href=/zh-cn/blog/>博客</a>
<a class=text-white href=/zh-cn/training/>培训</a>
<a class=text-white href=/zh-cn/partners/>合作伙伴</a>
<a class=text-white href=/zh-cn/community/>社区</a>
<a class=text-white href=/zh-cn/case-studies/>案例分析</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 The Kubernetes 作者 | 文档发布基于 <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a> 授权许可</small><br><small class=text-white>Copyright &copy; 2023 Linux 基金会&reg;。保留所有权利。Linux 基金会已注册并使用商标。如需了解 Linux 基金会的商标列表，请访问<a href=https://www.linuxfoundation.org/trademark-usage class=light-text>商标使用页面</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>