<!doctype html><html lang=ru class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=en href=https://kubernetes.io/docs/concepts/overview/><link rel=alternate hreflang=zh-cn href=https://kubernetes.io/zh-cn/docs/concepts/overview/><link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/concepts/overview/><link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/concepts/overview/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/concepts/overview/><link rel=alternate hreflang=it href=https://kubernetes.io/it/docs/concepts/overview/><link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/concepts/overview/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/concepts/overview/><link rel=alternate hreflang=pt-br href=https://kubernetes.io/pt-br/docs/concepts/overview/><link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/concepts/overview/><link rel=alternate hreflang=vi href=https://kubernetes.io/vi/docs/concepts/overview/><link rel=alternate hreflang=pl href=https://kubernetes.io/pl/docs/concepts/overview/><link rel=alternate hreflang=uk href=https://kubernetes.io/uk/docs/concepts/overview/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/ru/docs/concepts/overview/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>Обзор | Kubernetes</title><meta property="og:title" content="Обзор"><meta property="og:description" content="Первоклассная оркестрация контейнеров"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/ru/docs/concepts/overview/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="Обзор"><meta itemprop=description content="Первоклассная оркестрация контейнеров"><meta name=twitter:card content="summary"><meta name=twitter:title content="Обзор"><meta name=twitter:description content="Первоклассная оркестрация контейнеров"><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content><meta property="og:description" content><meta name=twitter:description content><meta property="og:url" content="https://kubernetes.io/ru/docs/concepts/overview/"><meta property="og:title" content="Обзор"><meta name=twitter:title content="Обзор"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/ru/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/ru/docs/>Документация</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ru/community/>Сообщество</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ru/case-studies/>Примеры использования</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Versions</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/ru/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/ru/docs/concepts/overview/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/ru/docs/concepts/overview/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/ru/docs/concepts/overview/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/ru/docs/concepts/overview/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/ru/docs/concepts/overview/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Русский (Russian)</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/docs/concepts/overview/>English</a>
<a class=dropdown-item href=/zh-cn/docs/concepts/overview/>中文 (Chinese)</a>
<a class=dropdown-item href=/ko/docs/concepts/overview/>한국어 (Korean)</a>
<a class=dropdown-item href=/ja/docs/concepts/overview/>日本語 (Japanese)</a>
<a class=dropdown-item href=/fr/docs/concepts/overview/>Français (French)</a>
<a class=dropdown-item href=/it/docs/concepts/overview/>Italiano (Italian)</a>
<a class=dropdown-item href=/de/docs/concepts/overview/>Deutsch (German)</a>
<a class=dropdown-item href=/es/docs/concepts/overview/>Español (Spanish)</a>
<a class=dropdown-item href=/pt-br/docs/concepts/overview/>Português (Portuguese)</a>
<a class=dropdown-item href=/id/docs/concepts/overview/>Bahasa Indonesia</a>
<a class=dropdown-item href=/vi/docs/concepts/overview/>Tiếng Việt (Vietnamese)</a>
<a class=dropdown-item href=/pl/docs/concepts/overview/>Polski (Polish)</a>
<a class=dropdown-item href=/uk/docs/concepts/overview/>Українська (Ukrainian)</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>Это многостраничный печатный вид этого раздела.
<a href=# onclick="return print(),!1">Нажмите что бы печатать</a>.</p><p><a href=/ru/docs/concepts/overview/>Вернуться к обычному просмотру страницы</a>.</p></div><h1 class=title>Обзор</h1><ul><li>1: <a href=#pg-45bdca6129cf540121623e903c18ba46>Что такое Kubernetes</a></li><li>2: <a href=#pg-13b0f1dbe89228e3d76d2ac231e245f1>Компоненты Kubernetes</a></li><li>3: <a href=#pg-0c745f42e623d2b70a53bc0e6db73d95>API Kubernetes</a></li><li>4: <a href=#pg-110f33530cf761140cb1dab536baef04>Работа с объектами Kubernetes</a></li><ul><li>4.1: <a href=#pg-9f5adfa77f48c50d5cc81155a3cecb98>Изучение объектов Kubernetes</a></li><li>4.2: <a href=#pg-6751db8ff5409476de8225d17d6c42dd>Управление объектами Kubernetes</a></li><li>4.3: <a href=#pg-f37749a83c2916b63279ea60f3cfe53e>Имена и идентификаторы объектов</a></li><li>4.4: <a href=#pg-1127165f472b7181b9c1d5a0b187d620>Пространства имён</a></li><li>4.5: <a href=#pg-f1dec4557fb8ffbac9f11390aaaf9fa4>Метки и селекторы</a></li><li>4.6: <a href=#pg-93cd7a1d4e1623e2bf01afc49a5af69c>Аннотации</a></li><li>4.7: <a href=#pg-046c03090d47bc4b89b818dc645c3865>Селекторы полей</a></li><li>4.8: <a href=#pg-5dd62c6a4a481b4cf1ac50f6799eb581>Рекомендуемые метки</a></li></ul></ul><div class=content></div></div><div class=td-content><h1 id=pg-45bdca6129cf540121623e903c18ba46>1 - Что такое Kubernetes</h1><p>Эта страница посвящена краткому обзору Kubernetes.</p><p>Kubernetes — это портативная расширяемая платформа с открытым исходным кодом для управления контейнеризованными рабочими нагрузками и сервисами, которая облегчает как декларативную настройку, так и автоматизацию. У платформы есть большая, быстро растущая экосистема. Сервисы, поддержка и инструменты Kubernetes широко доступны.</p><p>Название Kubernetes происходит от греческого, что означает рулевой или штурман. Google открыл исходный код Kubernetes в 2014 году. Kubernetes основывается на <a href=https://research.google/pubs/pub43438>десятилетнем опыте работы Google с масштабными рабочими нагрузками</a>, в сочетании с лучшими в своем классе идеями и практиками сообщества.</p><h2 id=история>История</h2><p>Давайте вернемся назад и посмотрим, почему Kubernetes так полезен.</p><p><img src=/images/docs/Container_Evolution.svg alt="Эволюция развертывания"></p><p><strong>Традиционная эра развертывания:</strong>
Ранее организации запускали приложения на физических серверах. Не было никакого способа определить границы ресурсов для приложений на физическом сервере, и это вызвало проблемы с распределением ресурсов. Например, если несколько приложений выполняются на физическом сервере, могут быть случаи, когда одно приложение будет занимать большую часть ресурсов, и в результате чего другие приложения будут работать хуже. Решением этого было запустить каждое приложение на другом физическом сервере. Но это не масштабировалось, поскольку ресурсы использовались не полностью, из-за чего организациям было накладно поддерживать множество физических серверов.</p><p><strong>Эра виртуального развертывания:</strong> В качестве решения была представлена виртуализация. Она позволила запускать несколько виртуальных машин (ВМ) на одном физическом сервере. Виртуализация изолирует приложения между виртуальными машинами и обеспечивает определенный уровень безопасности, поскольку информация одного приложения не может быть свободно доступна другому приложению.</p><p>Виртуализация позволяет лучше использовать ресурсы на физическом сервере и обеспечивает лучшую масштабируемость, поскольку приложение можно легко добавить или обновить, кроме этого снижаются затраты на оборудование и многое другое. С помощью виртуализации можно превратить набор физических ресурсов в кластер одноразовых виртуальных машин.</p><p>Каждая виртуальная машина представляет собой полноценную машину, на которой выполняются все компоненты, включая собственную операционную систему, поверх виртуализированного оборудования.</p><p><strong>Эра контейнеров:</strong> Контейнеры похожи на виртуальные машины, но у них есть свойства изоляции для совместного использования операционной системы (ОС) между приложениями. Поэтому контейнеры считаются легкими. Подобно виртуальной машине, контейнер имеет свою собственную файловую систему, процессор, память, пространство процесса и многое другое. Поскольку они не связаны с базовой инфраструктурой, они переносимы между облаками и дистрибутивами ОС.</p><p>Контейнеры стали популярными из-за таких дополнительных преимуществ как:</p><ul><li>Гибкое создание и развертывание приложений: простота и эффективность создания образа контейнера по сравнению с использованием образа виртуальной машины.</li><li>Непрерывная разработка, интеграция и развертывание: обеспечивает надежную и частую сборку и развертывание образа контейнера с быстрым и простым откатом (благодаря неизменности образа).</li><li>Разделение задач между Dev и Ops: создавайте образы контейнеров приложений во время сборки/релиза, а не во время развертывания, тем самым отделяя приложения от инфраструктуры.</li><li>Наблюдаемость охватывает не только информацию и метрики на уровне ОС, но также информацию о работоспособности приложений и другие сигналы.</li><li>Идентичная окружающая среда при разработке, тестировании и релизе: на ноутбуке работает так же, как и в облаке.</li><li>Переносимость облачных и операционных систем: работает на Ubuntu, RHEL, CoreOS, on-prem, Google Kubernetes Engine и в любом другом месте.</li><li>Управление, ориентированное на приложения: повышает уровень абстракции от запуска ОС на виртуальном оборудовании до запуска приложения в ОС с использованием логических ресурсов.</li><li>Слабосвязанные, распределенные, гибкие, выделенные микросервисы: вместо монолитного стека на одной большой выделенной машине, приложения разбиты на более мелкие независимые части, которые можно динамически развертывать и управлять.</li><li>Изоляция ресурсов: предсказуемая производительность приложения.</li><li>Грамотное использование ресурсов: высокая эффективность и компактность.</li></ul><h2 id=зачем-вам-kubernetes-и-что-он-может-сделать>Зачем вам Kubernetes и что он может сделать?</h2><p>Контейнеры — отличный способ связать и запустить ваши приложения. В производственной среде необходимо управлять контейнерами, которые запускают приложения, и гарантировать отсутствие простоев. Например, если контейнер выходит из строя, необходимо запустить другой контейнер. Не было бы проще, если бы такое поведение обрабатывалось системой?</p><p>Вот тут Kubernetes приходит на помощь! Kubernetes дает вам фреймворк для гибкой работы распределенных систем. Он занимается масштабированием и обработкой ошибок в приложении, предоставляет шаблоны развертывания и многое другое. Например, Kubernetes может легко управлять канареечным развертыванием вашей системы.</p><p>Kubernetes предоставляет вам:</p><ul><li><strong>Мониторинг сервисов и распределение нагрузки</strong>
Kubernetes может обнаружить контейнер, используя имя DNS или собственный IP-адрес. Если трафик в контейнере высокий, Kubernetes может сбалансировать нагрузку и распределить сетевой трафик, чтобы развертывание было стабильным.</li><li><strong>Оркестрация хранилища</strong>
Kubernetes позволяет вам автоматически смонтировать систему хранения по вашему выбору, такую как локальное хранилище, провайдеры общедоступного облака и многое другое.</li><li><strong>Автоматическое развертывание и откаты</strong>
Используя Kubernetes можно описать желаемое состояние развернутых контейнеров и изменить фактическое состояние на желаемое. Например, вы можете автоматизировать Kubernetes на создание новых контейнеров для развертывания, удаления существующих контейнеров и распределения всех их ресурсов в новый контейнер.</li><li><strong>Автоматическое распределение нагрузки</strong>
Вы предоставляете Kubernetes кластер узлов, который он может использовать для запуска контейнерных задач. Вы указываете Kubernetes, сколько ЦП и памяти (ОЗУ) требуется каждому контейнеру. Kubernetes может разместить контейнеры на ваших узлах так, чтобы наиболее эффективно использовать ресурсы.</li><li><strong>Самоконтроль</strong>
Kubernetes перезапускает отказавшие контейнеры, заменяет и завершает работу контейнеров, которые не проходят определенную пользователем проверку работоспособности, и не показывает их клиентам, пока они не будут готовы к обслуживанию.</li><li><strong>Управление конфиденциальной информацией и конфигурацией</strong>
Kubernetes может хранить и управлять конфиденциальной информацией, такой как пароли, OAuth-токены и ключи SSH. Вы можете развертывать и обновлять конфиденциальную информацию и конфигурацию приложения без изменений образов контейнеров и не раскрывая конфиденциальную информацию в конфигурации стека.</li></ul><h2 id=чем-kubernetes-не-является>Чем Kubernetes не является</h2><p>Kubernetes ― это не традиционная комплексная система PaaS (платформа как услуга). Поскольку Kubernetes работает на уровне контейнеров, а не на уровне оборудования, у него имеется определенные общеприменимые возможности, характерные для PaaS, такие как развертывание, масштабирование, балансировка нагрузки, ведение журналов и мониторинг. Тем не менее, Kubernetes это не монолитное решение, поэтому указанные возможности по умолчанию являются дополнительными и подключаемыми. У Kubernetes есть компоненты для создания платформы разработчика, но он сохраняет право выбора за пользователем и гибкость там, где это важно.</p><p>Kubernetes:</p><ul><li>Не ограничивает типы поддерживаемых приложений. Kubernetes стремится поддерживать широкий спектр рабочих нагрузок, включая те, у которых есть или отсутствует состояние, а также связанные с обработкой данных. Если приложение может работать в контейнере, оно должно отлично работать и в Kubernetes.</li><li>Не развертывает исходный код и не собирает приложение. Рабочие процессы непрерывной интеграции, доставки и развертывания (CI/CD) определяются культурой и предпочтениями организации, а также техническими требованиями.</li><li>Не предоставляет сервисы для приложения, такие как промежуточное программное обеспечение (например, очереди сообщений), платформы обработки данных (например, Spark), базы данных (например, MySQL), кеши или кластерные системы хранения (например, Ceph), как встроенные сервисы. Такие компоненты могут работать в Kubernetes и/или могут быть доступны для приложений, работающих в Kubernetes, через переносные механизмы, такие как Open Service Broker.</li><li>Не включает решения для ведения журнала, мониторинга или оповещения. Он обеспечивает некоторые интеграции в качестве доказательства концепции и механизмы для сбора и экспорта метрик.</li><li>Не указывает и не требует настройки языка/системы (например, Jsonnet). Он предоставляет декларативный API, который может быть нацелен на произвольные формы декларативных спецификаций.</li><li>Не предоставляет и не принимает никаких комплексных систем конфигурации, технического обслуживания, управления или самовосстановления.</li><li>Кроме того, Kubernetes — это не просто система оркестрации. Фактически, Kubernetes устраняет необходимость в этом. Техническое определение оркестрации — это выполнение определенного рабочего процесса: сначала сделай A, затем B, затем C. Напротив, Kubernetes содержит набор независимых, компонуемых процессов управления, которые непрерывно переводит текущее состояние к предполагаемому состоянию. Неважно, как добраться от А до С. Не требуется также централизованный контроль. Это делает систему более простой в использовании, более мощной, надежной, устойчивой и расширяемой.</li></ul><h2 id=что-дальше>Что дальше</h2><ul><li>Изучите <a href=/docs/concepts/overview/components/>Компоненты Kubernetes</a></li><li>Готовы <a href=/docs/setup/>начать</a>?</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-13b0f1dbe89228e3d76d2ac231e245f1>2 - Компоненты Kubernetes</h1><p>При развёртывании Kubernetes вы имеете дело с кластером.<p><p>Кластер Kubernetes cluster состоит из набор машин, так называемые узлы, которые запускают контейнеризированные приложения. Кластер имеет как минимум один рабочий узел.</p></p><p>В рабочих узлах размещены поды, являющиеся компонентами приложения. Плоскость управления управляет рабочими узлами и подами в кластере. В промышленных средах плоскость управления обычно запускается на нескольких компьютерах, а кластер, как правило, развёртывается на нескольких узлах, гарантируя отказоустойчивость и высокую надёжность.</p></p><p>На этой странице в общих чертах описывается различные компоненты, необходимые для работы кластера Kubernetes.</p><p>Ниже показана диаграмма кластера Kubernetes со всеми связанными компонентами.</p><p><img src=/images/docs/components-of-kubernetes.png alt="Компоненты Kubernetes"></p><h2 id=плоскость-управления-компонентами>Плоскость управления компонентами</h2><p>Компоненты панели управления отвечают за основные операции кластера (например, планирование), а также обрабатывают события кластера (например, запускают новый <a class=glossary-tooltip title='Самый маленький и простой объект в Kubernetes. Под — это набор запущенных контейнеров в кластере.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=под>под</a>, когда поле <code>replicas</code> развертывания не соответствует требуемому количеству реплик).</p><p>Компоненты панели управления могут быть запущены на любой машине в кластере. Однако для простоты сценарии настройки обычно запускают все компоненты панели управления на одном компьютере и в то же время не позволяют запускать пользовательские контейнеры на этом компьютере. Смотрите страницу <a href=/docs/admin/high-availability/>Создание высоконадёжных кластеров</a> для примера настройки нескольких ведущих виртуальных машин.</p><h3 id=kube-apiserver>kube-apiserver</h3><p>Сервер API — компонент Kubernetes
<a class=glossary-tooltip title='Уровень оркестрации контейнеров с API и интерфейсами для определения, развёртывания и управления жизненным циклом контейнеров.' data-toggle=tooltip data-placement=top href='/ru/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='панели управления'>панели управления</a>, который представляет API Kubernetes.
API-сервер — это клиентская часть панели управления Kubernetes</p><p>Основной реализацией API-сервера Kubernetes является <a href=/docs/reference/generated/kube-apiserver/>kube-apiserver</a>.
kube-apiserver предназначен для горизонтального масштабирования, то есть развёртывание на несколько экземпляров.
Вы можете запустить несколько экземпляров kube-apiserver и сбалансировать трафик между этими экземплярами.</p><h3 id=etcd>etcd</h3><p>Распределённое и высоконадёжное хранилище данных в формате "ключ-значение", которое используется как основное хранилище всех данных кластера в Kubernetes.</p><p>Если ваш кластер Kubernetes использует etcd в качестве основного хранилища, убедитесь, что у вас <a href=/docs/tasks/administer-cluster/configure-upgrade-etcd/#backing-up-an-etcd-cluster>настроено резервное копирование</a> данных.</p><p>Вы можете найти подробную информацию о etcd в <a href=https://etcd.io/docs/>официальной документации</a>.</p><h3 id=kube-scheduler>kube-scheduler</h3><p>Компонент плоскости управления, который отслеживает созданные поды без привязанного узла и выбирает узел, на котором они должны работать.</p><p>При планировании развёртывания подов на узлах учитываются множество факторов, включая требования к ресурсам, ограничения, связанные с аппаратными/программными политиками, принадлежности (affinity) и непринадлежности (anti-affinity) узлов/подов, местонахождения данных, предельных сроков.</p><h3 id=kube-controller-manager>kube-controller-manager</h3><p>Компонент Control Plane запускает процессы <a class=glossary-tooltip title='Управляющий цикл который отслеживает общее состояние кластера через API-сервер и вносит изменения пытаясь приветси текушее состояние к желаемому состоянию.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=контроллера>контроллера</a>.</p><p>Вполне логично, что каждый <a class=glossary-tooltip title='Управляющий цикл который отслеживает общее состояние кластера через API-сервер и вносит изменения пытаясь приветси текушее состояние к желаемому состоянию.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=контроллер>контроллер</a> в свою очередь представляет собой отдельный процесс, и для упрощения все такие процессы скомпилированы в один двоичный файл и выполняются в одном процессе.</p><p>Эти контроллеры включают:</p><ul><li>Контроллер узла (Node Controller): уведомляет и реагирует на сбои узла.</li><li>Контроллер репликации (Replication Controller): поддерживает правильное количество подов для каждого объекта контроллера репликации в системе.</li><li>Контроллер конечных точек (Endpoints Controller): заполняет объект конечных точек (Endpoints), то есть связывает сервисы (Services) и поды (Pods).</li><li>Контроллеры учетных записей и токенов (Account & Token Controllers): создают стандартные учетные записи и токены доступа API для новых пространств имен.</li></ul><h3 id=cloud-controller-manager>cloud-controller-manager</h3><p><a href=/docs/tasks/administer-cluster/running-cloud-controller/>cloud-controller-manager</a> запускает контроллеры, которые взаимодействуют с основными облачными провайдерами. Двоичный файл cloud-controller-manager — это альфа-функциональность, появившиеся в Kubernetes 1.6.</p><p>cloud-controller-manager запускает только циклы контроллера, относящиеся к облачному провайдеру. Вам нужно отключить эти циклы контроллера в kube-controller-manager. Вы можете отключить циклы контроллера, установив флаг <code>--cloud-provider</code> со значением <code>external</code> при запуске kube-controller-manager.</p><p>С помощью cloud-controller-manager код как облачных провайдеров, так и самого Kubernetes может разрабатываться независимо друг от друга. В предыдущих версиях код ядра Kubernetes зависел от кода, предназначенного для функциональности облачных провайдеров. В будущих выпусках код, специфичный для облачных провайдеров, должен поддерживаться самим облачным провайдером и компоноваться с cloud-controller-manager во время запуска Kubernetes.</p><p>Следующие контроллеры зависят от облачных провайдеров:</p><ul><li>Контроллер узла (Node Controller): проверяет облачный провайдер, чтобы определить, был ли удален узел в облаке после того, как он перестал работать</li><li>Контроллер маршрутов (Route Controller): настраивает маршруты в основной инфраструктуре облака</li><li>Контроллер сервисов (Service Controller): создаёт, обновляет и удаляет балансировщики нагрузки облачного провайдера.</li><li>Контроллер тома (Volume Controller): создаёт, присоединяет и монтирует тома, а также взаимодействует с облачным провайдером для оркестрации томов.</li></ul><h2 id=компоненты-узла>Компоненты узла</h2><p>Компоненты узла работают на каждом узле, поддерживая работу подов и среды выполнения Kubernetes.</p><h3 id=kubelet>kubelet</h3><p>Агент, работающий на каждом узле в кластере. Он следит за тем, чтобы контейнеры были запущены в поде.</p><p>Утилита kubelet принимает набор PodSpecs, и гарантирует работоспособность и исправность определённых в них контейнеров. Агент kubelet не отвечает за контейнеры, не созданные Kubernetes.</p><h3 id=kube-proxy>kube-proxy</h3><p><a href=/docs/reference/command-line-tools-reference/kube-proxy/>kube-proxy</a> — сетевой прокси, работающий на каждом узле в кластере, и реализующий часть концепции <a class=glossary-tooltip title='Способ представления приложения, запущенного в наборе подов, в виде сетевого сервиса.' data-toggle=tooltip data-placement=top href=/docs/concepts/services-networking/service/ target=_blank aria-label=сервис>сервис</a>.</p><p>kube-proxy конфигурирует правила сети на узлах. При помощи них разрешаются сетевые подключения к вашими подам изнутри и снаружи кластера.</p><p>kube-proxy использует уровень фильтрации пакетов в операционной системы, если он доступен. В противном случае, kube-proxy сам обрабатывает передачу сетевого трафика.</p><h3 id=среда-выполнения-контейнера>Среда выполнения контейнера</h3><p>Среда выполнения контейнера — это программа, предназначенная для выполнения контейнеров.</p><p>Kubernetes поддерживает несколько сред для запуска контейнеров: <a class=glossary-tooltip title='Docker — это программное обеспечение для виртуализации на уровне операционной системы, которая известна как контейнеризация.' data-toggle=tooltip data-placement=top href=https://docs.docker.com/engine/ target=_blank aria-label=Docker>Docker</a>,
<a class=glossary-tooltip title='Среда выполнения контейнера с упором на простоту, надежность и переносимость' data-toggle=tooltip data-placement=top href=https://containerd.io/docs/ target=_blank aria-label=containerd>containerd</a>, <a class=glossary-tooltip title='Оптимизированная среда выполнения контейнеров, разработанная специально для Kubernetes' data-toggle=tooltip data-placement=top href=https://cri-o.io/#what-is-cri-o target=_blank aria-label=CRI-O>CRI-O</a>,
и любая реализация <a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-node/container-runtime-interface.md>Kubernetes CRI (Container Runtime
Interface)</a>.</p><h2 id=дополнения>Дополнения</h2><p>Дополнения используют ресурсы Kubernetes (<a class=glossary-tooltip title='Гарантирует, что копия Pod выполняется в наборе узлов кластера.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/daemonset target=_blank aria-label=DaemonSet>DaemonSet</a>, <a class=glossary-tooltip title='API-объект, управляющий реплицированным приложением.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Deployment>Deployment</a> и т.д.) для расширения функциональности кластера. Поскольку дополнения охватывают весь кластер, ресурсы относятся к пространству имен <code>kube-system</code>.</p><p>Некоторые из дополнений описаны ниже; более подробный список доступных расширений вы можете найти на странице <a href=/docs/concepts/cluster-administration/addons/>Дополнения</a>.</p><h3 id=dns>DNS</h3><p>Хотя прочие дополнения не являются строго обязательными, однако при этом у всех Kubernetes-кластеров должен быть <a href=/docs/concepts/services-networking/dns-pod-service/>кластерный DNS</a>, так как многие примеры предполагают его наличие.</p><p>Кластерный DNS — это DNS-сервер наряду с другими DNS-серверами в вашем окружении, который обновляет DNS-записи для сервисов Kubernetes.</p><p>Контейнеры, запущенные посредством Kubernetes, автоматически включают этот DNS-сервер в свои DNS.</p><h3 id=веб-интерфейс-dashboard>Веб-интерфейс (Dashboard)</h3><p><a href=/docs/tasks/access-application-cluster/web-ui-dashboard/>Dashboard</a> — это универсальный веб-интерфейс для кластеров Kubernetes. С помощью этой панели, пользователи могут управлять и устранять неполадки кластера и приложений, работающих в кластере.</p><h3 id=мониторинг-ресурсов-контейнера>Мониторинг ресурсов контейнера</h3><p><a href=/docs/tasks/debug-application-cluster/resource-usage-monitoring/>Мониторинг ресурсов контейнера</a> записывает общие метрики о контейнерах в виде временных рядов в центральной базе данных и предлагает пользовательский интерфейс для просмотра этих данных.</p><h3 id=логирование-кластера>Логирование кластера</h3><p>Механизм <a href=/docs/concepts/cluster-administration/logging/>логирования кластера</a> отвечает за сохранение логов контейнера в централизованном хранилище логов с возможностью их поиска/просмотра.</p><h2 id=что-дальше>Что дальше</h2><ul><li>Подробнее про <a href=/docs/concepts/architecture/nodes/>узлы</a></li><li>Подробнее про <a href=/docs/concepts/architecture/controller/>контроллеры</a></li><li>Подробнее про <a href=/docs/concepts/scheduling/kube-scheduler/>kube-scheduler</a></li><li>Официальная <a href=https://etcd.io/docs/>документация</a> etcd</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-0c745f42e623d2b70a53bc0e6db73d95>3 - API Kubernetes</h1><p>Общие соглашения API описаны на <a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md>странице соглашений API</a>.</p><p>Конечные точки API, типы ресурсов и примеры описаны в <a href=/ru/docs/reference>справочнике API</a>.</p><p>Удаленный доступ к API обсуждается в <a href=/docs/reference/access-authn-authz/controlling-access/>Controlling API Access doc</a>.</p><p>API Kubernetes также служит основой декларативной схемы конфигурации системы. С помощью инструмента командной строки <a href=/ru/docs/reference/kubectl/overview/>kubectl</a> можно создавать, обновлять, удалять и получать API-объекты.</p><p>Kubernetes также сохраняет сериализованное состояние (в настоящее время в хранилище <a href=https://coreos.com/docs/distributed-configuration/getting-started-with-etcd/>etcd</a>) каждого API-ресурса.</p><p>Kubernetes как таковой состоит из множества компонентов, которые взаимодействуют друг с другом через собственные API.</p><h2 id=изменения-в-api>Изменения в API</h2><p>Исходя из нашего опыта, любая успешная система должна улучшаться и изменяться по мере появления новых сценариев использования или изменения существующих. Поэтому мы надеемся, что и API Kubernetes будет постоянно меняться и расширяться. Однако в течение продолжительного периода времени мы будем поддерживать хорошую обратную совместимость с существующими клиентами. В целом, новые ресурсы API и поля ресурсов будут добавляться часто. Удаление ресурсов или полей регулируются <a href=/docs/reference/using-api/deprecation-policy/>соответствующим процессом</a>.</p><p>Определение совместимого изменения и методы изменения API подробно описаны в <a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api_changes.md>документе об изменениях API</a>.</p><h2 id=определения-openapi-и-swagger>Определения OpenAPI и Swagger</h2><p>Все детали API документируется с использованием <a href=https://www.openapis.org/>OpenAPI</a>.</p><p>Начиная с Kubernetes 1.10, API-сервер Kubernetes основывается на спецификации OpenAPI через конечную точку <code>/openapi/v2</code>.
Нужный формат устанавливается через HTTP-заголовки:</p><table><thead><tr><th>Заголовок</th><th>Возможные значения</th></tr></thead><tbody><tr><td>Accept</td><td><code>application/json</code>, <code>application/com.github.proto-openapi.spec.v2@v1.0+protobuf</code> (по умолчанию заголовок Content-Type установлен в <code>application/json</code> с <code>*/*</code>, допустимо также пропускать этот заголовок)</td></tr><tr><td>Accept-Encoding</td><td><code>gzip</code> (можно не передавать этот заголовок)</td></tr></tbody></table><p>До версии 1.14 конечные точки с форматом (<code>/swagger.json</code>, <code>/swagger-2.0.0.json</code>, <code>/swagger-2.0.0.pb-v1</code>, <code>/swagger-2.0.0.pb-v1.gz</code>) предоставляли спецификацию OpenAPI в разных форматах. Эти конечные точки были объявлены устаревшими и удалены в Kubernetes 1.14.</p><p><strong>Примеры получения спецификации OpenAPI</strong>:</p><table><thead><tr><th>До 1.10</th><th>С версии Kubernetes 1.10</th></tr></thead><tbody><tr><td>GET /swagger.json</td><td>GET /openapi/v2 <strong>Accept</strong>: application/json</td></tr><tr><td>GET /swagger-2.0.0.pb-v1</td><td>GET /openapi/v2 <strong>Accept</strong>: <a href=mailto:application/com.github.proto-openapi.spec.v2@v1.0>application/com.github.proto-openapi.spec.v2@v1.0</a>+protobuf</td></tr><tr><td>GET /swagger-2.0.0.pb-v1.gz</td><td>GET /openapi/v2 <strong>Accept</strong>: <a href=mailto:application/com.github.proto-openapi.spec.v2@v1.0>application/com.github.proto-openapi.spec.v2@v1.0</a>+protobuf <strong>Accept-Encoding</strong>: gzip</td></tr></tbody></table><p>В Kubernetes реализован альтернативный формат сериализации API, основанный на Protobuf, который в первую очередь предназначен для взаимодействия внутри кластера. Описание этого формата можно найти в <a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/protobuf.md>проектом решении</a>, а IDL-файлы по каждой схемы — в пакетах Go, определяющих API-объекты.</p><p>До версии 1.14 apiserver Kubernetes также представлял API, который можно использовать для получения спецификации <a href=http://swagger.io/>Swagger v1.2</a> для API Kubernetes по пути <code>/swaggerapi</code>. Эта конечная точка устарела и была удалена в Kubernetes 1.14</p><h2 id=версионирование-api>Версионирование API</h2><p>Чтобы упростить удаления полей или изменение ресурсов, Kubernetes поддерживает несколько версий API, каждая из которых доступна по собственному пути, например, <code>/api/v1</code> или <code>/apis/extensions/v1beta1</code>.</p><p>Мы выбрали версионирование API, а не конкретных ресурсов или полей, чтобы API отражал четкое и согласованное представление о системных ресурсах и их поведении, а также, чтобы разграничивать API, которые уже не поддерживаются и/или находятся в экспериментальной стадии. Схемы сериализации JSON и Protobuf следуют одним и тем же правилам по внесению изменений в схему, поэтому описание ниже охватывают оба эти формата.</p><p>Обратите внимание, что версионирование API и программное обеспечение косвенно связаны друг с другом. <a href=https://git.k8s.io/community/contributors/design-proposals/release/versioning.md>Предложение по версионированию API и новых выпусков</a> описывает, как связаны между собой версии API с версиями программного обеспечения.</p><p>Разные версии API характеризуются разными уровнями стабильности и поддержки. Критерии каждого уровня более подробно описаны в <a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api_changes.md#alpha-beta-and-stable-versions>документации изменений API</a>. Ниже приводится краткое изложение:</p><ul><li>Альфа-версии:<ul><li>Названия версий включают надпись <code>alpha</code> (например, <code>v1alpha1</code>).</li><li>Могут содержать баги. Включение такой функциональности может привести к ошибкам. По умолчанию она отключена.</li><li>Поддержка функциональности может быть прекращена в любое время без какого-либо оповещения об этом.</li><li>API может быть несовместим с более поздними версиями без упоминания об этом.</li><li>Рекомендуется для использования только в тестировочных кластерах с коротким жизненным циклом из-за высокого риска наличия багов и отсутствия долгосрочной поддержки.</li></ul></li><li>Бета-версии:<ul><li>Названия версий включают надпись <code>beta</code> (например, <code>v2beta3</code>).</li><li>Код хорошо протестирован. Активация этой функциональности — безопасно. Поэтому она включена по умолчанию.</li><li>Поддержка функциональности в целом не будет прекращена, хотя кое-что может измениться.</li><li>Схема и/или семантика объектов может стать несовместимой с более поздними бета-версиями или стабильными выпусками. Когда это случится, мы даем инструкции по миграции на следующую версию. Это обновление может включать удаление, редактирование и повторного создание API-объектов. Этот процесс может потребовать тщательного анализа. Кроме этого, это может привести к простою приложений, которые используют данную функциональность.</li><li>Рекомендуется только для неосновного производственного использования из-за риска возникновения возможных несовместимых изменений с будущими версиями. Если у вас есть несколько кластеров, которые возможно обновить независимо, вы можете снять это ограничение.</li><li><strong>Пожалуйста, попробуйте в действии бета-версии функциональности и поделитесь своими впечатлениями! После того как функциональность выйдет из бета-версии, нам может быть нецелесообразно что-то дальше изменять.</strong></li></ul></li><li>Стабильные версии:<ul><li>Имя версии <code>vX</code>, где <code>vX</code> — целое число.</li><li>Стабильные версии функциональностей появятся в новых версиях.</li></ul></li></ul><h2 id=api-группы>API-группы</h2><p>Чтобы упростить расширение API Kubernetes, реализованы <a href=https://git.k8s.io/community/contributors/design-proposals/api-machinery/api-group.md><em>группы API</em></a>.
Группа API указывается в пути REST и в поле <code>apiVersion</code> сериализованного объекта.</p><p>В настоящее время используется несколько API-групп:</p><ol><li><p>Группа <em>core</em>, которая часто упоминается как <em>устаревшая</em> (<em>legacy group</em>), доступна по пути <code>/api/v1</code> и использует <code>apiVersion: v1</code>.</p></li><li><p>Именованные группы находятся в пути REST <code>/apis/$GROUP_NAME/$VERSION</code> и используют <code>apiVersion: $GROUP_NAME/$VERSION</code> (например, <code>apiVersion: batch/v1</code>). Полный список поддерживаемых групп API можно увидеть в <a href=/ru/docs/reference/>справочнике API Kubernetes</a>.</p></li></ol><p>Есть два поддерживаемых пути к расширению API с помощью <a href=/docs/concepts/api-extension/custom-resources/>пользовательских ресурсов</a>:</p><ol><li><a href=/docs/tasks/access-kubernetes-api/extend-api-custom-resource-definitions/>CustomResourceDefinition</a> для пользователей, которым нужен очень простой CRUD.</li><li>Пользователи, которым нужна полная семантика API Kubernetes, могут реализовать собственный apiserver и использовать <a href=/docs/tasks/access-kubernetes-api/configure-aggregation-layer/>агрегатор</a> для эффективной интеграции для клиентов.</li></ol><h2 id=включение-или-отключение-групп-api>Включение или отключение групп API</h2><p>Некоторые ресурсы и группы API включены по умолчанию. Их можно включить или отключить, установив <code>--runtime-config</code> для apiserver. Флаг <code>--runtime-config</code> принимает значения через запятую. Например, чтобы отключить batch/v1, используйте <code>--runtime-config=batch/v1=false</code>, а чтобы включить batch/v2alpha1, используйте флаг <code>--runtime-config=batch/v2alpha1</code>.
Флаг набор пар ключ-значение, указанных через запятую, который описывает конфигурацию во время выполнения сервера.</p><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong> Включение или отключение групп или ресурсов требует перезапуска apiserver и controller-manager для применения изменений <code>--runtime-config</code>.</div><h2 id=включение-определённых-ресурсов-в-группу-extensions-v1beta1>Включение определённых ресурсов в группу extensions/v1beta1</h2><p>DaemonSets, Deployments, StatefulSet, NetworkPolicies, PodSecurityPolicies и ReplicaSets в API-группе <code>extensions/v1beta1</code> по умолчанию отключены.
Например: чтобы включить deployments и daemonsets, используйте флаг <code>--runtime-config=extensions/v1beta1/deployments=true,extensions/v1beta1/daemonsets=true</code>.</p><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong> Включение/отключение отдельных ресурсов поддерживается только в API-группе <code>extensions/v1beta1</code> по историческим причинам.</div></div><div class=td-content style=page-break-before:always><h1 id=pg-110f33530cf761140cb1dab536baef04>4 - Работа с объектами Kubernetes</h1></div><div class=td-content><h1 id=pg-9f5adfa77f48c50d5cc81155a3cecb98>4.1 - Изучение объектов Kubernetes</h1><p>На этой странице объясняется, как объекты Kubernetes представлены в API Kubernetes, и как их можно определить в формате <code>.yaml</code>.</p><h2 id=kubernetes-objects>Изучение объектов Kubernetes</h2><p><em>Объекты Kubernetes</em> — сущности, которые хранятся в Kubernetes. Kubernetes использует их для представления состояния кластера. В частности, они описывают следующую информацию:</p><ul><li>Какие контейнеризированные приложения запущены (и на каких узлах).</li><li>Доступные ресурсы для этих приложений.</li><li>Стратегии управления приложения, которые относятся, например, к перезапуску, обновлению или отказоустойчивости.</li></ul><p>После создания объекта Kubernetes будет следить за существованием объекта. Создавая объект, вы таким образом указываете системе Kubernetes, какой должна быть рабочая нагрузка кластера; это <em>требуемое состояние</em> кластера.</p><p>Для работы с объектами Kubernetes – будь то создание, изменение или удаление — нужно использовать <a href=/docs/concepts/overview/kubernetes-api/>API Kubernetes</a>. Например, при использовании CLI-инструмента <code>kubectl</code>, он обращается к API Kubernetes. С помощью одной из <a href=/docs/reference/using-api/client-libraries/>клиентской библиотеки</a> вы также можете использовать API Kubernetes в собственных программах.</p><h3 id=спецификация-и-статус-объекта>Спецификация и статус объекта</h3><p>Почти в каждом объекте Kubernetes есть два вложенных поля-объекта, которые управляют конфигурацией объекта: <em><code>spec</code></em> и <em><code>status</code></em>.
При создании объекта в поле <code>spec</code> указывается <em>требуемое состояние</em> (описание характеристик, которые должны быть у объекта).</p><p>Поле <code>status</code> описывает <em>текущее состояние</em> объекта, которое создаётся и обновляется самим Kubernetes и его компонентами. <a class=glossary-tooltip title='Уровень оркестрации контейнеров с API и интерфейсами для определения, развёртывания и управления жизненным циклом контейнеров.' data-toggle=tooltip data-placement=top href='/ru/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='Плоскость управления'>Плоскость управления</a> Kubernetes непрерывно управляет фактическим состоянием каждого объекта, чтобы оно соответствовало требуемому состоянию, которое было задано пользователем.</p><p>Например: Deployment — это объект Kubernetes, представляющий работающее приложение в кластере. При создании объекта Deployment вы можете указать в его поле <code>spec</code>, что хотите иметь три реплики приложения. Система Kubernetes получит спецификацию объекта Deployment и запустит три экземпляра приложения, таким образом обновит статус (состояние) объекта, чтобы он соответствовал заданной спецификации. В случае сбоя одного из экземпляров (это влечет за собой изменение состояние), Kubernetes обнаружит несоответствие между спецификацией и статусом и исправит его, т.е. активирует новый экземпляр вместо того, который вышел из строя.</p><p>Для получения дополнительной информации о спецификации объекта, статусе и метаданных смотрите документ с <a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md>соглашениями API Kubernetes</a>.</p><h3 id=описание-объекта-kubernetes>Описание объекта Kubernetes</h3><p>При создании объекта в Kubernetes нужно передать спецификацию объекта, которая содержит требуемое состояние, а также основную информацию об объекте (например, его имя). Когда вы используете API Kubernetes для создания объекта (напрямую либо через <code>kubectl</code>), соответствующий API-запрос должен включать в теле запроса всю указанную информацию в JSON-формате. <strong>В большинстве случаев вы будете передавать <code>kubectl</code> эти данные, записанные в файле .yaml</strong>. Тогда инструмент <code>kubectl</code> преобразует их в формат JSON при выполнении запроса к API.</p><p>Ниже представлен пример <code>.yaml</code>-файла, в котором заданы обязательные поля и спецификация объекта, необходимая для объекта Deployment в Kubernetes:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ru/examples/application/deployment.yaml download=application/deployment.yaml><code>application/deployment.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("application-deployment-yaml")' title="Copy application/deployment.yaml to clipboard"></img></div><div class=includecode id=application-deployment-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb> </span><span style=color:#080;font-style:italic># до версии 1.9.0 нужно использовать apps/v1beta2</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># запускает 2 пода, созданных по шаблону</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Один из способов создания объекта Deployment с помощью файла <code>.yaml</code>, показанного выше — использовать команду <a href=/docs/reference/generated/kubectl/kubectl-commands#apply><code>kubectl apply</code></a>, которая принимает в качестве аргумента файл в формате <code>.yaml</code>. Например:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/application/deployment.yaml --record
</span></span></code></pre></div><p>Вывод будет примерно таким:</p><pre tabindex=0><code>deployment.apps/nginx-deployment created
</code></pre><h3 id=обязательные-поля>Обязательные поля</h3><p>В файле <code>.yaml</code> создаваемого объекта Kubernetes необходимо указать значения для следующих полей:</p><ul><li><code>apiVersion</code> — используемая для создания объекта версия API Kubernetes</li><li><code>kind</code> — тип создаваемого объекта</li><li><code>metadata</code> — данные, позволяющие идентифицировать объект (<code>name</code>, <code>UID</code> и необязательное поле <code>namespace</code>)</li><li><code>spec</code> — требуемое состояние объекта</li></ul><p>Конкретный формат поля-объекта <code>spec</code> зависит от типа объекта Kubernetes и содержит вложенные поля, предназначенные только для используемого объекта. В <a href=/docs/reference/generated/kubernetes-api/v1.25/>справочнике API Kubernetes</a> можно найти формат спецификации любого объекта Kubernetes.
Например, формат <code>spec</code> для объекта Pod находится в <a href=/docs/reference/generated/kubernetes-api/v1.25/#podspec-v1-core>ядре PodSpec v1</a>, а формат <code>spec</code> для Deployment — в <a href=/docs/reference/generated/kubernetes-api/v1.25/#deploymentspec-v1-apps>DeploymentSpec v1 apps</a>.</p><h2 id=что-дальше>Что дальше</h2><ul><li><a href=/docs/reference/using-api/api-overview/>Обзор API Kubernetes</a> более подробно объясняет некоторые из API-концепций</li><li>Познакомиться с наиболее важными и основными объектами в Kubernetes, например, с <a href=/docs/concepts/workloads/pods/pod-overview/>подами</a>.</li><li>Узнать подробнее про <a href=/docs/concepts/architecture/controller/>контролеры</a> в Kubernetes</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-6751db8ff5409476de8225d17d6c42dd>4.2 - Управление объектами Kubernetes</h1><p>В инструменте командной строки <code>kubectl</code> есть несколько разных способов создания и управления объектами Kubernetes. На этой странице рассматриваются различные подходы. Изучите <a href=https://kubectl.docs.kubernetes.io>документацию по Kubectl</a> для получения подробной информации по управлению объектами с помощью Kubectl.</p><h2 id=способы-управления>Способы управления</h2><div class="alert alert-danger warning callout" role=alert><strong>Предупреждение:</strong> Используйте только один способ для управления объектами Kubernetes. Применение нескольких методов управления к одному и тому же объекту может привести к неопределенному поведению.</div><table><thead><tr><th>Способ управления</th><th>Область применения</th><th>Рекомендуемое окружение</th><th>Количество поддерживаемых авторов</th><th>Трудность изучения</th></tr></thead><tbody><tr><td>Императивные команды</td><td>Активные объекты</td><td>Проекты в стадии разработки</td><td>1+</td><td>Низкая</td></tr><tr><td>Императивная конфигурация объекта</td><td>Отдельные файлы</td><td>Продакшен-проекты</td><td>1</td><td>Средняя</td></tr><tr><td>Декларативная конфигурация объекта</td><td>Директории или файлы</td><td>Продакшен-проекты</td><td>1+</td><td>Сложная</td></tr></tbody></table><h2 id=императивные-команды>Императивные команды</h2><p>При использовании императивных команд пользователь работает непосредственно с активными (текущими) объектами в кластере. Пользователь указывает выполняемые операции команде <code>kubectl</code> в качестве аргументов или флагов.</p><p>Это самый простой способ начать или выполнять одноразовые задачи в кластере. Из-за того, что происходит работа с активными объектами напрямую, нет возможности посмотреть историю предыдущих конфигураций.</p><h3 id=примеры>Примеры</h3><p>Запустите экземпляр контейнера nginx, посредством создания объекта Deployment:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl run nginx --image nginx
</span></span></code></pre></div><p>То же самое, но с другим синтаксисом:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl create deployment nginx --image nginx
</span></span></code></pre></div><h3 id=плюсы-и-минусы>Плюсы и минусы</h3><p>Преимущества по сравнению с конфигурацией объекта:</p><ul><li>Простые команды, которые легко выучить и запомнить.</li><li>Для применения изменений в кластер нужно только выполнить команды.</li></ul><p>Недостатки по сравнению с конфигурацией объекта:</p><ul><li>Команды не интегрированы с процессом проверки (обзора) изменений.</li><li>У команд нет журнала с изменениями.</li><li>Команды не дают источник записей, за исключением активных объектов.</li><li>Команды не содержат шаблон для создания новых объектов.</li></ul><h2 id=императивная-конфигурация-объекта>Императивная конфигурация объекта</h2><p>В случае использования императивной конфигурации объекта команде kubectl устанавливают действие (создание, замена и т.д.), необязательные флаги и как минимум одно имя файла. Файл должен содержать полное определение объекта в формате YAML или JSON.</p><p>Посмотрите <a href=/docs/reference/generated/kubernetes-api/v1.25/>Справочник API</a> для получения более подробной информации про определения объекта.</p><div class="alert alert-danger warning callout" role=alert><strong>Предупреждение:</strong> Императивная команда <code>replace</code> заменяет существующую спецификацию новой (переданной), удаляя все изменения в объекте, которые не определены в конфигурационном файле. Такой подход не следует использовать для типов ресурсов, спецификации которых обновляются независимо от конфигурационного файла.
Например, поле <code>externalIPs</code> в сервисах типа <code>LoadBalancer</code> обновляется кластером независимо от конфигурации.</div><h3 id=примеры-1>Примеры</h3><p>Создать объекты, определенные в конфигурационном файле:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl create -f nginx.yaml
</span></span></code></pre></div><p>Удалить объекты, определенные в двух конфигурационных файлах:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl delete -f nginx.yaml -f redis.yaml
</span></span></code></pre></div><p>Обновить объекты, определенные в конфигурационном файле, перезаписав текущую конфигурацию:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl replace -f nginx.yaml
</span></span></code></pre></div><h3 id=плюсы-и-минусы-1>Плюсы и минусы</h3><p>Преимущества по сравнению с императивными командами:</p><ul><li>Конфигурация объекта может храниться в системе управления версиями, такой как Git.</li><li>Конфигурация объекта может быть интегрирована с процессами проверки изменений и логирования.</li><li>Конфигурация объекта предусматривает шаблон для создания новых объектов.</li></ul><p>Недостатки по сравнению с императивными командами:</p><ul><li>Конфигурация объекта требует наличие общего представления об схеме объекта.</li><li>Конфигурация объекта предусматривает написание файла YAML.</li></ul><p>Преимущества по сравнению с декларативной конфигурацией объекта:</p><ul><li>Императивная конфигурация объекта проще и легче для понимания.</li><li>Начиная с Kubernetes 1.5, конфигурация императивных объектов стала лучше и совершеннее.</li></ul><p>Недостатки по сравнению с декларативной конфигурацией объекта:</p><ul><li>Императивная конфигурация объекта наилучшим образом работает с файлами, а не с директориями.</li><li>Обновления текущих объектов должны быть описаны в файлах конфигурации, в противном случае они будут потеряны при следующей замене.</li></ul><h2 id=декларативная-конфигурация-объекта>Декларативная конфигурация объекта</h2><p>При использовании декларативной конфигурации объекта пользователь работает с локальными конфигурационными файлами объекта, при этом он не определяет операции, которые будут выполняться над этими файлами. Операции создания, обновления и удаления автоматически для каждого объекта определяются <code>kubectl</code>. Этот механизм позволяет работать с директориями, в ситуациях, когда для разных объектов может потребоваться выполнение других операций.</p><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong> Декларативная конфигурация объекта сохраняет изменения, сделанные другими, даже если эти изменения не будут зафиксированы снова в конфигурационный файл объекта.
Это достигается путем использования API-операции <code>patch</code>, чтобы записать только обнаруженные изменения, а не использовать для этого API-операцию <code>replace</code>, которая полностью заменяет конфигурацию объекта.</div><h3 id=примеры-2>Примеры</h3><p>Обработать все конфигурационные файлы объектов в директории <code>configs</code> и создать либо частично обновить активные объекты. Сначала можно выполнить <code>diff</code>, чтобы посмотреть, какие изменения будут внесены, и только после этого применить их:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl diff -f configs/
</span></span><span style=display:flex><span>kubectl apply -f configs/
</span></span></code></pre></div><p>Рекурсивная обработка директорий:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl diff -R -f configs/
</span></span><span style=display:flex><span>kubectl apply -R -f configs/
</span></span></code></pre></div><h3 id=плюсы-и-минусы-2>Плюсы и минусы</h3><p>Преимущества по сравнению с императивной конфигурацией объекта:</p><ul><li>Изменения, внесенные непосредственно в активные объекты, будут сохранены, даже если они не отражены в конфигурационных файлах.</li><li>Декларативная конфигурация объекта лучше работает с директориями и автоматически определяет тип операции (создание, частичное обновление, удаление) каждого объекта.</li></ul><p>Недостатки по сравнению с императивной конфигурацией объекта:</p><ul><li>Декларативную конфигурацию объекта сложнее отладить и понять, когда можно получить неожиданные результаты.</li><li>Частичные обновления с использованием различий приводит к сложным операциям слияния и исправления.</li></ul><h2 id=что-дальше>Что дальше</h2><ul><li><a href=/docs/tasks/manage-kubernetes-objects/imperative-command/>Управление объектами Kubernetes с помощью императивных команд</a></li><li><a href=/docs/tasks/manage-kubernetes-objects/imperative-config/>Управление объектами Kubernetes с помощью императивной конфигурации объекта</a></li><li><a href=/docs/tasks/manage-kubernetes-objects/declarative-config/>Управление объектами Kubernetes с помощью декларативной конфигурации объекта</a></li><li><a href=/docs/tasks/manage-kubernetes-objects/kustomization/>Управление объектами Kubernetes с помощью Kustomize (декларативный способ)</a></li><li><a href=/docs/reference/generated/kubectl/kubectl-commands/>Справочник по командам Kubectl</a></li><li><a href=https://kubectl.docs.kubernetes.io>Документация Kubectl</a></li><li><a href=/docs/reference/generated/kubernetes-api/v1.25/>Справочник API Kubernetes</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-f37749a83c2916b63279ea60f3cfe53e>4.3 - Имена и идентификаторы объектов</h1><p>Каждый объект в кластере имеет уникальное <a href=#%D0%B8%D0%BC%D0%B5%D0%BD%D0%B0><em>имя</em></a> для конкретного типа ресурса.
Кроме этого, у каждого объекта Kubernetes есть собственный <a href=#%D0%B8%D0%B4%D0%B5%D0%BD%D1%82%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%82%D0%BE%D1%80%D1%8B><em>уникальный идентификатор (UID)</em></a> в пределах кластера.</p><p>Например, в одном и том же <a href=/ru/docs/concepts/overview/working-with-objects/namespaces/>пространстве имён</a> может быть только один Pod-объект с именем <code>myapp-1234</code>, и при этом существовать объект Deployment с этим же названием <code>myapp-1234</code>.</p><p>Для создания пользовательских неуникальных атрибутов у Kubernetes есть <a href=/ru/docs/concepts/overview/working-with-objects/labels/>метки</a> и <a href=/ru/docs/concepts/overview/working-with-objects/annotations/>аннотации</a>.</p><h2 id=имена>Имена</h2><p>Клиентская строка, предназначенная для ссылки на объект в URL-адресе ресурса, например <code>/api/v1/pods/some-name</code>.</p><p>Указанное имя может иметь только один объект определённого типа. Но если вы удалите этот объект, вы можете создать новый с таким же именем</p><p>Ниже перечислены три типа распространённых требований к именам ресурсов.</p><h3 id=имена-поддоменов-dns>Имена поддоменов DNS</h3><p>Большинству типов ресурсов нужно указать имя, используемое в качестве имени поддомена DNS в соответствии с <a href=https://tools.ietf.org/html/rfc1123>RFC 1123</a>. Соответственно, имя должно:</p><ul><li>содержать не более 253 символов</li><li>иметь только строчные буквенно-цифровые символы, '-' или '.'</li><li>начинаться с буквенно-цифрового символа</li><li>заканчивается буквенно-цифровым символом</li></ul><h3 id=имена-меток-dns>Имена меток DNS</h3><p>Некоторые типы ресурсов должны соответствовать стандарту меток DNS, который описан в <a href=https://tools.ietf.org/html/rfc1123>RFC 1123</a>. Таким образом, имя должно:</p><ul><li>содержать не более 63 символов</li><li>содержать только строчные буквенно-цифровые символы или '-'</li><li>начинаться с буквенно-цифрового символа</li><li>заканчивается буквенно-цифровым символом</li></ul><h3 id=имена-сегментов-пути>Имена сегментов пути</h3><p>Определённые имена типов ресурсов должны быть закодированы для использования в качестве сегмента пути. Проще говоря, имя не может быть "." или "..", а также не может содержать "/" или "%".</p><p>Пример файла манифеста пода <code>nginx-demo</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong> У отдельных типов ресурсов есть дополнительные ограничения именования.</div><h2 id=уникальные-идентификаторы>Уникальные идентификаторы</h2><p>Уникальная строка, сгенерированная самим Kubernetes, для идентификации объектов.</p><p>У каждого объекта, созданного в течение всего периода работы кластера Kubernetes, есть собственный уникальный идентификатор (UID). Он предназначен для выяснения различий между событиями похожих сущностей.</p><p>Уникальные идентификатор (UID) в Kubernetes — это универсальные уникальные идентификаторы (известные также как Universally Unique IDentifier, сокращенно UUID).
Эти идентификаторы стандартизированы под названием ISO/IEC 9834-8, а также как ITU-T X.667.</p><h2 id=что-дальше>Что дальше</h2><ul><li>Узнать подробнее про <a href=/ru/docs/concepts/overview/working-with-objects/labels/>метки</a> в Kubernetes.</li><li>Посмотреть архитектуру <a href=https://git.k8s.io/community/contributors/design-proposals/architecture/identifiers.md>идентификаторов и имён Kubernetes</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-1127165f472b7181b9c1d5a0b187d620>4.4 - Пространства имён</h1><p>Kubernetes поддерживает несколько виртуальных кластеров в одном физическом кластере. Такие виртуальные кластеры называются пространствами имён.</p><h2 id=причины-использования-нескольких-пространств-имён>Причины использования нескольких пространств имён</h2><p>Пространства имён применяются в окружениях с многочисленными пользователями, распределенными по нескольким командам или проектам. Пространства имён не нужно создавать, если есть кластеры с небольшим количеством пользователей (например, десяток пользователей). Пространства имён имеет смысл использовать, когда необходима такая функциональность.</p><p>Пространства имён определяют область имён. Имена ресурсов должны быть уникальными в пределах одного и того же пространства имён. Пространства имён не могут быть вложенными, а каждый ресурс Kubernetes может находиться только в одном пространстве имён.</p><p>Пространства имён — это способ разделения ресурсов кластера между несколькими пользователями (с помощью <a href=/docs/concepts/policy/resource-quotas/>квоты ресурсов</a>).</p><p>По умолчанию в будущих версиях Kubernetes объекты в одном и том же пространстве имён будут иметь одинаковую политику контроля доступа.</p><p>Не нужно использовать пространства имён только для разделения слегка отличающихся ресурсов, например, в случае разных версий одного и того же приложения. Используйте <a href=/ru/docs/concepts/overview/working-with-objects/labels/>метки</a>, чтобы различать ресурсы в рамках одного пространства имён.</p><h2 id=использование-пространств-имён>Использование пространств имён</h2><p>Создание и удаление пространств имён описаны в <a href=/docs/admin/namespaces>руководстве администратора по пространствам имён</a>.</p><h3 id=просмотр-пространств-имён>Просмотр пространств имён</h3><p>Используйте следующую команду, чтобы вывести список существующих пространств имён в кластере:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get namespace
</span></span></code></pre></div><pre tabindex=0><code>NAME          STATUS    AGE
default       Active    1d
kube-system   Active    1d
kube-public   Active    1d
</code></pre><p>По умолчанию в Kubernetes определены три пространства имён:</p><ul><li><code>default</code> — пространство имён по умолчанию для объектов без какого-либо другого пространства имён.</li><li><code>kube-system</code> — пространство имён для объектов, созданных Kubernetes</li><li><code>kube-public</code> — создаваемое автоматически пространство имён, которое доступно для чтения всем пользователям (включая также неаутентифицированных пользователей). Как правило, это пространство имён используется кластером, если некоторые ресурсы должны быть общедоступными для всего кластера. Главная особенность этого пространства имён — оно всего лишь соглашение, а не требование.</li></ul><h3 id=определение-пространства-имён-для-отдельных-команд>Определение пространства имён для отдельных команд</h3><p>Используйте флаг <code>--namespace</code>, чтобы определить пространство имён только для текущего запроса.</p><p>Примеры:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl run nginx --image<span style=color:#666>=</span>nginx --namespace<span style=color:#666>=</span>&lt;insert-namespace-name-here&gt;
</span></span><span style=display:flex><span>kubectl get pods --namespace<span style=color:#666>=</span>&lt;insert-namespace-name-here&gt;
</span></span></code></pre></div><h3 id=определение-пространства-имён-для-всех-команд>Определение пространства имён для всех команд</h3><p>Можно определить пространство имён, которое должно использоваться для всех выполняемых команд kubectl в текущем контексте.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config set-context --current --namespace<span style=color:#666>=</span>&lt;insert-namespace-name-here&gt;
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Проверка</span>
</span></span><span style=display:flex><span>kubectl config view --minify | grep namespace:
</span></span></code></pre></div><h2 id=пространства-имён-и-dns>Пространства имён и DNS</h2><p>При создании <a href=/docs/user-guide/services>сервиса</a> создаётся соответствующая ему <a href=/docs/concepts/services-networking/dns-pod-service/>DNS-запись</a>.
Эта запись вида <code>&lt;service-name>.&lt;namespace-name>.svc.cluster.local</code> означает, что если контейнер использует только <code>&lt;service-name></code>, то он будет локальным сервисом в пространстве имён. Это позволит применять одну и ту же конфигурацию в нескольких пространствах имен (например, development, staging и production). Если нужно обращаться к другим пространствам имён, то нужно использовать полностью определенное имя домена (FQDN).</p><h2 id=объекты-без-пространства-имён>Объекты без пространства имён</h2><p>Большинство ресурсов Kubernetes (например, поды, сервисы, контроллеры репликации и другие) расположены в определённых пространствах имён. При этом сами ресурсы пространства имён не находятся ни в других пространствах имён. А такие низкоуровневые ресурсы, как <a href=/docs/admin/node>узлы</a> и persistentVolumes, не принадлежат ни одному пространству имён.</p><p>Чтобы посмотреть, какие ресурсы Kubernetes находятся в пространстве имён, а какие — нет, используйте следующие команды:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Ресурсы в пространстве имён</span>
</span></span><span style=display:flex><span>kubectl api-resources --namespaced<span style=color:#666>=</span><span style=color:#a2f>true</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Ресурсы, не принадлежавшие ни одному пространству имён</span>
</span></span><span style=display:flex><span>kubectl api-resources --namespaced<span style=color:#666>=</span><span style=color:#a2f>false</span>
</span></span></code></pre></div><h2 id=что-дальше>Что дальше</h2><ul><li>Узнать подробнее про <a href=/docs/tasks/administer-cluster/namespaces/#creating-a-new-namespace>создание нового пространства имён</a>.</li><li>Узнать подробнее про <a href=/docs/tasks/administer-cluster/namespaces/#deleting-a-namespace>удаление пространства имён</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-f1dec4557fb8ffbac9f11390aaaf9fa4>4.5 - Метки и селекторы</h1><p><em>Метки</em> — это пары ключ-значение, которые добавляются к объектам, как поды.
Метки предназначены для идентификации атрибутов объектов, которые имеют значимость и важны для пользователей, но при этом не относятся напрямую к основной системе.
Метки можно использовать для группировки и выбора подмножеств объектов. Метки могут быть добавлены к объектам во время создания и изменены в любое время после этого.
Каждый объект может иметь набор меток в виде пары ключ-значение. Каждый ключ должен быть уникальным в рамках одного и того же объекта.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#b44>&#34;metadata&#34;</span><span>:</span> {
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;labels&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;key1&#34;</span> : <span style=color:#b44>&#34;value1&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;key2&#34;</span> : <span style=color:#b44>&#34;value2&#34;</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Метки используются при получении и отслеживании объектов и в веб-панелях и CLI-инструментах. Любая неидентифицирующая информация должна быть записана в <a href=/ru/docs/concepts/overview/working-with-objects/annotations/>аннотации</a>.</p><h2 id=причины-использования>Причины использования</h2><p>Метки позволяют пользователям гибко сопоставить их организационные структуры с системными объектами, не требуя от клиентов хранить эти соответствия.</p><p>Развертывания сервисов и процессы пакетной обработки часто являются многомерными сущностями (например, множество разделов или развертываний, несколько групп выпусков, несколько уровней приложения, несколько микросервисов на каждый уровень приложения). Для управления часто требуются сквозные операции, которые нарушают инкапсуляцию строго иерархических представлений, особенно жестких иерархий, определяемых инфраструктурой, а не пользователями.</p><p>Примеры меток:</p><ul><li><code>"release" : "stable"</code>, <code>"release" : "canary"</code></li><li><code>"environment" : "dev"</code>, <code>"environment" : "qa"</code>, <code>"environment" : "production"</code></li><li><code>"tier" : "frontend"</code>, <code>"tier" : "backend"</code>, <code>"tier" : "cache"</code></li><li><code>"partition" : "customerA"</code>, <code>"partition" : "customerB"</code></li><li><code>"track" : "daily"</code>, <code>"track" : "weekly"</code></li></ul><p>Это всего лишь примеры часто используемых меток; конечно, вы можете использовать свои собственные. Помните о том, что ключ метки должна быть уникальной в пределах одного объекта.</p><h2 id=синтаксис-и-набор-символов>Синтаксис и набор символов</h2><p><em>Метки</em> представляют собой пары ключ-значение. Разрешенные ключи метки имеют два сегмента, разделённые слешем (<code>/</code>): префикс (необязательно) и имя. Сегмент имени обязателен и должен содержать не более 63 символов, среди которых могут быть буквенно-цифровые символы (<code>[a-z0-9A-Z]</code>), а также дефисы (<code>-</code>), знаки подчеркивания (<code>_</code>), точки (<code>.</code>). Префикс не обязателен, но он быть поддоменом DNS: набор меток DNS, разделенных точками (<code>.</code>), общей длиной не более 253 символов, за которыми следует слеш (<code>/</code>).</p><p>Если префикс не указан, ключ метки считается закрытым для пользователя. Компоненты автоматизированной системы (например, <code>kube-scheduler</code>, <code>kube-controller-manager</code>, <code>kube-apiserver</code>, <code>kubectl</code> или другие сторонние), которые добавляют метки к объектам пользователя, должны указывать префикс.</p><p>Префиксы <code>kubernetes.io/</code> и <code>k8s.io/</code> зарезервированы для использования основными компонентами Kubernetes.</p><p>Например, ниже представлен конфигурационный файл объекта Pod с двумя метками <code>environment: production</code> и <code>app: nginx</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>label-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>environment</span>:<span style=color:#bbb> </span>production<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=селекторы-меток>Селекторы меток</h2><p>В отличие от <a href=/docs/user-guide/identifiers>имен и идентификаторов</a>, метки не гарантируют уникальность. Поэтому мы предполагаем, что многие объекты будут иметь одинаковые метки.</p><p>С помощью <em>селектора меток</em> клиент/пользователь может идентифицировать набор объектов. Селектор меток — основное средство группировки в Kubernetes.</p><p>В настоящее время API поддерживает два типа селекторов: <em>на равенстве</em> и <em>на наборе</em>.
Селектор меток может состоять из нескольких <em>условий</em>, разделенных запятыми. В таком случае все условия должны быть выполнены, поэтому запятая-разделитель работает как логический оператор <em>И</em> (<code>&&</code>).</p><p>Работа пустых или неопределённых селекторов зависит от контекста. Типы API, которые использует селекторы, должны задокументировать это поведение.</p><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong> Для некоторых API-типов, например, ReplicaSets, селекторы меток двух экземпляров не должны дублироваться в пространстве имен, в противном случае контроллер может рассматривать их как конфликтующие инструкции и не сможет определить количество реплик.</div><div class="alert alert-warning caution callout" role=alert><strong>Внимание:</strong> Как для условий, основанных на равенстве, так и для условий на основе набора, не существует логического оператора <em>ИЛИ</em> (<code>||</code>). Убедитесь, что синтаксис фильтрации правильно составлен.</div><h3 id=условие-равенства>Условие <em>равенства</em></h3><p>Условия <em>равенства</em> или <em>неравенства</em> позволяют отфильтровать объекты по ключам и значениям меток. Сопоставляемые объекты должны удовлетворять всем указанным условиям меток, хотя при этом у объектов также могут быть заданы другие метки.
Доступны три оператора: <code>=</code>,<code>==</code>,<code>!=</code>. Первые два означают <em>равенство</em> (и являются всего лишь синонимами), а последний оператор определяет <em>неравенство</em>. Например:</p><pre tabindex=0><code>environment = production
tier != frontend
</code></pre><p>Первый пример выбирает все ресурсы с ключом <code>environment</code>, у которого значение указано <code>production</code>.
Последний получает все ресурсы с ключом <code>tier</code> без значения <code>frontend</code>, а также все ресурсы, в которых нет метки с ключом <code>tier</code>.
Используя оператор запятой можно совместить показанные два условия в одно, запросив ресурсы, в которых есть значение метки <code>production</code> и исключить <code>frontend</code>: <code>environment=production,tier!=frontend</code>.</p><p>С помощью условия равенства в объектах Pod можно указать, какие нужно выбрать ресурсы. Например, в примере ниже объект Pod выбирает узлы с меткой "<code>accelerator=nvidia-tesla-p100</code>".</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cuda-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cuda-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;k8s.gcr.io/cuda-vector-add:v0.1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>nvidia.com/gpu</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodeSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>accelerator</span>:<span style=color:#bbb> </span>nvidia-tesla-p100<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=условие-набора>Условие <em>набора</em></h3><p>Условие меток <em>на основе набора</em> фильтрует ключи в соответствии с набором значений. Поддерживаются три вида операторов: <code>in</code>, <code>notin</code> и <code>exists</code> (только идентификатор ключа). Например:</p><pre tabindex=0><code>environment in (production, qa)
tier notin (frontend, backend)
partition
!partition
</code></pre><p>В первом примере выбираются все ресурсы с ключом <code>environment</code> и значением <code>production</code> или <code>qa</code>.
Во втором примере выбираются все ресурсы с ключом <code>tier</code> и любыми значениями, кроме <code>frontend</code> и <code>backend</code>, а также все ресурсы без меток с ключом <code>tier</code>.
Третий пример выбирает все ресурсы, включая метку с ключом <code>partition</code> (с любым значением).
В четвертом примере выбираются все ресурсы без метки с ключом <code>partition</code> (с любым значением).
Как и логический оператор <em>И</em> работает разделитель в виде запятой. Таким образом, фильтрация ресурсов по ключу <code>partition</code> (вне зависимости от значения) и ключу <code>environment</code> с любым значением, кроме <code>qa</code>, можно получить с помощью следующего выражения: <code>partition,environment notin (qa)</code>.
Селектор меток <em>на основе набора</em> — основная форма равенства, поскольку <code>environment=production</code> то же самое, что и <code>environment in (production)</code>; аналогично, оператор <code>!=</code> соответствует <code>notin</code>.</p><p>Условия <em>набора</em> могут использоваться одновременно с условия <em>равенства</em>. Например, так: <code>partition in (customerA, customerB),environment!=qa</code>.</p><h2 id=api>API</h2><h3 id=фильтрация-list-и-watch>Фильтрация LIST и WATCH</h3><p>Операции LIST и WATCH могут использовать параметр запроса, чтобы указать селекторы меток фильтрации наборов объектов. Есть поддержка обоих условий (строка запроса URL ниже показывается в исходном виде):</p><ul><li>Условия <em>на основе равенства</em>: <code>?labelSelector=environment%3Dproduction,tier%3Dfrontend</code></li><li>Условия <em>на основе набора</em>: <code>?labelSelector=environment+in+%28production%2Cqa%29%2Ctier+in+%28frontend%29</code></li></ul><p>Указанные выше формы селектора меток можно использовать для просмотра или отслеживания ресурсов через REST-клиент. Например, <code>apiserver</code> с <code>kubectl</code>, который использует <em>условие равенства</em>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l <span style=color:#b8860b>environment</span><span style=color:#666>=</span>production,tier<span style=color:#666>=</span>frontend
</span></span></code></pre></div><p>Либо используя условия <em>на основе набора</em>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l <span style=color:#b44>&#39;environment in (production),tier in (frontend)&#39;</span>
</span></span></code></pre></div><p>Как уже показывалось, <em>условия набора</em> дают больше возможностей. Например, в них можно использовать подобие оператора <em>И</em>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l <span style=color:#b44>&#39;environment in (production, qa)&#39;</span>
</span></span></code></pre></div><p>Либо можно воспользоваться исключающим сопоставлением с помощью оператора <em>exists</em>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l <span style=color:#b44>&#39;environment,environment notin (frontend)&#39;</span>
</span></span></code></pre></div><h3 id=установка-ссылок-в-api-объекты>Установка ссылок в API-объекты</h3><p>Некоторые объекты Kubernetes, такие как <a href=/docs/user-guide/services><code>services</code></a> и <a href=/docs/user-guide/replication-controller><code>replicationcontrollers</code></a>, также используют селекторы меток для ссылки на наборы из других ресурсов, например, <a href=/docs/user-guide/pods>подов</a>.</p><h4 id=service-и-replicationcontroller>Service и ReplicationController</h4><p>Набор подов, на которые указывает <code>service</code>, определяется через селектор меток. Аналогичным образом, количество подов, которыми должен управлять <code>replicationcontroller</code>, также формируются с использованием селектора меток.</p><p>Селекторы меток для обоих объектов записываются в словарях файлов формата <code>json</code> и <code>yaml</code>, при этом поддерживаются только селекторы с условием <em>равенства</em>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#b44>&#34;selector&#34;</span><span>:</span> {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;component&#34;</span> : <span style=color:#b44>&#34;redis&#34;</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Или:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>component</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span></code></pre></div><p>Этот селектор (как в формате <code>json</code>, так и в <code>yaml</code>) эквивалентен <code>component=redis</code> или <code>component in (redis)</code>.</p><h4 id=ресурсы-поддерживающие-условия-набора>Ресурсы, поддерживающие условия набора</h4><p>Новые ресурсы, такие как <a href=/docs/concepts/workloads/controllers/jobs-run-to-completion/><code>Job</code></a>, <a href=/docs/concepts/workloads/controllers/deployment/><code>Deployment</code></a>, <a href=/docs/concepts/workloads/controllers/replicaset/><code>ReplicaSet</code></a> и <a href=/docs/concepts/workloads/controllers/daemonset/><code>DaemonSet</code></a>, также поддерживают условия <em>набора</em>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>component</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- {<span style=color:green;font-weight:700>key: tier, operator: In, values</span>:<span style=color:#bbb> </span>[cache]}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- {<span style=color:green;font-weight:700>key: environment, operator: NotIn, values</span>:<span style=color:#bbb> </span>[dev]}<span style=color:#bbb>
</span></span></span></code></pre></div><p><code>matchLabels</code> — словарь пар <code>{key,value}</code>. Каждая пара <code>{key,value}</code> в словаре <code>matchLabels</code> эквивалентна элементу <code>matchExpressions</code>, где поле <code>key</code> — "key", поле <code>operator</code> — "In", а массив <code>values</code> содержит только "value".
<code>matchExpressions</code> представляет собой список условий селектора пода. В качестве операторов могут быть In, NotIn, Exists и DoesNotExist. В случае использования In и NotIn должны заданы непустые значения. Все условия, как для <code>matchLabels</code>, так и для <code>matchExpressions</code>, объединяются с помощью логического И, поэтому при выборке объектов все они должны быть выполнены.</p><h4 id=выбор-наборов-узлов>Выбор наборов узлов</h4><p>Один из вариантов использования меток — возможность выбора набора узлов, в которых может быть развернут под.
Смотрите документацию про <a href=/docs/concepts/configuration/assign-pod-node/>выбор узлов</a>, чтобы получить дополнительную информацию.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-93cd7a1d4e1623e2bf01afc49a5af69c>4.6 - Аннотации</h1><p>Аннотации Kubernetes можно использовать для добавления собственных метаданных к объектам. Такие клиенты, как инструменты и библиотеки, могут получить эти метаданные.</p><h2 id=добавление-метаданных-к-объектам>Добавление метаданных к объектам</h2><p>Вы можете использовать метки или аннотации для добавления метаданных к объектам Kubernetes. Метки можно использовать для выбора объектов и для поиска коллекций объектов, которые соответствуют определенным условиям. В отличие от них аннотации не используются для идентификации и выбора объектов. Метаданные в аннотации могут быть маленькими или большими, структурированными или неструктурированными, кроме этого они включать символы, которые не разрешены в метках.</p><p>Аннотации, как и метки, являются коллекциями с наборами пар ключ-значение:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#b44>&#34;metadata&#34;</span><span>:</span> {
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;annotations&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;key1&#34;</span> : <span style=color:#b44>&#34;value1&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;key2&#34;</span> : <span style=color:#b44>&#34;value2&#34;</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Некоторые примеры информации, которая может быть в аннотациях:</p><ul><li><p>Поля, управляемые декларативным уровнем конфигурации. Добавление этих полей в виде аннотаций позволяет отличать их от значений по умолчанию, установленных клиентами или серверами, а также от автоматически сгенерированных полей и полей, заданных системами автоматического масштабирования.</p></li><li><p>Информация о сборке, выпуске или образе, например, метка времени, идентификаторы выпуска, ветка git, номера PR, хеши образов и адрес реестра.</p></li><li><p>Ссылки на репозитории логирования, мониторинга, аналитики или аудита.</p></li><li><p>Информация о клиентской библиотеке или инструменте, которая может использоваться при отладке (например, имя, версия и информация о сборке).</p></li><li><p>Информация об источнике пользователя или инструмента/системы, например, URL-адреса связанных объектов из других компонентов экосистемы.</p></li><li><p>Небольшие метаданные развертывания (например, конфигурация или контрольные точки).</p></li><li><p>Номера телефонов или пейджеров ответственных лиц или записи в справочнике, в которых можно найти нужную информацию, например, сайт группы.</p></li><li><p>Инструкции от конечных пользователей по исправлению работы или использования нестандартной функциональности.</p></li></ul><p>Вместо использования аннотаций, вы можете сохранить такого рода информацию во внешней базе данных или директории, хотя это усложнило бы создание общих клиентских библиотек и инструментов развертывания, управления, самодиагностики и т.д.</p><h2 id=синтаксис-и-набор-символов>Синтаксис и набор символов</h2><p><em>Аннотации</em> представляют собой пары ключ-значение. Разрешенные ключи аннотации имеют два сегмента, разделённые слешем (<code>/</code>): префикс (необязательно) и имя. Сегмент имени обязателен и должен содержать не более 63 символов, среди которых могут быть буквенно-цифровые символы(<code>[a-z0-9A-Z]</code>), а также дефисы (<code>-</code>), знаки подчеркивания (<code>_</code>), точки (<code>.</code>). Префикс не обязателен, но он быть поддоменом DNS: набор меток DNS, разделенных точками (<code>.</code>), общей длиной не более 253 символов, за которыми следует слеш (<code>/</code>).</p><p>Если префикс не указан, ключ аннотации считается закрытым для пользователя. Компоненты автоматизированной системы (например, <code>kube-scheduler</code>, <code>kube-controller-manager</code>, <code>kube-apiserver</code>, <code>kubectl</code> или другие сторонние), которые добавляют аннотации к объектам пользователя, должны указывать префикс.</p><p>Префиксы <code>kubernetes.io/</code> и <code>k8s.io/</code> зарезервированы для использования основными компонентами Kubernetes.</p><p>Например, ниже представлен конфигурационный файл объекта Pod с аннотацией <code>imageregistry: https://hub.docker.com/</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>annotations-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imageregistry</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;https://hub.docker.com/&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=что-дальше>Что дальше</h2><p>Узнать подробнее про <a href=/ru/docs/concepts/overview/working-with-objects/labels/>метки и селекторы</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-046c03090d47bc4b89b818dc645c3865>4.7 - Селекторы полей</h1><p><em>Селекторы полей</em> позволяют <a href=/ru/docs/concepts/overview/working-with-objects/kubernetes-objects>выбирать ресурсы Kubernetes</a>, исходя из значения одного или нескольких полей ресурсов. Ниже приведены несколько примеров запросов селекторов полей:</p><ul><li><code>metadata.name=my-service</code></li><li><code>metadata.namespace!=default</code></li><li><code>status.phase=Pending</code></li></ul><p>Следующая команда <code>kubectl</code> выбирает все Pod-объекты, в которых значение поля <a href=/docs/concepts/workloads/pods/pod-lifecycle/#pod-phase><code>status.phase</code></a> равно <code>Running</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods --field-selector status.phase<span style=color:#666>=</span>Running
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong><p>По сути, селекторы полей являются <em>фильтрами</em> ресурсов. По умолчанию нет установленных селекторов/фильтров, поэтому выбираются ресурсы всех типов. Это означает, что два запроса <code>kubectl</code> ниже одинаковы:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods
</span></span><span style=display:flex><span>kubectl get pods --field-selector <span style=color:#b44>&#34;&#34;</span>
</span></span></code></pre></div></div><h2 id=поддерживаемые-поля>Поддерживаемые поля</h2><p>Доступные селекторы полей зависят от типа ресурса Kubernetes. У всех типов ресурсов есть поля <code>metadata.name</code> и <code>metadata.namespace</code>. При использовании несуществующего селекторов полей приведёт к возникновению ошибки. Например:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get ingress --field-selector foo.bar<span style=color:#666>=</span>baz
</span></span></code></pre></div><pre tabindex=0><code>Error from server (BadRequest): Unable to find &#34;ingresses&#34; that match label selector &#34;&#34;, field selector &#34;foo.bar=baz&#34;: &#34;foo.bar&#34; is not a known field selector: only &#34;metadata.name&#34;, &#34;metadata.namespace&#34;
</code></pre><h2 id=поддерживаемые-операторы>Поддерживаемые операторы</h2><p>Можно использовать операторы <code>=</code>, <code>==</code> и <code>!=</code> в селекторах полей (<code>=</code> и <code>==</code> — синонимы). Например, следующая команда <code>kubectl</code> выбирает все сервисы Kubernetes, не принадлежавшие пространству имен <code>default</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get services  --all-namespaces --field-selector metadata.namespace!<span style=color:#666>=</span>default
</span></span></code></pre></div><h2 id=составные-селекторы>Составные селекторы</h2><p>Аналогично <a href=/ru/docs/concepts/overview/working-with-objects/labels>метки</a> и другим селекторам, несколько селекторы полей могут быть объединены через запятую. Приведенная ниже команда <code>kubectl</code> выбирает все Pod-объекты, у которых значение поле <code>status.phase</code>, отличное от <code>Running</code>, а поле <code>spec.restartPolicy</code> имеет значение <code>Always</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods --field-selector<span style=color:#666>=</span>status.phase!<span style=color:#666>=</span>Running,spec.restartPolicy<span style=color:#666>=</span>Always
</span></span></code></pre></div><h2 id=множественные-типы-ресурсов>Множественные типы ресурсов</h2><p>Можно использовать селекторы полей с несколькими типами ресурсов одновременно. Команда <code>kubectl</code> выбирает все объекты StatefulSet и Services, не включенные в пространство имен <code>default</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get statefulsets,services --all-namespaces --field-selector metadata.namespace!<span style=color:#666>=</span>default
</span></span></code></pre></div></div><div class=td-content style=page-break-before:always><h1 id=pg-5dd62c6a4a481b4cf1ac50f6799eb581>4.8 - Рекомендуемые метки</h1><p>Вы можете визуализировать и управлять объектами Kubernetes не только с помощью kubectl и панели управления. С помощью единого набора меток можно единообразно описывать объекты, что позволяет инструментам согласованно работать между собой.</p><p>В дополнение к существующим инструментам, рекомендуемый набор меток описывают приложения в том виде, в котором они могут быть получены.</p><p>Метаданные сосредоточены на понятии <em>приложение</em>. Kubernetes — это не платформа как услуга (PaaS), поэтому не закрепляет формальное понятие приложения.
Вместо этого приложения являются неформальными и описываются через метаданные. Определение приложения довольно расплывчатое.</p><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong> Это рекомендуемые для использования метки. Они облегчают процесс управления приложениями, но при этом не являются обязательными для основных инструментов.</div><p>Общие метки и аннотации используют один и тот же префикс: <code>app.kubernetes.io</code>. Метки без префикса являются приватными для пользователей. Совместно используемый префикс гарантирует, что общие метки не будут влиять на пользовательские метки.</p><h2 id=метки>Метки</h2><p>Чтобы извлечь максимум пользы от использования таких меток, они должны добавляться к каждому ресурсному объекту.</p><table><thead><tr><th>Ключ</th><th>Описание</th><th>Пример</th><th>Тип</th></tr></thead><tbody><tr><td><code>app.kubernetes.io/name</code></td><td>Имя приложения</td><td><code>mysql</code></td><td>string</td></tr><tr><td><code>app.kubernetes.io/instance</code></td><td>Уникальное имя экземпляра приложения</td><td><code>wordpress-abcxzy</code></td><td>string</td></tr><tr><td><code>app.kubernetes.io/version</code></td><td>Текущая версия приложения (например, семантическая версия, хеш коммита и т.д.)</td><td><code>5.7.21</code></td><td>string</td></tr><tr><td><code>app.kubernetes.io/component</code></td><td>Имя компонента в архитектуре</td><td><code>database</code></td><td>string</td></tr><tr><td><code>app.kubernetes.io/part-of</code></td><td>Имя основного приложения, частью которого является текущий объект</td><td><code>wordpress</code></td><td>string</td></tr><tr><td><code>app.kubernetes.io/managed-by</code></td><td>Инструмент управления приложением</td><td><code>helm</code></td><td>string</td></tr></tbody></table><p>Для демонстрации этих меток, рассмотрим следующий объект <code>StatefulSet</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StatefulSet<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>wordpress-abcxzy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;5.7.21&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/component</span>:<span style=color:#bbb> </span>database<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/part-of</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/managed-by</span>:<span style=color:#bbb> </span>helm<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=приложения-и-экземпляры-приложений>Приложения и экземпляры приложений</h2><p>Одно и то же приложение может быть установлено несколько раз в кластер Kubernetes, в ряде случаев — в одинаковое пространство имен. Например, WordPress может быть установлен более одного раза, тогда каждый из сайтов будет иметь собственный установленный экземпляр WordPress.</p><p>Имя приложения и имя экземпляра хранятся по отдельности. Например, WordPress имеет ключ <code>app.kubernetes.io/name</code> со значением <code>wordpress</code>, при этом у него есть имя экземпляра, представленное ключом <code>app.kubernetes.io/instance</code> со значением <code>wordpress-abcxzy</code>. Такой механизм позволяет идентифицировать как приложение, так и экземпляры приложения. У каждого экземпляра приложения должно быть уникальное имя.</p><h2 id=примеры>Примеры</h2><p>Следующие примеры показывают разные способы использования общих меток, поэтому они различаются по степени сложности.</p><h3 id=простой-сервис-без-состояния>Простой сервис без состояния</h3><p>Допустим, у нас есть простой сервис без состояния, развернутый с помощью объектов <code>Deployment</code> и <code>Service</code>. Следующие два фрагмента конфигурации показывают, как можно использовать метки в самом простом варианте.</p><p>Объект <code>Deployment</code> используется для наблюдения за подами, на которых запущено приложение.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>myservice<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>myservice-abcxzy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Объект <code>Service</code> используется для открытия доступа к приложению.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>myservice<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>myservice-abcxzy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=веб-приложение-с-базой-данных>Веб-приложение с базой данных</h3><p>Рассмотрим случай немного посложнее: веб-приложение (WordPress), которое использует базу данных (MySQL), установленное с помощью Helm. В следующих фрагментов конфигурации объектов отображена отправная точка развертывания такого приложения.</p><p>Следующий объект <code>Deployment</code> используется для WordPress:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>wordpress-abcxzy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;4.9.4&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/managed-by</span>:<span style=color:#bbb> </span>helm<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/component</span>:<span style=color:#bbb> </span>server<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/part-of</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Объект <code>Service</code> используется для открытия доступа к WordPress:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>wordpress-abcxzy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;4.9.4&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/managed-by</span>:<span style=color:#bbb> </span>helm<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/component</span>:<span style=color:#bbb> </span>server<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/part-of</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>MySQL открывается в виде <code>StatefulSet</code> с метаданными как для самого приложения, так и основного (родительского) приложения, к которому принадлежит СУБД:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StatefulSet<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>mysql-abcxzy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;5.7.21&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/managed-by</span>:<span style=color:#bbb> </span>helm<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/component</span>:<span style=color:#bbb> </span>database<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/part-of</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Объект <code>Service</code> предоставляет MySQL в составе WordPress:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>mysql-abcxzy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;5.7.21&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/managed-by</span>:<span style=color:#bbb> </span>helm<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/component</span>:<span style=color:#bbb> </span>database<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/part-of</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Вы заметите, что <code>StatefulSet</code> и <code>Service</code> MySQL содержат больше информации о MySQL и WordPress.</p></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/ru/docs/home/>Главная</a>
<a class=text-white href=/ru/community/>Сообщество</a>
<a class=text-white href=/ru/case-studies/>Примеры использования</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 Авторы Kubernetes | Документация распространяется под лицензией <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small><br><small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. Все права защищены. The Linux Foundation является зарегистрированной торговой маркой. Список торговых марок The Linux Foundation приведен на странице <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>использования торговых марок</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>