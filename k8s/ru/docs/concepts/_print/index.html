<!doctype html><html lang=ru class=no-js><head><meta name=robots content="noindex, nofollow"><link rel=alternate hreflang=en href=https://kubernetes.io/docs/concepts/><link rel=alternate hreflang=zh-cn href=https://kubernetes.io/zh-cn/docs/concepts/><link rel=alternate hreflang=ko href=https://kubernetes.io/ko/docs/concepts/><link rel=alternate hreflang=ja href=https://kubernetes.io/ja/docs/concepts/><link rel=alternate hreflang=fr href=https://kubernetes.io/fr/docs/concepts/><link rel=alternate hreflang=it href=https://kubernetes.io/it/docs/concepts/><link rel=alternate hreflang=de href=https://kubernetes.io/de/docs/concepts/><link rel=alternate hreflang=es href=https://kubernetes.io/es/docs/concepts/><link rel=alternate hreflang=pt-br href=https://kubernetes.io/pt-br/docs/concepts/><link rel=alternate hreflang=id href=https://kubernetes.io/id/docs/concepts/><link rel=alternate hreflang=pl href=https://kubernetes.io/pl/docs/concepts/><link rel=alternate hreflang=uk href=https://kubernetes.io/uk/docs/concepts/><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.110.0"><link rel=canonical type=text/html href=https://kubernetes.io/ru/docs/concepts/><link rel="shortcut icon" type=image/png href=/images/favicon.png><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=manifest href=/manifest.webmanifest><link rel=apple-touch-icon href=/images/kubernetes-192x192.png><title>Концепции | Kubernetes</title><meta property="og:title" content="Концепции"><meta property="og:description" content="Первоклассная оркестрация контейнеров"><meta property="og:type" content="website"><meta property="og:url" content="https://kubernetes.io/ru/docs/concepts/"><meta property="og:site_name" content="Kubernetes"><meta itemprop=name content="Концепции"><meta itemprop=description content="Первоклассная оркестрация контейнеров"><meta name=twitter:card content="summary"><meta name=twitter:title content="Концепции"><meta name=twitter:description content="Первоклассная оркестрация контейнеров"><link href=/scss/main.css rel=stylesheet><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","url":"https://kubernetes.io","logo":"https://kubernetes.io/images/favicon.png","potentialAction":{"@type":"SearchAction","target":"https://kubernetes.io/search/?q={search_term_string}","query-input":"required name=search_term_string"}}</script><meta name=theme-color content="#326ce5"><link rel=stylesheet href=/css/feature-states.css><meta name=description content="Раздел &#34;Концепции&#34; поможет вам узнать о частях системы Kubernetes и об абстракциях, которые Kubernetes использует для представления вашего кластера, и помогает вам глубже понять, как работает Kubernetes.
Краткий обзор Чтобы работать с Kubernetes, вы используете объекты API Kubernetes для описания желаемого состояния вашего кластера: какие приложения или другие рабочие нагрузки вы хотите запустить, какие образы контейнеров они используют, количество реплик, какие сетевые и дисковые ресурсы вы хотите использовать и сделать доступными и многое другое."><meta property="og:description" content="Раздел &#34;Концепции&#34; поможет вам узнать о частях системы Kubernetes и об абстракциях, которые Kubernetes использует для представления вашего кластера, и помогает вам глубже понять, как работает Kubernetes.
Краткий обзор Чтобы работать с Kubernetes, вы используете объекты API Kubernetes для описания желаемого состояния вашего кластера: какие приложения или другие рабочие нагрузки вы хотите запустить, какие образы контейнеров они используют, количество реплик, какие сетевые и дисковые ресурсы вы хотите использовать и сделать доступными и многое другое."><meta name=twitter:description content="Раздел &#34;Концепции&#34; поможет вам узнать о частях системы Kubernetes и об абстракциях, которые Kubernetes использует для представления вашего кластера, и помогает вам глубже понять, как работает Kubernetes.
Краткий обзор Чтобы работать с Kubernetes, вы используете объекты API Kubernetes для описания желаемого состояния вашего кластера: какие приложения или другие рабочие нагрузки вы хотите запустить, какие образы контейнеров они используют, количество реплик, какие сетевые и дисковые ресурсы вы хотите использовать и сделать доступными и многое другое."><meta property="og:url" content="https://kubernetes.io/ru/docs/concepts/"><meta property="og:title" content="Концепции"><meta name=twitter:title content="Концепции"><meta name=twitter:image content="https://kubernetes.io/images/favicon.png"><meta name=twitter:image:alt content="Kubernetes"><meta property="og:image" content="/images/kubernetes-horizontal-color.png"><meta property="og:type" content="article"><script src=/js/jquery-3.6.0.min.js intregrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar" data-auto-burger=primary><a class=navbar-brand href=/ru/></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-2 mb-lg-0"><a class="nav-link active" href=/ru/docs/>Документация</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ru/community/>Сообщество</a></li><li class="nav-item mr-2 mb-lg-0"><a class=nav-link href=/ru/case-studies/>Примеры использования</a></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Versions</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/ru/releases>Release Information</a>
<a class=dropdown-item href=https://kubernetes.io/ru/docs/concepts/>v1.25</a>
<a class=dropdown-item href=https://v1-24.docs.kubernetes.io/ru/docs/concepts/>v1.24</a>
<a class=dropdown-item href=https://v1-23.docs.kubernetes.io/ru/docs/concepts/>v1.23</a>
<a class=dropdown-item href=https://v1-22.docs.kubernetes.io/ru/docs/concepts/>v1.22</a>
<a class=dropdown-item href=https://v1-21.docs.kubernetes.io/ru/docs/concepts/>v1.21</a></div></li><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=navbarDropdownMenuLink role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Русский (Russian)</a><div class="dropdown-menu dropdown-menu-right" aria-labelledby=navbarDropdownMenuLink><a class=dropdown-item href=/docs/concepts/>English</a>
<a class=dropdown-item href=/zh-cn/docs/concepts/>中文 (Chinese)</a>
<a class=dropdown-item href=/ko/docs/concepts/>한국어 (Korean)</a>
<a class=dropdown-item href=/ja/docs/concepts/>日本語 (Japanese)</a>
<a class=dropdown-item href=/fr/docs/concepts/>Français (French)</a>
<a class=dropdown-item href=/it/docs/concepts/>Italiano (Italian)</a>
<a class=dropdown-item href=/de/docs/concepts/>Deutsch (German)</a>
<a class=dropdown-item href=/es/docs/concepts/>Español (Spanish)</a>
<a class=dropdown-item href=/pt-br/docs/concepts/>Português (Portuguese)</a>
<a class=dropdown-item href=/id/docs/concepts/>Bahasa Indonesia</a>
<a class=dropdown-item href=/pl/docs/concepts/>Polski (Polish)</a>
<a class=dropdown-item href=/uk/docs/concepts/>Українська (Ukrainian)</a></div></li></ul></div><button id=hamburger onclick=kub.toggleMenu() data-auto-burger-exclude><div></div></button></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>Это многостраничный печатный вид этого раздела.
<a href=# onclick="return print(),!1">Нажмите что бы печатать</a>.</p><p><a href=/ru/docs/concepts/>Вернуться к обычному просмотру страницы</a>.</p></div><h1 class=title>Концепции</h1><ul><li>1: <a href=#pg-0554ac387412eaf4e6e89b2f847dacde>Обзор</a></li><ul><li>1.1: <a href=#pg-45bdca6129cf540121623e903c18ba46>Что такое Kubernetes</a></li><li>1.2: <a href=#pg-13b0f1dbe89228e3d76d2ac231e245f1>Компоненты Kubernetes</a></li><li>1.3: <a href=#pg-0c745f42e623d2b70a53bc0e6db73d95>API Kubernetes</a></li><li>1.4: <a href=#pg-110f33530cf761140cb1dab536baef04>Работа с объектами Kubernetes</a></li><ul><li>1.4.1: <a href=#pg-9f5adfa77f48c50d5cc81155a3cecb98>Изучение объектов Kubernetes</a></li><li>1.4.2: <a href=#pg-6751db8ff5409476de8225d17d6c42dd>Управление объектами Kubernetes</a></li><li>1.4.3: <a href=#pg-f37749a83c2916b63279ea60f3cfe53e>Имена и идентификаторы объектов</a></li><li>1.4.4: <a href=#pg-1127165f472b7181b9c1d5a0b187d620>Пространства имён</a></li><li>1.4.5: <a href=#pg-f1dec4557fb8ffbac9f11390aaaf9fa4>Метки и селекторы</a></li><li>1.4.6: <a href=#pg-93cd7a1d4e1623e2bf01afc49a5af69c>Аннотации</a></li><li>1.4.7: <a href=#pg-046c03090d47bc4b89b818dc645c3865>Селекторы полей</a></li><li>1.4.8: <a href=#pg-5dd62c6a4a481b4cf1ac50f6799eb581>Рекомендуемые метки</a></li></ul></ul><li>2: <a href=#pg-2bf36ccd6b3dbeafecf87c39761b07c7>Кластерная Архитектура</a></li><ul><li>2.1: <a href=#pg-9ef2890698e773b6c0d24fd2c20146f5>Узлы</a></li><li>2.2: <a href=#pg-c0251def6da29b30afebfb04549f1703>Связь между плоскостью управления и узлом</a></li><li>2.3: <a href=#pg-ca8819042a505291540e831283da66df>Контроллеры</a></li><li>2.4: <a href=#pg-bc804b02614d67025b4c788f1ca87fbc>Диспетчер облачных контроллеров</a></li><li>2.5: <a href=#pg-44a2e2e592af0846101e970aff9243e5>Сборщик мусора</a></li></ul><li>3: <a href=#pg-285a3785fd3d20f437c28d87ca4dadca>Администрирование кластера</a></li><ul><li>3.1: <a href=#pg-2bf9a93ab5ba014fb6ff70b22c29d432>Сертификаты</a></li><li>3.2: <a href=#pg-85d633ae590aa20ec024f1b7af1d74fc>Установка дополнений</a></li></ul></ul><div class=content><p>Раздел "Концепции" поможет вам узнать о частях системы Kubernetes и об абстракциях, которые Kubernetes использует для представления вашего <a class=glossary-tooltip title='Набор машин, так называемые узлы, которые запускают контейнеризированные приложения. Кластер имеет как минимум один рабочий узел.' data-toggle=tooltip data-placement=top href='/ru/docs/reference/glossary/?all=true#term-cluster' target=_blank aria-label=кластера>кластера</a>, и помогает вам глубже понять, как работает Kubernetes.</p><h2 id=краткий-обзор>Краткий обзор</h2><p>Чтобы работать с Kubernetes, вы используете <em>объекты API Kubernetes</em> для описания <em>желаемого состояния вашего кластера</em>: какие приложения или другие рабочие нагрузки вы хотите запустить, какие образы контейнеров они используют, количество реплик, какие сетевые и дисковые ресурсы вы хотите использовать и сделать доступными и многое другое. Вы устанавливаете желаемое состояние, создавая объекты с помощью API Kubernetes, обычно через интерфейс командной строки <code>kubectl</code>. Вы также можете напрямую использовать API Kubernetes для взаимодействия с кластером и установки или изменения желаемого состояния.</p><p>После того, как вы установили желаемое состояние, <em>Плоскость управления Kubernetes</em> заставляет текущее состояние кластера соответствовать желаемому состоянию с помощью генератора событий жизненного цикла подов (<a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/node/pod-lifecycle-event-generator.md>Pod Lifecycle Event Generator, PLEG</a>). Для этого Kubernetes автоматически выполняет множество задач, таких как запуск или перезапуск контейнеров, масштабирование количества реплик данного приложения и многое другое. Плоскость управления Kubernetes состоит из набора процессов, запущенных в вашем кластере:</p><ul><li><strong>Мастер Kubernetes</strong> — это коллекция из трех процессов, которые выполняются на одном узле в вашем кластере, который обозначен как главный узел. Это процессы: <a href=/docs/admin/kube-apiserver/>kube-apiserver</a>, <a href=/docs/admin/kube-controller-manager/>kube-controller-manager</a> и <a href=/docs/admin/kube-scheduler/>kube-scheduler</a>.</li><li>Каждый отдельный неосновной узел в вашем кластере выполняет два процесса:<ul><li><strong><a href=/docs/admin/kubelet/>kubelet</a></strong>, который взаимодействует с мастером Kubernetes.</li><li><strong><a href=/docs/admin/kube-proxy/>kube-proxy</a></strong>, сетевой прокси, который обрабатывает сетевые сервисы Kubernetes на каждом узле.</li></ul></li></ul><h2 id=объекты-kubernetes>Объекты Kubernetes</h2><p>Kubernetes содержит ряд абстракций, которые представляют состояние вашей системы: развернутые контейнеризованные приложения и рабочие нагрузки, связанные с ними сетевые и дисковые ресурсы и другую информацию о том, что делает ваш кластер. Эти абстракции представлены объектами в API Kubernetes. См. <a href=/docs/concepts/overview/working-with-objects/kubernetes-objects>Понимание объектов Kubernetes</a> для получения более подробной информации.</p><p>Основные объекты Kubernetes включают в себя:</p><ul><li><a href=/docs/concepts/workloads/pods/pod-overview/>Pod</a></li><li><a href=/docs/concepts/services-networking/service/>Service</a></li><li><a href=/docs/concepts/storage/volumes/>Том</a></li><li><a href=/docs/concepts/overview/working-with-objects/namespaces/>Namespace</a></li></ul><p>Kubernetes также содержит абстракции более высокого уровня, которые опираются на <a href=/docs/concepts/architecture/controller/>Контроллеры</a> для создания базовых объектов и предоставляют дополнительные функциональные и удобные функции. Они включают:</p><ul><li><a href=/docs/concepts/workloads/controllers/deployment/>Deployment</a></li><li><a href=/docs/concepts/workloads/controllers/daemonset/>DaemonSet</a></li><li><a href=/docs/concepts/workloads/controllers/statefulset/>StatefulSet</a></li><li><a href=/docs/concepts/workloads/controllers/replicaset/>ReplicaSet</a></li><li><a href=/docs/concepts/workloads/controllers/jobs-run-to-completion/>Job</a></li></ul><h2 id=плоскость-управления-kubernetes>Плоскость управления Kubernetes</h2><p>Различные части панели управления Kubernetes, такие как мастер Kubernetes и процессы kubelet, определяют, как Kubernetes взаимодействует с кластером. Плоскость управления поддерживает запись всех объектов Kubernetes в системе и запускает непрерывные циклы управления для обработки состояния этих объектов. В любое время циклы управления панели управления будут реагировать на изменения в кластере и работать, чтобы фактическое состояние всех объектов в системе соответствовало желаемому состоянию, которое вы указали.</p><p>Например, когда вы используете API Kubernetes для создания развертывания, вы предоставляете новое желаемое состояние для системы. Плоскость управления Kubernetes записывает создание этого объекта и выполняет ваши инструкции, запуская необходимые приложения и планируя их на узлы кластера, чтобы фактическое состояние кластера соответствовало желаемому состоянию.</p><h3 id=мастер-kubernetes>Мастер Kubernetes</h3><p>Мастер Kubernetes отвечает за поддержание желаемого состояния для вашего кластера. Когда вы взаимодействуете с Kubernetes, например, используя интерфейс командной строки <code>kubectl</code>, вы работаете с мастером Kubernetes вашего кластера.</p><blockquote><p>Под "мастером" понимается совокупность процессов, которые управляют состоянием кластера. Обычно все эти процессы выполняются на одном узле кластера, и поэтому этот узел называется главным (master). Мастер также может быть реплицирован для доступности и резервирования.</p></blockquote><h3 id=узлы-kubernetes>Узлы Kubernetes</h3><p>Узлы в кластере - это машины (виртуальные машины, физические серверы и т.д.), на которых работают ваши приложения и облачные рабочие процессы. Мастер Kubernetes контролирует каждый узел; вы редко будете взаимодействовать с узлами напрямую.</p><h2 id=что-дальше>Что дальше</h2><p>Если вы хотите описать концепт, обратитесь к странице
<a href=/docs/home/contribute/page-templates/>Использование шаблонов страниц</a>
для получения информации о типе страницы и шаблоне концепции.</p></div></div><div class=td-content style=page-break-before:always><h1 id=pg-0554ac387412eaf4e6e89b2f847dacde>1 - Обзор</h1></div><div class=td-content><h1 id=pg-45bdca6129cf540121623e903c18ba46>1.1 - Что такое Kubernetes</h1><p>Эта страница посвящена краткому обзору Kubernetes.</p><p>Kubernetes — это портативная расширяемая платформа с открытым исходным кодом для управления контейнеризованными рабочими нагрузками и сервисами, которая облегчает как декларативную настройку, так и автоматизацию. У платформы есть большая, быстро растущая экосистема. Сервисы, поддержка и инструменты Kubernetes широко доступны.</p><p>Название Kubernetes происходит от греческого, что означает рулевой или штурман. Google открыл исходный код Kubernetes в 2014 году. Kubernetes основывается на <a href=https://research.google/pubs/pub43438>десятилетнем опыте работы Google с масштабными рабочими нагрузками</a>, в сочетании с лучшими в своем классе идеями и практиками сообщества.</p><h2 id=история>История</h2><p>Давайте вернемся назад и посмотрим, почему Kubernetes так полезен.</p><p><img src=/images/docs/Container_Evolution.svg alt="Эволюция развертывания"></p><p><strong>Традиционная эра развертывания:</strong>
Ранее организации запускали приложения на физических серверах. Не было никакого способа определить границы ресурсов для приложений на физическом сервере, и это вызвало проблемы с распределением ресурсов. Например, если несколько приложений выполняются на физическом сервере, могут быть случаи, когда одно приложение будет занимать большую часть ресурсов, и в результате чего другие приложения будут работать хуже. Решением этого было запустить каждое приложение на другом физическом сервере. Но это не масштабировалось, поскольку ресурсы использовались не полностью, из-за чего организациям было накладно поддерживать множество физических серверов.</p><p><strong>Эра виртуального развертывания:</strong> В качестве решения была представлена виртуализация. Она позволила запускать несколько виртуальных машин (ВМ) на одном физическом сервере. Виртуализация изолирует приложения между виртуальными машинами и обеспечивает определенный уровень безопасности, поскольку информация одного приложения не может быть свободно доступна другому приложению.</p><p>Виртуализация позволяет лучше использовать ресурсы на физическом сервере и обеспечивает лучшую масштабируемость, поскольку приложение можно легко добавить или обновить, кроме этого снижаются затраты на оборудование и многое другое. С помощью виртуализации можно превратить набор физических ресурсов в кластер одноразовых виртуальных машин.</p><p>Каждая виртуальная машина представляет собой полноценную машину, на которой выполняются все компоненты, включая собственную операционную систему, поверх виртуализированного оборудования.</p><p><strong>Эра контейнеров:</strong> Контейнеры похожи на виртуальные машины, но у них есть свойства изоляции для совместного использования операционной системы (ОС) между приложениями. Поэтому контейнеры считаются легкими. Подобно виртуальной машине, контейнер имеет свою собственную файловую систему, процессор, память, пространство процесса и многое другое. Поскольку они не связаны с базовой инфраструктурой, они переносимы между облаками и дистрибутивами ОС.</p><p>Контейнеры стали популярными из-за таких дополнительных преимуществ как:</p><ul><li>Гибкое создание и развертывание приложений: простота и эффективность создания образа контейнера по сравнению с использованием образа виртуальной машины.</li><li>Непрерывная разработка, интеграция и развертывание: обеспечивает надежную и частую сборку и развертывание образа контейнера с быстрым и простым откатом (благодаря неизменности образа).</li><li>Разделение задач между Dev и Ops: создавайте образы контейнеров приложений во время сборки/релиза, а не во время развертывания, тем самым отделяя приложения от инфраструктуры.</li><li>Наблюдаемость охватывает не только информацию и метрики на уровне ОС, но также информацию о работоспособности приложений и другие сигналы.</li><li>Идентичная окружающая среда при разработке, тестировании и релизе: на ноутбуке работает так же, как и в облаке.</li><li>Переносимость облачных и операционных систем: работает на Ubuntu, RHEL, CoreOS, on-prem, Google Kubernetes Engine и в любом другом месте.</li><li>Управление, ориентированное на приложения: повышает уровень абстракции от запуска ОС на виртуальном оборудовании до запуска приложения в ОС с использованием логических ресурсов.</li><li>Слабосвязанные, распределенные, гибкие, выделенные микросервисы: вместо монолитного стека на одной большой выделенной машине, приложения разбиты на более мелкие независимые части, которые можно динамически развертывать и управлять.</li><li>Изоляция ресурсов: предсказуемая производительность приложения.</li><li>Грамотное использование ресурсов: высокая эффективность и компактность.</li></ul><h2 id=зачем-вам-kubernetes-и-что-он-может-сделать>Зачем вам Kubernetes и что он может сделать?</h2><p>Контейнеры — отличный способ связать и запустить ваши приложения. В производственной среде необходимо управлять контейнерами, которые запускают приложения, и гарантировать отсутствие простоев. Например, если контейнер выходит из строя, необходимо запустить другой контейнер. Не было бы проще, если бы такое поведение обрабатывалось системой?</p><p>Вот тут Kubernetes приходит на помощь! Kubernetes дает вам фреймворк для гибкой работы распределенных систем. Он занимается масштабированием и обработкой ошибок в приложении, предоставляет шаблоны развертывания и многое другое. Например, Kubernetes может легко управлять канареечным развертыванием вашей системы.</p><p>Kubernetes предоставляет вам:</p><ul><li><strong>Мониторинг сервисов и распределение нагрузки</strong>
Kubernetes может обнаружить контейнер, используя имя DNS или собственный IP-адрес. Если трафик в контейнере высокий, Kubernetes может сбалансировать нагрузку и распределить сетевой трафик, чтобы развертывание было стабильным.</li><li><strong>Оркестрация хранилища</strong>
Kubernetes позволяет вам автоматически смонтировать систему хранения по вашему выбору, такую как локальное хранилище, провайдеры общедоступного облака и многое другое.</li><li><strong>Автоматическое развертывание и откаты</strong>
Используя Kubernetes можно описать желаемое состояние развернутых контейнеров и изменить фактическое состояние на желаемое. Например, вы можете автоматизировать Kubernetes на создание новых контейнеров для развертывания, удаления существующих контейнеров и распределения всех их ресурсов в новый контейнер.</li><li><strong>Автоматическое распределение нагрузки</strong>
Вы предоставляете Kubernetes кластер узлов, который он может использовать для запуска контейнерных задач. Вы указываете Kubernetes, сколько ЦП и памяти (ОЗУ) требуется каждому контейнеру. Kubernetes может разместить контейнеры на ваших узлах так, чтобы наиболее эффективно использовать ресурсы.</li><li><strong>Самоконтроль</strong>
Kubernetes перезапускает отказавшие контейнеры, заменяет и завершает работу контейнеров, которые не проходят определенную пользователем проверку работоспособности, и не показывает их клиентам, пока они не будут готовы к обслуживанию.</li><li><strong>Управление конфиденциальной информацией и конфигурацией</strong>
Kubernetes может хранить и управлять конфиденциальной информацией, такой как пароли, OAuth-токены и ключи SSH. Вы можете развертывать и обновлять конфиденциальную информацию и конфигурацию приложения без изменений образов контейнеров и не раскрывая конфиденциальную информацию в конфигурации стека.</li></ul><h2 id=чем-kubernetes-не-является>Чем Kubernetes не является</h2><p>Kubernetes ― это не традиционная комплексная система PaaS (платформа как услуга). Поскольку Kubernetes работает на уровне контейнеров, а не на уровне оборудования, у него имеется определенные общеприменимые возможности, характерные для PaaS, такие как развертывание, масштабирование, балансировка нагрузки, ведение журналов и мониторинг. Тем не менее, Kubernetes это не монолитное решение, поэтому указанные возможности по умолчанию являются дополнительными и подключаемыми. У Kubernetes есть компоненты для создания платформы разработчика, но он сохраняет право выбора за пользователем и гибкость там, где это важно.</p><p>Kubernetes:</p><ul><li>Не ограничивает типы поддерживаемых приложений. Kubernetes стремится поддерживать широкий спектр рабочих нагрузок, включая те, у которых есть или отсутствует состояние, а также связанные с обработкой данных. Если приложение может работать в контейнере, оно должно отлично работать и в Kubernetes.</li><li>Не развертывает исходный код и не собирает приложение. Рабочие процессы непрерывной интеграции, доставки и развертывания (CI/CD) определяются культурой и предпочтениями организации, а также техническими требованиями.</li><li>Не предоставляет сервисы для приложения, такие как промежуточное программное обеспечение (например, очереди сообщений), платформы обработки данных (например, Spark), базы данных (например, MySQL), кеши или кластерные системы хранения (например, Ceph), как встроенные сервисы. Такие компоненты могут работать в Kubernetes и/или могут быть доступны для приложений, работающих в Kubernetes, через переносные механизмы, такие как Open Service Broker.</li><li>Не включает решения для ведения журнала, мониторинга или оповещения. Он обеспечивает некоторые интеграции в качестве доказательства концепции и механизмы для сбора и экспорта метрик.</li><li>Не указывает и не требует настройки языка/системы (например, Jsonnet). Он предоставляет декларативный API, который может быть нацелен на произвольные формы декларативных спецификаций.</li><li>Не предоставляет и не принимает никаких комплексных систем конфигурации, технического обслуживания, управления или самовосстановления.</li><li>Кроме того, Kubernetes — это не просто система оркестрации. Фактически, Kubernetes устраняет необходимость в этом. Техническое определение оркестрации — это выполнение определенного рабочего процесса: сначала сделай A, затем B, затем C. Напротив, Kubernetes содержит набор независимых, компонуемых процессов управления, которые непрерывно переводит текущее состояние к предполагаемому состоянию. Неважно, как добраться от А до С. Не требуется также централизованный контроль. Это делает систему более простой в использовании, более мощной, надежной, устойчивой и расширяемой.</li></ul><h2 id=что-дальше>Что дальше</h2><ul><li>Изучите <a href=/docs/concepts/overview/components/>Компоненты Kubernetes</a></li><li>Готовы <a href=/docs/setup/>начать</a>?</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-13b0f1dbe89228e3d76d2ac231e245f1>1.2 - Компоненты Kubernetes</h1><p>При развёртывании Kubernetes вы имеете дело с кластером.<p><p>Кластер Kubernetes cluster состоит из набор машин, так называемые узлы, которые запускают контейнеризированные приложения. Кластер имеет как минимум один рабочий узел.</p></p><p>В рабочих узлах размещены поды, являющиеся компонентами приложения. Плоскость управления управляет рабочими узлами и подами в кластере. В промышленных средах плоскость управления обычно запускается на нескольких компьютерах, а кластер, как правило, развёртывается на нескольких узлах, гарантируя отказоустойчивость и высокую надёжность.</p></p><p>На этой странице в общих чертах описывается различные компоненты, необходимые для работы кластера Kubernetes.</p><p>Ниже показана диаграмма кластера Kubernetes со всеми связанными компонентами.</p><p><img src=/images/docs/components-of-kubernetes.png alt="Компоненты Kubernetes"></p><h2 id=плоскость-управления-компонентами>Плоскость управления компонентами</h2><p>Компоненты панели управления отвечают за основные операции кластера (например, планирование), а также обрабатывают события кластера (например, запускают новый <a class=glossary-tooltip title='Самый маленький и простой объект в Kubernetes. Под — это набор запущенных контейнеров в кластере.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=под>под</a>, когда поле <code>replicas</code> развертывания не соответствует требуемому количеству реплик).</p><p>Компоненты панели управления могут быть запущены на любой машине в кластере. Однако для простоты сценарии настройки обычно запускают все компоненты панели управления на одном компьютере и в то же время не позволяют запускать пользовательские контейнеры на этом компьютере. Смотрите страницу <a href=/docs/admin/high-availability/>Создание высоконадёжных кластеров</a> для примера настройки нескольких ведущих виртуальных машин.</p><h3 id=kube-apiserver>kube-apiserver</h3><p>Сервер API — компонент Kubernetes
<a class=glossary-tooltip title='Уровень оркестрации контейнеров с API и интерфейсами для определения, развёртывания и управления жизненным циклом контейнеров.' data-toggle=tooltip data-placement=top href='/ru/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='панели управления'>панели управления</a>, который представляет API Kubernetes.
API-сервер — это клиентская часть панели управления Kubernetes</p><p>Основной реализацией API-сервера Kubernetes является <a href=/docs/reference/generated/kube-apiserver/>kube-apiserver</a>.
kube-apiserver предназначен для горизонтального масштабирования, то есть развёртывание на несколько экземпляров.
Вы можете запустить несколько экземпляров kube-apiserver и сбалансировать трафик между этими экземплярами.</p><h3 id=etcd>etcd</h3><p>Распределённое и высоконадёжное хранилище данных в формате "ключ-значение", которое используется как основное хранилище всех данных кластера в Kubernetes.</p><p>Если ваш кластер Kubernetes использует etcd в качестве основного хранилища, убедитесь, что у вас <a href=/docs/tasks/administer-cluster/configure-upgrade-etcd/#backing-up-an-etcd-cluster>настроено резервное копирование</a> данных.</p><p>Вы можете найти подробную информацию о etcd в <a href=https://etcd.io/docs/>официальной документации</a>.</p><h3 id=kube-scheduler>kube-scheduler</h3><p>Компонент плоскости управления, который отслеживает созданные поды без привязанного узла и выбирает узел, на котором они должны работать.</p><p>При планировании развёртывания подов на узлах учитываются множество факторов, включая требования к ресурсам, ограничения, связанные с аппаратными/программными политиками, принадлежности (affinity) и непринадлежности (anti-affinity) узлов/подов, местонахождения данных, предельных сроков.</p><h3 id=kube-controller-manager>kube-controller-manager</h3><p>Компонент Control Plane запускает процессы <a class=glossary-tooltip title='Управляющий цикл который отслеживает общее состояние кластера через API-сервер и вносит изменения пытаясь приветси текушее состояние к желаемому состоянию.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=контроллера>контроллера</a>.</p><p>Вполне логично, что каждый <a class=glossary-tooltip title='Управляющий цикл который отслеживает общее состояние кластера через API-сервер и вносит изменения пытаясь приветси текушее состояние к желаемому состоянию.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=контроллер>контроллер</a> в свою очередь представляет собой отдельный процесс, и для упрощения все такие процессы скомпилированы в один двоичный файл и выполняются в одном процессе.</p><p>Эти контроллеры включают:</p><ul><li>Контроллер узла (Node Controller): уведомляет и реагирует на сбои узла.</li><li>Контроллер репликации (Replication Controller): поддерживает правильное количество подов для каждого объекта контроллера репликации в системе.</li><li>Контроллер конечных точек (Endpoints Controller): заполняет объект конечных точек (Endpoints), то есть связывает сервисы (Services) и поды (Pods).</li><li>Контроллеры учетных записей и токенов (Account & Token Controllers): создают стандартные учетные записи и токены доступа API для новых пространств имен.</li></ul><h3 id=cloud-controller-manager>cloud-controller-manager</h3><p><a href=/docs/tasks/administer-cluster/running-cloud-controller/>cloud-controller-manager</a> запускает контроллеры, которые взаимодействуют с основными облачными провайдерами. Двоичный файл cloud-controller-manager — это альфа-функциональность, появившиеся в Kubernetes 1.6.</p><p>cloud-controller-manager запускает только циклы контроллера, относящиеся к облачному провайдеру. Вам нужно отключить эти циклы контроллера в kube-controller-manager. Вы можете отключить циклы контроллера, установив флаг <code>--cloud-provider</code> со значением <code>external</code> при запуске kube-controller-manager.</p><p>С помощью cloud-controller-manager код как облачных провайдеров, так и самого Kubernetes может разрабатываться независимо друг от друга. В предыдущих версиях код ядра Kubernetes зависел от кода, предназначенного для функциональности облачных провайдеров. В будущих выпусках код, специфичный для облачных провайдеров, должен поддерживаться самим облачным провайдером и компоноваться с cloud-controller-manager во время запуска Kubernetes.</p><p>Следующие контроллеры зависят от облачных провайдеров:</p><ul><li>Контроллер узла (Node Controller): проверяет облачный провайдер, чтобы определить, был ли удален узел в облаке после того, как он перестал работать</li><li>Контроллер маршрутов (Route Controller): настраивает маршруты в основной инфраструктуре облака</li><li>Контроллер сервисов (Service Controller): создаёт, обновляет и удаляет балансировщики нагрузки облачного провайдера.</li><li>Контроллер тома (Volume Controller): создаёт, присоединяет и монтирует тома, а также взаимодействует с облачным провайдером для оркестрации томов.</li></ul><h2 id=компоненты-узла>Компоненты узла</h2><p>Компоненты узла работают на каждом узле, поддерживая работу подов и среды выполнения Kubernetes.</p><h3 id=kubelet>kubelet</h3><p>Агент, работающий на каждом узле в кластере. Он следит за тем, чтобы контейнеры были запущены в поде.</p><p>Утилита kubelet принимает набор PodSpecs, и гарантирует работоспособность и исправность определённых в них контейнеров. Агент kubelet не отвечает за контейнеры, не созданные Kubernetes.</p><h3 id=kube-proxy>kube-proxy</h3><p><a href=/docs/reference/command-line-tools-reference/kube-proxy/>kube-proxy</a> — сетевой прокси, работающий на каждом узле в кластере, и реализующий часть концепции <a class=glossary-tooltip title='Способ представления приложения, запущенного в наборе подов, в виде сетевого сервиса.' data-toggle=tooltip data-placement=top href=/docs/concepts/services-networking/service/ target=_blank aria-label=сервис>сервис</a>.</p><p>kube-proxy конфигурирует правила сети на узлах. При помощи них разрешаются сетевые подключения к вашими подам изнутри и снаружи кластера.</p><p>kube-proxy использует уровень фильтрации пакетов в операционной системы, если он доступен. В противном случае, kube-proxy сам обрабатывает передачу сетевого трафика.</p><h3 id=среда-выполнения-контейнера>Среда выполнения контейнера</h3><p>Среда выполнения контейнера — это программа, предназначенная для выполнения контейнеров.</p><p>Kubernetes поддерживает несколько сред для запуска контейнеров: <a class=glossary-tooltip title='Docker — это программное обеспечение для виртуализации на уровне операционной системы, которая известна как контейнеризация.' data-toggle=tooltip data-placement=top href=https://docs.docker.com/engine/ target=_blank aria-label=Docker>Docker</a>,
<a class=glossary-tooltip title='Среда выполнения контейнера с упором на простоту, надежность и переносимость' data-toggle=tooltip data-placement=top href=https://containerd.io/docs/ target=_blank aria-label=containerd>containerd</a>, <a class=glossary-tooltip title='Оптимизированная среда выполнения контейнеров, разработанная специально для Kubernetes' data-toggle=tooltip data-placement=top href=https://cri-o.io/#what-is-cri-o target=_blank aria-label=CRI-O>CRI-O</a>,
и любая реализация <a href=https://github.com/kubernetes/community/blob/master/contributors/devel/sig-node/container-runtime-interface.md>Kubernetes CRI (Container Runtime
Interface)</a>.</p><h2 id=дополнения>Дополнения</h2><p>Дополнения используют ресурсы Kubernetes (<a class=glossary-tooltip title='Гарантирует, что копия Pod выполняется в наборе узлов кластера.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/daemonset target=_blank aria-label=DaemonSet>DaemonSet</a>, <a class=glossary-tooltip title='API-объект, управляющий реплицированным приложением.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/deployment/ target=_blank aria-label=Deployment>Deployment</a> и т.д.) для расширения функциональности кластера. Поскольку дополнения охватывают весь кластер, ресурсы относятся к пространству имен <code>kube-system</code>.</p><p>Некоторые из дополнений описаны ниже; более подробный список доступных расширений вы можете найти на странице <a href=/docs/concepts/cluster-administration/addons/>Дополнения</a>.</p><h3 id=dns>DNS</h3><p>Хотя прочие дополнения не являются строго обязательными, однако при этом у всех Kubernetes-кластеров должен быть <a href=/docs/concepts/services-networking/dns-pod-service/>кластерный DNS</a>, так как многие примеры предполагают его наличие.</p><p>Кластерный DNS — это DNS-сервер наряду с другими DNS-серверами в вашем окружении, который обновляет DNS-записи для сервисов Kubernetes.</p><p>Контейнеры, запущенные посредством Kubernetes, автоматически включают этот DNS-сервер в свои DNS.</p><h3 id=веб-интерфейс-dashboard>Веб-интерфейс (Dashboard)</h3><p><a href=/docs/tasks/access-application-cluster/web-ui-dashboard/>Dashboard</a> — это универсальный веб-интерфейс для кластеров Kubernetes. С помощью этой панели, пользователи могут управлять и устранять неполадки кластера и приложений, работающих в кластере.</p><h3 id=мониторинг-ресурсов-контейнера>Мониторинг ресурсов контейнера</h3><p><a href=/docs/tasks/debug-application-cluster/resource-usage-monitoring/>Мониторинг ресурсов контейнера</a> записывает общие метрики о контейнерах в виде временных рядов в центральной базе данных и предлагает пользовательский интерфейс для просмотра этих данных.</p><h3 id=логирование-кластера>Логирование кластера</h3><p>Механизм <a href=/docs/concepts/cluster-administration/logging/>логирования кластера</a> отвечает за сохранение логов контейнера в централизованном хранилище логов с возможностью их поиска/просмотра.</p><h2 id=что-дальше>Что дальше</h2><ul><li>Подробнее про <a href=/docs/concepts/architecture/nodes/>узлы</a></li><li>Подробнее про <a href=/docs/concepts/architecture/controller/>контроллеры</a></li><li>Подробнее про <a href=/docs/concepts/scheduling/kube-scheduler/>kube-scheduler</a></li><li>Официальная <a href=https://etcd.io/docs/>документация</a> etcd</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-0c745f42e623d2b70a53bc0e6db73d95>1.3 - API Kubernetes</h1><p>Общие соглашения API описаны на <a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md>странице соглашений API</a>.</p><p>Конечные точки API, типы ресурсов и примеры описаны в <a href=/ru/docs/reference>справочнике API</a>.</p><p>Удаленный доступ к API обсуждается в <a href=/docs/reference/access-authn-authz/controlling-access/>Controlling API Access doc</a>.</p><p>API Kubernetes также служит основой декларативной схемы конфигурации системы. С помощью инструмента командной строки <a href=/ru/docs/reference/kubectl/overview/>kubectl</a> можно создавать, обновлять, удалять и получать API-объекты.</p><p>Kubernetes также сохраняет сериализованное состояние (в настоящее время в хранилище <a href=https://coreos.com/docs/distributed-configuration/getting-started-with-etcd/>etcd</a>) каждого API-ресурса.</p><p>Kubernetes как таковой состоит из множества компонентов, которые взаимодействуют друг с другом через собственные API.</p><h2 id=изменения-в-api>Изменения в API</h2><p>Исходя из нашего опыта, любая успешная система должна улучшаться и изменяться по мере появления новых сценариев использования или изменения существующих. Поэтому мы надеемся, что и API Kubernetes будет постоянно меняться и расширяться. Однако в течение продолжительного периода времени мы будем поддерживать хорошую обратную совместимость с существующими клиентами. В целом, новые ресурсы API и поля ресурсов будут добавляться часто. Удаление ресурсов или полей регулируются <a href=/docs/reference/using-api/deprecation-policy/>соответствующим процессом</a>.</p><p>Определение совместимого изменения и методы изменения API подробно описаны в <a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api_changes.md>документе об изменениях API</a>.</p><h2 id=определения-openapi-и-swagger>Определения OpenAPI и Swagger</h2><p>Все детали API документируется с использованием <a href=https://www.openapis.org/>OpenAPI</a>.</p><p>Начиная с Kubernetes 1.10, API-сервер Kubernetes основывается на спецификации OpenAPI через конечную точку <code>/openapi/v2</code>.
Нужный формат устанавливается через HTTP-заголовки:</p><table><thead><tr><th>Заголовок</th><th>Возможные значения</th></tr></thead><tbody><tr><td>Accept</td><td><code>application/json</code>, <code>application/com.github.proto-openapi.spec.v2@v1.0+protobuf</code> (по умолчанию заголовок Content-Type установлен в <code>application/json</code> с <code>*/*</code>, допустимо также пропускать этот заголовок)</td></tr><tr><td>Accept-Encoding</td><td><code>gzip</code> (можно не передавать этот заголовок)</td></tr></tbody></table><p>До версии 1.14 конечные точки с форматом (<code>/swagger.json</code>, <code>/swagger-2.0.0.json</code>, <code>/swagger-2.0.0.pb-v1</code>, <code>/swagger-2.0.0.pb-v1.gz</code>) предоставляли спецификацию OpenAPI в разных форматах. Эти конечные точки были объявлены устаревшими и удалены в Kubernetes 1.14.</p><p><strong>Примеры получения спецификации OpenAPI</strong>:</p><table><thead><tr><th>До 1.10</th><th>С версии Kubernetes 1.10</th></tr></thead><tbody><tr><td>GET /swagger.json</td><td>GET /openapi/v2 <strong>Accept</strong>: application/json</td></tr><tr><td>GET /swagger-2.0.0.pb-v1</td><td>GET /openapi/v2 <strong>Accept</strong>: <a href=mailto:application/com.github.proto-openapi.spec.v2@v1.0>application/com.github.proto-openapi.spec.v2@v1.0</a>+protobuf</td></tr><tr><td>GET /swagger-2.0.0.pb-v1.gz</td><td>GET /openapi/v2 <strong>Accept</strong>: <a href=mailto:application/com.github.proto-openapi.spec.v2@v1.0>application/com.github.proto-openapi.spec.v2@v1.0</a>+protobuf <strong>Accept-Encoding</strong>: gzip</td></tr></tbody></table><p>В Kubernetes реализован альтернативный формат сериализации API, основанный на Protobuf, который в первую очередь предназначен для взаимодействия внутри кластера. Описание этого формата можно найти в <a href=https://github.com/kubernetes/community/blob/master/contributors/design-proposals/api-machinery/protobuf.md>проектом решении</a>, а IDL-файлы по каждой схемы — в пакетах Go, определяющих API-объекты.</p><p>До версии 1.14 apiserver Kubernetes также представлял API, который можно использовать для получения спецификации <a href=http://swagger.io/>Swagger v1.2</a> для API Kubernetes по пути <code>/swaggerapi</code>. Эта конечная точка устарела и была удалена в Kubernetes 1.14</p><h2 id=версионирование-api>Версионирование API</h2><p>Чтобы упростить удаления полей или изменение ресурсов, Kubernetes поддерживает несколько версий API, каждая из которых доступна по собственному пути, например, <code>/api/v1</code> или <code>/apis/extensions/v1beta1</code>.</p><p>Мы выбрали версионирование API, а не конкретных ресурсов или полей, чтобы API отражал четкое и согласованное представление о системных ресурсах и их поведении, а также, чтобы разграничивать API, которые уже не поддерживаются и/или находятся в экспериментальной стадии. Схемы сериализации JSON и Protobuf следуют одним и тем же правилам по внесению изменений в схему, поэтому описание ниже охватывают оба эти формата.</p><p>Обратите внимание, что версионирование API и программное обеспечение косвенно связаны друг с другом. <a href=https://git.k8s.io/community/contributors/design-proposals/release/versioning.md>Предложение по версионированию API и новых выпусков</a> описывает, как связаны между собой версии API с версиями программного обеспечения.</p><p>Разные версии API характеризуются разными уровнями стабильности и поддержки. Критерии каждого уровня более подробно описаны в <a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api_changes.md#alpha-beta-and-stable-versions>документации изменений API</a>. Ниже приводится краткое изложение:</p><ul><li>Альфа-версии:<ul><li>Названия версий включают надпись <code>alpha</code> (например, <code>v1alpha1</code>).</li><li>Могут содержать баги. Включение такой функциональности может привести к ошибкам. По умолчанию она отключена.</li><li>Поддержка функциональности может быть прекращена в любое время без какого-либо оповещения об этом.</li><li>API может быть несовместим с более поздними версиями без упоминания об этом.</li><li>Рекомендуется для использования только в тестировочных кластерах с коротким жизненным циклом из-за высокого риска наличия багов и отсутствия долгосрочной поддержки.</li></ul></li><li>Бета-версии:<ul><li>Названия версий включают надпись <code>beta</code> (например, <code>v2beta3</code>).</li><li>Код хорошо протестирован. Активация этой функциональности — безопасно. Поэтому она включена по умолчанию.</li><li>Поддержка функциональности в целом не будет прекращена, хотя кое-что может измениться.</li><li>Схема и/или семантика объектов может стать несовместимой с более поздними бета-версиями или стабильными выпусками. Когда это случится, мы даем инструкции по миграции на следующую версию. Это обновление может включать удаление, редактирование и повторного создание API-объектов. Этот процесс может потребовать тщательного анализа. Кроме этого, это может привести к простою приложений, которые используют данную функциональность.</li><li>Рекомендуется только для неосновного производственного использования из-за риска возникновения возможных несовместимых изменений с будущими версиями. Если у вас есть несколько кластеров, которые возможно обновить независимо, вы можете снять это ограничение.</li><li><strong>Пожалуйста, попробуйте в действии бета-версии функциональности и поделитесь своими впечатлениями! После того как функциональность выйдет из бета-версии, нам может быть нецелесообразно что-то дальше изменять.</strong></li></ul></li><li>Стабильные версии:<ul><li>Имя версии <code>vX</code>, где <code>vX</code> — целое число.</li><li>Стабильные версии функциональностей появятся в новых версиях.</li></ul></li></ul><h2 id=api-группы>API-группы</h2><p>Чтобы упростить расширение API Kubernetes, реализованы <a href=https://git.k8s.io/community/contributors/design-proposals/api-machinery/api-group.md><em>группы API</em></a>.
Группа API указывается в пути REST и в поле <code>apiVersion</code> сериализованного объекта.</p><p>В настоящее время используется несколько API-групп:</p><ol><li><p>Группа <em>core</em>, которая часто упоминается как <em>устаревшая</em> (<em>legacy group</em>), доступна по пути <code>/api/v1</code> и использует <code>apiVersion: v1</code>.</p></li><li><p>Именованные группы находятся в пути REST <code>/apis/$GROUP_NAME/$VERSION</code> и используют <code>apiVersion: $GROUP_NAME/$VERSION</code> (например, <code>apiVersion: batch/v1</code>). Полный список поддерживаемых групп API можно увидеть в <a href=/ru/docs/reference/>справочнике API Kubernetes</a>.</p></li></ol><p>Есть два поддерживаемых пути к расширению API с помощью <a href=/docs/concepts/api-extension/custom-resources/>пользовательских ресурсов</a>:</p><ol><li><a href=/docs/tasks/access-kubernetes-api/extend-api-custom-resource-definitions/>CustomResourceDefinition</a> для пользователей, которым нужен очень простой CRUD.</li><li>Пользователи, которым нужна полная семантика API Kubernetes, могут реализовать собственный apiserver и использовать <a href=/docs/tasks/access-kubernetes-api/configure-aggregation-layer/>агрегатор</a> для эффективной интеграции для клиентов.</li></ol><h2 id=включение-или-отключение-групп-api>Включение или отключение групп API</h2><p>Некоторые ресурсы и группы API включены по умолчанию. Их можно включить или отключить, установив <code>--runtime-config</code> для apiserver. Флаг <code>--runtime-config</code> принимает значения через запятую. Например, чтобы отключить batch/v1, используйте <code>--runtime-config=batch/v1=false</code>, а чтобы включить batch/v2alpha1, используйте флаг <code>--runtime-config=batch/v2alpha1</code>.
Флаг набор пар ключ-значение, указанных через запятую, который описывает конфигурацию во время выполнения сервера.</p><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong> Включение или отключение групп или ресурсов требует перезапуска apiserver и controller-manager для применения изменений <code>--runtime-config</code>.</div><h2 id=включение-определённых-ресурсов-в-группу-extensions-v1beta1>Включение определённых ресурсов в группу extensions/v1beta1</h2><p>DaemonSets, Deployments, StatefulSet, NetworkPolicies, PodSecurityPolicies и ReplicaSets в API-группе <code>extensions/v1beta1</code> по умолчанию отключены.
Например: чтобы включить deployments и daemonsets, используйте флаг <code>--runtime-config=extensions/v1beta1/deployments=true,extensions/v1beta1/daemonsets=true</code>.</p><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong> Включение/отключение отдельных ресурсов поддерживается только в API-группе <code>extensions/v1beta1</code> по историческим причинам.</div></div><div class=td-content style=page-break-before:always><h1 id=pg-110f33530cf761140cb1dab536baef04>1.4 - Работа с объектами Kubernetes</h1></div><div class=td-content><h1 id=pg-9f5adfa77f48c50d5cc81155a3cecb98>1.4.1 - Изучение объектов Kubernetes</h1><p>На этой странице объясняется, как объекты Kubernetes представлены в API Kubernetes, и как их можно определить в формате <code>.yaml</code>.</p><h2 id=kubernetes-objects>Изучение объектов Kubernetes</h2><p><em>Объекты Kubernetes</em> — сущности, которые хранятся в Kubernetes. Kubernetes использует их для представления состояния кластера. В частности, они описывают следующую информацию:</p><ul><li>Какие контейнеризированные приложения запущены (и на каких узлах).</li><li>Доступные ресурсы для этих приложений.</li><li>Стратегии управления приложения, которые относятся, например, к перезапуску, обновлению или отказоустойчивости.</li></ul><p>После создания объекта Kubernetes будет следить за существованием объекта. Создавая объект, вы таким образом указываете системе Kubernetes, какой должна быть рабочая нагрузка кластера; это <em>требуемое состояние</em> кластера.</p><p>Для работы с объектами Kubernetes – будь то создание, изменение или удаление — нужно использовать <a href=/docs/concepts/overview/kubernetes-api/>API Kubernetes</a>. Например, при использовании CLI-инструмента <code>kubectl</code>, он обращается к API Kubernetes. С помощью одной из <a href=/docs/reference/using-api/client-libraries/>клиентской библиотеки</a> вы также можете использовать API Kubernetes в собственных программах.</p><h3 id=спецификация-и-статус-объекта>Спецификация и статус объекта</h3><p>Почти в каждом объекте Kubernetes есть два вложенных поля-объекта, которые управляют конфигурацией объекта: <em><code>spec</code></em> и <em><code>status</code></em>.
При создании объекта в поле <code>spec</code> указывается <em>требуемое состояние</em> (описание характеристик, которые должны быть у объекта).</p><p>Поле <code>status</code> описывает <em>текущее состояние</em> объекта, которое создаётся и обновляется самим Kubernetes и его компонентами. <a class=glossary-tooltip title='Уровень оркестрации контейнеров с API и интерфейсами для определения, развёртывания и управления жизненным циклом контейнеров.' data-toggle=tooltip data-placement=top href='/ru/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='Плоскость управления'>Плоскость управления</a> Kubernetes непрерывно управляет фактическим состоянием каждого объекта, чтобы оно соответствовало требуемому состоянию, которое было задано пользователем.</p><p>Например: Deployment — это объект Kubernetes, представляющий работающее приложение в кластере. При создании объекта Deployment вы можете указать в его поле <code>spec</code>, что хотите иметь три реплики приложения. Система Kubernetes получит спецификацию объекта Deployment и запустит три экземпляра приложения, таким образом обновит статус (состояние) объекта, чтобы он соответствовал заданной спецификации. В случае сбоя одного из экземпляров (это влечет за собой изменение состояние), Kubernetes обнаружит несоответствие между спецификацией и статусом и исправит его, т.е. активирует новый экземпляр вместо того, который вышел из строя.</p><p>Для получения дополнительной информации о спецификации объекта, статусе и метаданных смотрите документ с <a href=https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md>соглашениями API Kubernetes</a>.</p><h3 id=описание-объекта-kubernetes>Описание объекта Kubernetes</h3><p>При создании объекта в Kubernetes нужно передать спецификацию объекта, которая содержит требуемое состояние, а также основную информацию об объекте (например, его имя). Когда вы используете API Kubernetes для создания объекта (напрямую либо через <code>kubectl</code>), соответствующий API-запрос должен включать в теле запроса всю указанную информацию в JSON-формате. <strong>В большинстве случаев вы будете передавать <code>kubectl</code> эти данные, записанные в файле .yaml</strong>. Тогда инструмент <code>kubectl</code> преобразует их в формат JSON при выполнении запроса к API.</p><p>Ниже представлен пример <code>.yaml</code>-файла, в котором заданы обязательные поля и спецификация объекта, необходимая для объекта Deployment в Kubernetes:</p><div class=highlight><div class=copy-code-icon style=text-align:right><a href=https://raw.githubusercontent.com/kubernetes/website/main/content/ru/examples/application/deployment.yaml download=application/deployment.yaml><code>application/deployment.yaml</code></a>
<img src=/images/copycode.svg style=max-height:24px;cursor:pointer onclick='copyCode("application-deployment-yaml")' title="Copy application/deployment.yaml to clipboard"></img></div><div class=includecode id=application-deployment-yaml><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb> </span><span style=color:#080;font-style:italic># до версии 1.9.0 нужно использовать apps/v1beta2</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>replicas</span>:<span style=color:#bbb> </span><span style=color:#666>2</span><span style=color:#bbb> </span><span style=color:#080;font-style:italic># запускает 2 пода, созданных по шаблону</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>template</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div></div></div><p>Один из способов создания объекта Deployment с помощью файла <code>.yaml</code>, показанного выше — использовать команду <a href=/docs/reference/generated/kubectl/kubectl-commands#apply><code>kubectl apply</code></a>, которая принимает в качестве аргумента файл в формате <code>.yaml</code>. Например:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://k8s.io/examples/application/deployment.yaml --record
</span></span></code></pre></div><p>Вывод будет примерно таким:</p><pre tabindex=0><code>deployment.apps/nginx-deployment created
</code></pre><h3 id=обязательные-поля>Обязательные поля</h3><p>В файле <code>.yaml</code> создаваемого объекта Kubernetes необходимо указать значения для следующих полей:</p><ul><li><code>apiVersion</code> — используемая для создания объекта версия API Kubernetes</li><li><code>kind</code> — тип создаваемого объекта</li><li><code>metadata</code> — данные, позволяющие идентифицировать объект (<code>name</code>, <code>UID</code> и необязательное поле <code>namespace</code>)</li><li><code>spec</code> — требуемое состояние объекта</li></ul><p>Конкретный формат поля-объекта <code>spec</code> зависит от типа объекта Kubernetes и содержит вложенные поля, предназначенные только для используемого объекта. В <a href=/docs/reference/generated/kubernetes-api/v1.25/>справочнике API Kubernetes</a> можно найти формат спецификации любого объекта Kubernetes.
Например, формат <code>spec</code> для объекта Pod находится в <a href=/docs/reference/generated/kubernetes-api/v1.25/#podspec-v1-core>ядре PodSpec v1</a>, а формат <code>spec</code> для Deployment — в <a href=/docs/reference/generated/kubernetes-api/v1.25/#deploymentspec-v1-apps>DeploymentSpec v1 apps</a>.</p><h2 id=что-дальше>Что дальше</h2><ul><li><a href=/docs/reference/using-api/api-overview/>Обзор API Kubernetes</a> более подробно объясняет некоторые из API-концепций</li><li>Познакомиться с наиболее важными и основными объектами в Kubernetes, например, с <a href=/docs/concepts/workloads/pods/pod-overview/>подами</a>.</li><li>Узнать подробнее про <a href=/docs/concepts/architecture/controller/>контролеры</a> в Kubernetes</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-6751db8ff5409476de8225d17d6c42dd>1.4.2 - Управление объектами Kubernetes</h1><p>В инструменте командной строки <code>kubectl</code> есть несколько разных способов создания и управления объектами Kubernetes. На этой странице рассматриваются различные подходы. Изучите <a href=https://kubectl.docs.kubernetes.io>документацию по Kubectl</a> для получения подробной информации по управлению объектами с помощью Kubectl.</p><h2 id=способы-управления>Способы управления</h2><div class="alert alert-danger warning callout" role=alert><strong>Предупреждение:</strong> Используйте только один способ для управления объектами Kubernetes. Применение нескольких методов управления к одному и тому же объекту может привести к неопределенному поведению.</div><table><thead><tr><th>Способ управления</th><th>Область применения</th><th>Рекомендуемое окружение</th><th>Количество поддерживаемых авторов</th><th>Трудность изучения</th></tr></thead><tbody><tr><td>Императивные команды</td><td>Активные объекты</td><td>Проекты в стадии разработки</td><td>1+</td><td>Низкая</td></tr><tr><td>Императивная конфигурация объекта</td><td>Отдельные файлы</td><td>Продакшен-проекты</td><td>1</td><td>Средняя</td></tr><tr><td>Декларативная конфигурация объекта</td><td>Директории или файлы</td><td>Продакшен-проекты</td><td>1+</td><td>Сложная</td></tr></tbody></table><h2 id=императивные-команды>Императивные команды</h2><p>При использовании императивных команд пользователь работает непосредственно с активными (текущими) объектами в кластере. Пользователь указывает выполняемые операции команде <code>kubectl</code> в качестве аргументов или флагов.</p><p>Это самый простой способ начать или выполнять одноразовые задачи в кластере. Из-за того, что происходит работа с активными объектами напрямую, нет возможности посмотреть историю предыдущих конфигураций.</p><h3 id=примеры>Примеры</h3><p>Запустите экземпляр контейнера nginx, посредством создания объекта Deployment:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl run nginx --image nginx
</span></span></code></pre></div><p>То же самое, но с другим синтаксисом:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl create deployment nginx --image nginx
</span></span></code></pre></div><h3 id=плюсы-и-минусы>Плюсы и минусы</h3><p>Преимущества по сравнению с конфигурацией объекта:</p><ul><li>Простые команды, которые легко выучить и запомнить.</li><li>Для применения изменений в кластер нужно только выполнить команды.</li></ul><p>Недостатки по сравнению с конфигурацией объекта:</p><ul><li>Команды не интегрированы с процессом проверки (обзора) изменений.</li><li>У команд нет журнала с изменениями.</li><li>Команды не дают источник записей, за исключением активных объектов.</li><li>Команды не содержат шаблон для создания новых объектов.</li></ul><h2 id=императивная-конфигурация-объекта>Императивная конфигурация объекта</h2><p>В случае использования императивной конфигурации объекта команде kubectl устанавливают действие (создание, замена и т.д.), необязательные флаги и как минимум одно имя файла. Файл должен содержать полное определение объекта в формате YAML или JSON.</p><p>Посмотрите <a href=/docs/reference/generated/kubernetes-api/v1.25/>Справочник API</a> для получения более подробной информации про определения объекта.</p><div class="alert alert-danger warning callout" role=alert><strong>Предупреждение:</strong> Императивная команда <code>replace</code> заменяет существующую спецификацию новой (переданной), удаляя все изменения в объекте, которые не определены в конфигурационном файле. Такой подход не следует использовать для типов ресурсов, спецификации которых обновляются независимо от конфигурационного файла.
Например, поле <code>externalIPs</code> в сервисах типа <code>LoadBalancer</code> обновляется кластером независимо от конфигурации.</div><h3 id=примеры-1>Примеры</h3><p>Создать объекты, определенные в конфигурационном файле:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl create -f nginx.yaml
</span></span></code></pre></div><p>Удалить объекты, определенные в двух конфигурационных файлах:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl delete -f nginx.yaml -f redis.yaml
</span></span></code></pre></div><p>Обновить объекты, определенные в конфигурационном файле, перезаписав текущую конфигурацию:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl replace -f nginx.yaml
</span></span></code></pre></div><h3 id=плюсы-и-минусы-1>Плюсы и минусы</h3><p>Преимущества по сравнению с императивными командами:</p><ul><li>Конфигурация объекта может храниться в системе управления версиями, такой как Git.</li><li>Конфигурация объекта может быть интегрирована с процессами проверки изменений и логирования.</li><li>Конфигурация объекта предусматривает шаблон для создания новых объектов.</li></ul><p>Недостатки по сравнению с императивными командами:</p><ul><li>Конфигурация объекта требует наличие общего представления об схеме объекта.</li><li>Конфигурация объекта предусматривает написание файла YAML.</li></ul><p>Преимущества по сравнению с декларативной конфигурацией объекта:</p><ul><li>Императивная конфигурация объекта проще и легче для понимания.</li><li>Начиная с Kubernetes 1.5, конфигурация императивных объектов стала лучше и совершеннее.</li></ul><p>Недостатки по сравнению с декларативной конфигурацией объекта:</p><ul><li>Императивная конфигурация объекта наилучшим образом работает с файлами, а не с директориями.</li><li>Обновления текущих объектов должны быть описаны в файлах конфигурации, в противном случае они будут потеряны при следующей замене.</li></ul><h2 id=декларативная-конфигурация-объекта>Декларативная конфигурация объекта</h2><p>При использовании декларативной конфигурации объекта пользователь работает с локальными конфигурационными файлами объекта, при этом он не определяет операции, которые будут выполняться над этими файлами. Операции создания, обновления и удаления автоматически для каждого объекта определяются <code>kubectl</code>. Этот механизм позволяет работать с директориями, в ситуациях, когда для разных объектов может потребоваться выполнение других операций.</p><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong> Декларативная конфигурация объекта сохраняет изменения, сделанные другими, даже если эти изменения не будут зафиксированы снова в конфигурационный файл объекта.
Это достигается путем использования API-операции <code>patch</code>, чтобы записать только обнаруженные изменения, а не использовать для этого API-операцию <code>replace</code>, которая полностью заменяет конфигурацию объекта.</div><h3 id=примеры-2>Примеры</h3><p>Обработать все конфигурационные файлы объектов в директории <code>configs</code> и создать либо частично обновить активные объекты. Сначала можно выполнить <code>diff</code>, чтобы посмотреть, какие изменения будут внесены, и только после этого применить их:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl diff -f configs/
</span></span><span style=display:flex><span>kubectl apply -f configs/
</span></span></code></pre></div><p>Рекурсивная обработка директорий:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>kubectl diff -R -f configs/
</span></span><span style=display:flex><span>kubectl apply -R -f configs/
</span></span></code></pre></div><h3 id=плюсы-и-минусы-2>Плюсы и минусы</h3><p>Преимущества по сравнению с императивной конфигурацией объекта:</p><ul><li>Изменения, внесенные непосредственно в активные объекты, будут сохранены, даже если они не отражены в конфигурационных файлах.</li><li>Декларативная конфигурация объекта лучше работает с директориями и автоматически определяет тип операции (создание, частичное обновление, удаление) каждого объекта.</li></ul><p>Недостатки по сравнению с императивной конфигурацией объекта:</p><ul><li>Декларативную конфигурацию объекта сложнее отладить и понять, когда можно получить неожиданные результаты.</li><li>Частичные обновления с использованием различий приводит к сложным операциям слияния и исправления.</li></ul><h2 id=что-дальше>Что дальше</h2><ul><li><a href=/docs/tasks/manage-kubernetes-objects/imperative-command/>Управление объектами Kubernetes с помощью императивных команд</a></li><li><a href=/docs/tasks/manage-kubernetes-objects/imperative-config/>Управление объектами Kubernetes с помощью императивной конфигурации объекта</a></li><li><a href=/docs/tasks/manage-kubernetes-objects/declarative-config/>Управление объектами Kubernetes с помощью декларативной конфигурации объекта</a></li><li><a href=/docs/tasks/manage-kubernetes-objects/kustomization/>Управление объектами Kubernetes с помощью Kustomize (декларативный способ)</a></li><li><a href=/docs/reference/generated/kubectl/kubectl-commands/>Справочник по командам Kubectl</a></li><li><a href=https://kubectl.docs.kubernetes.io>Документация Kubectl</a></li><li><a href=/docs/reference/generated/kubernetes-api/v1.25/>Справочник API Kubernetes</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-f37749a83c2916b63279ea60f3cfe53e>1.4.3 - Имена и идентификаторы объектов</h1><p>Каждый объект в кластере имеет уникальное <a href=#%D0%B8%D0%BC%D0%B5%D0%BD%D0%B0><em>имя</em></a> для конкретного типа ресурса.
Кроме этого, у каждого объекта Kubernetes есть собственный <a href=#%D0%B8%D0%B4%D0%B5%D0%BD%D1%82%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%82%D0%BE%D1%80%D1%8B><em>уникальный идентификатор (UID)</em></a> в пределах кластера.</p><p>Например, в одном и том же <a href=/ru/docs/concepts/overview/working-with-objects/namespaces/>пространстве имён</a> может быть только один Pod-объект с именем <code>myapp-1234</code>, и при этом существовать объект Deployment с этим же названием <code>myapp-1234</code>.</p><p>Для создания пользовательских неуникальных атрибутов у Kubernetes есть <a href=/ru/docs/concepts/overview/working-with-objects/labels/>метки</a> и <a href=/ru/docs/concepts/overview/working-with-objects/annotations/>аннотации</a>.</p><h2 id=имена>Имена</h2><p>Клиентская строка, предназначенная для ссылки на объект в URL-адресе ресурса, например <code>/api/v1/pods/some-name</code>.</p><p>Указанное имя может иметь только один объект определённого типа. Но если вы удалите этот объект, вы можете создать новый с таким же именем</p><p>Ниже перечислены три типа распространённых требований к именам ресурсов.</p><h3 id=имена-поддоменов-dns>Имена поддоменов DNS</h3><p>Большинству типов ресурсов нужно указать имя, используемое в качестве имени поддомена DNS в соответствии с <a href=https://tools.ietf.org/html/rfc1123>RFC 1123</a>. Соответственно, имя должно:</p><ul><li>содержать не более 253 символов</li><li>иметь только строчные буквенно-цифровые символы, '-' или '.'</li><li>начинаться с буквенно-цифрового символа</li><li>заканчивается буквенно-цифровым символом</li></ul><h3 id=имена-меток-dns>Имена меток DNS</h3><p>Некоторые типы ресурсов должны соответствовать стандарту меток DNS, который описан в <a href=https://tools.ietf.org/html/rfc1123>RFC 1123</a>. Таким образом, имя должно:</p><ul><li>содержать не более 63 символов</li><li>содержать только строчные буквенно-цифровые символы или '-'</li><li>начинаться с буквенно-цифрового символа</li><li>заканчивается буквенно-цифровым символом</li></ul><h3 id=имена-сегментов-пути>Имена сегментов пути</h3><p>Определённые имена типов ресурсов должны быть закодированы для использования в качестве сегмента пути. Проще говоря, имя не может быть "." или "..", а также не может содержать "/" или "%".</p><p>Пример файла манифеста пода <code>nginx-demo</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong> У отдельных типов ресурсов есть дополнительные ограничения именования.</div><h2 id=уникальные-идентификаторы>Уникальные идентификаторы</h2><p>Уникальная строка, сгенерированная самим Kubernetes, для идентификации объектов.</p><p>У каждого объекта, созданного в течение всего периода работы кластера Kubernetes, есть собственный уникальный идентификатор (UID). Он предназначен для выяснения различий между событиями похожих сущностей.</p><p>Уникальные идентификатор (UID) в Kubernetes — это универсальные уникальные идентификаторы (известные также как Universally Unique IDentifier, сокращенно UUID).
Эти идентификаторы стандартизированы под названием ISO/IEC 9834-8, а также как ITU-T X.667.</p><h2 id=что-дальше>Что дальше</h2><ul><li>Узнать подробнее про <a href=/ru/docs/concepts/overview/working-with-objects/labels/>метки</a> в Kubernetes.</li><li>Посмотреть архитектуру <a href=https://git.k8s.io/community/contributors/design-proposals/architecture/identifiers.md>идентификаторов и имён Kubernetes</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-1127165f472b7181b9c1d5a0b187d620>1.4.4 - Пространства имён</h1><p>Kubernetes поддерживает несколько виртуальных кластеров в одном физическом кластере. Такие виртуальные кластеры называются пространствами имён.</p><h2 id=причины-использования-нескольких-пространств-имён>Причины использования нескольких пространств имён</h2><p>Пространства имён применяются в окружениях с многочисленными пользователями, распределенными по нескольким командам или проектам. Пространства имён не нужно создавать, если есть кластеры с небольшим количеством пользователей (например, десяток пользователей). Пространства имён имеет смысл использовать, когда необходима такая функциональность.</p><p>Пространства имён определяют область имён. Имена ресурсов должны быть уникальными в пределах одного и того же пространства имён. Пространства имён не могут быть вложенными, а каждый ресурс Kubernetes может находиться только в одном пространстве имён.</p><p>Пространства имён — это способ разделения ресурсов кластера между несколькими пользователями (с помощью <a href=/docs/concepts/policy/resource-quotas/>квоты ресурсов</a>).</p><p>По умолчанию в будущих версиях Kubernetes объекты в одном и том же пространстве имён будут иметь одинаковую политику контроля доступа.</p><p>Не нужно использовать пространства имён только для разделения слегка отличающихся ресурсов, например, в случае разных версий одного и того же приложения. Используйте <a href=/ru/docs/concepts/overview/working-with-objects/labels/>метки</a>, чтобы различать ресурсы в рамках одного пространства имён.</p><h2 id=использование-пространств-имён>Использование пространств имён</h2><p>Создание и удаление пространств имён описаны в <a href=/docs/admin/namespaces>руководстве администратора по пространствам имён</a>.</p><h3 id=просмотр-пространств-имён>Просмотр пространств имён</h3><p>Используйте следующую команду, чтобы вывести список существующих пространств имён в кластере:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get namespace
</span></span></code></pre></div><pre tabindex=0><code>NAME          STATUS    AGE
default       Active    1d
kube-system   Active    1d
kube-public   Active    1d
</code></pre><p>По умолчанию в Kubernetes определены три пространства имён:</p><ul><li><code>default</code> — пространство имён по умолчанию для объектов без какого-либо другого пространства имён.</li><li><code>kube-system</code> — пространство имён для объектов, созданных Kubernetes</li><li><code>kube-public</code> — создаваемое автоматически пространство имён, которое доступно для чтения всем пользователям (включая также неаутентифицированных пользователей). Как правило, это пространство имён используется кластером, если некоторые ресурсы должны быть общедоступными для всего кластера. Главная особенность этого пространства имён — оно всего лишь соглашение, а не требование.</li></ul><h3 id=определение-пространства-имён-для-отдельных-команд>Определение пространства имён для отдельных команд</h3><p>Используйте флаг <code>--namespace</code>, чтобы определить пространство имён только для текущего запроса.</p><p>Примеры:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl run nginx --image<span style=color:#666>=</span>nginx --namespace<span style=color:#666>=</span>&lt;insert-namespace-name-here&gt;
</span></span><span style=display:flex><span>kubectl get pods --namespace<span style=color:#666>=</span>&lt;insert-namespace-name-here&gt;
</span></span></code></pre></div><h3 id=определение-пространства-имён-для-всех-команд>Определение пространства имён для всех команд</h3><p>Можно определить пространство имён, которое должно использоваться для всех выполняемых команд kubectl в текущем контексте.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl config set-context --current --namespace<span style=color:#666>=</span>&lt;insert-namespace-name-here&gt;
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Проверка</span>
</span></span><span style=display:flex><span>kubectl config view --minify | grep namespace:
</span></span></code></pre></div><h2 id=пространства-имён-и-dns>Пространства имён и DNS</h2><p>При создании <a href=/docs/user-guide/services>сервиса</a> создаётся соответствующая ему <a href=/docs/concepts/services-networking/dns-pod-service/>DNS-запись</a>.
Эта запись вида <code>&lt;service-name>.&lt;namespace-name>.svc.cluster.local</code> означает, что если контейнер использует только <code>&lt;service-name></code>, то он будет локальным сервисом в пространстве имён. Это позволит применять одну и ту же конфигурацию в нескольких пространствах имен (например, development, staging и production). Если нужно обращаться к другим пространствам имён, то нужно использовать полностью определенное имя домена (FQDN).</p><h2 id=объекты-без-пространства-имён>Объекты без пространства имён</h2><p>Большинство ресурсов Kubernetes (например, поды, сервисы, контроллеры репликации и другие) расположены в определённых пространствах имён. При этом сами ресурсы пространства имён не находятся ни в других пространствах имён. А такие низкоуровневые ресурсы, как <a href=/docs/admin/node>узлы</a> и persistentVolumes, не принадлежат ни одному пространству имён.</p><p>Чтобы посмотреть, какие ресурсы Kubernetes находятся в пространстве имён, а какие — нет, используйте следующие команды:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#080;font-style:italic># Ресурсы в пространстве имён</span>
</span></span><span style=display:flex><span>kubectl api-resources --namespaced<span style=color:#666>=</span><span style=color:#a2f>true</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-style:italic># Ресурсы, не принадлежавшие ни одному пространству имён</span>
</span></span><span style=display:flex><span>kubectl api-resources --namespaced<span style=color:#666>=</span><span style=color:#a2f>false</span>
</span></span></code></pre></div><h2 id=что-дальше>Что дальше</h2><ul><li>Узнать подробнее про <a href=/docs/tasks/administer-cluster/namespaces/#creating-a-new-namespace>создание нового пространства имён</a>.</li><li>Узнать подробнее про <a href=/docs/tasks/administer-cluster/namespaces/#deleting-a-namespace>удаление пространства имён</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-f1dec4557fb8ffbac9f11390aaaf9fa4>1.4.5 - Метки и селекторы</h1><p><em>Метки</em> — это пары ключ-значение, которые добавляются к объектам, как поды.
Метки предназначены для идентификации атрибутов объектов, которые имеют значимость и важны для пользователей, но при этом не относятся напрямую к основной системе.
Метки можно использовать для группировки и выбора подмножеств объектов. Метки могут быть добавлены к объектам во время создания и изменены в любое время после этого.
Каждый объект может иметь набор меток в виде пары ключ-значение. Каждый ключ должен быть уникальным в рамках одного и того же объекта.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#b44>&#34;metadata&#34;</span><span>:</span> {
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;labels&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;key1&#34;</span> : <span style=color:#b44>&#34;value1&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;key2&#34;</span> : <span style=color:#b44>&#34;value2&#34;</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Метки используются при получении и отслеживании объектов и в веб-панелях и CLI-инструментах. Любая неидентифицирующая информация должна быть записана в <a href=/ru/docs/concepts/overview/working-with-objects/annotations/>аннотации</a>.</p><h2 id=причины-использования>Причины использования</h2><p>Метки позволяют пользователям гибко сопоставить их организационные структуры с системными объектами, не требуя от клиентов хранить эти соответствия.</p><p>Развертывания сервисов и процессы пакетной обработки часто являются многомерными сущностями (например, множество разделов или развертываний, несколько групп выпусков, несколько уровней приложения, несколько микросервисов на каждый уровень приложения). Для управления часто требуются сквозные операции, которые нарушают инкапсуляцию строго иерархических представлений, особенно жестких иерархий, определяемых инфраструктурой, а не пользователями.</p><p>Примеры меток:</p><ul><li><code>"release" : "stable"</code>, <code>"release" : "canary"</code></li><li><code>"environment" : "dev"</code>, <code>"environment" : "qa"</code>, <code>"environment" : "production"</code></li><li><code>"tier" : "frontend"</code>, <code>"tier" : "backend"</code>, <code>"tier" : "cache"</code></li><li><code>"partition" : "customerA"</code>, <code>"partition" : "customerB"</code></li><li><code>"track" : "daily"</code>, <code>"track" : "weekly"</code></li></ul><p>Это всего лишь примеры часто используемых меток; конечно, вы можете использовать свои собственные. Помните о том, что ключ метки должна быть уникальной в пределах одного объекта.</p><h2 id=синтаксис-и-набор-символов>Синтаксис и набор символов</h2><p><em>Метки</em> представляют собой пары ключ-значение. Разрешенные ключи метки имеют два сегмента, разделённые слешем (<code>/</code>): префикс (необязательно) и имя. Сегмент имени обязателен и должен содержать не более 63 символов, среди которых могут быть буквенно-цифровые символы (<code>[a-z0-9A-Z]</code>), а также дефисы (<code>-</code>), знаки подчеркивания (<code>_</code>), точки (<code>.</code>). Префикс не обязателен, но он быть поддоменом DNS: набор меток DNS, разделенных точками (<code>.</code>), общей длиной не более 253 символов, за которыми следует слеш (<code>/</code>).</p><p>Если префикс не указан, ключ метки считается закрытым для пользователя. Компоненты автоматизированной системы (например, <code>kube-scheduler</code>, <code>kube-controller-manager</code>, <code>kube-apiserver</code>, <code>kubectl</code> или другие сторонние), которые добавляют метки к объектам пользователя, должны указывать префикс.</p><p>Префиксы <code>kubernetes.io/</code> и <code>k8s.io/</code> зарезервированы для использования основными компонентами Kubernetes.</p><p>Например, ниже представлен конфигурационный файл объекта Pod с двумя метками <code>environment: production</code> и <code>app: nginx</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>label-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>environment</span>:<span style=color:#bbb> </span>production<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=селекторы-меток>Селекторы меток</h2><p>В отличие от <a href=/docs/user-guide/identifiers>имен и идентификаторов</a>, метки не гарантируют уникальность. Поэтому мы предполагаем, что многие объекты будут иметь одинаковые метки.</p><p>С помощью <em>селектора меток</em> клиент/пользователь может идентифицировать набор объектов. Селектор меток — основное средство группировки в Kubernetes.</p><p>В настоящее время API поддерживает два типа селекторов: <em>на равенстве</em> и <em>на наборе</em>.
Селектор меток может состоять из нескольких <em>условий</em>, разделенных запятыми. В таком случае все условия должны быть выполнены, поэтому запятая-разделитель работает как логический оператор <em>И</em> (<code>&&</code>).</p><p>Работа пустых или неопределённых селекторов зависит от контекста. Типы API, которые использует селекторы, должны задокументировать это поведение.</p><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong> Для некоторых API-типов, например, ReplicaSets, селекторы меток двух экземпляров не должны дублироваться в пространстве имен, в противном случае контроллер может рассматривать их как конфликтующие инструкции и не сможет определить количество реплик.</div><div class="alert alert-warning caution callout" role=alert><strong>Внимание:</strong> Как для условий, основанных на равенстве, так и для условий на основе набора, не существует логического оператора <em>ИЛИ</em> (<code>||</code>). Убедитесь, что синтаксис фильтрации правильно составлен.</div><h3 id=условие-равенства>Условие <em>равенства</em></h3><p>Условия <em>равенства</em> или <em>неравенства</em> позволяют отфильтровать объекты по ключам и значениям меток. Сопоставляемые объекты должны удовлетворять всем указанным условиям меток, хотя при этом у объектов также могут быть заданы другие метки.
Доступны три оператора: <code>=</code>,<code>==</code>,<code>!=</code>. Первые два означают <em>равенство</em> (и являются всего лишь синонимами), а последний оператор определяет <em>неравенство</em>. Например:</p><pre tabindex=0><code>environment = production
tier != frontend
</code></pre><p>Первый пример выбирает все ресурсы с ключом <code>environment</code>, у которого значение указано <code>production</code>.
Последний получает все ресурсы с ключом <code>tier</code> без значения <code>frontend</code>, а также все ресурсы, в которых нет метки с ключом <code>tier</code>.
Используя оператор запятой можно совместить показанные два условия в одно, запросив ресурсы, в которых есть значение метки <code>production</code> и исключить <code>frontend</code>: <code>environment=production,tier!=frontend</code>.</p><p>С помощью условия равенства в объектах Pod можно указать, какие нужно выбрать ресурсы. Например, в примере ниже объект Pod выбирает узлы с меткой "<code>accelerator=nvidia-tesla-p100</code>".</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cuda-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cuda-test<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;k8s.gcr.io/cuda-vector-add:v0.1&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>      </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>limits</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>          </span><span style=color:green;font-weight:700>nvidia.com/gpu</span>:<span style=color:#bbb> </span><span style=color:#666>1</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>nodeSelector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>accelerator</span>:<span style=color:#bbb> </span>nvidia-tesla-p100<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=условие-набора>Условие <em>набора</em></h3><p>Условие меток <em>на основе набора</em> фильтрует ключи в соответствии с набором значений. Поддерживаются три вида операторов: <code>in</code>, <code>notin</code> и <code>exists</code> (только идентификатор ключа). Например:</p><pre tabindex=0><code>environment in (production, qa)
tier notin (frontend, backend)
partition
!partition
</code></pre><p>В первом примере выбираются все ресурсы с ключом <code>environment</code> и значением <code>production</code> или <code>qa</code>.
Во втором примере выбираются все ресурсы с ключом <code>tier</code> и любыми значениями, кроме <code>frontend</code> и <code>backend</code>, а также все ресурсы без меток с ключом <code>tier</code>.
Третий пример выбирает все ресурсы, включая метку с ключом <code>partition</code> (с любым значением).
В четвертом примере выбираются все ресурсы без метки с ключом <code>partition</code> (с любым значением).
Как и логический оператор <em>И</em> работает разделитель в виде запятой. Таким образом, фильтрация ресурсов по ключу <code>partition</code> (вне зависимости от значения) и ключу <code>environment</code> с любым значением, кроме <code>qa</code>, можно получить с помощью следующего выражения: <code>partition,environment notin (qa)</code>.
Селектор меток <em>на основе набора</em> — основная форма равенства, поскольку <code>environment=production</code> то же самое, что и <code>environment in (production)</code>; аналогично, оператор <code>!=</code> соответствует <code>notin</code>.</p><p>Условия <em>набора</em> могут использоваться одновременно с условия <em>равенства</em>. Например, так: <code>partition in (customerA, customerB),environment!=qa</code>.</p><h2 id=api>API</h2><h3 id=фильтрация-list-и-watch>Фильтрация LIST и WATCH</h3><p>Операции LIST и WATCH могут использовать параметр запроса, чтобы указать селекторы меток фильтрации наборов объектов. Есть поддержка обоих условий (строка запроса URL ниже показывается в исходном виде):</p><ul><li>Условия <em>на основе равенства</em>: <code>?labelSelector=environment%3Dproduction,tier%3Dfrontend</code></li><li>Условия <em>на основе набора</em>: <code>?labelSelector=environment+in+%28production%2Cqa%29%2Ctier+in+%28frontend%29</code></li></ul><p>Указанные выше формы селектора меток можно использовать для просмотра или отслеживания ресурсов через REST-клиент. Например, <code>apiserver</code> с <code>kubectl</code>, который использует <em>условие равенства</em>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l <span style=color:#b8860b>environment</span><span style=color:#666>=</span>production,tier<span style=color:#666>=</span>frontend
</span></span></code></pre></div><p>Либо используя условия <em>на основе набора</em>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l <span style=color:#b44>&#39;environment in (production),tier in (frontend)&#39;</span>
</span></span></code></pre></div><p>Как уже показывалось, <em>условия набора</em> дают больше возможностей. Например, в них можно использовать подобие оператора <em>И</em>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l <span style=color:#b44>&#39;environment in (production, qa)&#39;</span>
</span></span></code></pre></div><p>Либо можно воспользоваться исключающим сопоставлением с помощью оператора <em>exists</em>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods -l <span style=color:#b44>&#39;environment,environment notin (frontend)&#39;</span>
</span></span></code></pre></div><h3 id=установка-ссылок-в-api-объекты>Установка ссылок в API-объекты</h3><p>Некоторые объекты Kubernetes, такие как <a href=/docs/user-guide/services><code>services</code></a> и <a href=/docs/user-guide/replication-controller><code>replicationcontrollers</code></a>, также используют селекторы меток для ссылки на наборы из других ресурсов, например, <a href=/docs/user-guide/pods>подов</a>.</p><h4 id=service-и-replicationcontroller>Service и ReplicationController</h4><p>Набор подов, на которые указывает <code>service</code>, определяется через селектор меток. Аналогичным образом, количество подов, которыми должен управлять <code>replicationcontroller</code>, также формируются с использованием селектора меток.</p><p>Селекторы меток для обоих объектов записываются в словарях файлов формата <code>json</code> и <code>yaml</code>, при этом поддерживаются только селекторы с условием <em>равенства</em>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#b44>&#34;selector&#34;</span><span>:</span> {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;component&#34;</span> : <span style=color:#b44>&#34;redis&#34;</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Или:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>component</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span></code></pre></div><p>Этот селектор (как в формате <code>json</code>, так и в <code>yaml</code>) эквивалентен <code>component=redis</code> или <code>component in (redis)</code>.</p><h4 id=ресурсы-поддерживающие-условия-набора>Ресурсы, поддерживающие условия набора</h4><p>Новые ресурсы, такие как <a href=/docs/concepts/workloads/controllers/jobs-run-to-completion/><code>Job</code></a>, <a href=/docs/concepts/workloads/controllers/deployment/><code>Deployment</code></a>, <a href=/docs/concepts/workloads/controllers/replicaset/><code>ReplicaSet</code></a> и <a href=/docs/concepts/workloads/controllers/daemonset/><code>DaemonSet</code></a>, также поддерживают условия <em>набора</em>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>selector</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>matchLabels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>component</span>:<span style=color:#bbb> </span>redis<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>matchExpressions</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- {<span style=color:green;font-weight:700>key: tier, operator: In, values</span>:<span style=color:#bbb> </span>[cache]}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- {<span style=color:green;font-weight:700>key: environment, operator: NotIn, values</span>:<span style=color:#bbb> </span>[dev]}<span style=color:#bbb>
</span></span></span></code></pre></div><p><code>matchLabels</code> — словарь пар <code>{key,value}</code>. Каждая пара <code>{key,value}</code> в словаре <code>matchLabels</code> эквивалентна элементу <code>matchExpressions</code>, где поле <code>key</code> — "key", поле <code>operator</code> — "In", а массив <code>values</code> содержит только "value".
<code>matchExpressions</code> представляет собой список условий селектора пода. В качестве операторов могут быть In, NotIn, Exists и DoesNotExist. В случае использования In и NotIn должны заданы непустые значения. Все условия, как для <code>matchLabels</code>, так и для <code>matchExpressions</code>, объединяются с помощью логического И, поэтому при выборке объектов все они должны быть выполнены.</p><h4 id=выбор-наборов-узлов>Выбор наборов узлов</h4><p>Один из вариантов использования меток — возможность выбора набора узлов, в которых может быть развернут под.
Смотрите документацию про <a href=/docs/concepts/configuration/assign-pod-node/>выбор узлов</a>, чтобы получить дополнительную информацию.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-93cd7a1d4e1623e2bf01afc49a5af69c>1.4.6 - Аннотации</h1><p>Аннотации Kubernetes можно использовать для добавления собственных метаданных к объектам. Такие клиенты, как инструменты и библиотеки, могут получить эти метаданные.</p><h2 id=добавление-метаданных-к-объектам>Добавление метаданных к объектам</h2><p>Вы можете использовать метки или аннотации для добавления метаданных к объектам Kubernetes. Метки можно использовать для выбора объектов и для поиска коллекций объектов, которые соответствуют определенным условиям. В отличие от них аннотации не используются для идентификации и выбора объектов. Метаданные в аннотации могут быть маленькими или большими, структурированными или неструктурированными, кроме этого они включать символы, которые не разрешены в метках.</p><p>Аннотации, как и метки, являются коллекциями с наборами пар ключ-значение:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#b44>&#34;metadata&#34;</span><span>:</span> {
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;annotations&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;key1&#34;</span> : <span style=color:#b44>&#34;value1&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;key2&#34;</span> : <span style=color:#b44>&#34;value2&#34;</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Некоторые примеры информации, которая может быть в аннотациях:</p><ul><li><p>Поля, управляемые декларативным уровнем конфигурации. Добавление этих полей в виде аннотаций позволяет отличать их от значений по умолчанию, установленных клиентами или серверами, а также от автоматически сгенерированных полей и полей, заданных системами автоматического масштабирования.</p></li><li><p>Информация о сборке, выпуске или образе, например, метка времени, идентификаторы выпуска, ветка git, номера PR, хеши образов и адрес реестра.</p></li><li><p>Ссылки на репозитории логирования, мониторинга, аналитики или аудита.</p></li><li><p>Информация о клиентской библиотеке или инструменте, которая может использоваться при отладке (например, имя, версия и информация о сборке).</p></li><li><p>Информация об источнике пользователя или инструмента/системы, например, URL-адреса связанных объектов из других компонентов экосистемы.</p></li><li><p>Небольшие метаданные развертывания (например, конфигурация или контрольные точки).</p></li><li><p>Номера телефонов или пейджеров ответственных лиц или записи в справочнике, в которых можно найти нужную информацию, например, сайт группы.</p></li><li><p>Инструкции от конечных пользователей по исправлению работы или использования нестандартной функциональности.</p></li></ul><p>Вместо использования аннотаций, вы можете сохранить такого рода информацию во внешней базе данных или директории, хотя это усложнило бы создание общих клиентских библиотек и инструментов развертывания, управления, самодиагностики и т.д.</p><h2 id=синтаксис-и-набор-символов>Синтаксис и набор символов</h2><p><em>Аннотации</em> представляют собой пары ключ-значение. Разрешенные ключи аннотации имеют два сегмента, разделённые слешем (<code>/</code>): префикс (необязательно) и имя. Сегмент имени обязателен и должен содержать не более 63 символов, среди которых могут быть буквенно-цифровые символы(<code>[a-z0-9A-Z]</code>), а также дефисы (<code>-</code>), знаки подчеркивания (<code>_</code>), точки (<code>.</code>). Префикс не обязателен, но он быть поддоменом DNS: набор меток DNS, разделенных точками (<code>.</code>), общей длиной не более 253 символов, за которыми следует слеш (<code>/</code>).</p><p>Если префикс не указан, ключ аннотации считается закрытым для пользователя. Компоненты автоматизированной системы (например, <code>kube-scheduler</code>, <code>kube-controller-manager</code>, <code>kube-apiserver</code>, <code>kubectl</code> или другие сторонние), которые добавляют аннотации к объектам пользователя, должны указывать префикс.</p><p>Префиксы <code>kubernetes.io/</code> и <code>k8s.io/</code> зарезервированы для использования основными компонентами Kubernetes.</p><p>Например, ниже представлен конфигурационный файл объекта Pod с аннотацией <code>imageregistry: https://hub.docker.com/</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Pod<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>annotations-demo<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>annotations</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>imageregistry</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;https://hub.docker.com/&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>spec</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>containers</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>nginx<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>image</span>:<span style=color:#bbb> </span>nginx:1.14.2<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>ports</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>- <span style=color:green;font-weight:700>containerPort</span>:<span style=color:#bbb> </span><span style=color:#666>80</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=что-дальше>Что дальше</h2><p>Узнать подробнее про <a href=/ru/docs/concepts/overview/working-with-objects/labels/>метки и селекторы</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-046c03090d47bc4b89b818dc645c3865>1.4.7 - Селекторы полей</h1><p><em>Селекторы полей</em> позволяют <a href=/ru/docs/concepts/overview/working-with-objects/kubernetes-objects>выбирать ресурсы Kubernetes</a>, исходя из значения одного или нескольких полей ресурсов. Ниже приведены несколько примеров запросов селекторов полей:</p><ul><li><code>metadata.name=my-service</code></li><li><code>metadata.namespace!=default</code></li><li><code>status.phase=Pending</code></li></ul><p>Следующая команда <code>kubectl</code> выбирает все Pod-объекты, в которых значение поля <a href=/docs/concepts/workloads/pods/pod-lifecycle/#pod-phase><code>status.phase</code></a> равно <code>Running</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods --field-selector status.phase<span style=color:#666>=</span>Running
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong><p>По сути, селекторы полей являются <em>фильтрами</em> ресурсов. По умолчанию нет установленных селекторов/фильтров, поэтому выбираются ресурсы всех типов. Это означает, что два запроса <code>kubectl</code> ниже одинаковы:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods
</span></span><span style=display:flex><span>kubectl get pods --field-selector <span style=color:#b44>&#34;&#34;</span>
</span></span></code></pre></div></div><h2 id=поддерживаемые-поля>Поддерживаемые поля</h2><p>Доступные селекторы полей зависят от типа ресурса Kubernetes. У всех типов ресурсов есть поля <code>metadata.name</code> и <code>metadata.namespace</code>. При использовании несуществующего селекторов полей приведёт к возникновению ошибки. Например:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get ingress --field-selector foo.bar<span style=color:#666>=</span>baz
</span></span></code></pre></div><pre tabindex=0><code>Error from server (BadRequest): Unable to find &#34;ingresses&#34; that match label selector &#34;&#34;, field selector &#34;foo.bar=baz&#34;: &#34;foo.bar&#34; is not a known field selector: only &#34;metadata.name&#34;, &#34;metadata.namespace&#34;
</code></pre><h2 id=поддерживаемые-операторы>Поддерживаемые операторы</h2><p>Можно использовать операторы <code>=</code>, <code>==</code> и <code>!=</code> в селекторах полей (<code>=</code> и <code>==</code> — синонимы). Например, следующая команда <code>kubectl</code> выбирает все сервисы Kubernetes, не принадлежавшие пространству имен <code>default</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get services  --all-namespaces --field-selector metadata.namespace!<span style=color:#666>=</span>default
</span></span></code></pre></div><h2 id=составные-селекторы>Составные селекторы</h2><p>Аналогично <a href=/ru/docs/concepts/overview/working-with-objects/labels>метки</a> и другим селекторам, несколько селекторы полей могут быть объединены через запятую. Приведенная ниже команда <code>kubectl</code> выбирает все Pod-объекты, у которых значение поле <code>status.phase</code>, отличное от <code>Running</code>, а поле <code>spec.restartPolicy</code> имеет значение <code>Always</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get pods --field-selector<span style=color:#666>=</span>status.phase!<span style=color:#666>=</span>Running,spec.restartPolicy<span style=color:#666>=</span>Always
</span></span></code></pre></div><h2 id=множественные-типы-ресурсов>Множественные типы ресурсов</h2><p>Можно использовать селекторы полей с несколькими типами ресурсов одновременно. Команда <code>kubectl</code> выбирает все объекты StatefulSet и Services, не включенные в пространство имен <code>default</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get statefulsets,services --all-namespaces --field-selector metadata.namespace!<span style=color:#666>=</span>default
</span></span></code></pre></div></div><div class=td-content style=page-break-before:always><h1 id=pg-5dd62c6a4a481b4cf1ac50f6799eb581>1.4.8 - Рекомендуемые метки</h1><p>Вы можете визуализировать и управлять объектами Kubernetes не только с помощью kubectl и панели управления. С помощью единого набора меток можно единообразно описывать объекты, что позволяет инструментам согласованно работать между собой.</p><p>В дополнение к существующим инструментам, рекомендуемый набор меток описывают приложения в том виде, в котором они могут быть получены.</p><p>Метаданные сосредоточены на понятии <em>приложение</em>. Kubernetes — это не платформа как услуга (PaaS), поэтому не закрепляет формальное понятие приложения.
Вместо этого приложения являются неформальными и описываются через метаданные. Определение приложения довольно расплывчатое.</p><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong> Это рекомендуемые для использования метки. Они облегчают процесс управления приложениями, но при этом не являются обязательными для основных инструментов.</div><p>Общие метки и аннотации используют один и тот же префикс: <code>app.kubernetes.io</code>. Метки без префикса являются приватными для пользователей. Совместно используемый префикс гарантирует, что общие метки не будут влиять на пользовательские метки.</p><h2 id=метки>Метки</h2><p>Чтобы извлечь максимум пользы от использования таких меток, они должны добавляться к каждому ресурсному объекту.</p><table><thead><tr><th>Ключ</th><th>Описание</th><th>Пример</th><th>Тип</th></tr></thead><tbody><tr><td><code>app.kubernetes.io/name</code></td><td>Имя приложения</td><td><code>mysql</code></td><td>string</td></tr><tr><td><code>app.kubernetes.io/instance</code></td><td>Уникальное имя экземпляра приложения</td><td><code>wordpress-abcxzy</code></td><td>string</td></tr><tr><td><code>app.kubernetes.io/version</code></td><td>Текущая версия приложения (например, семантическая версия, хеш коммита и т.д.)</td><td><code>5.7.21</code></td><td>string</td></tr><tr><td><code>app.kubernetes.io/component</code></td><td>Имя компонента в архитектуре</td><td><code>database</code></td><td>string</td></tr><tr><td><code>app.kubernetes.io/part-of</code></td><td>Имя основного приложения, частью которого является текущий объект</td><td><code>wordpress</code></td><td>string</td></tr><tr><td><code>app.kubernetes.io/managed-by</code></td><td>Инструмент управления приложением</td><td><code>helm</code></td><td>string</td></tr></tbody></table><p>Для демонстрации этих меток, рассмотрим следующий объект <code>StatefulSet</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StatefulSet<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>wordpress-abcxzy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;5.7.21&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/component</span>:<span style=color:#bbb> </span>database<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/part-of</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/managed-by</span>:<span style=color:#bbb> </span>helm<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=приложения-и-экземпляры-приложений>Приложения и экземпляры приложений</h2><p>Одно и то же приложение может быть установлено несколько раз в кластер Kubernetes, в ряде случаев — в одинаковое пространство имен. Например, WordPress может быть установлен более одного раза, тогда каждый из сайтов будет иметь собственный установленный экземпляр WordPress.</p><p>Имя приложения и имя экземпляра хранятся по отдельности. Например, WordPress имеет ключ <code>app.kubernetes.io/name</code> со значением <code>wordpress</code>, при этом у него есть имя экземпляра, представленное ключом <code>app.kubernetes.io/instance</code> со значением <code>wordpress-abcxzy</code>. Такой механизм позволяет идентифицировать как приложение, так и экземпляры приложения. У каждого экземпляра приложения должно быть уникальное имя.</p><h2 id=примеры>Примеры</h2><p>Следующие примеры показывают разные способы использования общих меток, поэтому они различаются по степени сложности.</p><h3 id=простой-сервис-без-состояния>Простой сервис без состояния</h3><p>Допустим, у нас есть простой сервис без состояния, развернутый с помощью объектов <code>Deployment</code> и <code>Service</code>. Следующие два фрагмента конфигурации показывают, как можно использовать метки в самом простом варианте.</p><p>Объект <code>Deployment</code> используется для наблюдения за подами, на которых запущено приложение.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>myservice<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>myservice-abcxzy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Объект <code>Service</code> используется для открытия доступа к приложению.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>myservice<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>myservice-abcxzy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=веб-приложение-с-базой-данных>Веб-приложение с базой данных</h3><p>Рассмотрим случай немного посложнее: веб-приложение (WordPress), которое использует базу данных (MySQL), установленное с помощью Helm. В следующих фрагментов конфигурации объектов отображена отправная точка развертывания такого приложения.</p><p>Следующий объект <code>Deployment</code> используется для WordPress:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Deployment<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>wordpress-abcxzy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;4.9.4&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/managed-by</span>:<span style=color:#bbb> </span>helm<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/component</span>:<span style=color:#bbb> </span>server<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/part-of</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Объект <code>Service</code> используется для открытия доступа к WordPress:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>wordpress-abcxzy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;4.9.4&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/managed-by</span>:<span style=color:#bbb> </span>helm<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/component</span>:<span style=color:#bbb> </span>server<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/part-of</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>MySQL открывается в виде <code>StatefulSet</code> с метаданными как для самого приложения, так и основного (родительского) приложения, к которому принадлежит СУБД:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>apps/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>StatefulSet<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>mysql-abcxzy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;5.7.21&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/managed-by</span>:<span style=color:#bbb> </span>helm<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/component</span>:<span style=color:#bbb> </span>database<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/part-of</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Объект <code>Service</code> предоставляет MySQL в составе WordPress:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>Service<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>labels</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/name</span>:<span style=color:#bbb> </span>mysql<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/instance</span>:<span style=color:#bbb> </span>mysql-abcxzy<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/version</span>:<span style=color:#bbb> </span><span style=color:#b44>&#34;5.7.21&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/managed-by</span>:<span style=color:#bbb> </span>helm<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/component</span>:<span style=color:#bbb> </span>database<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>app.kubernetes.io/part-of</span>:<span style=color:#bbb> </span>wordpress<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#00f;font-weight:700>...</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>Вы заметите, что <code>StatefulSet</code> и <code>Service</code> MySQL содержат больше информации о MySQL и WordPress.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-2bf36ccd6b3dbeafecf87c39761b07c7>2 - Кластерная Архитектура</h1><div class=lead>Архитектурные концепции, лежащие в основе Kubernetes.</div></div><div class=td-content><h1 id=pg-9ef2890698e773b6c0d24fd2c20146f5>2.1 - Узлы</h1><p>Kubernetes запускает ваши приложения, помещая контейнеры в Поды для запуска на Узлах (<em>Nodes</em>).
В зависимости от кластера, узел может быть виртуальной или физической машиной. Каждый узел
содержит сервисы, необходимые для запуска
<a class=glossary-tooltip title='Самый маленький и простой объект в Kubernetes. Под — это набор запущенных контейнеров в кластере.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Подов>Подов</a>, управляемых
<a class=glossary-tooltip title='Уровень оркестрации контейнеров с API и интерфейсами для определения, развёртывания и управления жизненным циклом контейнеров.' data-toggle=tooltip data-placement=top href='/ru/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='плоскостью управления'>плоскостью управления</a>.</p><p>Обычно у вас есть несколько узлов в кластере; однако в среде обучения или среде
с ограниченными ресурсами у вас может быть только один.</p><p><a href=/ru/docs/concepts/overview/components/##%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D1%8B-%D1%83%D0%B7%D0%BB%D0%B0>Компоненты</a> на узле включают
<a class=glossary-tooltip title='Агент, работающий на каждом узле в кластере. Он следит за тем, чтобы контейнеры были запущены в поде.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a>,
<a class=glossary-tooltip title='Среда выполнения контейнера — это программа, предназначенная для выполнения контейнеров.' data-toggle=tooltip data-placement=top href=/docs/setup/production-environment/container-runtimes target=_blank aria-label='среду выполнения контейнера'>среду выполнения контейнера</a> и
<a class=glossary-tooltip title='kube-proxy — сетевой прокси, работающий на каждом узле в кластере.' data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-proxy/ target=_blank aria-label=kube-proxy>kube-proxy</a>.</p><h2 id=управление>Управление</h2><p>Существует два основных способа добавления Узлов в <a class=glossary-tooltip title='Компонент панели управления, обслуживающий API Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-apiserver/ target=_blank aria-label='API сервер'>API сервер</a>:</p><ol><li>Kubelet на узле саморегистрируется в плоскости управления</li><li>Вы или другой пользователь вручную добавляете объект Узла</li></ol><p>После того как вы создадите объект Узла или kubelet на узле самозарегистируется,
плоскость управления проверяет, является ли новый объект Узла валидным (правильным). Например, если вы
попробуете создать Узел при помощи следующего JSON манифеста:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;kind&#34;</span>: <span style=color:#b44>&#34;Node&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;apiVersion&#34;</span>: <span style=color:#b44>&#34;v1&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>&#34;metadata&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;10.240.79.157&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;labels&#34;</span>: {
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>&#34;name&#34;</span>: <span style=color:#b44>&#34;my-first-k8s-node&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Kubernetes создает внутри себя объект Узла (представление). Kubernetes проверяет,
что kubelet зарегистрировался на API сервере, который совпадает со значением поля <code>metadata.name</code> Узла.
Если узел здоров (если все необходимые сервисы запущены),
он имеет право на запуск Пода. В противном случае этот узел игнорируется для любой активности кластера
до тех пор, пока он не станет здоровым.</p><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong><p>Kubernetes сохраняет объект для невалидного Узла и продолжает проверять, становится ли он здоровым.</p><p>Вы или <a class=glossary-tooltip title='Управляющий цикл который отслеживает общее состояние кластера через API-сервер и вносит изменения пытаясь приветси текушее состояние к желаемому состоянию.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=контроллер>контроллер</a> должны явно удалить объект Узла, чтобы
остановить проверку доступности узла.</p></div><p>Имя объекта Узла должно быть валидным
<a href=/ru/docs/concepts/overview/working-with-objects/names#%D0%B8%D0%BC%D0%B5%D0%BD%D0%B0-%D0%BF%D0%BE%D0%B4%D0%B4%D0%BE%D0%BC%D0%B5%D0%BD%D0%BE%D0%B2-dns>именем поддомена DNS</a>.</p><h3 id=саморегистрация-узлов>Саморегистрация Узлов</h3><p>Когда kubelet флаг <code>--register-node</code> имеет значение <em>true</em> (по умолчанию), то kubelet будет пытаться
зарегистрировать себя на API сервере. Это наиболее предпочтительная модель, используемая большинством дистрибутивов.</p><p>Для саморегистрации kubelet запускается со следующими опциями:</p><ul><li><p><code>--kubeconfig</code> - Путь к учетным данным для аутентификации на API сервере.</p></li><li><p><code>--cloud-provider</code> - Как общаться с <a class=glossary-tooltip title='Организация, которая предлагает платформу облачных вычислений.' data-toggle=tooltip data-placement=top href=/docs/concepts/cluster-administration/cloud-providers target=_blank aria-label='облачным провайдером'>облачным провайдером</a>, чтобы прочитать метаданные о себе.</p></li><li><p><code>--register-node</code> - Автоматически зарегистрироваться на API сервере.</p></li><li><p><code>--register-with-taints</code> - Зарегистрировать узел с приведенным списком <a class=glossary-tooltip title='A core object consisting of three required properties: key, value, and effect. Taints prevent the scheduling of pods on nodes or node groups.' data-toggle=tooltip data-placement=top href=/docs/concepts/scheduling-eviction/taint-and-toleration/ target=_blank aria-label='ограничений (taints)'>ограничений (taints)</a> (разделенных запятыми <code>&lt;key>=&lt;value>:&lt;effect></code>).</p><p>Ничего не делает, если <code>register-node</code> - <em>false</em>.</p></li><li><p><code>--node-ip</code> - IP-адрес узла.</p></li><li><p><code>--node-labels</code> - <a class=glossary-tooltip title='Группирует объекты на основе произвольных критериев, по которым пользователи могут их идентифицировать.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/labels target=_blank aria-label=Метки>Метки</a> для добавления при регистрации узла в кластере (смотрите ограничения для меток, установленные <a href=/docs/reference/access-authn-authz/admission-controllers/#noderestriction>плагином согласования (admission plugin) NodeRestriction</a>).</p></li><li><p><code>--node-status-update-frequency</code> - Указывает, как часто kubelet отправляет статус узла мастеру.</p></li></ul><p>Когда <a href=/docs/reference/access-authn-authz/node/>режим авторизации Узла</a> и
<a href=/docs/reference/access-authn-authz/admission-controllers/#noderestriction>плагин согласования NodeRestriction</a> включены,
kubelet'ы имеют право только создавать/изменять свой собственный ресурс Узла.</p><h3 id=ручное-администрирование-узла>Ручное администрирование узла</h3><p>Вы можете создавать и изменять объекты узла используя
<a class=glossary-tooltip title='A command line tool for communicating with a Kubernetes cluster.' data-toggle=tooltip data-placement=top href=/docs/user-guide/kubectl-overview/ target=_blank aria-label=kubectl>kubectl</a>.</p><p>Когда вы хотите создать объекты Узла вручную, установите kubelet флаг <code>--register-node=false</code>.</p><p>Вы можете изменять объекты Узла независимо от настройки <code>--register-node</code>.
Например, вы можете установить метки на существующем Узле или пометить его не назначаемым.</p><p>Вы можете использовать метки на Узлах в сочетании с селекторами узла на Подах для управления планированием.
Например, вы можете ограничить Под, иметь право на запуск только на группе доступных узлов.</p><p>Маркировка узла как не назначаемого предотвращает размещение планировщиком новых подов на этом Узле,
но не влияет на существующие Поды на Узле. Это полезно в качестве
подготовительного шага перед перезагрузкой узла или другим обслуживанием.</p><p>Чтобы отметить Узел не назначаемым, выполните:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl cordon <span style=color:#b8860b>$NODENAME</span>
</span></span></code></pre></div><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong> Поды, являющиеся частью <a class=glossary-tooltip title='Гарантирует, что копия Pod выполняется в наборе узлов кластера.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/daemonset target=_blank aria-label=DaemonSet>DaemonSet</a> допускают
запуск на не назначаемом Узле. DaemonSets обычно обеспечивает локальные сервисы узла,
которые должны запускаться на Узле, даже если узел вытесняется для запуска приложений.</div><h2 id=статус-узла>Статус Узла</h2><p>Статус узла содержит следующие данные:</p><ul><li><a href=#%D0%B0%D0%B4%D1%80%D0%B5%D1%81%D0%B0>Адреса (Addresses)</a></li><li><a href=#%D1%83%D1%81%D0%BB%D0%BE%D0%B2%D0%B8%D0%B5>Условия (Conditions)</a></li><li><a href=#%D0%B5%D0%BC%D0%BA%D0%BE%D1%81%D1%82%D1%8C>Емкость и Выделяемые ресурсы (Capacity and Allocatable)</a></li><li><a href=#%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%86%D0%B8%D1%8F>Информация (Info)</a></li></ul><p>Вы можете использовать <code>kubectl</code> для просмотра статуса Узла и других деталей:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl describe node &lt;insert-node-name-here&gt;
</span></span></code></pre></div><p>Каждая секция из вывода команды описана ниже.</p><h3 id=адреса-addresses>Адреса (Addresses)</h3><p>Использование этих полей варьируется в зависимости от вашего облачного провайдера или конфигурации физических серверов (<em>bare metal</em>).</p><ul><li>HostName: Имя хоста, сообщаемое ядром узла. Может быть переопределено через kubelet <code>--hostname-override</code> параметр.</li><li>ExternalIP: Обычно, IP адрес узла, который является внешне маршрутизируемым (доступен за пределами кластера).</li><li>InternalIP: Обычно, IP адрес узла, который маршрутизируется только внутри кластера.</li></ul><h3 id=условие>Условия (Conditions)</h3><p>Поле <code>conditions</code> описывает статус всех <code>Running</code> узлов. Примеры условий включают в себя:</p><table><caption style=display:none>Условия узла и описание того, когда применяется каждое условие.</caption><thead><tr><th>Условие Узла</th><th>Описание</th></tr></thead><tbody><tr><td><code>Ready</code></td><td><code>True</code> если узел здоров и готов принять поды, <code>False</code> если узел нездоров и не принимает поды, и <code>Unknown</code> если контроллер узла не получал информацию от узла в течение последнего периода <code>node-monitor-grace-period</code> (по умолчанию 40 секунд)</td></tr><tr><td><code>DiskPressure</code></td><td><code>True</code> если присутствует давление на размер диска - то есть, если емкость диска мала; иначе <code>False</code></td></tr><tr><td><code>MemoryPressure</code></td><td><code>True</code> если существует давление на память узла - то есть, если памяти на узле мало; иначе <code>False</code></td></tr><tr><td><code>PIDPressure</code></td><td><code>True</code> если существует давление на процессы - то есть, если на узле слишком много процессов; иначе <code>False</code></td></tr><tr><td><code>NetworkUnavailable</code></td><td><code>True</code> если сеть для узла настроена некорректно, иначе <code>False</code></td></tr></tbody></table><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong> Если вы используете инструменты командной строки для вывода сведений об блокированном узле,
то Условие включает <code>SchedulingDisabled</code>. <code>SchedulingDisabled</code> не является Условием в Kubernetes API;
вместо этого блокированные узлы помечены как Не назначаемые в их спецификации.</div><p>Состояние узла представлено в виде JSON объекта. Например, следующая структура описывает здоровый узел:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span><span style=color:#b44>&#34;conditions&#34;</span><span>:</span> [
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;type&#34;</span>: <span style=color:#b44>&#34;Ready&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;status&#34;</span>: <span style=color:#b44>&#34;True&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;reason&#34;</span>: <span style=color:#b44>&#34;KubeletReady&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;message&#34;</span>: <span style=color:#b44>&#34;kubelet is posting ready status&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;lastHeartbeatTime&#34;</span>: <span style=color:#b44>&#34;2019-06-05T18:38:35Z&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>&#34;lastTransitionTime&#34;</span>: <span style=color:#b44>&#34;2019-06-05T11:41:27Z&#34;</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>]
</span></span></code></pre></div><p>Если значение параметра Status для условия Ready остается <code>Unknown</code> или <code>False</code>
дольше чем период <code>pod-eviction-timeout</code>(аргумент, переданный в
<a class=glossary-tooltip title='Компонент Control Plane запускает процессы контроллера.' data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-controller-manager/ target=_blank aria-label=kube-controller-manager>kube-controller-manager</a>), то все Поды
на узле планируются к удалению контроллером узла. По умолчанию таймаут выселения <strong>пять минут</strong>.
В некоторых случаях, когда узел недоступен, API сервер не может связаться с kubelet на узле.
Решение об удалении подов не может быть передано в kubelet до тех пор, пока связь с API сервером не будет восстановлена.
В то же время поды, которые запланированы к удалению, могут продолжать работать на отделенном узле.</p><p>Контроллер узла не будет принудительно удалять поды до тех пор, пока не будет подтверждено,
что они перестали работать в кластере. Вы можете видеть, что поды, которые могут работать на недоступном узле,
находятся в состоянии <code>Terminating</code> или <code>Unknown</code>. В тех случаях, когда Kubernetes не может сделать вывод
из основной инфраструктуры о том, что узел окончательно покинул кластер, администратору кластера может потребоваться
удалить объект узла вручную. Удаление объекта узла из Kubernetes приводит к удалению всех объектов Подов, запущенных
на узле, с API сервера и освобождает их имена.</p><p>Контроллер жизненного цикла узла автоматически создает
<a href=/docs/concepts/scheduling-eviction/taint-and-toleration/>ограничения (taints)</a>, которые представляют собой условия.
Планировщик учитывает ограничения Узла при назначении Пода на Узел.
Поды так же могут иметь допуски (tolerations), что позволяет им сопротивляться ограничениям Узла.</p><p>Смотрите раздел <a href=/docs/concepts/configuration/taint-and-toleration/#taint-nodes-by-condition>Ограничить Узлы по Условию</a>
для дополнительной информации.</p><h3 id=емкость>Емкость и Выделяемые ресурсы (Capacity and Allocatable)</h3><p>Описывает ресурсы, доступные на узле: CPU, память и максимальное количество подов,
которые могут быть запланированы на узле.</p><p>Поля в блоке capacity указывают общее количество ресурсов, которые есть на Узле.
Блок allocatable указывает количество ресурсов на Узле,
которые доступны для использования обычными Подами.</p><p>Вы можете прочитать больше о емкости и выделяемых ресурсах, изучая, как <a href=/docs/tasks/administer-cluster/reserve-compute-resources/#node-allocatable>зарезервировать вычислительные ресурсы</a> на Узле.</p><h3 id=информация-info>Информация (Info)</h3><p>Описывает общую информацию об узле, такую как версия ядра, версия Kubernetes (версии kubelet и kube-proxy), версия Docker (если используется) и название ОС.
Эта информация собирается Kubelet'ом на узле.</p><h3 id=контроллер-узла>Контроллер узла</h3><p><a class=glossary-tooltip title='Управляющий цикл который отслеживает общее состояние кластера через API-сервер и вносит изменения пытаясь приветси текушее состояние к желаемому состоянию.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label='Контроллер '>Контроллер</a> узла является компонентом
плоскости управления Kubernetes, который управляет различными аспектами узлов.</p><p>Контроллер узла играет различные роли в жизни узла. Первая - назначение CIDR-блока узлу
при его регистрации (если включено назначение CIDR).</p><p>Вторая - поддержание в актуальном состоянии внутреннего списка узлов контроллера узла
согласно списку доступных машин облачного провайдера. При работе в облачной среде всякий раз,
когда узел неисправен, контроллер узла запрашивает облачного провайдера, доступна ли
виртуальная машина для этого узла. Если нет, то контроллер узла удаляет узел из
своего списка узлов.</p><p>Третья - это мониторинг работоспособности узлов. Контроллер узла
отвечает за обновление условия NodeReady для NodeStatus на
ConditionUnknown, когда узел становится недоступным (т.е. контроллер узла
по какой-то причине перестает получать сердцебиения (heartbeats) от узла,
например, из-за того, что узел упал), и затем позже выселяет все поды с узла
(используя мягкое (graceful) завершение) если узел продолжает быть недоступным.
(По умолчанию таймауты составляют 40 секунд, чтобы начать сообщать <code>ConditionUnknown</code>,
и 5 минут после, чтобы начать выселять поды.)</p><p>Контроллер узла проверяет состояние каждого узла каждые <code>--node-monitor-period</code> секунд.</p><h4 id=сердцебиения>Сердцебиения</h4><p>Сердцебиения, посылаемые узлами Kubernetes, помогают определить доступность узла.</p><p>Существует две формы сердцебиений: обновление <code>NodeStatus</code> и
<a href=/docs/reference/generated/kubernetes-api/v1.25/#lease-v1-coordination-k8s-io>Lease объект</a>.
Каждый узел имеет связанный с ним Lease объект в <code>kube-node-lease</code>
<a class=glossary-tooltip title='An abstraction used by Kubernetes to support isolation of groups of resources within a single cluster.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/namespaces target=_blank aria-label=namespace>namespace</a>.
Lease - это легковесный ресурс, который улучшает производительность
сердцебиений узла при масштабировании кластера.</p><p>Kubelet отвечает за создание и обновление <code>NodeStatus</code> и Lease объекта.</p><ul><li>Kubelet обновляет <code>NodeStatus</code> либо когда происходит изменение статуса,
либо если в течение настроенного интервала обновления не было. По умолчанию
интервал для обновлений <code>NodeStatus</code> составляет 5 минут (намного больше,
чем 40-секундный стандартный таймаут для недоступных узлов).</li><li>Kubelet создает и затем обновляет свой Lease объект каждый 10 секунд
(интервал обновления по умолчанию). Lease обновления происходят независимо от
<code>NodeStatus</code> обновлений. Если обновление Lease завершается неудачно,
kubelet повторяет попытку с экспоненциальным откатом, начинающимся с 200 миллисекунд и ограниченным 7 секундами.</li></ul><h4 id=надежность>Надежность</h4><p>В большинстве случаев контроллер узла ограничивает скорость выселения
до <code>--node-eviction-rate</code> (по умолчанию 0,1) в секунду, что означает,
что он не выселяет поды с узлов быстрее чем с одного узла в 10 секунд.</p><p>Поведение выселения узла изменяется, когда узел в текущей зоне доступности
становится нездоровым. Контроллер узла проверяет, какой процент узлов в зоне
нездоров (NodeReady условие в значении ConditionUnknown или ConditiononFalse)
в одно и то же время. Если доля нездоровых узлов не меньше
<code>--unhealthy-zone-threshold</code> (по умолчанию 0.55), то скорость выселения уменьшается:
если кластер небольшой (т.е. количество узлов меньше или равно
<code>--large-cluster-size-threshold</code> - по умолчанию, 50), то выселения прекращаются,
в противном случае скорость выселения снижается до
<code>--secondary-node-eviction-rate</code> (по умолчанию, 0.01) в секунду.</p><p>Причина, по которой эти политики реализуются для каждой зоны доступности, заключается в том,
что одна зона доступности может стать отделенной от мастера, в то время как другие
остаются подключенными. Если ваш кластер не охватывает несколько зон доступности
облачного провайдера, то существует только одна зона доступности (весь кластер).</p><p>Основная причина разнесения ваших узлов по зонам доступности заключается в том,
что приложения могут быть перенесены в здоровые зоны, когда одна из зон полностью
становится недоступной. Поэтому, если все узлы в зоне нездоровы, то контроллер узла
выселяет поды с нормальной скоростью <code>--node-eviction-rate</code>. Крайний случай - когда все зоны
полностью нездоровы (т.е. в кластере нет здоровых узлов). В таком случае
контроллер узла предполагает, что существует некоторая проблема с подключением к мастеру,
и останавливает все выселения, пока какое-нибудь подключение не будет восстановлено.</p><p>Контроллер узла также отвечает за выселение подов, запущенных на узлах с
<code>NoExecute</code> ограничениями, за исключением тех подов, которые сопротивляются этим ограничениям.
Контроллер узла так же добавляет <a class=glossary-tooltip title='A core object consisting of three required properties: key, value, and effect. Taints prevent the scheduling of pods on nodes or node groups.' data-toggle=tooltip data-placement=top href=/docs/concepts/scheduling-eviction/taint-and-toleration/ target=_blank aria-label=ограничения>ограничения</a>
соответствующие проблемам узла, таким как узел недоступен или не готов. Это означает,
что планировщик не будет размещать поды на нездоровых узлах.</p><div class="alert alert-warning caution callout" role=alert><strong>Внимание:</strong> <code>kubectl cordon</code> помечает узел как 'не назначаемый', что имеет побочный эффект от контроллера сервисов,
удаляющего узел из любых списков целей LoadBalancer узла, на которые он ранее имел право,
эффективно убирая входящий трафик балансировщика нагрузки с блокированного узла(ов).</div><h3 id=емкость-узла>Емкость узла</h3><p>Объекты узла отслеживают информацию о емкости ресурсов узла (например,
объем доступной памяти и количество CPU).
Узлы, которые <a href=#%D1%81%D0%B0%D0%BC%D0%BE%D1%80%D0%B5%D0%B3%D0%B8%D1%81%D1%82%D1%80%D0%B0%D1%86%D0%B8%D1%8F-%D1%83%D0%B7%D0%BB%D0%BE%D0%B2>самостоятельно зарегистрировались</a>, сообщают
о своей емкости во время регистрации. Если вы <a href=#%D1%80%D1%83%D1%87%D0%BD%D0%BE%D0%B5-%D0%B0%D0%B4%D0%BC%D0%B8%D0%BD%D0%B8%D1%81%D1%82%D1%80%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%83%D0%B7%D0%BB%D0%B0>вручную</a>
добавляете узел, то вам нужно задать информацию о емкости узла при его добавлении.</p><p><a class=glossary-tooltip title='Компонент плоскости управления, который отслеживает созданные поды без привязанного узла и выбирает узел, на котором они должны работать.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-scheduler/ target=_blank aria-label=Планировщик>Планировщик</a> Kubernetes гарантирует,
что для всех Подов на Узле достаточно ресурсов. Планировщик проверяет,
что сумма requests от контейнеров на узле не превышает емкость узла.
Эта сумма requests включает все контейнеры, управляемые kubelet,
но исключает любые контейнеры, запущенные непосредственно средой выполнения контейнера,
а также исключает любые процессы, запущенные вне контроля kubelet.</p><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong> Если вы явно хотите зарезервировать ресурсы для процессов, не связанных с Подами, смотрите раздел
<a href=/docs/tasks/administer-cluster/reserve-compute-resources/#system-reserved>зарезервировать ресурсы для системных демонов</a>.</div><h2 id=топология-узла>Топология узла</h2><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.16 [alpha]</code></div><p>Если вы включили <code>TopologyManager</code>
<a href=/docs/reference/command-line-tools-reference/feature-gates/>feature gate</a>, то kubelet
может использовать подсказки топологии при принятии решений о выделении ресурсов.
Смотрите <a href=/docs/tasks/administer-cluster/topology-manager/>Контроль Политик Управления Топологией на Узле</a>
для дополнительной информации.</p><h2 id=что-дальше>Что дальше</h2><ul><li>Подробнее про<a href=/ru/docs/concepts/overview/components/#%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D1%8B-%D1%83%D0%B7%D0%BB%D0%B0>компоненты</a> из которых состоит узел.</li><li>Подробнее про <a href=/docs/reference/generated/kubernetes-api/v1.25/#node-v1-core>Определение API для Узла</a>.</li><li>Подробнее про <a href=https://git.k8s.io/community/contributors/design-proposals/architecture/architecture.md#the-kubernetes-node>Узлы</a>
of the architecture design document.</li><li>Подробнее про <a href=/docs/concepts/configuration/taint-and-toleration/>ограничения и допуски</a>.</li><li>Подробнее про <a href=/docs/tasks/administer-cluster/cluster-management/#cluster-autoscaling>авто масштабирование кластера</a>.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-c0251def6da29b30afebfb04549f1703>2.2 - Связь между плоскостью управления и узлом</h1><p>Этот документ описывает связь между плоскостью управления (apiserver) и кластером Kubernetes. Цель состоит в том, чтобы позволить пользователям настраивать свою установку для усиления сетевой конфигурации, чтобы кластер мог работать в ненадежной сети (или на полностью общедоступных IP-адресах облачного провайдера).</p><h2 id=связь-между-плоскостью-управления-и-узлом>Связь между плоскостью управления и узлом</h2><p>В Kubernetes имеется API шаблон «ступица и спица» (hub-and-spoke). Все используемые API из узлов (или которые запускают pod-ы) завершает apiserver. Ни один из других компонентов плоскости управления не предназначен для предоставления удаленных сервисов. Apiserver настроен на прослушивание удаленных подключений через безопасный порт HTTPS (обычно 443) с одной или несколькими включенными формами <a href=/docs/reference/access-authn-authz/authentication/>аутентификации</a> клиента.</p><p>Должна быть включена одна или несколько форм <a href=/docs/reference/access-authn-authz/authorization/>авторизации</a>, особенно, если разрешены <a href=/docs/reference/access-authn-authz/authentication/#anonymous-requests>анонимные запросы</a> или <a href=/docs/reference/access-authn-authz/authentication/#service-account-tokens>ServiceAccount токены</a>.</p><p>Узлы должны быть снабжены публичным корневым сертификатом для кластера, чтобы они могли безопасно подключаться к apiserver-у вместе с действительными учетными данными клиента. Хороший подход заключается в том, чтобы учетные данные клиента, предоставляемые kubelet-у, имели форму клиентского сертификата. См. Информацию о загрузке kubelet TLS <a href=/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/>kubelet TLS bootstrapping</a> для автоматической подготовки клиентских сертификатов kubelet.</p><p>Pod-ы, которые хотят подключиться к apiserver, могут сделать это безопасно, используя ServiceAccount, чтобы Kubernetes автоматически вводил общедоступный корневой сертификат и действительный токен-носитель в pod при его создании.
Служба <code>kubernetes</code> (в пространстве имен <code>default</code>) настроена с виртуальным IP-адресом, который перенаправляет (через kube-proxy) на HTTPS эндпоинт apiserver-а.</p><p>Компоненты уровня управления также взаимодействуют с кластером apiserver-а через защищенный порт.</p><p>В результате режим работы по умолчанию для соединений от узлов и модулей, работающих на узлах, к плоскости управления по умолчанию защищен и может работать в ненадежных и/или общедоступных сетях.</p><h2 id=узел-к-плоскости-управления>Узел к плоскости управления</h2><p>Существуют два пути связи плоскости управления (apiserver) с узлами. Первый - от apiserver-а до kubelet процесса, который выполняется на каждом узле кластера. Второй - от apiserver к любому узлу, pod-у или службе через промежуточную функциональность apiserver-а.</p><h3 id=apiserver-в-kubelet>apiserver в kubelet</h3><p>Соединение из apiserver-а к kubelet используются для:</p><ul><li>Извлечения логов с pod-ов.</li><li>Прикрепление (через kubectl) к запущенным pod-ам.</li><li>Обеспечение функциональности переадресации портов kubelet.</li></ul><p>Эти соединения завершаются на HTTPS эндпоинте kubelet-a. По умолчанию apiserver не проверяет сертификат обслуживания kubelet-ов, что делает соединение подверженным к атаке «человек посередине» (man-in-the-middle) и <strong>небезопасным</strong> к запуску в ненадежных и/или общедоступных сетях.</p><p>Для проверки этого соединения используется флаг <code>--kubelet-certificate-authority</code> чтобы предоставить apiserver-у набор корневых (root) сертификатов для проверки сертификата обслуживания kubelet-ов.</p><p>Если это не возможно, используйте <a href=#ssh-tunnels>SSH-тунелирование</a> между apiserver-ом и kubelet, если это необходимо, чтобы избежать подключения по ненадежной или общедоступной сети.</p><p>Наконец, должны быть включены <a href=/docs/reference/command-line-tools-reference/kubelet-authentication-authorization/>аутентификация или авторизация kubelet</a> для защиты kubelet API.</p><h3 id=apiserver-для-узлов-pod-ов-и-служб>apiserver для узлов, pod-ов, и служб</h3><p>Соединения с apiserver к узлу, поду или сервису по умолчанию осуществляются по-обычному HTTP-соединению и поэтому не аутентифицируются, и не шифруются. Они могут быть запущены по защищенному HTTPS-соединению, после добавления префикса <code>https:</code> к имени узла, пода или сервиса в URL-адресе API, но они не будут проверять сертификат предоставленный HTTPS эндпоинтом, как и не будут предоставлять учетные данные клиента. Таким образом, хотя соединение будет зашифровано, оно не обеспечит никаких гарантий целостности. Эти соединения <strong>в настоящее время небезопасны</strong> для запуска в ненадежных или общедоступных сетях.</p><h3 id=ssh-туннели>SSH-туннели</h3><p>Kubernetes поддерживает SSH-туннели для защиты плоскости управления узлов от путей связи. В этой конфигурации apiserver инициирует SSH-туннель для каждого узла в кластере (подключается к ssh-серверу, прослушивая порт 22) и передает весь трафик предназначенный для kubelet, узлу, pod-у или службе через туннель. Этот туннель гарантирует, что трафик не выводится за пределы сети, в которой работает узел.</p><p>SSH-туннели в настоящее время устарели, поэтому вы не должны использовать их, если не знаете, что делаете. Служба подключения является заменой этого канала связи.</p><h3 id=служба-подключения>Служба подключения</h3><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.18 [beta]</code></div><p>В качестве замены SSH-туннелям, служба подключения обеспечивает уровень полномочия TCP для плоскости управления кластерной связи. Служба подключения состоит из двух частей: сервер подключения к сети плоскости управления и агентов подключения в сети узлов. Агенты службы подключения инициируют подключения к серверу подключения и поддерживают сетевое подключение. После включения службы подключения, весь трафик с плоскости управления на узлы проходит через эти соединения.</p><p>Следуйте инструкциям <a href=/docs/tasks/extend-kubernetes/setup-konnectivity/>Задача службы подключения,</a> чтобы настроить службу подключения в кластере.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-ca8819042a505291540e831283da66df>2.3 - Контроллеры</h1><p>В робототехнике и автоматизации, <em>цикл управления</em> - это непрерывный цикл, который регулирует состояние системы.</p><p>Вот один из примеров контура управления: термостат в помещении.</p><p>Когда вы устанавливаете температуру, это говорит термостату о вашем <em>желаемом состоянии</em>. Фактическая температура в помещении - это
<em>текущее состояние</em>. Термостат действует так, чтобы приблизить текущее состояние к желаемому состоянию, путем включения или выключения оборудования.</p>Контроллеры в Kubernetes - управляющие циклы, которые отслеживают состояние вашего
<a class=glossary-tooltip title='Набор машин, так называемые узлы, которые запускают контейнеризированные приложения. Кластер имеет как минимум один рабочий узел.' data-toggle=tooltip data-placement=top href='/ru/docs/reference/glossary/?all=true#term-cluster' target=_blank aria-label=кластера>кластера</a>, затем вносят или запрашивают
изменения там, где это необходимо.
Каждый контроллер пытается привести текущее состояние кластера ближе к желаемому состоянию.<h2 id=шаблон-контроллера>Шаблон контроллера</h2><p>Контроллер отслеживает по крайней мере один тип ресурса Kubernetes.
Эти <a href=/docs/concepts/overview/working-with-objects/kubernetes-objects/#kubernetes-objects>объекты</a>
имеют поле спецификации, которое представляет желаемое состояние. Контроллер (ы) для этого ресурса несут ответственность за приближение текущего состояния к желаемому состоянию</p><p>Контроллер может выполнить это действие сам; чаще всего в Kubernetes,
контроллер отправляет сообщения на
<a class=glossary-tooltip title='Компонент панели управления, обслуживающий API Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kube-apiserver/ target=_blank aria-label='сервер API'>сервер API</a> которые имеют
полезные побочные эффекты. Пример этого вы можете увидеть ниже.</p><h3 id=управление-с-помощью-сервера-api>Управление с помощью сервера API</h3><p>Контроллер <a class=glossary-tooltip title='A finite or batch task that runs to completion.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/controllers/job/ target=_blank aria-label=Job>Job</a> является примером встроенного контроллера Kubernetes. Встроенные контроллеры управляют состоянием, взаимодействуя с кластером сервера API.</p><p>Задание - это ресурс Kubernetes, который запускает
<a class=glossary-tooltip title='Самый маленький и простой объект в Kubernetes. Под — это набор запущенных контейнеров в кластере.' data-toggle=tooltip data-placement=top href=/docs/concepts/workloads/pods/pod-overview/ target=_blank aria-label=Pod>Pod</a>, или возможно несколько Pod-ов, выполняющих задачу и затем останавливающихся.</p><p>(После <a href=/docs/concepts/scheduling-eviction/>планирования</a>, Pod объекты становятся частью желаемого состояния для kubelet).</p><p>Когда контроллер задания видит новую задачу, он убеждается что где-то в вашем кластере kubelet-ы на множестве узлов запускают нужное количество Pod-ов для выполнения работы.
Контроллер задания сам по себе не запускает никакие Pod-ы или контейнеры. Вместо этого контроллер задания сообщает серверу API о создании или удалении Pod-ов.
Другие компоненты в
<a class=glossary-tooltip title='Уровень оркестрации контейнеров с API и интерфейсами для определения, развёртывания и управления жизненным циклом контейнеров.' data-toggle=tooltip data-placement=top href='/ru/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='плоскости управления'>плоскости управления</a>
действуют на основе информации (имеются ли новые запланированные Pod-ы для запуска), и в итоге работа завершается.</p><p>После того как вы создадите новое задание, желаемое состояние для этого задания будет завершено. Контроллер задания приближает текущее состояние этой задачи к желаемому состоянию: создает Pod-ы, выполняющие работу, которую вы хотели для этой задачи, чтобы задание было ближе к завершению.</p><p>Контроллеры также обновляют объекты которые их настраивают.
Например: как только работа выполнена для задания, контроллер задания обновляет этот объект задание, чтобы пометить его как <code>Завершенный</code>.</p><p>(Это немного похоже на то, как некоторые термостаты выключают свет, чтобы указать, что теперь ваша комната имеет установленную вами температуру).</p><h3 id=прямое-управление>Прямое управление</h3><p>В отличие от Задания, некоторым контроллерам нужно вносить изменения в вещи за пределами вашего кластера.</p><p>Например, если вы используете контур управления, чтобы убедиться, что в вашем кластере достаточно <a class=glossary-tooltip title='Узел — рабочая машина в Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/nodes/ target=_blank aria-label=Узлов>Узлов</a>,
тогда этому контроллеру нужно что-то вне текущего кластера, чтобы при необходимости запустить новые узлы.</p><p>Контроллеры, которые взаимодействуют с внешним состоянием, находят свое желаемое состояние с сервера API, а затем напрямую взаимодействуют с внешней системой, чтобы приблизить текущее состояние.</p><p>(На самом деле существует <a href=https://github.com/kubernetes/autoscaler/>контроллер</a>, который горизонтально масштабирует узлы в вашем кластере.)</p><p>Важным моментом здесь является то, что контроллер вносит некоторые изменения, чтобы вызвать желаемое состояние, а затем сообщает текущее состояние обратно на сервер API вашего кластера. Другие контуры управления могут наблюдать за этими отчетными данными и предпринимать собственные действия.</p><p>В примере с термостатом, если в помещении очень холодно, тогда другой контроллер может также включить обогреватель для защиты от замерзания. В кластерах Kubernetes, плоскость управления косвенно работает с инструментами управления IP-адресами, службами хранения данных, API облачных провайдеров и другими службами для реализации
<a href=/docs/concepts/extend-kubernetes/>расширения Kubernetes</a>.</p><h2 id=desired-vs-current>Желаемое против текущего состояния</h2><p>Kubernetes использует систему вида cloud-native и способен справляться с постоянными изменениями.</p><p>Ваш кластер может изменяться в любой по мере выполнения работы и контуры управления автоматически устраняют сбой. Это означает, что потенциально Ваш кластер никогда не достигнет стабильного состояния.</p><p>Пока контроллеры вашего кластера работают и могут вносить полезные изменения, не имеет значения, является ли общее состояние стабильным или нет.</p><h2 id=дизайн>Дизайн</h2><p>В качестве принципа своей конструкции Kubernetes использует множество контроллеров, каждый из которых управляет определенным аспектом состояния кластера. Чаще всего конкретный контур управления (контроллер) использует один вид ресурса в качестве своего желаемого состояния и имеет другой вид ресурса, которым он управляет, чтобы это случилось. Например, контроллер для заданий отслеживает объекты заданий (для обнаружения новой работы) и объекты модулей (для выполнения заданий, а затем для того, чтобы видеть, когда работа завершена). В этом случае что-то еще создает задания, тогда как контроллер заданий создает Pod-ы.</p><p>Полезно иметь простые контроллеры, а не один монолитный набор взаимосвязанных контуров управления. Контроллеры могут выйти из строя, поэтому Kubernetes предназначен для этого.</p><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong><p>Существует несколько контроллеров, которые создают или обновляют один и тот же тип объекта. За кулисами контроллеры Kubernetes следят за тем, чтобы обращать внимание только на ресурсы, связанные с их контролирующим ресурсом.</p><p>Например, у вас могут быть развертывания и задания; они оба создают Pod-ы. Контроллер заданий не удаляет Pod-ы созданные вашим развертыванием, потому что имеется информационные (<a class=glossary-tooltip title='Группирует объекты на основе произвольных критериев, по которым пользователи могут их идентифицировать.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/labels target=_blank aria-label=метки>метки</a>)
которые могут быть использованы контроллерами тем самым показывая отличие Pod-ов.</p></div><h2 id=running-controllers>Способы запуска контроллеров</h2><p>Kubernetes поставляется с набором встроенных контроллеров, которые работают внутри <a class=glossary-tooltip title='Компонент Control Plane запускает процессы контроллера.' data-toggle=tooltip data-placement=top href=/docs/reference/command-line-tools-reference/kube-controller-manager/ target=_blank aria-label=kube-controller-manager>kube-controller-manager</a>. Эти встроенные контроллеры обеспечивают важные основные функции.</p><p>Контроллер развертывания и контроллер заданий - это примеры контроллеров, которые входят в состав самого Kubernetes («встроенные» контроллеры).
Kubernetes позволяет вам запускать устойчивую плоскость управления, так что в случае отказа одного из встроенных контроллеров работу берет на себя другая часть плоскости управления.</p><p>Вы можете найти контроллеры, которые работают вне плоскости управления, чтобы расширить Kubernetes.
Или, если вы хотите, можете написать новый контроллер самостоятельно. Вы можете запустить свой собственный контроллер в виде наборов Pod-ов,
или внешнее в Kubernetes. Что подойдет лучше всего, будет зависеть от того, что делает этот конкретный контроллер.</p><h2 id=что-дальше>Что дальше</h2><ul><li>Прочтите о <a href=/docs/concepts/overview/components/#control-plane-components>плоскости управления Kubernetes</a></li><li>Откройте для себя некоторые из основных <a href=/docs/concepts/overview/working-with-objects/kubernetes-objects/>объектов Kubernetes</a></li><li>Узнайте больше о <a href=/docs/concepts/overview/kubernetes-api/>Kubernetes API</a></li><li>Если вы хотите написать собственный контроллер, см <a href=/docs/concepts/extend-kubernetes/extend-cluster/#extension-patterns>Шаблоны расширения</a> в расширении Kubernetes.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-bc804b02614d67025b4c788f1ca87fbc>2.4 - Диспетчер облачных контроллеров</h1><div style=margin-top:10px;margin-bottom:10px><b>FEATURE STATE:</b> <code>Kubernetes v1.11 [beta]</code></div><p>Технологии облачной инфраструктуры позволяют запускать Kubernetes в общедоступных, частных и гибридных облаках. Kubernetes верит в автоматизированную, управляемую API инфраструктуру без жесткой связи между компонентами.</p><p><p>Диспетчер облачных контроллеров компонент <a class=glossary-tooltip title='Уровень оркестрации контейнеров с API и интерфейсами для определения, развёртывания и управления жизненным циклом контейнеров.' data-toggle=tooltip data-placement=top href='/ru/docs/reference/glossary/?all=true#term-control-plane' target=_blank aria-label='панель управления'>панель управления</a> Kubernetes - это встраиваемый в логику управления облочная спецификация. Диспетчер облачных контроллеров позволяет связать кластер с API поставщика облачных услуг и отделить компоненты, взаимодействующие с этой облачной платформой, от компонентов, взаимодействующих только с вашим кластером.</p></p><p>Отделяя логику взаимодействия между Kubernetes и базовой облачной инфраструктурой, компонент cloud-controller-manager позволяет поставщикам облачных услуг выпускать функции в другом темпе по сравнению с основным проектом Kubernetes.</p><p>Диспетчер облачных контроллеров спроектирован с использованием механизма плагинов, которые позволяют различным облачным провайдерам интегрировать свои платформы с Kubernetes.</p><h2 id=дизайн>Дизайн</h2><p><img src=/images/docs/components-of-kubernetes.svg alt="Kubernetes components"></p><p>Диспетчер облачных контроллеров работает в панели управления как реплицированный набор процессов (обычно это контейнер в Pod-ах). Каждый диспетчер облачных контроллеров реализует множество <a class=glossary-tooltip title='Управляющий цикл который отслеживает общее состояние кластера через API-сервер и вносит изменения пытаясь приветси текушее состояние к желаемому состоянию.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/controller/ target=_blank aria-label=контроллеров>контроллеров</a> в единственном процессе.</p><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong> Вы также можете запустить диспетчер облачных контроллеров как <a class=glossary-tooltip title='Resources that extend the functionality of Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/concepts/cluster-administration/addons/ target=_blank aria-label=дополнение>дополнение</a> Kubernetes, а не как часть панели управления.</div><h2 id=functions-of-the-ccm>Функции диспетчера облачных контроллеров</h2><p>Контроллеры внутри диспетчера облачных контроллеров включают в себя:</p><h3 id=контроллер-узла>Контроллер узла</h3><p>Контроллер узла отвечает за создание объектов <a class=glossary-tooltip title='Узел — рабочая машина в Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/nodes/ target=_blank aria-label=узла>узла</a> при создании новых серверов в вашей облачной инфраструктуре. Контроллер узла получает информацию о работающих хостах внутри вашей арендуемой инфраструктуры облачного провайдера.
Контроллер узла выполняет следующие функции:</p><ol><li>Инициализация объектов узла для каждого сервера, которые контроллер получает через API облачного провайдера.</li><li>Аннотирование и маркировка объектов узла специфичной для облака информацией, такой как регион узла и доступные ему ресурсы (процессор, память и т.д.).</li><li>Получение имени хоста и сетевых адресов.</li><li>Проверка работоспособности узла. В случае, если узел перестает отвечать на запросы, этот контроллер проверяет с помощью API вашего облачного провайдера, был ли сервер деактивирован / удален / прекращен. Если узел был удален из облака, контроллер удаляет объект узла из вашего Kubernetes кластера.</li></ol><p>Некоторые облачные провайдеры реализуют его разделение на контроллер узла и отдельный контроллер жизненного цикла узла.</p><h3 id=контроллер-маршрута>Контроллер маршрута</h3><p>Контроллер маршрута отвечает за соответствующую настройку маршрутов в облаке, чтобы контейнеры на разных узлах кластера Kubernetes могли взаимодействовать друг с другом.</p><p>В зависимости от облачного провайдера, контроллер маршрута способен также выделять блоки IP-адресов для сети Pod-ов.</p><h3 id=контроллер-сервисов>Контроллер сервисов</h3><p><a class=glossary-tooltip title='Способ представления приложения, запущенного в наборе подов, в виде сетевого сервиса.' data-toggle=tooltip data-placement=top href=/docs/concepts/services-networking/service/ target=_blank aria-label=Сервисы>Сервисы</a> интегрируются с компонентами облачной инфраструктуры, такими как управляемые балансировщики нагрузки, IP-адреса, фильтрация сетевых пакетов и проверка работоспособности целевых объектов. Контроллер сервисов взаимодействует с API вашего облачного провайдера для настройки требуемых балансировщиков нагрузки и других компонентов инфраструктуры, когда вы объявляете ресурсы сервисов.</p><h2 id=авторизация>Авторизация</h2><p>В этом разделе разбирается доступ к различным объектам API, который нужен облачным контроллерам для выполнения своих операций.</p><h3 id=authorization-node-controller>Контроллер узла</h3><p>Контроллер узла работает только с объектом узла. Он требует полного доступа на чтение и изменение объектов узла.</p><p><code>v1/Node</code>:</p><ul><li>Get</li><li>List</li><li>Create</li><li>Update</li><li>Patch</li><li>Watch</li><li>Delete</li></ul><h3 id=authorization-route-controller>Контроллер маршрута</h3><p>Контроллер маршрута прослушивает создание объектов узла и соответствующим образом настраивает маршруты. Для этого требуется получить доступ к объектам узла.</p><p><code>v1/Node</code>:</p><ul><li>Get</li></ul><h3 id=authorization-service-controller>Контроллер сервисов</h3><p>Контроллер сервисов прослушивает события Create, Update и Delete объектов служб, а затем соответствующим образом настраивает конечные точки для соответствующих сервисов.</p><p>Для доступа к сервисам требуется доступ к событиям List и Watch. Для обновления сервисов требуется доступ к событиям Patch и Update.</p><p>Чтобы настроить ресурсы конечных точек для сервисов, требуется доступ к событиям Create, List, Get, Watch и Update.</p><p><code>v1/Service</code>:</p><ul><li>List</li><li>Get</li><li>Watch</li><li>Patch</li><li>Update</li></ul><h3 id=authorization-miscellaneous>Другие</h3><p>Реализация ядра диспетчера облачных контроллеров требует доступ для создания объектов событий, а для обеспечения безопасной работы требуется доступ к созданию сервисных учетных записей (ServiceAccounts).</p><p><code>v1/Event</code>:</p><ul><li>Create</li><li>Patch</li><li>Update</li></ul><p><code>v1/ServiceAccount</code>:</p><ul><li>Create</li></ul><p><a class=glossary-tooltip title='Manages authorization decisions, allowing admins to dynamically configure access policies through the Kubernetes API.' data-toggle=tooltip data-placement=top href=/docs/reference/access-authn-authz/rbac/ target=_blank aria-label=RBAC>RBAC</a> ClusterRole для диспетчера облачных контроллеров выглядит так:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:green;font-weight:700>apiVersion</span>:<span style=color:#bbb> </span>rbac.authorization.k8s.io/v1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>kind</span>:<span style=color:#bbb> </span>ClusterRole<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>metadata</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>name</span>:<span style=color:#bbb> </span>cloud-controller-manager<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>rules</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- events<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- create<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- patch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- nodes<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#39;*&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- nodes/status<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- patch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- services<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- list<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- patch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- watch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- serviceaccounts<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- create<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- persistentvolumes<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- get<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- list<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- watch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>- <span style=color:green;font-weight:700>apiGroups</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- <span style=color:#b44>&#34;&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>resources</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- endpoints<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>verbs</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- create<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- get<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- list<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- watch<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span>- update<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=что-дальше>Что дальше</h2><p><a href=/docs/tasks/administer-cluster/running-cloud-controller/#cloud-controller-manager>Администрирование диспетчера облачных контроллеров</a>
содержит инструкции по запуску и управлению диспетчером облачных контроллеров.</p><p>Хотите знать, как реализовать свой собственный диспетчер облачных контроллеров или расширить проект?</p><p>Диспетчер облачных контроллеров использует интерфейсы Go, которые позволяют реализовать подключение из любого облака. В частности, он использует интерфейс <code>CloudProvider</code>, который определен в <a href=https://github.com/kubernetes/cloud-provider/blob/release-1.21/cloud.go#L42-L69><code>cloud.go</code></a> из <a href=https://github.com/kubernetes/cloud-provider>kubernetes/cloud-provider</a>.</p><p>Реализация общих контроллеров, описанных в этом документе (Node, Route, и Service), а также некоторые другие вспомогательные конструкции, вместе с общим интерфейсом облачного провайдера являются частью ядра Kubernetes. Особые реализации для облачных провайдеров находятся вне ядра Kubernetes и реализуют интерфейс <code>CloudProvider</code>.</p><p>Дополнительные сведения о разработке плагинов см. в разделе <a href=/docs/tasks/administer-cluster/developing-cloud-controller-manager/>Разработка диспетчера облачных контроллеров</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-44a2e2e592af0846101e970aff9243e5>2.5 - Сборщик мусора</h1><p>Сборщик мусора - это собирательный термин для различных механизмов? используемых Kubernetes для очистки ресурсов кластера. Это позволить очистить ресурсы, такие как:</p><ul><li><a href=/docs/concepts/workloads/pods/pod-lifecycle/#pod-garbage-collection>Неудачные pod-ы</a></li><li><a href=/docs/concepts/workloads/controllers/ttlafterfinished/>Завершенные задания</a></li><li><a href=#owners-dependents>Объекты без ссылок на владельца Objects</a></li><li><a href=#containers-images>Не используемые контейнеры и образы контейнеров</a></li><li><a href=/docs/concepts/storage/persistent-volumes/#delete>Dynamically provisioned PersistentVolumes with a StorageClass reclaim policy of Delete</a></li><li><a href=/docs/reference/access-authn-authz/certificate-signing-requests/#request-signing-process>Устаревшие или просроченные запросы подписания сертификатов (CSR)</a></li><li><a class=glossary-tooltip title='Узел — рабочая машина в Kubernetes.' data-toggle=tooltip data-placement=top href=/docs/concepts/architecture/nodes/ target=_blank aria-label=Nodes>Nodes</a> удалено в следующих сценариях:<ul><li>В облаке, когда кластер использует <a href=/docs/concepts/architecture/cloud-controller/>диспетчер облачных контроллеров</a></li><li>Локально когда кластер использует дополнение, аналогичное диспетчер облачных контроллеров</li></ul></li><li><a href=/docs/concepts/architecture/nodes/#heartbeats>Объекты аренды узлов</a></li></ul><h2 id=owners-dependents>Владельцы и зависимости</h2><p>Многие объекты в Kubernetes ссылаются друг на друга через <a href=/docs/concepts/overview/working-with-objects/owners-dependents/><em>ссылки владельцев</em></a>.
Ссылки владельцев сообщают плоскости управления какие объекты зависят от других.
Kubernetes использует ссылки владельцев, чтобы предоставить плоскости управления и другим API
клиентам, возможность очистить связанные ресурсы перед удалением объекта. В большинстве случаев, Kubernetes автоматический управляет ссылками владельцев.</p><p>Владелец отличается от <a href=/docs/concepts/overview/working-with-objects/labels/>меток и селекторов</a>
которые также используют некоторые ресурсы. Например, рассмотрим
<a class=glossary-tooltip title='Способ представления приложения, запущенного в наборе подов, в виде сетевого сервиса.' data-toggle=tooltip data-placement=top href=/docs/concepts/services-networking/service/ target=_blank aria-label=Службу>Службу</a> которая создает объект
<code>EndpointSlice</code>. Служба использует <em>метки</em> чтобы позволить плоскости управления определить какие <code>EndpointSlice</code> объекты используются для этой службы. В дополнение
к меткам, каждый <code>EndpointSlice</code> управляет ои имени службы, имеет
ссылку владельца. Ссылки владельцев помогают различным частям Kubernetes избегать
вмешательства в объекты, которые они не контролируют.</p><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong><p>Ссылки на владельцев перекрестных пространств имен запрещены по дизайну.
Зависимости пространства имен могут указывать на область действия кластера или владельцев пространства имен.
Владелец пространства имен <strong>должен</strong> быть в том же пространстве имен, что и зависимости.
Если это не возможно, ссылка владельца считается отсутствующей и зависимый объект подлежит удалению, как только будет проверено отсутствие всех владельцев.</p><p>Зависимости области действия кластер может указывать только владельцев области действия кластера.
В версии v1.20+, если зависимость с областью действия кластера указывает на пространство имен как владелец,
тогда он рассматривается как имеющий неразрешимую ссылку на владельца и не может быть обработан сборщиком мусора.</p><p>В версии v1.20+, если сборщик мусора обнаружит недопустимое перекрестное пространство имен <code>ownerReference</code>,
или зависящие от области действия кластера <code>ownerReference</code> ссылка на тип пространства имен, предупреждающее событие с причиной <code>OwnerRefInvalidNamespace</code> и <code>involvedObject</code> сообщающее о недействительной зависимости.
Вы можете проверить наличие такого рода событий, выполнив <code>kubectl get events -A --field-selector=reason=OwnerRefInvalidNamespace</code>.</p></div><h2 id=cascading-deletion>Каскадное удаление</h2><p>Kubernetes проверяет и удаляет объекты, на которые больше нет ссылок владельцев, так же как и pod-ов, оставленных после удаления ReplicaSet. Когда Вы удаляете объект, вы можете контролировать автоматический ли Kubernetes удаляет зависимые объекты автоматически в процессе вызова <em>каскадного удаления</em>. Существует два типа каскадного удаления, а именно:</p><ul><li>Каскадное удаление Foreground</li><li>Каскадное удаление Background</li></ul><p>Вы так же можете управлять как и когда сборщик мусора удаляет ресурсы, на которые ссылаются владельцы с помощью Kubernetes <a class=glossary-tooltip title='A namespaced key that tells Kubernetes to wait until specific conditions are met before it fully deletes an object marked for deletion.' data-toggle=tooltip data-placement=top href=/docs/concepts/overview/working-with-objects/finalizers/ target=_blank aria-label=finalizers>finalizers</a>.</p><h3 id=foreground-deletion>Каскадное удаление Foreground</h3><p>В Каскадном удалении Foreground, объект владельца, который вы удаляете, сначала переходить в состояние <em>в процессе удаления</em>. В этом состоянии с объектом-владельцем происходить следующее:</p><ul><li>Сервер Kubernetes API устанавливает полю объекта <code>metadata.deletionTimestamp</code>
время, когда объект был помечен для удаления.</li><li>Сервер Kubernetes API так же устанавливает метку <code>metadata.finalizers</code>для поля
<code>foregroundDeletion</code>.</li><li>Объект остается видимым благодаря Kubernetes API пока процесс удаления не завершиться</li></ul><p>После того как владелец объекта переходит в состояние прогресса удаления, контроллер удаляет зависимые объекты. После удаления всех зависимых объектов, контроллер удаляет объект владельца. На этом этапе, объект больше не отображается в Kubernetes API.</p><p>Во время каскадного удаления foreground, единственным зависимым, которые блокируют удаления владельца, являются те, у кого имеется поле <code>ownerReference.blockOwnerDeletion=true</code>.
Чтобы узнать больше. Смотрите <a href=/docs/tasks/administer-cluster/use-cascading-deletion/#use-foreground-cascading-deletion>Использование каскадного удаления foreground</a>.</p><h3 id=background-deletion>Каскадное удаление Background</h3><p>В каскадном удалении background, сервер Kubernetes API немедленно удаляет владельца объекта, а контроллер очищает зависимые объекты в фоновом режиме. По умолчанию, Kubernetes использует каскадное удаление background, если вы в ручную не используете удаление foreground или не решите отключить зависимые объекты.</p><p>Чтобы узнать больше. Смотрите <a href=/docs/tasks/administer-cluster/use-cascading-deletion/#use-background-cascading-deletion>Использование каскадного удаления background</a>.</p><h3 id=осиротевшие-зависимости>Осиротевшие зависимости</h3><p>Когда Kubernetes удаляет владельца объекта, оставшиеся зависимости называются <em>осиротевшими</em> объектами. По умолчанию, Kubernetes удаляет зависимые объекты. Чтобы узнать, как переопределить это поведение смотрите <a href=/docs/tasks/administer-cluster/use-cascading-deletion/#set-orphan-deletion-policy>Удаление объектов владельца и осиротевших зависимостей</a>.</p><h2 id=containers-images>Сбор мусора из неиспользуемых контейнеров и изображений</h2><p><a class=glossary-tooltip title='Агент, работающий на каждом узле в кластере. Он следит за тем, чтобы контейнеры были запущены в поде.' data-toggle=tooltip data-placement=top href=/docs/reference/generated/kubelet target=_blank aria-label=kubelet>kubelet</a> выполняет сбор мусора для неиспользуемых образов каждые пять минут и для неиспользуемых контейнеров каждую минуту. Вам следует избегать использования внешних инструментов для сборки мусора, так как они могут
нарушить поведение kubelet и удалить контейнеры, которые должны существовать.</p><p>Чтобы настроить параметры для сборщика мусора для неиспользуемого контейнера и сборки мусора образа, подстройте
kubelet использую <a href=/docs/tasks/administer-cluster/kubelet-config-file/>конфигурационный файл</a>
и измените параметры, связанные со сборщиком мусора используя тип ресурса
<a href=/docs/reference/config-api/kubelet-config.v1beta1/#kubelet-config-k8s-io-v1beta1-KubeletConfiguration><code>KubeletConfiguration</code></a>.</p><h3 id=жизненный-цикл-контейнерных-образов-container-image-lifecycle>Жизненный цикл контейнерных образов Container image lifecycle</h3><p>Kubernetes управляет жизненным циклом всех образов с помощью своего <em>менеджера образов</em>, которые являются частью kubelet, в сотрудничестве с cadvisor. При принятии решений о сборке мусора, kubelet учитывает следующие ограничения использования диска:</p><ul><li><code>HighThresholdPercent</code></li><li><code>LowThresholdPercent</code></li></ul><p>Использование диска выше настроенного значения <code>HighThresholdPercent</code> запускает сборку мусора, которая удаляет образы в порядке основанном на последнем использовании, начиная с самого старого. Kubelet удаляет образы до тех пор, пока использование диска не достигнет значения <code>LowThresholdPercent</code>.</p><h3 id=container-image-garbage-collection>Сборщик мусора контейнерных образов</h3><p>Kubelet собирает не используемые контейнеры на основе следующих переменных, которые вы можете определить:</p><ul><li><code>MinAge</code>: минимальный возраст, при котором kubelet может начать собирать мусор контейнеров. Отключить, установив значение <code>0</code>.</li><li><code>MaxPerPodContainer</code>: максимальное количество неактивных контейнеров, которое может быть у каждой пары Pod-ов. Отключить, установив значение меньше чем <code>0</code>.</li><li><code>MaxContainers</code>: максимальное количество не используемых контейнеров, которые могут быть в кластере. Отключить, установив значение меньше чем <code>0</code>.</li></ul><p>В дополнение к этим переменным, kubelet собирает неопознанные и удаленные контейнеры, обычно начиная с самого старого.</p><p><code>MaxPerPodContainer</code> и <code>MaxContainer</code> могут потенциально конфликтовать друг с другом в ситуациях, когда требуется максимальное количество контейнеров в Pod-е (<code>MaxPerPodContainer</code>) выйдет за пределы допустимого общего количества глобальных не используемых контейнеров (<code>MaxContainers</code>). В этой ситуации kubelet регулирует <code>MaxPodPerContainer</code> для устранения конфликта. Наихудшим сценарием было бы понизить <code>MaxPerPodContainer</code> да <code>1</code> и изгнать самые старые контейнеры.
Кроме того, владельцы контейнеров в pod-е могут быть удалены, как только они становятся старше чем <code>MinAge</code>.</p><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong> Kubelet собирает мусор только у контейнеров, которыми он управляет.</div><h2 id=configuring-gc>Настройка сборщик мусора</h2><p>Вы можете настроить сборку мусора ресурсов, настроив параметры, специфичные для контроллеров, управляющих этими ресурсами. В последующих страницах показано, как настроить сборку мусора:</p><ul><li><a href=/docs/tasks/administer-cluster/use-cascading-deletion/>Настройка каскадного удаления объектов Kubernetes</a></li><li><a href=/docs/concepts/workloads/controllers/ttlafterfinished/>Настройка очистки завершенных заданий</a></li></ul><h2 id=что-дальше>Что дальше</h2><ul><li>Узнайте больше о <a href=/docs/concepts/overview/working-with-objects/owners-dependents/>ownership of Kubernetes objects</a>.</li><li>Узнайте больше о Kubernetes <a href=/docs/concepts/overview/working-with-objects/finalizers/>finalizers</a>.</li><li>Узнать о <a href=/docs/concepts/workloads/controllers/ttlafterfinished/>TTL контроллере</a> (beta) that cleans up finished Jobs.</li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-285a3785fd3d20f437c28d87ca4dadca>3 - Администрирование кластера</h1><div class=lead>Lower-level detail relevant to creating or administering a Kubernetes cluster.</div><p>Обзор администрирования кластера предназначен для всех, кто создает или администрирует кластер Kubernetes. Это предполагает некоторое знакомство с основными <a href=/docs/concepts/>концепциями</a> Kubernetes.</p><h2 id=планирование-кластера>Планирование кластера</h2><p>См. Руководства в разделе <a href=/docs/setup/>настройка</a> для получения примеров того, как планировать, устанавливать и настраивать кластеры Kubernetes. Решения, перечисленные в этой статье, называются <em>distros</em>.</p><div class="alert alert-info note callout" role=alert><strong>Заметка:</strong> не все дистрибутивы активно поддерживаются. Выбирайте дистрибутивы, протестированные с последней версией Kubernetes.</div><p>Прежде чем выбрать руководство, вот некоторые соображения:</p><ul><li>Вы хотите опробовать Kubernetes на вашем компьютере или собрать много узловой кластер высокой доступности? Выбирайте дистрибутивы, наиболее подходящие для ваших нужд.</li><li>Будете ли вы использовать <strong>размещенный кластер Kubernetes</strong>, такой, как <a href=https://cloud.google.com/kubernetes-engine/>Google Kubernetes Engine</a> или <strong>разместите собственный кластер</strong>?</li><li>Будет ли ваш кластер <strong>в помещении</strong> или <strong>в облаке (IaaS)</strong>? Kubernetes не поддерживает напрямую гибридные кластеры. Вместо этого вы можете настроить несколько кластеров.</li><li><strong>Если вы будете настраивать Kubernetes в помещении (локально)</strong>, подумайте, какая <a href=/docs/concepts/cluster-administration/networking/>сетевая модель</a> подходит лучше всего.</li><li>Будете ли вы запускать Kubernetes на <strong>оборудований "bare metal"</strong> или на <strong>виртуальных машинах (VMs)</strong>?</li><li>Вы хотите <strong>запустить кластер</strong> или планируете <strong>активно разворачивать код проекта Kubernetes</strong>? В последнем случае выберите активно разрабатываемый дистрибутив. Некоторые дистрибутивы используют только двоичные выпуски, но предлагают более широкий выбор.</li><li>Ознакомьтесь с <a href=/docs/concepts/overview/components/>компонентами</a> необходимые для запуска кластера.</li></ul><h2 id=управление-кластером>Управление кластером</h2><ul><li><p>Узнайте как <a href=/docs/concepts/architecture/nodes/>управлять узлами</a>.</p></li><li><p>Узнайте как настроить и управлять <a href=/docs/concepts/policy/resource-quotas/>квотами ресурсов</a> для общих кластеров.</p></li></ul><h2 id=обеспечение-безопасности-кластера>Обеспечение безопасности кластера</h2><ul><li><p><a href=/docs/tasks/administer-cluster/certificates/>Сгенерировать сертификаты</a> описывает шаги по созданию сертификатов с использованием различных цепочек инструментов.</p></li><li><p><a href=/docs/concepts/containers/container-environment/>Kubernetes Container Environment</a> описывает среду для управляемых контейнеров Kubelet на узле Kubernetes.</p></li><li><p><a href=/docs/concepts/security/controlling-access>Управление доступом к Kubernetes API</a> описывает как Kubernetes реализует контроль доступа для своего собственного API.</p></li><li><p><a href=/docs/reference/access-authn-authz/authentication/>Аутентификация</a> объясняет аутентификацию в Kubernetes, включая различные варианты аутентификации.</p></li><li><p><a href=/docs/reference/access-authn-authz/authorization/>Авторизация</a> отделена от аутентификации и контролирует обработку HTTP-вызовов.</p></li><li><p><a href=/docs/reference/access-authn-authz/admission-controllers/>Использование контроллеров допуска</a> explains plug-ins which intercepts requests to the Kubernetes API server after authentication and authorization.</p></li><li><p><a href=/docs/tasks/administer-cluster/sysctl-cluster/>Использование Sysctls в кластере Kubernetes</a> описывает администратору, как использовать sysctl инструмент командной строки для установки параметров ядра.</p></li><li><p><a href=/docs/tasks/debug-application-cluster/audit/>Аудит</a> описывает, как взаимодействовать с журналами аудита Kubernetes.</p></li></ul><h3 id=обеспечение-безопасности-kubelet>Обеспечение безопасности kubelet</h3><ul><li><a href=/docs/concepts/architecture/control-plane-node-communication/>Связь между плоскостью управления и узлом</a></li><li><a href=/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/>Загрузка TLS</a></li><li><a href=/docs/reference/command-line-tools-reference/kubelet-authentication-authorization/>Аутентификация/авторизация Kubelet</a></li></ul><h2 id=дополнительные-кластерные-услуги>Дополнительные кластерные услуги</h2><ul><li><p><a href=/docs/concepts/services-networking/dns-pod-service/>Интеграция DNS</a> описывает как разрешить DNS имя непосредственно службе Kubernetes.</p></li><li><p><a href=/docs/concepts/cluster-administration/logging/>Ведение журнала и мониторинг активности кластера</a> объясняет, как работает ведение журнала в Kubernetes и как его реализовать.</p></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-2bf9a93ab5ba014fb6ff70b22c29d432>3.1 - Сертификаты</h1><p>Чтобы узнать, как генерировать сертификаты для кластера, см. раздел <a href=/docs/tasks/administer-cluster/certificates/>Сертификаты</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-85d633ae590aa20ec024f1b7af1d74fc>3.2 - Установка дополнений</h1><div class="alert alert-secondary callout third-party-content" role=alert><strong>Заметка:</strong>
This section links to third party projects that provide functionality required by Kubernetes. The Kubernetes project authors aren't responsible for these projects, which are listed alphabetically. To add a project to this list, read the <a href=/docs/contribute/style/content-guide/#third-party-content>content guide</a> before submitting a change. <a href=#third-party-content-disclaimer>More information.</a></div><p>Надстройки расширяют функциональность Kubernetes.</p><p>На этой странице перечислены некоторые из доступных надстроек и ссылки на соответствующие инструкции по установке.</p><h2 id=сеть-и-сетевая-политика>Сеть и сетевая политика</h2><ul><li><a href=https://www.github.com/noironetworks/aci-containers>ACI</a> обеспечивает интегрированную сеть контейнеров и сетевую безопасность с помощью Cisco ACI.</li><li><a href=https://antrea.io/>Antrea</a> работает на уровне 3, обеспечивая сетевые службы и службы безопасности для Kubernetes, используя Open vSwitch в качестве уровня сетевых данных.</li><li><a href=https://docs.projectcalico.org/latest/introduction/>Calico</a> Calico поддерживает гибкий набор сетевых опций, поэтому вы можете выбрать наиболее эффективный вариант для вашей ситуации, включая сети без оверлея и оверлейные сети, с или без BGP. Calico использует тот же механизм для обеспечения соблюдения сетевой политики для хостов, модулей и (при использовании Istio и Envoy) приложений на уровне сервисной сети (mesh layer).</li><li><a href=https://projectcalico.docs.tigera.io/getting-started/kubernetes/flannel/flannel>Canal</a> объединяет Flannel и Calico, обеспечивая сеть и сетевую политику.</li><li><a href=https://github.com/cilium/cilium>Cilium</a> - это плагин сети L3 и сетевой политики, который может прозрачно применять политики HTTP/API/L7. Поддерживаются как режим маршрутизации, так и режим наложения/инкапсуляции, и он может работать поверх других подключаемых модулей CNI.</li><li><a href=https://github.com/cni-genie/CNI-Genie>CNI-Genie</a> позволяет Kubernetes легко подключаться к выбору плагинов CNI, таких как Calico, Canal, Flannel, Romana или Weave.</li><li><a href=https://www.juniper.net/us/en/products-services/sdn/contrail/contrail-networking/>Contrail</a>, основан на <a href=https://tungsten.io>Tungsten Fabric</a>, представляет собой платформу для виртуализации мультиоблачных сетей с открытым исходным кодом и управления политиками. Contrail и Tungsten Fabric интегрированы с системами оркестрации, такими как Kubernetes, OpenShift, OpenStack и Mesos, и обеспечивают режимы изоляции для виртуальных машин, контейнеров/подов и рабочих нагрузок без операционной системы.</li><li><a href=https://github.com/flannel-io/flannel#deploying-flannel-manually>Flannel</a> - это поставщик оверлейной сети, который можно использовать с Kubernetes.</li><li><a href=https://github.com/ZTE/Knitter/>Knitter</a> - это плагин для поддержки нескольких сетевых интерфейсов Kubernetes подов.</li><li><a href=https://github.com/k8snetworkplumbingwg/multus-cni>Multus</a> - это плагин Multi для работы с несколькими сетями в Kubernetes, который поддерживает большинство самых популярных <a href=https://github.com/containernetworking/cni>CNI</a> (например: Calico, Cilium, Contiv, Flannel), в дополнение к рабочим нагрузкам основанных на SRIOV, DPDK, OVS-DPDK и VPP в Kubernetes.</li><li><a href=https://github.com/ovn-org/ovn-kubernetes/>OVN-Kubernetes</a> - это сетевой провайдер для Kubernetes основанный на <a href=https://github.com/ovn-org/ovn/>OVN (Open Virtual Network)</a>, реализация виртуальной сети, появившийся в результате проекта Open vSwitch (OVS). OVN-Kubernetes обеспечивает сетевую реализацию на основе наложения для Kubernetes, включая реализацию балансировки нагрузки и сетевой политики на основе OVS.</li><li><a href=https://github.com/opnfv/ovn4nfv-k8s-plugin>OVN4NFV-K8S-Plugin</a> - это подключаемый модуль контроллера CNI на основе OVN для обеспечения облачной цепочки сервисных функций (SFC), несколько наложенных сетей OVN, динамического создания подсети, динамического создания виртуальных сетей, сети поставщика VLAN, сети прямого поставщика и подключаемого к другим Multi Сетевые плагины, идеально подходящие для облачных рабочих нагрузок на периферии в сети с несколькими кластерами.</li><li><a href=https://docs.vmware.com/en/VMware-NSX-T-Data-Center/index.html>NSX-T</a> плагин для контейнера (NCP) обеспечивающий интеграцию между VMware NSX-T и контейнерами оркестраторов, таких как Kubernetes, а так же интеграцию между NSX-T и контейнеров на основе платформы CaaS/PaaS, таких как Pivotal Container Service (PKS) и OpenShift.</li><li><a href=https://github.com/nuagenetworks/nuage-kubernetes/blob/v5.1.1-1/docs/kubernetes-1-installation.rst>Nuage</a> - эта платформа SDN, которая обеспечивает сетевое взаимодействие на основе политик между Kubernetes подами и не Kubernetes окружением, с отображением и мониторингом безопасности.</li><li><a href=https://github.com/romana/romana>Romana</a> - это сетевое решение уровня 3 для сетей подов, которое также поддерживает <a href=/docs/concepts/services-networking/network-policies/>NetworkPolicy API</a>. Подробности установки Kubeadm доступны <a href=https://github.com/romana/romana/tree/master/containerize>здесь</a>.</li><li><a href=https://www.weave.works/docs/net/latest/kubernetes/kube-addon/>Weave Net</a> предоставляет сеть и обеспечивает сетевую политику, будет работать на обеих сторонах сетевого раздела и не требует внешней базы данных.</li></ul><h2 id=обнаружение-служб>Обнаружение служб</h2><ul><li><a href=https://coredns.io>CoreDNS</a> - это гибкий, расширяемый DNS-сервер, который может быть <a href=https://github.com/coredns/deployment/tree/master/kubernetes>установлен</a> в качестве внутрикластерного DNS для подов.</li></ul><h2 id=визуализация-и-контроль>Визуализация и контроль</h2><ul><li><a href=https://github.com/kubernetes/dashboard#kubernetes-dashboard>Dashboard</a> - это веб-интерфейс панели инструментов для Kubernetes.</li><li><a href=https://www.weave.works/documentation/scope-latest-installing/#k8s>Weave Scope</a> - это инструмент для графической визуализации ваших контейнеров, подов, сервисов и т.д. Используйте его вместе с <a href=https://cloud.weave.works/>учетной записью Weave Cloud</a> или разместите пользовательский интерфейс самостоятельно.</li></ul><h2 id=инфраструктура>Инфраструктура</h2><ul><li><a href=https://kubevirt.io/user-guide/#/installation/installation>KubeVirt</a> - это дополнение для запуска виртуальных машин в Kubernetes. Обычно работает на bare-metal кластерах.</li></ul><h2 id=legacy-add-ons>Legacy Add-ons</h2><p>В устаревшем каталоге <a href=https://git.k8s.io/kubernetes/cluster/addons>cluster/addons</a> задокументировано несколько других дополнений.</p><p>Ссылки на те, в хорошем состоянии, должны быть здесь. Пул реквесты приветствуются!</p></div></main></div></div><footer class=d-print-none><div class=footer__links><nav><a class=text-white href=/ru/docs/home/>Главная</a>
<a class=text-white href=/ru/community/>Сообщество</a>
<a class=text-white href=/ru/case-studies/>Примеры использования</a></nav></div><div class=container-fluid><div class=row><div class="col-6 col-sm-2 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="User mailing list" aria-label="User mailing list"><a class=text-white target=_blank href=https://discuss.kubernetes.io><i class="fa fa-envelope"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank href=https://twitter.com/kubernetesio><i class="fab fa-twitter"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Calendar aria-label=Calendar><a class=text-white target=_blank href="https://calendar.google.com/calendar/embed?src=calendar%40kubernetes.io"><i class="fas fa-calendar-alt"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Youtube aria-label=Youtube><a class=text-white target=_blank href=https://youtube.com/kubernetescommunity><i class="fab fa-youtube"></i></a></li></ul></div><div class="col-6 col-sm-2 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank href=https://github.com/kubernetes/kubernetes><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Slack aria-label=Slack><a class=text-white target=_blank href=https://slack.k8s.io><i class="fab fa-slack"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Contribute aria-label=Contribute><a class=text-white target=_blank href=https://git.k8s.io/community/contributors/guide><i class="fas fa-edit"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title="Stack Overflow" aria-label="Stack Overflow"><a class=text-white target=_blank href=https://stackoverflow.com/questions/tagged/kubernetes><i class="fab fa-stack-overflow"></i></a></li></ul></div><div class="col-12 col-sm-8 text-center order-sm-2"><small class=text-white>&copy; 2023 Авторы Kubernetes | Документация распространяется под лицензией <a href=https://git.k8s.io/website/LICENSE class=light-text>CC BY 4.0</a></small><br><small class=text-white>Copyright &copy; 2023 The Linux Foundation &reg;. Все права защищены. The Linux Foundation является зарегистрированной торговой маркой. Список торговых марок The Linux Foundation приведен на странице <a href=https://www.linuxfoundation.org/trademark-usage class=light-text>использования торговых марок</a></small><br><small class=text-white>ICP license: 京ICP备17074266号-3</small></div></div></div></footer></div><script src=/js/jquery-3.6.0.min.js integrity=sha384-vtXRMe3mGCbOeY7l30aIg8H9p3GdeSe4IFlP6G8JMa7o7lXvnz3GFKzPxzJdPfGK crossorigin=anonymous></script>
<script src=/js/popper-1.16.1.min.js intregrity=sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN crossorigin=anonymous></script>
<script src=/js/bootstrap-4.6.1.min.js integrity=sha384-VHvPCCyXqtD5DqJeNxl2dtTyhF78xXNXdkwX1CZeRusQfRKp+tA7hAShOK/B/fQ2 crossorigin=anonymous></script>
<script src=/js/script.js></script>
<script async src=/js/mermaid-8.13.4.min.js integrity=sha384-5hHNvPeMrNH14oM3IcQofDoBhiclNK3g2+hnEinKzQ07C4AliMeVpnvxuiwEGpaO crossorigin=anonymous></script>
<script src=/js/main.min.5c0bf7f21dc4f66485f74efbbeeff28a7e4f8cddaac1bae47043159c922ff3a3.js integrity="sha256-XAv38h3E9mSF9077vu/yin5PjN2qwbrkcEMVnJIv86M=" crossorigin=anonymous></script></body></html>